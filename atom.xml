<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>浅幽丶奈芙莲的个人博客</title>
  
  <subtitle>NephrenCake Blog</subtitle>
  <link href="https://nephrencake.gitee.io/atom.xml" rel="self"/>
  
  <link href="https://nephrencake.gitee.io/"/>
  <updated>2021-11-26T09:24:00.929Z</updated>
  <id>https://nephrencake.gitee.io/</id>
  
  <author>
    <name>NephrenCake</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Python后端部署-Part5</title>
    <link href="https://nephrencake.gitee.io/2021/11/Python%E5%90%8E%E7%AB%AF%E9%83%A8%E7%BD%B2-Part5/"/>
    <id>https://nephrencake.gitee.io/2021/11/Python%E5%90%8E%E7%AB%AF%E9%83%A8%E7%BD%B2-Part5/</id>
    <published>2021-11-22T11:46:38.000Z</published>
    <updated>2021-11-26T09:24:00.929Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Python后端部署-Part5——MySQL数据库容器"><a href="#Python后端部署-Part5——MySQL数据库容器" class="headerlink" title="Python后端部署-Part5——MySQL数据库容器"></a>Python后端部署-Part5——MySQL数据库容器</h1><p>[TOC]</p><h2 id="服务器-Mysql-容器配置"><a href="#服务器-Mysql-容器配置" class="headerlink" title="服务器 Mysql 容器配置"></a>服务器 Mysql 容器配置</h2><blockquote><p>参考：<a href="https://www.cnblogs.com/sablier/p/11605606.html#%E4%B8%80%E3%80%81%E5%AE%89%E8%A3%85docker">https://www.cnblogs.com/sablier/p/11605606.html#%E4%B8%80%E3%80%81%E5%AE%89%E8%A3%85docker</a></p></blockquote><h3 id="创建-MySQL-的-Docker-容器"><a href="#创建-MySQL-的-Docker-容器" class="headerlink" title="创建 MySQL 的 Docker 容器"></a>创建 MySQL 的 Docker 容器</h3><ol><li><p>拉取官方镜像（暂时选择5.7）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker pull mysql:5.7   <span class="comment"># 拉取 mysql 5.7</span></span><br></pre></td></tr></table></figure></li><li><p>检查是否拉取成功</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker images</span><br></pre></td></tr></table></figure></li><li><p>创建容器，暂时不建立目录映射</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -p 9050:3306 --name WebService_mysql -e MYSQL_ROOT_PASSWORD=password1 -d mysql:5.7</span><br></pre></td></tr></table></figure><ul><li>–name：容器名，此处命名为 <code>mysql</code></li><li>-e：配置 mysql 的 root 用户的登陆密码</li><li>-p：映射主机9050端口到容器的3306端口</li><li>-d：后台运行容器，保证在退出终端后容器继续运行</li></ul></li><li><p>如果要建立目录映射</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -p 9050:3306 --name WebService_mysql \</span><br><span class="line">    -v /usr/<span class="built_in">local</span>/docker/mysql/conf:/etc/mysql \</span><br><span class="line">    -v /usr/<span class="built_in">local</span>/docker/mysql/logs:/var/<span class="built_in">log</span>/mysql \</span><br><span class="line">    -v /usr/<span class="built_in">local</span>/docker/mysql/data:/var/lib/mysql \</span><br><span class="line">    -e MYSQL_ROOT_PASSWORD=password1 \</span><br><span class="line">    -d mysql:5.7</span><br></pre></td></tr></table></figure><ul><li>-v：主机和容器的目录映射关系，”:”前为主机目录，之后为容器目录</li></ul></li><li><p>检查容器是否正确运行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker ps</span><br></pre></td></tr></table></figure><h3 id="连接-MySql"><a href="#连接-MySql" class="headerlink" title="连接 MySql"></a>连接 MySql</h3></li><li><p>需要进入 docker 本地客户端设置远程访问账号（否则只能在容器内连接数据库）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker <span class="built_in">exec</span> -it mysql bash</span><br><span class="line">$ mysql -uroot -ppassword1</span><br><span class="line">mysql&gt; grant all privileges on *.* to root@<span class="string">&#x27;%&#x27;</span> identified by <span class="string">&quot;password2&quot;</span>;</span><br></pre></td></tr></table></figure></li><li><p>使用远程连接软件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">host: 127.0.0.1</span><br><span class="line">port: 9050</span><br><span class="line">user: root</span><br><span class="line">password: password2</span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    
    <summary type="html">MySQL数据库容器</summary>
    
    
    
    <category term="Python后端部署" scheme="https://nephrencake.gitee.io/categories/Python%E5%90%8E%E7%AB%AF%E9%83%A8%E7%BD%B2/"/>
    
    
  </entry>
  
  <entry>
    <title>Python后端部署-Part4</title>
    <link href="https://nephrencake.gitee.io/2021/11/Python%E5%90%8E%E7%AB%AF%E9%83%A8%E7%BD%B2-Part4/"/>
    <id>https://nephrencake.gitee.io/2021/11/Python%E5%90%8E%E7%AB%AF%E9%83%A8%E7%BD%B2-Part4/</id>
    <published>2021-11-22T11:46:34.000Z</published>
    <updated>2021-11-26T09:24:10.549Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Python后端部署-Part4——uWSGI与Nginx部署"><a href="#Python后端部署-Part4——uWSGI与Nginx部署" class="headerlink" title="Python后端部署-Part4——uWSGI与Nginx部署"></a>Python后端部署-Part4——uWSGI与Nginx部署</h1><p>[TOC]</p><h2 id="uWSGI"><a href="#uWSGI" class="headerlink" title="uWSGI"></a>uWSGI</h2><h3 id="WSGI-与-uWSGI"><a href="#WSGI-与-uWSGI" class="headerlink" title="WSGI 与 uWSGI"></a>WSGI 与 uWSGI</h3><ul><li>WSGI：<ul><li>WSGI（Web Server Gateway Interface 或者 Python Web Server Gateway Interface），是为 Python 语言定义的 Web 服务器和 Web 应用或框架之间的一种简单而通用的接口。</li><li>WSGI，是网关（Gateway）。网关的作用就是在协议之间进行转换。</li><li>很多框架都自带了 WSGI server，如 Flask、Django 等。但性能都不好，自带的 WebServer 更多的是测试用途，发布时则使用生产环境的 WSGI server。</li></ul></li><li>uWSGI：<ul><li>是一个Web服务器，实现了 WSGI、uwsgi、http 等协议。<ul><li>uwsgi 协议是 uWSGI 服务器自有的协议，用于定义传输信息的类型。</li><li>每一个 uwsgi packet 前 4byte 为传输信息类型描述，uwsgi 与 WSGI 相比是两样东西。</li></ul></li><li>Nginx 中 HttpUwsgiModule 的作用是与 uWSGI 服务器进行交换。</li></ul></li><li>WSGI / uwsgi / uWSGI 区分：<ul><li>WSGI 是一种通信协议。</li><li>uwsgi 同 WSGI 一样是一种通信协议。</li><li>uWSGI 是实现了 uwsgi 和 WSGI 两种协议的 Web 服务器。</li></ul></li><li>为什么有了 uWSGI 为什么还需要 nginx？<ul><li>因为 nginx 具备优秀的静态内容处理能力，然后将动态内容转发给 uWSGI 服务器，这样可以达到很好的客户端响应。 </li></ul></li></ul><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pip install uwsgi<span class="comment"># 安装</span></span><br><span class="line">uwsgi --version    <span class="comment"># 查看 uwsgi 版本</span></span><br></pre></td></tr></table></figure><h3 id="自定义配置文件（常用）"><a href="#自定义配置文件（常用）" class="headerlink" title="自定义配置文件（常用）"></a>自定义配置文件（常用）</h3><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[uwsgi]</span></span><br><span class="line"><span class="comment"># 项目所在的根目录</span></span><br><span class="line"><span class="attr">chdir</span> = /data/WebService/backend</span><br><span class="line"><span class="comment"># 指定项目的application,启动程序文件</span></span><br><span class="line"><span class="comment"># wsgi-file = WebService/wsgi.py</span></span><br><span class="line"><span class="attr">module</span> = WebService.wsgi</span><br><span class="line"><span class="comment"># 指定sock的文件路径，这个sock文件会在nginx的uwsgi_pass配置，用来nginx与uwsgi通信       </span></span><br><span class="line"><span class="comment"># 支持 ip+port 模式以及 socket file 模式</span></span><br><span class="line"><span class="comment"># socket = %(chdir)/uwsgi_conf/uwsgi.sock</span></span><br><span class="line"><span class="attr">socket</span> = <span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">8000</span></span><br><span class="line"><span class="comment"># 指定IP端口，web访问入口</span></span><br><span class="line"><span class="attr">http</span> = <span class="number">0.0</span>.<span class="number">0.0</span>:<span class="number">8000</span></span><br><span class="line"><span class="comment"># 进程个数、线程数</span></span><br><span class="line"><span class="attr">processes</span> = <span class="number">2</span></span><br><span class="line"><span class="attr">threads</span> = <span class="number">4</span></span><br><span class="line"><span class="comment"># 每个进程worker数</span></span><br><span class="line"><span class="attr">workers</span> = <span class="number">5</span></span><br><span class="line"><span class="comment"># uwsgi的进程名称前缀</span></span><br><span class="line"><span class="attr">procname-prefix-spaced</span> = WebService</span><br><span class="line"><span class="comment"># py文件修改，自动加载</span></span><br><span class="line"><span class="attr">py-autoreload</span> = <span class="number">1</span></span><br><span class="line"><span class="comment"># 指定多个静态文件：static目录和media目录,也可以不用指定该静态文件，在nginx中配置静态文件目录</span></span><br><span class="line"><span class="comment"># uwsgi有自己的配置语法，详细可参考官网，无需写绝对路径，可以用循环、判断等高级配置语法</span></span><br><span class="line"><span class="attr">for</span> = static media</span><br><span class="line"><span class="attr">static-map</span> = /static=%(chdir)/static</span><br><span class="line"><span class="comment"># 启动uwsgi的用户名和用户组</span></span><br><span class="line"><span class="attr">uid</span> = root</span><br><span class="line"><span class="attr">gid</span> = root</span><br><span class="line"><span class="comment"># 启动主进程，来管理其他进程，其它的uwsgi进程都是这个master进程的子进程，如果kill这个master进程，相当于重启所有的uwsgi进程。</span></span><br><span class="line"><span class="attr">master</span> = <span class="literal">true</span></span><br><span class="line"><span class="comment"># 当服务停止的时候自动移除unix Socket和pid文件</span></span><br><span class="line"><span class="attr">vacuum</span> = <span class="literal">true</span></span><br><span class="line"><span class="comment"># 序列化接受的内容，如果可能的话</span></span><br><span class="line"><span class="attr">thunder-lock</span> = <span class="literal">true</span></span><br><span class="line"><span class="comment"># 启用线程</span></span><br><span class="line"><span class="attr">enable-threads</span> = <span class="literal">true</span></span><br><span class="line"><span class="comment"># 设置一个超时，用于中断那些超过服务器请求上限的额外请求</span></span><br><span class="line"><span class="attr">harakiri</span>=<span class="number">30</span></span><br><span class="line"><span class="attr">http-timeout</span> = <span class="number">180</span></span><br><span class="line"><span class="attr">socket-timeout</span> = <span class="number">180</span></span><br><span class="line"><span class="comment"># 设置缓冲</span></span><br><span class="line"><span class="attr">post-buffering</span>=<span class="number">4096</span></span><br><span class="line"><span class="attr">buffer-size</span> = <span class="number">65536</span></span><br><span class="line"><span class="comment"># 设置日志目录</span></span><br><span class="line"><span class="attr">daemonize</span>=%(chdir)/uwsgi_conf/uwsgi.log</span><br><span class="line"><span class="comment"># uWSGI进程号存放</span></span><br><span class="line"><span class="attr">pidfile</span>=%(chdir)/uwsgi_conf/uwsgi.pid</span><br><span class="line"><span class="comment"># monitor uwsgi status  通过该端口可以监控 uwsgi 的负载情况</span></span><br><span class="line"><span class="comment"># 支持 ip+port 模式以及 socket file 模式</span></span><br><span class="line"><span class="comment"># stats=%(chdir)/uwsgi_conf/uwsgi.status </span></span><br><span class="line"><span class="attr">stats</span> = <span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">9001</span></span><br><span class="line"><span class="attr">max-requests</span> = <span class="number">1000</span>   </span><br></pre></td></tr></table></figure><h3 id="指令（常用）"><a href="#指令（常用）" class="headerlink" title="指令（常用）"></a>指令（常用）</h3><ul><li>启动 uWSGI：<code>uwsgi --ini uwsgi.ini</code></li><li>关闭 uWSGI：<code>uwsgi --stop uwsgi.pid</code></li></ul><h3 id="管理静态文件"><a href="#管理静态文件" class="headerlink" title="管理静态文件"></a>管理静态文件</h3><blockquote><p>参考：<a href="https://note.qidong.name/2017/07/uwsgi-serve-django-static/">https://note.qidong.name/2017/07/uwsgi-serve-django-static/</a></p></blockquote><p>现象：</p><ul><li>在 uWSGI 下无法访问静态资源，而在 runserver 下则没有问题。</li></ul><p>原因：</p><ul><li>一个 Django 应用，一般有两类静态文件。 一是<strong>应用内的静态文件</strong>，二是 <strong>Django 本身以及第三方库的静态文件</strong>。<ul><li>应用内的静态文件：在与 settings.py 设定的 STATICFILES_DIRS 目录列表中。</li><li>Django 本身以及第三方库的静态文件：INSTALLED_APPS 中配置的 django.contrib.admin、rest_framework 等。<ul><li>例，admin 的静态文件在：/usr/local/lib/python3.6/site-packages/django/contrib/admin/static/admin/。</li></ul></li></ul></li><li>因此 STATICFILES_DIRS 不仅包含了自己存放的应用内的静态文件，还隐含了 Django 本身以及第三方库的静态文件</li><li>而 uWSGI 根本不知道静态文件在什么位置，只有 Django 自己知道。</li></ul><p>解决：</p><ul><li><p>在 Django 的 <code>setting.py</code> 中配置：</p><ul><li>```python<br>STATIC_ROOT = ‘./collectedstatic’  # /data/WebService/backend/collectedstatic<br>STATIC_URL = ‘/static/‘<br>STATICFILES_DIRS = (  # 不能与 STATIC_ROOT 重名<pre><code>os.path.join(BASE_DIR, &#39;static&#39;),</code></pre>)<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 运行 Django 命令：&#96;python3 manage.py collectstatic&#96;</span><br><span class="line"></span><br><span class="line">  - 把所有 STATICFILES_DIRS 目录下的文件，都复制到 STATIC_ROOT 中。 </span><br><span class="line"></span><br><span class="line">- 在配置文件中添加：</span><br><span class="line"></span><br><span class="line">  - &#96;&#96;&#96;ini</span><br><span class="line">    static-map &#x3D; &#x2F;static&#x3D;&#x2F;data&#x2F;WebService&#x2F;backend&#x2F;collectedstatic</span><br></pre></td></tr></table></figure></li><li>通常使用绝对路径，但也支持相对路径。</li></ul></li><li><p>启动 uWSGI ：<code>uwsgi --ini uwsgi.ini</code></p></li></ul><h2 id="Nginx"><a href="#Nginx" class="headerlink" title="Nginx"></a>Nginx</h2><h3 id="安装-1"><a href="#安装-1" class="headerlink" title="安装"></a>安装</h3><ol><li><p>apt</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">   apt-get install nginx</span><br><span class="line"></span><br><span class="line">2. wget</span><br><span class="line"></span><br><span class="line">   ```bash</span><br><span class="line">   wget http://nginx.org/download/nginx-1.5.6.tar.gz</span><br><span class="line">   tar xf nginx-1.5.6.tar.gz</span><br><span class="line">   <span class="built_in">cd</span> nginx-1.5.6</span><br><span class="line">   ./configure --prefix=/usr/<span class="built_in">local</span>/nginx-1.5.6 \</span><br><span class="line">   --with-http_stub_status_module \</span><br><span class="line">   --with-http_gzip_static_module</span><br><span class="line">   make &amp;&amp; make install</span><br></pre></td></tr></table></figure></li><li><p>检查 nginx 是否安装、启动成功</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ /etc/init.d/nginx start</span><br><span class="line">[ ok ] Starting nginx (via systemctl): nginx.service.</span><br><span class="line">$ ps -ef |grep -i nginx</span><br><span class="line">root       6961      1  0 03:56 ?        00:00:00 nginx: master process /usr/sbin/nginx -g daemon on; master_process on;</span><br><span class="line">www-data   6962   6961  0 03:56 ?        00:00:00 nginx: worker process</span><br><span class="line">pala       6985   2090  0 03:57 pts/0    00:00:00 grep --color=auto -i nginx</span><br></pre></td></tr></table></figure></li><li><p>打开浏览器，访问 ip 地址，可以看见 Welcome to nginx!</p></li></ol><h3 id="常用命令（常用）"><a href="#常用命令（常用）" class="headerlink" title="常用命令（常用）"></a>常用命令（常用）</h3><ul><li>启动：<code>/etc/init.d/nginx start</code></li><li>关闭：<code>/etc/init.d/nginx stop</code></li><li>重启：<code>/etc/init.d/nginx restart</code></li></ul><h3 id="自定义配置文件（常用）-1"><a href="#自定义配置文件（常用）-1" class="headerlink" title="自定义配置文件（常用）"></a>自定义配置文件（常用）</h3><ol><li><p>Nginx 的配置目录为 /etc/nginx/conf.d/ 或 /etc/nginx/sites-enabled/</p></li><li><p>创建配置文件：<code>$ vim /etc/nginx/conf.d/xxx.conf</code></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">server&#123;</span><br><span class="line">    <span class="comment"># 需要监听的端口</span></span><br><span class="line">    listen 80;</span><br><span class="line">    <span class="comment"># 如果有域名就是买的域名</span></span><br><span class="line">    server_name 0.0.0.0;</span><br><span class="line">    <span class="comment"># 日志配置</span></span><br><span class="line">    access_log  /var/log/nginx/access.log  main;  </span><br><span class="line">    <span class="comment"># 编码</span></span><br><span class="line">    charset utf-8;</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 启用压缩,这个的作用就是给用户一个网页,比如3M压缩后1M这样传输速度就会提高很多</span></span><br><span class="line">    gzip on;  </span><br><span class="line">    <span class="comment"># 支持压缩的类型</span></span><br><span class="line">    gzip_types text/plain application/x-javascript text/css text/javascript application/x-httpd-php application/json text/json image/jpeg image/gif image/png application/octet-stream;  </span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 错误页面</span></span><br><span class="line">    error_page  404           /404.html;  </span><br><span class="line">    error_page   500 502 503 504  /50x.html;  </span><br><span class="line"></span><br><span class="line">    <span class="comment"># todo 加载静态文件的路径</span></span><br><span class="line">    location /media  &#123;</span><br><span class="line">        alias /data/WebService/backend/media;  # your Django project&#x27;s media files - amend as required</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    location /static &#123;</span><br><span class="line">        alias /data/WebService/backend/static;  # your Django project&#x27;s static files - amend as required</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    location /&#123;</span><br><span class="line">        <span class="comment"># 在nginx里面的文件uwsgi_params</span></span><br><span class="line">        include uwsgi_params;</span><br><span class="line">        <span class="comment"># 跟uwsgi通信的端口</span></span><br><span class="line">        uwsgi_pass 127.0.0.1:8000;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>若还未移动到目录下，则：<code>cp /data/WebService/backend/nginx.conf /etc/nginx/sites-enabled/nginx.conf</code></p></li><li><p>重启 Nginx：<code>$ /etc/init.d/nginx restart</code>  </p></li></ol>]]></content>
    
    
    <summary type="html">uWSGI与Nginx部署</summary>
    
    
    
    <category term="Python后端部署" scheme="https://nephrencake.gitee.io/categories/Python%E5%90%8E%E7%AB%AF%E9%83%A8%E7%BD%B2/"/>
    
    
  </entry>
  
  <entry>
    <title>Python后端部署-Part3</title>
    <link href="https://nephrencake.gitee.io/2021/11/Python%E5%90%8E%E7%AB%AF%E9%83%A8%E7%BD%B2-Part3/"/>
    <id>https://nephrencake.gitee.io/2021/11/Python%E5%90%8E%E7%AB%AF%E9%83%A8%E7%BD%B2-Part3/</id>
    <published>2021-11-22T11:46:29.000Z</published>
    <updated>2021-11-26T09:24:18.274Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Python后端部署-Part3——Supervisor进程管理"><a href="#Python后端部署-Part3——Supervisor进程管理" class="headerlink" title="Python后端部署-Part3——Supervisor进程管理"></a>Python后端部署-Part3——Supervisor进程管理</h1><p>[TOC]</p><h2 id="nohup"><a href="#nohup" class="headerlink" title="nohup"></a>nohup</h2><ul><li><p>用途：不挂断地运行命令。</p></li><li><p>语法：<code>nohup Command [ Arg … ] [　&amp; ]</code></p><ul><li>Command：要执行的命令。</li><li>Arg：一些参数，可以指定输出文件。</li><li>&amp;：让命令在后台执行，终端退出后命令仍旧执行。</li></ul></li><li><p>启动进程：</p><ul><li><pre><code class="bash">nohup python3 /data/WebService/backend/manage.py runserver 0.0.0.0:8000 &gt;&gt;/data/WebService/backend/log/output.log 2&gt;&amp;1 &amp;<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  - 2&gt;&amp;1：将标准错误 2 重定向到标准输出 &amp;1 ，标准输出 &amp;1 再被重定向输入到 runoob.log 文件中。</span><br><span class="line"></span><br><span class="line">    - 0 – stdin（standard input，标准输入）</span><br><span class="line">    - 1 – stdout（standard output，标准输出）</span><br><span class="line">    - 2 – stderr（standard error，标准错误输出）</span><br><span class="line"></span><br><span class="line">- 终止进程：</span><br><span class="line"></span><br><span class="line">  - &#96;&#96;&#96;bash</span><br><span class="line">    ps -aux | grep manage.py</span><br><span class="line">    ps -aux | grep manage.py | grep -v grep | awk &#39;&#123;print $2&#125;&#39;</span><br></pre></td></tr></table></figure></code></pre></li><li><p>参数说明：</p><ul><li>a : 显示所有程序</li><li>u : 以用户为主的格式来显示</li><li>x : 显示所有程序，不区分终端机</li></ul></li><li><pre><code class="bash">kill -9  进程号PID</code></pre></li></ul></li></ul><h2 id="Supervisor"><a href="#Supervisor" class="headerlink" title="Supervisor"></a>Supervisor</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><ul><li>Supervisor 是用 Python 开发的一套通用的进程管理程序，能将一个普通的命令行进程变为后台 daemon，并监控进程状态，异常退出时能自动重启。</li><li>它是通过 fork/exec 的方式把这些被管理的进程当作 supervisor 的子进程来启动，这样只要在 supervisor 的配置文件中，把要管理的进程的可执行文件的路径写进去即可。也实现当子进程挂掉的时候，父进程可以准确获取子进程挂掉的信息的，可以选择是否自己启动和报警。</li><li>Supervisor 还提供了一个功能，可以为 supervisord 或者每个子进程，设置一个非 root 的 user，这个 user 就可以管理它对应的进程。</li></ul><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><ol><li><p>配置好 yum 源后，可以直接安装</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install supervisor</span><br></pre></td></tr></table></figure></li><li><p>Debian/Ubuntu 可通过 apt 安装</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt-get install supervisor</span><br></pre></td></tr></table></figure></li><li><p>pip 安装</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install supervisor</span><br></pre></td></tr></table></figure><h3 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h3></li></ol><h4 id="默认配置文件"><a href="#默认配置文件" class="headerlink" title="默认配置文件"></a>默认配置文件</h4><ul><li>默认配置文件：<code>/etc/supervisor/supervisord.conf</code>（可能会在不同的地方）</li><li>默认配置文件一般不需要改动，直接定义自己的配置文件即可</li></ul><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[unix_http_server]</span></span><br><span class="line"><span class="attr">file</span>=/tmp/supervisor.sock   <span class="comment">;UNIX socket 文件，supervisorctl 会使用</span></span><br><span class="line"><span class="comment">;chmod=0700                 ;socket文件的mode，默认是0700</span></span><br><span class="line"><span class="comment">;chown=nobody:nogroup       ;socket文件的owner，格式：uid:gid</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">;[inet_http_server]         ;HTTP服务器，提供web管理界面</span></span><br><span class="line"><span class="comment">;port=127.0.0.1:9001        ;Web管理后台运行的IP和端口，如果开放到公网，需要注意安全性</span></span><br><span class="line"><span class="comment">;username=user              ;登录管理后台的用户名</span></span><br><span class="line"><span class="comment">;password=123               ;登录管理后台的密码</span></span><br><span class="line"> </span><br><span class="line"><span class="section">[supervisord]</span></span><br><span class="line"><span class="attr">logfile</span>=/tmp/supervisord.log <span class="comment">;日志文件，默认是 $CWD/supervisord.log</span></span><br><span class="line"><span class="attr">logfile_maxbytes</span>=<span class="number">50</span>MB        <span class="comment">;日志文件大小，超出会rotate，默认 50MB，如果设成0，表示不限制大小</span></span><br><span class="line"><span class="attr">logfile_backups</span>=<span class="number">10</span>           <span class="comment">;日志文件保留备份数量默认10，设为0表示不备份</span></span><br><span class="line"><span class="attr">loglevel</span>=info                <span class="comment">;日志级别，默认info，其它: debug,warn,trace</span></span><br><span class="line"><span class="attr">pidfile</span>=/tmp/supervisord.pid <span class="comment">;pid 文件</span></span><br><span class="line"><span class="attr">nodaemon</span>=<span class="literal">false</span>               <span class="comment">;是否在前台启动，默认是false，即以 daemon 的方式启动</span></span><br><span class="line"><span class="attr">minfds</span>=<span class="number">1024</span>                  <span class="comment">;可以打开的文件描述符的最小值，默认 1024</span></span><br><span class="line"><span class="attr">minprocs</span>=<span class="number">200</span>                 <span class="comment">;可以打开的进程数的最小值，默认 200</span></span><br><span class="line"> </span><br><span class="line"><span class="section">[supervisorctl]</span></span><br><span class="line"><span class="attr">serverurl</span>=unix:///tmp/supervisor.sock <span class="comment">;通过UNIX socket连接supervisord，路径与unix_http_server部分的file一致</span></span><br><span class="line"><span class="comment">;serverurl=http://127.0.0.1:9001 ; 通过HTTP的方式连接supervisord</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">; [program:xx]是被管理的进程配置参数，xx是进程的名称</span></span><br><span class="line"><span class="section">[program:xx]</span></span><br><span class="line"><span class="attr">command</span>=/opt/apache-tomcat-<span class="number">8.0</span>.<span class="number">35</span>/bin/catalina.sh run  <span class="comment">; 程序启动命令</span></span><br><span class="line"><span class="attr">autostart</span>=<span class="literal">true</span>       <span class="comment">; 在supervisord启动的时候也自动启动</span></span><br><span class="line"><span class="attr">startsecs</span>=<span class="number">10</span>         <span class="comment">; 启动10秒后没有异常退出，就表示进程正常启动了，默认为1秒</span></span><br><span class="line"><span class="attr">autorestart</span>=<span class="literal">true</span>     <span class="comment">; 程序退出后自动重启,可选值：[unexpected,true,false]，默认为unexpected，表示进程意外杀死后才重启</span></span><br><span class="line"><span class="attr">startretries</span>=<span class="number">3</span>       <span class="comment">; 启动失败自动重试次数，默认是3</span></span><br><span class="line"><span class="attr">user</span>=tomcat          <span class="comment">; 用哪个用户启动进程，默认是root</span></span><br><span class="line"><span class="attr">priority</span>=<span class="number">999</span>         <span class="comment">; 进程启动优先级，默认999，值小的优先启动</span></span><br><span class="line"><span class="attr">redirect_stderr</span>=<span class="literal">true</span> <span class="comment">; 把stderr重定向到stdout，默认false</span></span><br><span class="line"><span class="attr">stdout_logfile_maxbytes</span>=<span class="number">20</span>MB  <span class="comment">; stdout 日志文件大小，默认50MB</span></span><br><span class="line"><span class="attr">stdout_logfile_backups</span> = <span class="number">20</span>   <span class="comment">; stdout 日志文件备份数，默认是10</span></span><br><span class="line"><span class="comment">; stdout 日志文件，需要注意当指定目录不存在时无法正常启动，所以需要手动创建目录（supervisord 会自动创建日志文件）</span></span><br><span class="line"><span class="attr">stdout_logfile</span>=/opt/apache-tomcat-<span class="number">8.0</span>.<span class="number">35</span>/logs/catalina.out</span><br><span class="line"><span class="attr">stopasgroup</span>=<span class="literal">false</span>     <span class="comment">;默认为false,进程被杀死时，是否向这个进程组发送stop信号，包括子进程</span></span><br><span class="line"><span class="attr">killasgroup</span>=<span class="literal">false</span>     <span class="comment">;默认为false，向进程组发送kill信号，包括子进程</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">;包含其它配置文件</span></span><br><span class="line"><span class="section">[include]</span></span><br><span class="line"><span class="attr">files</span> = relative/directory/*.ini    <span class="comment">;可以指定一个或多个以.ini结束的配置文件</span></span><br></pre></td></tr></table></figure><h4 id="自定义子进程配置文件（常用）"><a href="#自定义子进程配置文件（常用）" class="headerlink" title="自定义子进程配置文件（常用）"></a>自定义子进程配置文件（常用）</h4><ul><li>自定义的子进程配置文件路径：<code>/etc/supervisor/conf.d/</code></li></ul><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 项目名</span></span><br><span class="line"><span class="section">[program:WebService]</span></span><br><span class="line"><span class="comment"># 脚本目录</span></span><br><span class="line"><span class="attr">directory</span>=/data/WebService/backend</span><br><span class="line"><span class="comment"># 脚本执行命令</span></span><br><span class="line"><span class="attr">command</span>=python3 /data/WebService/backend/manage.py runserver <span class="number">0.0</span>.<span class="number">0.0</span>:<span class="number">8000</span></span><br><span class="line"><span class="comment">; command=uwsgi --ini /data/WebService/backend/start.ini</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#supervisor启动的时候是否随着同时启动，默认True</span></span><br><span class="line"><span class="attr">autostart</span>=<span class="literal">true</span></span><br><span class="line"><span class="comment"># 当程序exit的时候，这个program不会自动重启,默认unexpected，设置子进程挂掉后自动重启的情况，</span></span><br><span class="line"><span class="comment"># 有三个选项，false,unexpected和true。</span></span><br><span class="line"><span class="comment"># 如果为false的时候，无论什么情况下，都不会被重新启动，</span></span><br><span class="line"><span class="comment"># 如果为unexpected，只有当进程的退出码不在下面的exitcodes里面定义的</span></span><br><span class="line"><span class="attr">autorestart</span>=unexpected</span><br><span class="line"><span class="comment"># 这个选项是子进程启动多少秒之后，此时状态如果是running，则我们认为启动成功了。默认值为1</span></span><br><span class="line"><span class="attr">startsecs</span>=<span class="number">1</span></span><br><span class="line"><span class="comment"># 脚本运行的用户身份</span></span><br><span class="line"><span class="attr">user</span> = test</span><br><span class="line"><span class="comment"># 日志输出</span></span><br><span class="line"><span class="attr">stderr_logfile</span>=/data/WebService/backend/log/web_err.log</span><br><span class="line"><span class="attr">stdout_logfile</span>=/data/WebService/backend/log/web_out.log</span><br><span class="line"><span class="comment"># 把stderr重定向到stdout，默认 false</span></span><br><span class="line"><span class="attr">redirect_stderr</span> = <span class="literal">true</span></span><br><span class="line"><span class="comment"># stdout日志文件大小，默认 50MB</span></span><br><span class="line"><span class="attr">stdout_logfile_maxbytes</span> = <span class="number">50</span>MB</span><br><span class="line"><span class="comment"># stdout日志文件备份数</span></span><br><span class="line"><span class="attr">stdout_logfile_backups</span> = <span class="number">20</span></span><br></pre></td></tr></table></figure><blockquote><p>注意：supervisor 不能监控后台进程，因此 command 不能为后台运行命令</p></blockquote><h3 id="启动服务"><a href="#启动服务" class="headerlink" title="启动服务"></a>启动服务</h3><h4 id="supervisord-直接启动"><a href="#supervisord-直接启动" class="headerlink" title="supervisord 直接启动"></a>supervisord 直接启动</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">supervisord -c /etc/supervisord.conf </span><br></pre></td></tr></table></figure><h4 id="systemctl-命令启动"><a href="#systemctl-命令启动" class="headerlink" title="systemctl 命令启动"></a>systemctl 命令启动</h4><ul><li>编辑配置文件</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /usr/lib/systemd/system/supervisord.service</span><br></pre></td></tr></table></figure><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[Unit]</span></span><br><span class="line"><span class="attr">Description</span>=Supervisor daemon</span><br><span class="line"></span><br><span class="line"><span class="section">[Service]</span></span><br><span class="line"><span class="attr">Type</span>=forking</span><br><span class="line"><span class="attr">PIDFile</span>=/home/supervisor/supervisord.pid</span><br><span class="line"><span class="attr">ExecStart</span>=/usr/local/python3/bin/supervisord -c /etc/supervisord.conf</span><br><span class="line"><span class="attr">ExecStop</span>=/usr/local/python3/bin/supervisorctl shutdown</span><br><span class="line"><span class="attr">ExecReload</span>=/usr/local/python3/bin/supervisorctl reload</span><br><span class="line"><span class="attr">KillMode</span>=process</span><br><span class="line"><span class="attr">Restart</span>=<span class="literal">on</span>-failure</span><br><span class="line"><span class="attr">RestartSec</span>=<span class="number">42</span>s</span><br><span class="line"></span><br><span class="line"><span class="section">[Install]</span></span><br><span class="line"><span class="attr">WantedBy</span>=multi-user.target</span><br></pre></td></tr></table></figure><ul><li>常用命令</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">systemctl stop supervisord</span><br><span class="line">systemctl start supervisord</span><br><span class="line">systemctl status supervisord</span><br><span class="line">systemctl reload supervisord</span><br><span class="line">systemctl restart supervisord</span><br></pre></td></tr></table></figure><h3 id="常用命令（常用）"><a href="#常用命令（常用）" class="headerlink" title="常用命令（常用）"></a>常用命令（常用）</h3><ol><li><p><code>supervisorctl status all</code>：查看所有进程的状态</p></li><li><p><code>supervisorctl stop [program]</code>：停止 program</p><ul><li>program 换成 all 可以管理配置中的所有进程</li></ul></li><li><p><code>supervisorctl start [program]</code>：启动 program</p></li><li><p><code>supervisorctl restart [program]</code>：重启 program</p></li><li><p><code>supervisorctl update</code>：配置文件修改后可以使用该命令加载新的配置</p><ul><li><pre><code class="bash">$ cp /data/WebService/backend/supervisor.conf /etc/supervisor/conf.d/supervisor.conf$ supervisorctl updateWebService: added process group  # 其实这个时候已经开始运行后台了<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">6. &#96;supervisorctl reload&#96;：重新启动 supervisor</span><br><span class="line"></span><br><span class="line">   - &#96;&#96;&#96;bash</span><br><span class="line">     $ supervisorctl reload</span><br><span class="line">     Restarted supervisord</span><br></pre></td></tr></table></figure>### 常见问题</code></pre></li></ul></li><li><p>unix:///var/run/supervisor/supervisor.sock no such file</p><ul><li>没有开启服务。<code>supervisord -c /etc/supervisord.conf</code> </li></ul></li><li><p>启动了多个 supervisord 服务，导致无法正常关闭服务</p><ul><li>使用 <code>ps -fe | grep supervisord</code> 查看所有启动过的 supervisord 服务，kill 相关的进程 <code>kill -9 进程号</code>。</li></ul></li><li><p>启动 uwsgi 时要注释 uwsgi 里的如下配置，否则 supervisorctl 启动时会报错</p><ul><li><pre><code class="ini">; daemonize = /home/apps/logManage/logs/uwsgi.log; pidfile = /home/apps/logManage/conf/uwsgi.pid; 可以增加 logto配置logto = /home/apps/logManage/logs/uwsgi.log  </code></pre></li></ul></li><li><p>bind(): Address already in use [core/socket.c line 769]</p></li></ol>]]></content>
    
    
    <summary type="html">Supervisor进程管理</summary>
    
    
    
    <category term="Python后端部署" scheme="https://nephrencake.gitee.io/categories/Python%E5%90%8E%E7%AB%AF%E9%83%A8%E7%BD%B2/"/>
    
    
  </entry>
  
  <entry>
    <title>Python后端部署-Part2</title>
    <link href="https://nephrencake.gitee.io/2021/11/Python%E5%90%8E%E7%AB%AF%E9%83%A8%E7%BD%B2-Part2/"/>
    <id>https://nephrencake.gitee.io/2021/11/Python%E5%90%8E%E7%AB%AF%E9%83%A8%E7%BD%B2-Part2/</id>
    <published>2021-11-22T11:46:24.000Z</published>
    <updated>2021-11-26T09:24:25.664Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Python后端部署-Part2——Django登录验证"><a href="#Python后端部署-Part2——Django登录验证" class="headerlink" title="Python后端部署-Part2——Django登录验证"></a>Python后端部署-Part2——Django登录验证</h1><p>[TOC]</p><h2 id="登录验证的实现思路"><a href="#登录验证的实现思路" class="headerlink" title="登录验证的实现思路"></a>登录验证的实现思路</h2><blockquote><p>参考：</p><ul><li><a href="https://blog.csdn.net/weixin_41861301/article/details/119519785">https://blog.csdn.net/weixin_41861301/article/details/119519785</a></li><li><a href="https://www.jianshu.com/p/902b18a6bd78">https://www.jianshu.com/p/902b18a6bd78</a></li></ul></blockquote><ul><li>采用 token 认证方式，使用 rest_framework_simplejwt 库配置权限认证。</li><li>Simple JWT 为 Django REST Framework 框架提供了一个 JSON Web 令牌认证后端。</li><li>注意：使用 rest_framework_simplejwt 进行身份认证时并不需要去对数据库进行查询校验，所以并不会将 token 保存在数据库中。</li></ul><h2 id="安装使用-rest-framework"><a href="#安装使用-rest-framework" class="headerlink" title="安装使用 rest_framework"></a>安装使用 rest_framework</h2><ol><li><p>安装</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install rest_framework</span><br></pre></td></tr></table></figure></li><li><p>添加 <code>rest_framework</code> 到 <code>INSTALLED_APPS</code> 设置中</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -&gt; backend/WebService/settings.py</span></span><br><span class="line"></span><br><span class="line">INSTALLED_APPS = [</span><br><span class="line">    ...</span><br><span class="line">    <span class="string">&#x27;rest_framework&#x27;</span>,  <span class="comment"># DRF</span></span><br><span class="line">]</span><br></pre></td></tr></table></figure></li><li><p>若使用 DRF 的可浏览 API，则修改路由 <code>urls.py</code>（在生产环境中是不需要的）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -&gt; backend/WebService/urls.py</span></span><br><span class="line"></span><br><span class="line">urlpatterns = [</span><br><span class="line">    ...</span><br><span class="line">    path(<span class="string">&#x27;api-auth/&#x27;</span>, include(<span class="string">&#x27;rest_framework.urls&#x27;</span>)),</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h2 id="安装使用-rest-framework-simplejwt"><a href="#安装使用-rest-framework-simplejwt" class="headerlink" title="安装使用 rest_framework_simplejwt"></a>安装使用 rest_framework_simplejwt</h2></li><li><p>安装</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install rest_framework_simplejwt</span><br></pre></td></tr></table></figure></li><li><p>添加 <code>rest_framework_simplejwt</code> 到 <code>INSTALLED_APPS</code> 设置中</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -&gt; backend/WebService/settings.py</span></span><br><span class="line"></span><br><span class="line">INSTALLED_APPS = [</span><br><span class="line">    ...</span><br><span class="line">    <span class="string">&#x27;rest_framework.authtoken&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;rest_framework_simplejwt&#x27;</span>,  <span class="comment"># jwt</span></span><br><span class="line">]</span><br></pre></td></tr></table></figure></li><li><p>将 Simple JWT 的 JSON Web 令牌认证添加到身份验证类列表中</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -&gt; backend/WebService/settings.py</span></span><br><span class="line"></span><br><span class="line">REST_FRAMEWORK = &#123;</span><br><span class="line">    <span class="comment"># 全局的权限认证，只有通过认证后才赋予用户权限</span></span><br><span class="line">    <span class="string">&#x27;DEFAULT_PERMISSION_CLASSES&#x27;</span>: (</span><br><span class="line">        <span class="string">&#x27;rest_framework.permissions.IsAuthenticated&#x27;</span>,</span><br><span class="line">    ),</span><br><span class="line">    <span class="comment"># 身份验证类列表，可以设定多个身份验证</span></span><br><span class="line">    <span class="string">&#x27;DEFAULT_AUTHENTICATION_CLASSES&#x27;</span>: (</span><br><span class="line">        <span class="string">&#x27;rest_framework_simplejwt.authentication.JWTAuthentication&#x27;</span>,</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>配置 JWT 相关参数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -&gt; backend/WebService/settings.py</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> timedelta</span><br><span class="line"></span><br><span class="line">SIMPLE_JWT = &#123;</span><br><span class="line">    <span class="string">&#x27;ACCESS_TOKEN_LIFETIME&#x27;</span>: timedelta(minutes=<span class="number">1</span>),  <span class="comment"># token 的过期时间</span></span><br><span class="line">    <span class="string">&#x27;REFRESH_TOKEN_LIFETIME&#x27;</span>: timedelta(days=<span class="number">15</span>),  <span class="comment"># 刷新 token 的过期时间</span></span><br><span class="line">    <span class="comment"># &#x27;AUTH_HEADER_TYPES&#x27;: (&#x27;Bearer&#x27;, &#x27;JWT&#x27;),  # token 的请求头类型</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在任意的路由配置中添加 Simple JWT 提供的视图（这里将登录验证模块集成到 login 应用下）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -&gt; backend/login/urls.py</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> django.urls <span class="keyword">import</span> path</span><br><span class="line"><span class="keyword">from</span> rest_framework_simplejwt.views <span class="keyword">import</span> TokenObtainPairView, TokenRefreshView, TokenVerifyView</span><br><span class="line"></span><br><span class="line">urlpatterns = [</span><br><span class="line">    path(<span class="string">&#x27;token/&#x27;</span>, TokenObtainPairView.as_view(), name=<span class="string">&#x27;token_obtain_pair&#x27;</span>),  <span class="comment"># POST 登录接口</span></span><br><span class="line">    path(<span class="string">&#x27;token/refresh/&#x27;</span>, TokenRefreshView.as_view(), name=<span class="string">&#x27;token_refresh&#x27;</span>),  <span class="comment"># POST 刷新token接口</span></span><br><span class="line">    path(<span class="string">&#x27;token/verify/&#x27;</span>, TokenVerifyView.as_view(), name=<span class="string">&#x27;token_verify&#x27;</span>),  <span class="comment"># POST 验证token接口 用于vue前端写路由守卫</span></span><br><span class="line">...</span><br><span class="line">]</span><br></pre></td></tr></table></figure></li><li><p>如果自定义用户表</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -&gt; backend/WebService/settings.py</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># AUTH_USER_MODEL 配置默认的校验用户表</span></span><br><span class="line">AUTH_USER_MODEL = <span class="string">&#x27;login.UserInfo&#x27;</span> </span><br></pre></td></tr></table></figure><h2 id="安装使用-django-simple-captcha"><a href="#安装使用-django-simple-captcha" class="headerlink" title="安装使用 django-simple-captcha"></a>安装使用 django-simple-captcha</h2></li><li><p>安装</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">   pip install django-simple-captcha</span><br><span class="line"></span><br><span class="line">2. 添加 `captcha` 到 `INSTALLED_APPS` 中</span><br><span class="line"></span><br><span class="line">   ```python</span><br><span class="line">   <span class="comment"># -&gt; backend/WebService/settings.py</span></span><br><span class="line">   </span><br><span class="line">   INSTALLED_APPS = [</span><br><span class="line">       ...</span><br><span class="line">       <span class="string">&#x27;captcha&#x27;</span>,  <span class="comment"># 生成验证码</span></span><br><span class="line">   ]</span><br></pre></td></tr></table></figure></li><li><p>需要更新数据库</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">python manage.py makemigrations</span><br><span class="line">python manage.py migrate</span><br></pre></td></tr></table></figure><h2 id="无验证码的登录验证"><a href="#无验证码的登录验证" class="headerlink" title="无验证码的登录验证"></a>无验证码的登录验证</h2></li><li><p>其实配置完 simplejwt 时，即可直接使用登录验证。</p><ul><li><p>创建超级用户，命令行输入：<code>python3 manage.py createsuperuser</code></p></li><li><p>使用 post 请求获取 token 令牌</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">headers：Content-Type:application/json</span><br><span class="line">body：&#123;&quot;username&quot;: &quot;admin&quot;, &quot;password&quot;: &quot;admin&quot;&#125;</span><br></pre></td></tr></table></figure></li><li><p>携带 token 令牌请求访问后端</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">body: &#123;&quot;token&quot;: &quot;token&quot;&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>之后编写的其他视图函数，都要继承 <code>from rest_framework.views import APIView </code>，否则将无法进行身份验证。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -&gt; backend/login/views.py</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> rest_framework.views <span class="keyword">import</span> APIView</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">test</span>(<span class="params">APIView</span>):</span>  <span class="comment"># 使用 token 之后，应当继承 APIView 类</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span>(<span class="params">self, request</span>):</span></span><br><span class="line">        <span class="keyword">return</span> JsonResponse(&#123;<span class="string">&quot;msg&quot;</span>: <span class="string">&quot;ok&quot;</span>&#125;, json_dumps_params=&#123;<span class="string">&quot;ensure_ascii&quot;</span>: <span class="literal">False</span>&#125;)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">test_no_login</span>(<span class="params">APIView</span>):</span>  <span class="comment"># 不需要进行登录验证的逻辑则添加 permission_classes = []</span></span><br><span class="line">    permission_classes = []</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span>(<span class="params">self, request</span>):</span></span><br><span class="line">        <span class="keyword">return</span> JsonResponse(&#123;<span class="string">&quot;msg&quot;</span>: <span class="string">&quot;ok&quot;</span>&#125;, json_dumps_params=&#123;<span class="string">&quot;ensure_ascii&quot;</span>: <span class="literal">False</span>&#125;)</span><br></pre></td></tr></table></figure><h2 id="带验证码的登录验证"><a href="#带验证码的登录验证" class="headerlink" title="带验证码的登录验证"></a>带验证码的登录验证</h2></li></ol><h3 id="构造返回验证码的视图"><a href="#构造返回验证码的视图" class="headerlink" title="构造返回验证码的视图"></a>构造返回验证码的视图</h3><ol><li><p>返回验证码的视图接口</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -&gt; backend/login/views.py</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">from</span> django.http <span class="keyword">import</span> HttpResponse</span><br><span class="line"><span class="keyword">from</span> captcha.views <span class="keyword">import</span> CaptchaStore, captcha_image</span><br><span class="line"><span class="keyword">from</span> django.views <span class="keyword">import</span> View</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CaptchaAPIView</span>(<span class="params">View</span>):</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span>(<span class="params">self, request</span>):</span></span><br><span class="line">        hash_key = CaptchaStore.generate_key()</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="comment"># 获取图片id</span></span><br><span class="line">            id_ = CaptchaStore.objects.<span class="built_in">filter</span>(hashkey=hash_key).first().<span class="built_in">id</span></span><br><span class="line">            image = captcha_image(request, hash_key)</span><br><span class="line">            <span class="comment"># 将图片转换为base64</span></span><br><span class="line">            image_base = <span class="string">&#x27;data:image/png;base64,%s&#x27;</span> % base64.b64encode(image.content).decode(<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">            json_data = json.dumps(&#123;<span class="string">&quot;id&quot;</span>: id_, <span class="string">&quot;image_base&quot;</span>: image_base&#125;)</span><br><span class="line">            <span class="comment"># 批量删除过期验证码</span></span><br><span class="line">            CaptchaStore.remove_expired()</span><br><span class="line">        <span class="keyword">except</span>:</span><br><span class="line">            json_data = <span class="literal">None</span></span><br><span class="line">        <span class="keyword">return</span> HttpResponse(json_data, content_type=<span class="string">&quot;application/json&quot;</span>)</span><br></pre></td></tr></table></figure></li><li><p>添加验证码视图的接口路由</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment"># -&gt; backend/login/urls.py</span></span><br><span class="line">   </span><br><span class="line">   <span class="keyword">from</span> django.urls <span class="keyword">import</span> path</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">from</span> login.views <span class="keyword">import</span> CaptchaAPIView</span><br><span class="line">   </span><br><span class="line">   urlpatterns = [</span><br><span class="line">       ...</span><br><span class="line">       path(<span class="string">&#x27;captcha/&#x27;</span>, CaptchaAPIView.as_view(), name=<span class="string">&#x27;captcha_api&#x27;</span>),  <span class="comment"># GET 返回验证码接口</span></span><br><span class="line">   ]</span><br><span class="line"></span><br><span class="line"><span class="comment">### 重写带验证码的登录视图</span></span><br><span class="line"></span><br><span class="line"><span class="number">1.</span> 构造一个手动返回令牌的方法</span><br><span class="line"></span><br><span class="line">   ```python</span><br><span class="line">   <span class="comment"># -&gt; backend/login/utils/get_token.py</span></span><br><span class="line">   </span><br><span class="line">   <span class="keyword">from</span> rest_framework_simplejwt.tokens <span class="keyword">import</span> RefreshToken</span><br><span class="line">   </span><br><span class="line">   <span class="function"><span class="keyword">def</span> <span class="title">get_tokens_for_user</span>(<span class="params">user</span>):</span></span><br><span class="line">       <span class="comment"># 手动返回令牌</span></span><br><span class="line">       refresh = RefreshToken.for_user(user)</span><br><span class="line">   </span><br><span class="line">       <span class="keyword">return</span> &#123;</span><br><span class="line">           <span class="string">&#x27;refresh&#x27;</span>: <span class="built_in">str</span>(refresh),</span><br><span class="line">           <span class="string">&#x27;access&#x27;</span>: <span class="built_in">str</span>(refresh.access_token),</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure></li><li><p>在扩展 <code>TokenObtainPairView</code> 视图前先扩展该序列化类 <code>TokenObtainPairSerializer</code> </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -&gt; backend/login/serializer.py</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> django.utils <span class="keyword">import</span> timezone</span><br><span class="line"><span class="keyword">from</span> rest_framework <span class="keyword">import</span> serializers</span><br><span class="line"><span class="keyword">from</span> rest_framework_simplejwt.serializers <span class="keyword">import</span> TokenObtainPairSerializer</span><br><span class="line"><span class="keyword">from</span> django.contrib.auth <span class="keyword">import</span> authenticate</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> captcha.fields <span class="keyword">import</span> CaptchaStore</span><br><span class="line"><span class="keyword">from</span> login.utils.get_token <span class="keyword">import</span> get_tokens_for_user</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DmallTokenObtainPairSerializer</span>(<span class="params">TokenObtainPairSerializer</span>):</span></span><br><span class="line">    captcha = serializers.CharField(max_length=<span class="number">4</span>, required=<span class="literal">True</span>,</span><br><span class="line">                                    trim_whitespace=<span class="literal">True</span>, min_length=<span class="number">4</span>,</span><br><span class="line">                                    error_messages=&#123;</span><br><span class="line">                                        <span class="string">&quot;max_length&quot;</span>: <span class="string">&quot;图片验证码仅允许4位&quot;</span>,</span><br><span class="line">                                        <span class="string">&quot;min_length&quot;</span>: <span class="string">&quot;图片验证码仅允许4位&quot;</span>,</span><br><span class="line">                                        <span class="string">&quot;required&quot;</span>: <span class="string">&quot;请输入图片验证码&quot;</span></span><br><span class="line">                                    &#125;, help_text=<span class="string">&quot;图片验证码&quot;</span>)</span><br><span class="line">    imgcode_id = serializers.CharField(required=<span class="literal">True</span>, write_only=<span class="literal">True</span>,</span><br><span class="line">                                       help_text=<span class="string">&quot;图片验证码id&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_token</span>(<span class="params">cls, user</span>):</span></span><br><span class="line">        token = <span class="built_in">super</span>().get_token(user)</span><br><span class="line">        token[<span class="string">&#x27;captcha&#x27;</span>] = user.captcha</span><br><span class="line">        token[<span class="string">&#x27;imgcode_id&#x27;</span>] = user.imgcode_id</span><br><span class="line">        <span class="keyword">return</span> token</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">validate_captcha</span>(<span class="params">self, captcha</span>):</span></span><br><span class="line">        <span class="comment"># 验证码验证</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            captcha = captcha.lower()</span><br><span class="line">        <span class="keyword">except</span>:</span><br><span class="line">            <span class="keyword">raise</span> serializers.ValidationError(<span class="string">&quot;验证码错误&quot;</span>)</span><br><span class="line">        img_code = CaptchaStore.objects.<span class="built_in">filter</span>(</span><br><span class="line">            <span class="built_in">id</span>=<span class="built_in">int</span>(self.initial_data[<span class="string">&#x27;imgcode_id&#x27;</span>])</span><br><span class="line">        ).first()</span><br><span class="line">        <span class="keyword">if</span> img_code <span class="keyword">and</span> timezone.now() &gt; img_code.expiration:</span><br><span class="line">            <span class="keyword">raise</span> serializers.ValidationError(<span class="string">&quot;图片验证码过期&quot;</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">if</span> img_code <span class="keyword">and</span> img_code.response == captcha:</span><br><span class="line">                <span class="keyword">pass</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">raise</span> serializers.ValidationError(<span class="string">&quot;验证码错误&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">validate</span>(<span class="params">self, attrs</span>):</span></span><br><span class="line">        <span class="comment"># 删除验证码</span></span><br><span class="line">        <span class="keyword">del</span> attrs[<span class="string">&#x27;captcha&#x27;</span>]</span><br><span class="line">        <span class="keyword">del</span> attrs[<span class="string">&#x27;imgcode_id&#x27;</span>]</span><br><span class="line">        authenticate_kwargs = &#123;</span><br><span class="line">            <span class="string">&#x27;username&#x27;</span>: attrs[<span class="string">&#x27;username&#x27;</span>],</span><br><span class="line">            <span class="string">&#x27;password&#x27;</span>: attrs[<span class="string">&#x27;password&#x27;</span>],</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment"># 验证当前登录用户</span></span><br><span class="line">        self.user = authenticate(**authenticate_kwargs)</span><br><span class="line">        <span class="keyword">if</span> self.user <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">raise</span> serializers.ValidationError(<span class="string">&#x27;账号或密码不正确&#x27;</span>)</span><br><span class="line">        <span class="comment"># 登录成功返回token信息</span></span><br><span class="line">        token = get_tokens_for_user(self.user)</span><br><span class="line">        <span class="keyword">return</span> token</span><br></pre></td></tr></table></figure></li><li><p>重写 <code>TokenObtainPairView</code> 视图函数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -&gt; backend/login/views.py</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> rest_framework_simplejwt.views <span class="keyword">import</span> TokenObtainPairView</span><br><span class="line"><span class="keyword">from</span> login.serializer <span class="keyword">import</span> DmallTokenObtainPairSerializer</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DmallTokenObtainPairView</span>(<span class="params">TokenObtainPairView</span>):</span></span><br><span class="line">    <span class="comment"># 登录成功返回token</span></span><br><span class="line">    serializer_class = DmallTokenObtainPairSerializer</span><br></pre></td></tr></table></figure></li><li><p>添加登录视图的接口路由</p><pre><code class="python"># -&gt; backend/login/urls.pyfrom django.urls import pathfrom login.views import DmallTokenObtainPairViewurlpatterns = [    ...    path(&#39;captcha/token/&#39;, DmallTokenObtainPairView.as_view(), name=&#39;mytoken&#39;),]</code></pre></li><li><p>测试</p><img src="/2021/11/Python%E5%90%8E%E7%AB%AF%E9%83%A8%E7%BD%B2-Part2/image-20211126124446649.png" alt="image-20211126124446649" style="zoom:150%;"></li></ol>]]></content>
    
    
    <summary type="html">Django登录验证</summary>
    
    
    
    <category term="Python后端部署" scheme="https://nephrencake.gitee.io/categories/Python%E5%90%8E%E7%AB%AF%E9%83%A8%E7%BD%B2/"/>
    
    
  </entry>
  
  <entry>
    <title>Python后端部署-Part1</title>
    <link href="https://nephrencake.gitee.io/2021/11/Python%E5%90%8E%E7%AB%AF%E9%83%A8%E7%BD%B2-Part1/"/>
    <id>https://nephrencake.gitee.io/2021/11/Python%E5%90%8E%E7%AB%AF%E9%83%A8%E7%BD%B2-Part1/</id>
    <published>2021-11-22T11:46:18.000Z</published>
    <updated>2021-11-26T09:24:32.789Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Python后端部署-Part1——Web项目总览"><a href="#Python后端部署-Part1——Web项目总览" class="headerlink" title="Python后端部署-Part1——Web项目总览"></a>Python后端部署-Part1——Web项目总览</h1><p>[TOC]</p><h2 id="快速使用"><a href="#快速使用" class="headerlink" title="快速使用"></a>快速使用</h2><p>施工中……</p><h2 id="手动部署全流程"><a href="#手动部署全流程" class="headerlink" title="手动部署全流程"></a>手动部署全流程</h2><h2 id="服务器-Nginx-uwsgi-Django-配置"><a href="#服务器-Nginx-uwsgi-Django-配置" class="headerlink" title="服务器 Nginx+uwsgi+Django 配置"></a>服务器 Nginx+uwsgi+Django 配置</h2><h3 id="创建项目的-Docker-容器"><a href="#创建项目的-Docker-容器" class="headerlink" title="创建项目的 Docker 容器"></a>创建项目的 Docker 容器</h3><ol><li><p>拉取 ubuntu 镜像</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker pull django/ubuntu:20.04</span><br></pre></td></tr></table></figure></li><li><p>创建容器</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -it --name WebService -p 9045:22 -p 9046:80 -p 9048:8000 -p 9049:8080 -v /data/WebService:/data/WebService -d ubuntu:20.04 /bin/bash</span><br></pre></td></tr></table></figure><ul><li>-p 9045:22 用于 ssh 连接</li><li>-p 9046:80 用于 Nginx 代理</li><li>-p 9048:8000 用于 Django 测试</li><li>-p 9049:8080 用于 Vue 测试</li><li>-v /data/WebService:/data/WebService 将宿主机与容器内的项目根目录进行挂载</li></ul></li><li><p>进入容器（后续操作都在容器中进行）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker <span class="built_in">exec</span> -it WebService bash</span><br></pre></td></tr></table></figure></li><li><p>保持运行并退出容器</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ctrl + p + q</span><br></pre></td></tr></table></figure><h3 id="ssh-连接（可选）"><a href="#ssh-连接（可选）" class="headerlink" title="ssh 连接（可选）"></a>ssh 连接（可选）</h3></li></ol><h4 id="服务端搭建-ssh-服务"><a href="#服务端搭建-ssh-服务" class="headerlink" title="服务端搭建 ssh 服务"></a>服务端搭建 ssh 服务</h4><blockquote><p>参考：<a href="https://www.cnblogs.com/linuxAndMcu/p/10766589.html">https://www.cnblogs.com/linuxAndMcu/p/10766589.html</a></p></blockquote><ol><li><p>安装服务器</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ apt-get update</span><br><span class="line">$ apt-get install openssh-server</span><br></pre></td></tr></table></figure></li><li><p>生成秘钥</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">$ ssh-keygen -t rsa</span><br><span class="line">Generating public/private rsa key pair.</span><br><span class="line">Enter file <span class="keyword">in</span> <span class="built_in">which</span> to save the key (/root/.ssh/id_rsa): <span class="comment"># 这里回车</span></span><br><span class="line">Created directory <span class="string">&#x27;/root/.ssh&#x27;</span>.</span><br><span class="line">Enter passphrase (empty <span class="keyword">for</span> no passphrase): <span class="comment"># 这里回车</span></span><br><span class="line">Enter same passphrase again: <span class="comment"># 这里回车</span></span><br><span class="line">Your identification has been saved <span class="keyword">in</span> /root/.ssh/id_rsa</span><br><span class="line">Your public key has been saved <span class="keyword">in</span> /root/.ssh/id_rsa.pub</span><br><span class="line">The key fingerprint is:</span><br><span class="line">SHA256:7JmFyqQScZ5pTgQPro31HbSRQ0WhOXfaj36OlVW6rTY root@ac5b1c2f2ed8</span><br><span class="line">The key<span class="string">&#x27;s randomart image is:</span></span><br><span class="line"><span class="string">+---[RSA 3072]----+</span></span><br><span class="line"><span class="string">|  o  .+++.       |</span></span><br><span class="line"><span class="string">| . + .o=         |</span></span><br><span class="line"><span class="string">|  + + *.. .     .|</span></span><br><span class="line"><span class="string">| = * + = =     o |</span></span><br><span class="line"><span class="string">|o o B o S o   o  |</span></span><br><span class="line"><span class="string">|   = + o + o o o |</span></span><br><span class="line"><span class="string">|  . o o + . + . .|</span></span><br><span class="line"><span class="string">|   .     . o. E. |</span></span><br><span class="line"><span class="string">|          oo.... |</span></span><br><span class="line"><span class="string">+----[SHA256]-----+</span></span><br></pre></td></tr></table></figure></li><li><p>开放通过密码登录（如果没有开放的话）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ apt-get install vim  <span class="comment"># 如果没有 vim 的话</span></span><br><span class="line">$ vim /etc/ssh/sshd_config  <span class="comment"># 编辑</span></span><br><span class="line"></span><br><span class="line">输入/Permi，回车，找到</span><br><span class="line"><span class="comment">#PermitRootLogin prohibit-password</span></span><br><span class="line">取消注释, 修改成</span><br><span class="line">PermitRootLogin yes</span><br><span class="line"></span><br><span class="line">esc+:wq!退出</span><br></pre></td></tr></table></figure></li><li><p>设置密码</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ passwd</span><br><span class="line">New password: </span><br><span class="line">Retype new password: </span><br><span class="line">passwd: password updated successfully</span><br></pre></td></tr></table></figure></li><li><p>重启 ssh 服务</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ service ssh restart</span><br><span class="line"> * Restarting OpenBSD Secure Shell server sshd</span><br></pre></td></tr></table></figure><h4 id="使用-Pycharm-连接服务器"><a href="#使用-Pycharm-连接服务器" class="headerlink" title="使用 Pycharm 连接服务器"></a>使用 Pycharm 连接服务器</h4></li></ol><ul><li><p>pycharm 中找到远程主机</p><ul><li><img src="/2021/11/Python%E5%90%8E%E7%AB%AF%E9%83%A8%E7%BD%B2-Part1/image-20211113151601673.png" alt="image-20211113151601673"></li></ul></li><li><p>选择 SFTP</p><ul><li><img src="/2021/11/Python%E5%90%8E%E7%AB%AF%E9%83%A8%E7%BD%B2-Part1/image-20211113151849146.png" alt="image-20211113151849146"></li></ul></li><li><p>通信使用 utf-8</p><ul><li><img src="/2021/11/Python%E5%90%8E%E7%AB%AF%E9%83%A8%E7%BD%B2-Part1/image-20211113152019895.png" alt="image-20211113152019895"></li></ul></li><li><p>编辑 SSH 配置。由于 docker 容器的端口映射，这里的 9045 会连到容器的 22 端口。</p><ul><li><img src="/2021/11/Python%E5%90%8E%E7%AB%AF%E9%83%A8%E7%BD%B2-Part1/image-20211113152227627.png" alt="image-20211113152227627"></li></ul></li><li><p>设置映射</p><ul><li><img src="/2021/11/Python%E5%90%8E%E7%AB%AF%E9%83%A8%E7%BD%B2-Part1/image-20211113152505113.png" alt="image-20211113152505113"></li></ul></li><li><p>最终结果</p><ul><li><img src="/2021/11/Python%E5%90%8E%E7%AB%AF%E9%83%A8%E7%BD%B2-Part1/image-20211113152740086.png" alt="image-20211113152740086"></li></ul></li><li><p>同时，你可以通过 <code>ssh -p 9045 root@120.27.135.145</code> 在控制台登录</p><ul><li><img src="/2021/11/Python%E5%90%8E%E7%AB%AF%E9%83%A8%E7%BD%B2-Part1/image-20211113153636630.png" alt="image-20211113153636630"></li></ul></li><li><p>启动服务端的服务建议使用本地控制台连接服务器，后面会有启动命令</p></li></ul><blockquote><p>之后，你有两种方法来部署项目代码</p><ol><li>使用 ssh 连接服务器，在服务器上 git pull（当然，在此之前，你需要把代码 push 到 git 仓库）</li><li>使用 pycharm 直接部署代码（但是同样要记得 push 代码到仓库，否则在服务器上很难察觉版本迭代）</li></ol><p>同时，对于服务器上的文件修改，不需要再使用命令行，可以直接在 IDE 中编辑并上传。</p></blockquote><h3 id="容器内环境配置与测试"><a href="#容器内环境配置与测试" class="headerlink" title="容器内环境配置与测试"></a>容器内环境配置与测试</h3><blockquote><p>参考：</p><ul><li><a href="https://blog.csdn.net/yilovexing/article/details/82969103">https://blog.csdn.net/yilovexing/article/details/82969103</a></li><li><a href="https://blog.csdn.net/weixin_42292991/article/details/95937600">https://blog.csdn.net/weixin_42292991/article/details/95937600</a></li><li><a href="https://hub.docker.com/r/dockerfiles/django-uwsgi-nginx">https://hub.docker.com/r/dockerfiles/django-uwsgi-nginx</a></li><li><a href="https://www.cnblogs.com/Skyda/p/10030121.html">https://www.cnblogs.com/Skyda/p/10030121.html</a></li></ul></blockquote><ol><li><p>更新源，准备必要环境：git、py3、nginx、uwsgi</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">apt-get update &amp;&amp; \</span><br><span class="line">apt-get upgrade -y &amp;&amp; \ </span><br><span class="line">apt-get install -y \</span><br><span class="line">git \</span><br><span class="line">python3 \</span><br><span class="line">python3-dev \</span><br><span class="line">python3-setuptools \</span><br><span class="line">python3-pip \</span><br><span class="line">nginx \</span><br><span class="line">supervisor &amp;&amp; \</span><br><span class="line">pip3 install -U pip setuptools &amp;&amp; \</span><br><span class="line">pip3 install uwsgi &amp;&amp; \</span><br><span class="line">rm -rf /var/lib/apt/lists/*</span><br></pre></td></tr></table></figure></li><li><p>检查 python3</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ python3</span><br><span class="line">Python <span class="number">3.8</span><span class="number">.10</span> (default, Sep <span class="number">28</span> <span class="number">2021</span>, <span class="number">16</span>:<span class="number">10</span>:<span class="number">42</span>) </span><br><span class="line">[GCC <span class="number">9.3</span><span class="number">.0</span>] on linux</span><br><span class="line">Type <span class="string">&quot;help&quot;</span>, <span class="string">&quot;copyright&quot;</span>, <span class="string">&quot;credits&quot;</span> <span class="keyword">or</span> <span class="string">&quot;license&quot;</span> <span class="keyword">for</span> more information.</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span></span><br></pre></td></tr></table></figure></li><li><p>拉取仓库</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /data</span><br><span class="line">git <span class="built_in">clone</span> https://gitee.com/NephrenCake/WebService.git</span><br></pre></td></tr></table></figure><p>之后更新本地仓库</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /data/WebService</span><br><span class="line">git pull</span><br></pre></td></tr></table></figure></li><li><p>安装 pip 依赖</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd /data/WebService</span><br><span class="line">pip3 install -r backend/requirements.txt</span><br></pre></td></tr></table></figure></li><li><p>使用 Django 测试服务器启动服务</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python3 /data/WebService/backend/manage.py runserver <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span>:<span class="number">8000</span></span><br></pre></td></tr></table></figure><ul><li>浏览器打开 <a href="http://120.27.135.145:9048/">http://120.27.135.145:9048/</a></li></ul></li><li><p>使用 uwsgi 服务器启动服务</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">uwsgi --ini /data/WebService/backend/start.ini</span><br></pre></td></tr></table></figure><ul><li>浏览器打开 <a href="http://120.27.135.145:9048/%EF%BC%88%E5%9C%A8%E4%BD%BF%E7%94%A8">http://120.27.135.145:9048/（在使用</a> Django 或 uwsgi 服务器时，需要确保互相不同时使用，否则会有端口占用冲突）</li></ul></li><li><p>使用 Nginx 启动服务</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ cp /data/WebService/backend/nginx.conf /etc/nginx/sites-enabled/nginx.conf</span><br><span class="line">$ /etc/init.d/nginx restart</span><br><span class="line">$ nginx -s reload</span><br></pre></td></tr></table></figure><ul><li>浏览器打开 <a href="http://120.27.135.145:9046/%EF%BC%88%E5%90%8E%E9%9D%A2%E5%AE%9E%E9%99%85%E9%83%A8%E7%BD%B2%E4%BC%9A%E4%BD%BF%E7%94%A8%E8%AF%A5%E5%9C%B0%E5%9D%80%EF%BC%89">http://120.27.135.145:9046/（后面实际部署会使用该地址）</a></li></ul></li><li><p>使用 nohup 后台运行</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">nohup python3 /data/WebService/backend/manage.py runserver <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span>:<span class="number">8000</span> &gt;&gt;/data/WebService/backend/log/output.log <span class="number">2</span>&gt;&amp;<span class="number">1</span> &amp;</span><br><span class="line">ps -aux|grep manage.py| grep -v grep | awk <span class="string">&#x27;&#123;print $2&#125;&#x27;</span></span><br><span class="line">kill -<span class="number">9</span>  <span class="number">2619</span></span><br></pre></td></tr></table></figure></li><li><p>使用 Supervisor 运行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ supervisord -c /etc/supervisord.conf</span><br><span class="line">$ cp /data/WebService/backend/supervisor.conf /etc/supervisor/conf.d/supervisor.conf</span><br><span class="line">$ supervisorctl update</span><br><span class="line">WebService: added process group  <span class="comment"># 其实这个时候已经开始运行后台了</span></span><br><span class="line">$ supervisorctl restart WebService</span><br></pre></td></tr></table></figure><blockquote><p>注意：单独使用 uwsgi 和使用 Nginx+uwsgi 组合，使用的是同一个配置文件，即 start.ini，切换时需要修改对应项。当直接使用 Django 时不需要修改该配置文件。</p><ul><li><img src="/2021/11/Python%E5%90%8E%E7%AB%AF%E9%83%A8%E7%BD%B2-Part1/image-20211113171103506.png" alt="image-20211113171103506"></li></ul></blockquote></li></ol>]]></content>
    
    
    <summary type="html">Web项目总览</summary>
    
    
    
    <category term="Python后端部署" scheme="https://nephrencake.gitee.io/categories/Python%E5%90%8E%E7%AB%AF%E9%83%A8%E7%BD%B2/"/>
    
    
  </entry>
  
  <entry>
    <title>Python后端部署-完结目录</title>
    <link href="https://nephrencake.gitee.io/2021/11/Python%E5%90%8E%E7%AB%AF%E9%83%A8%E7%BD%B2-%E5%AE%8C%E7%BB%93%E7%9B%AE%E5%BD%95/"/>
    <id>https://nephrencake.gitee.io/2021/11/Python%E5%90%8E%E7%AB%AF%E9%83%A8%E7%BD%B2-%E5%AE%8C%E7%BB%93%E7%9B%AE%E5%BD%95/</id>
    <published>2021-11-22T11:20:17.000Z</published>
    <updated>2021-11-26T09:22:57.049Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Python后端部署-完结目录"><a href="#Python后端部署-完结目录" class="headerlink" title="Python后端部署-完结目录"></a>Python后端部署-完结目录</h1><table><thead><tr><th align="center"><a href="/2021/11/Python%E5%90%8E%E7%AB%AF%E9%83%A8%E7%BD%B2-Part1/">Python后端部署-Part1——Web项目总览</a></th></tr></thead><tbody><tr><td align="center"><strong><a href="/2021/11/Python%E5%90%8E%E7%AB%AF%E9%83%A8%E7%BD%B2-Part2/">Python后端部署-Part2——Django登录验证</a></strong></td></tr><tr><td align="center"><strong><a href="/2021/11/Python%E5%90%8E%E7%AB%AF%E9%83%A8%E7%BD%B2-Part3/">Python后端部署-Part3——Supervisor进程管理</a></strong></td></tr><tr><td align="center"><strong><a href="Python%E5%90%8E%E7%AB%AF%E9%83%A8%E7%BD%B2-Part4/">Python后端部署-Part4——uWSGI与Nginx部署</a></strong></td></tr><tr><td align="center"><strong><a href="/2021/11/Python%E5%90%8E%E7%AB%AF%E9%83%A8%E7%BD%B2-Part5/">Python后端部署-Part5——MySQL数据库容器</a></strong></td></tr></tbody></table><p>在本系列中，主要采取以下技术栈：（以后可能会不定期更新）</p><ol><li>容器工具：Docker</li><li>后端框架：Django+DjangoRestfulFramwork</li><li>进程管理：Supervisor</li><li>Web服务器：uWSGI</li><li>反向代理：Nginx</li><li>数据库：MySQL</li></ol>]]></content>
    
    
    <summary type="html">Python后端部署-完结目录</summary>
    
    
    
    <category term="Python后端部署" scheme="https://nephrencake.gitee.io/categories/Python%E5%90%8E%E7%AB%AF%E9%83%A8%E7%BD%B2/"/>
    
    
    <category term="Web" scheme="https://nephrencake.gitee.io/tags/Web/"/>
    
  </entry>
  
  <entry>
    <title>操作系统-完结目录</title>
    <link href="https://nephrencake.gitee.io/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E5%AE%8C%E7%BB%93%E7%9B%AE%E5%BD%95/"/>
    <id>https://nephrencake.gitee.io/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E5%AE%8C%E7%BB%93%E7%9B%AE%E5%BD%95/</id>
    <published>2021-11-01T01:44:19.000Z</published>
    <updated>2021-11-16T08:40:49.523Z</updated>
    
    <content type="html"><![CDATA[<h1 id="操作系统-完结目录"><a href="#操作系统-完结目录" class="headerlink" title="操作系统-完结目录"></a>操作系统-完结目录</h1><p>教程视频传送门：</p><ol><li><a href="https://www.bilibili.com/video/BV1YE411D7nH">王道计算机考研 操作系统</a></li></ol><p>推荐资源：</p><ol><li>王道配套书</li></ol><p>不多说，==做题==！</p><table><thead><tr><th align="center"><a href="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part1/">操作系统-Part1——计算机系统概述</a></th></tr></thead><tbody><tr><td align="center"><strong><a href="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part2/">操作系统-Part2——进程管理</a></strong></td></tr><tr><td align="center"><strong><a href="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part3/">操作系统-Part3——内存管理</a></strong></td></tr><tr><td align="center"><strong><a href="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part4/">操作系统-Part4——文件管理</a></strong></td></tr><tr><td align="center"><strong><a href="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part5/">操作系统-Part5——I/O 管理</a></strong></td></tr></tbody></table>]]></content>
    
    
    <summary type="html">完结目录</summary>
    
    
    
    <category term="操作系统" scheme="https://nephrencake.gitee.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="408" scheme="https://nephrencake.gitee.io/tags/408/"/>
    
  </entry>
  
  <entry>
    <title>操作系统-Part5</title>
    <link href="https://nephrencake.gitee.io/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part5/"/>
    <id>https://nephrencake.gitee.io/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part5/</id>
    <published>2021-11-01T01:44:00.000Z</published>
    <updated>2021-11-16T08:41:16.716Z</updated>
    
    <content type="html"><![CDATA[<h1 id="操作系统-Part5——I-O-管理"><a href="#操作系统-Part5——I-O-管理" class="headerlink" title="操作系统-Part5——I/O 管理"></a>操作系统-Part5——I/O 管理</h1><p>[TOC]</p><h2 id="I-O-管理概述"><a href="#I-O-管理概述" class="headerlink" title="I/O 管理概述"></a>I/O 管理概述</h2><h3 id="I-O-设备的基本概念和分类"><a href="#I-O-设备的基本概念和分类" class="headerlink" title="I/O 设备的基本概念和分类"></a>I/O 设备的基本概念和分类</h3><p><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part5/image-20211115162634513.png" alt="image-20211115162634513"></p><ul><li>UNIX 系统将外部设备抽象为一种特殊的文件，用户可以使用与文件操作相同的方式对外部设备进行操作。<ul><li>Write 操作：向外部设备写出数据</li><li>Read 操作：从外部设备读入数据</li></ul></li><li>I/O 设备的分类<ul><li>按使用特性<ul><li>人机交互类外设</li><li>存储设备</li><li>网络通信设备</li></ul></li><li>按传输速率分类<ul><li>低速设备（鼠标、键盘）</li><li>中速设备（激光打印机）</li><li>高速设备（磁盘）</li></ul></li><li>按信息交换的单位分类<ul><li>块设备（磁盘）<ul><li>传输速率较高，可寻址</li></ul></li><li>字符设备（鼠标、键盘）<ul><li>传输速率较慢，不可寻址</li><li>常采用中断驱动方式</li></ul></li></ul></li></ul></li></ul><h3 id="I-O-控制器"><a href="#I-O-控制器" class="headerlink" title="I/O 控制器"></a>I/O 控制器</h3><p><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part5/image-20211115171623799.png" alt="image-20211115171623799"></p><ul><li>I/O 设备的组成<ul><li>机械部件<ul><li>主要用来执行具体 I/O 操作。</li></ul></li><li>电子部件<ul><li>通常是一块插入主板扩充槽的印刷电路板。</li><li>包括 I/O 控制器（设备控制器）</li></ul></li></ul></li><li>I/O 控制器的功能：<ul><li>接受和识别 CPU 的命令<ul><li>CPU发来的 read/write 命令，I/O 控制器中会有相应的<strong>控制寄存器</strong>来存放命令和参数。</li></ul></li><li>想 CPU 报告设备的状态<ul><li>I/O 控制器中会有相应的状态寄存器，用于记录 I/O 设备的当前状态。</li></ul></li><li>数据交换<ul><li>I/O 控制器中设置相应的数据寄存器。用于暂存输入输出时的数据。</li></ul></li><li>地址识别<ul><li>为了区分设备控制器中的各个寄存器，也需要给各个寄存器设置特定的地址</li></ul></li></ul></li><li>I/O 控制器的组成<ul><li><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part5/image-20211115171448414.png" alt="image-20211115171448414"></li><li>一个 I/O 控制器可能会对应多个设备；</li><li>数据寄存器、控制寄存器、状态寄存器可能有多个（<strong>每个控制/状态寄存器对应一个具体的设备</strong>），且这些寄存器都要有相应的地址，才能方便CPU操作。<ul><li>有的计算机会让这些寄存器占用内存地址的一部分，称为<strong>内存映像 I/O</strong>；另一些计算机则采用 I/O 专用地址，即<strong>寄存器独立编址</strong>。</li></ul></li></ul></li><li>内存映像 I/O v.s. 寄存器独立编址<ul><li><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part5/image-20211115171837978.png" alt="image-20211115171837978"></li></ul></li></ul><h3 id="I-O-控制方式"><a href="#I-O-控制方式" class="headerlink" title="I/O 控制方式"></a>I/O 控制方式</h3><p><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part5/image-20211115201702719.png" alt="image-20211115201702719"></p><ul><li>程序直接控制方式<ul><li>完成一次读/写操作的流程<ul><li><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part5/image-20211115194455982.png" alt="image-20211115194455982" style="zoom:50%;"></li></ul></li><li>CPU 干预的频率<ul><li>很频繁，I/O 操作<strong>开始之前</strong>、<strong>完成之后</strong>需要 CPU 介入，并且在<strong>等待 I/O 完成的过程中</strong> CPU 需要不断地轮询检查。</li></ul></li><li>数据传送的单位<ul><li>每次读/写<strong>一个字</strong></li></ul></li><li>数据的流向<ul><li>读操作（数据输入）：I/O 设备 -&gt; CPU -&gt; 内存</li><li>写操作（数据输出）：内存 -&gt; CPU -&gt; I/O 设备</li><li>每个字的读/写都需要 CPU 的帮助</li></ul></li><li>主要缺点和主要优点<ul><li>优点：实现简单。</li><li>缺点：CPU 和 I/O 设备<strong>只能串行工作</strong>，CPU 需要一直轮询检查，长期处于<strong>忙等</strong>状态 ，CPU <strong>利用率低</strong>。</li></ul></li></ul></li><li>中断驱动方式<ul><li>完成一次读/写操作的流程<ul><li><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part5/image-20211115195236013.png" alt="image-20211115195236013" style="zoom:50%;"></li><li>引入<strong>中断机制</strong>。将<strong>等待 I/O 的进程阻塞</strong>，<strong>在每个指令周期的末尾检查中断</strong>；</li></ul></li><li>CPU 干预的频率<ul><li>每次 I/O 操作<strong>开始之前</strong>、<strong>完成之后</strong>需要 CPU 介入。</li><li>而等待 I/O 完成的过程中 CPU 可以切换到别的进程执行。</li></ul></li><li>数据传送的单位<ul><li>每次读/写一个字</li></ul></li><li>数据的流向<ul><li>读操作（数据输入）：I/O 设备 -&gt; CPU -&gt; 内存</li><li>写操作（数据输出）：内存 -&gt; CPU -&gt; I/O 设备</li></ul></li><li>主要缺点和主要优点<ul><li>优点：通过 I/O 控制器<strong>主动发出中断信号</strong>报告 I/O 已完成，CPU 不再需要不停地轮询。CPU 和 I/O 设备并行工作，CPU 利用率明显提升。</li><li>缺点：每个字<strong>在 I/O 设备与内存之间的传输，都需要经过 CPU</strong>。而<strong>频繁的中断处理会消耗较多的 CPU 时间</strong>。</li></ul></li></ul></li><li>DMA（ Direct Memory Access，直接存储器存取）方式<ul><li>DMA 控制器<ul><li><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part5/image-20211115200414017.png" alt="image-20211115200414017" style="zoom:80%;"></li><li>DR（Data Register，数据寄存器）：暂存从设备到内存，或从内存到设备的数据。</li><li>MAR（Memory Address Register，内存地址寄存器）：在输入时，MAR 表示数据应放到内存中的什么位置；输出时 MAR 表示要输出的数据放在内存中的什么位置。</li><li>DC（Data Counter，数据计数器）：表示剩余要读/写的字节数。</li><li>CR（Command Register，命令/状态寄存器）：用于存放 CPU 发来的 I/O 命令，或设备的状态信息。</li></ul></li><li>完成一次读/写操作的流程<ul><li><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part5/image-20211115195617190.png" alt="image-20211115195617190" style="zoom:50%;"></li><li>DMA 读写完之后，向 CPU 发出中断信号</li></ul></li><li>CPU 干预的频率<ul><li>仅在传送一个或多个数据块的<strong>开始</strong>和<strong>结束</strong>时，才需要 CPU 干预。</li></ul></li><li>数据传送的单位<ul><li>每次读/写<strong>一个或多个块</strong></li><li>注意：<strong>每次读写的只能是连续的多个块，且这些块读入内存后在内存中也必须是连续的</strong>。</li></ul></li><li>数据的流向（不再需要经过CPU）<ul><li>读操作（数据输入）：I/O 设备 -&gt; 内存</li><li>写操作（数据输出）：内存 -&gt; I/O 设备</li></ul></li><li>主要缺点和主要优点<ul><li>优点：<ul><li><strong>数据传输单位为“块”</strong>，而不是“字”。</li><li>数据在 I/O 与内存之间的传输不需要经过 CPU，<strong>CPU 介入频率降低</strong>，<strong>数据传输效率增加</strong>。</li><li><strong>CPU 和 I/O 设备的并行性得到提升</strong>。</li></ul></li><li>缺点：<ul><li>CPU 每发出一条 I/O 指令，<strong>只能读/写一个或多个连续（而不能离散）的数据块</strong>。</li><li>如果<strong>要读/写多个离散存储的数据块，或者要将数据分别写到不同的内存区域</strong>时，CPU 要<strong>分别发出多条 I/O 指令，进行多次中断处理</strong>才能完成。</li></ul></li></ul></li></ul></li><li>通道控制方式<ul><li>通道（弱化 CPU）可以识别并执行一系列通道指令<ul><li><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part5/image-20211115201531964.png" alt="image-20211115201531964" style="zoom:80%;"></li><li>CPU 向通道发出 I/O 指令。指明<strong>通道程序在内存中的位置</strong>，并指明要<strong>操作的是哪个 I/O 设备</strong>。</li><li>通道执行内存中的通道程序（其中指明了要<strong>读入/写出多少数据</strong>，读/写的数据应<strong>放在内存的位置</strong>等信息，<strong>相当于任务清单</strong>）</li><li>通道执行完规定的任务后，向 CPU 发出中断信号</li></ul></li><li>完成一次读/写操作的流程<ul><li><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part5/image-20211115200740547.png" alt="image-20211115200740547" style="zoom:50%;"></li></ul></li><li>CPU 干预的频率<ul><li>极低，通道会根据 CPU 的指示执行相应的通道程序，只有完成一组数据块的读/写后才需要发出中断信号，请求 CPU 干预。</li></ul></li><li>数据传送的单位<ul><li>每次读/写<strong>一组数据块</strong></li></ul></li><li>数据的流向（在通道的控制下进行）<ul><li>读操作（数据输入）：I/O 设备 -&gt; 内存</li><li>写操作（数据输出）：内存 -&gt; I/O 设备</li></ul></li><li>主要缺点和主要优点<ul><li>缺点：实现复杂，需要专门的通道硬件支持</li><li>优点：<strong>CPU、通道、I/O 设备可并行工作，资源利用率很高</strong>。</li></ul></li></ul></li></ul><h3 id="I-O-软件层次结构"><a href="#I-O-软件层次结构" class="headerlink" title="I/O 软件层次结构"></a>I/O 软件层次结构</h3><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part5/image-20211115202052358.png" alt="image-20211115202052358" style="zoom:80%;"><ul><li><p>用户层软件</p><ul><li>用户层软件<strong>实现了与用户交互的接口</strong>，用户可直接<strong>使用该层提供的、与 I/O 操作相关的库函数</strong>对设备进行操作</li><li>用户层软件将用户请求翻译成格式化的 I/O 请求，并通过<strong>系统调用</strong>请求操作系统内核的服务</li></ul></li><li><p>设备独立性软件</p><ul><li>设备独立性软件，又称设备无关性软件。与设备的硬件特性无关的功能几乎都在这一层实现。</li><li>主要实现的功能：<ul><li><strong>向上层提供统一的调用接口</strong>（如 read/write 系统调用）</li><li><strong>设备的保护</strong>（访问权限）</li><li><strong>差错处理</strong></li><li><strong>设备的分配与回收</strong>（临界资源）</li><li><strong>数据缓冲区管理</strong>（屏蔽设备之间数据交换单位大小和传输速度的差异）</li><li><strong>建立逻辑设备表</strong>（LUT，Logical UnitTable），包含逻辑设备名到物理设备名的<strong>映射关系</strong>、根据设备类型选择<strong>调用相应的驱动程序</strong>。<ul><li><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part5/image-20211115203148579.png" alt="image-20211115203148579" style="zoom: 67%;"></li><li>操作系统系统可以采用两种方式管理逻辑设备表（LUT）： <ol><li><strong>整个系统</strong>设置一张 LUT，意味着所有用户不能使用相同的逻辑设备名，因此只适用于单用户操作系统。</li><li><strong>每个用户</strong>设置一张 LUT，各个用户使用的逻辑设备名可以重复，适用于多用户操作系统。系统在用户登录时为其建立一个用户管理进程，而 LUT 就存放在用户管理进程的 PCB 中。</li></ol></li></ul></li></ul></li></ul></li><li><p>设备驱动程序</p><ul><li>负责对硬件设备的具体控制，将上层发出的一系列命令转化成特定（不同厂家）设备的命令。</li><li>包括<strong>设置设备寄存器</strong>、<strong>检查设备状态</strong>等</li><li>驱动程序一般会以一个独立进程的方式存在。</li></ul></li><li><p>中断处理程序</p><ul><li><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part5/image-20211115205824849.png" alt="image-20211115205824849" style="zoom:80%;"></li><li>当 I/O 任务完成时，I/O 控制器会发送一个中断信号，系统会根据中断信号类型找到相应的中断处理程序并执行。</li></ul></li><li><p>最常考的是设备<strong>独立性软件、设备驱动程序</strong>这两层。</p><ul><li>直接涉及到硬件具体细节、且与中断无关的操作肯定是在<strong>设备驱动程序层</strong>完成的</li><li>没有涉及硬件的、对各种设备都需要进行的管理工作都是在<strong>设备独立性软件层</strong>完成的</li><li><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part5/image-20211115210124001.png" alt="image-20211115210124001"></li></ul></li></ul><h2 id="I-O-核心子系统"><a href="#I-O-核心子系统" class="headerlink" title="I/O 核心子系统"></a>I/O 核心子系统</h2><h3 id="I-O-子系统概述"><a href="#I-O-子系统概述" class="headerlink" title="I/O 子系统概述"></a>I/O 子系统概述</h3><ul><li><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part5/image-20211115210745581.png" alt="image-20211115210745581" style="zoom:80%;"></li><li>考研中，需要重点理解和掌握的功能是：<ul><li><strong>I/O 调度</strong><ul><li>类比磁盘调度</li><li>先来先服务算法、优先级算法、短作业优先等</li></ul></li><li><strong>设备保护</strong><ul><li>类比文件保护功能</li><li>设备被看做是一种特殊的文件，每个设备也会有对应的 FCB。</li><li>当用户请求访问某个设备时，系统根据 FCB 中记录的信息来判断该用户是否有相应的访问权限，以此实现“设备保护”的功能。</li></ul></li><li><strong>假脱机技术</strong>（SPOOLing技术）</li><li><strong>设备分配与回收</strong></li><li><strong>缓冲区管理</strong>（即缓冲与高速缓存）</li></ul></li></ul><h3 id="假脱机技术"><a href="#假脱机技术" class="headerlink" title="假脱机技术"></a>假脱机技术</h3><p><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part5/image-20211115210955966.png" alt="image-20211115210955966"></p><ul><li>脱机技术 —— 脱离主机的控制进行的输入/输出操作。<ul><li><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part5/image-20211115214348914.png" alt="image-20211115214348914" style="zoom: 67%;"></li><li>缓解 CPU 与慢速 I/O 设备的速度矛盾。</li><li>实现 I/O 设备与 CPU 的并行。</li></ul></li><li>假脱机技术（SPOOLing 技术）<ul><li><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part5/image-20211115213754105.png" alt="image-20211115213754105" style="zoom:67%;"></li><li>输入井：模拟脱机<strong>输入时的磁带</strong>，用于收容 I/O 设备输入的数据</li><li>输出井：模拟脱机<strong>输出时的磁带</strong>，用于收容用户进程输出的数据</li><li>在<strong>磁盘上</strong>开辟出两个存储区域 —— 输入井和输出井。</li><li>输入进程：模拟脱机<strong>输入时的外围控制机</strong></li><li>输出进程：模拟脱机<strong>输出时的外围控制机</strong></li><li>要实现 SPOOLing 技术，<strong>必须要有多道程序技术的支持</strong>。系统会建立输入进程和输出进程。</li><li>输入缓冲区：用于暂存从输入设备输入的数据，之后再转存到输入井中</li><li>输出缓冲区：用于暂存从输出井送来的数据，之后再传送到输出设备上</li><li>输入缓冲区和输出缓冲区是<strong>在内存中</strong>的缓冲区</li></ul></li><li>共享打印机<ul><li>SPOOLing 技术可以把一台物理设备<strong>虚拟</strong>成逻辑上的多台设备，可以<strong>将独占式设备改造成共享设备</strong>。<ol><li><strong>在磁盘输出井中</strong>为进程申请一个空闲缓冲区（这个缓冲区是在磁盘上的），并将要打印的数据送入其中；</li><li>为用户进程申请一张空白的打印请求表，并将用户的打印请求填入表中（用来说明用户的打印数据存放位置等信息），再将该表挂到假脱机文件队列上。</li><li>当打印机空闲时，<strong>输出进程会从文件队列的队头取出一张打印请求表</strong>，并根据表中的要求将要打印的数据<strong>从输出井传送到输出缓冲区</strong>，再输出到打印机进行打印。</li></ol></li><li><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part5/image-20211116140746931.png" alt="image-20211116140746931"></li></ul></li></ul><h3 id="设备的分配与回收"><a href="#设备的分配与回收" class="headerlink" title="设备的分配与回收"></a>设备的分配与回收</h3><p><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part5/image-20211116141015539.png" alt="image-20211116141015539"></p><ul><li><p><strong>设备分配时应考虑的因素</strong></p><ul><li>设备的固有属性<ul><li><strong>独占设备</strong>：一个时段只能分配给一个进程，只允许各个进程串行使用（如打印机）</li><li><strong>共享设备</strong>：可同时分配给多个进程使用（如磁盘），各进程往往是宏观上同时共享使用设备，而微观上交替使用。</li><li><strong>虚拟设备</strong>：采用 SPOOLing 技术将独占设备改造成虚拟的共享设备，可同时分配给多个进程使用（如采用 SPOOLing 技术实现的共享打印机）</li></ul></li><li>设备分配算法<ul><li><strong>先来先服务</strong></li><li><strong>优先级高者优先</strong></li><li><strong>短任务优先</strong></li><li>……</li></ul></li><li>设备分配中的安全性<ul><li><strong>安全分配方式</strong>：为进程分配一个 I/O 设备后就将进程阻塞，本次 I/O 完成后才将进程唤醒。<ul><li><strong>一个时段内每个进程只能使用一个设备</strong></li><li>优点：破坏了“请求和保持”条件，<strong>不会死锁</strong></li><li>缺点：对于一个进程来说，CPU 和 I/O 设备只能<strong>串行</strong>工作</li></ul></li><li><strong>不安全分配方式</strong>：进程发出 I/O 请求后，系统为其分配 I/O 设备，并且进程可继续执行，之后还可以发出新的 I/O 请求。只有某个 I/O 请求得不到满足时才将进程阻塞。<ul><li><strong>一个进程可以同时使用多个设备</strong></li><li>优点：进程的计算任务和 I/O 任务可以<strong>并行</strong>处理</li><li>缺点：<strong>有可能发生死锁</strong>（死锁避免、死锁的检测和解除）</li></ul></li></ul></li></ul></li><li><p><strong>静态分配与动态分配</strong></p><ul><li>静态分配：进程<strong>运行前为其分配全部所需资源</strong>，运行结束后归还资源<ul><li>破坏了“请求和保持”条件，不会发生死锁</li></ul></li><li>动态分配：进程<strong>运行过程中动态申请</strong>设备资源</li></ul></li><li><p><strong>设备分配管理中的数据结构</strong></p><ul><li><strong>设备、控制器、通道</strong>之间的关系：<ul><li>一个通道控制多个控制器，一个控制器控制多个设备</li><li><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part5/image-20211116142938193.png" alt="image-20211116142938193" style="zoom: 67%;"></li></ul></li><li><strong>设备控制表（DCT）</strong>：系统为每个设备配置一张 DCT，用于记录设备情况<ul><li>系统会根据阻塞原因不同，将进程 PCB 挂到不同的阻塞队列中</li><li><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part5/image-20211116143032613.png" alt="image-20211116143032613" style="zoom: 80%;"></li></ul></li><li><strong>控制器控制表（COCT）</strong>：每个设备控制器都会对应一张 COCT。操作系统根据 COCT 的信息对控制器进行操作和管理。<ul><li><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part5/image-20211116143127155.png" alt="image-20211116143127155" style="zoom:80%;"></li></ul></li><li><strong>通道控制表（CHCT）</strong>：每个通道都会对应一张 CHCT。操作系统根据 CHCT 的信息对通道进行操作和管理。<ul><li><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part5/image-20211116143209860.png" alt="image-20211116143209860" style="zoom:80%;"></li></ul></li><li><strong>系统设备表（SDT）</strong>：记录了<strong>系统中全部设备</strong>的情况，每个设备对应一个表目。<ul><li><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part5/image-20211116143256935.png" alt="image-20211116143256935" style="zoom:80%;"></li></ul></li></ul></li><li><p><strong>设备分配的步骤</strong></p><ul><li><p>步骤：</p><ol><li>根据进程请求的<strong>物理设备名</strong>查找 SDT（注：物理设备名是进程请求分配设备时提供的参数）</li><li>根据 SDT 找到 DCT，若<strong>设备</strong>忙碌则将进程 PCB 挂到<strong>设备等待队列</strong>中，不忙碌则将<strong>设备</strong>分配给进程。</li><li>根据 DCT 找到 COCT，若<strong>控制器</strong>忙碌则将进程 PCB 挂到<strong>控制器等待队列</strong>中，不忙碌则将<strong>控制器</strong>分配给进程。</li><li>根据 COCT 找到 CHCT，若<strong>通道</strong>忙碌则将进程 PCB 挂到<strong>通道等待队列</strong>中，不忙碌则将<strong>通道</strong>分配给进程。</li></ol></li><li><p>注意：<strong>只有设备、控制器、通道三者都分配成功时，这次设备分配才算成功，之后便可启动 I/O 设备进行数据传送</strong>。</p></li><li><p>缺点：</p><ul><li>用户编程时必须使用<strong>物理设备名</strong>，底层细节对用户不透明，不方便编程 </li><li>若换了一个<strong>物理设备</strong>，则程序无法运行</li><li>若进程<strong>请求的物理设备</strong>正在忙碌，则即使系统中还有<strong>同类型的设备</strong>，进程也必须阻塞等待</li></ul></li></ul></li><li><p><strong>设备分配步骤的改进方法</strong></p><ul><li>改进方法：建立逻辑设备名与物理设备名的映射机制，用户编程时只需提供<strong>逻辑设备名</strong>。<ul><li><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part5/image-20211116144907464.png" alt="image-20211116144907464"></li></ul></li><li>分配步骤<ol><li>根据进程请求的<strong>逻辑设备名</strong>查找 SDT（注：用户编程时提供的逻辑设备名其实就是“设备类型”）</li><li>查找 SDT，找到用户进程<strong>指定类型的且空闲</strong>的设备，将其及其 DCT 分配给该进程。<ul><li>操作系统<strong>在逻辑设备表（LUT）中新增一个表项</strong>，<strong>记录该次调用的逻辑设备名和物理设备名的映射关系</strong>，</li><li>在这一步，操作系统动态分配物理设备，并返回相应 DCT。</li><li>之后用户进程再次通过相同的逻辑设备名，操作系统通过 LUT 表的记录也可以找到对应的物理设备。</li></ul></li><li>根据 DCT 找到 COCT，若控制器忙碌则将进程 PCB 挂到控制器等待队列中，不忙碌则将控制器分配给进程。</li><li>根据 COCT 找到 CHCT，若通道忙碌则将进程 PCB 挂到通道等待队列中，不忙碌则将通道分配给进程。</li></ol></li><li>逻辑设备表的设置问题： <ul><li>整个系统只有一张 LUT：各用户所用的<strong>逻辑设备名不允许重复</strong>，适用于单用户操作系统</li><li>每个用户一张 LUT：<strong>不同用户的逻辑设备名可重复</strong>，适用于多用户操作系统</li></ul></li></ul></li></ul><h3 id="缓冲区管理"><a href="#缓冲区管理" class="headerlink" title="缓冲区管理"></a>缓冲区管理</h3><p><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part5/image-20211116150127920.png" alt="image-20211116150127920"></p><ul><li>缓冲区的定义<ul><li>缓冲区是一个<strong>存储区域</strong>，可以<strong>由专门的硬件寄存器</strong>组成，也可利用<strong>内存</strong>作为缓冲区。<ul><li>使用硬件作为缓冲区的成本较高，容量也较小，一般仅用在对速度要求非常高的场合（如，存储器管理中所用的联想寄存器，快表）</li><li>一般情况下，更多的是利用内存作为缓冲区，“设备独立性软件”的缓冲区管理就是要组织管理好内存中的缓冲区</li></ul></li></ul></li><li>缓冲区的作用<ul><li>缓和 CPU 与 I/O 设备之间速度不匹配的矛盾</li><li>减少对 CPU 的中断频率，放宽对 CPU 中断响应时间的限制<ul><li>字符型设备，每输出完一个字符就要向 CPU 发送一次中断信号</li></ul></li><li>解决数据粒度不匹配的问题<ul><li>输出进程每次可以生成一块数据，但 I/O 设备每次只能输出一个字符</li></ul></li><li>提高 CPU 和 I/O 设备之间的并行性</li></ul></li><li>单缓冲<ul><li>单缓冲策略，操作系统会在<strong>主存中为其分配一个缓冲区</strong>。</li><li>注意：<ul><li><strong>当缓冲区数据非空时，不能往缓冲区冲入数据，只能从缓冲区把数据传出</strong>；</li><li><strong>当缓冲区为空时，可以往缓冲区冲入数据，但必须把缓冲区充满以后，才能从缓冲区把数据传出</strong>。</li><li>一般来说，一个缓冲区的大小就是一个块，用户进程的工作区大小与缓冲区相同</li></ul></li><li><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part5/image-20211116154946154.png" alt="image-20211116154946154" style="zoom:67%;"></li><li><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part5/image-20211116154847194.png" alt="image-20211116154847194"></li><li>技巧：假定一个初始状态，分析下次到达相同状态需要多少时间，这就是处理<strong>一块数据平均所需时间</strong>。<ul><li><strong>采用单缓冲策略，处理一块数据平均耗时 Max(C, T)+M</strong>。</li></ul></li></ul></li><li>双缓冲<ul><li>双缓冲策略，操作系统会在主存中为其分配两个缓冲区</li><li><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part5/image-20211116155441445.png" alt="image-20211116155441445" style="zoom:67%;"></li><li><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part5/image-20211116155706436.png" alt="image-20211116155706436"></li><li>当 M+C&gt;T，则<strong>很难有回到初始状态</strong>，但是通过图中观察可发现，周期为 M+C。<ul><li>**采用双缓冲策略，处理一个数据块的平均耗时为 Max (T, C+M)**。</li></ul></li></ul></li><li>使用单/双缓冲在通信时的区别<ul><li>两台机器之间<strong>通信</strong>时，可以配置缓冲区用于数据的发送和接受。<ul><li>若两个相互通信的机器只设置<strong>单缓冲区</strong>，在任一时刻只能实现<strong>数据的单向传输</strong>。</li><li>若两个相互通信的机器设置<strong>双缓冲区</strong>，则同一时刻可以实现<strong>双向的数据传输</strong>。</li><li>管道通信中的“管道”其实就是缓冲区。要实现数据的双向传输，必须设置两个管道</li><li>==这里与part2说法冲突todo==</li></ul></li></ul></li><li>循环缓冲<ul><li>将多个大小相等的缓冲区链接成一个循环队列。</li><li><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part5/image-20211116162507957.png" alt="image-20211116162507957" style="zoom:80%;"></li></ul></li><li>缓冲池<ul><li>缓冲池由系统中共用的缓冲区组成。这些缓冲区按使用状况可以分为：空缓冲队列、装满输入数据的缓冲队列（输入队列）、装满输出数据的缓冲队列（输出队列）。</li><li>另外，根据一个缓冲区在实际运算中扮演的功能不同，又设置了四种工作缓冲区：用于收容输入数据的工作缓冲区（hin）、用于提取输入数据的工作缓冲区（sin）、用于收容输出数据的工作缓冲区（hout）、用于提取输出数据的工作缓冲区（sout）</li><li><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part5/image-20211116163116910.png" alt="image-20211116163116910" style="zoom:80%;"></li></ul></li></ul>]]></content>
    
    
    <summary type="html">I/O 管理</summary>
    
    
    
    <category term="操作系统" scheme="https://nephrencake.gitee.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
  </entry>
  
  <entry>
    <title>操作系统-Part4</title>
    <link href="https://nephrencake.gitee.io/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part4/"/>
    <id>https://nephrencake.gitee.io/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part4/</id>
    <published>2021-11-01T01:43:54.000Z</published>
    <updated>2021-11-16T08:41:12.320Z</updated>
    
    <content type="html"><![CDATA[<h1 id="操作系统-Part4——文件管理"><a href="#操作系统-Part4——文件管理" class="headerlink" title="操作系统-Part4——文件管理"></a>操作系统-Part4——文件管理</h1><p>[TOC]</p><h2 id="文件系统基础"><a href="#文件系统基础" class="headerlink" title="文件系统基础"></a>文件系统基础</h2><h3 id="初识文件管理"><a href="#初识文件管理" class="headerlink" title="初识文件管理"></a>初识文件管理</h3><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part4/image-20211111183657165.png" alt="image-20211111183657165"><ul><li>文件属性<ul><li><strong>文件名</strong>：由创建文件的用户决定文件名，主要是为了方便用户找到文件，<strong>同一目录下不允许有重名文件</strong>。</li><li><strong>标识符</strong>：一个系统内的各文件标识符唯一，对用户来说毫无可读性，因此标识符只是操作系统用于区分各个文件的一种内部名称。</li><li><strong>类型</strong>：指明文件的类型</li><li><strong>位置</strong>：文件存放的路径（让用户使用）、在外存中的地址（操作系统使用，对用户不可见）</li><li><strong>大小</strong>：指明文件大小</li><li><strong>创建时间、上次修改时间</strong></li><li><strong>文件所有者信息</strong></li><li><strong>保护信息</strong>：对文件进行保护的访问控制信息</li></ul></li><li>文件内部的数据组织<ul><li>无结构文件（如文本文件），由一些二进制或字符流组成，又称“流式文件”</li><li>有结构文件（如数据库表），由一组相似的记录组成，又称“记录式文件”<ul><li>记录是一组相关数据项的集合</li><li>数据项是文件系统中<strong>最基本的数据单位</strong></li><li><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part4/image-20211111182113600.png" alt="image-20211111182113600" style="zoom:67%;"></li></ul></li></ul></li><li>文件之间的组织<ul><li>目录（文件夹）其实也是一种特殊的有结构文件</li><li><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part4/image-20211111182238302.png" alt="image-20211111182238302" style="zoom:67%;"></li></ul></li><li>操作系统向上提供的功能<ul><li><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part4/image-20211111182641475.png" alt="image-20211111182641475" style="zoom: 50%;"></li><li>图形化交互操作的本质也是<strong>调用操作系统提供的接口</strong></li><li>可用几个基本操作完成更复杂的操作，比如：“复制文件”：先创建一个新的空文件，再把源文件读入内存，再将内存中的数据写到新文件中</li><li>读/写文件之前，需要“打开文件”</li><li>读/写文件结束之后，需要“关闭文件”</li></ul></li><li>文件在外存的存放<ul><li>外存也是由一个个存储单元组成的，每个存储单元可以存储一定量的数据（如 1B）。<ul><li>每个存储单元对应一个物理地址</li></ul></li><li>类似于内存分为一个个“内存块”，外存会分为一个个“块/磁盘块/物理块”。每个磁盘块的大小是相等的，每块一般包含 2 的整数幂个地址<ul><li>文件的逻辑地址也可以分为（逻辑块号，块内地址），操作系统同样需要将逻辑地址转 换为外存的物理地址（物理块号，块内地址）的形式。</li><li>块内地址的位数取决于磁盘块的大小</li></ul></li><li>操作系统<strong>以块为单位为文件分配存储空间、读入内存</strong><ul><li>即使一个文件大小只有 10B，但它依然需要占用 1KB 的磁盘块</li></ul></li></ul></li><li>其他需要由操作系统实现的文件管理功能<ul><li>文件共享：使多个用户可以共享使用一个文件</li><li>文件保护：如何保证不同的用户对文件有不同的操作权限</li></ul></li></ul><h3 id="文件的逻辑结构"><a href="#文件的逻辑结构" class="headerlink" title="文件的逻辑结构"></a>文件的逻辑结构</h3><p><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part4/image-20211111224112533.png" alt="image-20211111224112533"></p><ul><li>逻辑结构，指在用户看来，文件内部的数据应该是如何组织起来的。物理结构，指在操作系统看来，文件的数据是如何存放在外存中的。</li><li>按文件是否有结构分类，可以分为无结构文件、有结构文件两种。<ul><li><strong>无结构文件</strong>：文件内部的数据就是一系列二进制流或字符流组成。又称“<strong>流式文件</strong>”。</li><li><strong>有结构文件</strong>：由一组相似的记录组成，又称“<strong>记录式文件</strong>”。每条记录又若干个数据项组成。一般来说，每条记录有一个数据项可作为<strong>关键字</strong>（作为识别不同记录的ID）<ul><li>根据各条记录的长度（占用的存储空间）是否相等，又可分为<strong>定长记录</strong>和<strong>可变长记录</strong>两种。</li></ul></li></ul></li><li>有结构文件的逻辑结构<ul><li>顺序文件：文件中的记录一个接一个地顺序排列（逻辑上），记录可以是<strong>定长</strong>的或<strong>可变长</strong>的。各个记录在物理上可以<strong>顺序存储</strong>或<strong>链式存储</strong>。<ul><li><strong>串结构</strong>：记录之间的顺序与关键字无关</li><li><strong>顺序结构</strong>：记录之间的顺序按关键字顺序排序</li><li>一般来说，考试题目中所说的“顺序文件”指的是<strong>物理上顺序存储的顺序文件</strong>。<ul><li>顺序文件的缺点是增加/删除一个记录比较困难</li></ul></li><li><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part4/image-20211111223019417.png" alt="image-20211111223019417"></li></ul></li><li>索引文件：<ul><li>索引表本身是定长记录的顺序文件。</li><li>主要用于对信息处理的及时性要求比较高的场合。</li><li>可以用不同的数据项（属性）建立多个索引表。</li><li><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part4/image-20211111223256012.png" alt="image-20211111223256012" style="zoom: 67%;"></li></ul></li><li>索引顺序文件：<ul><li>是索引文件和顺序文件思想的结合。区别在于，不是每个记录对应一个索引表项，而是<strong>一组记录对应一个索引表项</strong>。</li><li><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part4/image-20211111223511426.png" alt="image-20211111223511426" style="zoom:67%;"></li></ul></li><li>多级索引顺序文件<ul><li><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part4/image-20211111223713847.png" alt="image-20211111223713847" style="zoom:67%;"></li></ul></li></ul></li></ul><h3 id="文件目录"><a href="#文件目录" class="headerlink" title="文件目录"></a>文件目录</h3><p><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part4/image-20211111230036761.png" alt="image-20211111230036761"></p><ul><li><strong>文件控制块</strong>（File Control Block，FCB）<ul><li>目录本身就是一种有结构文件，由一条条记录组成。每条记录对应一个在该放在该目录下的文件</li><li><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part4/image-20211111230640935.png" alt="image-20211111230640935"></li><li>对目录进行的操作<ul><li>搜索：当用户要使用一个文件时，系统要根据文件名搜索目录，找到该文件对应的目录项</li><li>创建文件：创建一个新文件时，需要在其所属的目录中增加一个目录项</li><li>删除文件：当删除一个文件时，需要在目录中删除相应的目录项</li><li>显示目录：用户可以请求显示目录的内容，如显示该目录中的所有文件及相应属性</li><li>修改目录：某些文件属性保存在目录中，因此这些属性变化时需要修改相应的目录项（如：文件重命名）</li></ul></li></ul></li><li><strong>目录结构</strong><ul><li><strong>单级目录结构</strong><ul><li>早期操作系统并不支持多级目录，整个系统中只建立一张目录表，每个文件占一个目录项。</li><li>特点：单级目录实现了“按名存取”，但是不允许文件重名。</li><li>缺点：不适用于多用户操作系统。</li></ul></li><li><strong>两级目录结构</strong><ul><li>早期的多用户操作系统，采用两级目录结构。分为<strong>主文件目录</strong>（MFD，Master File Directory）和<strong>用户文件目录</strong>（UFD，User Flie Directory）。</li><li>特点：1. 允许不同用户的文件重名；2. 可以在目录上实现实现访问限制</li><li>缺点：依然缺乏灵活性，用户不能对自己的文件进行分类</li></ul></li><li><strong>多级目录结构</strong>（树形目录结构）<ul><li><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part4/image-20211111231141027.png" alt="image-20211111231141027" style="zoom:80%;"></li><li>系统根据<strong>绝对路径</strong>一层一层地找到下一级目录。刚开始从外存读入根目录的目录表；找到“照片”目录的存放位置后，从外存读入对应的目录表；再找到“2015-08”目录的存放位置，再从外存读入对应目录表；最后才找到文件“自拍.jpg”的存放位置。<strong>整个过程需要 3 次读磁盘 I/O 操作</strong>。</li><li>引入<strong>当前目录</strong>和<strong>相对路径</strong>后，磁盘 I/O 的次数减少，提升了访问文件的效率。</li><li>特点：可以很方便地对文件进行分类，层次结构清晰，也能够更有效地进行文件的管理和保护。</li><li>缺点：<strong>不便于实现文件的共享</strong>。</li></ul></li><li><strong>无环图目录结构</strong><ul><li><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part4/image-20211111231431422.png" alt="image-20211111231431422" style="zoom:80%;"></li><li>可以用不同的文件名指向同一个文件或目录</li><li>实现：<strong>为每个共享结点设置一个共享计数器</strong>，用于记录此时有多少个地方在共享该结点。用户提出删除结点的请求时，只是<strong>删除该用户的 FCB、并使共享计数器减 1</strong>，并不会直接删除共享结点。<strong>只有共享计数器减为 0 时，才删除结点</strong>。</li><li>共享文件不同于复制文件。在共享文件中，由于各用户指向的是同一个文件，因此只要其中一个用户修改了文件数据，那么所有用户都可以看到文件数据的变化。</li></ul></li></ul></li><li>索引结点（FCB的改进）<ul><li>使用索引结点机制，磁盘块可容纳的 FCB 增多，对于拥有较多目录项的目录来说，减少了 I/O 次数，大大提升文件检索速度。</li><li>存放<strong>在外存中</strong>的索引结点称为“<strong>磁盘索引结点</strong>”；当索引结点<strong>放入内存后</strong>称为“<strong>内存索引结点</strong>”。</li><li>相比之下<strong>内存索引结点中需要增加一些信息</strong>，比如：文件是否被修改、此时有几个进程正在访问该文件等</li><li><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part4/image-20211111231941136.png" alt="image-20211111231941136" style="zoom: 67%;"></li></ul></li></ul><h3 id="文件保护"><a href="#文件保护" class="headerlink" title="文件保护"></a>文件保护</h3><p><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part4/image-20211112110535854.png" alt="image-20211112110535854"></p><ul><li><strong>口令保护</strong><ul><li>用户<strong>请求访问该文件时必须提供口令</strong>。<ul><li>口令一般存放在文件对应的 <strong>FCB</strong> 或<strong>索引结点</strong>中。</li></ul></li><li>优点：保存口令的空间开销不多，验证口令的时间开销也很小。</li><li>缺点：正确的口令存放在系统内部，<strong>不够安全</strong>。</li></ul></li><li><strong>加密保护</strong><ul><li>使用密码对文件进行加密保存，在访问文件时需要提供正确的密码才能对文件进行解密。</li><li>优点：保密性强，不需要在系统中存储“密码”</li><li>缺点：编码/译码，或者说加密/解密要花费一定时间。</li><li><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part4/image-20211112111542108.png" alt="image-20211112111542108" style="zoom: 80%;"></li></ul></li><li><strong>访问控制</strong><ul><li><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part4/image-20211112112011037.png" alt="image-20211112112011037"></li><li>在每个文件的 FCB（或索引结点）中增加一个<strong>访问控制列表</strong>（Access-Control List，ACL），该表中记录了各个用户可以对该文件执行哪些操作。</li><li><strong>精简的访问列表</strong>：<strong>以组为单位</strong>，标记各组用户可以对文件执行哪些操作。</li><li>如果对<strong>某个目录</strong>进行了访问权限的控制，那也要对<strong>目录下的所有文件</strong>进行相同的访问权限控制</li></ul></li></ul><h3 id="文件共享"><a href="#文件共享" class="headerlink" title="文件共享"></a>文件共享</h3><p><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part4/image-20211112112227710.png" alt="image-20211112112227710"></p><ul><li>注意：<ul><li>多个用户<strong>共享</strong>同一个文件，意味着系统中只有<strong>一份</strong>文件数据。用户对该文件的修改，在用户之间是共享的、可见的。</li><li>多个用户<strong>复制</strong>同一个文件，意味着系统中会有<strong>多份</strong>文件数据。用户对自己文件的修改，对其他用户的文件数据并没有影响。</li></ul></li><li><strong>基于索引结点的共享方式（硬链接）</strong><ul><li><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part4/image-20211112113309277.png" alt="image-20211112113309277"></li><li>索引结点中设置一个链接计数变量 count，用于表示链接到本索引结点上的用户目录项数。</li><li>若 count&gt;1，说明此时<strong>有多个用户目录项链接到该索引结点上</strong>，或者说<strong>有多个用户在共享此文件</strong>。</li><li>若某个用户删除该文件，则只是<strong>把目录中与该文件对应的目录项删除</strong>，且<strong>索引结点的 count 值减 1</strong>。 </li><li>若 count&gt;0，说明还有别的用户要使用该文件，暂时不能把文件数据删除，否则会导致指针悬空。</li><li>当 count=0 时系统负责删除文件。</li></ul></li><li><strong>基于符号链的共享方式（软链接）</strong><ul><li><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part4/image-20211112113608981.png" alt="image-20211112113608981" style="zoom:80%;"></li><li>当 Link 型文件被删除时，Link 指向的文件依然存在</li><li>当 Link 指向的文件被删除时，该 Link 型文件失效</li></ul></li></ul><h2 id="文件系统实现"><a href="#文件系统实现" class="headerlink" title="文件系统实现"></a>文件系统实现</h2><h3 id="文件的物理结构（重点）"><a href="#文件的物理结构（重点）" class="headerlink" title="文件的物理结构（重点）"></a>文件的物理结构（重点）</h3><p><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part4/image-20211112114305513.png" alt="image-20211112114305513"></p><ul><li><p>文件块、磁盘块</p><ul><li>文件的逻辑地址空间也被分为了一个个<strong>文件块</strong>，也可以表示为<strong>（逻辑块号，块内地址）</strong>的形式。</li><li>通常，<strong>磁盘块的大小与内存块、页面的大小相同</strong></li><li>内存与磁盘之间的数据交换（即读/写操作、磁盘 I/O）都是以块为单位进行的。</li></ul></li><li><p>连续分配</p><ul><li><p>连续分配方式要求<strong>每个文件在磁盘上占有一组连续的块</strong>。</p></li><li><p>逻辑地址到物理地址的映射</p><ul><li>（逻辑块号，块内地址）-&gt;（物理块号，块内地址）。只需转换块号就行，块内地址保持不变</li><li>物理块号 = 起始块号 + 逻辑块号</li><li>同时，还要检查逻辑块号是否合法（逻辑块号 ≤ 长度）</li></ul></li><li><p>优点</p><ul><li><strong>连续分配支持顺序访问和直接访问</strong>（随机访问）</li><li><strong>连续分配的文件在顺序读/写时速度最快</strong></li></ul></li><li><p>缺点</p><ul><li><strong>文件不方便拓展</strong>。</li><li><strong>存储空间利用率低</strong>，<strong>会产生难以利用的磁盘碎片</strong>（可以用<strong>紧凑</strong>来处理碎片，但是需要耗费很大的时间代价）</li></ul></li><li><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part4/image-20211112210113773.png" alt="image-20211112210113773" style="zoom: 67%;"></li></ul></li></ul><ul><li>链接分配<ul><li>隐式链接<ul><li>除文件的最后一个盘块之外，每个盘块中都存有<strong>指向下一个盘块的指针</strong>。文件目录包括文件<strong>第一块</strong>的指针和<strong>最后一块</strong>的指针。</li><li>优点：<ul><li>很方便文件拓展</li><li>不会有碎片问题，外存利用率高。</li></ul></li><li>缺点：<ul><li>只支持顺序访问，查找效率低</li><li>指向下一个盘块的指针也需要耗费少量的存储空间</li></ul></li><li><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part4/image-20211112211102158.png" alt="image-20211112211102158" style="zoom:67%;"></li></ul></li><li>显式链接<ul><li>把用于链接文件各物理块的指针显式地存放在一张表中。即，<strong>文件分配表</strong>（<strong>FAT</strong>，File Allocation Table）</li><li>注意：<strong>一个磁盘仅设置一张FAT。开机时，将FAT读入内存，并常驻内存</strong>。<ul><li><strong>逻辑块号转换成物理块号的过程不需要读磁盘操作</strong>。</li></ul></li><li>优点：<ul><li>支持顺序访问，也<strong>支持随机访问</strong></li><li><strong>块号转换的过程不需要访问磁盘，文件的访问效率更高</strong></li><li><strong>不会产生外部碎片</strong>，也可以很方便地对文件进行拓展</li></ul></li><li>缺点：<ul><li>文件分配表的需要占用一定的存储空间。</li></ul></li><li><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part4/image-20211112211434277.png" alt="image-20211112211434277" style="zoom:67%;"></li></ul></li></ul></li><li>索引分配<ul><li>系统<strong>为每个文件建立一张索引表</strong>，索引表中<strong>记录了文件的各个逻辑块对应的物理块</strong>（内存管理中的页表：建立<strong>逻辑页面</strong>到<strong>物理页</strong>之间的映射关系）。</li><li>索引表存放的磁盘块称为<strong>索引块</strong>。文件数据存放的磁盘块称为<strong>数据块</strong>。</li><li>注意：<ul><li><strong>显式链接</strong>方式中，文件分配表 FAT 是<strong>一个磁盘对应一张</strong>。</li><li><strong>索引分配</strong>方式中，索引表是<strong>一个文件对应一张</strong>。</li></ul></li><li>优点：<ul><li>可以支持随机访问。</li><li>文件拓展也很容易实现</li></ul></li><li>缺点<ul><li>索引表需要占用一定的存储空间</li></ul></li><li><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part4/image-20211112212647379.png" alt="image-20211112212647379" style="zoom:67%;"></li><li><strong>链接方案</strong>：<ul><li>如果索引表太大，一个索引块装不下，那么可以将多个索引块链接起来存放。</li><li>缺点：若文件很大，索引表很长，就需要将很多个索引块链接起来。<strong>查找效率低下</strong>。</li><li><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part4/image-20211112213257207.png" alt="image-20211112213257207" style="zoom:67%;"></li></ul></li><li><strong>多层索引</strong>：<ul><li>建立多层索引（原理类似于多级页表）。</li><li>结论：<ul><li>采用 <strong>k</strong> 层索引结构时，且<strong>顶级索引表未调入内存</strong>，则访问一个数据块只需要 <strong>K+1</strong> 次磁盘操作</li></ul></li><li>缺点：<ul><li>即使是小文件，访问一个数据块依然需要 K+1 次读磁盘。</li></ul></li><li><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part4/image-20211112213345728.png" alt="image-20211112213345728" style="zoom:67%;"></li></ul></li><li><strong>混合索引</strong>：<ul><li>多种索引分配方式的结合。</li><li>优点：<ul><li><strong>对于小文件来说，访问一个数据块所需的读磁盘次数更少</strong>。</li></ul></li><li><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part4/image-20211112214310115.png" alt="image-20211112214310115" style="zoom:80%;"></li></ul></li><li><strong>超级超级超级重要考点</strong>：<ul><li>要会根据多层索引、混合索引的结构计算出文件的最大长度（Key：<strong>各级索引表最大不能超过一个块</strong>）；</li><li>要能自己分析访问某个数据块所需要的读磁盘次数Key：FCB 中会存有<strong>指向顶级索引块</strong>的指针，因此可以根据 FCB 读入顶级索引块。每次读入下一级的索引块都需要一次读磁盘操作。另外，要注意题目条件：<strong>顶级索引块是否已调入内存</strong>）</li></ul></li></ul></li></ul><h3 id="逻辑结构-VS-物理结构"><a href="#逻辑结构-VS-物理结构" class="headerlink" title="逻辑结构 VS 物理结构"></a>逻辑结构 VS 物理结构</h3><p><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part4/image-20211112215804531.png" alt="image-20211112215804531"><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part4/image-20211112215911132.png" alt="image-20211112215911132" style="zoom: 50%;"></p><ul><li>个人理解：<ul><li>逻辑结构，是用户针对<strong>文件中价值内容</strong>的组织，追求对内容的查询效率</li><li>物理结构，是操作系统针对<strong>空间利用率</strong>、<strong>物理查询速度</strong>的优化，对内容是无关的</li></ul></li></ul><h3 id="文件存储空间管理"><a href="#文件存储空间管理" class="headerlink" title="文件存储空间管理"></a>文件存储空间管理</h3><p><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part4/image-20211112221825169.png" alt="image-20211112221825169"></p><ul><li><p>存储空间的划分与初始化</p><ul><li><p>存储空间的划分：将物理磁盘划分为一个个<strong>文件卷</strong>（<strong>逻辑卷、逻辑盘</strong>）</p><ul><li>同时，也有系统可以支持<strong>由多个物理磁盘组成一个文件卷</strong></li></ul></li><li><p>存储空间的初始化：<strong>将各个文件卷划分为目录区、文件区</strong>。</p><ul><li><strong>目录区</strong>，主要存放文件目录信息（FCB）、用于磁盘存储空间管理的信息</li><li><strong>文件区</strong>，用于存放文件数据</li></ul></li><li><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part4/image-20211113222439483.png" alt="image-20211113222439483" style="zoom:67%;"></li></ul></li><li><p>从三个方面进行理解：</p><ol><li><p>用什么方式记录、组织空闲块？</p></li><li><p>如何分配磁盘块</p></li><li><p>如何回收磁盘块</p></li></ol></li><li><p>存储空间管理</p><ul><li><p>空闲表法</p><ul><li><p>特点：</p><ul><li>适用于“连续分配方式”</li></ul></li><li><p>如何分配磁盘块：</p><ul><li>与<strong>内存管理中的动态分区分配</strong>很类似，为一个文件<strong>分配连续的存储空间</strong>。</li><li>可采用<strong>首次适应、最佳适应、最坏适应等算法</strong>来决定要为文件分配哪个区间。</li></ul></li><li><p>如何回收磁盘块：</p><ul><li><p>与<strong>内存管理中的动态分区分配</strong>很类似，当回收某个存储区时需要有四种情况</p><ul><li>回收区的前后都没有相邻空闲区</li><li>回收区的前后都是空闲区</li><li>回收区前面是空闲区</li><li>回收区后面是空闲区。</li></ul></li><li><p>总之，回收时需要注意表项的合并问题。</p></li></ul></li><li><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part4/image-20211113223018472.png" alt="image-20211113223018472" style="zoom:80%;"></li></ul></li><li><p>空闲链表法</p><ul><li><p><strong>操作系统保存着链头、链尾指针</strong>。</p></li><li><p>空闲盘块链：</p><ul><li>如何分配：若某文件申请 K 个盘块，则<strong>从链头开始依次摘下 K 个盘块分配</strong>，并修改空闲链的链头指针。</li><li>如何回收：<strong>回收的盘块依次挂到链尾</strong>，并修改空闲链的链尾指针。</li></ul></li><li><p>空闲盘区链：</p><ul><li>如何分配：若某文件申请 K 个盘块，则可以<strong>采用首次适应、最佳适应等算法</strong>，从链头开始检索，按照算法规则找到一个大小符合要求的空闲盘区，分配给文件。若没有合适的连续空闲块，也可以将不同盘区的盘块同时分配给一个文件，注意分配后可能要修改相应的链指针、盘区大小等数据。</li><li>如何回收：若回收区和某个空闲盘区相邻，则需要将回收区<strong>合并</strong>到空闲盘区中。若回收区没有和任何空闲区相邻，将回收区作为单独的一个空闲盘区<strong>挂到链尾</strong>。</li></ul></li><li><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part4/image-20211113223526372.png" alt="image-20211113223526372" style="zoom:80%;"></li></ul></li><li><p>位示图法（常考）</p><ul><li>每个二进制位对应一个盘块。<ul><li>位示图一般用连续的“字”来表示，如本例中一个字的字长是 16 位，<strong>字中的每一位对应一个盘块</strong>。</li><li>可以用（<strong>字号，位号</strong>）对应一个盘块号。当然有的题目中也描述为（<strong>行号，列号</strong>）</li></ul></li><li>重要：要能自己推出盘块号与（字号，位号）相互转换的公式。<ul><li>注意题目条件，盘块号、字号、位号到底是从 0 开始还是从 1 开始</li><li>（字号，位号）=（i，j）的二进制位对应的*<em>盘块号 b = n * i + j*</em></li><li>b 号盘块对应的<strong>字号 i = b / n，位号 j = b % n</strong>。</li></ul></li><li>如何分配：若文件需要 K 个块<ul><li>顺序扫描位示图，找到 K 个相邻或不相邻的“0”</li><li>根据字号、位号算出对应的盘块号，将相应盘块分配给文件</li><li>将相应位设置为“1”。</li></ul></li><li>如何回收：<ul><li>根据回收的盘块号计算出对应的字号、位号</li><li>将相应二进制位设为“0” </li></ul></li><li><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part4/image-20211114190154046.png" alt="image-20211114190154046" style="zoom:80%;"></li></ul></li><li><p>成组链接法</p><ul><li>针对问题：<strong>空闲表法、空闲链表法不适用于大型文件系统</strong>，因为空闲表或空闲链表可能过大。</li><li>改进方向：UNIX 系统中采用了成组链接法对磁盘空闲块进行管理。</li><li>文件卷的<strong>目录区中专门用一个磁盘块作为“超级块”</strong>，当系统<strong>启动时需要将超级块读入内存</strong>。并且要<strong>保证内存与外存中的“超级块”数据一致</strong>。</li><li>下一组（指第二列）空闲盘块数为 100；（第一列）有 99 个指针指向真正空闲的盘区，第一个指针指向的盘块记录下下组（第三列）的空闲盘块信息。</li><li>如何分配：<ul><li>先从下一组（第二列）中取，同时删去第一列对应的指针，减少下一组空闲盘块数</li><li>若下一组（第二列）分配完，则超级块更新内容（复制第一个空闲块的信息），指向第三组的信息，同时第二列第一块空闲被分配。</li><li><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part4/image-20211114192427463.png" alt="image-20211114192427463"></li></ul></li><li>如何回收：<ul><li>需要将超级块中的数据复制到新回收的块中，并修改超级块的内容，让新回收的块成为第一个分组。</li><li><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part4/image-20211114193521443.png" alt="image-20211114193521443"></li></ul></li></ul></li></ul></li></ul><h3 id="文件的基本操作"><a href="#文件的基本操作" class="headerlink" title="文件的基本操作"></a>文件的基本操作</h3><p><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part4/image-20211114203102662.png" alt="image-20211114203102662"></p><ul><li><p>创建文件</p><ul><li><p>需要提供的参数：</p><ul><li>所需的外存空间大小（如，一个盘块，即 1KB）</li><li>文件存放路径（如，“D:/Demo”）</li><li>文件名（如，“新建文本文档.txt”）</li></ul></li><li><p>操作系统处理 Create 系统调用：</p><ul><li><strong>在外存中找到文件所需的空间</strong>（<strong>分配空闲的磁盘空间</strong>）</li><li>根据文件存放路径的信息找到<strong>该目录对应的目录文件</strong>，在目录中<strong>创建该文件对应的目录项</strong>。目录项中包含了文件名、文件在外存中的存放位置等信息。</li></ul></li></ul></li><li><p>删除文件</p><ul><li><p>需要提供的参数：</p><ul><li>文件存放路径（如，“D:/Demo”）</li><li>文件名（如，“test.txt”）</li></ul></li><li><p>操作系统处理 Delete 系统调用：</p><ul><li>根据文件存放路径找到相应的目录文件，从目录中<strong>找到文件名对应的目录项</strong>。</li><li>根据该目录项记录的文件在外存的存放位置、文件大小等信息，<strong>回收文件占用的磁盘块</strong>。（<strong>回收空闲的磁盘空间</strong>）</li><li>从目录表中<strong>删除文件对应的目录项</strong>。</li></ul></li></ul></li><li><p>打开文件</p><ul><li><p>需要提供的参数：</p><ul><li>文件存放路径（如，“D:/Demo”）</li><li>文件名（如，“test.txt”）</li><li>要对文件的操作类型（如，r 只读、rw 读写等）</li></ul></li><li><p>操作系统处理 open 系统调用：</p><ul><li>根据文件存放路径找到相应的目录文件，从目录中<strong>找到文件名对应的的目录项</strong>，并<strong>检查该用户是否有指定的操作权限</strong>。</li><li><strong>将目录项复制到内存中的“打开文件表”中</strong>。并将对应表目的编号返回给用户。之后<strong>用户使用打开文件表的编号来指明要操作的文件</strong>。</li></ul></li><li><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part4/image-20211114195520247.png" alt="image-20211114195520247" style="zoom: 67%;"></li><li><p>进程的打开文件表和系统的打开文件表</p><ul><li><p>进程的打开文件表记录</p><ul><li>读写指针：记录了该进程对文件的读/写操作进行到的位置。每个进程都有不同的指针指向不同位置。</li><li>访问模式：如果打开文件时声明的是“只读”，则该进程不能对文件进行写操作</li></ul></li><li><p>系统的打开文件表记录（系统唯一）</p><ul><li>打开计数器：记录此时有多少个进程打开了此文件。若多个进程占用，则不允许删除。</li></ul></li><li><p><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part4/image-20211114200250821.png" alt="image-20211114200250821"></p></li></ul></li></ul></li><li><p>关闭文件</p><ul><li>操作系统处理 Close 系统调用：<ul><li>将进程的打开文件表响应的表项删除</li><li>回收分配给该文件的内存空间等资源</li><li>系统打开文件表的打开计数器 -1，若 count=0，则删除对应表项</li></ul></li></ul></li><li><p>读文件</p><ul><li>需要提供的参数：<ul><li>指明哪个文件（<strong>在读文件之前已经打开文件了，所以只需要指明文件在进程的打开文件表中的索引号即可</strong>）</li><li>指明读入多少数据</li><li>指明<strong>从外存读入</strong>的数据要放在内存中的位置</li></ul></li><li>操作系统处理 Read 系统调用：<ul><li>从<strong>读指针指向的外存</strong>中，将用户指定大小的数据读入用户指定的内存区域中。</li></ul></li></ul></li><li><p>写文件</p><ul><li>需要提供的参数：<ul><li>指明哪个文件（<strong>指明文件在进程的打开文件表中的索引号</strong>）</li><li>指明写出多少数据</li><li>指明<strong>写回外存</strong>的数据放在内存中的位置</li></ul></li><li>操作系统处理 Write 系统调用：<ul><li>从用户指定的内存区域中，将指定大小的数据写回<strong>写指针指向的外存</strong>。</li></ul></li></ul></li></ul><h3 id="文件系统的层次结构"><a href="#文件系统的层次结构" class="headerlink" title="文件系统的层次结构"></a>文件系统的层次结构</h3><p><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part4/image-20211114203949942.png" alt="image-20211114203949942"></p><p>辅助记忆：假设某用户请求删除文件 “D:/工作目录/学生信息.xlsx” 的最后100条记录。</p><ol><li><p>用户需要通过操作系统提供的接口发出请求——<strong>用户接口</strong></p></li><li><p>由于提供的是文件的存放路径，因此需要操作系统一层一层地查找目录，找到对应的目录项——<strong>文件目录系统</strong></p></li><li><p>不同的用户对文件有不同的操作权限，因此为了保证安全，需要检查用户是否有访问权限——<strong>存取控制模块（存取控制验证层）</strong></p></li><li><p>验证了用户的访问权限之后，需要把用户提供的“记录号”转变为对应的逻辑地址——<strong>逻辑文件系统与文件信息缓冲区</strong></p></li><li><p>知道了目标记录对应的逻辑地址后，还需要转换成实际的物理地址——<strong>物理文件系统</strong></p></li><li><p>要删除这条记录，必定要对磁盘设备发出请求——<strong>设备管理程序模块</strong></p></li><li><p>删除这些记录后，会有一些盘块空闲，因此要将这些空闲盘块回收——<strong>辅助分配模块</strong></p></li></ol><h2 id="磁盘组织与管理"><a href="#磁盘组织与管理" class="headerlink" title="磁盘组织与管理"></a>磁盘组织与管理</h2><h3 id="磁盘的结构"><a href="#磁盘的结构" class="headerlink" title="磁盘的结构"></a>磁盘的结构</h3><p><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part4/image-20211115125801360.png" alt="image-20211115125801360"></p><ul><li>磁盘：磁盘的<strong>表面由一些磁性物质组成</strong>，可以用这些磁性物质来<strong>记录二进制数据</strong>。</li><li>磁道：磁盘的盘面被划分成一个个磁道，一个“圈”就是一个磁道</li><li>扇区：一个磁道被划分成多个扇区，<strong>每个扇区</strong>就是一个“<strong>磁盘块</strong>”。各个扇区存放的数据量相同（如1KB）<ul><li>最内侧磁道上的扇区面积最小，因此数据密度最大</li><li>重要：<strong>每个扇区</strong>就是一个“<strong>磁盘块</strong>”！</li></ul></li><li>盘面：一个盘片可能会有两个盘面</li><li>磁头：每个盘面对应一个磁头。<strong>所有的磁头只能共进退</strong>。</li><li><strong>磁盘的物理地址</strong><ul><li><strong>可用（柱面号，盘面号，扇区号）来定位任意一个“磁盘块”</strong>。外存中的块号就可以转换成（柱面号，盘面号，扇区号）的地址形式。</li><li>读取一个“块”的流程<ul><li>根据“柱面号”移动磁臂，让磁头指向<strong>指定柱面</strong>；</li><li><strong>激活指定盘面对应的磁头</strong>；</li><li>磁盘旋转的过程中，指定的扇区从磁头下面划过，完成对指定扇区的读/写。</li></ul></li></ul></li><li>磁盘的分类<ul><li>根据磁头分类：<ul><li>磁头可以移动的称为<strong>活动头磁盘</strong>。磁臂可以来回伸缩来带动磁头定位磁道</li><li>磁头不可移动的称为<strong>固定头磁盘</strong>。这种磁盘中每个磁道有一个磁头</li></ul></li><li>根据是否可以更换分类：<ul><li>盘片可以更换的称为<strong>可换盘磁盘</strong>。</li><li>盘片不可更换的称为<strong>固定盘磁盘</strong>。</li></ul></li></ul></li><li><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part4/image-20211115125719713.png" alt="image-20211115125719713"></li></ul><h3 id="磁盘调度算法"><a href="#磁盘调度算法" class="headerlink" title="磁盘调度算法"></a>磁盘调度算法</h3><p><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part4/image-20211115125939512.png" alt="image-20211115125939512"></p><ul><li><p>一次磁盘读/写操作需要的时间</p><ul><li>**寻找时间（寻道时间）T<del>S</del>**：在读/写数据前，将磁头移动到指定磁道所花的时间。<ul><li><strong>启动磁头臂</strong>是需要时间的。假设耗时为 s；</li><li><strong>移动磁头</strong>也是需要时间的。假设磁头匀速移动，每跨越一个磁道耗时为 m，总共需要跨越 n 条磁道；</li><li>寻道时间 *<em>T<del>S</del> = s + m * n*</em> </li></ul></li><li>**延迟时间 T<del>R</del>**：通过旋转磁盘，使磁头定位到目标扇区所需要的时间。<ul><li>设磁盘转速为 r （单位：转/秒，或 转/分）<ul><li>硬盘的典型转速为 5400 转/分，或 7200 转/分</li></ul></li><li>平均所需的延迟时间 *<em>T<del>R</del> = (1/2)</em>(1/r) = 1/2r**<ul><li>找到目标扇区平均需要转半圈，因此再乘以 1/2</li></ul></li></ul></li><li>**传输时间 T<del>t</del>**：从磁盘读出或向磁盘写入数据所经历的时间<ul><li>假设磁盘转速为 r，此次读/写的字节数为 b，每个磁道上的字节数为 N</li><li>传输时间 *<em>T<del>t</del> = (1/r) * (b/N) = b/(rN)*</em></li></ul></li><li>延迟时间、传输时间都<strong>与磁盘转速为线性相关</strong>。而转速是硬件的固有属性，因此<strong>操作系统无法优化延迟时间和传输时间</strong></li><li><strong>移动磁头</strong>所花费的时间，是磁盘调度算法影响的指标</li></ul></li><li><p>磁盘调度算法</p><ul><li><p>先来先服务算法（FCFS）</p><ul><li>算法思想：根据进程请求访问磁盘的先后顺序进行调度。<ul><li><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part4/image-20211115131917033.png" alt="image-20211115131917033" style="zoom: 80%;"></li></ul></li><li>优点：公平；如果请求访问的磁道比较集中，则算法性能还行</li><li>缺点：如果有大量进程竞争使用磁盘，请求访问的磁道很分散，则 FCFS 在性能上很差，寻道时间长。</li></ul></li><li><p>最短寻找时间优先（SSTF）</p><ul><li>算法思想：SSTF 算法会优先处理的磁道是与当前磁头最近的磁道。<ul><li><strong>可以保证每次的寻道时间最短，但是并不能保证总的寻道时间最短</strong>。</li><li><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part4/image-20211115132033429.png" alt="image-20211115132033429" style="zoom:80%;"></li></ul></li><li>优点：性能较好，平均寻道时间短</li><li>缺点：<strong>可能产生“饥饿”现象</strong></li></ul></li><li><p>扫描算法（SCAN）</p><ul><li>针对问题：SSTF 算法会产生饥饿</li><li>问题原因：磁头有可能<strong>在一个小区域内来回移动</strong>。</li><li>算法思想：<strong>扫描算法（电梯算法）规定，只有磁头移动到最外侧磁道的时候才能往内移动，移动到最内侧磁道的时候才能往外移动</strong>。<ul><li><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part4/image-20211115132330637.png" alt="image-20211115132330637" style="zoom:80%;"></li></ul></li><li>优点：性能较好，平均寻道时间较短，不会产生饥饿现象</li><li>缺点：<ul><li>只有到达最边上的磁道才能改变磁头移动方向。</li><li><strong>对于各个位置磁道的响应频率不平均</strong></li></ul></li></ul></li><li><p>LOOK 调度算法</p><ul><li>针对问题：扫描算法只有到达最边上的磁道才能改变磁头移动方向。</li><li>算法思想：<strong>如果在磁头移动方向上已经没有别的请求，就可以立即改变磁头移动方向</strong>。（边移动边观察，因此叫 LOOK）<ul><li><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part4/image-20211115132956097.png" alt="image-20211115132956097" style="zoom:80%;"></li></ul></li><li>优点：比起 SCAN 算法，<strong>使寻道时间进一步缩短</strong>。</li></ul></li><li><p>循环扫描算法（C-SCAN）</p><ul><li>针对问题：扫描算法对于各个位置磁道的响应频率不平均。</li><li>算法思想：规定<strong>只有磁头朝某个特定方向移动时才处理磁道访问请求</strong>，而<strong>返回时直接快速移动至起始端而不处理任何请求</strong>。<ul><li><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part4/image-20211115133606481.png" alt="image-20211115133606481" style="zoom:80%;"></li></ul></li><li>优点：比起 SCAN，对于各个位置磁道的响应频率很平均。</li><li>缺点：<ul><li>只有到达最边上的磁道时才能改变磁头移动方向</li><li>磁头返回时其实只需要返回到 18 号磁道即可，不需要返回到最边缘的磁道。</li><li>比起 SCAN 算法，平均寻道时间更长。</li></ul></li></ul></li><li><p>C-LOOK 调度算法</p><ul><li>算法思想：如果磁头移动的方向上已经没有磁道访问请求了，就可以立即让磁头返回，并且磁头只需要返回到有磁道访问请求的位置即可。<ul><li>也就是 C-SCAN + LOOK</li><li><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part4/image-20211115133949701.png" alt="image-20211115133949701" style="zoom:80%;"></li></ul></li><li>优点：比起 C-SCAN 算法，不需要每次都移动到最外侧或最内侧才改变磁头方向，<strong>使寻道时间进一步缩短</strong></li></ul></li><li><blockquote><p>若题目中无特别说明， 则 SCAN 就是 LOOK， C-SCAN 就是 C-LOOK</p></blockquote></li></ul></li></ul><h3 id="减少磁盘延迟时间的方法"><a href="#减少磁盘延迟时间的方法" class="headerlink" title="减少磁盘延迟时间的方法"></a>减少磁盘延迟时间的方法</h3><p><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part4/image-20211115150136330.png" alt="image-20211115150136330"></p><ul><li>针对问题：磁头读入一个扇区数据后需要一小段时间处理，如果<strong>逻辑上相邻的扇区在物理上也相邻，则将花费很长的延迟时间</strong></li><li>减少延迟时间的方法：<strong>交替编号</strong><ul><li>采用交替编号的策略，即让逻辑上相邻的扇区在物理上有一定的间隔，可以使读取连续的逻辑扇区所需要的延迟时间更小。</li><li><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part4/image-20211115145219763.png" alt="image-20211115145219763" style="zoom: 67%;"></li></ul></li><li><strong>磁盘地址结构的设计</strong><ul><li><strong>磁盘的物理地址是（柱面号，盘面号，扇区号）</strong>而不是（盘面号，柱面号，扇区号）</li><li>原因：读取地址连续的磁盘块时，采用（柱面号，盘面号，扇区号）的地址结构<strong>可以减少磁头移动消耗的时间</strong>，<strong>仅需激活不同盘面上的磁头</strong>。</li></ul></li><li>减少延迟时间的方法：<strong>错位命名</strong><ul><li>为了在读取地址连续的磁盘块、切换盘面激活磁头时，需要空出间隔保证磁头启动。</li><li><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part4/image-20211115145913456.png" alt="image-20211115145913456" style="zoom:67%;"></li></ul></li></ul><h3 id="磁盘的管理"><a href="#磁盘的管理" class="headerlink" title="磁盘的管理"></a>磁盘的管理</h3><p><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part4/image-20211115150211019.png" alt="image-20211115150211019"></p><ul><li>磁盘初始化：<ol><li>进行<strong>低级格式化（物理格式化）</strong>，将磁盘的各个磁道划分为扇区。一个扇区通常可分为<strong>头</strong>、<strong>数据区域</strong>（如 512B 大小）、<strong>尾</strong>三个部分组成。<ul><li>管理扇区所需要的各种数据结构一般存放在<strong>头、尾</strong>两个部分，包括扇区校验码（如奇偶校验、CRC 循环冗余校验码等）</li></ul></li><li>将磁盘分区，每个分区由若干柱面组成（即分为我们熟悉的 C盘、D盘、E盘）<ul><li><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part4/image-20211115151139969.png" alt="image-20211115151139969" style="zoom:50%;"></li></ul></li><li>进行<strong>逻辑格式化</strong>，<strong>创建文件系统</strong>。包括创建文件系统的根目录、初始化存储空间管理所用的数据结构（如 位示图、空闲分区表）</li></ol></li><li>引导块：<ul><li>计算机开机时需要进行初始化，这些初始化工作是通过执行<strong>初始化程序（自举程序）</strong>完成的<ul><li>出厂时在主板上将集成一块<strong>不可修改的 ROM</strong>（只读存储器），其中只存放很小的“<strong>自举装入程序</strong>”</li><li>完整的自举程序放在磁盘的启动块（即<strong>引导块/启动分区</strong>）上，<strong>启动块位于磁盘的固定位置</strong>。</li><li>开机时计算机先运行“自举装入程序”，通过执行该程序就可找到引导块，并将完整的“自举程序”读入内存，完成初始化</li></ul></li><li>拥有启动分区的磁盘称为<strong>启动磁盘</strong>或<strong>系统磁盘</strong>。</li></ul></li><li>坏块的管理<ul><li>对于简单的磁盘，可以在<strong>逻辑格式化</strong>时对整个磁盘进行坏块检查，标明哪些扇区是坏扇区，比如：在文件分配表（FAT）上标明。<ul><li>在这种方式中，<strong>坏块对操作系统不透明</strong>。</li></ul></li><li>对于复杂的磁盘，磁盘控制器（磁盘设备内部的一个硬件部件）会维护一个坏块链表。<ul><li>在磁盘出厂前进行低级格式化（物理格式化）时就将坏块链进行初始化。</li><li>会保留一些<strong>备用扇区</strong>，用于替换坏块。这种方案称为<strong>扇区备用</strong>。</li><li>这种处理方式中，<strong>坏块对操作系统透明</strong>。 </li></ul></li></ul></li></ul>]]></content>
    
    
    <summary type="html">文件管理</summary>
    
    
    
    <category term="操作系统" scheme="https://nephrencake.gitee.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
  </entry>
  
  <entry>
    <title>操作系统-Part3</title>
    <link href="https://nephrencake.gitee.io/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part3/"/>
    <id>https://nephrencake.gitee.io/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part3/</id>
    <published>2021-11-01T01:43:49.000Z</published>
    <updated>2021-11-16T08:41:07.964Z</updated>
    
    <content type="html"><![CDATA[<h1 id="操作系统-Part3——内存管理"><a href="#操作系统-Part3——内存管理" class="headerlink" title="操作系统-Part3——内存管理"></a>操作系统-Part3——内存管理</h1><p>[TOC]</p><h2 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h2><h3 id="内存的基础知识"><a href="#内存的基础知识" class="headerlink" title="内存的基础知识"></a>内存的基础知识</h3><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part3/image-20211106201311424.png" alt="image-20211106201311424" style="zoom:100%;"><ul><li>编译：由编译程序将用户<strong>源代码</strong>编译成若干个<strong>目标模块</strong>（编译就是把高级语言翻译为机器语言）</li><li>链接：由链接程序将编译后形成的一组目标模块，以及所需库函数链接在一起，形成一个完整的<strong>装入模块</strong></li><li>装入（装载）：由装入程序<strong>将装入模块装入内存</strong>运行</li><li><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part3/image-20211106201147384.png" alt="image-20211106201147384"></li></ul><h4 id="装入的三种方式"><a href="#装入的三种方式" class="headerlink" title="装入的三种方式"></a>装入的三种方式</h4><ul><li><strong>绝对装入</strong>：<ul><li>编译后，在可执行文件中<strong>直接指出程序装入内存后的绝对地址</strong>。</li><li><strong>由编译器完成</strong>，因为此时还未出现操作系统。</li><li><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part3/image-20211106184745104.png" alt="image-20211106184745104" style="zoom:67%;"></li><li>缺点：<ul><li>只适用于一台机器</li><li>只适用于单道程序环境</li></ul></li><li>程序中使用的绝对地址，可在编译或汇编时给出，也可由程序员直接赋予。通常情况下都是编译或汇编时再转换为绝对地址。</li></ul></li><li><strong>静态重定位</strong>（可重定位装入）：<ul><li>编译后，装入模块的地址都是从 0 开始的，指令中使用的地址、数据存放的地址都是相对于起始地址而言的<strong>逻辑地址</strong>。</li><li>根据内存的情况，将装入模块装入到内存的适当位置。装入时对地址进行“重定位”，将逻辑地址变换为物理地址（<strong>地址变换是在装入时一次完成的</strong>）。</li><li><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part3/image-20211106184445773.png" alt="image-20211106184445773" style="zoom: 67%;"></li><li>特点：<ul><li>在一个作业装入内存时，<strong>必须分配其要求的全部内存空间</strong>，如果没有足够的内存，就不能装入该作业。</li><li>作业一旦进入内存后，<strong>在运行期间就不能再移动</strong>，也不能再申请内存空间。</li></ul></li></ul></li><li><strong>动态重定位</strong>（动态运行时装入）：<ul><li>编译后，装入模块的地址都是从 0 开始的，指令中使用的地址、数据存放的地址都是相对于起始地址而言的<strong>逻辑地址</strong>。（同静态重定位）</li><li>装入程序把装入模块装入内存后，<strong>并不会把逻辑地址转换为物理地址</strong>，而是<strong>把地址转换推迟到程序真正执行时进行</strong>。因此装入内存后所有的地址依然是<strong>逻辑地址</strong>。这种方式需要一个<strong>重定位寄存器</strong>的支持，用于<strong>存放装入模块的起始位置</strong>。</li><li><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part3/image-20211106200839645.png" alt="image-20211106200839645" style="zoom:67%;"></li><li>特点：<ul><li><strong>可将程序分配到不连续的存储区中</strong></li><li>程序<strong>只需装入部分代码</strong>即可运行，并根据需要<strong>动态申请分配内存</strong></li><li>便于程序段的共享，可以向用户提供一个比存储空间大得多的地址空间</li><li>采用动态重定位时<strong>允许程序在内存中发生移动</strong></li></ul></li></ul></li></ul><h4 id="链接的三种方式"><a href="#链接的三种方式" class="headerlink" title="链接的三种方式"></a>链接的三种方式</h4><ul><li><strong>静态链接</strong>：<ul><li>在程序运行之前，先将各目标模块及它们所需的库函数连接成一个完整的可执行文件（装入模块），之后不再拆开。</li><li><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part3/image-20211106201450752.png" alt="image-20211106201450752" style="zoom: 67%;"></li></ul></li><li><strong>装入时动态链接</strong>：<ul><li>将各目标模块装入内存时，边装入边链接的链接方式。</li><li><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part3/image-20211106201530718.png" alt="image-20211106201530718" style="zoom:67%;"></li></ul></li><li><strong>运行时动态链接</strong>：<ul><li>在程序执行中需要该目标模块时，才对它进行链接。其优点是便 于修改和更新，便于实现对目标模块的共享。</li><li>优点：灵活性更高，提高对内存的利用率</li><li><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part3/image-20211106201608804.png" alt="image-20211106201608804" style="zoom:67%;"></li></ul></li></ul><h3 id="内存管理的概念"><a href="#内存管理的概念" class="headerlink" title="内存管理的概念"></a>内存管理的概念</h3><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part3/image-20211106203022788.png" alt="image-20211106203022788" style="zoom:100%;"><p>操作系统对内存管理需要实现的四个功能</p><ul><li>操作系统需要负责<strong>内存空间的分配与回收</strong></li><li>操作系统需要提供某种技术从逻辑上<strong>对内存空间进行扩充</strong></li><li>操作系统需要提供<strong>地址转换功能</strong>，负责程序的逻辑地址与物理地址的转换<ul><li>即装入的三种方式：绝对装入、可重定位装入（静态重定位）、动态运行时装入（动态重定位）</li></ul></li><li>操作系统需要提供<strong>内存保护</strong>功能。保证各进程在各自存储空间内运行，互不干扰<ul><li>方法一：在 CPU 中设置<strong>一对上、下限寄存器</strong>，存放进程的上、下限地址。进程的指令要访问某个地址时，CPU 检查是否越界。</li><li>方法二：采用<strong>重定位寄存器（基址寄存器）</strong>和<strong>界地址寄存器（限长寄存器）</strong>进行越界检查。分别存放进程的<strong>起始物理地址</strong>和<strong>最大逻辑地址</strong>。</li></ul></li></ul><h3 id="覆盖与交换"><a href="#覆盖与交换" class="headerlink" title="覆盖与交换"></a>覆盖与交换</h3><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part3/image-20211106204129149.png" alt="image-20211106204129149" style="zoom:100%;"><ul><li><strong>覆盖技术</strong><ul><li>思想：将程序分为多个段（多个模块）。常用的段常驻内存，不常用的段在需要时调入内存。</li><li>内存中分为一个“<strong>固定区</strong>”和若干个“<strong>覆盖区</strong>”。<ul><li>需要常驻内存的段放在“固定区”中，<strong>调入后就不再调出</strong>（除非运行结束）</li><li>不常用的段放在“覆盖区”，<strong>需要用到时调入内存，用不到时调出内存</strong><ul><li>按照自身逻辑结构，让那些<strong>不可能同时被访问</strong>的程序段共享同一个覆盖区，覆盖区大小以最大的程序段为准</li><li><strong>必须由程序员声明覆盖结构</strong>，操作系统完成自动覆盖。</li></ul></li></ul></li><li><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part3/image-20211106204512297.png" alt="image-20211106204512297" style="zoom:80%;"></li><li>缺点：对用户不透明，<strong>增加了编程负担</strong>。因此，只用于早期的操作系统中，现在已成为历史。</li></ul></li><li><strong>交换技术</strong><ul><li>思想：内存空间紧张时，系统将内存中某些进程暂时<strong>换出</strong>外存，把外存中某些已具备运行条件的进程<strong>换入</strong>内存（进程在内存与磁盘间动态调度）<ul><li>中级调度（内存调度），决定将哪个处于挂起状态的进程重新调入内存。</li><li>挂起队列中的 <strong>PCB 要负责记录挂起进程在磁盘中的位置</strong>。因此，<strong>PCB 会常驻内存</strong>，不会被换出外存</li><li>暂时换出外存等待的进程状态为<strong>挂起状态</strong>（suspend），进一步细分为<strong>就绪挂起</strong>、<strong>阻塞挂起</strong>两种状态</li></ul></li><li><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part3/image-20211107092841147.png" alt="image-20211107092841147" style="zoom:67%;"></li><li>交换的进程在外存中保存的位置<ul><li>具有对换功能的操作系统中，通常把磁盘空间分为<strong>文件区</strong>和<strong>对换区</strong>两部分。</li><li>文件区主要用于存放文件，主要追求<strong>存储空间的利用率</strong>，因此对文件区空间的管理采用<strong>离散分配方式</strong></li><li>对换区空间只占磁盘空间的小部分，用于存放被换出的进程数据，主要追求<strong>换入换出速度</strong>以提升系统的整体速度，因此通常对换区采用<strong>连续分配方式</strong>。</li><li>总之，对换区的 I/O 速度比文件区的更快。</li></ul></li><li>交换的时机<ul><li>交换通常在许多进程运行且内存吃紧（经常发生缺页）时进行，而系统负荷降低（缺页率明显下降）就暂停。</li></ul></li><li>交换的对象进程<ul><li>可优先换出<strong>阻塞进程</strong></li><li>可换出<strong>优先级低的进程</strong></li><li>为了防止优先级低的进程在频繁调入调出内存，有的系统还会考虑<strong>进程在内存的驻留时间</strong></li></ul></li></ul></li></ul><h3 id="连续分配管理方式"><a href="#连续分配管理方式" class="headerlink" title="连续分配管理方式"></a>连续分配管理方式</h3><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part3/image-20211107094033664.png" alt="image-20211107094033664" style="zoom:100%;"><ul><li><strong>连续分配</strong>：为用户进程分配的必须是一个<strong>连续的内存空间</strong>。</li><li><strong>非连续分配</strong>：为用户进程分配的可以是一些<strong>分散的内存空间</strong>。</li></ul><p>三种连续分配方式：</p><ul><li><strong>单一连续分配</strong><ul><li>在单一连续分配方式中，内存被分为<strong>系统区</strong>和<strong>用户区</strong>。<ul><li>系统区通常位于<strong>内存的低地址部分</strong>，用于存放操作系统相关数据；用户区用于存放用户进程相关数据。</li><li>内存中只能有一道用户程序，用户程序<strong>独占</strong>整个用户区空间。</li><li><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part3/image-20211107095633275.png" alt="image-20211107095633275" style="zoom:50%;"></li></ul></li><li>优点：<ul><li>实现简单</li><li><strong>无外部碎片</strong></li><li>可以采用覆盖技术扩充内存</li><li><strong>不一定</strong>需要采取内存保护（eg：早期的 PC 操作系统 MS-DOS）。</li></ul></li><li>缺点：<ul><li>只能用于<strong>单用户、单任务</strong>的操作系统中</li><li><strong>有内部碎片</strong>（分配给某进程的内存区域中，没有使用的部分）</li><li><strong>存储器利用率极低</strong>。</li></ul></li></ul></li><li><strong>固定分区分配</strong><ul><li>将整个<strong>用户空间</strong>划分为<strong>若干个固定大小的分区</strong>，在<strong>每个分区中只装入一道作业</strong>。是最早的、最简单的一种可运行多道程序、不会相互干扰的内存管理方式。<ul><li><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part3/image-20211107095934415.png" alt="image-20211107095934415" style="zoom: 50%;"></li></ul></li><li>特点：<ul><li><strong>分区大小相等</strong>：缺乏灵活性，但是很适合用于用一台计算机控制多个相同对象的场合<ul><li>比如：钢铁厂有 n 个相同的炼钢炉，就可把内存分为 n 个大小相等的区域存放 n 个炼钢炉控制程序</li></ul></li><li><strong>分区大小不等</strong>：增加了灵活性，可以满足不同大小的进程需求。根据常在系统中运行的作业大小情况进行划分<ul><li>比如：划分多个小分区、适量中等分区、少量大分区</li></ul></li></ul></li><li><strong>分区说明表</strong><ul><li>实现各个分区的分配与回收。每个表项对应一个分区，通常按分区大小排列。每个表项包括对应分区的<strong>大小</strong>、<strong>起始地址</strong>、<strong>状态</strong>（是否已分配）。</li><li><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part3/image-20211107100114456.png" alt="image-20211107100114456" style="zoom:67%;"></li><li>优点：实现简单，<strong>无外部碎片</strong>。</li><li>缺点：<ul><li>当用户程序太大时，可能所有的分区都不能满足需求，此时不得不采用覆盖技术来解决，但这又会降低性能</li><li>会产生内部碎片，内存利用率低。</li></ul></li></ul></li></ul></li><li><strong>动态分区分配</strong><ul><li>动态分区分配（可变分区分配），<strong>不会预先划分内存分区</strong>，而是在进程装入内存时，<strong>根据进程的大小动态地建立分区</strong>，并使分区的大小正好适合进程的需要。<ul><li>因此系统分区的大小和数目是可变的。</li></ul></li><li>记录内存使用情况的数据结构<ul><li>两种常用的数据结构：<strong>空闲分区表</strong>、<strong>空闲分区链</strong></li><li><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part3/image-20211107101014557.png" alt="image-20211107101014557"></li></ul></li><li>多个空闲分区的分配选择<ul><li>四种<strong>动态分区分配算法</strong></li></ul></li><li>分区的分配与回收<ul><li>回收内存分区时，相邻分区需要合并<ul><li>回收区的后面有一个相邻的空闲分区（修改分区大小和起始地址）</li><li>回收区的前面有一个相邻的空闲分区（修改分区大小）</li><li>回收区的前、后各有一个相邻的空闲分区（合并分区表项，修改分区大小）</li><li>回收区的前、后都没有相邻的空闲分区（新建分区表项）</li></ul></li><li>注：各表项的顺序不一定按照地址递增顺序排列，需要依据动态分区分配算法来确定。</li></ul></li><li>动态分区分配<strong>没有内部碎片</strong>，但是<strong>有外部碎片</strong>。<ul><li>内部碎片，内存中<strong>进程所属的分区中</strong>没有利用的部分</li><li>外部碎片，内存中<strong>非进程所属分区中</strong>没有利用的部分</li><li>可以通过<strong>紧凑</strong>（拼凑，Compaction）技术来解决外部碎片。<ul><li>移动进程分区首地址以腾出连续空间</li><li>适用于<strong>动态重定位</strong></li><li>紧凑之后需要修改 CPB 中的起始地址信息</li></ul></li></ul></li></ul></li></ul><h3 id="动态分区分配算法"><a href="#动态分区分配算法" class="headerlink" title="动态分区分配算法"></a>动态分区分配算法</h3><ul><li>首次适应算法（First Fit）<ul><li>算法思想：从低地址开始找到第一个适合的分区</li><li>分区排列顺序：空闲分区以<strong>地址递增</strong>次序排列</li><li>优点：<ul><li><strong>综合看性能最好</strong>。<strong>算法开销小</strong>（回收分区后不需要对空闲分区队列重新排序）</li><li>每次都需要检索低地址的小分区。有可能把高地址部分的大分区保留下来（最佳适应算法的优点）</li></ul></li></ul></li><li>最佳适应算法（Best Fit）<ul><li>算法思想：优先使用更小的分区，以保留更多大分区</li><li>分区排列顺序：空闲分区以<strong>容量递增</strong>次序排列</li><li>优点：会有更多的大分区被保留下来，更能满足大进程需求</li><li>缺点：会产生越来越多太小的、难以利用的碎片；<strong>算法开销大</strong>（回收分区后可能需要对空闲分区队列重新排序）</li></ul></li><li>最坏适用算法（Worst Fit）<ul><li>算法思想：优先使用更大的分区，以防止产生太小的不可用的碎片</li><li>分区排列顺序：空闲分区以<strong>容量递减</strong>次序排列</li><li>优点：可以减少难以利用的小碎片</li><li>缺点：大分区容易被用完，不利于后续的大进程；<strong>算法开销大</strong></li></ul></li><li>临近适应算法（Next Fit）<ul><li>算法思想：由首次适应演变而来，每次从上次查找结束位置开始查找</li><li>分区排列顺序：空闲分区以<strong>地址递增</strong>次序排列（可排列成循环链表）</li><li>优点：不用每次都从低地址的小分区开始检索。<strong>算法开销小</strong></li><li>缺点：可能会使高地址的大分区也被用完</li></ul></li></ul><h3 id="基本分页存储管理的基本概念（重点）"><a href="#基本分页存储管理的基本概念（重点）" class="headerlink" title="基本分页存储管理的基本概念（重点）"></a>基本分页存储管理的基本概念（重点）</h3><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part3/image-20211108133534598.png" alt="image-20211108133534598" style="zoom:100%;"><ul><li><p>分页存储：</p><ul><li>将内存空间分为一个个<strong>大小相等的分区</strong>，每个分区就是一个<strong>页框</strong>（<strong>页框=页帧=内存块=物理块=物理页面</strong>）。<ul><li>每个页框有一个<strong>页框号</strong>（<strong>页框号=页帧号=内存块号=物理块号=物理页号</strong>），页框号从 0 开始。</li></ul></li><li>将<strong>进程的逻辑地址空间</strong>也分为<strong>与页框大小相等</strong>的一个个部分，每个部分称为一个<strong>页</strong>（<strong>页=页面</strong>） 。<ul><li>每个页面有一个“页号”，页号从 0 开始。</li></ul></li><li>注意区别：页、页面 vs 页框、页帧、物理页</li><li>操作系统<strong>以页框为单位</strong>为各个进程分配内存空间。进程的每个页面分别放入一个页框中。进程的页面与内存的页框有一一对应的关系。<ul><li>各个页面不必连续存放，可以放到不相邻的各个页框中。</li></ul></li><li>注：进程的最后一个页面可能没有一个页框那么大。即，<strong>分页存储有可能产生内部碎片</strong>。因此页框不能太大，否则可能产生过大的内部碎片造成浪费</li></ul></li><li><p>页表：</p><ul><li>一个进程对应一张页表</li><li>进程的每个页面对应一个页表项</li><li>每个<strong>页表项</strong>由“页号”和“块号”组成</li><li>页表记录<strong>进程页面</strong>和<strong>实际存放的内存块</strong>之间的映射关系</li><li>每个页表项的长度是相同的</li><li><strong>指向页表的指针存在于 PCB（进程控制块）中</strong></li><li><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part3/image-20211108115320995.png" alt="image-20211108115320995"></li></ul></li><li><p>每个页表项的长度计算</p><ul><li>Eg：假设某系统物理内存大小为 4GB，页面大小为 4KB，则每个页表项至少应该为多少字节？</li><li><strong>内存块大小</strong>=<strong>页面大小</strong>=4KB= 2^12^B <ul><li>4GB 的内存总共会被分为 2^32^ / 2^12^ = 2^20^ 个内存块</li><li>内存块号的范围应该是 0 ~ 2^20^-1 </li><li>内存块号至少要用 20bit 来表示</li><li>至少要用 3B 来表示块号（3*8=24bit）<ul><li>重要考点：计算机中<strong>内存块的数量</strong> -&gt; 页表项中<strong>块号至少占多少字节</strong></li></ul></li><li>页表中的<strong>页号是隐含的</strong>，即<strong>页号不占用存储空间</strong></li></ul></li><li>每个页表项占 3B，存储整个页表至少需要 (n+1)*3B</li><li>注意：页表记录的只是内存块号，而不是内存块的起始地址。*<em>J 号内存块的起始地址 = J * 内存块大小*</em></li></ul></li><li><p>实现地址的转换（重点）</p><ul><li><blockquote><p>逻辑地址A对应的物理地址 = P号页面在内存中的起始地址 + 页内偏移量W</p></blockquote><ul><li><strong>页号 = 逻辑地址 / 页面长度</strong></li><li><strong>页内偏移量 = 逻辑地址 % 页面长度</strong></li><li>*<em>起始地址 = 页表[页号] * 内存块大小*</em></li></ul></li><li><p>如果页面大小为 2^K^B，逻辑地址可以快速拆分为页号、页内偏移量</p><ul><li>在逻辑地址中，<strong>末尾 K 位为页内偏移量</strong>，其余前半部分为页号</li><li>在物理地址中，末尾 K 位为页内偏移量，<strong>其余前半部分为页表[页号]</strong></li><li><blockquote><p>即，对于页面大小为 2^K^B 的情况来说，直接将逻辑地址的<strong>页号</strong>部分替换成<strong>页框号</strong></p></blockquote></li></ul></li></ul></li><li><p>逻辑地址结构</p><ul><li><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part3/image-20211108133314602.png" alt="image-20211108133314602" style="zoom:80%;"></li><li>地址长度为 32 位；其中 0<del>11位 为“<strong>页内偏移量</strong>”（<strong>页内地址</strong>）；12</del>31 位为“<strong>页号</strong>”。</li><li><strong>如果有 K 位表示“页内偏移量”，则说明该系统中一个页面的大小是 2^K^ 个内存单元</strong></li><li><strong>如果有 M 位表示“页号”，则说明在该系统中一个进程最多允许有 2^M^ 个页面</strong></li></ul></li></ul><h3 id="基本地址变换机构（重点）"><a href="#基本地址变换机构（重点）" class="headerlink" title="基本地址变换机构（重点）"></a>基本地址变换机构（重点）</h3><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part3/image-20211108133940207.png" alt="image-20211108133940207" style="zoom:100%;"><ul><li>基本地址变换机构可以借助进程的页表将逻辑地址转换为物理地址：（重点）<ul><li><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part3/image-20211108134704399.png" alt="image-20211108134704399" style="zoom: 80%;"></li><li>进程未执行时，<strong>页表的始址</strong>和<strong>页表长度</strong>放在<strong>进程控制块</strong>（PCB）中；当进程被调度时，操作系统内核会把它们放到页表寄存器中。</li><li>设页面大小为 L、起始地址 F、页表长度 M、逻辑地址 A 到物理地址 E 的变换过程：<ol><li>计算页号 P 和页内偏移量 W<ul><li>P=A/L，W=A%L</li></ul></li><li>比较页号 P 和页表长度 M，<strong>若 P≥M</strong>，则产生越界中断</li><li>页表中页号 P 对应的*<em>页表项地址 = 页表起始地址 F + 页号 P * 页表项长度*</em>。取出该页表项内容 b，即为内存块号。<ul><li>注意：区分<strong>页表项长度</strong>、<strong>页表长度</strong>、<strong>页面大小</strong>。</li><li>页表长度，指这个页表中总共有几个页表项，即总共有几个页</li><li>页表项长度，指的是每个页表项占多大的存储空间</li><li>页面大小，指的是一个页面占多大的存储空间</li></ul></li><li>计算 E = b * L + W，用得到的物理地址 E 去访存。<ul><li>如果内存块号、页面偏移量是用二进制表示的，则直接把二者拼接即物理地址</li></ul></li></ol></li><li>在分页存储管理（页式管理）的系统中：<ul><li><strong>页面的大小和逻辑地址结构是互相确定的</strong>：页面大小 L 为 1K 字节 == 某系统<strong>按字节寻址</strong>，逻辑地址结构中，<strong>页内偏移量占 10 位</strong></li><li><strong>页式管理中地址是一维的</strong>（只需要一个参数）：只要给出一个逻辑地址，就可以直接求得页号、页内偏移量</li></ul></li></ul></li><li>对页表项大小的进一步探讨<ul><li><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part3/image-20211110103417636.png" alt="image-20211110103417636"></li><li>一般不会考察，当问最小的页表长度时，按 3B 回答</li></ul></li></ul><h3 id="具有快表的地址变换机构"><a href="#具有快表的地址变换机构" class="headerlink" title="具有快表的地址变换机构"></a>具有快表的地址变换机构</h3><ul><li><strong>快表，联想寄存器</strong>（<strong>TLB</strong>， translation lookaside buffer）<ul><li><strong>TLB 不是内存，是 cache</strong></li><li>用来存放最近访问的页表项的<strong>副本</strong></li><li>与此对应，内存中的页表常称为<strong>慢表</strong>。</li></ul></li><li>引入快表之后的地址变换过程<ul><li><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part3/image-20211110181512724.png" alt="image-20211110181512724"></li><li>CPU 给出逻辑地址，由硬件算得页号、页内偏移量，将页号与<strong>快表中的所有页号</strong>进行比较。</li><li>若命中，则直接从 TLB 取出目标的内存块号，与页内偏移量拼接形成物理地址，访问对应的内存单元。<ul><li>因此，若<strong>快表命中</strong>，则访问某个逻辑地址<strong>仅需一次访存</strong>即可。</li></ul></li><li>若没有命中，则需要访问内存中的页表，通过页表始址和页号定位对应页表项，得到目标的内存块号，再将内存块号与页内偏移量拼接形成物理地址，访问该对应的内存单元。<ul><li>因此，若<strong>快表未命中</strong>，则访问某个逻辑地址<strong>需要两次访存</strong></li><li>在找到页表项后，应同时将其存入快表，以便后面可能的再次访问。</li><li>若快表已满，则必须按照一定的算法对旧的页表项进行替换</li><li><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part3/image-20211110182850496.png" alt="image-20211110182850496" style="zoom:80%;"></li></ul></li></ul></li><li>局部性原理<ul><li>时间局部性：如果执行了程序中的某条指令，那么不久后这条指令很有可能再次执行；如果某个数据被访问过，不久之后该数据很可能再次被访问。<ul><li>因为程序中存在大量的循环</li></ul></li><li>空间局部性：一旦程序访问了某个存储单元，在不久之后，其附近的存储单元也很有可能被访问。<ul><li>因为很多数据在内存中都是连续存放的</li></ul></li></ul></li></ul><p>总结</p><ul><li><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part3/image-20211110183624691.png" alt="image-20211110183624691"></li></ul><h3 id="两级页表"><a href="#两级页表" class="headerlink" title="两级页表"></a>两级页表</h3><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part3/image-20211110192048406.png" alt="image-20211110192048406" style="zoom:100%;"><ul><li>针对问题：<ul><li>单级页表必须连续存放，因此<strong>当页表很大时，需要占用很多个连续的页框</strong>，与离散分配存储管理相悖。</li><li>没有必要让整个页表常驻内存，因为根据局部性原理，<strong>进程在一段时间内可能只需要访问某几个特定的页面</strong>。</li></ul></li><li>改进方向：<ul><li>把页表再分页并离散存储，建立一张页表记录页表各个部分的存放位置</li><li>该页表称为<strong>页目录表/外层页表/顶层页表</strong></li></ul></li><li>二级页表的结构<ul><li><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part3/image-20211110190608035.png" alt="image-20211110190608035"></li><li>与单级页表的结构意义是相同的，前半部分来找到<strong>内存块号</strong>，后半部分为<strong>页内偏移量</strong></li><li>页目录表的 item 记录<strong>二级页表在内存中的内存块号</strong>，二级页表的 item 记录<strong>数据在内存中的内存块号</strong></li><li>页目录表、二级页表的每个页表项都增加一个标志位，用于<strong>表示该页面是否已经调入内存</strong>，否则产生<strong>缺页中断</strong>（内中断/异常）</li></ul></li><li>注意：<ul><li>若分为两级页表后，页表依然很长，则可以采用更多级页表，<strong>各级页表的大小不能超过一个页面</strong><ul><li><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part3/image-20211110191953863.png" alt="image-20211110191953863"></li></ul></li><li>两级页表的访存次数分析（假设没有快表机构）<ul><li>第一次访存：访问内存中的页目录表</li><li>第二次访存：访问内存中的二级页表</li><li>第三次访存：访问目标内存单元</li></ul></li></ul></li></ul><h3 id="基本分段存储管理方式"><a href="#基本分段存储管理方式" class="headerlink" title="基本分段存储管理方式"></a>基本分段存储管理方式</h3><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part3/image-20211111112309332.png" alt="image-20211111112309332" style="zoom:100%;"><ul><li><p>进程的地址空间：按照程序<strong>自身的逻辑</strong>关系<strong>划分为若干个段</strong>，每个段都有一个段名，<strong>每段从 0 开始编址</strong>。</p></li><li><p>内存分配规则：以段为单位进行分配，<strong>每个段在内存中占据连续空间</strong>，但<strong>各段之间可以不相邻</strong>。</p></li><li><p>分段存储管理方式的优点：按逻辑功能模块划分，<strong>编程更方便</strong>，<strong>程序的可读性更高</strong>。</p></li><li><p>分段系统的逻辑地址结构：</p><ul><li><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part3/image-20211110193605564.png" alt="image-20211110193605564" style="zoom:80%;"></li><li><strong>段号的位数决定了每个进程最多可以分几个段</strong></li><li><strong>段内地址位数决定了每个段的最大长度是多少</strong></li></ul></li><li><p>段表</p><ul><li><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part3/image-20211110194243704.png" alt="image-20211110194243704"></li><li>每个段对应一个段表项，其中记录了该段在内存中的<strong>基址</strong>和<strong>长度</strong>。</li><li><strong>各个段表项的长度是相同的</strong>。因此，<strong>段号也是隐含的</strong>。<ul><li>例如：某系统按字节寻址，采用分段存储管理，逻辑地址结构为（段号 16 位, 段内地址 16 位），因此用 16 位即可表示最大段长。物理内存大小为4GB（可用 32 位表示整个物理内存地址空间）。因此，可以让每个段表项占 16+32 = 48位，即 6B。</li></ul></li></ul></li><li><p>地址变换过程</p><ul><li><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part3/image-20211110194425962.png" alt="image-20211110194425962"></li></ul></li><li><p>信息的共享和保护</p><ul><li><p>不可修改的代码（纯代码/可重入代码）是可以共享的。可修改的代码是不能共享的。</p><ul><li>不可修改的代码<strong>不属于临界资源</strong>。</li><li>可修改的代码（代码段）可能包含很多变量，各进程并发访问可能造成数据不一致</li></ul></li><li><p>只需让各进程的<strong>段表项指向同一个段</strong>即可实现共享</p></li><li><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part3/image-20211111111620647.png" alt="image-20211111111620647" style="zoom:80%;"></li></ul></li></ul><blockquote><p><strong>分段、分页管理的对比</strong></p><ul><li>目的<ul><li><strong>页</strong>是<strong>信息的物理单位</strong>。分页的主要目的是为了实现离散分配，提高内存利用率。分页仅仅是系统管理上的需要，完全是系统行为，<strong>对用户是不可见的</strong>。 </li><li><strong>段</strong>是<strong>信息的逻辑单位</strong>。分段的主要目的是更好地满足用户需求。一个段通常包含着一组属于一个逻辑模块的信息。<strong>分段对用户是可见的</strong>，用户编程时需要显式地给出段名。</li></ul></li><li>长度<ul><li>页的大小固定且由系统决定。段的长度却不固定，决定于用户编写的程序。</li></ul></li><li>维度<ul><li><strong>分页</strong>的用户进程地址空间是<strong>一维</strong>的，只需给出<strong>一个记忆符</strong>即可表示一个地址。</li><li><strong>分段</strong>的用户进程地址空间是<strong>二维</strong>的，在标识一个地址时，既要给出<strong>段名</strong>，也要给出<strong>段内地址</strong>。</li></ul></li><li>共享与保护<ul><li>分段比分页<strong>更容易实现信息的共享和保护</strong>。不可修改的代码（纯代码/可重入代码）是可以共享的。可修改的代码是不能共享的。</li></ul></li><li>访存次数<ul><li>分页（单级页表）：查内存中的页表（第一次访存）+ 访问目标内存单元（第二次访存）。总共两次访存</li><li>分段：查内存中的段表（第一次访存）+ 访问目标内存单元（第二次访存）。总共两次访存。<ul><li>分段系统中也可以引入<strong>快表</strong>机构，将近期访问过的段表项放到快表中，这样可以少一次访问，加快地址变换速度。</li></ul></li></ul></li></ul></blockquote><h3 id="段页式管理方式"><a href="#段页式管理方式" class="headerlink" title="段页式管理方式"></a>段页式管理方式</h3><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part3/image-20211111112409226.png" alt="image-20211111112409226" style="zoom:100%;"><ul><li>针对问题：<ul><li>分页管理<ul><li><strong>优点</strong>：内存空间利用率高，<strong>不会产生外部碎片</strong>，只会有少量的页内碎片</li><li><strong>缺点</strong>：不方便按照逻辑模块实现信息的共享和保护</li></ul></li><li>分段管理<ul><li><strong>优点</strong>：很方便按照逻辑模块实现信息的共享和保护</li><li><strong>缺点</strong>：1. 当段长过大时，分配很大的连续空间会很不方便。2. <strong>会产生外部碎片</strong>（可以用“紧凑”来解决，只是需要付出较大的时间代价）</li></ul></li></ul></li><li>段页式管理的实现<ul><li><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part3/image-20211111113416029.png" alt="image-20211111113416029" style="zoom:80%;"></li><li>理论：将进程按逻辑<strong>先按模块分段</strong>，<strong>再将各段分页</strong></li><li>段页式系统的逻辑地址结构：<ul><li>由段号、页号、页内地址（页内偏移量）组成。</li><li><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part3/image-20211111114030310.png" alt="image-20211111114030310" style="zoom:80%;"></li><li><strong>段号的位数</strong>决定了<strong>每个进程最大段数</strong><ul><li>段号占 16 位，每个进程最多有 2^16^=64K 个段</li></ul></li><li><strong>页号位数</strong>决定了<strong>每个段最大页数</strong><ul><li>页号占 4 位，每个段最多有 2^4^=16 页</li></ul></li><li><strong>页内偏移量</strong>决定了<strong>页面/内存块大小</strong><ul><li>页内偏移量占 12 位，每个页面\每个内存块大小为 2^12^=4096=4KB</li></ul></li></ul></li><li>分段对用户是可见的，编程时需要<strong>显式地给出段号、段内地址</strong>。而将各段分页对用户是不可见的，系统会根据段内地址<strong>自动划分页号和页内偏移量</strong>。<ul><li><strong>段页式管理的地址结构是二维的</strong>。</li></ul></li><li><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part3/image-20211111114731857.png" alt="image-20211111114731857"><ul><li>每个段对应一个段表项，每个段表项由<strong>段号、页表长度、页表存放块号（页表起始地址）</strong>组成。每个段表项长度相等，段号是隐含的。</li><li>每个页面对应一个页表项，每个页表项由<strong>页号、页面存放的内存块号</strong>组成。每个页表项长度相等，页号是隐含的。</li></ul></li><li>地址转换过程<ul><li><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part3/image-20211111115141951.png" alt="image-20211111115141951"></li><li>得到段号、页号、页内偏移量</li><li>检查段号越界</li><li>根据段号找到段表项，取页表起始块号、长度</li><li>检查页号越界</li><li>根据页号找到页表项，取目标数据的内存块号</li><li>访问目标内存单元</li></ul></li></ul></li></ul><h2 id="虚拟内存管理"><a href="#虚拟内存管理" class="headerlink" title="虚拟内存管理"></a>虚拟内存管理</h2><h3 id="虚拟内存的基本概念"><a href="#虚拟内存的基本概念" class="headerlink" title="虚拟内存的基本概念"></a>虚拟内存的基本概念</h3><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part3/image-20211111120739916.png" alt="image-20211111120739916" style="zoom:100%;"><ul><li>传统存储管理方式的特征、缺点<ul><li>一次性：作业<strong>必须一次性全部装入</strong>内存后才能开始运行。这会造成两个问题：<ul><li>作业很大时，不能全部装入内存，导致大作业无法运行</li><li>当大量作业要求运行时，由于内存无法容纳所有作业，因此只有少量作业能运行，导致多道程序并发度下降。</li></ul></li><li>驻留性：一旦作业被装入内存，就会<strong>一直驻留在内存中</strong>，直至作业运行结束。<ul><li>事实上，在一个时间段内，只需要访问作业的一小部分数据即可正常运行，这就导致了内存中会驻留大量暂时用不到的数据，浪费了宝贵的内存资源。</li></ul></li></ul></li><li>虚拟内存的定义：<ul><li>基于局部性原理，在程序装入时，可以将程序中<strong>很快会用到的部分装入内存，暂时用不到的部分留在外存</strong>，就可以让程序开始执行。</li><li>在程序执行过程中，当所访问的<strong>信息不在内存时，由操作系统负责将所需信息从外存调入内存</strong>，然后继续执行程序。<ul><li>操作系统要提供<strong>请求调页（请求调段）</strong>功能</li></ul></li><li>若内存空间不够，由<strong>操作系统负责将内存中暂时用不到的信息换出到外存</strong>。<ul><li>操作系统要提供<strong>页面置换（段置换）</strong>的功能</li></ul></li><li>在操作系统的管理下，在用户角度看虚拟内存比实际内存大得多</li></ul></li><li>易混知识点：<ul><li>虚拟内存的<strong>最大容量</strong>是由计算机的地址结构（CPU寻址范围）确定的</li><li>虚拟内存的<strong>实际容量</strong> = min（内存和外存容量之和，CPU寻址范围）</li></ul></li><li>虚拟内存的三个主要特征：<ul><li>多次性：无需将作业一次性全部装入内存，而是<strong>允许分多次调入内存</strong>。</li><li>对换性：在作业运行时无需一直常驻内存，而是<strong>允许将作业换入、换出</strong>。</li><li>虚拟性：<strong>从逻辑上扩充了内存的容量</strong>，使用户看到的内存容量，远大于实际的容量。</li></ul></li><li>实现虚拟内存技术：<ul><li>传统的非连续分配存储管理：基本分页存储管理，基本分段存储管理，基本段页式存储管理</li><li>虚拟内存实现：请求分页存储管理，请求分段存储管理，请求段页式存储管理</li></ul></li></ul><h3 id="请求分页管理方式"><a href="#请求分页管理方式" class="headerlink" title="请求分页管理方式"></a>请求分页管理方式</h3><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part3/image-20211111133427802.png" alt="image-20211111133427802" style="zoom:100%;"><ul><li>页表机制<ul><li><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part3/image-20211111134046407.png" alt="image-20211111134046407"></li></ul></li><li>缺页中断机构<ul><li>在请求分页系统中，每当要访问的<strong>页面不在内存时</strong>，便产生一个<strong>缺页中断</strong>，然后<strong>由操作系统的缺页中断处理程序处理中断</strong>。</li><li>此时<strong>缺页的进程阻塞</strong>，放入阻塞队列，调页<strong>完成后再将其唤醒</strong>，放回就绪队列。</li><li>如果内存中<strong>有空闲块</strong>，则为进程<strong>分配一个空闲块</strong>，将所缺页面装入该块，并修改页表中相应的页表项。</li><li>如果内存中<strong>没有空闲块</strong>，则<strong>由页面置换算法选择一个页面淘汰</strong>，若该页面在内存期间<strong>被修改过</strong>，则要将其<strong>写回外存</strong>。未修改过的页面不用写回外存。</li><li><strong>缺页中断</strong>是因为当前执行的指令想要访问的目标页面未调入内存而产生的，因此属于内中断、故障（fault）</li><li><strong>一条指令</strong>在执行期间，<strong>可能产生多次缺页中断</strong>。</li></ul></li><li>地址变换机构<ul><li>新增步骤<ul><li>请求调页（查到页表项时根据状态位判断）</li><li>页面置换（需要调入页面，但没有空闲内存块时进行）</li><li>需要修改请求页表中新增的表项</li></ul></li><li><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part3/image-20211111135241839.png" alt="image-20211111135241839"><ul><li>查快表（未命中）—— 查慢表（发现未调入内存）—— 调页（调入的页面对应的表项会直接加入快表）—— 查快表（命中）—— 访问目标内存单元</li></ul></li><li>注意<ul><li><strong>快表中的页面一定是在内存中的</strong>。若某个页面被换出外存，则<strong>快表中的相应表项也要删除</strong>，否则可能访问错误的页面</li><li><strong>只有写指令才需要修改修改位</strong>。并且，一般只需修改快表中的数据，只有<strong>当将快表项删除时才需要写回内存中的慢表</strong>。这样可以减少访存次数。</li><li>和普通的中断处理一样，缺页中断处理依然需要保留 CPU 现场。</li><li>换入/换出页面都需要启动慢速的 I/O 操作，如果<strong>换入/换出太频繁，会有很大的开销</strong>。</li><li>页面调入内存后，需要同时修改慢表、快表。</li></ul></li></ul></li></ul><h3 id="页面置换算法"><a href="#页面置换算法" class="headerlink" title="页面置换算法"></a>页面置换算法</h3><p><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part3/image-20211111100054045.png" alt="image-20211111100054045"></p><ul><li><p>最佳置换算法（OPT，Optimal）：</p><ul><li>每次选择淘汰的页面都是<strong>以后永不使用</strong>，或者<strong>在最长时间内不再被访问</strong>的页面。<ul><li><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part3/image-20211111140714145.png" alt="image-20211111140714145" style="zoom:80%;"></li></ul></li><li>最佳置换算法<strong>可以保证最低的缺页率</strong>，但实际上，操作系统无法提前预判页面访问序列。因此，<strong>最佳置换算法是无法实现的</strong>。</li></ul></li><li><p>先进先出置换算法（FIFO）</p><ul><li>每次选择淘汰的页面是<strong>最早进入内存</strong>的页面<ul><li><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part3/image-20211111140930234.png" alt="image-20211111140930234" style="zoom:80%;"></li><li><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part3/image-20211111141136485.png" alt="image-20211111141136485"></li></ul></li><li><strong>Belady 异常</strong>：当为进程分配的物理块数增大时，缺页次数不减反增的异常现象。<ul><li><strong>只有 FIFO 算法会产生 Belady 异常</strong>。</li></ul></li><li>FIFO 算法虽然实现简单，但是该算法与进程实际运行时的规律不适应，因为先进入的页面也有可能最经常被访问。因此，<strong>算法性能差</strong>。</li></ul></li><li><p>最近最久未使用置换算法（LRU）</p><ul><li>每次淘汰的页面是最近最久未使用的页面</li><li>实现方法：<ul><li>赋予每个页面对应的页表项中，用访问字段记录该页面自上次被访问以来所经历的时间 t。</li><li>当需要淘汰一个页面时，选择现有页面中 t 值最大的，即最近最久未使用的页面。</li><li><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part3/image-20211111141926199.png" alt="image-20211111141926199" style="zoom:80%;"></li><li>虽然性能好，但是实现困难、开销大。</li></ul></li><li>做题时，仅需逆向扫描过程中最后出现的页号，即要淘汰的页面。</li></ul></li><li><p>时钟置换算法（CLOCK）</p><ul><li><p>时钟置换算法（CLOCK 算法/最近未用算法（NRU，Not Recently Used）），是一种性能和开销较均衡的算法。</p></li><li><p><strong>简单的 CLOCK 算法实现方法</strong>：</p><ul><li><p>为每个页面设置一个访问位，再将内存中的页面都通过链接指针链接成一个循环队列。</p></li><li><p>算法规则：</p><ul><li>当某页被访问时，其访问位置为 1。</li><li>当需要淘汰一个页面时，只需检查页的访问位：如果是 0，就选择该页换出；如果是 1，则将它置为 0，暂不换出</li><li>若第一轮扫描中所有页面都是 1，则将这些页面的访问位依次置为 0 后，再进行第二轮扫描</li></ul></li><li><p><strong>简单的 CLOCK 算法选择一个淘汰页面最多会经过两轮扫描</strong></p></li></ul></li><li><p><strong>改进型的时钟置换算法</strong>：</p><ul><li><p>针对问题：<strong>只有被淘汰的页面被修改过时，才需要写回外存</strong>。</p></li><li><p>改进方向：在其他条件都相同时，应优先淘汰没有修改过的页面，避免 I/O 操作。</p></li><li><p>修改位=0，表示页面没有被修改过；修改位=1，表示页面被修改过。用（访问位，修改位）的形式表示各页面状态。</p></li><li><p>算法规则：</p><ul><li><p>第一轮：从当前位置开始扫描到第一个（0, 0）的帧用于替换。本轮扫描不修改任何标志位</p><ul><li>第一优先级：<strong>最近没访问，且没修改的页面</strong></li></ul></li><li><p>第二轮：若第一轮扫描失败，则重新扫描，查找第一个（0, 1）的帧用于替换。本轮将所有扫描过的帧访问位设为 0 </p><ul><li>第二优先级：<strong>最近没访问，但修改过的页面</strong></li></ul></li><li><p>第三轮：若第二轮扫描失败，则重新扫描，查找第一个（0, 0）的帧用于替换。本轮扫描不修改任何标志位</p><ul><li>第三优先级：<strong>最近访问过，但没修改的页面</strong></li></ul></li><li><p>第四轮：若第三轮扫描失败，则重新扫描，查找第一个（0, 1）的帧用于替换。</p><ul><li>第四优先级：<strong>最近访问过，且修改过的页面</strong></li></ul></li></ul></li><li><p><strong>改进型 CLOCK 置换算法选择一个淘汰页面最多会进行四轮扫描</strong></p></li></ul></li><li><blockquote><p>NRU 相比 LRU：</p><ul><li>记录谁<strong>最早</strong>被使用很难，那么换一种思路，把时间分成一个个周期，<strong>如果最近一个周期都没有被使用，那就干脆当做一直没有被使用</strong>。</li><li><strong>不一定要最早被使用的被淘汰，只要不是最近被使用的被淘汰就好了</strong>。</li></ul></blockquote></li></ul></li></ul><h3 id="页面分配策略"><a href="#页面分配策略" class="headerlink" title="页面分配策略"></a>页面分配策略</h3><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part3/image-20211111100203514.png" alt="image-20211111100203514" style="zoom:100%;"><ul><li>驻留集：<ul><li>指<strong>请求分页存储管理中给进程分配的物理块的集合</strong>。</li><li>在采用了虚拟存储技术的系统中，<strong>驻留集大小一般小于进程的总大小</strong>。</li><li>选择一个合适的驻留集大小<ul><li>若驻留集太小，会导致缺页频繁，系统要花大量的时间来处理缺页，实际用于进程推进的时间很少；</li><li>若驻留集太大，会导致多道程序并发度下降，资源利用率降低。</li></ul></li></ul></li><li>页面分配：<ul><li><strong>固定分配</strong>：操作系统为每个进程分配一组固定数目的物理块，在进程运行期间不再改变。即，<strong>驻留集大小不变</strong></li><li><strong>可变分配</strong>：先为每个进程分配一定数目的物理块，在进程运行期间，可根据情况做适当的增加或减少。即，<strong>驻留集大小可变</strong></li><li><strong>局部置换</strong>：发生缺页时<strong>只能选进程自己的物理块进行置换</strong>。</li><li><strong>全局置换</strong>：可以将内存中<strong>任意的物理块分配给缺页进程</strong>（包括操作系统保持的空闲物理块、争夺别的进程持有的物理块）</li></ul></li><li>置换策略：<ul><li><strong>固定分配局部置换</strong>：<ul><li>系统为每个进程分配一定数量的物理块，在整个运行期间都不改变。若进程在运行中发生缺页，则只能从该进程在内存中的页面中选出一页换出，然后再调入需要的页面。</li><li>缺点：<strong>很难在最初为每个进程确定分配合理的物理块数量</strong>。（采用这种策略的系统可以根据进程大小、优先级、或是根据程序员给出的参数来确定为一个进程分配的内存块数）</li></ul></li><li><strong>可变分配全局置换</strong>：<ul><li>刚开始会为每个进程分配一定数量的物理块。操作系统会<strong>保持一个空闲物理块队列</strong>。当某进程发生缺页时，从空闲物理块中取出一块分配给该进程；若已无空闲物理块，则可选择一个<strong>未锁定</strong>的页面换出外存，再将该物理块分配给缺页的进程。</li><li>特点：<strong>只要缺页就给分配新物理块</strong>。</li><li>缺点：当空闲物理块用完时，系统可以选择任意一个进程中未锁定的页面调出，因此这个<strong>被选中的进程拥有的物理块减少，缺页率增加</strong>。</li></ul></li><li><strong>可变分配局部置换</strong>：<ul><li>刚开始会为每个进程分配一定数量的物理块。当某进程发生缺页时，只允许从该进程自己的物理块中选出一个进行换出外存。如果进程在运行中频繁地缺页，系统会为该进程多分配几个物理块，直至该进程缺页率趋势适当程度；反之，如果进程在运行中缺页率特别低，则可适当减少分配给该进程的物理块。</li><li>特点：<strong>要根据发生缺页的频率来动态地增加或减少进程的物理块</strong></li></ul></li></ul></li><li>何时调入页面<ul><li>预调页策略：<ul><li>根据局部性原理，一次调入若干个相邻的页面可能比一次调入一个页面更高效。但如果提前调入的页面中大多数都没被访问过，则又是低效的。因此可以预测不久之后可能访问到的页面，将它们预先调入内存，但目前预测成功率只有 50% 左右。</li><li>故这种策略<strong>主要用于进程的首次调入</strong>（<strong>运行前调入</strong>），由程序员指出应该先调入哪些部分。<ul><li>主要指空间局部性，即：如果当前访问了某个内存单元，在之后很有可能会接着访问与其相邻的</li></ul></li></ul></li><li>请求调页策略：<ul><li>进程<strong>在运行期间发现缺页时才将所缺页面调入内存</strong>（<strong>运行时调入</strong>）。</li><li>由这种策略调入的页面一定会被访问到，但由于每次只能调入一页，而每次调页都要磁盘 I/O 操作，因此 I/O 开销较大。</li></ul></li></ul></li><li>从何处调入页<ul><li>系统拥有足够的对换区空间：<ul><li>页面的调入、调出都是在内存与对换区之间进行，这样可以<strong>保证页面的调入、调出速度很快</strong>。在进程运行前，需将进程相关的数据从文件区复制到对换区。</li><li><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part3/image-20211111153622301.png" alt="image-20211111153622301" style="zoom: 67%;"></li></ul></li><li>系统缺少足够的对换区空间：<ul><li>凡是不会被修改的数据都直接从文件区调入，由于这些页面不会被修改，因此<strong>换出时不必写回磁盘，下次需要时再从文件区调入即可</strong>。对于可能被修改的部分，<strong>换出时需写回磁盘对换区，下次需要时再从对换区调入</strong>。</li><li><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part3/image-20211111153712918.png" alt="image-20211111153712918" style="zoom: 67%;"></li></ul></li><li>UNIX 方式：<ul><li>运行之前进程有关的数据全部放在文件区，故未使用过的页面，都可从文件区调入。若被使用过的页面需要换出，则写回对换 区，下次需要时从对换区调入。</li><li><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part3/image-20211111153811349.png" alt="image-20211111153811349" style="zoom: 67%;"></li></ul></li></ul></li><li>抖动（颠簸）现象<ul><li><strong>刚刚换出的页面马上又要换入内存，刚刚换入的页面马上又要换出外存</strong>。<ul><li>产生原因：进程频繁访问的页面数目高于可用的物理块数（<strong>分配给进程的物理块不够</strong>）</li></ul></li><li>为进程分配的物理块太少，会使进程发生抖动现象。为进程分配的物理块太多，又会降低系统整体的并发度，降低某些资源的利用率</li><li>为了研究为应该为每个进程分配多少个物理块，Denning 提出了进程“工作集”的概念<ul><li>驻留集：指请求分页存储管理中给进程分配的内存块的集合。</li><li>工作集：指在某段时间间隔里，进程实际访问页面的集合。</li><li><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part3/image-20211111153945600.png" alt="image-20211111153945600" style="zoom:80%;"></li><li>工作集大小可能小于窗口尺寸，实际应用中，操作系统可以统计进程的工作集大小，根据工作集大小给进程分配若干内存块。</li><li>一般来说，<strong>驻留集大小不能小于工作集大小，否则进程运行过程中将频繁缺页</strong>。</li><li>拓展：可以根据进程近期访问的页面集合（工作集）来设计一种页面置换算法——选择一个不在工作集中的页面进行淘汰。</li></ul></li></ul></li></ul>]]></content>
    
    
    <summary type="html">内存管理</summary>
    
    
    
    <category term="操作系统" scheme="https://nephrencake.gitee.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
  </entry>
  
  <entry>
    <title>操作系统-Part2</title>
    <link href="https://nephrencake.gitee.io/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part2/"/>
    <id>https://nephrencake.gitee.io/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part2/</id>
    <published>2021-11-01T01:43:44.000Z</published>
    <updated>2021-11-16T08:41:01.852Z</updated>
    
    <content type="html"><![CDATA[<h1 id="操作系统-Part2——进程管理"><a href="#操作系统-Part2——进程管理" class="headerlink" title="操作系统-Part2——进程管理"></a>操作系统-Part2——进程管理</h1><p>[TOC]</p><h2 id="进程与线程"><a href="#进程与线程" class="headerlink" title="进程与线程"></a>进程与线程</h2><h3 id="进程的概念、组成、特征"><a href="#进程的概念、组成、特征" class="headerlink" title="进程的概念、组成、特征"></a>进程的概念、组成、特征</h3><p><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part2/image-20211102143509078.png" alt="image-20211102143509078"></p><ul><li><p>概念</p><ul><li>程序：是静态的，是存放在磁盘的可执行文件。</li><li>进程：是动态的，是进程实体的运行过程，<strong>是能独立运行、独立获得资源、独立接受调度的基本单位</strong>。<ul><li>进程实体（进程映像）：是静态的，一个进程实体由 PCB、程序段、数据段组成。</li><li><strong>进程实体（进程映像）反应了进程某一时刻的状态</strong></li></ul></li><li>同一个程序多次执行会对应多个进程</li></ul></li><li><p>组成（严格地来说是<strong>进程实体的组成</strong>）</p><ul><li><strong>进程控制块</strong>（Process Control Block，PCB）<ul><li><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part2/image-20211102140823925.png" alt="image-20211102140823925"><ul><li>进程描述信息：用于区分各个进程</li><li>进程控制和管理信息：用于实现操作系统对进程的控制、调度</li><li>资源分配清单：用于实现对资源的管理</li><li>处理机相关信息：用于实现进程切换</li></ul></li><li>其中，进程标识符 PID 是<strong>唯一的、不重复的</strong>，即使进程已经被杀死</li><li>操作系统对进程进行管理工作<strong>所需的所有信息，都存在 PCB 中</strong></li><li><strong>PCB 是进程存在的唯一标志</strong>，当进程被创建时，操作系统为其创建 PCB，当进程结束时，会回收其 PCB。</li></ul></li><li><strong>程序段</strong>与<strong>数据段</strong><ul><li>PCB 是给<strong>操作系统</strong>用的。程序段、数据段是给<strong>进程</strong>自己用的。</li><li>程序段：程序的代码（指令序列）<ul><li>一个应用的多个进程拥有<strong>相同的程序段</strong></li></ul></li><li>数据段：运行过程中的各种数据（变量）<ul><li>一个应用的多个进程拥有<strong>不同的数据段</strong></li></ul></li></ul></li></ul></li><li><p>特征</p><ul><li><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part2/image-20211102143009562.png" alt="image-20211102143009562"></li><li>动态性是进程最基本的特征</li><li>引入线程之后，进程不再是独立接受调度的基本单位，但仍是独立获得资源的基本单位</li></ul></li></ul><h3 id="进程的状态与转换、进程的组织"><a href="#进程的状态与转换、进程的组织" class="headerlink" title="进程的状态与转换、进程的组织"></a>进程的状态与转换、进程的组织</h3><p><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part2/image-20211102152923790.png" alt="image-20211102152923790"></p><p>进程的状态与转换</p><ul><li>状态转换过程<ul><li><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part2/image-20211102152203439.png" alt="image-20211102152203439"></li><li>创建态（New，新建态）：进程正在被创建。在这个阶段，操作系统会为进程分配资源、初始化 PCB</li><li>就绪态（Ready）：仅缺少 CPU，具备其他所有运行条件，随时可以被处理运行</li><li>运行态（Running）：进程正在 CPU 上运行<ul><li>多核 CPU 可能有多个进程处于运行态</li></ul></li><li>阻塞态（Waiting/Blocked，等待态）：进程<strong>主动</strong>请求等待某个事件的发生（资源分配或其他进程响应）<ul><li>即除 CPU 之外还缺少必要的条件，只有<strong>被动</strong>获得其余条件，才能转化成就绪态</li></ul></li><li>终止态（Terminated，结束态）：执行 exit 系统调用，或出现终止异常。进程下 CPU、回收内存空间等<strong>资源</strong>、回收该进程的 <strong>PCB</strong>，彻底消失。</li></ul></li><li>三种基本状态：运行态、就绪态、阻塞态</li><li><strong>不能由阻塞态直接转为运行态，也不能由就绪态直接转为阻塞态</strong>。</li><li>进程 PCB 中，会有一个变量 state 来表示进程的当前状态</li></ul><p>进程的组织</p><ul><li>链接方式<ul><li>按照进程状态将 PCB 分为多个队列</li><li>操作系统持有各个队列的指针</li></ul></li><li>索引方式<ul><li>根据进程状态的不同，建立索引表</li><li>操作系统持有各个索引表的指针</li></ul></li></ul><h3 id="进程控制"><a href="#进程控制" class="headerlink" title="进程控制"></a>进程控制</h3><ul><li><p>基本概念</p><ul><li>进程控制：实现进程状态转换</li><li>进程控制的实现方式：原语<ul><li>原语的执行具有<strong>原子性</strong>，运行必须一气呵成，不可中断</li><li>进程控制/状态转换，不可中断</li><li>通过<strong>关/中断指令</strong>这两个<strong>特权指令</strong>实现原子性</li><li>进程控制必定是内核程序，需要运行在<strong>核心态</strong></li></ul></li></ul></li><li><p>进程控制相关原语</p><ul><li>进程的创建<ul><li><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part2/image-20211102155434833.png" alt="image-20211102155434833"></li><li>作业调度：将位于<strong>外存</strong>后备队列中的作业调入<strong>内存</strong></li></ul></li><li>进程的终止<ul><li><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part2/image-20211102155614381.png" alt="image-20211102155614381" style="zoom:80%;"></li></ul></li><li>进程的阻塞、进程的唤醒<ul><li><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part2/image-20211102155717098.png" alt="image-20211102155717098"></li><li>阻塞和切换必定成对出现</li></ul></li><li>进程的切换<ul><li><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part2/image-20211102155913145.png" alt="image-20211102155913145" style="zoom: 67%;"></li><li>通过 PCB 恢复运行环境</li></ul></li></ul></li><li><p>无论哪个进程控制原语，要做的无非三类事情：</p><ul><li>更新 PCB 中的信息（修改进程状态，保存/恢复运行环境）<ul><li>所有的进程控制原语一定都会修改进程状态标志</li><li>剥夺当前运行进程的CPU使用权必然需要保存其运行环境</li><li>某进程开始运行前必然要恢复期运行环境</li></ul></li><li>将 PCB 插入合适的队列</li><li>分配/回收资源</li></ul></li></ul><h3 id="进程通信"><a href="#进程通信" class="headerlink" title="进程通信"></a>进程通信</h3><p><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part2/image-20211102160516149.png" alt="image-20211102160516149"></p><ul><li>基本概念<ul><li>进程通信（Inter-Process Communication， IPC）是指两个进程之间产生数据交互。</li><li>进程是分配系统资源的单位（包括内存地址空间），因此各进程拥有的<strong>内存地址空间相互独立</strong>。<ul><li>为了保证安全，<strong>一个进程不能直接访问另一个进程的地址空间</strong>。</li></ul></li></ul></li><li><strong>共享存储</strong><ul><li>为避免出错，各个进程对共享空间的访问应该是<strong>互斥</strong>的。</li><li>基于<strong>数据结构</strong>的共享：<ul><li>比如共享空间里只能放一个长度为 10 的数组。</li><li>速度慢、限制多，是一种<strong>低级通信</strong>方式</li></ul></li><li>基于<strong>存储区</strong>的共享：<ul><li>操作系统在内存中划出一块共享存储区。数据的形式、存放位置都由<strong>通信进程</strong>控制，而不是操作系统。</li><li>速度很快，是一种<strong>高级通信</strong>方式。</li><li><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part2/image-20211102190332073.png" alt="image-20211102190332073" style="zoom: 67%;"></li></ul></li></ul></li><li><strong>消息传递</strong><ul><li>进程间的数据交换以<strong>格式化的消息</strong>（Message）为单位。进程通过操作系统提供的“发送消息/接收消息”两个<strong>原语</strong>进行数据交换。</li><li><strong>直接通信方式</strong><ul><li>消息发送进程要指明接收进程的ID</li><li><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part2/image-20211102190853574.png" alt="image-20211102190853574" style="zoom: 67%;"></li></ul></li><li><strong>间接通信方式</strong><ul><li>通过“信箱”间接地通信。因此又称“信箱通信方式”</li><li><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part2/image-20211102191135092.png" alt="image-20211102191135092" style="zoom:67%;"></li></ul></li></ul></li><li><strong>管信通信</strong><ul><li>“管道”是一个特殊的共享文件，又名 pipe 文件。其实就是在内存中开辟一个<strong>大小固定的内存缓冲区</strong>（循环队列）</li><li>管道只能采用<strong>半双工通信</strong>，某一时间段内只能实现单向的传输。如果要实现<strong>全双工通信</strong>，则需要设置两个管道。</li><li>各进程要<strong>互斥</strong>地访问管道（由操作系统实现）</li><li>当管道<strong>写满</strong>时，<strong>写进程将阻塞</strong>，直到读进程将管道中的数据取走，即可唤醒写进程。</li><li>当管道<strong>读空</strong>时，<strong>读进程将阻塞</strong>，直到写进程往管道中写入数据，即可唤醒读进程。</li><li>管道中的数据一旦被读出，就彻底消失。因此，当多个进程读同一个管道时，可能会错乱。对此，通常有两种解决方案：<ul><li>一个管道允许<strong>多个写进程，一个读进程</strong>（2014年408真题高教社官方答案）；</li><li>允许有多个写进程，多个读进程，但系统会让各个读进程轮流从管道中读数据（Linux 的方案）。</li></ul></li><li>只要管道没空，读进程就可以从管道读数据；只要管道没满，写进程就可以往管道写数据。</li></ul></li></ul><h3 id="线程的概念与特点"><a href="#线程的概念与特点" class="headerlink" title="线程的概念与特点"></a>线程的概念与特点</h3><ul><li>线程是一个基本的 CPU 执行单元，是<strong>程序执行流的最小单位</strong>。</li><li>带来的变化：<ul><li>资源分配、调度<ul><li>传统进程机制中，进程是资源分配、调度的基本单位</li><li>引入线程之后，进程是<strong>资源分配</strong>的基本单位，线程是<strong>调度</strong>的基本单位</li></ul></li><li>并发性<ul><li>传统进程机制中，只能进程间并发</li><li>引入线程之后，各线程之间也能并发，提升了并发度</li></ul></li><li>系统开销<ul><li>传统的进程间并发，需要切换进程的运行环境，系统开销大</li><li>线程间并发，如果是<strong>同一线程内的线程切换</strong>，则不需要切换进程环境，<strong>系统开销小</strong></li><li>引入线程后，并发带来的系统开销减小</li></ul></li></ul></li><li>线程属性：<ul><li>线程是处理机调度单位</li><li>多 CPU 计算机中，各个线程可以占用不同的 CPU<ul><li>（一般是一个进程占一个核。因为不同逻辑核心用的缓存是不同的，若一个进程同时用多个核，则数据调用会变得困难。但是考纲表明，一个进程可以占用多个核心，核心级线程是处理机分配的最小单位）</li></ul></li><li>每一个线程都有<strong>线程 ID、线程控制块（TCB）</strong></li><li>线程也有<strong>就绪、堵塞、运行</strong>三种基本状态</li><li>线程几乎不拥有系统资源</li><li>同一进程的不同线程<strong>共享进程的资源</strong></li><li>由于共享内存地址空间，同一线程中的线程间通信无需系统干预</li><li>同一进程中的线程切换，不会引起进程切换；不同进程中的线程切换，会引起进程切换。</li><li>切换同进程内的线程，系统开销很小；切换进程，系统的开销较大。</li></ul></li></ul><h3 id="线程的实现方式和多线程模型"><a href="#线程的实现方式和多线程模型" class="headerlink" title="线程的实现方式和多线程模型"></a>线程的实现方式和多线程模型</h3><p><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part2/image-20211102232120706.png" alt="image-20211102232120706"></p><ul><li><p>线程的实现方式</p><ul><li><strong>用户级线程</strong>（User-Level Thread, ULT）<ul><li>用户级线程<strong>由应用程序通过线程库实现</strong>，所有的线程管理工作都<strong>由应用程序负责</strong>（包括线程切换）</li><li>用户级线程中，线程切换可以<strong>在用户态下完成</strong>，无需操作系统干预。</li><li>在用户看来，是有多个线程。但是在操作系统内核看来，并意识不到线程的存在。</li><li>优点：用户级线程的切换在用户空间即可完成，不需要切换到核心态，线程管理的<strong>开销小，效率高</strong></li><li>缺点：当一个用户级线程被阻塞后，整个进程都会被阻塞，<strong>并发度不高</strong>。多个线程不可在多核处理机上并行运行。</li><li><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part2/image-20211103135106630.png" alt="image-20211103135106630" style="zoom:80%;"></li></ul></li><li><strong>内核级线程</strong>（Kernel-Level Thread, KLT，又称“内核支持的线程”）<ul><li>内核级线程的管理工作由操作系统内核完成。</li><li>线程调度、切换等工作都由内核负责，因此内核级线程的切换必然需要在核心态下才能完成。</li><li>操作系统会为每个内核级线程建立相应的 TCB（Thread Control Block，线程控制块），通过 TCB 对线程进行管理。“内核级线程”就是“从操作系统内核视角看能看到的线程”</li><li>优点：当一个线程被阻塞后，别的线程还可以继续执行，并发能力强。多线程可在多核处理机上并行执行。</li><li>缺点：一个用户进程会占用多个内核级线程，线程切换由操作系统内核完成，需要切换到核心态，因此线程管理的成本高，开销大。</li><li><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part2/image-20211103134402805.png" alt="image-20211103134402805" style="zoom:80%;"></li></ul></li></ul></li><li><p>多线程模型</p><ul><li>一对一模型：（内核级线程）<ul><li><strong>一个用户级线程映射到一个内核级线程</strong>。每个用户进程有与用户级线程同数量的内核级线程。</li><li>优点：当一个线程被阻塞后，别的线程还可以继续执行，<strong>并发能力强</strong>。<strong>多线程可在多核处理机上并行执行</strong>。</li><li>缺点：<strong>一个用户进程会占用多个内核级线程</strong>，线程切换由操作系统内核完成，需要切换到核心态，因此<strong>线程管理的成本高，开销大</strong>。</li></ul></li><li>多对一模型：（用户级线程）<ul><li><strong>多个用户级线程映射到一个内核级线程</strong>。且<strong>一个进程只被分配一个内核级线程</strong>。</li><li>优点：用户级线程的切换在用户空间即可完成，不需要切换到核心态，线程管理的系统开销小，效率高</li><li>缺点：当一个用户级线程被阻塞后，整个进程都会被阻塞，<strong>并发度不高</strong>。多个线程不可在多核处理机上并行运行，因为只有这一个进程只有一个内核级线程。</li></ul></li><li>多对多模型：<ul><li>n 用户及线程映射到 m 个内核级线程（<strong>n&gt;=m</strong>）。每个用户进程对应 m 个内核级线程。</li><li>克服了多对一模型并发度不高的缺点（一个阻塞全体阻塞），又克服了一对一模型中一个用户进程占用太多内核级线程，开销太大的缺点。</li><li><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part2/image-20211103135439234.png" alt="image-20211103135439234" style="zoom:80%;"></li></ul></li></ul><blockquote><ul><li>用户级线程是“代码逻辑”的载体</li><li>内核级线程是“运行机会”的载体</li><li>注意：<strong>内核级线程才是处理机分配的单位</strong>。</li></ul></blockquote></li></ul><h2 id="处理机调度"><a href="#处理机调度" class="headerlink" title="处理机调度"></a>处理机调度</h2><h3 id="调度的概念、层次"><a href="#调度的概念、层次" class="headerlink" title="调度的概念、层次"></a>调度的概念、层次</h3><p><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part2/image-20211103143657421.png" alt="image-20211103143657421"></p><ul><li><p>基本概念：确定某种规则来决定处理任务的顺序</p></li><li><p>三个层次</p><ul><li>高级调度（作业调度）<ul><li>作业：指一个具体的任务</li><li>用户向系统提交一个作业 ≈ 用户让操作系统启动一个程序（来处理一个具体的任务）</li><li>按一定的原则从<strong>外存</strong>的作业后备队列中挑选一个作业调入<strong>内存</strong>，并<strong>创建进程</strong>。</li><li>每个作业<strong>只调入一次</strong>，<strong>调出一次</strong>。作业调入时会建立 PCB，调出时才撤销 PCB。</li></ul></li><li>中级调度（内存调度）<ul><li>内存不够时，将某些进程的数据调出外存。等内存空闲或者进程需要运行时再重新调入内存。</li><li>暂时调到外存等待的进程状态为<strong>挂起状态</strong>（suspend）。被挂起的进程 PCB 会被组织成<strong>挂起队列</strong></li><li>一个进程可能会被<strong>多次调出、调入内存</strong>，因此<strong>中级调度发生的频率要比高级调度更高</strong>。</li></ul></li><li>低级调度（进程调度）<ul><li>从<strong>内存</strong>中的<strong>就绪队列</strong>中选取一个进程，将<strong>处理机</strong>分配给它。</li><li><strong>进程调度是操作系统中最基本的一种调度</strong>，在一般的操作系统中都必须配置进程调度。</li><li>进程调度的<strong>频率很高</strong>，一般几十毫秒一次。</li></ul></li></ul></li><li><p>补充</p><ul><li>进程的挂起态<ul><li>暂时调到<strong>外存</strong>等待的进程状态为挂起状态</li><li>挂起态又可以进一步细分为<strong>就绪挂起</strong>、<strong>阻塞挂起</strong>两种状态</li></ul></li><li>七状态模型<ul><li>注意：挂起和阻塞，两种状态都是暂时不能获得CPU的服务，但挂起态是<strong>将进程映像调到外存</strong>去了，而<strong>阻塞态下进程映像还在内存中</strong>。</li><li>有的操作系统会把就绪挂起、阻塞挂起分为两个挂起队列，甚至会根据阻塞原因不同再把阻塞挂起进程进一步细分为多个队列。</li><li><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part2/image-20211103142132494.png" alt="image-20211103142132494"></li></ul></li></ul></li><li><p>三个层次的联系、对比</p><ul><li><table><thead><tr><th></th><th>内容</th><th>发生位置</th><th>发生频率</th><th>进程状态</th></tr></thead><tbody><tr><td>（高级）作业调度</td><td>从后备队列选择以创建进程</td><td>外存 -&gt; 内存（面向作业）</td><td>最低</td><td>无 -&gt; 创建态 -&gt; 就绪态</td></tr><tr><td>（中级）内存调度</td><td>从挂起队列选择以调回内存</td><td>外存 -&gt; 内存（面向进程）</td><td>中等</td><td>挂起态 -&gt; 就绪态</td></tr><tr><td>（低级）进程调度</td><td>从就绪队列选择以分配 CPU</td><td>内存 -&gt; CPU</td><td>最高</td><td>就绪态 -&gt; 运行态</td></tr></tbody></table></li></ul></li></ul><h3 id="进程调度的时机、切换与过程、方式"><a href="#进程调度的时机、切换与过程、方式" class="headerlink" title="进程调度的时机、切换与过程、方式"></a>进程调度的时机、切换与过程、方式</h3><p><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part2/image-20211103143931197.png" alt="image-20211103143931197"></p><ul><li><strong>进程调度的时机</strong><ul><li>进程调度（低级调度），就是按照某种算法从就绪队列中选择一个进程为其分配处理机。</li><li><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part2/image-20211103144051040.png" alt="image-20211103144051040"></li><li><strong>需要</strong>进行进程调度与切换的情况<ul><li>当前进程<strong>主动</strong>放弃处理机<ul><li>进程正常终止</li><li>发生异常而终止</li><li>进程主动请求阻塞（如 等待I/O）</li></ul></li><li>当前进程<strong>被动</strong>放弃处理机<ul><li>分给进程的时间片用完</li><li>有更紧急的事需要处理（如 I/O中断）</li><li>有更高优先级的进程进入就绪队列</li></ul></li></ul></li><li><strong>不能</strong>进行进程调度与切换的情况<ul><li>在<strong>处理中断的过程中</strong>。中断处理过程复杂，与硬件密切相关，很难做到在中断处理过程中进行进程切换。</li><li>进程在<strong>操作系统内核程序临界区中</strong>。但是进程在普通临界区中是可以进行调度、切换的。</li><li>在<strong>原子操作过程中</strong>（原语）。原子操作不可中断。（如修改 PCB 中进程状态标志，并把 PCB 放到相应队列）</li></ul></li><li>真题案例：<ul><li>进程在<strong>操作系统内核程序临界区</strong>中<strong>不能</strong>进行调度与切换。<strong>对</strong></li><li>（2012年联考真题）进程处于<strong>临界区</strong>时<strong>不能</strong>进行处理机调度。<strong>错</strong></li><li>临界资源：<strong>一个时间段内只允许一个进程使用的资源</strong>。各进程需要互斥地访问临界资源。</li><li>临界区：访问临界资源的那段代码。</li><li><strong>内核程序临界区</strong>一般是用来访问<strong>某种内核数据结构</strong>的，比如进程的就绪队列（由各就绪进程的 PCB 组成）<ul><li>进程还未退出临界区时，临界资源（就绪队列）则一直处于上锁状态，则其他进程调度相关的程序就会被阻塞。</li><li>内核程序临界区访问的临界资源如果不尽快释放，极有可能影响到操作系统内核的其他管理工作。因此<strong>在访问内核程序临界区期间不能进行调度和切换</strong>。</li></ul></li><li>普通临界区<ul><li>在打印机打印完成之前，进程一直处于临界区内，临界资源（打印机）不会解锁。但打印机是慢速设备，如果不允许进程调度则会导致 CPU 一直空闲</li><li>普通临界区资源（如打印机）不会影响到操作系统内核的管理工作。因此<strong>在访问普通临界区资源时可以进行调度与切换</strong>。</li></ul></li></ul></li></ul></li><li><strong>进程调度的方式</strong><ul><li><strong>非剥夺调度方式</strong>，又称<strong>非抢占方式</strong>。即，只允许进程主动放弃处理机。在运行过程中即便有更紧迫的任务到达，当前进程依然会继续使用处理机，直到该进程终止或主动要求进入阻塞态。<ul><li>实现简单，系统开销小但是无法及时处理紧急任务，适合于<strong>早期的批处理系统</strong></li></ul></li><li><strong>剥夺调度方式</strong>，又称<strong>抢占方式</strong>。当一个进程正在处理机上执行时，如果有一个更重要或更紧迫的进程需要使用处理机，则立即暂停正在执行的进程，将处理机分配给更重要紧迫的那个进程。<ul><li>可以优先处理更紧急的进程，也可实现让各进程按时间片轮流执行的功能（通过时钟中断）。适合于<strong>分时操作系统、实时操作系统</strong></li></ul></li></ul></li><li><strong>进程的切换与过程</strong><ul><li><strong>进程调度</strong>与<strong>进程切换</strong>的区别：<ul><li><strong>狭义的进程调度</strong>，指的是从就绪队列中选中一个要运行的进程。（这个进程可以是刚刚被暂停执行的进程，也可能是另一个进程，后一种情况就需要进程切换）</li><li><strong>进程切换</strong>，指一个进程让出处理机，由另一个进程占用处理机的过程。</li><li><strong>广义的进程调度</strong>，包含了选择一个进程和进程切换两个步骤</li></ul></li><li>进程切换的过程主要完成了：<ul><li>对原来运行进程各种数据的保存</li><li>对新的进程各种数据的恢复</li></ul></li><li><strong>进程切换是有代价的</strong>，因此如果过于频繁的进行进程调度、切换，必然会使整个系统的效率降低，使系统大部分时间都花在了进程切换上，而真正用于执行进程的时间减少。</li></ul></li></ul><h3 id="调度算法的评价指标"><a href="#调度算法的评价指标" class="headerlink" title="调度算法的评价指标"></a>调度算法的评价指标</h3><p><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part2/image-20211103220000158.png" alt="image-20211103220000158"></p><ul><li><strong>CPU 利用率</strong>：指 CPU 忙碌的时间占总时间的比例。</li><li><strong>系统吞吐量</strong>：单位时间内完成作业的数量</li><li>周转时间<ul><li><strong>周转时间</strong>，指从作业被提交给系统开始，到作业完成为止的时间。<ul><li>包括四个部分：作业<strong>在外存后备队列上等待作业调度（高级调度）</strong>的时间、进程<strong>在就绪队列上等待进程调度（低级调度）</strong>的时间、进程<strong>在CPU上执行的时间</strong>、进程<strong>等待 I/O 操作完成的时间</strong>。后三项在一个作业的整个处理过程中，可能发生多次。</li></ul></li><li><strong>带权周转时间</strong>必然 ≥ 1</li><li>带权周转时间与周转时间都是越小越好</li></ul></li><li><strong>等待时间</strong><ul><li>等待时间，指进程/作业<strong>处于等待处理机状态时间之和</strong>，等待时间越长，用户满意度越低。</li><li>对于进程来说，等待时间就是指进程建立后<strong>等待被服务的时间之和</strong>，在等待I/O完成的期间其实进程也是在被服务的，所以不计入等待时间。</li><li>对于作业来说，不仅要考虑<strong>建立进程后的等待时间</strong>，还要加上<strong>作业在外存后备队列中等待的时间</strong>。</li></ul></li><li><strong>响应时间</strong>：指从用户提交请求到首次产生响应所用的时间。</li></ul><h3 id="调度算法"><a href="#调度算法" class="headerlink" title="调度算法"></a>调度算法</h3><ul><li>各种调度算法的学习思路<ol><li>算法思想</li><li>算法规则</li><li>作业调度 or 进程调度</li><li>抢占式 or 非抢占式</li><li>优点 and 缺点</li><li>是否会导致饥饿/饿死</li></ol></li><li>FCFS、SJF/SPF、HRRN 适合用于早期的批处理系统；时间片轮转、优先级调度、多级反馈队列适合用于交互式系统</li></ul><h4 id="先来先服务"><a href="#先来先服务" class="headerlink" title="先来先服务"></a>先来先服务</h4><ul><li>先来先服务（FCFS, First Come First Serve）<ul><li>算法思想：主要从“公平”的角度考虑</li><li>算法规则：按照<strong>到达的先后顺序</strong>进行服务</li><li>调度对象：用于作业调度时，考虑的是哪个作业先到达<strong>后备队列</strong>；用于进程调度时，考虑的是哪个进程先到达<strong>就绪队列</strong></li><li>是否抢占：非抢占式</li><li>优点：公平、算法实现简单</li><li>缺点：<ul><li><strong>带权周转时间很大</strong>。</li><li>公平</li><li><strong>对长作业有利，对短作业不利</strong>。</li></ul></li><li>是否会导致饥饿/饿死：不会</li></ul></li></ul><p><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part2/image-20211104135659417.png" alt="image-20211104135659417"></p><h4 id="最短作业优先"><a href="#最短作业优先" class="headerlink" title="最短作业优先"></a>最短作业优先</h4><ul><li><p>短作业优先（SJF, Shortest Job First）</p><ul><li>算法思想：追求最少的<strong>平均等待时间</strong>、<strong>平均周转时间</strong>、<strong>平均带权周转时间</strong></li><li>算法规则：<strong>要求服务时间最短</strong>的作业/进程优先得到服务</li><li>调度对象：作业/进程调度皆可。用于进程调度称为，短进程优先算法（SPF, Shortest Process First）</li><li>是否抢占：SJF 和 SPF 是非抢占式的算法。但是也有抢占式的版本——最短剩余时间优先算法（SRTN, Shortest Remaining Time Next）<ul><li>SJF：仅在每次调度时选择当前<strong>已到达且运行时间最短</strong>的作业/进程。</li><li>SRTN：每当有进程加入<strong>就绪队列改变时就需要调度</strong>，如果新到达的进程<strong>剩余时间</strong>比当前运行的进程剩余时间<strong>更短</strong>，则由新进程<strong>抢占</strong>处理机，当前运行进程重新回到就绪队列。另外，当一个进程完成时也需要调度。</li></ul></li><li>优点：“最短的”平均等待时间、平均周转时间</li><li>缺点：<ul><li>不公平。</li><li><strong>对短作业有利，对长作业不利</strong>。</li><li>可能产生饥饿现象。</li><li>作业/进程的运行时间是由用户提供的，并不一定真实，不一定能做到真正的短作业优先</li></ul></li><li>是否会导致饥饿/饿死：会</li></ul></li><li><p>注意：</p><ul><li>如果题目中未特别说明，所提到的“短作业/进程优先算法”默认是<strong>非抢占式</strong>的</li><li>“SJF 调度算法的平均等待时间、平均周转时间最少”，严格来说，这个表述是错误的，不严谨的。<ul><li>在<strong>所有进程同时可运行</strong>时，采用 SJF 调度算法的平均等待时间、平均周转时间最少</li><li>在<strong>所有进程都几乎同时到达</strong>时，采用 SJF 调度算法的平均等待时间、平均周转时间最少</li><li><strong>抢占式的</strong>短作业/进程优先调度算法（<strong>最短剩余时间优先</strong>，SRNT算法）的平均等待时间、平均周转时间最少</li></ul></li></ul></li></ul><p><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part2/image-20211104135754210.png" alt="image-20211104135754210"></p><p><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part2/image-20211104135848421.png" alt="image-20211104135848421"></p><h4 id="最高响应比优先"><a href="#最高响应比优先" class="headerlink" title="最高响应比优先"></a>最高响应比优先</h4><ul><li>高响应比优先（HRRN, Highest Response Ratio Next）<ul><li>算法思想：综合考虑作业/进程的等待时间和要求服务的时间</li><li>算法规则：在每次调度时先<strong>计算各个作业/进程的响应比，选择响应比最高</strong>的作业/进程为其服务<ul><li><strong>响应比 =（等待时间+要求服务时间）/ 要求服务时间</strong></li></ul></li><li>调度对象：即可用于作业调度，也可用于进程调度</li><li>是否抢占：非抢占式</li><li>优缺点：<ul><li>综合考虑了等待时间和运行时间（要求服务时间）</li><li>等待时间相同时，要求服务时间短的优先（SJF 的优点）</li><li>要求服务时间相同时，等待时间长的优先（FCFS 的优点）</li><li>对于长作业来说，随着等待时间越来越久，其响应比也会越来越大，从而避免了长作业饥饿的问题</li></ul></li><li>是否会导致饥饿/饿死：不会</li></ul></li></ul><p><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part2/image-20211104135933630.png" alt="image-20211104135933630"></p><h4 id="时间片轮转"><a href="#时间片轮转" class="headerlink" title="时间片轮转"></a>时间片轮转</h4><ul><li>时间片轮转（RR，Round-Robin）<ul><li>算法思想：公平地、轮流地为各个进程服务，让每个进程在一定时间间隔内都可以得到响应</li><li>算法规则：按照各进程到达就绪队列的顺序，轮流让各个进程执行一个时间片。若进程未在一个时间片内执行完，则剥夺处理机，将进程重新放到就绪队列队尾重新排队。</li><li>调度对象：进程调度（只有作业放入内存建立了相应的进程后，才能被分配处理机时间片）</li><li>是否抢占：<strong>抢占式</strong>。由时钟装置发出<strong>时钟中断</strong>来通知 CPU 时间片已到</li><li>优点：公平；响应快，适用于分时操作系统；</li><li>缺点：由于高频率的进程切换，因此有一定开销；不区分任务的紧急程度。</li><li>是否会导致饥饿/饿死：不会</li></ul></li><li>注意：<ul><li>当同时有进程 a <strong>下处理机</strong>、有进程 b <strong>到达</strong>，则默认新到达的进程先进入就绪队列</li><li>进程主动放弃处理机，则<strong>立刻调度下一个进程上处理机</strong>，并且<strong>不影响下一个进程的时间片周期</strong></li><li>通常，设计时间片要让切换进程的开销占比不超过 1%<ul><li>时间片不能太大：否则，将使得每个进程都可以在一个时间片内就完成，则时间片轮转调度算法<strong>退化为先来先服务调度算法</strong>，并且会<strong>增大进程响应时间</strong>。</li><li>时间片不能太小：否则会导致<strong>进程切换过于频繁</strong>，而进程调度、切换都有时间代价（保存、恢复运行环境）。</li></ul></li></ul></li></ul><p><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part2/image-20211104150056927.png" alt="image-20211104150056927"></p><h4 id="优先级调度"><a href="#优先级调度" class="headerlink" title="优先级调度"></a>优先级调度</h4><ul><li>优先级调度算法<ul><li>算法思想：根据任务的紧急程度来决定处理顺序</li><li>算法规则：每个作业/进程有各自的优先级，调度时选择优先级最高的</li><li>调度对象：作业、进程、I/O 调度</li><li>是否抢占：抢占式、非抢占式都有。<ul><li>非抢占式只需在进程主动放弃处理机时进行调度即可</li><li>抢占式另外还需在就绪队列变化时，检查是否会发生抢占</li></ul></li><li>优点：<ul><li>用优先级区分紧急程度、重要程度，适用于实时操作系统。</li><li>可灵活地调整对各种作业/进程的偏好程度。</li></ul></li><li>缺点：若源源不断地有高优先级进程到来，则可能导致饥饿</li><li>是否会导致饥饿/饿死：会</li></ul></li><li>注意：<ul><li>优先数要按照题意判断：优先数<strong>越大（或者越小）</strong>，优先级越高</li><li>根据优先级是否可以动态改变，有两种分类<ul><li><strong>静态优先级</strong>：创建进程时确定，之后一直不变。</li><li><strong>动态优先级</strong>：创建进程时有一个初始值，之后会根据情况动态地调整优先级。</li></ul></li><li>通常：<ul><li>系统进程优先级<strong>高于</strong>用户进程</li><li>前台进程优先级<strong>高于</strong>后台进程</li><li>操作系统更<strong>偏好 I/O 型进程（I/O 繁忙型进程）</strong><ul><li>相对的是计算型进程（CPU 繁忙型进程）</li></ul></li></ul></li><li>动态优先级调整策略<ul><li>如果某进程在就绪队列中<strong>等待了很长时间</strong>，则可以适当提升其优先级</li><li>如果某进程<strong>占用处理机运行了很长时间</strong>，则可适当降低其优先级</li><li>如果发现一个进程频<strong>繁地进行 I/O 操作</strong>，则可适当提升其优先级</li></ul></li></ul></li></ul><p><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part2/image-20211104150805430.png" alt="image-20211104150805430"></p><p><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part2/image-20211104150844950.png" alt="image-20211104150844950"></p><h4 id="多级反馈队列"><a href="#多级反馈队列" class="headerlink" title="多级反馈队列"></a>多级反馈队列</h4><ul><li><ul><li>算法思想：对其他调度算法的折中权衡</li><li>算法规则：<ul><li>设置多级就绪队列，<strong>各级队列优先级从高到低</strong>，<strong>时间片从小到大</strong></li><li>新进程到达时先进入第 1 级队列，按 FCFS 原则排队等待被分配时间片。若用完时间片进程还未结束，则进入下一级队列队尾。如果已经在最下级队列，则重新放回该级队列队尾</li><li>被抢占处理机的进程重新放回原队列队尾</li><li>只有第 k 级队列为空时，才会为 k+1 级队头的进程分配时间片。</li></ul></li><li>调度对象：进程调度</li><li>是否抢占：抢占式</li><li>优缺点：<ul><li>对各类型进程相对公平（FCFS的优点）</li><li>每个新到达的进程都可以很快就得到响应（RR的优点）</li><li>短进程只用较少的时间就可完成（SPF的优点）</li><li>不必实现估计进程的运行时间（避免用户作假）；</li><li>可灵活地调整对各类进程的偏好程度，比如 CPU 密集型进程、I/O 密集型进程（拓展：可以将因 I/O 而阻塞的进程重新放回原队列，这样 I/O 型进程就可以保持较高优先级）</li></ul></li><li>是否会导致饥饿/饿死：会</li></ul></li></ul><p><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part2/image-20211104151749404.png" alt="image-20211104151749404"></p><h2 id="进程同步"><a href="#进程同步" class="headerlink" title="进程同步"></a>进程同步</h2><h3 id="进程同步、进程互斥"><a href="#进程同步、进程互斥" class="headerlink" title="进程同步、进程互斥"></a>进程同步、进程互斥</h3><p><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part2/image-20211104162619267.png" alt="image-20211104162619267"></p><ul><li>进程同步<ul><li>针对问题：进程具有异步性的特征。各并发执行的进程以<strong>各自独立的、不可预知的</strong>速度向前推进。</li><li><strong>同步</strong>亦称<strong>直接制约关系</strong>。指为了完成某种任务而建立的多个进程，因为需要在某些位置上<strong>协调工作次序</strong>而产生的制约关系。</li></ul></li><li>进程互斥<ul><li>针对问题：<strong>一个时间段内只允许一个进程使用</strong>的资源称为临界资源。</li><li><strong>互斥</strong>，亦称<strong>间接制约关系</strong>。指当一个进程访问临界资源时，另一个想要访问该临界资源的进程必须等待，直到临界资源被释放</li><li><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part2/image-20211104162337247.png" alt="image-20211104162337247"></li><li>注意：<ul><li><strong>临界区</strong>是进程中<strong>访问临界资源</strong>的代码段。</li><li><strong>进入区</strong>和<strong>退出区</strong>是<strong>负责实现互斥</strong>的代码段。</li><li>临界区也可称为“临界段”。</li></ul></li><li><strong>四个原则</strong>：（为了实现对临界资源的互斥访问，同时保证系统整体性能）<ol><li>空闲让进。临界区空闲时，可以允许一个请求进入临界区的进程立即进入临界区；</li><li>忙则等待。当已有进程进入临界区时，其他试图进入临界区的进程必须等待；</li><li>有限等待。对请求访问的进程，应保证能在有限时间内进入临界区（保证不会饥饿）；</li><li>让权等待。当进程不能进入临界区时，应立即释放处理机，防止进程忙等待。</li></ol></li></ul></li></ul><h3 id="进程互斥的软件实现方法（高频）"><a href="#进程互斥的软件实现方法（高频）" class="headerlink" title="进程互斥的软件实现方法（高频）"></a>进程互斥的软件实现方法（高频）</h3><p><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part2/image-20211104165325471.png" alt="image-20211104165325471"></p><ul><li>单标志法<ul><li>算法思想：两个进程在<strong>访问完临界区后</strong>会把使用临界区的权限转交给另一个进程。即，<strong>每个进程进入临界区的权限只能被另一个进程赋予</strong></li><li>主要问题：违背“<strong>空闲让进</strong>”原则。</li><li><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part2/image-20211104202433915.png" alt="image-20211104202433915"></li></ul></li><li>双标志先检查<ul><li>算法思想：设置一个布尔型数组，用来<strong>标记各进程想进入临界区的意愿</strong></li><li>主要问题：违反“<strong>忙则等待</strong>”原则。</li><li>问题原因：<strong>检查</strong>与<strong>上锁</strong>之间可能发生进程切换。</li><li><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part2/image-20211104203017349.png" alt="image-20211104203017349"></li></ul></li><li>双标志后检查<ul><li>算法思想：先“上锁”后“检查”</li><li>主要问题：违背了“<strong>空闲让进</strong>”和“<strong>有限等待</strong>”原则，会产生“<strong>饥饿</strong>”现象。</li><li><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part2/image-20211104202926919.png" alt="image-20211104202926919"></li></ul></li><li>Peterson 算法<ul><li>算法思想：结合双标志法（争取）、单标志法（谦让）的思想。<strong>主动争取、主动谦让、检查</strong>。</li><li>主要问题：未遵循“<strong>让权等待</strong>”原则</li><li><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part2/image-20211104203638733.png" alt="image-20211104203638733"></li></ul></li></ul><h3 id="进程互斥的硬件实现方法"><a href="#进程互斥的硬件实现方法" class="headerlink" title="进程互斥的硬件实现方法"></a>进程互斥的硬件实现方法</h3><p><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part2/image-20211104204033279.png" alt="image-20211104204033279"></p><ul><li>中断屏蔽方法<ul><li>利用“开/关中断指令”实现</li><li>优点：<strong>简单、高效</strong></li><li>缺点：<ul><li><strong>不适用于多处理机</strong>。A 核执行了关中断，不影响 B 核使用相同的临界区。</li><li>只适用于操作系统内核进程，不适用于用户进程（<strong>开/关中断指令只能运行在内核态</strong>）</li></ul></li></ul></li><li>TestAndSet 指令<ul><li>TS 指令，也称 TestAndSetLock（TSL）指令</li><li>TSL 指令是用<strong>硬件实现</strong>的，执行的过程不允许被中断</li><li><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part2/image-20211105121953825.png" alt="image-20211105121953825"></li><li>优点：<ul><li>实现简单，无需像软件实现方法那样严格检查是否会有逻辑漏洞</li><li>适用于多处理机环境</li></ul></li><li>缺点：不满足“让权等待”原则，暂时无法进入临界区的进程会占用 CPU 并循环执行TSL指令。</li></ul></li><li>Swap 指令<ul><li>也称 Exchange（XCHG）指令</li><li>Swap 指令是用<strong>硬件实现</strong>的，执行的过程不允许被中断</li><li><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part2/image-20211105122231302.png" alt="image-20211105122231302"></li><li>优缺点：同 TestAndSet 指令</li></ul></li></ul><h3 id="信号量机制"><a href="#信号量机制" class="headerlink" title="信号量机制"></a>信号量机制</h3><p><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part2/image-20211105124116186.png" alt="image-20211105124116186"></p><ul><li>基本概念：<ul><li>用户进程可以通过使用操作系统提供的<strong>一对原语</strong>来对<strong>信号量</strong>进行操作，从而很方便的实现了进程互斥、进程同步。</li><li>信号量其实就是一个变量，用来<strong>表示系统中某种资源的数量</strong>。</li><li>原语是一种特殊的程序段，其<strong>执行只能一气呵成，不可被中断</strong>。</li><li>一对原语：<strong>wait(S) 原语</strong>和 <strong>signal(S) 原语</strong>，S 为信号量</li><li>wait、signal 原语常简称为 P、V 操作（来自荷兰语 proberen 和 verhogen），即 <strong>P(S)、V(S)</strong></li></ul></li><li>整型信号量<ul><li>用一个<strong>整数型的变量</strong>作为信号量。<ul><li>与普通整数变量的区别：对信号量的操作只有三种，初始化、P 操作、V 操作</li></ul></li><li>其实和 TS 指令差不多</li><li><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part2/image-20211105124727576.png" alt="image-20211105124727576" style="zoom: 75%;"></li><li>问题：<strong>不满足“让权等待”</strong></li></ul></li><li>记录型信号量<ul><li>用记录型数据结构表示的信号量。<ul><li>如果剩余资源数不足，使用 <strong>block 原语</strong>使进程<strong>从运行态进入阻塞态</strong>，并把挂到信号量 S 的等待队列（阻塞队列）中</li><li>释放资源后，若还有别的进程在等待这种资源，则使用 <strong>wakeup 原语</strong>唤醒等待队列中的一个进程，该进程<strong>从阻塞态变为就绪态</strong></li></ul></li><li><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part2/image-20211105125223262.png" alt="image-20211105125223262" style="zoom:80%;"></li><li>P(S)、V(S) 实现系统资源的“<strong>申请</strong>”和“<strong>释放</strong>”。</li><li><strong>S.value 的初值</strong>表示系统中<strong>某种资源的数目</strong>。</li><li>P 操作：<ul><li>对信号量 S 的<strong>一次 P 操作</strong>意味着进程<strong>请求一个单位的该类资源</strong>，因此需要执行 S.value–，表示资源数减 1。</li><li>当 S.value &lt; 0 时表示该类资源已分配完毕，因此进程应调用 block 原语进行自我阻塞（**当前运行的进程从运行态 -&gt; 阻塞态<strong>），</strong>主动放弃处理机<strong>，并</strong>插入该类资源的等待队列 S.L 中**。</li><li>可见，该机制<strong>遵循了“让权等待”原则</strong>，不会出现“忙等”现象。</li></ul></li><li>V 操作：<ul><li>对信号量 S 的<strong>一次 V 操作</strong>意味着进程<strong>释放一个单位的该类资源</strong>，因此需要执行 S.value++，表示资源数加 1。</li><li>若加 1 后仍是 S.value &lt;= 0，表示依然有进程在等待该类资源，因此应**调用 wakeup 原语**唤醒等待队列中的第一个进程（**被唤醒进程从阻塞态 -&gt; 就绪态**）。</li></ul></li></ul></li></ul><blockquote><p>信号量的值 = 这种资源的剩余数量</p><p>P( S ) —— 申请一个资源 S，如果资源不够就阻塞等待</p><p>V( S ) —— 释放一个资源 S，如果有进程在等待该资源，则唤醒一个进程</p></blockquote><h3 id="信号量实现进程互斥、同步、前驱关系"><a href="#信号量实现进程互斥、同步、前驱关系" class="headerlink" title="信号量实现进程互斥、同步、前驱关系"></a>信号量实现进程互斥、同步、前驱关系</h3><p><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part2/image-20211105131735276.png" alt="image-20211105131735276"></p><ul><li>实现进程互斥<ul><li>过程：<ul><li>分析并发进程的关键活动，划定临界区</li><li>设置互斥信号量 mutex，<strong>初值为 1</strong></li><li><strong>在进入区 P(mutex)——申请资源</strong></li><li><strong>在退出区 V(mutex)——释放资源</strong></li><li><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part2/image-20211105144434351.png" alt="image-20211105144434351" style="zoom:80%;"></li></ul></li><li>注意：<ul><li>对不同的临界资源需要设置不同的互斥信号量。 </li><li>P、V 操作必须成对出现。缺少 P(mutex) 就不能保证临界资源的互斥访问。缺少 V(mutex) 会导致资源永不被释放，等待进程永不被唤醒。</li></ul></li></ul></li><li>实现进程同步<ul><li>过程：<ul><li>分析什么地方需要实现“同步关系”，即必须保证“一前一后”执行的两个操作</li><li>设置同步信号量 S，<strong>初始为 0</strong></li><li><strong>在“前操作”之后执行 V(S)</strong></li><li><strong>在“后操作”之前执行 P(S)</strong><ul><li>信号量 S 代表“某种资源”，刚开始是没有这种资源的。P2 需要使用这种资源，而又只能由 P1 产生这种资源</li><li><strong>前 V 后 P</strong></li></ul></li><li><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part2/image-20211105144750166.png" alt="image-20211105144750166" style="zoom:80%;"></li></ul></li></ul></li><li>实现前驱关系<ul><li>过程<ul><li>为<strong>每一对前驱关系</strong>各设置一个同步信号量</li><li>在“前操作”之后对相应的同步信号量执行 V 操作</li><li>在“后操作”之前对相应的同步信号量执行 P 操作</li><li><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part2/image-20211105145022913.png" alt="image-20211105145022913" style="zoom:80%;"></li></ul></li><li>前驱关系问题，<strong>本质上就是多级同步问题</strong>。</li></ul></li></ul><h3 id="生产者-消费者问题"><a href="#生产者-消费者问题" class="headerlink" title="生产者-消费者问题"></a>生产者-消费者问题</h3><ul><li>问题描述：系统中有一组生产者进程和一组消费者进程，生产者进程每次生产一个产品放入缓冲区，消费者进程每次从缓冲区中取出一个产品并使用。生产者、消费者共享一个初始为空、大小为 n 的缓冲区。</li><li>问题分析：<ul><li>只有<strong>缓冲区没满</strong>时，生产者才能把产品放入缓冲区，否则必须等待。——同步</li><li>只有<strong>缓冲区不空</strong>时，消费者才能从中取出产品，否则必须等待。——同步</li><li>缓冲区是临界资源，各进程必须<strong>互斥</strong>地访问。——互斥</li></ul></li><li>算法实现：<ul><li><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part2/image-20211105173157993.png" alt="image-20211105173157993"></li></ul></li><li>注意：<ul><li><strong>实现互斥的 P 操作一定要在实现同步的 P 操作之后</strong>。</li><li>V 操作不会导致进程阻塞，因此<strong>两个 V 操作顺序可以交换</strong>。</li><li>生产产品与使用产品可以放在 P、V 中间，但是这样会使得临界区代码变长</li><li>有时候是<strong>消费者需要等待生产者生产</strong>，有时候是<strong>生产者要等待消费者消费</strong>，这是两个不同的“一前一后问题”。因此，题目<strong>隐含两对同步关系</strong>，也需要<strong>设置两个同步信号量</strong>。</li></ul></li></ul><h3 id="多生产者-多消费者"><a href="#多生产者-多消费者" class="headerlink" title="多生产者-多消费者"></a>多生产者-多消费者</h3><ul><li>问题描述：桌子上有一只盘子，每次只能向其中放入一个水果。爸爸专向盘子中放苹果，妈妈专向盘子中放橘子，儿子专等着吃盘子中的橘子，女儿专等着吃盘子中的苹果。只有盘子空时，爸爸或妈妈才可向盘子中放一个水果。仅当盘子中有自己需要的水果时，儿子或女儿可以从盘子中取出水果。</li><li>问题分析：<ul><li>对缓冲区（盘子）的访问要互斥地进行。——互斥</li><li>父亲将苹果放入盘子后，女儿才能取苹果。——同步</li><li>母亲将橘子放入盘子后，儿子才能取橘子。——同步</li><li>只有<strong>盘子为空</strong>时，<strong>父亲或母亲</strong>才能放入水果。——同步<ul><li>“盘子为空”这个事件可以由儿子或女儿触发。</li></ul></li></ul></li><li>算法实现<ul><li><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part2/image-20211105175350546.png" alt="image-20211105175350546"></li></ul></li><li>注意：<ul><li>当缓冲区容量为 1 时，则<strong>可能</strong>不设置专门的互斥变量 mutex，也不会出现多个进程同时访问盘子的现象。具体情况具体分析</li><li>如果来不及仔细分析，完全可以加上互斥信号量，以保证各进程一定会互斥地访问缓冲区。<strong>互斥的 P 一定要在同步 P 之后</strong>。</li></ul></li></ul><blockquote><p>解决“多生产者-多消费者问题”的关键在于理清复杂的同步关系。</p><p>在分析同步问题（一前一后问题）的时候<strong>不能从单个进程行为</strong>的角度来分析，要把“一前一后”发生的事看做是两种“<strong>事件</strong>”的前后关系。</p><ul><li>如果从单个进程行为的角度来考虑的话，我们会有以下结论：<ul><li>如果盘子里装有苹果，那么一定要女儿取走苹果后父亲或母亲才能再放入水果</li><li>如果盘子里装有橘子，那么一定要儿子取走橘子后父亲或母亲才能再放入水果</li><li>意味着要设置四个同步信号量分别实现这四个“一前一后”的关系？</li></ul></li><li>正确的分析方法应该从“事件”（面向过程）的角度来考虑，我们可以把上述四对“进程行为的前后关系”抽象为一对“事件的前后关系”<ul><li>盘子变空事件 -&gt; 放入水果事件。</li><li>“盘子变空事件”既可由儿子（进程）引发，也可由女儿（进程）引发；“放水果事件”既可能是父亲（进程）执行，也可能是母亲（进程）执行。</li><li>这样的话，就可以用一个同步信号量解决问题了</li></ul></li></ul></blockquote><h3 id="吸烟者问题"><a href="#吸烟者问题" class="headerlink" title="吸烟者问题"></a>吸烟者问题</h3><ul><li>问题描述：假设一个系统有<strong>三个抽烟者进程</strong>和<strong>一个供应者进程</strong>。每个抽烟者不停地卷烟并抽掉它，但是要卷起并抽掉一支烟，抽烟者需要有三种材料：烟草、纸和胶水。三个抽烟者中，<strong>第一个拥有烟草、第二个拥有纸、第三个拥有胶水</strong>。供应者进程无限地提供三种材料，供应者每次将两种材料放桌子上，<strong>拥有剩下那种材料的抽烟者卷一根烟并抽掉它，并给供应者进程一个信号告诉完成了</strong>，供应者就会放另外两种材料再桌上，这个过程一直重复（<strong>让三个抽烟者轮流地抽烟</strong>）</li><li>问题分析：<ul><li>也属于“生产者-消费者”问题，更详细的说应该是“可生产多种产品的单生产者-多消费者”。</li><li>缓冲区大小为 1，每个吸烟者其实需要的是<strong>一个“组合”</strong>，且<strong>可以不设置互斥信号量</strong></li><li><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part2/image-20211105194323459.png" alt="image-20211105194323459"></li></ul></li><li>算法实现：<ul><li><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part2/image-20211105194941823.png" alt="image-20211105194941823"></li></ul></li></ul><h3 id="读者-写者问题"><a href="#读者-写者问题" class="headerlink" title="读者-写者问题"></a>读者-写者问题</h3><ul><li>问题描述：<ul><li>有读者和写者两组并发进程，共享一个文件，当两个或两个以上的读进程同时访问共享数据时不会产生副作用，但若某个写进程和其他进程（读进程或写进程）同时访问共享数据时则可能导致数据不一致的错误。</li><li>因此要求：①<strong>允许多个读者可以同时对文件执行读操作</strong>；②<strong>只允许一个写者往文件中写信息</strong>；③<strong>任一写者在完成写操作之前不允许其他读者或写者工作</strong>；④<strong>写者执行写操作前，应让已有的读者和写者全部退出</strong>。</li></ul></li><li>问题分析：<ul><li>两类进程：写进程、读进程</li><li>互斥关系：写进程—写进程、写进程—读进程。读进程与读进程不存在互斥问题。</li></ul></li><li>算法实现：<ul><li>读进程优先：<ul><li><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part2/image-20211105202012898.png" alt="image-20211105202012898"></li><li>问题：若<strong>两个读进程并发执行</strong>，则 count=0 时两个进程也许<strong>都能满足 if 条件，都会执行 P(rw)**，从而</strong>使第二个读进程阻塞**的情况。</li><li>原因：在于对 count 变量的检查和赋值无法一气呵成</li><li>解决：设置 mutex  互斥信号量来保证各读进程对 count 变量的互斥访问</li><li>特点：只要有读进程还在读，写进程就要一直阻塞等待，可能“饿死”。因此，该算法为<strong>读进程优先</strong></li></ul></li><li>读写公平：<ul><li><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part2/image-20211105202325653.png" alt="image-20211105202325653"></li><li>精髓：在读者写者中 P(w)、V(w) 分别<strong>包住了写文件</strong>和<strong>没有包住读文件</strong>，因此可以保证写者与其他互斥，读文件可以并发</li></ul></li></ul></li></ul><blockquote><p>总结：</p><ul><li>互斥 -&gt; 读者写者；同步 -&gt; 生产者消费者</li><li>对于读者共享，要<strong>设置计数器 count 来记录当前正在访问共享文件的读进程数</strong>。<strong>只有第一个/最后一个读进程需要进行 P、V 操作</strong>。</li><li>对于需要一气呵成的“<strong>检查和赋值</strong>” ，自然应该想到用<strong>互斥信号量</strong>实现。 </li><li>解决“写进程饥饿”问题，需要<strong>通过写者来限制读者访问 count</strong>。</li></ul></blockquote><h3 id="哲学家进餐问题"><a href="#哲学家进餐问题" class="headerlink" title="哲学家进餐问题"></a>哲学家进餐问题</h3><ul><li>问题描述：一张圆桌上坐着 5 名哲学家，每两个哲学家之间的桌上摆一根筷子，桌子的中间是一碗米饭。哲学家们倾注毕生的精力用于思考和进餐，哲学家在思考时，并不影响他人。只有当哲学家饥饿时，才试图拿起左、右两根筷子（一根一根地拿起）。如果筷子已在他人手上，则需等待。饥饿的哲学家只有同时拿起两根筷子才可以开始进餐，当进餐完毕后，放下筷子继续思考。</li><li>问题分析：因为需要<strong>同时持有两个临界资源</strong>，所以如果多个哲学家并发则可能出现<strong>循环等待</strong>，<strong>发生死锁</strong>。</li><li>算法实现：<ul><li>保证了“<strong>各哲学家拿筷子这件事必须互斥的执行</strong>”。<ul><li>即使一个哲学家在拿筷子拿到一半时被阻塞，也不会有别的哲学家继续尝试拿筷子。</li></ul></li><li>并不能保证“<strong>仅当一个哲学家左右两支筷子都可用时才允许他抓起筷子</strong>”。</li><li><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part2/image-20211105215209806.png" alt="image-20211105215209806" style="zoom:80%;"></li></ul></li></ul><h3 id="管程"><a href="#管程" class="headerlink" title="管程"></a>管程</h3><p><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part2/image-20211105215354783.png" alt="image-20211105215354783"></p><ul><li>针对问题：编写程序困难、易出错</li><li>改进方向：将复杂部分<strong>封装</strong>为管程，对外<strong>仅暴露接口</strong></li><li>组成：<ul><li>局部于管程的<strong>共享数据结构</strong></li><li>对该数据结构进行操作的<strong>过程</strong></li><li>对共享数据设置的<strong>初始值</strong></li><li>管程的名字</li></ul></li><li>基本特征：<ul><li>共享数据<strong>只能由内部的过程操作</strong></li><li>一个进程<strong>只有通过调用管程的过程</strong>才能访问共享数据</li><li><strong>每次仅允许一个进程在管程内执行某个内部过程</strong></li><li>其互斥特性是<strong>由编译器负责实现</strong></li><li>可在管程中设置<strong>条件变量</strong>及<strong>等待/唤醒操作</strong>以解决同步问题。</li></ul></li><li>实现：（伪代码，不考）<ul><li><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part2/image-20211105221421680.png" alt="image-20211105221421680"></li><li>JAVA 中的 synchronized 关键字</li></ul></li></ul><h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><h3 id="死锁的概念"><a href="#死锁的概念" class="headerlink" title="死锁的概念"></a>死锁的概念</h3><p><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part2/image-20211106134325023.png" alt="image-20211106134325023"></p><ul><li>死锁、饥饿、死循环<ul><li>死锁：各进程互相等待对方手里的资源，导致各进程都阻塞，无法向前推进的现象。</li><li>饥饿：由于长期得不到想要的资源，某进程无法向前推进的现象。</li><li>死循环：某进程执行过程中一直跳不出某个循环的现象。</li></ul></li><li>共同点：都是进程无法顺利向前推进的现象</li><li><strong>死锁、饥饿、死循环的区别</strong><ul><li>数量：<ul><li>死锁：如果有死锁现象，那<strong>至少有两个或两个以上</strong>的进程同时发生死锁。</li><li>饥饿：可能<strong>只有一个或多个</strong>进程发生饥饿。</li><li>死循环：可能<strong>只有一个或多个</strong>进程发生死循环。</li></ul></li><li>原因：<ul><li>死锁：一定是“<strong>循环等待对方手里的资源</strong>”导致的</li><li>饥饿：长期得不到需要的 <strong>I/O 设备</strong>或<strong>处理机</strong></li><li>死循环：代码<strong>逻辑的错误或者人为因素</strong></li></ul></li><li>进程状态：<ul><li>死锁：一定处于阻塞态。</li><li>饥饿：既可能是阻塞态，也可能是就绪态。</li><li>死循环：可以是运行态</li></ul></li><li>死锁和饥饿，是由于<strong>操作系统分配资源的策略不合理</strong>导致的，是管理者（操作系统）的问题；死循环是<strong>被管理者</strong>的问题。</li></ul></li><li><strong>死锁产生的必要条件</strong><ul><li>产生死锁<strong>必须同时满足</strong>一下四个条件，只要其中任一条件不成立，死锁就不会发生。</li><li><strong>互斥条件</strong>：<strong>只有对必须互斥使用的资源的争抢</strong>才会导致死锁（如哲学家的筷子、打印机设备）。像内存、扬声器这样可以同时让多个进程使用的资源是不会导致死锁的（因为进程不用阻塞等待这种资源）。</li><li><strong>不剥夺条件</strong>：进程所获得的资源在<strong>未使用完之前，不能由其他进程强行夺走</strong>，只能主动释放。</li><li><strong>请求和保持条件</strong>：进程<strong>已经保持了至少一个资源，但又提出了新的资源请求，而该资源又被其他进程占有</strong>，此时请求进程被阻塞，但又对自己已有的资源保持不放。</li><li><strong>循环等待条件</strong>：存在一种<strong>进程资源的循环等待链</strong>，链中的每一个进程已获得的资源同时被下一个进程所请求。</li></ul></li><li>注意：发生死锁时一定有循环等待，但是发生循环等待时未必死锁（循环等待是死锁的必要不充分条件）<ul><li>存在循环等待的同时，还存在其他可以获得资源的分支</li><li><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part2/image-20211106133925724.png" alt="image-20211106133925724" style="zoom:50%;"></li></ul></li><li>发生死锁的情况（<strong>对不可剥夺资源的不合理分配</strong>）<ul><li>对系统资源的竞争。各进程对<strong>不可剥夺的资源</strong>（如打印机）的竞争可能引起死锁，对可剥夺的资源（CPU）的竞争是不会引起死锁的。</li><li>进程推进顺序非法。请求和释放资源的顺序不当，也同样会导致死锁。例如，并发执行的进程 P1、P2 分别申请并占有了资源 R1、R2，之后进程 P1 又紧接着申请资源 R2，而进程 P2 又申请资源 R1，两者会因为申请的资源被对方占有而阻塞，从而发生死锁。</li><li>信号量的使用不当也会造成死锁。如生产者-消费者问题中，如果实现互斥的P操作在实现同步的 P 操作之前，就有可能导致死锁。（可以把互斥信号量、同步信号量也看做是一种抽象的系统资源）</li></ul></li></ul><h3 id="死锁的处理策略"><a href="#死锁的处理策略" class="headerlink" title="死锁的处理策略"></a>死锁的处理策略</h3><h4 id="预防死锁（静态策略）"><a href="#预防死锁（静态策略）" class="headerlink" title="预防死锁（静态策略）"></a>预防死锁（静态策略）</h4><p><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part2/image-20211106134712771.png" alt="image-20211106134712771"></p><ul><li><strong>破坏互斥条件</strong><ul><li>把只能互斥使用的资源改造为允许共享使用，则系统不会进入死锁状态。</li><li>如：SPOOLing 技术把独占设备在逻辑上改造成共享设备。<ul><li><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part2/image-20211106145121574.png" alt="image-20211106145121574" style="zoom:80%;"></li></ul></li><li>缺点：并不是所有的资源都可以改造成可共享使用的资源。并且为了系统安全，很多地方还必须保护这种互斥性。因此，<strong>很多时候都无法破坏互斥条件</strong>。</li></ul></li><li><strong>破坏不剥夺条件</strong><ul><li>方案一：当某个进程请求新的资源得不到满足时，必须立即<strong>主动释放保持的所有资源</strong>，以后需要时重新申请。</li><li>方案二：当某个进程需要的资源被其他进程所占有的时候，可以<strong>由操作系统协助，将想要的资源强行剥夺</strong>。<ul><li>这种方式一般需要考虑各进程的优先级（比如：剥夺调度方式，就是将处理机资源强行剥夺给优先级更高的进程使用）</li></ul></li><li>缺点：<ul><li>实现起来比较复杂。</li><li>释放已获得的资源可能造成前一阶段工作的失效。因此这种方法一般只<strong>适用于易保存和恢复状态的资源</strong>，如 CPU。</li><li>反复地申请和释放资源会增加系统开销，降低系统吞吐量。</li><li>若采用方案一，意味着只要暂时得不到某个资源，之前获得的那些资源就都需要放弃，以后再重新申请。如果<strong>一直发生放弃资源，就会导致进程饥饿</strong>。</li></ul></li></ul></li><li><strong>破坏请求和保持条件</strong><ul><li>采用<strong>静态分配方法</strong>，即进程在运行前一次申请完它所需要的全部资源，在它的资源未满足前，不让它投入运行。一旦投入运行后，这些资源就一直归它所有，该进程就不会再请求别的任何资源了。</li><li>缺点：<strong>有些资源可能只需要用很短的时间</strong>，因此如果进程的整个运行期间都一直保持着所有资源，就会造成严重的<strong>资源浪费</strong>，资源利用率极低。另外，该策略也有可能导致某些进程饥饿。</li></ul></li><li><strong>破坏循环等待条件</strong><ul><li>采用<strong>顺序资源分配法</strong>。首先给系统中的资源编号，规定每个进程<strong>必须按编号递增的顺序请求资源</strong>（持有 n 号资源时，不允许请求 &lt;n 号的资源），同类资源（即编号相同的资源）一次申请完。</li><li>缺点：<ul><li><strong>不方便增加新的设备</strong>，因为可能需要重新分配所有的编号；</li><li>进程<strong>实际使用资源的顺序</strong>可能和<strong>编号递增顺序</strong>不一致（必须先占有资源，但不使用），会导致资源浪费；</li><li>必须按规定次序申请资源，编程麻烦。</li></ul></li></ul></li></ul><h4 id="避免死锁（动态策略）"><a href="#避免死锁（动态策略）" class="headerlink" title="避免死锁（动态策略）"></a>避免死锁（动态策略）</h4><ul><li><p><strong>安全序列</strong>，指如果系统按照这种序列分配资源，则每个进程都能顺利完成。</p><ul><li>只要能找出一个安全序列，系统就是<strong>安全状态</strong>。<strong>安全序列可能有多个</strong>。</li><li>如果分配了资源之后，系统中找不出任何一个安全序列，系统就进入了<strong>不安全状态</strong>。这就意味着之后<strong>可能</strong>所有进程都无法顺利的执行下去。<ul><li>如果有进程提前归还了一些资源，那系统也<strong>有可能重新回到安全状态</strong>，不过我们在分配资源之前总是要考虑到最坏的情况。</li></ul></li></ul></li><li><p>注意：</p><ul><li>如果系统处于<strong>安全状态</strong>，就<strong>一定不会发生死锁</strong>；如果系统进入<strong>不安全状态</strong>，就<strong>可能发生死锁</strong>。</li><li><strong>处于不安全状态未必会发生死锁，但发生死锁时一定是在不安全状态</strong></li></ul></li><li><p>核心思想：</p><ul><li>在进程提出资源申请时，先预判此次分配是否会导致系统进入不安全状态。如果会进入不安全状态，就暂时不答应这次请求，让该进程先阻塞等待。</li></ul></li><li><p>算法实现：</p><ul><li><p>假设系统中有 n 个进程，m 种资源</p></li><li><p>数据结构：</p><ul><li><p>n*m 矩阵 <strong>Max</strong> 表示各进程对资源的最大需求数</p></li><li><p>n*m 矩阵 <strong>Allocation</strong> 表示已经给各进程分配了多少资源</p></li><li><p>Max – Allocation = <strong>Need</strong> 矩阵表示各进程最多还需要多少资源</p></li><li><p>长度为 m 的一维数组 <strong>Available</strong> 表示还有多少可用资源</p></li><li><p>用长度为 m 的一位数组 <strong>Request</strong> 表示进程此次申请的各种资源数</p></li></ul></li><li><p>银行家算法步骤：</p><ul><li>Request ≤ Need[i]：检查此次申请是否超过了之前声明的最大需求数</li><li>Request ≤ Available：检查此时系统剩余的可用资源是否还能满足这次请求</li><li>Available -= Request；Allocation[i] += Request；Need[i] -= Request：试探着分配，更改各数据结构</li><li>用安全性算法<strong>检查此次分配是否会导致系统进入不安全状态</strong>（是否能找到安全序列）。若安全，才正式分配；否则，恢复相应数据，让进程阻塞等待。</li></ul></li><li><p><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part2/image-20211106153921852.png" alt="image-20211106153921852"></p></li><li><p><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part2/image-20211106154041109.png" alt="image-20211106154041109"></p></li></ul></li></ul><h4 id="死锁的检测与解除"><a href="#死锁的检测与解除" class="headerlink" title="死锁的检测与解除"></a>死锁的检测与解除</h4><p><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part2/image-20211106153523487.png" alt="image-20211106153523487"></p><p>如果系统中<strong>既不采取预防死锁的措施，也不采取避免死锁的措施</strong>，系统就很可能发生死锁。在这种情况下，系统应当提供两个算法：</p><ul><li><p>死锁检测算法：</p><ul><li>用于检测系统状态，以确定系统中是否发生了死锁。</li><li>算法实现：<ul><li>用某种<strong>数据结构</strong>来保存资源的请求和分配信息</li><li>提供<strong>一种算法</strong>，利用上述信息来检测系统是否已进入死锁状态</li><li><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part2/image-20211106160701820.png" alt="image-20211106160701820"></li><li>删去所有<strong>可以请求到足够资源</strong>（不阻塞）的<strong>进程节点的边</strong><ul><li>最终能消除所有边，就称这个图是<strong>可完全简化的</strong>。此时一定没有发生死锁（能找到一个安全序列）</li><li>如果最终不能消除所有边，那么此时就是发生了死锁。</li><li><strong>化简资源分配图后，还连着边的那些进程就是死锁进程</strong>。</li></ul></li></ul></li><li>死锁定理：如果某时刻系统的资源分配图是<strong>不可完全简化</strong>的，那么此时系统死锁</li></ul></li><li><p>死锁解除算法：</p><ul><li><p>当认定系统中已经发生了死锁，利用该算法可将系统从死锁状态中解脱出来。</p></li><li><p>解除死锁的主要方法有：</p><ol><li><p><strong>资源剥夺法</strong>。挂起（暂时放到外存上）某些死锁进程，并抢占它的资源，将这些资源分配给其他的死锁进程。但是应防止被挂起的进程长时间得不到资源而饥饿。</p></li><li><p><strong>撤销进程法</strong>（<strong>终止进程法</strong>）。强制撤销部分、甚至全部死锁进程，并剥夺这些进程的资源。这种方式的优点是实现简单，但所付出的代价可能会很大。因为有些进程可能已经运行了很长时间，已经接近结束了，一旦被终止可谓功亏一篑，以后还得从头再来。</p></li><li><p><strong>进程回退法</strong>。让一个或多个死锁进程回退到足以避免死锁的地步。这就要求系统要记录进程的历史信息，设置还原点。</p></li></ol></li><li><p>确定解除对象进程：</p><ol><li><p>进程优先级（优先级更高的进程先获得资源）</p></li><li><p>已执行时间（回退已执行时间越长的进程，代价越大）</p></li><li><p>预计完成花费时间（优先让快结束的进程获得资源）</p></li><li><p>进程已使用资源量（优先牺牲持有多资源的进程）</p></li><li><p>进程是交互式的还是批处理式的（优先牺牲批处理式进程）</p></li></ol></li></ul></li></ul>]]></content>
    
    
    <summary type="html">进程管理</summary>
    
    
    
    <category term="操作系统" scheme="https://nephrencake.gitee.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
  </entry>
  
  <entry>
    <title>操作系统-Part1</title>
    <link href="https://nephrencake.gitee.io/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part1/"/>
    <id>https://nephrencake.gitee.io/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part1/</id>
    <published>2021-11-01T01:42:56.000Z</published>
    <updated>2021-11-23T13:24:51.892Z</updated>
    
    <content type="html"><![CDATA[<h1 id="操作系统-Part1——计算机系统概述"><a href="#操作系统-Part1——计算机系统概述" class="headerlink" title="操作系统-Part1——计算机系统概述"></a>操作系统-Part1——计算机系统概述</h1><p>[TOC]</p><h2 id="操作系统的概念、功能"><a href="#操作系统的概念、功能" class="headerlink" title="操作系统的概念、功能"></a>操作系统的概念、功能</h2><p><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part1/image-20211101105704370.png" alt="image-20211101105704370"></p><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><ul><li><strong>操作系统</strong>（Operating System， OS）是指控制和<strong>管理</strong>整个计算机系统的<strong>硬件和软件资源</strong>，并合理地组织调度计算机的工作和资源的分配；以<strong>提供给用户和其他软件方便的接口和环境</strong>；它是计算机系统中最基本的<strong>系统软件</strong>。 <ul><li>操作系统是系统资源的管理者</li><li>向上层提供方便易用的服务</li><li>是最接近硬件的一层软件</li></ul></li></ul><h3 id="功能和目标"><a href="#功能和目标" class="headerlink" title="功能和目标"></a>功能和目标</h3><ul><li>作为系统资源的管理者<ul><li>功能：<ul><li>处理机管理</li><li>存储器管理</li><li>文件管理</li><li>设备管理</li></ul></li><li>目标：<ul><li>安全、高效</li></ul></li></ul></li><li>向上层提供方便易用的服务<ul><li>封装：操作系统把丑陋的硬件功能封装成简单易用的服务，使用户能更方便地使用计算机</li><li>实例：<ul><li>直接给用户使用<ul><li><strong>GUI</strong>（Graphical User Interface）：图形化用户接口</li><li>命令接口<ul><li><strong>联机命令接口</strong>（交互式命令接口）</li><li><strong>脱机命令接口</strong>（批处理命令接口）</li></ul></li></ul></li><li>给软件/程序员使用<ul><li><strong>程序接口</strong>：系统调用（广义指令）是应用程序请求操作系统服务的唯一方式</li></ul></li></ul></li><li>其中，命令接口与程序接口，统称为<strong>用户接口</strong>（狭义的用户接口不包括 GUI）</li></ul></li><li>作为最接近硬件的层次<ul><li>目标：实现<strong>对硬件机器的拓展</strong><ul><li>使单纯的硬件组合起来以获得更强的功能</li></ul></li><li>通常把覆盖了软件的机器成为扩充机器，又称之为虚拟机</li></ul></li></ul><h2 id="操作系统的特征"><a href="#操作系统的特征" class="headerlink" title="操作系统的特征"></a>操作系统的特征</h2><p><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part1/image-20211101105417671.png" alt="image-20211101105417671"></p><p>考点：</p><ul><li>并发和并行的区别</li><li>并发和共享<strong>互为存在条件</strong></li><li>并发和共享<strong>是操作系统的两个最基本的特征</strong>（没有并发和共享，就谈不上虚拟和异步）</li></ul><h3 id="基本特征"><a href="#基本特征" class="headerlink" title="基本特征"></a>基本特征</h3><ul><li>操作系统的特征<ul><li>并发</li><li>共享</li><li>虚拟</li><li>异步</li></ul></li><li>其中，并发和共享<strong>是两个最基本的特征，二者互为条件</strong>（重点）。</li></ul><h3 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h3><ul><li><p>并发：指两个或多个事件在同一时间间隔内发生。这些事件<strong>宏观上是同时发生的</strong>，但<strong>微观上是交替发生的</strong>。</p><ul><li>常考易混概念——<strong>并行</strong>：指两个或多个事件在<strong>同一时刻同时发生</strong>。</li></ul></li><li><p><strong>操作系统的并发性</strong>：指计算机系统中<strong>同时运行着多个程序</strong>，这些程序宏观上看是同时运行着的，而微观上看是交替运行的。</p><ul><li>操作系统就是伴随着“多道程序技术”而出现的，<strong>操作系统和程序并发是一起诞生的</strong>。</li></ul></li><li><p>注意（重要考点）：</p><ul><li>单核 CPU 同一时刻只能执行一个程序，各个程序<strong>只能并发</strong>地执行。</li><li>多核 CPU 同一时刻可以同时执行多个程序，多个程序<strong>可以并行</strong>地执行。</li></ul></li><li><p>只要有超过可并行数量的程序需要同时运行，那么并发性就是必不可少的。所以，<strong>并发性是操作系统一个最基本的特性</strong>。</p></li></ul><h3 id="共享"><a href="#共享" class="headerlink" title="共享"></a>共享</h3><ul><li><strong>共享</strong>：即资源共享，是指系统中的资源可供内存中多个并发执行的进程共同使用。</li><li>两种资源共享方式<ul><li>互斥共享方式：系统中的某些资源，虽然可以提供给多个进程使用，但<strong>一个时间段内只允许一个进程访问该资源</strong></li><li>同时共享方式：系统中的某些资源，<strong>允许一个时间段内由多个进程“同时”对它们进行访问</strong></li></ul></li><li>所谓的“同时”往往是宏观上的，而在微观上，<strong>这些进程可能是交替地对该资源进行访问的</strong>（分时共享）<ul><li>微观上交替，例：多个进程交替访问硬盘</li><li>也有可能是宏观上也为同时，例：多个进程同时使用扬声器</li></ul></li></ul><blockquote><p>并发和共享的关系：</p><ul><li>两个进程正在并发执行（并发性）<ul><li>如果失去并发性，则系统中只有一个程序正在运行，则共享性失去存在的意义</li></ul></li><li>需要共享地访问硬盘资源（共享性）<ul><li>如果失去共享性，则 QQ 和微信不能同时访问硬盘资源，就无法实现同时发送文件，也就无法并发</li></ul></li></ul></blockquote><h3 id="虚拟"><a href="#虚拟" class="headerlink" title="虚拟"></a>虚拟</h3><ul><li>虚拟：指把一个物理上的实体变为若干个逻辑上的对应物。物理实体（前者）是实际存在的，而逻辑上对应物（后者）是用户感受到的。</li><li>虚拟技术：<ul><li>空分复用技术<ul><li>如虚拟存储器技术：运行程序的大小远超实际内存</li></ul></li><li>时分复用技术：微观上处理机在各个微小的时间段内交替着为各个进程服务<ul><li>如虚拟处理器技术：实际只有单核，但是用户看来有多核 CPU 在工作</li></ul></li></ul></li></ul><blockquote><p>如果失去了并发性，就失去了实现虚拟性的意义了。因此，<strong>没有并发性，就谈不上虚拟性</strong>。</p></blockquote><h3 id="异步"><a href="#异步" class="headerlink" title="异步"></a>异步</h3><ul><li>进程的异步性：在多道程序环境下，允许多个程序并发执行，但由于资源有限，进程的执行只能以不可预知的速度向前推进。</li><li>并发运行的程序会争抢使用系统资源，而系统中的资源有限，因此进程的执行不是一贯到底的，而是走走停停的，向前推进的速度是不可预知的</li></ul><blockquote><p>如果失去了并发性，即系统只能串行地运行各个程序，那么每个程序的执行会一贯到底。<strong>只有系统拥有并发性，才有可能导致异步性</strong>。</p></blockquote><h2 id="操作系统的发展与分类"><a href="#操作系统的发展与分类" class="headerlink" title="操作系统的发展与分类"></a>操作系统的发展与分类</h2><p><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part1/image-20211101105849759.png" alt="image-20211101105849759"></p><h3 id="发展阶段"><a href="#发展阶段" class="headerlink" title="发展阶段"></a>发展阶段</h3><ul><li><p>手工操作阶段</p><ul><li>主要缺点：用户独占全机、人机速度矛盾导致资源利用率极低</li></ul></li><li><p>批处理阶段——单道批处理系统</p><ul><li>引入<strong>脱机输入/输出技术</strong>（用外围机+磁带完成），并由<strong>监督程序</strong>负责控制作业的输入、输出<ul><li>通过外围机把程序（纸带）提前存到磁带里，主机则读写磁带信息</li><li>监督程序是操作系统的雏形</li></ul></li><li>主要优点：缓解了一定程度的人机速度矛盾，资源利用率有所提升。</li><li>主要缺点：<ul><li>内存中仅能有一道程序运行，只有该程序运行结束之后才能调入下一道程序。</li><li>CPU 有大量的时间是在空闲等待 I/O 完成。资源利用率依然很低。</li></ul></li></ul></li><li><p>批处理阶段——多道批处理系统</p><ul><li>每次往内存中读入多道程序</li><li>操作系统正式诞生，用于支持多道程序并发运行</li><li>主要优点：多道程序并发执行，共享计算机资源。资源利用率大幅提升，CPU 和其他资源更能保持“忙碌”状态，系统吞吐量增大。</li><li>主要缺点：用户响应时间长，没有人机交互功能（用户提交自己的作业之后就只能等待计算机处理完成，中间不能控制自己的作业执行）</li></ul></li><li><p>分时操作系统</p><ul><li>计算机以<strong>时间片</strong>为单位<strong>轮流为各个用户/作业服务</strong>，各个用户可通过终端与计算机进行交互。</li><li>主要优点：用户请求可以被即时响应，<strong>解决了人机交互问题</strong>。允许多个用户同时使用一台计算机，并且用户对计算机的操作相互独立，感受不到别人的存在。</li><li>主要缺点：<strong>不能优先处理一些紧急任务</strong>。操作系统对各个用户/作业都是完全公平的，循环地为每个用户/作业服务一个时间片，不区分任务的紧急性。</li></ul></li><li><p>实时操作系统</p><ul><li>主要优点：能够优先响应一些紧急任务，某些紧急任务不需时间片排队。</li><li>在实时操作系统的控制下，计算机系统接收到外部信号后及时进行处理，并且<strong>要在严格的时限内处理完事件</strong>。实时操作系统的主要特点是<strong>及时性和可靠性</strong>。</li><li>分类：<ul><li>硬实时系统：必须在绝对严格的时间内完成处理（如：导弹控制系统、自动驾驶系统）</li><li>软实时系统：能接受偶尔违反时间规定（如：12306火车订票系统）</li></ul></li></ul></li><li><p>其他几种操作系统</p><ul><li>网络操作系统：是伴随着计算机网络的发展而诞生的，能把网络中各个计算机有机地结合起来，实现数据传送等功能，<strong>实现网络中各种资源的共享和各台计算机之间的通信</strong>。（如：Windows NT 就是一种典型的网络操作系统，网站服务器就可以使用）</li><li>分布式操作系统：主要特点是<strong>分布性和并行性</strong>。系统中的各台计算机地位相同，<strong>任何工作都可以分布在这些计算机上，由它们并行、协同完成这个任务</strong>。</li><li>个人计算机操作系统：如 Windows XP、MacOS，方便个人使用。</li></ul></li></ul><h2 id="操作系统的运行机制（考点）"><a href="#操作系统的运行机制（考点）" class="headerlink" title="操作系统的运行机制（考点）"></a>操作系统的运行机制（考点）</h2><p><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part1/image-20211101132816322.png" alt="image-20211101132816322"></p><h3 id="内核程序-v-s-应用程序"><a href="#内核程序-v-s-应用程序" class="headerlink" title="内核程序 v.s. 应用程序"></a>内核程序 v.s. 应用程序</h3><ul><li>普通程序员写的程序是“应用程序”</li><li>操作系统程序员写的是“内核程序”<ul><li>由多个<strong>内核程序</strong>组成了“操作系统内核”，或简称“内核（Kernel）”</li><li><strong>内核</strong>是操作系统最重要最核心的部分，也是<strong>最接近硬件的部分</strong></li><li>其实，一个操作系统只要有内核就够了（eg：Docker -&gt; 仅需 Linux 内核）</li><li>操作系统的功能未必都在内核中，如图形化用户界面 GUI</li></ul></li></ul><h3 id="特权指令-v-s-非特权指令"><a href="#特权指令-v-s-非特权指令" class="headerlink" title="特权指令 v.s. 非特权指令"></a>特权指令 v.s. 非特权指令</h3><ul><li><p>应用程序：只能使用“非特权指令”，如：加法、减法指令等</p></li><li><p>内核程序：作为 “管理者”有时会让CPU执行一些“特权指令”，如：内存清零指令。</p></li><li><p><strong>在 CPU 设计和生产的时候就划分了特权指令和非特权指令</strong>，因此 CPU 执行一条指令前就能判断出其类型</p></li></ul><h3 id="内核态-v-s-用户态"><a href="#内核态-v-s-用户态" class="headerlink" title="内核态 v.s. 用户态"></a>内核态 v.s. 用户态</h3><ul><li>CPU 有两种状态，“<strong>内核态</strong>”和“<strong>用户态</strong>”<ul><li>处于内核态时，说明此时正在运行的是<strong>内核程序</strong>，此时<strong>可以执行特权指令</strong></li><li>处于用户态时，说明此时正在运行的是<strong>应用程序</strong>，此时<strong>只能执行非特权指令</strong></li><li>内核态=核心态=<strong>管态</strong>；用户态=<strong>目态</strong></li><li>这两种状态由 PSW 中的一个二进制位表示</li></ul></li><li>内核态、用户态的切换<ul><li><strong>内核态 -&gt; 用户态</strong>：执行一条<strong>特权指令</strong>——<strong>修改 PSW</strong> 的标志位为“用户态”，这个动作意味着操作系统将主动让出 CPU 使用权</li><li><strong>用户态 -&gt; 内核态</strong>：由“<strong>中断</strong>”引发，<strong>由硬件完成变态过程</strong>，触发中断信号意味着操作系统将强行夺回 CPU 的使用权<ul><li>除非法使用特权指令外，还有很多事件需要让操作系统夺回 CPU 使用权。它们的共性是，<strong>但凡需要操作系统介入的地方，都会触发中断信号</strong></li></ul></li></ul></li></ul><h2 id="中断和异常（考点）"><a href="#中断和异常（考点）" class="headerlink" title="中断和异常（考点）"></a>中断和异常（考点）</h2><p><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part1/image-20211101140101072.png" alt="image-20211101140101072"></p><h3 id="中断的作用"><a href="#中断的作用" class="headerlink" title="中断的作用"></a>中断的作用</h3><ul><li>中断是<strong>让操作系统内核夺回 CPU 使用权的唯一途径</strong></li><li>没有中断机制，就<strong>不可能实现操作系统</strong>，<strong>不可能实现程序并发</strong></li></ul><h3 id="中断的类型"><a href="#中断的类型" class="headerlink" title="中断的类型"></a>中断的类型</h3><ul><li>内中断（异常）<ul><li>与当前执行的指令<strong>有关</strong>，中断信号来源于 CPU <strong>内部</strong></li><li><strong>特权指令</strong>：试图在用户态下执行特权指令</li><li><strong>非法指令</strong>：如，除零运算</li><li><strong>陷入指令</strong>：应用程序主动将控制权交给操作系统，常用于请求操作系统的服务（系统调用），该指令将引发一个内部中断信号<ul><li>陷入指令 = trap 指令 = <strong>访管指令</strong></li></ul></li></ul></li><li>外中断<ul><li>与当前执行的指令<strong>无关</strong>，中断信号来源于 CPU <strong>外部</strong></li><li><strong>每一条指令执行结束时</strong>，CPU 都会例行检查是否有外中断信号</li><li><strong>时钟中断</strong>：由时钟部件发来的中断信号。用于实现多道程序并发运行</li><li><strong>I/O 中断</strong>：由输入/输出设备发来的中断信号</li></ul></li><li>中断的分类<ul><li><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part1/image-20211101135845317.png" alt="image-20211101135845317"></li><li>大多数的教材、试卷中，“中断”特指狭义的中断，即外中断。而内中断一般称为“异常”</li></ul></li></ul><h3 id="中断机制的基本原理"><a href="#中断机制的基本原理" class="headerlink" title="中断机制的基本原理"></a>中断机制的基本原理</h3><ul><li>不同的中断信号，需要用不同的中断处理程序来处理。<ul><li>当 CPU 检测到中断信号后，会根据中断信号的类型去<strong>查询中断向量表</strong>，以此来找到相应的中断处理程序在内存中的存放位置。</li></ul></li><li>中断处理程序<strong>一定是内核程序</strong>，需要运行在“内核态”</li></ul><h2 id="系统调用（考点）"><a href="#系统调用（考点）" class="headerlink" title="系统调用（考点）"></a>系统调用（考点）</h2><p><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part1/image-20211101142240743.png" alt="image-20211101142240743"></p><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><ul><li>操作系统作向上提供的服务中，主要包括<strong>命令接口</strong>和<strong>程序接口</strong>。其中，<strong>程序接口由一组系统调用组成</strong>。</li><li><strong>系统调用</strong>，是操作系统提供给应用程序（程序员）使用的接口，应用程序可以通过系统调用来请求获得操作系统内核的服务</li></ul><h3 id="系统调用-v-s-库函数"><a href="#系统调用-v-s-库函数" class="headerlink" title="系统调用 v.s. 库函数"></a>系统调用 v.s. 库函数</h3><ul><li><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part1/image-20211101140936662.png" alt="image-20211101140936662" style="zoom:80%;"></li><li>不涉及系统调用的库函数：如“取绝对值”</li><li>涉及系统调用的库函数：如“创建一个新文件”</li></ul><h3 id="系统调用的必需性"><a href="#系统调用的必需性" class="headerlink" title="系统调用的必需性"></a>系统调用的必需性</h3><ul><li>针对问题：对于互斥共享的资源，各个程序不能同时使用</li><li>解决方案：由操作系统内核对共享资源进行统一的管理，并向上提供系统调用。<ul><li>用户进程想要使用打印机这种共享资源，只能通过系统调用向操作系统内核发出请求。内核会对各个请求进行协调处理。</li></ul></li></ul><h3 id="什么功能需要系统调用"><a href="#什么功能需要系统调用" class="headerlink" title="什么功能需要系统调用"></a>什么功能需要系统调用</h3><ul><li><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part1/image-20211101141628507.png" alt="image-20211101141628507"></li><li><strong>凡是与共享资源有关的操作</strong>（如存储分配、I/O操作、文件管理等），<strong>都必须通过系统调用的方式向操作系统内核提出服务请求</strong>，由操作系统内核代为完成。</li><li>这样可以<strong>保证系统的稳定性和安全性</strong>，防止用户进行非法操作。</li></ul><h3 id="系统调用的过程"><a href="#系统调用的过程" class="headerlink" title="系统调用的过程"></a>系统调用的过程</h3><ul><li><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part1/image-20211101142044385.png" alt="image-20211101142044385"></li><li>过程：<ul><li>传递系统调用参数</li><li>执行陷入指令（用户态）</li><li>执行相应的内请求核程序处理系统调用（核心态）</li><li>返回应用程序</li></ul></li><li>注意：<ul><li><strong>陷入指令是在用户态执行的</strong>，执行陷入指令之后立即引发一个<strong>内中断</strong>，使 CPU 进入<strong>核心态</strong></li><li><strong>发出系统调用请求是在用户态</strong>，而<strong>对系统调用的相应处理在核心态下进行</strong></li></ul></li></ul><h2 id="操作系统的体系结构"><a href="#操作系统的体系结构" class="headerlink" title="操作系统的体系结构"></a>操作系统的体系结构</h2><p><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part1/image-20211101143353619.png" alt="image-20211101143353619"></p><h3 id="操作系统内核"><a href="#操作系统内核" class="headerlink" title="操作系统内核"></a>操作系统内核</h3><ul><li><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part1/image-20211101133719590.png" alt="image-20211101133719590" style="zoom:80%;"></li><li><strong>内核</strong>是计算机上配置的<strong>底层软件</strong>，是操作系统最基本、最核心的部分。</li><li>实现操作系统内核功能的那些程序就是<strong>内核程序</strong>。</li><li><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part1/image-20211101134031062.png" alt="image-20211101134031062"></li></ul><h3 id="大内核与微内核"><a href="#大内核与微内核" class="headerlink" title="大内核与微内核"></a>大内核与微内核</h3><ul><li><p>通过对内核功能的划分（是否包含对系统资源的管理），可以分为<strong>大内核/单内核/宏内核</strong>和<strong>微内核</strong></p><ul><li>典型的 大内核/宏内核/单内核 操作系统： Linux、UNIX</li><li>典型的 微内核 操作系统： Windows NT</li></ul></li><li><p>注意：</p><ul><li><p>操作系统<strong>内核功能运行在内核态</strong></p></li><li><p>操作系统<strong>非内核功能运行在用户态</strong></p></li><li><p>变态的过程是有成本的，要消耗不少时间，频繁地变态会降低系统性能</p></li></ul></li><li><p><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part1/image-20211101143313918.png" alt="image-20211101143313918"></p></li></ul><h1 id="习题课"><a href="#习题课" class="headerlink" title="习题课"></a>习题课</h1><h2 id="1-1-4"><a href="#1-1-4" class="headerlink" title="1.1.4"></a>1.1.4</h2><ol><li><p>软件分类</p><ul><li>按软件的用户群体分类<ul><li><strong>通用软件</strong>：普通大众都会使用的（如Office、迅雷）</li><li><strong>专用软件</strong>：某些领域的专业人士使用的（如AutoCAD Logic Pro）</li></ul></li><li>按照软件在计算机内的角色分类<ul><li><strong>系统软件</strong>：操作系统、数据库管理程序（DBMS）、语言处理程序（编译、汇编）、服务性程序（装入程序）、标准库程序（printf）</li><li><strong>应用软件</strong>：微信、Office</li></ul></li></ul></li><li><p>操作系统既管理软件，也管理硬件（可以从任务管理器看出）</p><ul><li>软件 vs 应用程序：<strong>软件 = 程序 + 其他相关文件</strong></li><li>eg：一个游戏软件包括程序（.exe）和其它图片（.bmp等）、音效（.wav等）等附件，那么这个程序（.exe）称作<strong>应用程序</strong>，而它与其他文件（图片、音效等）在一起合称<strong>软件</strong></li><li>操作系统管理<strong>计算机资源</strong><ul><li>软件、硬件、文件都属于计算机资源</li><li>若只给出软件、硬件，则依然不如计算机资源更全面，不正确</li></ul></li></ul></li><li><p>源代码属于文件。但是操作系统关心的是文件的结构与组织，而不是文件内容。</p></li><li><p>界面 = 接口 = Interface</p><ul><li>操作系统提供给用户程序使用的接口：系统调用</li><li>操作系统提供给用户直接使用的接口：命令接口、GUl</li></ul></li><li><p>发展历程：</p><ul><li>1950 年代早期第一个操作系统诞生（批处理操作系统）<ul><li>定义：操作系统是指控制和管理整个计算机系统的硬件和软件资源，并合理地组织调度计算机的工作和资源的分配；以提供给用户和其他软件方便的接口和环境；它是计算机系统中最基本的系统软件。 </li><li><strong>管理和控制计算机资源</strong>，更加基本</li><li>其他三个选项可以说是应用程序提供的功能</li></ul></li><li>后来才支持用户交互</li><li>1970 年代早期，第一个 GUI 诞生</li><li>1983 年互联网诞生</li></ul></li><li><p>并发和共享<strong>互为存在条件</strong>；并发和共享<strong>是操作系统的两个最基本的特征</strong>。</p></li><li><p>并发：宏观上同时，微观上交替发生。并行：微观上同时发生。</p><ul><li>并发不没有严格规定要在同一时间间隔内发生，彼此发生间隔不同也是可以的</li><li>但是其他选项更不对</li></ul></li><li><p>单处理机 = 单核 CPU。不可能并发执行多个程序</p></li><li><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part1/image-20211123205819442.png" alt="image-20211123205819442" style="zoom:80%;"></li><li><p>系统调用是操作系统为应用程序使用内核功能所提供的的接口。</p></li><li><p>请求系统服务：更为概括的描述</p><p>中止系统服务：如 Linux 中的 exit 系统调用请求中止进程</p><p>申请系统资源：如 open 系统调用，可请求打开一个文件或 IO 设备</p><p>释放系统资源：如 close 系统调用，可请求关闭一个文件或 IO 设备</p></li><li><p>系统调用，文件 I/O 需要在内核态运行。</p></li><li><p>Shell：即 Unix、Linux 的命令接口</p><p>命令解释器：解释用户在“小黑框”输入的命令，如：cd、ls 等</p><p>广义指令：即系统调用</p><p>缓存管理：对用户不可见，由操作系统负责</p></li><li><p>制约性：程序的执行因为共享资源而相互制约</p><p>间断性：一个程序的执行是走走停停的</p><p>顺序性：各个程序按顺序依次执行</p><ul><li>顺序性是单道程序设计的基本特征</li><li>自从引入多道程序设计之后，程序的执行就失去了封闭性和顺序性</li></ul><p>共享性：多道程序共享资源</p></li><li><p>OS 管理资源：后序章节会有体会</p><p>OS 管理用户程序执行：第二章，处理机管理</p><p>OS 使系统资源提高效率：各种调度算法</p><p>用来编程的程序：eclipse、IntelliJ IDEA、VS …</p></li><li><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part1/image-20211123212445393.png" alt="image-20211123212445393" style="zoom: 50%;"></li></ol>]]></content>
    
    
    <summary type="html">计算机系统概述</summary>
    
    
    
    <category term="操作系统" scheme="https://nephrencake.gitee.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
  </entry>
  
  <entry>
    <title>计算机组成原理-完结目录</title>
    <link href="https://nephrencake.gitee.io/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E5%AE%8C%E7%BB%93%E7%9B%AE%E5%BD%95/"/>
    <id>https://nephrencake.gitee.io/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E5%AE%8C%E7%BB%93%E7%9B%AE%E5%BD%95/</id>
    <published>2021-10-02T02:53:51.000Z</published>
    <updated>2021-10-31T01:38:07.829Z</updated>
    
    <content type="html"><![CDATA[<h1 id="计算机组成原理-完结目录"><a href="#计算机组成原理-完结目录" class="headerlink" title="计算机组成原理-完结目录"></a>计算机组成原理-完结目录</h1><p>教程视频传送门：</p><ol><li><a href="https://www.bilibili.com/video/BV1BE411D7ii">王道计算机考研 计算机组成原理</a></li></ol><p>推荐资源：</p><ol><li>王道配套书</li></ol><p>不能只看视频，==要过一遍书，做一遍题==！</p><table><thead><tr><th align="center"><a href="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part1/">计算机组成原理-Part1——计算机系统概述</a></th></tr></thead><tbody><tr><td align="center"><strong><a href="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part2/">计算机组成原理-Part2——数据的表示和运算</a></strong></td></tr><tr><td align="center"><strong><a href="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part3/">计算机组成原理-Part3——存储系统</a></strong></td></tr><tr><td align="center"><strong><a href="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part4/">计算机组成原理-Part4——指令系统</a></strong></td></tr><tr><td align="center"><strong><a href="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part5/">计算机组成原理-Part5——中央处理器</a></strong></td></tr><tr><td align="center"><strong><a href="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part6/">计算机组成原理-Part6——总线</a></strong></td></tr><tr><td align="center"><strong><a href="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part7/">计算机组成原理-Part7——I/O 系统</a></strong></td></tr></tbody></table>]]></content>
    
    
    <summary type="html">完结目录</summary>
    
    
    
    <category term="计算机组成原理" scheme="https://nephrencake.gitee.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    
    
    <category term="408" scheme="https://nephrencake.gitee.io/tags/408/"/>
    
  </entry>
  
  <entry>
    <title>计算机组成原理-Part7</title>
    <link href="https://nephrencake.gitee.io/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part7/"/>
    <id>https://nephrencake.gitee.io/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part7/</id>
    <published>2021-10-02T02:53:29.000Z</published>
    <updated>2021-11-15T04:45:50.444Z</updated>
    
    <content type="html"><![CDATA[<h1 id="计算机组成原理-Part7——I-O-系统"><a href="#计算机组成原理-Part7——I-O-系统" class="headerlink" title="计算机组成原理-Part7——I/O 系统"></a>计算机组成原理-Part7——I/O 系统</h1><p>[TOC]</p><h2 id="I-O-系统基本概念"><a href="#I-O-系统基本概念" class="headerlink" title="I/O 系统基本概念"></a>I/O 系统基本概念</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><ul><li>I/O 设备：可以将数据输入到计算机，或者可以接收计算机输出数据的外部设备，包括<strong>输入设备、输出设备、外存设备</strong>。</li><li>I/O 接口：又称 I/O 控制器（I/O Controller）、设备控制器，负责协调主机与外部设备之间的数据传输<ul><li>I/O 控制器就是一块芯片，常被集成在主板上</li><li>现在的 I/O 接口（芯片）也会被集成在南桥芯片内部</li></ul></li><li>数据流：键盘 -&gt; I/O 接口的数据寄存器 -&gt; 数据总线 -&gt; CPU某寄存器 -&gt; 主存（变量 i 的对应位置）</li></ul><h3 id="控制方式"><a href="#控制方式" class="headerlink" title="控制方式"></a>控制方式</h3><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part7/image-20211028202903178.png" alt="image-20211028202903178" style="zoom:80%;"><ul><li><strong>程序查询方式</strong>：CPU 不断轮询检查 I/O 控制器中的“状态寄存器”，<strong>直到检测到状态为“已完成”之后</strong>，才从数据寄存器取出输入数据（如程序中的输入等待）</li><li><strong>程序中断方式</strong>：等待键盘 I/O 时 CPU 可以先去执行其他程序，<strong>键盘 I/O 完成后 I/O 控制器向 CPU 发出中断请求，CPU 响应中断请求</strong>，并取走输入数据</li><li><strong>DMA 控制方式</strong>：主存与高速 I/O 设备之间有一条直接数据通路（DMA总线）。CPU 向 DMA 接口发出“读/写”命令，并指明主存地址、磁盘地址、读写数据量等参数。<ul><li>DMA 控制器自动控制磁盘与主存的数据读写，<strong>DMA 控制器与主存每次传送1个字</strong>，<strong>每当完成一整块数据读写</strong>（如 1KB 为一整块） ，才向 CPU 发出一次中断请求。</li><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part7/image-20211027224155076.png" alt="image-20211027224155076" style="zoom:80%;"></li></ul></li><li><strong>通道控制方式</strong>：相比 DMA 控制方式，不仅不与高速外设进行直接相连，包括低速外设都交由通道来管理，且通道程序保存在内存中。<ul><li>针对场景：I/O 密集型场景</li><li>通道：可以理解为是“弱鸡版的 CPU”。通道可以识别并执行一系列通道指令，通道指令种类、功能通常比较单一</li><li>步骤：<ol><li>CPU 向通道发出 I/O 指令。指明通道程序在内存中的位置，并指明要操作的是哪个 I/O 设备。CPU 就可以去做其他事情</li><li>通道执行内存中的通道程序，控制 I/O 设备完成一系列任务</li><li>通道执行完规定的任务后，向 CPU 发出中断请求，之后 CPU 对中断进行处理</li></ol></li><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part7/image-20211027224229248.png" alt="image-20211027224229248" style="zoom:80%;"></li></ul></li></ul><h3 id="系统基本组成"><a href="#系统基本组成" class="headerlink" title="系统基本组成"></a>系统基本组成</h3><ul><li>一般来说，I/O 系统由 I/O 软件和 I/O 硬件两部分构成。</li><li>I/O 硬件：包括外部<strong>设备、I/O 接口 、I/O 总线</strong>等。</li><li>I/O 软件：包括<strong>驱动程序、用户程序、管理程序、升级补丁</strong>等。通常采用 <strong>I/O 指令</strong>和<strong>通道指令</strong>实现信息交换。<ul><li>I/O 指令：CPU 指令的一部分<ul><li>操作码（CPU 对 IO 接口做什么）+ 命令码（IO 接口对设备做什么）+ 设备码（对哪个设备进行操作）</li></ul></li><li>通道指令：通道能识别的指令（提前编制好放在主存中）<ul><li>在含有通道的计算机中，CPU 执行 I/O 指令对通道发出命令，由通道执行一系列通道指令，代替 CPU 对 I/O 设备进行管理</li></ul></li></ul></li></ul><h2 id="外部设备"><a href="#外部设备" class="headerlink" title="外部设备"></a>外部设备</h2><h3 id="总览"><a href="#总览" class="headerlink" title="总览"></a>总览</h3><ul><li>外部设备<ul><li>输入设备<ul><li>用于向计算机系统输入命令和文本、数据等信息的部件。</li><li>键盘、鼠标</li></ul></li><li>输出设备<ul><li>用于将计算机系统中的信息输出到计算机外部进行显示、交换等的部件。</li><li>显示器、打印机</li></ul></li><li>外存储器（考点：磁盘存取时间的计算）<ul><li>指除计算机内存及CPU缓存等以外的存储器。</li><li>磁盘存储器、磁盘阵列、光盘存储器、SSD</li></ul></li></ul></li></ul><h3 id="显示器"><a href="#显示器" class="headerlink" title="显示器"></a>显示器</h3><h4 id="性能标准（考点：显存的计算）"><a href="#性能标准（考点：显存的计算）" class="headerlink" title="性能标准（考点：显存的计算）"></a>性能标准（考点：显存的计算）</h4><ul><li>屏幕大小：以对角线长度表示，常用的有 12～29 英寸等。</li><li>分辨率：所能表示的像素个数，<strong>宽、高的像素的乘积</strong>，如1920×1280。</li><li>灰度级：显示的像素点的亮暗差别，典型的有 8 位（256级）、16 位等。<strong>n 位可以表示 2^n^ 种不同的亮度或颜色</strong>。</li><li>刷新：单位时间内扫描整个屏幕内容的次数，通常显示器刷新频率在 60～120 Hz。</li><li>显示存储器（VRAM）：<ul><li>也称刷新存储器，<strong>显存</strong>。由图像分辨率和灰度级决定，分辨率越高，灰度级越多，刷新存储器容量越大。</li><li>显存除了作为当前显示帧的缓存，还会用于保存用于渲染的图像数据，如 3D 模型。</li><li>集成显卡计算机中，通常分配一片内存作为显存</li><li><strong>VRAM 容量 = 分辨率 × 灰度级位数</strong><ul><li>例：1440 × 900 × 3 B ≈ 3.7MB（最低工作要求，能够存储一帧图像的信息）</li></ul></li><li><strong>VRAM 带宽 = 分辨率 × 灰度级位数 × 帧频</strong><ul><li>例：3.7 × 60 Hz = 222MB/s</li></ul></li></ul></li><li>显示器分类<ul><li>阴极射线管（CRT）显示器</li><li>液晶（LCD）显示器</li><li>发光二极管（LED）显示器</li></ul></li></ul><h4 id="阴极射线管显示器（考点：字符点阵的存储）"><a href="#阴极射线管显示器（考点：字符点阵的存储）" class="headerlink" title="阴极射线管显示器（考点：字符点阵的存储）"></a>阴极射线管显示器（考点：字符点阵的存储）</h4><p>按显示信息内容不同可分为</p><ul><li><strong>字符显示器</strong>（计算器）</li><li>图形显示器（特别用途设备）<ul><li>优点：分辨率高且显示的曲线平滑。</li><li>缺点：当显示复杂图形时，会有闪烁感。</li></ul></li><li>图像显示器（用户友好界面）</li></ul><p>字符显示器：</p><ul><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part7/image-20211028115857070.png" alt="image-20211028115857070"></li><li>显示字符的方法以点阵为基础。<ul><li><strong>点阵是指由 m×n 个点组成的阵列</strong>。</li><li>点阵的多少取决于显示<strong>字符的质量</strong>和<strong>字符窗口</strong>的大小。<ul><li><strong>字符窗口是指每个字符在屏幕上所占的点数</strong>，包括字符显示点阵和字符间隔。</li></ul></li></ul></li><li>对应于每个字符窗口，所需显示<strong>字符的 ASCII 代码被存放在视频存储器 VRAM</strong> 中，以备刷新。</li><li>将<strong>点阵存入由 ROM 构成的字符发生器</strong>中，在 CRT 进行光栅扫描的过程中，从字符发生器中依次读出某个字符的点阵，按照点阵中 0 和 1 代码不同控制扫描电子束的开或关，从而在屏幕上显示出字符。<ul><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part7/image-20211028115930559.png" alt="image-20211028115930559" style="zoom:80%;"></li><li>按扫描方式不同可分为<ul><li>光栅扫描显示器</li><li>随机扫描显示器</li></ul></li></ul></li></ul><h3 id="打印机"><a href="#打印机" class="headerlink" title="打印机"></a>打印机</h3><ul><li>按印字原理不同可分为<ul><li><strong>击打式打印机</strong>：利用机械动作使印字机构与色带和纸相撞而打印字符<ul><li>优：设备成本低 、印字质量好、防伪性好</li><li>缺：噪声大、速度慢</li></ul></li><li><strong>非击打式打印机</strong>：采用电、磁、光、喷墨等物理、化学方法来印刷字符<ul><li>优：速度快、噪声小</li><li>缺：成本高</li></ul></li></ul></li><li>按打印机工作方式不同可分为<ul><li><strong>串行打印机</strong>：逐字打印、速度慢</li><li><strong>行式打印机</strong>：逐行打印、速度快</li></ul></li><li>按工作方式可分为<ul><li><strong>针式打印机</strong>：<ul><li>原理：在联机状态下，主机发出打印命令，经接口、检测和控制电路，间歇驱动纵向送纸和打印头横向移动，同时驱动打印机间歇冲击色带，在纸上打印出所需内容。</li><li>特点：擅长多层复写打印，实现各种票据或蜡纸等的打印。工作原理简单，造价低廉，耗材（色带）便宜，但打印分辨率和打印速度不够高。</li></ul></li><li><strong>喷墨式打印机</strong>：<ul><li>原理：带电的喷墨雾点经过电极偏转后，直接在纸上形成所需字形。彩色喷墨打印机基于三基色原理，即分别喷射 3 种颜色墨滴，按一定的比例混合出所要求的颜色。</li><li>特点：打印噪声小，可实现高质量彩色打印；通常打印速度比针式打印机快；但防水性差，高质量打印需要专用打印纸。</li></ul></li><li><strong>激光打印机</strong>：<ul><li>原理：计算机输出的二进制信息，经过调制后的激光束扫描，在感光鼓上形成潜像，再经过显影、转印和定影，便在纸上得到所需的字符或图像。</li><li>特点：打印质量高、速度快、噪声小、处理能力强；但耗材多、价格较贵、不能复写打印多份，且对纸张的要求高。感光鼓（也称为硒鼓）是激光打印机的核心部件。</li></ul></li></ul></li></ul><h3 id="外部存储器"><a href="#外部存储器" class="headerlink" title="外部存储器"></a>外部存储器</h3><h4 id="磁表面存储器简介"><a href="#磁表面存储器简介" class="headerlink" title="磁表面存储器简介"></a>磁表面存储器简介</h4><ul><li>磁表面存储器，是指把<strong>磁性材料</strong>薄薄地涂在金属铝或塑料表面上作为载磁体来存储信息。磁盘存储器、磁带存储器和磁鼓存储器均属于磁表面存储器。</li><li>磁表面存储器的优点：<ul><li>存储容量大，位价格低； </li><li>记录介质可以重复使用；</li><li>记录信息可以长期保存而不丢失，甚至可以脱机存档； </li><li>非破坏性读出，读出时不需要再生。</li></ul></li><li>磁表面存储器的缺点：<ul><li>存取速度慢；</li><li>机械结构复杂；</li><li>对工作环境要求较高。</li></ul></li><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part7/image-20211028122201199.png" alt="image-20211028122201199"></li><li>原理：当磁头和磁性记录介质有相对运动时，通过电磁转换（/切割磁感线）完成读/写操作。</li><li>编码方法：按某种方案，把一串二进制信息变换成存储介质磁层中一个磁化翻转状态的序列。</li><li>磁记录方式：通常采用调频制（FM）和改进型调频制（MFM）的记录方式。</li></ul><h4 id="磁盘设备"><a href="#磁盘设备" class="headerlink" title="磁盘设备"></a>磁盘设备</h4><h5 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h5><ul><li>硬盘存储器<ul><li>硬盘存储器由磁盘驱动器、磁盘控制器和盘片组成。</li><li>磁盘驱动器：核心部件是磁头组件（磁头移动臂）和盘片组件（驱动轴盘片），温彻斯特盘是一种可移动头固定盘片的硬盘存储器。</li><li>磁盘控制器：是硬盘存储器和主机的接口，主流的标准有 IDE、SCSI、SATA 等。</li></ul></li><li>存储区域：<ul><li><strong>一块硬盘</strong>含有<strong>若干个盘片</strong>；（即有好几个盘）</li><li><strong>每个盘片</strong>可以有 1 或 2 面<strong>盘面</strong>；（即磁盘的正反面都可以利用，每个盘面对应 1 个磁头）</li><li><strong>每个记录面</strong>划分为<strong>若干条磁道</strong>；（<strong>所有记录面上的同一条磁道组成一个柱面</strong>）</li><li>而<strong>每条磁道</strong>又划分为<strong>若干个扇区</strong>；（切蛋糕）</li><li><strong>扇区（也称块）是磁盘读写的最小单位</strong>，也就是说磁盘<strong>按块存取</strong>。</li><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part7/image-20211028124407864.png" alt="image-20211028124407864"></li></ul></li><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part7/image-20211028124733827.png" alt="image-20211028124733827"></li></ul><h5 id="性能指标"><a href="#性能指标" class="headerlink" title="性能指标"></a>性能指标</h5><ul><li>磁盘的容量：一个磁盘所能存储的字节总数称为磁盘容量。磁盘容量有非格式化容量和格式化容量之分。<ul><li>非格式化容量：指磁记录表面理论氪用的磁化单元总数。</li><li>格式化容量：指按照某种特定的记录格式后所能利用、存储的信息总量。</li></ul></li><li>记录密度：记录密度是指盘片单位面积上记录的二进制的信息量，通常以道密度、位密度和面密度表示。<ul><li>道密度：沿磁盘半径方向单位长度上的磁道数；</li><li>位密度：一条磁道单位长度上能记录的二进制代码位数；</li><li>面密度：位密度和道密度的乘积。</li><li>注意：磁盘所有磁道记录的信息量一定是相等的，并不是圆越大信息越多，故<strong>越内侧的磁道位密度越大</strong>。</li></ul></li><li>平均存取时间：<ul><li><code>平均存取时间 = 磁盘控制器延迟（可能会有）+ 寻道时间（磁头移动到目的磁道）+ 旋转延迟时间（磁头定位到所在扇区）+ 传输时间（传输数据所花费的时间）</code></li><li>一般寻道时间会在题中给出，旋转延迟时间可以按数学期望（即转半圈）来计算，同时通过转速也可以确定转一个扇区的时间</li><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part7/image-20211028130946542.png" alt="image-20211028130946542" style="zoom:80%;"></li></ul></li><li>数据传输率：磁盘存储器在单位时间内向主机传送数据的字节数，称为数据传输率。<ul><li>假设磁盘转数为 r（转/秒），每条磁道容量为 N 个字节，则数据传输率为 D<del>r</del>=r×N</li></ul></li></ul><h5 id="磁盘地址"><a href="#磁盘地址" class="headerlink" title="磁盘地址"></a>磁盘地址</h5><ul><li>主机向磁盘控制器发送寻址信息，包括<ul><li>驱动器号：一台电脑可能有多个硬盘</li><li>柱面（磁道）号：移动磁头臂（寻道）</li><li>盘面号：激活某个磁头</li><li>扇区号：通过旋转将特定扇区划过磁头下方</li></ul></li><li>例：若系统中有 4 个驱动器，每个驱动器带一个磁盘，每个磁盘 256 个磁道、16 个盘面，每个盘面划分为 16个扇区，则每个扇区地址要 18 位二进制代码<ul><li>驱动器号（2bit）+ 柱面（磁道）号（8bit）+ 盘面号（4bit）+ 扇区号（4bit） </li></ul></li></ul><h5 id="硬盘的工作过程"><a href="#硬盘的工作过程" class="headerlink" title="硬盘的工作过程"></a>硬盘的工作过程</h5><ul><li>硬盘的主要操作是<strong>寻址、读盘、写盘</strong>。每个操作都对应一个控制字，硬盘工作时，第一步是取控制字，第二步是执行控制字。</li><li>硬盘属于机械式部件，其读写操作是串行的，不可能在同一时刻既读又写，也不可能在同一时刻读两组数据或写两组数据。</li><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part7/image-20211028150614567.png" alt="image-20211028150614567" style="zoom:80%;"></li></ul><h4 id="磁盘阵列"><a href="#磁盘阵列" class="headerlink" title="磁盘阵列"></a>磁盘阵列</h4><ul><li>RAID（ Redundant Array of Inexpensive Disks，廉价冗余磁盘阵列）是将多个独立的物理磁盘组成一个独立的逻辑盘，数据在多个物理盘上分割交叉存储、并行访问，具有更好的存储性能、可靠性和安全性。</li><li>RAID 有 RAID1～RAID5 的几种方案，无论何时有磁盘损坏，都可以随时拔出受损的磁盘再插入好的磁盘，而数据不会损坏。（raid 数越高，冗余越少、越稳定）<ul><li>RAID0：无冗余和无校验的磁盘阵列。（条带化，提高存取速度，没有容错能力）</li><li>RAID1：镜像磁盘阵列。（镜像磁盘互为备份，容量减少一半）</li><li>RAID2：采用纠错的海明码的磁盘阵列。（开始通过数据校验提高容错能力）</li><li>RAID3：位交叉奇偶校验的磁盘阵列。</li><li>RAID4：块交叉奇偶校验的磁盘阵列。</li><li>RAID5：无独立校验的奇偶校验磁盘阵列。</li></ul></li><li>RAID 通过同时使用多个磁盘，提高传输率；通过在多个磁盘上并行存取来大幅提高存储系统的数据吞吐量；通过镜像功能，提高安全可靠性；通过数据校验，提供容错能力。</li></ul><h4 id="光盘存储器"><a href="#光盘存储器" class="headerlink" title="光盘存储器"></a>光盘存储器</h4><ul><li>利用光学原理读/写信息的存储装置，采用聚焦激光束对盘式介质以非接触的方式记录信息。</li><li>光盘的类型：<ul><li>CD-ROM：只读型光盘，只能读出其中内容，不能写入或修改。</li><li>CD-R：只可写入一次信息，之后不可修改。</li><li>CD-RW：可读可写光盘，可以重复读写。</li><li>DVD-ROM：高容量的 CD-ROM，DVD 表示通用数字化多功能光盘。</li></ul></li></ul><h4 id="固态硬盘"><a href="#固态硬盘" class="headerlink" title="固态硬盘"></a>固态硬盘</h4><ul><li>由 Flash Memory 组成，以及其他硬件和软件的支持。</li><li>闪存（Flash Memory）是在 E2PROM 的基础上发展起来的，<strong>本质上是只读存储器</strong>。</li></ul><h2 id="I-O-接口"><a href="#I-O-接口" class="headerlink" title="I/O 接口"></a>I/O 接口</h2><h3 id="主要功能"><a href="#主要功能" class="headerlink" title="主要功能"></a>主要功能</h3><ul><li><strong>数据缓冲</strong>：通过<strong>数据缓冲寄存器</strong>（DBR）达到主机和外设工作速度的匹配</li><li><strong>错误或状态监测</strong>：通过<strong>状态寄存器</strong>反馈设备的各种错误、状态信息，供 CPU 查用</li><li><strong>控制和定时</strong>：接收从控制总线发来的控制信号、时钟信号</li><li><strong>数据格式转换</strong>：“串-并”、“并-串”等格式转换</li><li><strong>与主机和设备通信</strong>：实现“主机—I/O接口—I/O设备”之间的通信</li></ul><h3 id="结构与原理"><a href="#结构与原理" class="headerlink" title="结构与原理"></a>结构与原理</h3><ul><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part7/image-20211028162350702.png" alt="image-20211028162350702" style="zoom: 67%;"><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part7/image-20211028202711609.png" alt="image-20211028202711609" style="zoom:67%;"></li><li><strong>内部接口</strong>：内部接口与系统总线相连，实质上是与内存、CPU 相连。</li><li><strong>外部接口</strong>：外部接口通过接口电缆与外设相连。外部接口的数据传输可能是串行方式，因此 I/O 接口需具有串/并转换功能。</li><li><strong>工作原理</strong>：<ul><li>发命令：发送<strong>命令字</strong>到 I/O 控制寄存器，向设备发送命令（需要驱动程序的协助）</li><li>读状态：从状态寄存器读取<strong>状态字</strong>，获得设备或 I/O 控制器的状态信息</li><li>读/写数据：从数据缓冲寄存器发送或读取数据，完成主机与外设的数据交换</li></ul></li><li>控制寄存器、状态寄存器在<strong>使用时间上错开</strong>，因此有的 I/O 接口中可将二者合二为一</li><li><strong>IO 控制器中的一个个寄存器也称为一个个 I/O 端口</strong></li></ul><h3 id="I-O-端口"><a href="#I-O-端口" class="headerlink" title="I/O 端口"></a>I/O 端口</h3><ul><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part7/image-20211028164339128.png" alt="image-20211028164339128" style="zoom: 67%;"><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part7/image-20211028163713330.png" alt="image-20211028163713330" style="zoom:80%;"></li><li><strong>统一编址</strong>：靠不同的<strong>地址码</strong>区分内存和 I/O 设备。<strong>访存类的指令都</strong>可以访问 I/O 端口。又称<strong>存储器映射方式</strong>。<ul><li>优点：1. 不需要专门的输入/输出指令，所有访存指令可直接访问端口，程序设计灵活性高；2. 端口有较大的编址空间；3. 读写控制逻辑电路简单</li><li>缺点：1. 端口占用了主存地址空间，使主存地址空间变小；2. 外设寻址时间长（地址位数多，地址译码速度慢）</li></ul></li><li><strong>独立编址</strong>：靠不同的<strong>指令</strong>区分内存和 I/O 设备。<strong>只能用专门的 I/O 指令</strong>可以访问 I/O 端口。<ul><li>优点：1. 使用专用 I/O 指令，程序编制清晰；2. I/O 端口地址位数少，<strong>地址译码速度快</strong>；3. I/O 端口的地址不占用主存地址空间</li><li>缺点：1. I/O 指令类型少，一般只能对端口进行传送操作；2. <strong>程序设计灵活性差</strong>；3. 需要 CPU 提供存储器读/写、I/O 设备读/写两组控制信号，增加了控制逻辑电路的复杂性</li></ul></li></ul><h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><ul><li>按数据传送方式可分为<ul><li><strong>并行接口</strong>：一个字节或一个字所有位同时传送。</li><li><strong>串行接口</strong>：一位一位地传送。</li><li>这里指的是<strong>外设和接口一侧</strong>的传送方式，为了传输到主机和接口一侧，接口要完成数据格式转换。</li></ul></li><li>按主机访问I/O设备的控制方式可分为<ul><li>程序查询接口</li><li>中断接口</li><li>DMA 接口</li></ul></li><li>按功能选择的灵活性可分为<ul><li>可编程接口</li><li>不可编程接口</li></ul></li></ul><h2 id="I-O-方式"><a href="#I-O-方式" class="headerlink" title="I/O 方式"></a>I/O 方式</h2><h3 id="程序查询方式"><a href="#程序查询方式" class="headerlink" title="程序查询方式"></a>程序查询方式</h3><ul><li>优点：接口<strong>设计简单</strong>、设备量少。</li><li>缺点：CPU 在信息传送过程中要<strong>花费很多时间用于查询和等待</strong>，而且在一段时间内只能和一台外设交换信息，效率大大降低。</li><li>例题<ul><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part7/image-20211028211418243.png" alt="image-20211028211418243"></li></ul></li><li><strong>独占查询</strong>：CPU 100%的时间都在查询I/O状态，完全串行</li><li><strong>定时查询</strong>：在保证数据不丢失的情况下，每隔一段时间 CPU 就查询一次 I/O 状态。查询的间隔内 CPU 可以执行其他程序</li></ul><h3 id="中断系统"><a href="#中断系统" class="headerlink" title="中断系统"></a>中断系统</h3><h4 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h4><ol><li>中断请求</li></ol><ul><li>中断源向 CPU 发送中断请求信号。</li></ul><ol start="2"><li>中断响应</li></ol><ul><li><strong>中断请求标记</strong>：<ul><li>为了区分不同的中断源，中断系统需对每个中断源设置<strong>中断请求标记触发器 INTR</strong>，当其状态为“1”时，表示中断源有请求。</li><li>这些触发器可组成<strong>中断请求标记寄存器</strong>，该寄存器可集中在CPU中，也可分散在各个中断源中。</li><li>对于<strong>外中断</strong>，CPU <strong>响应中断的时间</strong>是在每条<strong>指令执行阶段的结束前</strong>。</li><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part7/image-20211029131814925.png" alt="image-20211029131814925" style="zoom:80%;"></li></ul></li><li><strong>响应中断的条件</strong>：<ol><li>中断源有中断请求。</li><li>一条指令执行完毕，且没有更紧迫的任务。</li><li>允许中断：当前 PSW 的 IF（Interrupt Flag）为真<ul><li>IF=1 表示开中断（允许中断）；IF=0 表示关中断（不允许中断）</li><li>关中断的作用：实现<strong>原子操作</strong>（必须一次性做完的操作）</li><li>除非是不得不响应的非屏蔽中断（如掉电）</li></ul></li></ol></li><li><strong>中断判优</strong>：多个中断源同时提出请求时通过中断判优逻辑响应一个中断源。<ul><li>中断判优既可以用硬件实现，也可用软件实现：<ul><li>硬件实现是通过<strong>硬件排队器</strong>实现的，它既可以设置在 CPU 中，也可以分散在各个中断源中；</li><li>软件实现是通过<strong>查询程序</strong>实现的。（相比硬件更慢，通常使用硬件排队器）</li></ul></li><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part7/image-20211029132629325.png" alt="image-20211029132629325"></li><li><strong>优先级设置</strong>：<ol><li>硬件故障中断属于最高级，其次是软件中断；</li><li>非屏蔽中断优于可屏蔽中断；</li><li>DMA 请求优于 I/O 设备传送的中断请求</li><li>高速设备优于低速设备；</li><li>输入设备优于输出设备；</li><li>实时设备优于普通设备。</li></ol></li></ul></li></ul><ol start="3"><li>中断处理</li></ol><ul><li><strong>中断隐指令</strong>：CPU 在检测到中断请求时自动完成的一系列动作<ul><li><strong>关中断</strong>。为了在保护现场期间不被新的中断打断，必须关中断，从而保证被中断的程序在中断服务程序执行完毕之后能接着正确地执行下去。</li><li><strong>保存断点</strong>。为了保证在中断服务程序执行完毕后能正确地返回到原来的程序，必须将原来程序的断点（即程序计数器（PC）的内容）保存起来。可以存入堆栈或指定单元。</li><li><strong>引出中断服务程序</strong>。引出中断服务程序的实质就是取出中断服务程序的入口地址并传送给程序计数器（PC）。<ul><li>软件向量法</li><li>硬件向量法<ul><li>由<strong>硬件</strong>产生指向<strong>中断向量</strong>的<strong>向量地址</strong></li><li><strong>中断向量</strong>指向<strong>中断服务程序</strong>的<strong>入口地址</strong></li><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part7/image-20211029204003689.png" alt="image-20211029204003689" style="zoom:80%;"></li></ul></li></ul></li><li>以及其他任务……</li></ul></li><li><strong>中断服务程序</strong>。<ul><li><strong>保护现场</strong>：保存通用寄存器和状态寄存器的内容（eg：保存ACC寄存器的值），以便返回原程序后可以恢复 CPU 环境。可使用堆栈，也可以使用特定存储单元。</li><li><strong>中断服务</strong>（设备服务）：主体部分，如通过程序控制需打印的字符代码送入打印机的缓冲存储器中（eg：中断服务的过程中有可能修改 ACC 寄存器的值）</li><li><strong>恢复现场</strong>：通过出栈指令或取数指令把之前保存的信息送回寄存器中（eg：把原程序算到一般的 ACC 值恢复原样）</li><li><strong>中断返回</strong>：通过中断返回指令回到原程序断点处。</li></ul></li></ul><h4 id="多重中断"><a href="#多重中断" class="headerlink" title="多重中断"></a>多重中断</h4><ul><li><p><strong>单重中断</strong>：执行中断服务程序时不响应新的中断请求。</p><ul><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part7/image-20211029205105146.png" alt="image-20211029205105146" style="zoom: 67%;"></li></ul></li><li><p><strong>多重中断</strong>：又称<strong>中断嵌套</strong>，执行中断服务程序时可响应新的中断请求。</p><ul><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part7/image-20211029210138245.png" alt="image-20211029210138245" style="zoom:67%;"><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part7/image-20211029205642997.png" alt="image-20211029205642997"></li></ul></li><li><p>中断屏蔽技术：</p><ul><li><p>CPU 要具备多重中断的功能，须满足下列条件（主要用于多重中断）</p><ul><li>在中断服务程序中提前设置开中断指令。</li><li>优先级别高的中断源有权中断优先级别低的中断源。</li></ul></li><li><p>屏蔽字设置的规律：</p><ol><li><p>一般用“1”表示屏蔽，“0”表示正常申请。</p></li><li><p>每个中断源对应一个屏蔽字（在处理该中断源的中断服务程序时，屏蔽寄存器中的内容为该中断源对应的屏蔽字）。</p></li><li><p>屏蔽字中“1”越多，优先级越高。每个屏蔽字中至少有一个“1”（至少要能屏蔽自身的中断）。</p></li></ol></li><li><p>例题：</p><ul><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part7/image-20211029221003756.png" alt="image-20211029221003756"></li></ul></li></ul></li></ul><h3 id="程序中断方式"><a href="#程序中断方式" class="headerlink" title="程序中断方式"></a>程序中断方式</h3><ul><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part7/image-20211029220829035.png" alt="image-20211029220829035"></li><li>例题：<ul><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part7/image-20211029221803157.png" alt="image-20211029221803157"></li></ul></li></ul><h3 id="DMA-方式"><a href="#DMA-方式" class="headerlink" title="DMA 方式"></a>DMA 方式</h3><h4 id="DMA-传送过程"><a href="#DMA-传送过程" class="headerlink" title="DMA 传送过程"></a>DMA 传送过程</h4><ul><li><p><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part7/image-20211029232153701.png" alt="image-20211029232153701"></p></li><li><p>DMA 控制器工作流程：</p><ul><li>CPU 向 DMA 控制器指明要<strong>输入还是输出</strong>；要传送<strong>多少数据</strong>；数据在<strong>主存、外设中的地址</strong>。</li><li>接受外设发出的 DMA 请求（外设传送一个字的请求），并向 CPU 发出<strong>总线请求</strong>。</li><li>CPU 响应此总线请求，发出总线响应信号，接管总线控制权，进入 DMA 操作周期。</li><li>确定传送数据的<strong>主存单元地址及长度</strong>，并能自动修改<strong>主存地址计数</strong>和<strong>传送长度计数</strong>。</li><li>规定数据在主存和外设间的<strong>传送方向</strong>，发出读写等控制信号，执行数据传送操作。</li><li>向 CPU 报告 DMA 操作的结束。</li></ul></li><li><p>DMA 组成：</p><ul><li>主存地址计数器：简称 AR，存放要交换数据的主存地址。</li><li>传送长度计数器：简称 WC，用来记录传送数据的长度，计数溢出时，数据即传送完毕，自动发中断请求信号。</li><li>数据缓冲寄存器：用于暂存每次传送的数据。</li><li>DMA 请求触发器：每当 I/O 设备准备好数据后给出一个控制信号，使 DMA 请求触发器置位。</li><li>控制/状态逻辑：由控制和时序电路及状态标志组成，用于指定传送方向，修改传送参数，并对DMA请求信号和CPU响应信号进行协调和同步。</li><li>中断机构：当一个数据块传送完毕后触发中断机构，向CPU提出中断请求。</li></ul></li><li><p>注：在 DMA 传送过程中，DMA 控制器将接管 CPU 的地址总线、数据总线和控制总线，CPU 的主存控制信号被禁止使用。而当 DMA 传送结束后，将恢复 CPU 的一切权利并开始执行其操作。</p></li><li><p>CPU 和 DMA 控制器访问主存可能产生冲突</p><ul><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part7/image-20211030223325881.png" alt="image-20211030223325881"></li></ul></li></ul><h4 id="DMA-传送方式"><a href="#DMA-传送方式" class="headerlink" title="DMA 传送方式"></a>DMA 传送方式</h4><ul><li>主存和 DMA 控制器之间有一条数据通路，因此主存和 I/O 设备之间交换信息时，不通过 CPU。但当 I/O 设备和 CPU 同时访问主存时，可能发生冲突，为了有效地使用主存，DMA 控制器与 CPU 通常采用以下 3 种方法使用主存。<ol><li>停止 CPU 访问主存<ul><li>优点：控制简单</li><li>缺点：CPU 处于不工作状态或保持状态未充分发挥 CPU 对主存的利用率</li><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part7/image-20211031092120253.png" alt="image-20211031092120253"></li></ul></li><li>DMA 与 CPU 交替访存<ul><li>一个 CPU 周期，分为 C1 和 C2 两个周期。C1 专供 DMA 访存，C2 专供 CPU 访存</li><li>优点：不需要总线使用权的申请、建立和归还过程</li><li>缺点：硬件逻辑更为复杂</li><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part7/image-20211031092135200.png" alt="image-20211031092135200"></li></ul></li><li>周期挪用（周期窃取）<ul><li>周期指<strong>存取周期</strong>。</li><li>DMA 访问主存有三种可能：<ul><li>CPU 此时不访存（不冲突）</li><li>CPU 正在访存（存取周期结束让出总线）</li><li>CPU 与 DMA 同时请求访存（I/O 访存优先）</li></ul></li><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part7/image-20211031092208256.png" alt="image-20211031092208256"></li></ul></li></ol></li></ul><h4 id="DMA-方式的特点"><a href="#DMA-方式的特点" class="headerlink" title="DMA 方式的特点"></a>DMA 方式的特点</h4><ul><li>主存和 DMA 接口之间有一条直接数据通路。 由于 DMA 方式传送数据不需要经过 CPU，因此不必中断现行程序，<strong>I/O 与主机并行工作，程序和传送并行工作</strong>。</li><li>DMA 方式具有下列特点：<ul><li>它使主存与 CPU 的固定联系脱钩，主存既可被 CPU 访问，又可被外设访问。 </li><li>在数据块传送时，主存地址的确定、传送数据的计数等都由硬件电路直接实现。</li><li>主存中要开辟专用缓冲区，及时供给和接收外设的数据。</li><li>DMA 传送速度快，CPU 和外设并行工作，提高了系统效率。</li><li>DMA 在传送开始前要通过程序进行预处理，结束后要通过中断方式进行后处理。</li></ul></li></ul><table><thead><tr><th></th><th>中断</th><th>DMA</th></tr></thead><tbody><tr><td>数据传输</td><td>程序控制</td><td>硬件控制</td></tr><tr><td>中断请求</td><td>每次传送数据</td><td>只有后处理</td></tr><tr><td>响应时间</td><td>指令周期结束</td><td>总线空闲即可</td></tr><tr><td>场景</td><td>CPU 控制低速设备</td><td>MDA 控制器控制高速设备</td></tr><tr><td>优先级</td><td>低于 DMA</td><td>高于中断</td></tr><tr><td>异常处理</td><td>能处理异常事件</td><td>仅传送数据</td></tr></tbody></table>]]></content>
    
    
    <summary type="html">IO 系统</summary>
    
    
    
    <category term="计算机组成原理" scheme="https://nephrencake.gitee.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    
    
  </entry>
  
  <entry>
    <title>计算机组成原理-Part6</title>
    <link href="https://nephrencake.gitee.io/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part6/"/>
    <id>https://nephrencake.gitee.io/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part6/</id>
    <published>2021-10-02T02:53:23.000Z</published>
    <updated>2021-10-30T13:47:30.115Z</updated>
    
    <content type="html"><![CDATA[<h1 id="计算机组成原理-Part6——总线"><a href="#计算机组成原理-Part6——总线" class="headerlink" title="计算机组成原理-Part6——总线"></a>计算机组成原理-Part6——总线</h1><p>[TOC]</p><h2 id="总线概述"><a href="#总线概述" class="headerlink" title="总线概述"></a>总线概述</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><ul><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part6/image-20211025162259335.png" alt="image-20211025162259335"></li><li><strong>总线</strong>是一组能为多个部件<strong>分时共享</strong>的<strong>公共</strong>信息传送<strong>线路</strong>。</li><li>同一时刻只能有<strong>一个设备控制</strong>总线传输操作，可以有<strong>一个或多个设备</strong>从总线<strong>接收</strong>数据。</li><li>特点：<ul><li>共享：指总线上可以挂接多个部件，各个部件之间互相交换的信息都可以通过这组线路分时共享。</li><li>分时：指同一时刻只允许有一个部件向总线发送信息，如果系统中有多个部件，则它们只能分时地向总线发送信息。</li></ul></li><li>特性：<ul><li>机械特性：尺寸、形状、管脚数、排列顺序</li><li>电气特性：传输方向（数据双向、地址/控制单向）和有效的电平范围（高电平、低电平的定义范围）</li><li>功能特性：每根传输线的功能（地址、数据、控制）</li><li>时间特性：信号的时序关系</li></ul></li><li><strong>数据通路</strong>描述的是数据的路径，是逻辑上的概念。<strong>数据总线</strong>是承载数据的物理载体，<strong>地址总线</strong>一样可以成为数据通路的一部分。</li></ul><h3 id="总线分类（重点）"><a href="#总线分类（重点）" class="headerlink" title="总线分类（重点）"></a>总线分类（重点）</h3><ul><li>按数据传输格式：<ul><li>串行总线<ul><li>优点：1. 只需要一条传输线，成本低廉，广泛应用于长距离传输；2. 不容易发生跳变；3. 应用于计算机内部时，可以节省布线空间。</li><li>缺点：1. 在数据发送和接收的时候要进行拆卸和装配，要考虑串行-并行转换的问题。</li></ul></li><li>并行总线<ul><li>优点：1. 总线的逻辑时序比较简单，电路实现起来比较容易。</li><li>缺点：1. 信号线数量多，占用更多的布线空间；2. 远距离传输成本高昂；3. 由于工作频率较高时，并行的信号线之间会产生严重干扰，对每条线等长的要求也越高，所以无法持续提升工作频率。</li></ul></li><li>并行总线传输速度一定比串行总线快，是错误的。</li></ul></li><li>按总线功能（连接的部件）：<ul><li>片内总线<ul><li>片内总线是芯片内部的总线。</li><li>是 CPU 芯片内部<strong>寄存器与寄存器</strong>之间、<strong>寄存器与 ALU</strong> 之间的公共连接线。</li></ul></li><li>系统总线<ul><li>系统总线是计算机系统内各功能部件（CPU、主存、I/O接口）之间相互连接的总线。</li><li>按系统总线<strong>传输信息内容</strong>的不同，又可分为3类：<strong>数据总线</strong>（Data Bus）、<strong>地址总线</strong>（Address Bus）和<strong>控制总线</strong>（Control Bus）。</li><li>数据总线（双向）：用来传输各功能部件之间的数据信息，其位数与<strong>机器字长、存储字长有关</strong>。</li><li>地址总线（单向）：用来指出数据总线上的源数据或目的数据所在的主存单元或 I/O 端口的地址，地址总线的位数与<strong>主存地址空间大小</strong>和<strong>设备数量</strong>有关。</li><li>控制总线（单根单向，整体双向）：传输的是控制信息，包括 <strong>CPU 送出的控制命令</strong>和<strong>主存（或外设）返回 CPU 的反馈信号</strong>。</li></ul></li><li>通信总线<ul><li>通信总线是用于计算机系统之间或计算机系统与其他系统（如远程通信设备、测试设备）之间信息传送的总线，通信总线也称为外部总线。</li></ul></li></ul></li><li>按时序控制方式：<ul><li>同步总线</li><li>异步总线</li></ul></li></ul><h3 id="系统总线的结构（重点）"><a href="#系统总线的结构（重点）" class="headerlink" title="系统总线的结构（重点）"></a>系统总线的结构（重点）</h3><ul><li>单总线结构<ul><li>结构：CPU、主存、I/O设备（通过I/O接口）都连接在<strong>一组</strong>总线（而不是只有一根信号线）上，允许 I/O 设备之间、I/O 设备和 CPU 之间或 I/O 设备与主存之间直接交换信息。</li><li>优点：结构简单，成本低，易于接入新的设备。</li><li>缺点：带宽低、负载重，多个部件只能争用唯一的总线，且不支持并行传送操作。CPU、IO 的速度差异导致总线性能并不能完全发挥。</li><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part6/image-20211025190248221.png" alt="image-20211025190248221" style="zoom:80%;"></li></ul></li><li>双总线结构<ul><li>结构：双总线结构有两条总线，一条是主存总线，用于 CPU、主存和通道之间进行数据传送；另一条是 I/O 总线，用于多个外部设备与通道之间进行数据传送。</li><li>优点：将较低速的 I/O 设备从单总线上分离出来，实现存储器总线和 I/O 总线分离。</li><li>缺点：需要增加通道等硬件设备。</li><li>主存总线支持突发（猝发）传送：<strong>只需要送出一个首地址，就可以读写多个地址连续（超出一次数据总线的传输能力）的数据，而不需要每次都发送子地址</strong>。</li><li>通道是具有特殊功能的处理器，能对 I/O 设备进行统一管理。 通道程序放在主存中。</li><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part6/image-20211025190342462.png" alt="image-20211025190342462" style="zoom:80%;"></li></ul></li><li>三总线结构<ul><li>结构：三总线结构是在计算机系统各部件之间采用 3 条各自独立的总线来构成信息通路，这3条总线分别为主存总线、I/O 总线和直接内存访问 DMA 总线。</li><li>优点：<strong>提高了 I/O 设备的性能</strong>，使其更快地响应命令，提高系统吞吐量。</li><li>缺点：系统工作效率较低。（三条总线同时刻只有一个能工作）</li><li>DMA：Direct Memory Access，直接内存访问。</li><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part6/image-20211025190627701.png" alt="image-20211025190627701" style="zoom:80%;"></li></ul></li><li>四总线结构<ul><li>桥接器：用于连接不同的总线，具有数据缓冲、转换和控制功能。</li><li>靠近 CPU 的总线速度较快。</li><li>每级总线的设计遵循总线标准。</li></ul></li></ul><h3 id="总线的性能指标"><a href="#总线的性能指标" class="headerlink" title="总线的性能指标"></a>总线的性能指标</h3><ol><li><p>总线的传输周期（总线周期）</p><ul><li><strong>一次总线操作所需的时间</strong>（包括申请阶段、 寻址阶段、传输阶段和结束阶段），通常由若干个总线时钟周期构成。</li><li>总线周期与总线时钟周期的对应关系要具体按照题意，有可能会有多对一、一对一、一对多。</li></ul></li><li><p>总线时钟周期</p><ul><li>即<strong>机器的时钟周期</strong>。总线也要受 CPU 时钟的控制。</li><li>现在的计算机中，总线时钟周期也有可能由桥接器提供</li></ul></li><li><p>总线的工作频率</p><ul><li>总线上各种操作的频率，为<strong>总线周期的倒数</strong>。 </li><li>若总线周期=N个时钟周期，则总线的工作频率=时钟频率/N。 </li><li>实际上指<strong>一秒内传送几次数据</strong>。</li></ul></li><li><p>总线的时钟频率</p><ul><li>即机器的时钟频率，为<strong>时钟周期的倒数</strong>。 </li><li>若时钟周期为T，则时钟频率为1/T。 </li><li>实际上指<strong>一秒内有多少个时钟周期</strong>。</li></ul></li><li><p>总线宽度</p><ul><li>又称为<strong>总线位宽</strong>，它是总线上<strong>同时能够传输的数据位数</strong>，</li><li>一般说总线宽度，通常是指<strong>数据总线的根数</strong>，如 32 根数据信号线称为 32 位（bit）总线。</li></ul></li><li><p>总线带宽</p><ul><li>可理解为总线的<strong>数据传输速率</strong>，即<strong>单位时间内总线上可传输数据的位数</strong>，通常用每秒钟传送信息的字节数来衡量，单位可用字节/秒（B/s）表示。</li><li>总线带宽 = 总线工作频率 × 总线宽度（bit/s）= 总线工作频率 × (总线宽度/8)（B/s）= 总线宽度/总线周期（bit/s）= (总线宽度/8)/总线周期（B/s）</li><li>总线带宽是指总线本身所能达到的<strong>最高传输速率</strong>。在计算实际的<strong>有效数据传输率</strong>时，要用实际传输的数据量（<strong>去除冗余校验位之后</strong>）除以耗时。</li><li>注意，串行总线和并行总线之间的比较就需要用到：总线带宽 = 总线工作频率 × 总线宽度</li></ul></li><li><p>总线复用</p><ul><li><p>总线复用是指<strong>一种信号线在不同的时间传输不同的信息</strong>。</p><p>可以使用<strong>较少的线</strong>传输更多的信息，从而节省了空间和成本。</p></li></ul></li><li><p>信号线数</p><ul><li>地址总线、数据总线和控制总线 3 种总线数的总和称为信号线数。</li><li><strong>只传输一位 bit 数据的先叫做信号线</strong></li></ul></li></ol><ul><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part6/image-20211026092049020.png" alt="image-20211026092049020"></li></ul><h2 id="总线仲裁"><a href="#总线仲裁" class="headerlink" title="总线仲裁"></a>总线仲裁</h2><h3 id="基本概念-1"><a href="#基本概念-1" class="headerlink" title="基本概念"></a>基本概念</h3><ul><li>针对问题：总线作为一种共享设备，不可避免地会出现同一时刻有多个主设备竞争总线控制权的问题。</li><li><strong>主设备：</strong>获得总线控制权的设备。</li><li><strong>从设备：</strong>被主设备访问的设备，只能响应从主设备发来的各种总线命令。</li></ul><h3 id="总线仲裁分类"><a href="#总线仲裁分类" class="headerlink" title="总线仲裁分类"></a>总线仲裁分类</h3><h4 id="集中仲裁方式"><a href="#集中仲裁方式" class="headerlink" title="集中仲裁方式"></a>集中仲裁方式</h4><ul><li><p>主要工作流程：</p><ul><li>主设备发出请求信号；</li><li>若多个主设备同时要使用总线，则由总线控制器的判优、仲裁逻辑按一定的优先等级顺序确定哪个主设备能使用总线；</li><li>获得总线使用权的主设备开始传送数据。</li></ul></li><li><p>链式查询方式</p><ul><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part6/image-20211026094129115.png" alt="image-20211026094129115"></li><li>BS、BR、BG 都是一根信号线</li><li>优先级：<ul><li>离总线控制器越近的部件，其优先级越高；</li><li>离总线控制器越远的部件，其优先级越低。</li></ul></li><li>优点：链式查询方式优先级固定。只需很少几根控制线就能按一定优先次序实现总线控制，结构简单，扩充容易。</li><li>缺点：对硬件电路的故障敏感，并且优先级不能改变。当优先级高的部件频繁请求使用总线时，会使<strong>优先级较低的部件长期不能使用总线</strong>。</li></ul></li><li><p>计数器定时查询方式</p><ul><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part6/image-20211026111543103.png" alt="image-20211026111543103" style="zoom:80%;"></li><li>结构特点：用一个计数器控制总线使用权，相对链式查询方式多了一组设备地址线（设备地址线是一组线），少了一根总线响应线 BG；它仍共用一根总线请求线。</li><li>优点：<ul><li>计数初始值可以改变优先次序</li><li>对电路的故障没有链式敏感</li></ul></li><li>缺点：<ul><li>增加了控制线数。若设备有 n 个，则需 [log2n]+2 条控制线</li><li>控制相对比链式查询相对复杂</li></ul></li></ul></li><li><p>独立请求方式</p><ul><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part6/image-20211026112051799.png" alt="image-20211026112051799" style="zoom:80%;"></li><li>结构特点：每一个设备均有一对总线请求线 BRi 和总线允许线 BGi。</li><li>优点：<ul><li>响应速度快，总线允许信号 BG 直接从控制器发送到有关设备，不必在设备间传递或者查询。</li><li>对优先次序的控制相当灵活。</li></ul></li><li>缺点：<ul><li>控制线数量多。若设备有n个，则需要 2n+1 条控制线。</li><li>总线的控制逻辑更加复杂</li></ul></li></ul></li></ul><blockquote><p>“总线忙”信号的建立者是<strong>获得总线控制权的设备</strong>，而不是仲裁器发出。</p></blockquote><p><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part6/image-20211026112251788.png" alt="image-20211026112251788"></p><h4 id="分布仲裁方式"><a href="#分布仲裁方式" class="headerlink" title="分布仲裁方式"></a>分布仲裁方式</h4><ul><li>特点：不需要中央仲裁器，每个潜在的主模块都有自己的仲裁器和仲裁号，多个仲裁器竞争使用总线。</li><li>步骤<ul><li>当设备有总线请求时，它们就<strong>把各自唯一的仲裁号发送到共享的仲裁总线上</strong>；</li><li><strong>每个仲裁器</strong>将从仲裁<strong>总线上得到的仲裁号</strong>与自己的仲裁号进行<strong>比较</strong>；</li><li>如果仲裁总线上的号优先级高，则它的总线请求不予响应，并撤销它的仲裁号；</li><li>最后，获胜者的仲裁号保留在仲裁总线上。</li></ul></li></ul><h2 id="总线操作和定时"><a href="#总线操作和定时" class="headerlink" title="总线操作和定时"></a>总线操作和定时</h2><h3 id="基本概念-2"><a href="#基本概念-2" class="headerlink" title="基本概念"></a>基本概念</h3><ul><li>总线周期的四个阶段<ul><li>申请分配阶段：由需要使用总线的主模块（或主设备）提出申请，经总线仲裁机构决定将下一传输周期的总线使用权。也可将此阶段细分为<strong>传输请求</strong>和<strong>总线仲裁</strong>两个阶段。</li><li>寻址阶段：获得使用权的主模块通过总线发出本次要访问的从模块的地址及有关命令，<strong>启动参与本次传输的从模块</strong>。</li><li>传输阶段：主模块和从模块进行<strong>数据交换</strong>，可单向或双向进行数据传送。</li><li>结束阶段：主模块的<strong>有关信息</strong>均从系统总线上<strong>撤除</strong>，让出总线使用权。</li></ul></li><li>针对问题：占用总线的一对设备如何进行数据传输</li><li><strong>总线定时</strong>，指总线在双方交换数据的过程中需要时间上配合关系的控制，实质是一种协议或规则<ul><li>同步通信(同步定时方式)：由<strong>统一时钟</strong>控制数据传送</li><li>异步通信(异步定时方式)：采用<strong>应答方式</strong>，没有公共时钟标准</li><li>半同步通信：同步、异步结合</li><li>分离式通信：充分挖掘系统总线每瞬间的潜力</li></ul></li></ul><h3 id="同步定时方式"><a href="#同步定时方式" class="headerlink" title="同步定时方式"></a>同步定时方式</h3><ul><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part6/image-20211026141316738.png" alt="image-20211026141316738"></li><li>同步定时方式：总线控制器采用一个<strong>统一的时钟信号</strong>来协调发送和接收双方的传送定时关系。</li><li>假设：CPU 作为主设备，选择某个输入设备作为从设备<ol><li>CPU 在 T1 时刻的上升沿给出地址信息</li><li>在T2的上升沿给出读命令（低电平有效），与地址信息相符合的输入设备按命令进行一系列的内部操作，且必须在T3的上升沿来之前将CPU所需的数据送到数据总线上。</li><li>CPU在T3时钟周期内，将数据线上的信息传送到其内部寄存器中。</li><li>CPU在T4的上升沿撤销读命令，输入设备不再向数据总线上传送数据，撤销它对数据总线的驱动。</li></ol></li><li>优点：<strong>传送速度快</strong>，具有较高的传输速率；<strong>总线控制逻辑简单</strong>。</li><li>缺点：主从设备属于强制性同步；不能及时进行数据通信的有效性检验，<strong>可靠性较差</strong>。</li><li>同步通信适用于<strong>总线长度较短</strong>（总线长度短，传输更稳定）及总线<strong>所接部件的存取时间比较接近</strong>的系统。</li></ul><h3 id="异步定时方式"><a href="#异步定时方式" class="headerlink" title="异步定时方式"></a>异步定时方式</h3><ul><li>在异步定时方式中，没有统一的时钟，也没有固定的时间间隔，完全依靠传送双方相互制约的“握手”信号来实现定时控制。</li><li>主设备提出交换信息的“请求”信号（指明操作与地址），经接口传送到从设备；从设备接到主设备的请求后，通过接口向主设备发出“回答”信号。</li><li>根据“请求”和“回答”信号的撤销是否互锁，分为以下 3 种类型。<ul><li><strong>不互锁方式</strong>：速度最快，可靠性最差<ul><li>主设备发出“请求”信号后，<strong>不必等</strong>到接到从设备的“回答”信号，而是经过一段时间，便撤销“请求”信号。</li><li>而从设备在接到“请求”信号后，发出“回答”信号，并经过一段时间，<strong>自动撤销</strong>“回答”信号。双方不存在互锁关系。</li></ul></li><li><strong>半互锁方式</strong>：<ul><li>主设备发出“请求”信号后，<strong>必须等</strong>接到从设备的“回答”信号后，才撤销“请求”信号，有互锁的关系。</li><li>而从设备在接到“请求”信号后，发出“回答”信号，但不必等待获知主设备的“请求”信号已经撤销，而是隔一段时间后<strong>自动撤销</strong>“回答”信号，不存在互锁关系。</li></ul></li><li><strong>全互锁方式</strong>：最可靠，速度最慢<ul><li>主设备发出“请求”信号后，<strong>必须等</strong>从设备“回答”后，才撤销“请求”信号；</li><li>从设备发出“回答”信号，<strong>必须等</strong>获知主设备“请求”信号已撤销后，再撤销其“回答”信号。双方存在互锁关系。</li></ul></li></ul></li><li>优点：总线周期长度可变，能保证两个工作速度相差很大的部件或设备之间<strong>可靠</strong>地进行信息交换，自动适应时间的配合。</li><li>缺点：比同步控制方式稍复杂一些，速度比同步定时方式慢。</li><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part6/image-20211026144100498.png" alt="image-20211026144100498"></li></ul><h3 id="半同步通信（仅了解）"><a href="#半同步通信（仅了解）" class="headerlink" title="半同步通信（仅了解）"></a>半同步通信（仅了解）</h3><ul><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part6/image-20211026144310741.png" alt="image-20211026144310741"></li><li>半同步通信：统一时钟的基础上，增加一个“等待”响应信号 WAIT</li><li>当从设备跟不上主设备速度时，从设备通过 WAIT 信号线要求主设备等待</li></ul><h3 id="分离式通信（仅了解）"><a href="#分离式通信（仅了解）" class="headerlink" title="分离式通信（仅了解）"></a>分离式通信（仅了解）</h3><ul><li>上述三种通信的共同点<ul><li>主模块发地址 、命令 —— 使用总线</li><li>从模块准备数据 —— 不使用总线，<strong>总线空闲</strong></li><li>从模块向主模块发数据 —— 使用总线</li></ul></li><li>分离式通信的一个总线传输周期<ul><li>子周期 1：主模块申请占用总线，使用完后放弃总线的使用权</li><li>子周期 2：从模块申请占用总线，将各种信息送至总线上</li></ul></li><li>特点：<ul><li>各模块均有权申请占用总线</li><li>采用同步方式通信，不等对方回答</li><li>各模块准备数据时，不占用总线</li><li>总线利用率提高</li></ul></li></ul><h2 id="总线标准"><a href="#总线标准" class="headerlink" title="总线标准"></a>总线标准</h2><h3 id="基本概念-3"><a href="#基本概念-3" class="headerlink" title="基本概念"></a>基本概念</h3><ul><li>总线标准是国际上公布或推荐的互连各个模块的标准，是把各种不同的模块组成计算机系统时必须遵守的规范。</li><li><strong>系统总线</strong>：<strong>通常与 CPU 直接相连</strong>，用于连接 CPU 与北桥芯片、或 CPU 与主存等</li><li><strong>局部总线</strong>：<strong>没有直接与 CPU 连接</strong>，通常是连接高速的<strong>北桥芯片</strong>，用于连接了很多重要的硬件部件（如显卡、声卡等）</li><li><strong>设备总线</strong>、<strong>通信总线</strong>：通常由<strong>南桥芯片</strong>控制，用于连接计算机与计算机，或连接计算机与外部 I/O 设备</li></ul><h3 id="总线标准的发展"><a href="#总线标准的发展" class="headerlink" title="总线标准的发展"></a>总线标准的发展</h3><ul><li>系统总线<ul><li>ISA（Industry Standard Architecture）：<strong>并行总线</strong>，1984 年提出</li><li>EISA（Extended ISA）：<strong>并行总线</strong>，1988 年提出，在 ISA 基础上增加位宽</li><li>FBS、QPI：<strong>串行总线</strong>，Intel 提出的两种系统总线，用于连接 CPU 和北桥芯片；QPI 又称 multi-FSB</li></ul></li><li>局部总线<ul><li>VESA（Video Electronics Standard Architecture）：<strong>并行总线</strong>，1991 年提出，用于传输图像，但渐渐赶不上 CPU 的发展</li><li>PCI（Peripheral Component Interconnect）：<strong>并行总线</strong>，1992 年提出，速度和 VESA 差不多，但工作频率可以独立于 CPU 主频，用于连接显卡、声卡、网卡等，支持即插即用</li><li>AGP（Accelerated Graphics Port）：<strong>并行总线</strong>，1996 年提出，从 PCI2.1 基础上扩展而来，用于连接显存和主存</li><li>PCI-E（PCI-Express（3GIO））：<strong>串行总线</strong>，2001 年提出，工作频率很高，支持全双工通信</li></ul></li><li>设备/通信总线<ul><li>连接各种外设<ul><li>RS-232C（Recommended Standard）：<strong>串行总线</strong>，1970 年提出，用于极慢速的电传打印机</li><li>SCSI（Small Computer System Interface）：<strong>并行总线</strong>，1986 年提出，用于连接硬盘、打印机、扫描仪等</li><li>PCMCIA（Personal Computer Memory Card International Association）：<strong>并行总线</strong>，1991 年提出，用于连接外部存储卡，目的是增强个人电脑的信息互换</li><li>USB（Universal Serial Bus）：<strong>串行总线</strong>，1996 年提出，采用差模信号，每次只能传输 1 bit，工作频率可以很高</li></ul></li><li>连接硬盘<ul><li>IDE（Integrated Drive Electronics）：<strong>并行总线</strong>，19986 年提出，又称 Parallel ATA，主要用于连接硬盘、光驱等</li><li>SATA（Serial Advanced Technology Attachment）：<strong>串行总线</strong>，2001 年提出，Serial ATA，主要用于连接硬盘、光驱等</li></ul></li></ul></li></ul><h3 id="串行总线取代并行总线的原因"><a href="#串行总线取代并行总线的原因" class="headerlink" title="串行总线取代并行总线的原因"></a>串行总线取代并行总线的原因</h3><ul><li>并行总线：<ul><li>用 m 根线每次传送 m 个比特，用高/低电平表示 1/0，通常采用同步定时方式。</li><li>由于线间信号干扰，因此总线工作频率不能太高。</li><li>另外，各条线不能有长度差，长距离并行传输时工艺难度大。</li></ul></li><li>串行总线：<ul><li>用两根线每次传送一个比特，采用“差模信号”表示 1/0，通常采用异步定时方式，总线工作频率可以很高。</li><li>现在的串行总线通常基于包传输，如 80bit 为一个数据包，包与包之间有先后关系，因此可以用多个数据通路分别串行传输多个数据包，某种程度上现在的串行总线也有“并行”的特点</li></ul></li></ul>]]></content>
    
    
    <summary type="html">总线</summary>
    
    
    
    <category term="计算机组成原理" scheme="https://nephrencake.gitee.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    
    
  </entry>
  
  <entry>
    <title>计算机组成原理-Part5</title>
    <link href="https://nephrencake.gitee.io/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part5/"/>
    <id>https://nephrencake.gitee.io/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part5/</id>
    <published>2021-10-02T02:53:18.000Z</published>
    <updated>2021-10-26T15:16:15.323Z</updated>
    
    <content type="html"><![CDATA[<h1 id="计算机组成原理-Part5——中央处理器"><a href="#计算机组成原理-Part5——中央处理器" class="headerlink" title="计算机组成原理-Part5——中央处理器"></a>计算机组成原理-Part5——中央处理器</h1><p>[TOC]</p><h2 id="CPU-的功能和结构"><a href="#CPU-的功能和结构" class="headerlink" title="CPU 的功能和结构"></a>CPU 的功能和结构</h2><h3 id="CPU-的功能"><a href="#CPU-的功能" class="headerlink" title="CPU 的功能"></a>CPU 的功能</h3><ol><li><strong>指令控制</strong>：完成<strong>取指令</strong>、<strong>分析指令</strong>和<strong>执行指令</strong>的操作，即程序的顺序控制。</li><li><strong>操作控制</strong>：CPU 产生并管理一条指令中的若干操作信号，从而<strong>控制相应的部件</strong>按指令要求进行动作。</li><li><strong>时间控制</strong>：为<strong>每条指令按时间顺序</strong>提供应有的控制信号。</li><li><strong>数据加工</strong>：对数据进行<strong>算术和逻辑运算</strong>。</li><li><strong>中断处理</strong>：管理<strong>总线</strong>及<strong>输入输出</strong>；处理<strong>异常情况</strong>和<strong>特殊请求</strong>。</li></ol><ul><li>运算器：<strong>数据加工</strong></li><li>控制器：<strong>操作控制</strong>、<strong>时间控制</strong>、<strong>指令控制</strong>、<strong>中断处理</strong></li></ul><h3 id="运算器的基本结构"><a href="#运算器的基本结构" class="headerlink" title="运算器的基本结构"></a>运算器的基本结构</h3><ul><li>运算器结构：<ul><li>算术逻辑单元：进行算术/逻辑运算。</li><li>通用寄存器组：如 AX、BX、CX、DX、SP 等。用于存放操作数（包括源操作数、目的操作数及中间结果）和各种地址信息等。</li><li>暂存寄存器：用于暂存<strong>从主存读来的数据</strong>，这个数据不能立即存放在通用寄存器中，否则会破坏其原有内容。</li><li>累加寄存器：是一个通用寄存器，用于暂时存放 ALU 运算的结果信息，用于实现加法运算。</li><li>程序状态字寄存器（PSW）：保留由算术逻辑运算指令或测试指令的结果的各种状态信息，如溢出标志（OP）、符号标志（SF）、零标志（ZF）、进位标志（CF）等。<strong>这些位参与并决定微操作的形成</strong>。</li><li>移位器：对运算结果进行移位运算。</li><li>计数器：控制乘除运算的操作步数。</li></ul></li></ul><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part5/image-20211023104243472.png" alt="image-20211023104243472" style="zoom:80%;"><ul><li><strong>专用数据通路方式</strong>：根据指令执行过程中的数据和地址的流动方向安排连接线路。<ul><li>特点：<strong>性能较高</strong>，基本不存在数据冲突现象，但<strong>结构复杂</strong>，硬件量大，不易实现。</li></ul></li><li>针对问题：<ul><li>如果 ALU 与寄存器组直接用导线连接，相当于多个寄存器同时并且一直向 ALU 传输数据</li></ul></li><li>改进方向：<ul><li>解决方法1：使用<strong>多路选择器</strong>根据控制信号选择一路输出</li><li>解决方法2：使用<strong>三态门</strong>可以控制每一路是否输出</li></ul></li></ul><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part5/image-20211023105644925.png" alt="image-20211023105644925" style="zoom:80%;"><ul><li><strong>CPU 内部单总线方式</strong>：将所有寄存器的输入端和输出端都连接到一条公共的通路上。<ul><li>特点：结构简单，容易实现，但数据传输存在较多冲突的现象，性能较低。</li></ul></li><li>针对问题：<ul><li>ALU 的计算结果会在电流不稳定时直接传回 CPU 内部总线，破坏寄存器信息</li></ul></li><li>改进方向：<ul><li>在 ALU 后加入<strong>暂存寄存器</strong>和<strong>三态门</strong>来等待稳定之后再将结果写入寄存器</li><li>通常会把 ALU 后的寄存器添加移位功能</li></ul></li></ul><h3 id="控制器的基本结构"><a href="#控制器的基本结构" class="headerlink" title="控制器的基本结构"></a>控制器的基本结构</h3><p><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part5/image-20211023121447512.png" alt="image-20211023121447512"></p><ol><li>程序计数器：存放下一条指令在主存中的地址。CPU 会根据 PC 的内容去主存中取指令。通常 PC 有自增功能，有的也会交给 ALU 进行加一。</li><li>指令寄存器：用于保存当前正在执行的指令。</li><li>指令译码器：仅<strong>对操作码字段进行译码</strong>，向控制器提供特定的操作信号。</li><li>微操作信号发生器：根据 <strong>IR 的内容</strong>（指令）、<strong>PSW 的内容</strong>（状态信息）及<strong>时序信号</strong>（时序脉冲），产生控制整个计算机系统所需的各种控制信号，其结构有<strong>组合逻辑型</strong>和<strong>存储逻辑型</strong>两种。</li><li>时序系统：用于产生各种时序信号，它们都是由统一时钟（CLOCK）分频得到。</li><li>存储器地址寄存器：用于存放所要访问的主存单元地址。</li><li>存储器数据寄存器：用于存放向主存写入的信息或从主存中读出的信息。</li></ol><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part5/image-20211023122455417.png" alt="image-20211023122455417"></p><ul><li>用户可见寄存器：通用寄存器组、程序状态字寄存器 PSW、程序计数器 PC</li><li>用户不可见寄存器：MAR、MDR、IR、暂存寄存器</li></ul><h2 id="指令执行过程"><a href="#指令执行过程" class="headerlink" title="指令执行过程"></a>指令执行过程</h2><h3 id="指令周期"><a href="#指令周期" class="headerlink" title="指令周期"></a>指令周期</h3><ul><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part5/image-20211023123259434.png" alt="image-20211023123259434" style="zoom:80%;"><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part5/image-20211023123229871.png" alt="image-20211023123229871" style="zoom:80%;"></li><li><strong>指令周期</strong>：CPU 从主存中每<strong>取出并执行</strong>一条指令所需的全部时间。<ul><li>指令周期常常用若干<strong>机器周期</strong>（<strong>CPU 周期</strong>）来表示。</li><li>一个机器周期又包含若干<strong>时钟周期</strong>（也称为<strong>节拍</strong>、<strong>T 周期</strong>、<strong>主频的倒数</strong>或 <strong>CPU 时钟周期</strong>，它是 CPU 操作的<strong>最基本单位</strong>）。</li></ul></li><li>每个指令周期内机器周期数可以<strong>不等</strong>，每个机器周期内的节拍数也可以<strong>不等</strong>。<ul><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part5/image-20211023124356581.png" alt="image-20211023124356581" style="zoom:80%;"></li></ul></li></ul><h3 id="指令周期数据流"><a href="#指令周期数据流" class="headerlink" title="指令周期数据流"></a>指令周期数据流</h3><ul><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part5/image-20211023130107891.png" alt="image-20211023130107891" style="zoom:80%;"></li><li><p>四个工作周期都有CPU访存操作，只是访存的目的不同。</p><ul><li><strong>取指周期</strong>是为了<strong>取指令</strong></li><li><strong>间址周期</strong>是为了<strong>取有效地址</strong></li><li><strong>执行周期</strong>是为了<strong>取操作数</strong></li><li><strong>中断周期</strong>是为了<strong>保存程序断点</strong></li></ul></li><li><p name="取指周期">取指周期（所有指令都一样）</p><ul><li>(PC) → MAR：当前指令地址送至存储器地址寄存器</li><li>1 → R：CU 发出控制信号，经控制总线传到主存，这里是给<strong>读信号接口</strong>输送一个高电平</li><li>M(MAR) → MDR：将 MAR 所指主存中的内容经数据总线送入 MDR</li><li>(MDR) → IR：将 MDR 中的内容（此时是指令）送入 IR</li><li>OP(IR) → ID：将指令（IR 中的操作码部分）传入指令译码器（Instruction Decoder，ID）</li><li>(PC)+1 → PC：CU 发出控制信号，形成下一条指令地址</li></ul></li><li><p>间址周期（所有指令都一样）</p><ul><li>Ad(IR/MDR) → MAR：将指令的地址码送入 MAR</li><li>1 → R：CU 发出控制信号，启动主存做<strong>读操作</strong></li><li>M(MAR) → MDR：将 MAR 所指主存中的内容经数据总线送入 MDR</li><li>(MDR) → Ad(IR)：将最终的有效地址（IR 中的地址码部分）送至指令的地址码字段</li></ul></li><li><p>执行周期（各不相同）</p><ul><li>执行周期的任务是根据 IR 中的指令字的操作码和操作数通过 ALU 操作产生执行结果。不同指令的执行周期操作不同，因此没有统一的数据流向。</li><li>CLA：clear ACC（ACC清零）<ul><li>0 → AC</li></ul></li><li>LDA X：load ACC（把X所指内容取到ACC）<ul><li>Ad ( IR ) → MAR</li><li>1 → R</li><li>M ( MAR ) → MDR</li><li>MDR → AC</li></ul></li><li>JMP X：（无条件转移)<ul><li>Ad(IR) → PC</li></ul></li><li>BAN X：Branch ACC Negative（当ACC为负时转移）<ul><li>A<del>0</del> • Ad (IR) + (!A<del>0</del>) • (PC) → PC</li></ul></li></ul></li><li><p>中断周期</p><ul><li>中断：暂停当前任务去完成其他任务。为了能够恢复当前任务，需要保存断点。一般使用堆栈来保存断点，假设 SP 指向栈顶元素（低地址部分）。进栈操作是先修改指针，后存入数据。</li><li>中断周期三个任务：<ul><li>保存断点</li><li>形成中断服务程序的入口地址</li><li>关中断</li></ul></li><li>(SP)-1 → SP，(SP) → MAR：CU 控制 SP 减1，修改后的地址送入 MAR</li><li>1 → W：CU 发出控制信号，启动主存做<strong>写操作</strong></li><li>(PC) → MDR：将断点（PC 内容）送入 MDR</li><li>向量地址 → PC：CU 控制将中断服务程序的入口地址（由向量地址形成部件产生）送入 PC</li></ul></li></ul><h3 id="指令执行方案"><a href="#指令执行方案" class="headerlink" title="指令执行方案"></a>指令执行方案</h3><ul><li>一个指令周期通常要包括几个时间段（执行步骤），每个步骤完成指令的一部分功能，几个依次执行的步骤完成这条指令的全部功能。</li><li>单指令周期<ul><li>所有指令都选用相同的执行时间来完成，指令之间串行执行。</li><li>指令周期取决于执行时间最长的指令的执行时间。对于可以在更短时间内完成的指令，要使用等待至最长的周期，会降低系统的运行速度。</li></ul></li><li>多指令周期<ul><li>对不同类型的指令选用不同的执行步骤来完成 ，指令之间串行执行。</li><li>可选用不同个数的时钟周期来完成不同指令的执行过程 。需要更复杂的硬件设计。</li></ul></li><li>流水线方案<ul><li>在每一个时钟周期启动一条指令，让多条指令处在<strong>不同的执行步骤</strong>中<strong>同时运行</strong>，指令之间并行执行。</li></ul></li></ul><h2 id="数据通路（大题高频）"><a href="#数据通路（大题高频）" class="headerlink" title="数据通路（大题高频）"></a>数据通路（大题高频）</h2><ul><li>数据通路：数据在功能部件之间传送的路径。<ul><li>寄存器-寄存器</li><li>寄存器-主存</li><li>寄存器-ALU</li></ul></li><li>数据通路的基本结构：<ul><li>CPU 内部单总线方式（ALU 必须配合暂存寄存器使用）</li><li>CPU 内部多总线方式（相比单总线成本更高，但是数据传输更有效率）</li><li>专用数据通路方式</li></ul></li></ul><h3 id="单总线结构"><a href="#单总线结构" class="headerlink" title="单总线结构"></a>单总线结构</h3><ul><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part5/image-20211023141239720.png" alt="image-20211023141239720" style="zoom:80%;"></li><li>寄存器之间数据传送<ul><li>(PC)→Bus：PCout 有效（PC 内容送总线）</li><li>Bus→MAR：MARin 有效（总线内容送 MAR）</li></ul></li><li>主存与CPU之间的数据传送<ul><li>(PC)→Bus→MAR：PCout 和 MARin 有效（现行指令地址→MAR）</li><li>1→R：CU 发读命令</li><li>MEM(MAR)→MDR：MDRinE 有效</li><li>MDR→Bus→IR：MDRout 和 IRin 有效（现行指令→IR）</li></ul></li><li>执行算术或逻辑运算<ul><li>Ad(IR/MDR)→Bus→MAR：MDRout 和 MARin 有效</li><li>1→R：CU 发读命令</li><li>MEM(MAR)→数据线→MDR：MDRin 有效</li><li>MDR→Bus→Y：MDRout 和 Yin 有效（操作数→Y）</li><li>(ACC)+(Y)→Z：ACCout 和 ALUin 有效（CU 向 ALU 发送加命令）</li><li>Z→ACC：Zout 和 ACCin 有效（结果→ACC）</li></ul></li></ul><h3 id="专用通路结构"><a href="#专用通路结构" class="headerlink" title="专用通路结构"></a>专用通路结构</h3><ul><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part5/image-20211023145547590.png" alt="image-20211023145547590" style="zoom:80%;"></li><li>取指周期<ul><li>(PC)→MAR：C0有效</li><li>(MAR)→主存：C1有效</li><li>1→R：控制单元向主存发送读命令</li><li>M(MAR)→MDR：C2有效</li><li>(MDR)→IR：C3有效</li><li>(PC)+1→PC</li><li>Op(IR)→CU：C4有效</li></ul></li></ul><blockquote><p>数据通路是计组大题高频考点！一定要做题巩固！</p></blockquote><h2 id="控制器的功能和工作原理"><a href="#控制器的功能和工作原理" class="headerlink" title="控制器的功能和工作原理"></a>控制器的功能和工作原理</h2><h3 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h3><ul><li>硬布线控制器：使用<strong>纯硬件</strong>的方式来实现控制器的功能</li><li>微程序控制器：使用<strong>软硬件结合</strong>的方式来实现控制器的功能</li><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part5/image-20211023185221891.png" alt="image-20211023185221891"></li><li>CPU 会在每个时钟周期内发出一个<strong>微命令</strong>，即完成一个对应<strong>微操作</strong>的控制信号。<ul><li>如，微命令1 使得 PCout、MARin 有效，从而完成对应的微操作1 (PC)-&gt;MAR。</li><li>微命令与微操作是相互对应的</li><li>特点：<ol><li>多个<strong>相容</strong>的微操作是可以<strong>在一个节拍内并行</strong>的。比如使用专用通路结构就可以提高微命令的并行数量</li><li>同一个微操作可能在不同的指令阶段中重复使用</li><li>在定长机器周期中，通常以<strong>访存所需节拍数</strong>作为参考</li><li>若实际所需节拍数较少，可将微操作安排在机器周期末尾进行</li></ol></li></ul></li><li>根据<strong>指令操作码</strong>、<strong>当前的机器周期</strong>、<strong>节拍信号</strong>、<strong>机器状态条件</strong>，即可确定现在这个节拍下应该发出哪些“微命令”</li><li>CPU 所处的周期由四个不同的触发器确定。</li></ul><h3 id="硬布线控制器"><a href="#硬布线控制器" class="headerlink" title="硬布线控制器"></a>硬布线控制器</h3><ul><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part5/image-20211023190651176.png" alt="image-20211023190651176"></li><li>设计步骤<ol><li><a href="#取指周期">分析每个阶段的微操作序列</a>（哪些指令在<strong>什么阶段</strong>、<strong>什么条件</strong>下会使用到<strong>什么微操作</strong>）</li><li>选择 CPU 的控制方式（定长/不定长周期，每个周期的节拍数）</li><li>安排微操作时序</li><li>电路设计（逻辑表达式与电路设计）<ul><li>列出操作时间表</li><li>写出微操作的最简表达式</li><li>画出逻辑图</li></ul></li></ol></li><li>安排微操作时序的原则<ol><li>微操作的<strong>先后顺序</strong>不得随意更改</li><li><strong>被控对象不同</strong>的微操作尽量安排在<strong>一个节拍</strong>内完成</li><li>占用<strong>时间较短</strong>的微操作尽量安排在<strong>一个节拍</strong>内完成，允许有先后顺序</li></ol></li><li>取指周期：<ul><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part5/image-20211023194220430.png" alt="image-20211023194220430" style="zoom:80%;"></li><li>M ( MAR ) -&gt; MDR：从主存取数据，用时较长，因此必须一个时钟周期才能保证微操作的完成</li><li>MDR -&gt; IR：是 CPU 内部寄存器之间的数据传送，速度很快，因此在一个时钟周期内可以紧接着完成第二个微命令 OP ( IR ) -&gt; ID。</li></ul></li><li>间址周期：<ul><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part5/image-20211023194429655.png" alt="image-20211023194429655" style="zoom:80%;"></li></ul></li><li>执行周期：<ul><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part5/image-20211023194744913.png" alt="image-20211023194744913" style="zoom:80%;"></li></ul></li><li>缺点：<ul><li>指令越多，设计、实现就越复杂，因此<strong>一般用于 RISC</strong>（精简指令集系统） </li><li>如果扩充一条新的指令，则控制器的设计就需要大改，因此<strong>扩充指令较困难</strong>。</li></ul></li><li>优点：<ul><li>由于使用纯硬件实现控制，因此执行<strong>速度很快</strong>。</li><li><strong>微操作控制信号</strong>由组合逻辑电路根据当前的指令码、状态和时序，<strong>即时产生</strong>。</li></ul></li></ul><h3 id="微程序控制器（考点）"><a href="#微程序控制器（考点）" class="headerlink" title="微程序控制器（考点）"></a>微程序控制器（考点）</h3><h4 id="基本原理-1"><a href="#基本原理-1" class="headerlink" title="基本原理"></a>基本原理</h4><h5 id="微程序的概念"><a href="#微程序的概念" class="headerlink" title="微程序的概念"></a>微程序的概念</h5><ul><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part5/image-20211024094522115.png" alt="image-20211024094522115"></li><li>基本思想：采用“存储程序”的思想，CPU 出厂前将所有指令的“微程序”存入“控制器存储器”中</li><li>层次结构：<ul><li>程序：由<strong>指令序列</strong>组成</li><li><strong>微程序</strong>：<ul><li>由<strong>微指令序列</strong>组成，<strong>每一种指令对应一个微程序</strong></li><li><strong>取指、间指、执行、中断周期微程序段</strong>，共同<strong>组成一个微程序</strong></li></ul></li><li><strong>指令</strong>：是对程序执行步骤的描述<ul><li>指令/微程序是对微指令功能的“封装”</li><li>是一个微指令序列</li></ul></li><li><strong>微指令</strong>：是对指令执行步骤的描述<ul><li>微指令中可能包含多个<strong>微命令</strong></li><li><strong>每一个微命令对应一个微操作</strong>，<strong>每一个微命令对应一条输出控制线</strong></li></ul></li></ul></li></ul><h5 id="微程序控制器基本结构"><a href="#微程序控制器基本结构" class="headerlink" title="微程序控制器基本结构"></a>微程序控制器基本结构</h5><ul><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part5/image-20211024180509785.png" alt="image-20211024180509785"></li><li><strong>微地址形成部件</strong>：产生初始微地址和后继微地址，以保证微指令的连续执行。</li><li><strong>CMAR</strong>：又称 <strong>μPC</strong>，微地址寄存器，接收微地址形成部件送来的微地址，为在 CM 中读取微指令作准备。</li><li><strong>地址译码</strong>：将地址码转化为存储单元控制信号。</li><li><strong>控制存储器 CM</strong>：简称<strong>控存</strong>，用于存放各指令对应的微程序，控制存储器是由<strong>只读存储器 ROM</strong> 构成。</li><li><strong>CMDR</strong>：别名：<strong>μIR</strong>，用于存放从 CM 中取出的微指令，它的位数同微指令字长相等。</li><li><strong>顺序逻辑</strong>：<ul><li>根据<strong>指令地址码的寻址特征位</strong>判断是否要跳过间址周期</li><li>根据<strong>中断信号</strong>判断是否进入中断周期</li></ul></li><li>所有指令的<strong>取指周期</strong>、<strong>间址周期</strong>、<strong>中断周期</strong>所对应的微指令序列都一样，<strong>可以共享使用</strong>。</li><li>取指周期微程序：（常考）<ul><li>通常是公用的，故如果某指令系统中有 n 条机器指令，则 CM 中微程序（段）的个数至少是 <strong>n+1</strong> 个</li><li>一些早期的 CPU、物联网设备的 CPU <strong>可以不提供间接寻址和中断功能</strong>，因此这类 CPU 可以不包含间址周期、中断周期的微程序段</li></ul></li><li>有的选择题中，虽然取指周期、执行周期<strong>在物理上</strong>是两个微程序，但<strong>逻辑上</strong>应该把它们看作一个整体。即，<strong>一条指令对应一个微程序</strong>。</li></ul><h4 id="微指令的设计"><a href="#微指令的设计" class="headerlink" title="微指令的设计"></a>微指令的设计</h4><h5 id="微指令的格式"><a href="#微指令的格式" class="headerlink" title="微指令的格式"></a>微指令的格式</h5><ul><li>水平型微指令：一条微指令能定义多个可并行的微命令。<ul><li>优点：微程序短，执行速度快；</li><li>缺点：微指令长，编写微程序较麻烦。</li><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part5/image-20211024182849406.png" alt="image-20211024182849406"></li></ul></li><li>垂直型微指令：一条微指令只能定义<strong>一个</strong>微命令<strong>，</strong>由微操作码字段规定具体功能<ul><li>优点：微指令短、简单、规整，便于编写微程序；</li><li>缺点：微程序长，执行速度慢，工作效率低。 </li><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part5/image-20211024182907683.png" alt="image-20211024182907683"></li></ul></li><li>混合型微指令：<ul><li>在垂直型的基础上增加一些不太复杂的并行操作。</li><li>微指令较短，仍便于编写；微程序也不长，执行速度加快。</li></ul></li></ul><blockquote><ul><li><strong>相容性</strong>微命令：可以并行完成的微命令。</li><li><strong>互斥性</strong>微命令：不允许并行完成的微命令。</li></ul></blockquote><h5 id="微指令的编码方式（高频）"><a href="#微指令的编码方式（高频）" class="headerlink" title="微指令的编码方式（高频）"></a>微指令的编码方式（高频）</h5><p><strong>微指令的编码方式</strong>，又称<strong>微指令的控制方式</strong>，指如何对微指令的控制字段进行编码，以形成控制信号。目标是在保证速度的情况下，尽量缩短微指令字长。</p><ol><li>直接编码（直接控制）方式<ul><li>在微指令的操作控制字段中，<strong>每一位代表一个微操作命令</strong>，某位为 1 表示该控制信号有效</li><li>优点：简单、直观，执行速度快，操作并行性好。</li><li>缺点：微指令字长过长，n 个微命令就要求微指令的操作字段有 n 位，造成控存容量极大。</li><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part5/image-20211024205924843.png" alt="image-20211024205924843"></li></ul></li><li>字段直接编码方式<ul><li>将微指令的控制字段分成若干“段”，<strong>每段经译码后发出控制信号</strong>微命令字段分段的原则：<ul><li><strong>互斥性</strong>微命令分在<strong>同一段内</strong>，<strong>相容性</strong>微命令分在<strong>不同段内</strong>。不同段/不同互斥类/相容的微命令可以并行</li><li><strong>每个小段</strong>中包含的<strong>信息位不能太多</strong>，否则将增加译码线路的复杂性和译码时间。</li><li>一般<strong>每个小段还要留出一个状态</strong>，表示本字段不发出任何微命令。因此，当某字段的长度为 3 位时，最多只能表示 7 个互斥的微命令，<strong>通常用 000 表示不操作</strong>。</li></ul></li><li>优点：可以缩短微指令字长。</li><li>缺点：要通过译码电路后再发出微命令，因此比直接编码方式慢 。</li><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part5/image-20211024210134498.png" alt="image-20211024210134498"></li></ul></li><li>字段间接编码方式<ul><li>一个字段的某些微命令需由另一个字段中的某些微命令来解释，由于不是靠字段直接译码发出的微命令，故称为字段间接编码，又称隐式编码。</li><li>优点：可进一步缩短微指令字长。</li><li>缺点：削弱了微指令的并行控制能力。通常作为字段直接编码方式的一种辅助手段。</li><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part5/image-20211024210333131.png" alt="image-20211024210333131"></li></ul></li></ol><h5 id="微指令的地址形成方式"><a href="#微指令的地址形成方式" class="headerlink" title="微指令的地址形成方式"></a>微指令的地址形成方式</h5><ol><li><strong>断定方式</strong>（常考）：微指令的下地址字段直接指出后继微指令的地址。</li><li>根据机器指令的<strong>操作码</strong>形成：当机器指令取至指令寄存器后，微指令的地址由操作码经微地址形成部件形成。（不常考）</li><li>增量<strong>计数器法</strong>（常考）：(CMAR) + 1 -&gt; CMAR/μPC</li><li>分支转移：操作控制字段+转移方式+转移地址。转移方式，指明判别条件；转移地址，指明转移成功后的去向。（不常考）</li><li>通过测试网络（不常考）</li><li>由<strong>硬件</strong>产生微程序入口地址：<ul><li>第一条微指令地址：由<strong>硬件</strong>产生（用专门的硬件记录取指周期微程序首地址）</li><li>中断周期：由<strong>硬件</strong>产生中断周期微程序首地址（用专门的硬件记录）</li></ul></li></ol><h4 id="微程序控制单元的设计"><a href="#微程序控制单元的设计" class="headerlink" title="微程序控制单元的设计"></a>微程序控制单元的设计</h4><ul><li><p><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part5/image-20211024232747714.png" alt="image-20211024232747714"></p></li><li><p>设计步骤：</p><ol><li><p>分析每个阶段的微操作序列</p></li><li><p>写出对应机器指令的微操作命令及节拍安排</p><ul><li><p> 写出每个周期所需要的微操作（参照硬布线）</p></li><li><p>补充微程序控制器特有的微操作：</p><p>a. 取指周期：</p><ul><li>Ad ( CMDR ) -&gt; CMAR（每条微指令结束都要进行）</li><li>OP ( IR ) -&gt; 微地址形成部件 -&gt; CMAR（取指周期结束，根据指令操作码确定其执行周期的微程序首地址）</li></ul><p>b. 执行周期：</p><ul><li>Ad(CMDR) -&gt; CMAR（每条微指令结束都要进行，最后一条微指令的下地址是 0）</li></ul></li></ul></li><li><p>确定微指令格式</p><ul><li>根据<strong>微操作个数</strong>决定采用何种<strong>编码方式</strong>，以确定微指令的<strong>操作控制字段的位数</strong>。</li><li>根据 CM 中存储的<strong>微指令总数</strong>，确定微指令的<strong>顺序控制字段的位数</strong>。</li><li>最后按操作控制字段位数和顺序控制字段位数就可确定<strong>微指令字长</strong>。</li></ul></li><li><p>编写微指令码点</p><ul><li>根据操作控制字段每一位代表的微操作命令，编写每一条微指令的码点。</li></ul></li></ol></li><li><p>读出微指令：</p><ul><li>取指周期的<strong>第一条微指令地址由硬件自动给出</strong></li><li>用微指令 a 的下地址表示 b 的地址。上一条微指令的下地址部分转到下一条微指令的译码，同样需要消耗一个节拍</li></ul></li></ul><h4 id="微程序设计分类"><a href="#微程序设计分类" class="headerlink" title="微程序设计分类"></a>微程序设计分类</h4><ol><li>静态微程序设计和动态微程序设计<ul><li>静态：微程序无需改变，采用 ROM</li><li>动态：通过改变<strong>微指令</strong>和<strong>微程序</strong>改变机器指令。有利于仿真，采用 EPROM</li></ul></li><li>毫微程序设计<ul><li>微程序设计：用微程序解释机器指令</li><li>毫微程序设计：用毫微程序解释微程序</li><li><strong>毫微指令与微指令</strong>的关系好比<strong>微指令与机器指令</strong>的关系</li></ul></li></ol><h3 id="硬布线与微程序的比较"><a href="#硬布线与微程序的比较" class="headerlink" title="硬布线与微程序的比较"></a>硬布线与微程序的比较</h3><table><thead><tr><th>对比项目</th><th>微程序控制器</th><th>硬布线控制器</th></tr></thead><tbody><tr><td>工作原理</td><td>读出微程序</td><td>电路即时产生</td></tr><tr><td>执行速度</td><td>慢</td><td>快</td></tr><tr><td>规整性</td><td>较规整</td><td>繁琐，不规整</td></tr><tr><td>应用场合</td><td>CISC CPU</td><td>RISC CPU</td></tr><tr><td>易扩充性</td><td>易扩充修改</td><td>困难</td></tr></tbody></table><h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part5/image-20211024235150778.png" alt="image-20211024235150778"></p><h2 id="指令流水线（大题考察）"><a href="#指令流水线（大题考察）" class="headerlink" title="指令流水线（大题考察）"></a>指令流水线（大题考察）</h2><h3 id="指令流水线的基本概念"><a href="#指令流水线的基本概念" class="headerlink" title="指令流水线的基本概念"></a>指令流水线的基本概念</h3><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><ul><li>指令流水：一条指令的执行过程可以分成多个阶段（或过程）。根据计算机的不同，具体的分法、数量也不同。<ul><li>取指（Instruction Fetch，IF）、分析（Instruction Decode，ID）、执行（Execute）、Memory、Writeback</li><li>分成 5 个阶段的 RISC 是比较常见的考法。</li></ul></li></ul><h4 id="执行方式"><a href="#执行方式" class="headerlink" title="执行方式"></a>执行方式</h4><ul><li>顺序执行方式：<ul><li>总耗时T = n×3t = 3nt</li><li>传统冯·诺依曼机采用顺序执行方式，又称串行执行方式。</li><li>优点：控制简单，硬件代价小。</li><li>缺点：执行指令的速度较慢，在任何时刻，处理机中只有一条指令在执行，各功能部件的利用率很低。</li></ul></li><li>一次重叠执行方式：<ul><li>总耗时T = 3t + (n-1)×2t = (1+2n)t</li><li>优点：程序的执行时间缩短了1/3，各功能部件的利用率明显提高。</li><li>缺点：需要付出硬件上较大开销的代价，控制过程也比顺序执行复杂了。</li></ul></li><li>二次重叠执行方式：<ul><li>总耗时T = 3t + (n-1)×t = (2+n)t</li><li>与顺序执行方式相比，指令的执行时间缩短近2/3。这是一种理想的指令执行方式，在正常情况下，处理机中同时有3条指令在执行。</li></ul></li></ul><h4 id="表示方法（重要）"><a href="#表示方法（重要）" class="headerlink" title="表示方法（重要）"></a>表示方法（重要）</h4><ul><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part5/image-20211025092552132.png" alt="image-20211025092552132"></li><li>指令执行过程图：主要用于分析指令执行过程以及影响流水线的因素</li><li>时空图：主要用于分析流水线的性能</li></ul><h4 id="性能指标（重要）"><a href="#性能指标（重要）" class="headerlink" title="性能指标（重要）"></a>性能指标（重要）</h4><p><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part5/image-20211025093530754.png" alt="image-20211025093530754"></p><p>一条指令的执行分为 k 个阶段，每个阶段耗时 Δt ，一般取 Δt=一个时钟周期（应该是机器周期，在理想情况下可以当做时钟周期）</p><ul><li>吞吐率：在单位时间内流水线所完成的任务数量。<ul><li>吞吐率计算公式：$TP = \frac{n}{T_{k}}$</li><li>实际吞吐率为：$TP = \frac{n}{(k+n-1)Δt}$</li><li>当连续输入的任务 n→∞ 时，最大吞吐率为 TPmax=1/Δt。</li></ul></li><li>加速比：完成同样一批任务，<strong>不使用流水线所用的时间</strong>与<strong>使用流水线所用的时间</strong>之比。<ul><li>加速比公式：$S = \frac{T_{0}}{T_{k}}$</li><li>实际加速比：$S = \frac{knΔt}{(k+n-1)Δt} = \frac{kn}{(k+n-1)}$</li><li>当连续输入的任务 n→∞ 时，最大加速比为 Smax=k。</li></ul></li><li>效率：流水线的设备利用率称为流水线的效率。<ul><li>在时空图上，流水线的效率定义为完成<strong>n个任务占用的时空区有效面积</strong>与<strong>n个任务所用的时间与k个流水段所围成的时空区总面积</strong>之比。</li><li>效率公式：$E = \frac{n个任务占用k时空区有效面积}{n个任务所用的时间与k个流水段所围成的时空区总面积}=\frac{T_{0}}{kT_{k}}$</li><li>当连续输入的任务 n→∞ 时，最高效率为 Emax=1。</li><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part5/image-20211025095147120.png" alt="image-20211025095147120"></li></ul></li></ul><h3 id="指令流水线的影响因素和分类"><a href="#指令流水线的影响因素和分类" class="headerlink" title="指令流水线的影响因素和分类"></a>指令流水线的影响因素和分类</h3><h4 id="影响流水线的因素（重要）"><a href="#影响流水线的因素（重要）" class="headerlink" title="影响流水线的因素（重要）"></a>影响流水线的因素（重要）</h4><ul><li>结构相关（资源冲突）<ul><li>由于多条指令在同一时刻争用同一资源而形成的冲突称为结构相关。</li><li>解决办法：<ul><li>后一相关指令暂停一周期</li><li>资源重复配置：数据存储器+指令存储器</li></ul></li><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part5/image-20211025102708962.png" alt="image-20211025102708962"></li></ul></li><li>数据相关（数据冲突）<ul><li>数据相关指在一个程序中，存在必须等前一条指令执行完才能执行后一条指令的情况，则这两条指令即为数据相关。</li><li>解决办法：<ul><li>把遇到数据相关的指令及其后续指令都暂停一至几个时钟周期，直到数据相关问题消失后再继续执行。可分为<strong>硬件阻塞（stall）</strong>和<strong>软件插 入（NOP）</strong>两种方法。</li><li>数据旁路技术（转发机制）：通过增加电路（数据旁路），将上一步的 ALU 结果直接送入下一步的 ALU</li><li>编译优化：通过编译器调整指令顺序来解决数据相关。</li></ul></li><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part5/image-20211025102758077.png" alt="image-20211025102758077"></li></ul></li><li>控制相关（控制冲突）<ul><li>当流水线遇到改变 PC 值的指令（如转移指令、CALL、中断）而造成断流时，会引起控制相关。</li><li>解决办法：（由转移指令发生）<ul><li>转移指令预测。简单预测（永远猜true或false）动态预测（根据历史情况动态调整）</li><li>预取转移成功和不成功两个控制流方向上的目标指令（需要增加至能够支持两个方向的寄存器数量）</li><li>加快和提前形成条件码（类似于全加器并行）</li><li>提高转移方向的猜准率</li></ul></li><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part5/image-20211025103223036.png" alt="image-20211025103223036"></li></ul></li></ul><p><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part5/image-20211025103334530.png" alt="image-20211025103334530"></p><h4 id="流水线的分类"><a href="#流水线的分类" class="headerlink" title="流水线的分类"></a>流水线的分类</h4><ul><li>部件功能级、处理机级和处理机间级流水线（流水线使用的级别）<ul><li><strong>部件功能级流水</strong>就是将复杂的算术逻辑运算组成流水线工作方式。例如，可将浮点加法操作分成求阶差、对阶、尾数相加以及结果规格化等4个子过程。</li><li><strong>处理机级流水</strong>是把一条指令解释过程分成多个子过程，如前面提到的取指、译码、执行、访存及写回 5 个子过程。</li><li><strong>处理机间流水</strong>是一种宏流水，其中每一个处理机完成某一专门任务，各个处理机所得到的结果需存放在与下一个处理机所共享的存储器中。</li></ul></li><li>单功能流水线和多功能流水线（流水线可以完成的功能）<ul><li><strong>单功能流水线</strong>指只能实现一种固定的专门功能的流水线</li><li><strong>多功能流水线</strong>指通过各段间的不同连接方式可以同时或不同时地实现多种功能的流水线</li></ul></li><li>动态流水线和静态流水线（同一时间内各段之间的连接方式）<ul><li><strong>静态流水线</strong>指在同一时间内，流水线的各段只能按同一种功能的连接方式工作。</li><li><strong>动态流水线</strong>指在同一时间内，当某些段正在实现某种运算时，另一些段却正在进行另一种运算。这样对提高流水线的效率很有好处，但会使流水线控制变得很复杂。</li></ul></li><li>线性流水线和非线性流水线（各个功能段之间是否有反馈信号）<ul><li><strong>线性流水线</strong>中，从输入到输出，每个功能段只允许经过一次，不存在反馈回路。</li><li><strong>非线性流水线</strong>存在反馈回路，从输入到输出过程中，某些功能段将数次通过流水线，这种流水线适合进行线性递归的运算。</li></ul></li></ul><h4 id="流水线的多发技术"><a href="#流水线的多发技术" class="headerlink" title="流水线的多发技术"></a>流水线的多发技术</h4><ul><li><strong>超标量技术</strong>（空分复用）<ul><li>每个时钟周期内可<strong>并发多条独立指令</strong></li><li>要配置<strong>多个功能部件</strong>（多个 ALU、寄存器组）</li><li><strong>不能调整</strong>指令的<strong>执行顺序</strong>（乱序发射 CPU 可以调整顺序）</li><li>通过编译优化技术，把可并行执行的指令搭配起来</li><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part5/image-20211025105329051.png" alt="image-20211025105329051"></li></ul></li><li><strong>超流水技术</strong>（时分复用）<ul><li>在<strong>一个时钟周期内再分段</strong>（3段）</li><li>在一个时钟周期（机器周期，理想情况下min机器周期-&gt;时钟周期）内<strong>一个功能部件使用多次</strong>（ 3 次）</li><li><strong>不能调整</strong>指令的<strong>执行顺序</strong></li><li>靠编译程序解决优化问题</li><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part5/image-20211025105518773.png" alt="image-20211025105518773"></li></ul></li><li><strong>超长指令字</strong><ul><li>由<strong>编译程序</strong>挖掘出指令间<strong>潜在的并行性</strong></li><li>将<strong>多条能并行操作的指令组合</strong>成 一条</li><li>具有<strong>多个操作码字段</strong>的超长指令字（可达几百位）</li><li>采用<strong>多个处理部件</strong></li></ul></li></ul><h3 id="五段式指令流水线"><a href="#五段式指令流水线" class="headerlink" title="五段式指令流水线"></a>五段式指令流水线</h3><h4 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h4><ul><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part5/image-20211025100227733.png" alt="image-20211025100227733"></li><li>为方便流水线的设计，将每个阶段的耗时取成一样，以最长耗时为准。即此处应将机器周期设置为 100ns。</li><li>流水线<strong>每一个功能段</strong>部件后面都要有一个<strong>缓冲寄存器</strong>，或称为<strong>锁存器</strong>，其作用是<strong>保存本流水段的执行结果</strong>，提供给下一流水段使用。</li><li><strong>① IF 取指 -&gt; ② ID 译码&amp;取数 -&gt; ③ EX 执行 -&gt; ④ M 访存 -&gt; ⑤ WB 写回寄存器</strong></li><li>考试中常见的五类指令：<ul><li><strong>运算类指令</strong>、<strong>LOAD 指令</strong>、<strong>STORE 指令</strong>、<strong>条件转移指令</strong>、<strong>无条件转移指令</strong></li></ul></li></ul><h4 id="运算类指令的执行过程"><a href="#运算类指令的执行过程" class="headerlink" title="运算类指令的执行过程"></a>运算类指令的执行过程</h4><ul><li>IF：根据 PC 从指令 Cache 取指令至 IF 段的锁存器</li><li>ID：取出操作数至 ID 段锁存器</li><li>EX：运算，将结果存入 EX 段锁存器</li><li>M：空段（RISC 指令集不会在运算指令中访问主存，但是这段时间周期是需要消耗的）</li><li>WB：将运算结果写回指定寄存器</li></ul><table><thead><tr><th>运算类指令举例</th><th>指令的汇编格式</th><th>功能</th></tr></thead><tbody><tr><td>加法指令（两个寄存器相加）</td><td>ADD Rs, Rd</td><td>(Rs)+(Rd) -&gt; Rd</td></tr><tr><td>加法指令（寄存器与立即数相加）</td><td>ADD #996, Rd</td><td>996+(Rd) -&gt; Rd</td></tr><tr><td>算数左移指令</td><td>SHL Rd</td><td>(Rd)&lt;&lt;&lt;2 -&gt; Rd</td></tr></tbody></table><blockquote><ul><li>Rs 指源操作数（source）</li><li>Rd 指目的操作数（destination）</li></ul></blockquote><h4 id="LOAD-指令的执行过程"><a href="#LOAD-指令的执行过程" class="headerlink" title="LOAD 指令的执行过程"></a>LOAD 指令的执行过程</h4><ul><li>IF：根据 PC 从指令 Cache 取指令至 IF 段的锁存器</li><li>ID：将基址寄存器的值放到锁存器 A，将偏移量的值放到 Imm</li><li>EX：运算，得到有效地址</li><li>M：从数据 Cache 中取数并放入锁存器</li><li>WB：将取出的数写回寄存器</li><li>LOAD 也需要经过运算，才能得到有效地址</li></ul><table><thead><tr><th>指令的汇编格式</th><th>功能</th></tr></thead><tbody><tr><td>LOAD Rd, 996(Rs) 或 LOAD Rd, mem</td><td>(996+(Rs)) -&gt; Rd 或 (mem) -&gt; Rd</td></tr></tbody></table><blockquote><p>通常，RISC 处理器<strong>只有“取数 LOAD”和“存数 STORE”指令才能访问主存</strong></p></blockquote><h4 id="STORE-指令的执行过程"><a href="#STORE-指令的执行过程" class="headerlink" title="STORE 指令的执行过程"></a>STORE 指令的执行过程</h4><ul><li>IF：根据 PC 从指令 Cache 取指令至 IF 段的锁存器</li><li>ID：将基址寄存器的值放到锁存器 A，将偏移量的值放到 Imm。<strong>将要存的数放到 B</strong></li><li>EX：运算，得到有效地址。并将锁存器 B 的内容放到锁存器 Store。</li><li>M：写入数据 Cache</li><li>WB：空段</li></ul><table><thead><tr><th>指令的汇编格式</th><th>功能</th></tr></thead><tbody><tr><td>STORE Rs, 996(Rd) 或 STORE Rs, mem</td><td>Rs -&gt; (996+(Rd)) 或 Rs -&gt; (mem)</td></tr></tbody></table><h4 id="条件转移指令的执行过程"><a href="#条件转移指令的执行过程" class="headerlink" title="条件转移指令的执行过程"></a>条件转移指令的执行过程</h4><ul><li><p>IF：根据 PC 从指令 Cache 取指令至 IF 段的锁存器</p></li><li><p>ID：进行比较的两个数放入锁存器 A、B；偏移量放入 Imm</p></li><li><p>EX：运算，比较两个数</p></li><li><p>M：将目标 PC 值写回 PC（<strong>修改 PC 值不在写回阶段而是访存阶段</strong>）</p></li><li><p>WB：空段（<strong>写回阶段通常是修改通用寄存器</strong>）</p></li><li><p>转移类指令常采用<strong>相对寻址</strong></p></li><li><p>很多教材把写回 PC 的功能段称为“WrPC 段”，其耗时比 M 段更短，可安排在 M 段时间内完成。</p></li><li><p>通常在 IF 段结束止之后 PC 就会自动 +“1”</p></li></ul><table><thead><tr><th>指令的汇编格式</th><th>功能</th></tr></thead><tbody><tr><td>beq Rs, Rt, #偏移量</td><td>若(Rs)==(Rt)，则**(PC)+指令字长+(偏移量×指令字长) -&gt; PC<strong>；否则</strong>(PC)+指令字长 -&gt; PC**</td></tr><tr><td>bne Rs, Rt, #偏移量</td><td>若(Rs)!=(Rt)，则**(PC)+指令字长+(偏移量×指令字长) -&gt; PC<strong>；否则</strong>(PC)+指令字长 -&gt; PC**</td></tr></tbody></table><h4 id="无条件转移指令的执行过程"><a href="#无条件转移指令的执行过程" class="headerlink" title="无条件转移指令的执行过程"></a>无条件转移指令的执行过程</h4><ul><li>IF：根据 PC 从指令 Cache 取指令至IF段的锁存器</li><li>ID：偏移量放入 Imm</li><li>EX：将目标 PC 值写回 PC（<strong>这里修改 PC 值不在写回阶段而又是在执行阶段</strong>）</li><li>M：空段</li><li>WB：空段</li><li>“WrPC段”耗时比 EX 段更短，可安排在 EX 段时间内完成。<strong>尽早完成 WrPC 段、修改 PC 值，就越能避免控制冲突</strong>。当然，也有的地方会在 WB 段时间内才修改 PC 的值</li><li>偏移量通常采用补码表示</li></ul><table><thead><tr><th>指令的汇编格式</th><th>功能</th></tr></thead><tbody><tr><td>jmp #偏移量</td><td>(PC)+指令字长+(偏移量×指令字长) -&gt; PC</td></tr></tbody></table>]]></content>
    
    
    <summary type="html">中央处理器</summary>
    
    
    
    <category term="计算机组成原理" scheme="https://nephrencake.gitee.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    
    
  </entry>
  
  <entry>
    <title>计算机组成原理-Part4</title>
    <link href="https://nephrencake.gitee.io/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part4/"/>
    <id>https://nephrencake.gitee.io/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part4/</id>
    <published>2021-10-02T02:53:13.000Z</published>
    <updated>2021-11-16T11:10:35.892Z</updated>
    
    <content type="html"><![CDATA[<h1 id="计算机组成原理-Part4——指令系统"><a href="#计算机组成原理-Part4——指令系统" class="headerlink" title="计算机组成原理-Part4——指令系统"></a>计算机组成原理-Part4——指令系统</h1><p>[TOC]</p><h2 id="指令格式"><a href="#指令格式" class="headerlink" title="指令格式"></a>指令格式</h2><h3 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h3><ul><li>指令（机器指令）：一台计算机的所有指令的集合构成该机的<strong>指令系统</strong>，也称为<strong>指令集</strong>。</li><li>一台计算机只能执行自己指令系统中的指令，不能执行其他系统的指令。Eg：x86 架构、ARM架构</li><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part4/image-20211021233141411.png" alt="image-20211021233141411"></li></ul><h3 id="根据地址码数目不同分类"><a href="#根据地址码数目不同分类" class="headerlink" title="根据地址码数目不同分类"></a>根据地址码数目不同分类</h3><ul><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part4/image-20211021235538544.png" alt="image-20211021235538544"></li><li>一条指令可能包含不同数量的地址码</li><li>零地址指令<ul><li>不需要操作数，如空操作、停机、关中断等指令             </li></ul></li><li>一地址指令<ul><li>只需要单操作数，如加1、减1、取反、求补等<ul><li>指令含义：OP(A1) -&gt; A1 ，完成一条指令需要 3 次访存：<strong>取指 -&gt; 读A1 -&gt; 写A1</strong></li></ul></li><li>需要两个操作数，但其中一个操作数隐含在某个寄存器（如隐含在ACC）<ul><li>指令含义： (ACC)OP(A1) -&gt; ACC，完成一条指令需要2次访存：<strong>取指 -&gt; 读A1</strong></li></ul></li><li>注：A1 指某个主存地址， (A1)表示 A1 所指向的地址中的内容</li></ul></li><li>二地址指令<ul><li>常用于需要两个操作数的算术运算、逻辑运算相关指令</li><li>指令含义：(A1)OP(A2) -&gt; A1</li><li>完成一条指令需要访存 4 次，<strong>取指 -&gt; 读A1 -&gt; 读A2 -&gt; 写A1</strong></li></ul></li><li>三地址指令<ul><li>常用于需要两个操作数的算术运算、逻辑运算相关指令</li><li>指令含义：(A1)OP(A2) -&gt; A3</li><li>完成一条指令需要访存 4 次，<strong>取指 -&gt; 读A1 -&gt; 读A2 -&gt; 写A3</strong></li></ul></li><li>四地址指令<ul><li>指令含义：(A1)OP(A2) -&gt; A3，A4=下一条将要执行指令的地址</li><li>完成一条指令需要访存 4 次，<strong>取指 -&gt; 读A1 -&gt; 读A2 -&gt; 写A3</strong></li></ul></li><li><strong>若指令总长度固定不变，则地址码数量越多，寻址能力越差</strong></li></ul><h3 id="根据指令长度分类"><a href="#根据指令长度分类" class="headerlink" title="根据指令长度分类"></a>根据指令长度分类</h3><ul><li><strong>指令字长</strong>：一条指令的总长度（可能会变）<ul><li>机器字长：CPU进行一次整数运算所能处理的二进制数据的位数（通常和ALU直接相关）</li><li>存储字长：一个存储单元中的二进制代码位数（通常和MDR位数相同）</li><li>半字长指令、单字长指令、双字长指令——指令长度是机器字长的 n 倍</li><li>指令字长会影响取指令所需时间。如：机器字长=存储字长=16bit，则取一条双字长指令需要两次访存</li></ul></li><li><strong>定长指令字结构</strong>：指令系统中所有指令的长度都相等</li><li><strong>变长指令字结构</strong>：指令系统中各种指令的长度不等</li></ul><h3 id="根据操作码长度分类"><a href="#根据操作码长度分类" class="headerlink" title="根据操作码长度分类"></a>根据操作码长度分类</h3><ul><li><strong>定长操作码</strong>：指令系统中所有指令的操作码长度都相同<ul><li>控制器的译码电路设计简单，但灵活性较低</li><li>n 位 -&gt; 2^n^ 条指令</li><li>优：定长操作码对于简化计算机硬件设计，提高指令译码和识别速度很有利；</li><li>缺：指令数量增加时会占用更多固定位，留给表示操作数地址的位数受限。</li></ul></li><li><strong>可变长操作码</strong>：指令系统中各指令的操作码长度可变<ul><li>控制器的译码电路设计复杂， 但灵活性较高</li><li>不同地址数的指令可以具有不同长度的操作码，从而在满足需要的前提下，有效地缩短指令字长。</li><li>优： 在指令字长有限的前提下仍保持比较丰富的指令种类；</li><li>缺 ：增加了指令译码和分析的难度，使控制器的设计复杂化。</li></ul></li><li><strong>定长指令字结构+可变长操作码</strong> -&gt; <strong>扩展操作码指令格式</strong><ul><li>不同地址数的指令使用不同长度的操作码</li></ul></li></ul><h3 id="根据操作类型分类"><a href="#根据操作类型分类" class="headerlink" title="根据操作类型分类"></a>根据操作类型分类</h3><ul><li>数据传送类：进行主存与CPU之间的数据传送<ol><li>数据传送<ul><li>LOAD：把<strong>存储器</strong>中的数据放到<strong>寄存器</strong>中</li><li>STORE：把<strong>寄存器</strong>中的数据放到<strong>存储器</strong>中</li></ul></li></ol></li><li>运算类<ol start="2"><li>算术逻辑操作<ul><li>算术：加、减、乘、除、增 1、减 1、求补、浮点运算、十进制运算</li><li>逻辑：与、或、非、异或、位操作、位测试、位清除、位求反</li></ul></li><li>移位操作<ul><li>算术移位、逻辑移位、循环移位(带进位和不带进位)</li></ul></li></ol></li><li>程序控制类：改变程序执行的顺序<ol start="4"><li>转移操作<ul><li>无条件转移 JMP</li><li>条件转移 JZ：结果为 0；JO：结果溢出；JC：结果有进位</li><li>调用和返回 CALL 和 RETURN</li><li>陷阱(Trap)与陷阱指令</li></ul></li></ol></li><li>输入输出类（I/O）：进行CPU和I/O设备之间的数据传送<ol start="5"><li>输入输出操作<ul><li>CPU 寄存器与 IO 端口之间的数据传送（端口即 IO 接口中的寄存器）</li></ul></li></ol></li></ul><h2 id="扩展操作码指令格式"><a href="#扩展操作码指令格式" class="headerlink" title="扩展操作码指令格式"></a>扩展操作码指令格式</h2><ul><li>扩展操作码：定长指令字结构+可变长操作码</li><li>设计扩展操作码指令格式的注意点：<ul><li>不允许短码是长码的前缀。</li><li>各指令的操作码一定不能重复。</li></ul></li><li>通常情况下，对使用频率较高的指令，分配较短的操作码；对使用频率较低的指令，分配较长的操作码。从而尽可能减少指令译码和分析的时间。</li><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part4/image-20211022102529044.png" alt="image-20211022102529044"></li><li>设地址长度为 n，上一层留出 m 种状态，则下一层可扩展出 m×2^n^ 种状态</li></ul><h2 id="指令寻址"><a href="#指令寻址" class="headerlink" title="指令寻址"></a>指令寻址</h2><h3 id="顺序寻址"><a href="#顺序寻址" class="headerlink" title="顺序寻址"></a>顺序寻址</h3><ul><li>指令寻址：下一条欲执行指令的地址（<strong>始终由程序计数器PC给出</strong>）</li><li>顺序寻址：( PC ) + “1” -&gt; PC</li><li><strong>这里的“1”理解为 1 个指令的字长</strong>，实际加的值会因<strong>指令长度</strong>、<strong>编址方式</strong>而不同<ul><li><strong>定长</strong>指令字结构 + 按<strong>字</strong>编址 + 指令字长=存储字长=16bit=2B：每次 PC + 1 </li><li><strong>定长</strong>指令字结构 + 按<strong>字节</strong>编址 + 指令字长=存储字长=16bit=2B：每次 PC + 2</li><li><strong>变长</strong>指令字结构 + 按<strong>字节</strong>编址 + 指令字长!=存储字长=16bit=2B：每次 PC + n<ul><li>根据指令的类型，CPU 可能还要进行多次访存，<strong>每次读入一个字</strong></li><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part4/image-20211022130853433.png" alt="image-20211022130853433" style="zoom:80%;"></li></ul></li></ul></li></ul><h3 id="跳跃寻址"><a href="#跳跃寻址" class="headerlink" title="跳跃寻址"></a>跳跃寻址</h3><ul><li>跳跃寻址：由转移指令指出</li><li>CPU 与 PC 之间的顺序：<ul><li>CPU 取出 PC 中存储的指令</li><li>PC += 1</li><li>CPU 执行取出的指令<ul><li>如果是执行转移指令，则修改 PC 内容</li></ul></li><li>CPU 取出 PC 中存储的指令。Loop</li></ul></li><li>每一条指令的执行都分为 “取指令”、“执行指令” 两个阶段</li><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part4/image-20211022131031340.png" alt="image-20211022131031340"></li></ul><h2 id="数据寻址"><a href="#数据寻址" class="headerlink" title="数据寻址"></a>数据寻址</h2><h3 id="指令寻址-v-s-数据寻址"><a href="#指令寻址-v-s-数据寻址" class="headerlink" title="指令寻址 v.s. 数据寻址"></a>指令寻址 v.s. 数据寻址</h3><ul><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part4/image-20211022132436880.png" alt="image-20211022132436880"></li><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part4/image-20211022132520543.png" alt="image-20211022132520543"></li><li>求出操作数的真实地址，称为有效地址（EA）。</li></ul><h3 id="直接与间接寻址"><a href="#直接与间接寻址" class="headerlink" title="直接与间接寻址"></a>直接与间接寻址</h3><h4 id="直接寻址"><a href="#直接寻址" class="headerlink" title="直接寻址"></a>直接寻址</h4><ul><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part4/image-20211022133342005.png" alt="image-20211022133342005" style="zoom:80%;"></li><li>直接寻址：指令字中的<strong>形式地址 A 就是操作数的真实地址 EA(effective address)**，即 **EA=A</strong> 。</li><li>共访存 <strong>2</strong> 次：取指令访存1次；执行指令访存 1 次。</li><li>优点：<ul><li>简单，指令执行阶段仅访问一次主存，不需专门计算操作数的地址。</li></ul></li><li>缺点：<ul><li>A 的位数决定了该指令操作数的寻址范围。</li><li>操作数的地址不易修改。</li></ul></li></ul><h4 id="间接寻址"><a href="#间接寻址" class="headerlink" title="间接寻址"></a>间接寻址</h4><ul><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part4/image-20211022134527227.png" alt="image-20211022134527227" style="zoom:80%;"></li><li>间接寻址：指令的地址字段给出的形式地址是<strong>操作数有效地址所在的存储单元的地址</strong>，也就是操作数地址的地址，即 <strong>EA=(A)</strong> 。</li><li>共访存 <strong>3</strong> 次：取指令访存 1 次；执行指令访存 2 次。</li><li>优点：<ul><li>可扩大寻址范围（有效地址 EA 的位数大于形式地址 A 的位数）。</li><li>便于编制程序（用间接寻址可以方便地完成子程序返回）。</li></ul></li><li>缺点：<ul><li>指令在执行阶段要多次访存（一次间址需两次访存，多次寻址需根据存储字的最高位确定几次访存）。</li></ul></li></ul><h4 id="寄存器寻址"><a href="#寄存器寻址" class="headerlink" title="寄存器寻址"></a>寄存器寻址</h4><ul><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part4/image-20211022135027732.png" alt="image-20211022135027732" style="zoom:80%;"></li><li>寄存器寻址：在指令字中直接给出操作数所在的寄存器编号，即 **EA=R<del>i</del>**，其操作数在由 R<del>i</del> 所指的寄存器内。</li><li>共访存 <strong>1</strong> 次：取指令访存 1 次；执行指令访存 0 次。</li><li>优点：<ul><li>指令在<strong>执行阶段</strong>不访问主存，<strong>只访问寄存器</strong></li><li>指令字短且执行速度快，支持<strong>向量/矩阵运算</strong>。</li></ul></li><li>缺点：<ul><li>寄存器价格昂贵，计算机中寄存器个数有限 。</li></ul></li></ul><h4 id="寄存器间接寻址"><a href="#寄存器间接寻址" class="headerlink" title="寄存器间接寻址"></a>寄存器间接寻址</h4><ul><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part4/image-20211022135538548.png" alt="image-20211022135538548" style="zoom:80%;"></li><li>寄存器间接寻址：寄存器 R<del>i</del> 中给出的不是一个操作数，而是<strong>操作数所在主存单元的地址</strong>，即 <strong>EA=(R<del>i</del>)</strong> 。</li><li>共访存 <strong>2</strong> 次：取指令访存 1 次；执行指令访存 1 次。</li><li>特点：<ul><li>与一般间接寻址相比速度更快，但指令的执行阶段需要访问主存（因为操作数在主存中）。</li></ul></li></ul><h4 id="隐含寻址"><a href="#隐含寻址" class="headerlink" title="隐含寻址"></a>隐含寻址</h4><ul><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part4/image-20211022135948636.png" alt="image-20211022135948636" style="zoom:80%;"></li><li>隐含寻址：不是明显地给出操作数的地址，而是在指令中隐含着操作数的地址。</li><li>共访存 <strong>1</strong> 次：取指令访存 1 次；执行指令访存 0 次。</li><li>优点：有利于缩短指令字长。</li><li>缺点：需增加存储操作数或隐含地址的硬件。</li></ul><h4 id="立即寻址"><a href="#立即寻址" class="headerlink" title="立即寻址"></a>立即寻址</h4><ul><li>立即寻址：形式地址 A 就是<strong>操作数本身</strong>，又称为立即数，一般采用补码形式。“#”表示立即寻址特征。</li><li>共访存 <strong>1</strong> 次：取指令访存 1 次；执行指令访存 0 次。</li><li>优点：指令执行阶段不访问主存，<strong>指令执行时间最短</strong></li><li>缺点：A 的位数限制了立即数的范围。<ul><li>如 A 的位数为 n，且立即数采用补码时，可表示的数据范围为：−2^n-1^ ～ 2^n-1^−1</li></ul></li></ul><h3 id="偏移寻址"><a href="#偏移寻址" class="headerlink" title="偏移寻址"></a>偏移寻址</h3><h4 id="基址寻址（多道程序）"><a href="#基址寻址（多道程序）" class="headerlink" title="基址寻址（多道程序）"></a>基址寻址（多道程序）</h4><ul><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part4/image-20211022142356006.png" alt="image-20211022142356006"></li><li>基址寻址：将 CPU 中基址寄存器（base address register，BR）的内容加上指令格式中的形式地址 A，而形成操作数的有效地址，即 <strong>EA=(BR)+A</strong>。<ul><li>操作系统第三章第一节学习，OS 课中的“重定位寄存器”就是“基址寄存器”</li><li>程序运行前，CPU 将 BR 的值修改为该程序的起始地址（存在操作系统 PCB 中）</li></ul></li><li>基址寄存器是<strong>面向操作系统</strong>的，<strong>其内容仅由操作系统或管理程序确定，对于程序员是透明的</strong>。<ul><li>基址寄存器的内容不变（作为基地址），形式地址可变（作为偏移量）。</li><li>当采用通用寄存器作为基址寄存器时，可由<strong>用户决定哪个寄存器作为基址寄存器</strong>，但其<strong>内容仍由操作系统确定</strong>。</li></ul></li><li>优点：<ul><li>便于程序在内存里的地址浮动，方便实现<strong>多道程序</strong>并发运行</li><li>可扩大寻址范围（基址寄存器的位数大于形式地址的位数）</li><li>用户<strong>不必考虑自己的程序存于主存的哪一空间区域</strong>，故<strong>有利于多道程序设计</strong></li></ul></li></ul><h4 id="变址寻址（循环程序）"><a href="#变址寻址（循环程序）" class="headerlink" title="变址寻址（循环程序）"></a>变址寻址（循环程序）</h4><ul><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part4/image-20211022181842393.png" alt="image-20211022181842393"></li><li>变址寻址：有效地址 EA 等于指令字中的形式地址 A 与变址寄存器 IX 的内容相加之和，即 <strong>EA=(IX)+A</strong>。其中 <strong>IX 可为变址寄存器（专用）</strong>，也<strong>可用通用寄存器作为变址寄存器</strong>。</li><li>变址寄存器是<strong>面向用户</strong>的，<strong>变址寄存器的内容可由用户改变</strong><ul><li>基址寄存器的内容不变（作为偏移量），形式地址可变（作为基地址）。</li></ul></li><li>优点：<ul><li>在数组处理过程中，可设定 A 为数组的首地址，不断改变变址寄存器 IX(index register) 的内容，便可很容易地表示数组中任一数据的地址，<strong>适合编制循环程序</strong>。</li></ul></li><li>两者同样可以一起使用——基址&amp;变址复合寻址</li></ul><h4 id="相对寻址（转移指令）"><a href="#相对寻址（转移指令）" class="headerlink" title="相对寻址（转移指令）"></a>相对寻址（转移指令）</h4><ul><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part4/image-20211022185157913.png" alt="image-20211022185157913"></li><li>相对寻址：把程序计数器 PC 的内容加上指令格式中的形式地址 A 而形成操作数的有效地址，即 <strong>EA=(PC)+A</strong>。<ul><li><strong>A 是相对于下一条指令（PC 所指地址）的偏移量</strong>，可正可负，<strong>补码表示</strong> 。因为 PC 会在取出指令后立刻加一。</li></ul></li><li>优点：<ul><li>便于一段代码在程序内部的浮动。</li></ul></li><li>相对寻址广泛应<strong>用于转移指令</strong>。</li></ul><h3 id="堆栈寻址"><a href="#堆栈寻址" class="headerlink" title="堆栈寻址"></a>堆栈寻址</h3><h4 id="堆栈寻址-1"><a href="#堆栈寻址-1" class="headerlink" title="堆栈寻址"></a>堆栈寻址</h4><ul><li>堆栈寻址：操作数存放在堆栈中，隐含使用堆栈指针（Stack Pointer, SP）作为操作数地址。</li><li>堆栈是一块按“后进先出（LIFO）”原则管理的存储区，该存储区中被读/写单元的地址是用堆栈指针给出的。</li><li>堆栈可以由寄存器组（硬堆栈，成本高）或者主存中划分一块区域（软堆栈，成本低）实现。</li><li>有堆栈才可以方便地实现保护现场、调用函数。</li></ul><h3 id="数据寻址总结"><a href="#数据寻址总结" class="headerlink" title="数据寻址总结"></a>数据寻址总结</h3><table><thead><tr><th>寻址方式</th><th>有效地址</th><th>访存次数（指令执行期间）</th></tr></thead><tbody><tr><td>直接寻址</td><td>EA=A</td><td>1</td></tr><tr><td>一次间接寻址</td><td>EA=(A)</td><td>2</td></tr><tr><td>寄存器寻址</td><td>EA=R<del>i</del></td><td>0</td></tr><tr><td>寄存器间接一次寻址</td><td>EA=(R<del>i</del>)</td><td>1</td></tr><tr><td>隐含寻址</td><td>程序指定</td><td>0</td></tr><tr><td>立即寻址</td><td>A 即是操作数</td><td>0</td></tr><tr><td>基址寻址</td><td>EA=(BR)+A</td><td>1</td></tr><tr><td>变址寻址</td><td>EA=(IX)+A</td><td>1</td></tr><tr><td>相对寻址</td><td>EA=(PC)+A</td><td>1</td></tr><tr><td>堆栈寻址</td><td>入栈/出栈时 EA 的确定方式不同</td><td>硬堆栈不访存，软堆栈访存1次</td></tr></tbody></table><h2 id="CISC-和-RISC"><a href="#CISC-和-RISC" class="headerlink" title="CISC 和 RISC"></a>CISC 和 RISC</h2><ul><li>CISC：Complex Instruction Set Computer<ul><li>设计思路：一条指令完成一个复杂的基本功能。</li></ul></li><li>RISC：Reduced Instruction Set Computer<ul><li>设计思路：一条指令完成一个基本“动作”；多条指令组合完成一个复杂的基本功能。</li></ul></li></ul><table><thead><tr><th>对比项目</th><th>CISC</th><th>RISC</th></tr></thead><tbody><tr><td>指令系统</td><td>复杂</td><td>简单</td></tr><tr><td>代表</td><td>x86 架构</td><td>ARM 架构</td></tr><tr><td>指令数目</td><td>一般大于 200 条</td><td>一般小于 100 条</td></tr><tr><td>指令字长</td><td>不固定</td><td>定长</td></tr><tr><td>可访存指令</td><td>不加限制</td><td>有 Load/Store 指令</td></tr><tr><td>各指令执行时间</td><td>相差较大</td><td>大部分在一个周期内</td></tr><tr><td>各指令执行频率</td><td>相差较大</td><td>都比较常用</td></tr><tr><td>通用寄存器数量</td><td>较少</td><td>多</td></tr><tr><td>目标代码</td><td>难以用优化编译提高程序效率</td><td>可以用优化编译提高程序效率</td></tr><tr><td>控制方式</td><td>大部分为微程序控制（更慢）</td><td>大部分为组合逻辑控制（更快）</td></tr><tr><td>指令流水线</td><td>可以实现</td><td>必须实现</td></tr></tbody></table>]]></content>
    
    
    <summary type="html">指令系统</summary>
    
    
    
    <category term="计算机组成原理" scheme="https://nephrencake.gitee.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    
    
  </entry>
  
  <entry>
    <title>计算机组成原理-Part3</title>
    <link href="https://nephrencake.gitee.io/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part3/"/>
    <id>https://nephrencake.gitee.io/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part3/</id>
    <published>2021-10-02T02:53:08.000Z</published>
    <updated>2021-10-26T15:16:29.302Z</updated>
    
    <content type="html"><![CDATA[<h1 id="计算机组成原理-Part3——存储系统"><a href="#计算机组成原理-Part3——存储系统" class="headerlink" title="计算机组成原理-Part3——存储系统"></a>计算机组成原理-Part3——存储系统</h1><p>[TOC]</p><h2 id="存储系统基本概念"><a href="#存储系统基本概念" class="headerlink" title="存储系统基本概念"></a>存储系统基本概念</h2><h3 id="存储器的层次结构"><a href="#存储器的层次结构" class="headerlink" title="存储器的层次结构"></a>存储器的层次结构</h3><ul><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part3/image-20211018200033029.png" alt="image-20211018200033029"></li><li>辅存中的数据要调入主存后才能被 CPU 访问</li><li>主存—辅存：实现虚拟存储系统，<strong>解决了主存容量不够的问题</strong></li><li>Cache—主存：<strong>解决了主存与 CPU 速度不匹配的问题</strong></li></ul><h3 id="存储器的分类"><a href="#存储器的分类" class="headerlink" title="存储器的分类"></a>存储器的分类</h3><ol><li>层次：<ul><li>高速缓存（Cache）</li><li>主存储器（主存、内存）</li><li>辅助存储器（辅存、外存）</li></ul></li><li>存储介质：<ul><li>半导体存储器（主存、Cache）</li><li>磁表面存储器（磁盘、磁带）</li><li>光存储器（光盘）</li></ul></li><li>存取方式：<ul><li><strong>随机存取存储器</strong>（Random Access Memory，RAM）（内存）</li><li>串行访问存储器：读写某个存储单元所需时间与存储单元的物理位置有关<ul><li>顺序存取存储器（Sequential Access Memory，SAM）（磁带）：读写一个存储单元所需时间取决于存储单元所在的物理位置</li><li>直接存取存储器（Direct Access Memory，DAM）（磁盘）：既有随机存取特性，也有顺序存取特性。先直接选取信息所在区域，然后按顺序方式存取。</li></ul></li><li>相联存储器（Associative Memory），即可按内容访问的存储器（Content Addressed Memory，CAM）：可以按照内容检索到存储位置进行读写，“快表”就是一种相联存储器。</li></ul></li><li>信息的可更改性：<ul><li>读写存储器（Read/Write Memory）：即可读、也可写（磁盘、内存、Cache）</li><li>只读存储器（Read Only Memory）：只能读，不能写（实体音乐专辑通常采用 CD-ROM、实体电影采用蓝光光碟、BIOS 通常写在 ROM 中）</li></ul></li><li>信息的可保存性：<ul><li>断电后，存储信息消失的存储器——易失性存储器（主存、Cache）</li><li>断电后，存储信息依然保持的存储器——非易失性存储器（磁盘、光盘）</li><li>信息读出后，原存储信息被破坏——破坏性读出（如 DRAM 芯片，读出数据后要进行重写）</li><li>信息读出后，原存储信息不被破坏——非破坏性读出（如 SRAM 芯片、磁盘、光盘）</li></ul></li></ol><h3 id="存储器的性能指标"><a href="#存储器的性能指标" class="headerlink" title="存储器的性能指标"></a>存储器的性能指标</h3><ol><li>存储容量：存储字数（MDR）×字长（MAR）。</li><li>单位成本：每位价格=总成本/总容量。（每个 bit 位的成本）</li><li>存储速度：数据传输率=数据的宽度/存储周期。<ul><li>数据的宽度=存储字长</li><li>数据传输率=主存带宽</li></ul></li></ol><p><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part3/image-20211018202338820.png" alt="image-20211018202338820"></p><ul><li><strong>存取时间</strong>（T<del>a</del>）：指从启动一次存储器操作到完成该操作所经历的时间，分为读出时间和写入时间。</li><li><strong>存取周期</strong>（T<del>m</del>）：又称<strong>读写周期</strong>或<strong>访问周期</strong>。它是指存储器进行一次完整的读写操作所需的全部时间，即连续两次独立地访问存储器操作（读或写操作）之间所需的最小时间间隔。<ul><li><strong>存取周期=存取时间+恢复时间</strong></li></ul></li><li><strong>主存带宽</strong>（B<del>m</del>）：又称<strong>数据传输率</strong>，表示每秒从主存进出信息的最大数量，单位为字/秒、字节/秒（B/s）或位/秒（b/s）。</li></ul><h2 id="主存储器的基本组成"><a href="#主存储器的基本组成" class="headerlink" title="主存储器的基本组成"></a>主存储器的基本组成</h2><h3 id="半导体元件的原理"><a href="#半导体元件的原理" class="headerlink" title="半导体元件的原理"></a>半导体元件的原理</h3><ul><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part3/image-20211018203602384.png" alt="image-20211018203602384"></li><li>MOS 管相当于一种电控开关，输入电压达到某个阈值时，MOS 管就可以接通</li><li>之所以是<strong>按存储字读写</strong>，是因为<strong>一个存储单元共用一条线来控制 MOS 管</strong>，只能同时读取或同时写入一个字</li></ul><h3 id="存储芯片的基本原理"><a href="#存储芯片的基本原理" class="headerlink" title="存储芯片的基本原理"></a>存储芯片的基本原理</h3><ul><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part3/image-20211018204801463.png" alt="image-20211018204801463"></li><li>头上划线表示该信号低电平有效</li><li>引脚与数据线<ul><li>地址线</li><li>数据线</li><li>片选线：一块内存条可能有多块存储芯片<ul><li>CS：Chip-Select；CE：Chip-Enable（两种表示方式皆可，当有上划线则表示低电平有效）</li><li>对选中存储芯片的片选线给予低电平，对未选中的给予高电平</li></ul></li><li>读写线<ul><li>当使用不同数量的读写线，则对外暴露的引脚是不一样的</li><li>使用 WE(Write Enable)、OE，则两根读写线</li><li>使用 WE或WR 则一根读写线（低电平写，高电平读）</li></ul></li></ul></li><li>译码器驱动电路：将地址信号转化成字选通线的高低电平</li><li>存储矩阵（存储体）：由多个存储单元构成，每个存储单元又由多个存储元构成</li></ul><h3 id="如何实现不同的寻址方式"><a href="#如何实现不同的寻址方式" class="headerlink" title="如何实现不同的寻址方式"></a>如何实现不同的寻址方式</h3><ul><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part3/image-20211018223923446.png" alt="image-20211018223923446"></li><li>一般以<strong>字节</strong>编址，即每个字节对应一个地址。同时也能够支持按半字、字、双字寻址</li><li>存储单元的长度并不影响按何种方式寻址，但是一次读写数据必须按字为单位</li><li>n 根地址线能够寻 2^n^ 个存储单元</li></ul><h2 id="SRAM-和-DRAM"><a href="#SRAM-和-DRAM" class="headerlink" title="SRAM 和 DRAM"></a>SRAM 和 DRAM</h2><ul><li>随机存取存储器（Random Access Memory，RAM）<ul><li>Dynamic Random Access Memory，即动态RAM</li><li>Static Random Access Memory，即静态RAM</li><li><strong>DRAM</strong> 用于<strong>主存</strong>；<strong>SRAM</strong> 用于 <strong>Cache</strong></li></ul></li><li>核心区别：<strong>存储元不一样</strong><ul><li>DRAM芯片：使用<strong>栅极电容</strong>存储信息</li><li>SRAM芯片：使用<strong>双稳态触发器</strong>存储信息</li></ul></li></ul><h3 id="存储元件不同导致的特性差异"><a href="#存储元件不同导致的特性差异" class="headerlink" title="存储元件不同导致的特性差异"></a>存储元件不同导致的特性差异</h3><h4 id="栅极电容"><a href="#栅极电容" class="headerlink" title="栅极电容"></a>栅极电容</h4><p><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part3/image-20211019205541116.png" alt="image-20211019205541116"></p><ul><li>存储状态<ul><li>1：电容内存储了电荷</li><li>0：电容内未存储电荷</li></ul></li><li>读出状态<ul><li>读出 1：MOS 管接通，电容放电，数据线上产生电流</li><li>读出 0：MOS 管接通后，数据线上无电流</li></ul></li><li>特点<ul><li>电容放电信息被破坏，是<strong>破坏性读出</strong>。所以，读出后应有<strong>重写</strong>操作，也称“再生”</li><li>读写速度<strong>更慢</strong></li><li><strong>制造成本更低，集成度高，功耗低</strong></li></ul></li></ul><h4 id="双稳态触发器"><a href="#双稳态触发器" class="headerlink" title="双稳态触发器"></a>双稳态触发器</h4><p><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part3/image-20211019205912531.png" alt="image-20211019205912531"></p><ul><li>存储状态<ul><li>1：A 高电平 B 低电平</li><li>0：A 低电平 B 高电平</li></ul></li><li>读出状态<ul><li>读出 0：BL 为低电平，BLX 无信号</li><li>读出 1：BLX 为低电平，BL 无信号</li></ul></li><li>特点<ul><li>读出数据，触发器状态保持稳定，是<strong>非破坏性读出</strong>，<strong>无需重写</strong></li><li>读写速度<strong>更快</strong></li><li><strong>制造成本更高，集成度低，功耗大</strong></li></ul></li></ul><h4 id="DRAM-和-SRAM-对比（高频）"><a href="#DRAM-和-SRAM-对比（高频）" class="headerlink" title="DRAM 和 SRAM 对比（高频）"></a>DRAM 和 SRAM 对比（高频）</h4><table><thead><tr><th>类型特点</th><th>SRAM（静态 RAM）</th><th>DRAM（动态 RAM）</th></tr></thead><tbody><tr><td>存储信息</td><td>触发器</td><td>电容</td></tr><tr><td>破坏性读出</td><td>否</td><td>是</td></tr><tr><td>读出后需要重写</td><td>否</td><td>是</td></tr><tr><td>运行速度</td><td>快</td><td>man</td></tr><tr><td>集成度</td><td>低</td><td>高</td></tr><tr><td>发热量</td><td>大</td><td>小</td></tr><tr><td>存储成本</td><td>高</td><td>低</td></tr><tr><td>易失/非易失性存储器</td><td>易失（断电后丢失信息）</td><td>易失（断电后丢失信息）</td></tr><tr><td>需要刷新</td><td>不需要</td><td>需要</td></tr><tr><td>送行列地址</td><td>同时送</td><td>分两次送</td></tr><tr><td>常用与制作</td><td>Cache</td><td>主存</td></tr></tbody></table><h3 id="DRAM-的刷新"><a href="#DRAM-的刷新" class="headerlink" title="DRAM 的刷新"></a>DRAM 的刷新</h3><p><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part3/image-20211019220838787.png" alt="image-20211019220838787"></p><ul><li><p>为什么刷新？</p><ul><li>双稳态（静态RAM，SRAM）只要不断电，触发器的状态就不会改变。所以<strong>不需要刷新</strong>。</li><li>栅极电容（动态RAM，DRAM）电容内的电荷只能维持 2ms。即便不断电，2ms 后信息也会消失。所以，2ms 之内必须“刷新”一次（给电容充电）</li></ul></li><li><p>多久需要刷新一次？刷新周期：若题目没有指明，则一般为 <strong>2ms</strong></p></li><li><p>每次刷新多少存储单元？以行为单位，<strong>每次刷新一行存储单元</strong></p><ul><li>为什么要用行列地址？<strong>减少选通线的数量</strong>。拆分为行列地址（<strong>DRAM行、列地址等长</strong>）</li></ul></li><li><p>如何刷新？有硬件支持，读出一行的信息后重新写入，<strong>占用1个读/写周期（存取周期）</strong></p></li><li><p>在什么时刻刷新？</p><ul><li>假设 DRAM 内部结构排列成 128×128 的形式，读/写周期 0.5us。2ms 共 <code>2ms / 0.5us = 4000</code> 个周期</li></ul></li><li><p><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part3/image-20211019215622587.png" alt="image-20211019215622587"></p></li><li><p>“刷新”由存储器独立完成，不需要 CPU 控制。</p></li></ul><h3 id="DRAM-的地址线复用技术"><a href="#DRAM-的地址线复用技术" class="headerlink" title="DRAM 的地址线复用技术"></a>DRAM 的地址线复用技术</h3><ul><li>SRAM 同时送行列地址；DRAM 分两次送行列地址。</li><li>同时送指的是将地址的前后两部分同时送给行地址译码器和列地址译码器。这样的话，<strong>地址有 n 位，就要设计 n 根地址线</strong></li><li>但是 DRAM 的存储容量较大。所以将<strong>地址线、引脚减半</strong>，先将<strong>前半部分送入行地址缓冲器</strong>，再将<strong>后半部分送入列地址缓冲器</strong></li></ul><h2 id="只读存储器ROM"><a href="#只读存储器ROM" class="headerlink" title="只读存储器ROM"></a>只读存储器ROM</h2><h3 id="各种-ROM"><a href="#各种-ROM" class="headerlink" title="各种 ROM"></a>各种 ROM</h3><ol><li><strong>MROM（Mask Read-Only Memory）</strong>——掩模式只读存储器<ul><li>厂家按照客户需求，在芯片生产过程中直接写入信息，之后<strong>任何人不可重写</strong>（只能读出）</li><li>可靠性高、灵活性差、生产周期长、只适合批量定制</li></ul></li><li><strong>PROM（Programmable Read-Only Memory）</strong>——可编程只读存储器<ul><li>用户可用专门的PROM写入器写入信息，<strong>写一次之后就不可更改</strong></li></ul></li><li><strong>EPROM（Erasable Programmable Read-Only Memory）</strong>——可擦除可编程只读存储器<ul><li>允许用户写入信息，之后用某种方法擦除数据，<strong>修改次数有限，写入时间很长</strong></li><li>UVEPROM（ultraviolet rays）——用紫外线照射8~20分钟，<strong>擦除所有信息</strong></li><li>EEPROM（也常记为E2 PROM，第一个E是Electrically）——可用“电擦除”的方式，<strong>擦除特定的字</strong></li></ul></li><li><strong>Flash Memory</strong> ——闪速存储器（注：U盘、SD卡就是闪存）<ul><li>在EEPROM 基础上发展而来，断电后也能保存信息，且<strong>可进行多次快速擦除重写</strong></li><li>注意：由于闪存需要先擦除在写入，因此<strong>闪存的“写”速度要比“读”速度更慢</strong>。</li><li>每个存储元只需单个MOS管，位密度比RAM高</li></ul></li><li><strong>SSD（Solid State Drives）</strong>—— 固态硬盘<ul><li>由控制单元+存储单元（Flash 芯片）构成，与闪速存储器的核心区别在于控制单元不一样，但存储介质都类似，<strong>可进行多次快速擦除重写</strong>。</li><li>SSD速度快、功耗低、价格高。</li><li>手机辅存也使用Flash 芯片，但相比SSD使用的芯片集成度高、功耗低、价格贵</li></ul></li></ol><ul><li>很多 ROM 芯片虽然名字是“Read-Only”，但<strong>很多 ROM 也可以“写”</strong></li><li>RAM（Random Access Memory）芯片是易失性的，ROM（Read-Only Memory）芯片是非易失性的。<strong>很多 ROM 也具有“随机存取”的特性</strong></li></ul><h3 id="计算机内的重要-ROM"><a href="#计算机内的重要-ROM" class="headerlink" title="计算机内的重要 ROM"></a>计算机内的重要 ROM</h3><ul><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part3/image-20211019223754947.png" alt="image-20211019223754947"></li><li>针对问题<ul><li>断电后，RAM内数据全部丢失</li><li>操作系统安装在辅存</li></ul></li><li><strong>主板上的</strong> BIOS 芯片（ROM），存储了“自举装入程序”，负责引导装入操作系统（开机）</li><li>逻辑上，<strong>主存由 RAM+ROM 组成</strong>，且二者常统一编址</li><li>我们常说“内存条”就是“主存”，但事实上，主板上的 ROM 芯片也是“主存”的一部分</li></ul><h2 id="主存储器与-CPU-的连接"><a href="#主存储器与-CPU-的连接" class="headerlink" title="主存储器与 CPU 的连接"></a>主存储器与 CPU 的连接</h2><h3 id="单块存储芯片与-CPU-的连接"><a href="#单块存储芯片与-CPU-的连接" class="headerlink" title="单块存储芯片与 CPU 的连接"></a>单块存储芯片与 CPU 的连接</h3><ul><li><p>针对问题：想要扩展主存<strong>字数</strong></p><ul><li>改进方向：<strong>字扩展</strong></li><li>连接多块存储芯片来扩展主存字数</li></ul></li><li><p>针对问题：想要扩展<strong>存储字长</strong></p><ul><li>改进方向：<strong>位扩展</strong></li><li>一个存储字长是 8bit，而数据总线一般有 64bit</li><li>为了尽可能发挥数据总线的性能，要保持<strong>数据总线宽度=存储字长</strong>，提高一次读写的数据量</li></ul></li><li><p>现在 MDR 和 MAR 常集成于 CPU 内部，存储芯片内只需要一个普通的寄存器（暂存输入输出数据）</p><ul><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part3/image-20211020121325377.png" alt="image-20211020121325377" style="zoom:80%;"></li><li>CPU 和主存之间通过<strong>数据总线</strong>、<strong>地址总线</strong>、<strong>控制总线</strong>连接</li><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part3/image-20211020123151574.png" alt="image-20211020123151574" style="zoom:80%;"></li><li>对外暴露的引脚：地址线+数据线+片选线+读写控制线</li></ul></li></ul><h3 id="多块存储芯片与-CPU-的连接"><a href="#多块存储芯片与-CPU-的连接" class="headerlink" title="多块存储芯片与 CPU 的连接"></a>多块存储芯片与 CPU 的连接</h3><h4 id="位扩展法"><a href="#位扩展法" class="headerlink" title="位扩展法"></a>位扩展法</h4><ul><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part3/image-20211020130901005.png" alt="image-20211020130901005" style="zoom:80%;"></li><li>将 <strong>n</strong> 片 <strong>k×m</strong> 位的存储芯片，集合成 <strong>k×(m×n)</strong> 的芯片</li></ul><h4 id="字扩展法"><a href="#字扩展法" class="headerlink" title="字扩展法"></a>字扩展法</h4><h5 id="线选法"><a href="#线选法" class="headerlink" title="线选法"></a>线选法</h5><ul><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part3/image-20211020131651225.png" alt="image-20211020131651225" style="zoom:80%;"></li><li><strong>n</strong> 条线可提供 <strong>n</strong> 个片选信号</li><li>将 <strong>n</strong> 片 <strong>k×m</strong> 位的存储芯片，集合成 <strong>(n×k)×m</strong> 的芯片</li></ul><h5 id="片选法"><a href="#片选法" class="headerlink" title="片选法"></a>片选法</h5><ul><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part3/image-20211020131755343.png" alt="image-20211020131755343"></li><li><strong>n</strong> 条线可提供 <strong>2^n^</strong> 个片选信号</li><li>将 <strong>n</strong> 片 <strong>k×m</strong> 位的存储芯片，集合成 <strong>(n^2^×k)×m</strong> 的芯片</li><li>要注意译码器的接线，若 A<del>15</del> 无接线，则 A<del>15</del> 取值与地址无关</li></ul><table><thead><tr><th>线选法</th><th>译码片选法</th></tr></thead><tbody><tr><td>n 条线 -&gt; n 个片选信号</td><td>n 条线 -&gt; 2^n^ 个片选信号</td></tr><tr><td>电路简单</td><td>电路复杂</td></tr><tr><td>地址空间不连续</td><td>地址空间连续</td></tr></tbody></table><h4 id="字位扩展法"><a href="#字位扩展法" class="headerlink" title="字位扩展法"></a>字位扩展法</h4><ul><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part3/image-20211020133531141.png" alt="image-20211020133531141"></li><li>同时扩展字位</li></ul><h3 id="译码器知识补充"><a href="#译码器知识补充" class="headerlink" title="译码器知识补充"></a>译码器知识补充</h3><ul><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part3/image-20211020135655208.png" alt="image-20211020135655208" style="zoom:80%;"></li><li>低电平有效还是高电平有效，在译码器与存储芯片之间是相互协调同步的，<strong>都带圈或都不带圈</strong>。带圈则低电平，否则高电平。</li><li>译码器会有<strong>一个或者多个</strong>使能端，带圈则低电平，否则高电平。<ul><li>CPU 可使用译码器的使能端控制片选信号的生效时间</li><li>保证地址的信号稳定之后，再由 MREQ 发出存储器请求信号，然后译码器发出片选信号</li></ul></li><li>RAM的读周期<ul><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part3/image-20211020135621066.png" alt="image-20211020135621066"></li></ul></li></ul><h2 id="双端口-RAM-和多模块存储器"><a href="#双端口-RAM-和多模块存储器" class="headerlink" title="双端口 RAM 和多模块存储器"></a>双端口 RAM 和多模块存储器</h2><h3 id="存取周期"><a href="#存取周期" class="headerlink" title="存取周期"></a>存取周期</h3><ul><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part3/image-20211020140333261.png" alt="image-20211020140333261"></li><li>存取周期：可以连续读/写的最短时间间隔<ul><li><strong>存取周期T = 存取时间r + 恢复时间</strong></li></ul></li><li>DRAM 芯片的恢复时间比较长，有可能是存取时间的几倍（SRAM的恢复时间较短）<ul><li>如：存取时间为 r，存取周期为 T，T=4r</li><li>针对问题：多核CPU都要访存；CPU 读写速度比主存快很多，而主存恢复时间太长</li></ul></li></ul><h3 id="双端口-RAM"><a href="#双端口-RAM" class="headerlink" title="双端口 RAM"></a>双端口 RAM</h3><ul><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part3/image-20211020140651218.png" alt="image-20211020140651218"></li><li>作用：<strong>优化多核 CPU 访问一根内存条的速度</strong></li><li><strong>需要有两组完全独立的数据线、地址线、控制线</strong>。</li><li><strong>CPU、RAM 中控制电路也更复杂</strong>。</li><li>两个端口对同一主存操作有以下 4 种情况：<ol><li>两个端口同时对不同的地址单元存取数据。 </li><li>两个端口同时对同一地址单元读出数据。 </li><li>两个端口同时对同一地址单元写入数据。 （禁止）</li><li>两个端口同时对同一地址单元，一个写入数据，另一个读出数据。（禁止）</li></ol></li><li>置“busy”信号为 0，由判断逻辑决定暂时关闭一个端口（即被延时）</li></ul><h3 id="多模块存储器"><a href="#多模块存储器" class="headerlink" title="多模块存储器"></a>多模块存储器</h3><h4 id="多体并行存储器"><a href="#多体并行存储器" class="headerlink" title="多体并行存储器"></a>多体并行存储器</h4><ul><li><p><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part3/image-20211020151139894.png" alt="image-20211020151139894"></p></li><li><p><strong>高位交叉编址</strong>：<strong>更慢</strong>；<strong>低位交叉编址</strong>：<strong>更快</strong></p></li><li><p>为什么要探讨“连续访问”的情况？诸如数组、程序代码，都是在连续空间中存储的。</p></li><li><p>低位交叉编址</p><ul><li>采用“流水线”的方式并行存取（宏观上并行访问 m 个模块，微观上串行访问 m 个模块）</li><li>宏观上，一个存储周期内，m 体交叉存储器可以提供的数据量为单个模块的 m 倍。</li></ul></li><li><p>应该取多少个存储体？</p><ul><li>存取周期为 T，<strong>存取时间</strong>（<strong>总线传输周期</strong>）为 r，为了使流水线不间断，应保证模块数 <strong>m≥T/r</strong></li><li>存取时间：<strong>存储体的性能瓶颈</strong>。总线传输周期：<strong>将数据传给 CPU 所需要的时间</strong>。<ul><li>虽然意义不同，但<strong>都代表了 CPU 存取一次的时间都不可能低于 r</strong></li></ul></li><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part3/image-20211020151753136.png" alt="image-20211020151753136"></li></ul></li><li><p>通过地址 x，确定为第几个存储体</p><ul><li>通过二进制 体内地址+体号 中的<strong>体号</strong>确定</li><li>通过十进制对地址取余 <strong>x%m</strong></li></ul></li></ul><h4 id="单体多字存储器"><a href="#单体多字存储器" class="headerlink" title="单体多字存储器"></a>单体多字存储器</h4><ul><li>每次并行读出 m 个连续的<strong>字</strong></li><li>总线宽度也要扩展成 m</li><li>速度效率因为是一次读出 m 个字，所以跟多体并行存储器是差不多的<ul><li>但是相比多体并行存储器，单体多字存储器更加不灵活</li></ul></li></ul><h2 id="Cache-的基本概念和原理（高频）"><a href="#Cache-的基本概念和原理（高频）" class="headerlink" title="Cache 的基本概念和原理（高频）"></a>Cache 的基本概念和原理（高频）</h2><h3 id="高速缓冲存储器-Cache"><a href="#高速缓冲存储器-Cache" class="headerlink" title="高速缓冲存储器 Cache"></a>高速缓冲存储器 Cache</h3><ul><li>针对问题：双端口 RAM、多模块存储器<strong>提高存储器的工作速度</strong>，但<strong>与 CPU 差距依然很大</strong></li><li>改进方向：更高速的存储单元 <strong>Cache</strong> 和存储体系的改善“<strong>Cache-主存</strong>”层次</li><li>依据：程序访问的<strong>局部性原理</strong></li><li>Cache 的工作原理：<ul><li><strong>Cache 被集成在CPU内部</strong>，Cache <strong>用 SRAM 实现</strong>，速度快，成本高。</li><li>将可能会被经常用到的代码/数据<strong>复制</strong>一份到 Cache</li></ul></li></ul><h3 id="局部性原理"><a href="#局部性原理" class="headerlink" title="局部性原理"></a>局部性原理</h3><ul><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part3/image-20211020221430934.png" alt="image-20211020221430934"></li><li>空间局部性：在最近的未来要用到的信息(指令和数据)，很可能与现在正在使用的信息在<strong>存储空间</strong>上是邻近的<ul><li>Eg：数组元素、顺序执行的指令代码</li></ul></li><li>时间局部性：在最近的未来要用到的信息，很可能是现在<strong>正在使用的信息</strong><ul><li>Eg：循环结构的指令代码</li></ul></li><li>基于局部性原理，可以把 CPU 目前访问的地址“周围”的部分数据放到 Cache 中</li><li>程序 B 按“列优先”访问二维数组，空间局部性更差，更难利用 Cache 的优势</li></ul><h3 id="性能分析"><a href="#性能分析" class="headerlink" title="性能分析"></a>性能分析</h3><ul><li>设 t<del>c</del> 为访问一次 Cache 所需时间，t<del>m</del> 为访问一次主存所需时间</li><li><strong>命中率</strong> H：CPU 欲访问的信息已在 Cache 中存在的比率</li><li><strong>缺失（未命中）率</strong> M：1 - H</li><li>“Cache—主存”系统的<strong>平均访问时间</strong> t 为：<ul><li>先访问 Cache，若 Cache 未命中再访问主存：t = H * t<del>c</del> + (1 - H) * (t<del>c</del> + t<del>m</del>)</li><li>同时访问 Cache 和主存，若 Cache 命中则立即停止访问主存：t = H * t<del>c</del> + (1 - H) * t<del>m</del> </li></ul></li></ul><h3 id="存储空间分块"><a href="#存储空间分块" class="headerlink" title="存储空间分块"></a>存储空间分块</h3><ul><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part3/image-20211020223722710.png" alt="image-20211020223722710"></li><li>主存与 Cache 之间<strong>以“块”为单位</strong>进行数据交换。</li><li>主存地址可以看作为：<strong>块号 + 块内地址</strong></li><li><strong>操作系统</strong>中，通常将主存中的“一个<strong>块</strong>”也称为“一个<strong>页/页面/页框</strong>”</li><li>Cache 中的“<strong>块</strong>”也称为“<strong>行</strong>” </li><li><strong>每次被访问的主存块，一定会被立即调入 Cache</strong>。</li><li><strong>Cache 的块和主存的块大小相等</strong>。</li></ul><h2 id="Cache-和主存的映射方式"><a href="#Cache-和主存的映射方式" class="headerlink" title="Cache 和主存的映射方式"></a>Cache 和主存的映射方式</h2><h3 id="Cache-中存储的信息"><a href="#Cache-中存储的信息" class="headerlink" title="Cache 中存储的信息"></a>Cache 中存储的信息</h3><ul><li>针对问题：<strong>如何确定 Cache 与主存的数据块对应关系</strong></li><li>Cache 中存储的信息：<strong>有效位（0/1标记是否有效）</strong>+ <strong>标记（来自主存的块号）</strong>+ 块数据</li><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part3/image-20211021090740397.png" alt="image-20211021090740397"></li></ul><h3 id="全相联映射"><a href="#全相联映射" class="headerlink" title="全相联映射"></a>全相联映射</h3><ul><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part3/image-20211021092031684.png" alt="image-20211021092031684"></li><li>映射规则：主存块可以放在 Cache 的<strong>任意位置</strong> </li><li>优点：<strong>Cache 存储空间利用充分，命中率高</strong></li><li>缺点：<strong>查找标记慢，可能要遍历所有行</strong></li><li>CPU 访存：<ul><li>将想要访问的主存地址的<strong>前 22 位</strong>主存块号，对比 Cache 中所有块的<strong>标记</strong>；</li><li>若标记匹配且有效位=1，则 Cache 命中，访问块内地址为 001110 的单元。</li><li>若未命中或有效位=0，则正常访问主存</li></ul></li></ul><h3 id="直接映射"><a href="#直接映射" class="headerlink" title="直接映射"></a>直接映射</h3><ul><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part3/image-20211021093735633.png" alt="image-20211021093735633"></li><li>映射规则：每个主存块只能放到一个特定的位置：<strong>Cache块号 = 主存块号 % Cache总块数</strong> </li><li>优点：对于任意地址<strong>只需要比对一遍标记，速度最快</strong></li><li>缺点：即使其他地方有空闲 Cache 块，但是不一定能使用。存储空间利用不充分，命中率低</li><li>优化标记：<ul><li>若 <strong>Cache总块数=2^n^</strong> 则主存块号末尾 n 位<strong>直接反映它在 Cache 中的位置</strong></li><li>其主存块号的其余位即为标记</li></ul></li><li>CPU 访存：<ul><li>根据主存块号的<strong>后 3 位确定 Cache 行</strong></li><li>若主存块号的<strong>前 19 位与 Cache 标记匹配</strong>且有效位=1，则 Cache 命中，访问块内地址为 001110 的单元。</li><li>若未命中或有效位=0，则正常访问主存</li></ul></li></ul><h3 id="组相连映射"><a href="#组相连映射" class="headerlink" title="组相连映射"></a>组相连映射</h3><ul><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part3/image-20211021094545290.png" alt="image-20211021094545290"></li><li>映射规则：Cache 块分为若干组，每个主存块可放到特定分组中的任意一个位置：<strong>组号 = 主存块号 % 分组数</strong> </li><li>n 路组相联映射——每 n 个Cache 行为一组</li><li>优点：是前两种的折中方式</li><li>CPU 访存：<ul><li>根据主存块号的<strong>后 2 位确定所属分组号</strong></li><li>若主存块号的<strong>前 20 位与分组内的某个标记匹配</strong>且有效位=1， 则 Cache 命中，访问块内地址为 001110 的单元。</li><li>若未命中或有效位=0，则正常访问主存</li></ul></li></ul><h2 id="Cache-替换算法"><a href="#Cache-替换算法" class="headerlink" title="Cache 替换算法"></a>Cache 替换算法</h2><ul><li><p><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part3/image-20211021204805492.png" alt="image-20211021204805492"></p></li><li><p>针对问题：Cache 很小，主存很大。如何替换满 Cache 的块数据</p></li><li><p><strong>抖动现象</strong>：<strong>频繁的换入换出现象（刚被替换的块很快又被调入）</strong></p></li><li><p><strong>随机算法</strong>（<strong>RAND</strong>, Random）—— 若 Cache 已满，则随机选择一块替换。</p><ul><li>评价：：实现简单，但完全没考虑局部性原理，命中率低，实际效果很不稳定</li></ul></li><li><p><strong>先进先出算法</strong>（<strong>FIFO</strong>, First In First Out）—— 若 Cache 已满，则替换最先被调入 Cache 的块</p><ul><li>评价：：实现简单，依然没考虑局部性原理，最先被调入 Cache 的块也有可能是被频繁访问的</li></ul></li><li><p><strong>近期最少使用算法</strong>（<strong>LRU</strong>, Least Recently Used ）—— 为每一个 Cache 块设置一个“<strong>计数器</strong>”，用于记录每个 Cache 块已经有多久没被访问了。当 Cache 满后<strong>替换“计数器”最大的</strong></p><ul><li>机器实现：<ul><li>命中时，<strong>所命中的行的计数器清零</strong>，<strong>比其低的计数器加1，比其高的不变</strong>；</li><li>未命中且还有空闲行时，新装入的行的计数器置0，其余非空闲行全加1；</li><li>未命中且无空闲行时，计数值最大的行的信息块被淘汰，新装行的块的计数器置0，其余全加1。</li></ul></li><li><strong>刷题策略</strong>：当需要确定替换谁时，<strong>在“依次访问主存块”列表向前数 n 位，最后一个即为淘汰项</strong></li><li><strong>Cache 块的总数=2^n^，则计数器只需 n 位</strong>。且 Cache 装满后所有计数器的值一定不重复</li><li>评价：<ul><li>基于“局部性原理”，近期被访问过的主存块，在不久的将来也很有可能被再次访问，因此淘汰最久没被访问过的块是合理的。LRU 算法的<strong>实际运行效果优秀，Cache 命中率高</strong>。</li><li>但若<strong>被频繁访问的主存块数量 &gt; Cache 行的数量</strong>，则有可能发生“抖动”，如：{1,2,3,4,5,1,2,3,4,5,1,2…}</li></ul></li></ul></li><li><p><strong>最不经常使用算法</strong>（<strong>LFU</strong>, Least Frequently Used ）—— 为每一个 Cache 块设置一个“<strong>计数器</strong>”，用于记录每个 Cache 块被访问过几次。当 Cache 满后<strong>替换“计数器”最小的</strong></p><ul><li>若有多个计数器最小的行，可按行号递增、或 FIFO 策略进行选择</li><li>计数器范围可能会很大</li><li>评价：曾经被经常访问的主存块<strong>在未来不一定会用到</strong>（如：微信视频聊天相关的块），并没有很好地遵循局部性原理，因此<strong>实际运行效果不如 LRU</strong></li></ul></li><li><p>最常考察的是近期最少使用算法 LRU，同时也不太会考察计数器，掌握刷题策略即可</p></li></ul><h2 id="Cache-写策略"><a href="#Cache-写策略" class="headerlink" title="Cache 写策略"></a>Cache 写策略</h2><ul><li>针对问题：CPU 修改了 Cache 中的数据副本，如何确保主存中数据母本的一致性？</li><li>读操作不会导致数据不一致性，所以只需要讨论写操作</li></ul><h3 id="写命中"><a href="#写命中" class="headerlink" title="写命中"></a>写命中</h3><h4 id="全写法"><a href="#全写法" class="headerlink" title="全写法"></a>全写法</h4><ul><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part3/image-20211021212957934.png" alt="image-20211021212957934"></li><li>全写法(写直通法，write-through) —— 当CPU对Cache写命中时，必须把数据同时写入 Cache 和主存，一般使用写缓冲(write buffer)</li><li><strong>访存次数增加，速度变慢</strong>，但<strong>更能保证数据一致性</strong>。</li><li>使用写缓冲时：CPU 写的速度很快，若写操作不频繁，则效果很好。若写操作很频繁，可能会因为写缓冲饱和而发生阻塞。</li></ul><h4 id="写回法"><a href="#写回法" class="headerlink" title="写回法"></a>写回法</h4><ul><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part3/image-20211021212704830.png" alt="image-20211021212704830"></li><li>写回法(write-back) —— 当 CPU 对 Cache 写命中时，<strong>只修改 Cache 的内容，而不立即写入主存，只有当此块被换出时才写回主存</strong> </li><li>要新增一个<strong>脏位</strong>，表示是否经过修改</li><li><strong>减少了访存次数</strong>，但<strong>存在数据不一致的隐患</strong>。</li></ul><h3 id="写不命中"><a href="#写不命中" class="headerlink" title="写不命中"></a>写不命中</h3><h4 id="写分配法"><a href="#写分配法" class="headerlink" title="写分配法"></a>写分配法</h4><ul><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part3/image-20211021213711247.png" alt="image-20211021213711247"></li><li>写分配法(write-allocate)——当 CPU 对 Cache 写不命中时，把主存中的块调入 Cache，在 Cache 中修改。<strong>通常搭配写回法使用</strong>。</li></ul><h4 id="非写分配法"><a href="#非写分配法" class="headerlink" title="非写分配法"></a>非写分配法</h4><ul><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part3/image-20211021213515741.png" alt="image-20211021213515741"></li><li>非写分配法(not-write-allocate)——当 CPU 对 Cache <strong>写不命中时</strong>只写入主存，不调入Cache。<strong>搭配全写法使用</strong>。<ul><li>全写法—— 当 CPU 对 Cache <strong>写命中时</strong>，必须把数据同时写入Cache和主存，一般使用写缓冲</li><li>只有“读”未命中时才会调入 Cache</li></ul></li></ul><h3 id="多级-Cache"><a href="#多级-Cache" class="headerlink" title="多级 Cache"></a>多级 Cache</h3><ul><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part3/image-20211021213826421.png" alt="image-20211021213826421"></li><li>各级 Cache 之间常采用“全写法+非写分配法”。保证数据一致性。</li><li>Cache-主存 之间常采用“写回法+写分配法”。减少访存次数。</li></ul><h2 id="页式存储器"><a href="#页式存储器" class="headerlink" title="页式存储器"></a>页式存储器</h2><h3 id="页式存储"><a href="#页式存储" class="headerlink" title="页式存储"></a>页式存储</h3><ul><li>页式存储系统：<ul><li>一个程序(进程)<strong>在逻辑上被分为若干个大小相等的页面</strong>；</li><li><strong>页面大小与块的大小相同</strong>；</li><li><strong>每个页面可以离散地放入不同的主存块中</strong>，从而提高主存的利用率。</li></ul></li><li>CPU 执行的机器指令中，使用的是“逻辑地址”，因此<strong>需要通过“页表”将逻辑地址转为物理地址</strong>。<ul><li>逻辑地址（虚地址）：程序员视角看到的地址<ul><li>逻辑地址= 逻辑页号+页内地址（虚地址=虚页号+页内地址）</li></ul></li><li>物理地址（实地址）：实际在主存中的地址<ul><li>物理地址= 主存块号+页内地址（实地址=实页号+页内地址）</li></ul></li><li>页表的作用：记录了每个逻辑页面存放在哪个主存块中</li><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part3/image-20211021220933259.png" alt="image-20211021220933259"></li></ul></li></ul><h3 id="地址变换过程"><a href="#地址变换过程" class="headerlink" title="地址变换过程"></a>地址变换过程</h3><ul><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part3/image-20211021221504428.png" alt="image-20211021221504428"></li><li>快表是一种“相联存储器”，可以按内容寻访</li><li>快表中存储的是页表项的副本；Cache中存储的是主存块的副本。</li></ul><h2 id="虚拟存储器"><a href="#虚拟存储器" class="headerlink" title="虚拟存储器"></a>虚拟存储器</h2><h3 id="页式虚拟存储器"><a href="#页式虚拟存储器" class="headerlink" title="页式虚拟存储器"></a>页式虚拟存储器</h3><ul><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part3/image-20211021231033684.png" alt="image-20211021231033684"></li><li>有效位：这个页面是否已调入主存</li><li>脏位：这个页面是否被修改过</li><li>引用位：用于“页面置换算法”，比如，可以用来统计这个页面被访问过多少次</li><li>物理页：即主存块号</li><li>磁盘地址：即这个页面的数据在磁盘中的存放位置</li></ul><h3 id="段-页-式虚拟存储器"><a href="#段-页-式虚拟存储器" class="headerlink" title="段(页)式虚拟存储器"></a>段(页)式虚拟存储器</h3><ul><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part3/image-20211021231601239.png" alt="image-20211021231601239"></li><li>页式虚拟存储器——拆分成大小相等的页面</li><li>段式虚拟存储器——按照功能模块拆分。如：#0 段是自己的代码，#1 段是库函数代码，#2 段是变量</li><li>段页式虚拟存储器——把程序按逻辑结构分段，每段再划分为固定大小的页，主存空间也划分为大小相等的页。<ul><li>程序对主存的调入、调出仍以页为基本传送单位。</li><li><strong>每个程序对应一个段表</strong>，每段对应一个页表。</li><li>虚拟地址：段号+段内页号+页内地址</li></ul></li></ul>]]></content>
    
    
    <summary type="html">存储系统</summary>
    
    
    
    <category term="计算机组成原理" scheme="https://nephrencake.gitee.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    
    
  </entry>
  
  <entry>
    <title>计算机组成原理-Part2</title>
    <link href="https://nephrencake.gitee.io/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part2/"/>
    <id>https://nephrencake.gitee.io/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part2/</id>
    <published>2021-10-02T02:53:03.000Z</published>
    <updated>2021-10-26T15:16:36.936Z</updated>
    
    <content type="html"><![CDATA[<h1 id="计算机组成原理-Part2——数据的表示和运算"><a href="#计算机组成原理-Part2——数据的表示和运算" class="headerlink" title="计算机组成原理-Part2——数据的表示和运算"></a>计算机组成原理-Part2——数据的表示和运算</h1><p>[TOC]</p><h2 id="数制与编码"><a href="#数制与编码" class="headerlink" title="数制与编码"></a>数制与编码</h2><h3 id="进位计数制及其相互转换"><a href="#进位计数制及其相互转换" class="headerlink" title="进位计数制及其相互转换"></a>进位计数制及其相互转换</h3><h4 id="r-进制计数法"><a href="#r-进制计数法" class="headerlink" title="r 进制计数法"></a>r 进制计数法</h4><ul><li><strong>基数</strong>：每个数码位所用到的不同符号的个数，r 进制的基数为 r</li><li><strong>位权</strong>：处于第 i 位的权重，值为 r^i^</li><li>每个位上的取值范围：0 ~ r-1</li></ul><h4 id="其他进制-gt-十进制"><a href="#其他进制-gt-十进制" class="headerlink" title="其他进制 -&gt; 十进制"></a>其他进制 -&gt; 十进制</h4><ul><li>r 进制数：K<del>n</del>K<del>n-1</del>……K<del>1</del>K<del>0</del>K<del>-1</del>……K<del>-m</del></li><li>十进制：  K<del>n</del> × r^n^ + K<del>n-1</del> × r^n-1^ + …… + K<del>1</del> × r^1^ + K<del>0</del> × r^0^ + K<del>-1</del> × r^-1^ + …… + K<del>-m</del> × r^m^ </li></ul><table><thead><tr><th>2^12^</th><th>2^11^</th><th>2^10^</th><th>2^9^</th><th>2^8^</th><th>2^7^</th><th>2^6^</th><th>2^5^</th><th>2^4^</th><th>2^3^</th><th>2^2^</th><th>2^1^</th><th>2^0^</th><th>2^-1^</th><th>2^-2^</th><th>2^-3^</th></tr></thead><tbody><tr><td>4096</td><td>2048</td><td>1024</td><td>512</td><td>256</td><td>128</td><td>64</td><td>32</td><td>16</td><td>8</td><td>4</td><td>2</td><td>1</td><td>0.5</td><td>0.25</td><td>0.125</td></tr></tbody></table><h4 id="二、八、十六进制之间相互转换"><a href="#二、八、十六进制之间相互转换" class="headerlink" title="二、八、十六进制之间相互转换"></a>二、八、十六进制之间相互转换</h4><ul><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part2/image-20211003084155324.png" alt="image-20211003084155324"></li><li>各种进制的常见书写方式<ul><li>二进制（Binary）：(1010001010010)<del>2</del>    或    1010001010010B</li><li>八进制：(1652)<del>8</del></li><li>十六进制（hex）：(1652)<del>16</del>    或     1652H    或    0x1652</li><li>十进制（dec）：(1652)<del>10</del>    或    1652D</li></ul></li><li>注意需要补位：整数向前补 0，小数向后补 0。</li></ul><h4 id="十进制-gt-其他进制"><a href="#十进制-gt-其他进制" class="headerlink" title="十进制 -&gt; 其他进制"></a>十进制 -&gt; 其他进制</h4><ul><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part2/image-20211003085557768.png" alt="image-20211003085557768"></li><li>整数部分除法：先除得的余数为低位（靠近0）</li><li>小数部分乘法：先进位的整数为高位（靠近0）</li><li>也可以使用拼凑法：枚举 r 进制数与十进制数的对应表</li><li>有的十进制小数无法使用二进制精确表示，如：0.3</li></ul><h4 id="真值和机器数"><a href="#真值和机器数" class="headerlink" title="真值和机器数"></a>真值和机器数</h4><ul><li><strong>真值</strong>：符合人类习惯的数字</li><li><strong>机器数</strong>：数字实际存到机器里的形式，正负号需要被“数字化”</li></ul><h3 id="BCD码（408大纲已删）"><a href="#BCD码（408大纲已删）" class="headerlink" title="BCD码（408大纲已删）"></a>BCD码（408大纲已删）</h3><ul><li>BCD ：Binary-Coded Decimal，用二进制编码的十进制<ul><li>8421 码（掌握加法）</li><li>余 3 码</li><li>2421 码</li></ul></li><li>针对问题：二进制方便计算机处理、十进制符合人类习惯，但是转换麻烦</li><li>改进方向：快速转换，一一对应</li><li><strong>以 4bit 二进制码表示 0~9</strong>。一共 16 种情况，6 种冗余。</li></ul><h4 id="8421-码"><a href="#8421-码" class="headerlink" title="8421 码"></a>8421 码</h4><ul><li>4 位二进制权值分别为：8 4 2 1</li><li>8421 码是有权码</li><li>8421 码的加法：<strong>先用十进制加法得出结果，再转 8421 码</strong></li><li>8421码中，1010～1111 没有定义</li><li>在机器的视角中，若发现结果<strong>非法定义</strong>（6+7）或<strong>出现进位</strong>（9+9），则需要继续 +6 进行修正。</li></ul><table><thead><tr><th>0</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th><th>7</th><th>8</th><th>9</th></tr></thead><tbody><tr><td>0000</td><td>0001</td><td>0010</td><td>0011</td><td>0100</td><td>0101</td><td>0110</td><td>0111</td><td>1000</td><td>1001</td></tr></tbody></table><h4 id="余-3-码"><a href="#余-3-码" class="headerlink" title="余 3 码"></a>余 3 码</h4><ul><li>余3码：8421码 + (0011)<del>2</del></li><li>余 3 码的每个权位不固定，所以是无权码</li></ul><table><thead><tr><th>0</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th><th>7</th><th>8</th><th>9</th></tr></thead><tbody><tr><td>0011</td><td>0100</td><td>0101</td><td>0110</td><td>0111</td><td>1000</td><td>1001</td><td>1010</td><td>1011</td><td>1100</td></tr></tbody></table><h4 id="2421-码"><a href="#2421-码" class="headerlink" title="2421 码"></a>2421 码</h4><ul><li>4 位二进制权值分别为：2 4 2 1</li><li>0<del>4 首位必须是 0，5</del>9 首位必须是 1</li></ul><table><thead><tr><th>0</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th><th>7</th><th>8</th><th>9</th></tr></thead><tbody><tr><td>0000</td><td>0001</td><td>0010</td><td>0011</td><td>0100</td><td>1011</td><td>1100</td><td>1101</td><td>1110</td><td>1111</td></tr></tbody></table><h3 id="字符与字符串"><a href="#字符与字符串" class="headerlink" title="字符与字符串"></a>字符与字符串</h3><h4 id="ASCII-码"><a href="#ASCII-码" class="headerlink" title="ASCII 码"></a>ASCII 码</h4><ul><li>键盘共 128 个字符，可以用 7 位二进制编码。<ul><li>为了存入计算机，通常在最高位补 0，凑足1B</li></ul></li><li>可印刷字符：32～126，其余为控制（如：127 DEL）、通信（如：6 ACK）字符</li><li>数字 0~9：<strong>48</strong>(0011 0000)～<strong>57</strong>(0011 1001)<ul><li>数字的 ASCII 码的<strong>前四位是 0011，后四位是 8421 码</strong></li></ul></li><li>大写字母 A~Z：<strong>65</strong>(0100 0001)～<strong>90</strong>(0101 1010)<ul><li>大写字母 ASCII 码<strong>前三位都是 010，后五位是 1~26</strong></li></ul></li><li>小写字母 a~z：<strong>97</strong>(0110 0001)～<strong>122</strong>(0111 1010)<ul><li>小写字母 ASCII 码<strong>前三位都是 011，后五位是 1~26</strong></li></ul></li><li>所有数字、大写字母、小写字母的编码都是连续的</li></ul><blockquote><p>求解某字符 ASCII 码时，要充分利用上述规律，避免十进制、二进制转换。</p></blockquote><h4 id="汉字的表示和编码"><a href="#汉字的表示和编码" class="headerlink" title="汉字的表示和编码"></a>汉字的表示和编码</h4><ul><li>GB 2312-100（19100年）：汉字+各种符号共7445个</li><li><strong>区位码：94 个区，每区 94 个位置</strong>。相当于把所有汉字存放在了 94*94 的方阵中，通过两个字节长度来定位汉字</li><li><strong>国标码：区位码 + 20H</strong>。防止信息交换时与“控制/通信字符”冲突</li><li><strong>汉字(机)内码：国标码 + 100H</strong>。保证高位为1，与ASCII码区分</li><li>输入法 -&gt; 国标码 -&gt; 汉字内码 -&gt;  (国标码 -&gt; )汉字字形码（像素方阵）</li></ul><h4 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h4><ul><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part2/image-20211003101235176.png" alt="image-20211003101235176"></li><li><strong>按字节编址：每个地址对应 1B/1字节（存储单元大小为 1B/8b）</strong></li><li>很多语言中，“\0”作为字符串结尾标志</li><li>在所有计算机中，多字节数据都被存放在连续的字节序列中。根据数据中各字节的排列顺序不同，可能有“大端模式”、“小端模式”<ul><li>大端模式：将数据的<strong>最高有效字节存放在低地址单元</strong>中（低位到高位顺序读取）</li><li>小端模式：将数据的<strong>最高有效字节存放在高地址单元</strong>中（遇到多字节数据需要倒着读）</li></ul></li></ul><h3 id="奇偶校验码（计网要考）"><a href="#奇偶校验码（计网要考）" class="headerlink" title="奇偶校验码（计网要考）"></a>奇偶校验码（计网要考）</h3><h4 id="校验原理"><a href="#校验原理" class="headerlink" title="校验原理"></a>校验原理</h4><ul><li>位错误：在 bit 位上发生的突变。0 变 1，1 变 0</li><li><strong>码字</strong>：由若干位代码组成的一个字</li><li><strong>两个码字间的距离</strong>：将两个码字逐位进行对比，<strong>具有不同的位的个数</strong></li><li><strong>码距</strong>：一种编码方案中，合法码字之间的最小距离。<strong>最少变动多少位可以在各合法码字之间转换</strong></li><li>当 d=1 时，无检错能力；当 d=2 时，有检错能力；当 d≥3 时，若设计合理，可能具有检错、纠错能力</li></ul><h4 id="奇偶校验码"><a href="#奇偶校验码" class="headerlink" title="奇偶校验码"></a>奇偶校验码</h4><ul><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part2/image-20211004142023267.png" alt="image-20211004142023267" style="zoom:100%;"></li><li><strong>奇校验码</strong>：在有效信息位之外添加一位校验位，使得整个校验码中“1”的个数为<strong>奇数</strong>。</li><li><strong>偶校验码</strong>：在有效信息位之外添加一位校验位，使得整个校验码中“1”的个数为<strong>偶数</strong>。</li><li>本质：如果出现<strong>奇数次的位错误，则可以检测出错误</strong>；如果出现<strong>偶数次位错误，则检不出错误</strong>。</li><li><strong>偶校验的硬件实现</strong>：取各位的信息依次进行异或（模2加）运算，得到的结果即为偶校验位。<ul><li>进行偶校验且结果为 0 时，则通过校验。</li><li>进行奇校验且结果为 1 时，则通过校验。</li></ul></li><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part2/image-20211004143356036.png" alt="image-20211004143356036" style="zoom:100%;"></li></ul><h3 id="海明校验码（计网要考）"><a href="#海明校验码（计网要考）" class="headerlink" title="海明校验码（计网要考）"></a>海明校验码（计网要考）</h3><h4 id="基本思想"><a href="#基本思想" class="headerlink" title="基本思想"></a>基本思想</h4><ul><li>针对问题：偶校验只能发现<strong>奇数位错误</strong>，且<strong>无法确定出错位置</strong>，想要获得正确信息则必须重新传输信息。</li><li>改进方向：将信息位分组进行偶校验 —&gt; 多个校验位 —&gt; 多个校验位标注出错位置<ul><li>1 个校验位之只能携带 2 种状态信息（对/错）</li><li>多个校验位能携带多种状态信息（对/错，错在哪）</li></ul></li><li>信息位 n 位 + 校验位 k 位 = 共 n+k 位<ul><li>k 位校验位代表最多能表示 2^k^ 种状态</li><li>校验位表示的状态应该要考虑到 n+k 的任何一位都有可能出错</li><li>重要公式：<strong>2^k^ ≥ n + k + 1</strong></li></ul></li><li>本质：分 k 组偶校验</li></ul><h4 id="海明码求解步骤（TODO）"><a href="#海明码求解步骤（TODO）" class="headerlink" title="海明码求解步骤（TODO）"></a>海明码求解步骤（TODO）</h4><p>Eg：信息位为 1010，求解海明码。</p><ol><li><p>确定海明码的位数：</p><ul><li>2^k^ ≥ n + k + 1</li><li>n=4 =&gt; k=3</li></ul></li><li><p>确定校验位的分布：</p><ul><li><p>设信息位 D<del>4</del>D<del>3</del>D<del>2</del>D<del>1</del>（1010），共4位；校验位 P<del>3</del>P<del>2</del>P<del>1</del>，共3位；对应的海明码为 H<del>7</del>H<del>6</del>H<del>5</del>H<del>4</del>H<del>3</del>H<del>2</del>H<del>1</del></p></li><li><p><strong>校验位 P<del>i</del> 放在海明位号为 2^i−1^ 的位置上</strong></p></li><li><p>校验位 P<del>i</del> 与位置序号第 i 位为 1 的信息位归为同一组，进行偶校验</p></li><li><table><thead><tr><th>H<del>7</del></th><th>H<del>6</del></th><th>H<del>5</del></th><th>H<del>4</del></th><th>H<del>3</del></th><th>H<del>2</del></th><th>H<del>1</del></th></tr></thead><tbody><tr><td>D<del>4</del></td><td>D<del>3</del></td><td>D<del>2</del></td><td>P<del>3</del></td><td>D<del>1</del></td><td>P<del>2</del></td><td>P<del>1</del></td></tr><tr><td>1</td><td>0</td><td>1</td><td>0</td><td>0</td><td>1</td><td>0</td></tr></tbody></table></li></ul></li><li><p>求校验位的值：</p><ul><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part2/image-20211004151532962.png" alt="image-20211004151532962" style="zoom:100%;"></li><li>将海明码信息位的下标转二进制矩阵，一列为一组，对应 1 的信息拿出来做偶校验，结果就是海明码校验位的值。</li></ul></li><li><p>纠错：</p><ul><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part2/image-20211004154938467.png" alt="image-20211004154938467" style="zoom:100%;"></li><li>题目的下标顺序不影响做题（TODO）</li></ul></li></ol><h4 id="海明码的检错、纠错能力"><a href="#海明码的检错、纠错能力" class="headerlink" title="海明码的检错、纠错能力"></a>海明码的检错、纠错能力</h4><ul><li>海明码的检错、纠错能力：<ul><li>纠错能力：1位（无法区分到底是 1 位错还是 2 位错）</li><li>检错能力：2位</li></ul></li><li>为了区分是 1 位错误还是 2 位错误，需加上“全校验位”，对整体进行偶校验。</li><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part2/image-20211004155557262.png" alt="image-20211004155557262"></li></ul><h3 id="循环冗余校验码（计网要考）"><a href="#循环冗余校验码（计网要考）" class="headerlink" title="循环冗余校验码（计网要考）"></a>循环冗余校验码（计网要考）</h3><h4 id="基本思想-1"><a href="#基本思想-1" class="headerlink" title="基本思想"></a>基本思想</h4><ul><li>循环冗余校验（Cyclic Redundancy Check，CRC）</li><li>数据发送、接受方<strong>共同约定一个“除数”</strong></li><li>K个信息位+R个校验位 作为“被除数”，<strong>添加校验位以保证除法的余数为 0</strong><ul><li>收到数据后，进行除法检查余数是否为0</li><li>若余数非 0 说明出错，则进行重传或纠错</li></ul></li></ul><h4 id="构造、检错、纠错"><a href="#构造、检错、纠错" class="headerlink" title="构造、检错、纠错"></a>构造、检错、纠错</h4><ul><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part2/image-20211004164514722.png" alt="image-20211004164514722" style="zoom:100%;"></li><li>流程：<ol><li>题目给出生成多项式、信息码</li><li>K = 信息码的长度 = 6，R = 生成多项式最高次幂 = 3 =&gt; 校验码位数 N = K + R = 9</li><li>信息码左移 R 位，低位补 0。利用生成多项式系数进行模2除法，得余数为校验码。</li><li>将接受到的码字用生成多项式进行模2除法，余数为000则代表没有出错，否则不然。</li></ol></li><li>循环冗余校验码的检错、纠错特性：<ul><li>可检测出所有奇数个错误</li><li>可检测出所有双比特的错误</li><li>可检测出所有小于等于校验位长度的连续错误</li><li>对于确定的生成多项式，出错位与余数是相对应的</li><li>当码字长度超出检错码可表示的能力时，出错位与余数的对应关系将进行循环</li><li>K个信息位，R个校验位，若生成多项式选择得当，且 2^R^≥K+R+1，则 CRC 码可纠正1位错</li></ul></li></ul><h2 id="定点数的表示与运算"><a href="#定点数的表示与运算" class="headerlink" title="定点数的表示与运算"></a>定点数的表示与运算</h2><blockquote><ul><li>定点数：小数点的位置固定（定点数也包含小数）<ul><li>常规计数</li><li>Eg：996.007</li></ul></li><li>浮点数：小数点的位置不固定<ul><li>科学计数法</li><li>Eg：9.96007*102</li></ul></li></ul></blockquote><h3 id="定点数的表示"><a href="#定点数的表示" class="headerlink" title="定点数的表示"></a>定点数的表示</h3><h4 id="无符号数的定点表示"><a href="#无符号数的定点表示" class="headerlink" title="无符号数的定点表示"></a>无符号数的定点表示</h4><ul><li>无符号数：<strong>整个机器字长的全部二进制位均为数值位</strong>，没有符号位，相当于数的绝对值。</li><li>通常只有无符号整数，而没有无符号小数（unsigned int/long）</li><li>表示范围：<strong>n 位 bit 的无符号数表示范围为：0 ～ 2n-1</strong><ul><li>Eg：8位二进制数： 2^8^ 种不同的状态，表示 0000 0000 ～ 1111 1111，即 0 ~ 255</li></ul></li></ul><h4 id="有符号数的定点表示"><a href="#有符号数的定点表示" class="headerlink" title="有符号数的定点表示"></a>有符号数的定点表示</h4><ul><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part2/image-20211007120237263.png" alt="image-20211007120237263" style="zoom:100%;"></li><li>可用 <strong>原码、反码、补码</strong> 三种方式来表示定点整数和定点小数。还可用 <strong>移码</strong> 表示定点整数。</li><li>若真值为 x，则用 <strong>[x]原、[x]反、[x]补、[x]移</strong> 分别表示真值所对应的原码、反码、补码、移码</li><li>若机器字长为 n+1 位，则符号位占 1 位，尾数占 n 位</li><li>表示定点整数，默认小数点隐含在尾数后；表示定点小数，默认小数点隐含在符号位后尾数前。</li></ul><h5 id="原码表示定点整数和定点小数"><a href="#原码表示定点整数和定点小数" class="headerlink" title="原码表示定点整数和定点小数"></a>原码表示定点整数和定点小数</h5><ul><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part2/image-20211007121910742.png" alt="image-20211007121910742" style="zoom:100%;"></li><li>未指明机器字长时，整数尾数前端的 0 可略去，小数尾数后端的 0 可略去。</li><li>要注意<strong>第一位是符号位</strong>，切不能当成数值。</li><li>整数原码常用 <strong>逗号</strong> 分割符号位和尾数，小数原码常用 <strong>小数点</strong> 分割符号位和尾数。</li><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part2/image-20211007123125347.png" alt="image-20211007123125347" style="zoom:100%;"></li><li>在整数和小数的原码表示中，<strong>真值 0 有 +0 和 -0 两种形式</strong>，即两种二进制状态对应了同一种真值。<ul><li>因此即使机器字长为 n+1 位，理论上能够表示 2^n+1^ 种情况，但实际上值表示了 <strong>2^n+1^-1</strong> 种。</li></ul></li><li>原码整数表示范围：**-(2^n^-1)≤x≤2^n^-1<strong>；源码小数表示范围：</strong>-(1-2^n^)≤x≤1-2^n^**。</li></ul><h5 id="反码表示定点整数和定点小数"><a href="#反码表示定点整数和定点小数" class="headerlink" title="反码表示定点整数和定点小数"></a>反码表示定点整数和定点小数</h5><ul><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part2/image-20211007124524338.png" alt="image-20211007124524338" style="zoom:100%;"></li><li>反码：<strong>若符号位为0，则反码与原码相同；若符号位为1，则数值位全部取反。</strong></li><li>表示范围和源码相同。</li></ul><blockquote><p>“反码”只是“原码”转变为“补码”的一个中间状态，实际中并没什么卵用——并没有解决“真值 0 有 +0 和 -0 两种形式”这个问题。</p></blockquote><h5 id="补码表示定点整数和定点小数"><a href="#补码表示定点整数和定点小数" class="headerlink" title="补码表示定点整数和定点小数"></a>补码表示定点整数和定点小数</h5><ul><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part2/image-20211007131951644.png" alt="image-20211007131951644" style="zoom:100%;"></li><li>补码：正数的补码=原码；负数的补码=反码末位+1（要考虑进位）</li><li>补码的真值 0 只有一种表示形式：[+0]补= [-0]补= 00000000<ul><li>定点整数<ul><li>[-2^7^]补 = **1,**0000000</li><li>表示范围：−2^n^ ≤ x ≤ 2^n^−1</li></ul></li><li>定点小数<ul><li>[-1]补 = **1.**0000000 </li><li>表示范围：-1 ≤ x ≤ 1-2^-n^</li></ul></li></ul></li><li><strong>由 [x]补 快速求 [-x]补 的方法：符号位、数值位全部取反，末位+1</strong></li></ul><h5 id="移码表示定点整数"><a href="#移码表示定点整数" class="headerlink" title="移码表示定点整数"></a>移码表示定点整数</h5><ul><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part2/image-20211007143059138.png" alt="image-20211007143059138" style="zoom:100%;"></li><li>移码：<strong>补码的基础上将符号位取反</strong>。注意：<strong>移码只能用于表示整数</strong>。</li><li>移码表示的整数很方便对比大小</li><li>在浮点数中将大量是使用源码</li></ul><h3 id="原码补码移码的作用"><a href="#原码补码移码的作用" class="headerlink" title="原码补码移码的作用"></a>原码补码移码的作用</h3><ul><li>无符号数：可以进行直接加减运算。</li><li>原码的加减运算：需要将符号位单独区分，但是这样将增加硬件成本、计算复杂度。<ul><li>因此需要用加法运算来代替减法运算 =&gt; 将减法操作转换成取模运算（例如：-3mod12=9）</li></ul></li><li>补码的本质：为了能够进行直接加运算，将系统设计成了循环。</li><li>反码的本质：将原码的负数部分进行了反转，是补码能够循环的铺垫。</li><li>移码的本质：使用偏置将补码的循环提前了半个周期。</li></ul><table><thead><tr><th>二进制机器数</th><th>二进制表示无符号数</th><th>二进制表示原码</th><th>二进制表示反码</th><th>二进制表示补码</th><th>二进制表示移码</th></tr></thead><tbody><tr><td>0000 0000</td><td><strong>0</strong></td><td><strong>+0</strong></td><td><strong>+0</strong></td><td><strong>±0</strong></td><td>-128</td></tr><tr><td>0000 0001</td><td>1</td><td>1</td><td>1</td><td>1</td><td>-127</td></tr><tr><td>……</td><td>……</td><td>……</td><td>……</td><td>……</td><td>……</td></tr><tr><td>0111 1111</td><td>127</td><td>127</td><td>127</td><td>127</td><td>-1</td></tr><tr><td>1000 0000</td><td>128</td><td><strong>-0</strong></td><td>-127</td><td>-128</td><td><strong>±0</strong></td></tr><tr><td>1000 0001</td><td>129</td><td>-1</td><td>-126</td><td>-127</td><td>1</td></tr><tr><td>……</td><td>……</td><td>……</td><td>……</td><td>……</td><td>……</td></tr><tr><td>1111 1111</td><td>255</td><td>-127</td><td><strong>-0</strong></td><td>-1</td><td>127</td></tr></tbody></table><ul><li>带余除法——设 x, m∈Z, m&gt;0 则存在唯一决定的整数 q 和 r，使得：x = q*m + r , 0 ≤ r &lt; m <ul><li>(mod 12) 把所有整数分为 12 类（余数为 0~11）</li><li>(mod 12) 余数相同的数，都是同一类，都是等价的</li><li>在 (mod m) 的条件下，若能<strong>找到负数的补数</strong>，就可以<strong>用正数的加法来等价替代减法</strong><ul><li>若二个数绝对值之和=模，则称这两个数互为补数</li></ul></li><li><strong>模 - a的绝对值 = a的补数</strong></li><li>↑ 这是补码的原生定义</li></ul></li><li>反码 + 原码 + 1 = 模</li><li>补码的作用： 使用补码可将减法操作转变为等价的加法，ALU 中无需集成减法器。执行加法操作时，符号位一起参与运算。</li></ul><h3 id="移位运算"><a href="#移位运算" class="headerlink" title="移位运算"></a>移位运算</h3><h4 id="算数移位"><a href="#算数移位" class="headerlink" title="算数移位"></a>算数移位</h4><ul><li><p>移位：通过改变各个数码位和小数点的相对位置，从而改变各数码位的位权。可用移位运算实现乘法、除法</p></li><li><p>原码的算数移位——<strong>符号位保持不变，仅对数值位进行移位</strong>。</p><ul><li>右移：高位补0，低位舍弃。若舍弃的位=0，<strong>则相当于÷2</strong>；若舍弃的位≠0，则会丢失<strong>精度</strong></li><li>左移：低位补0，高位舍弃。若舍弃的位=0，<strong>则相当于×2</strong>；若舍弃的位≠0，则会出现<strong>严重误差</strong></li></ul></li><li><p>反码的算数移位</p><ul><li>正数的反码与原码相同，因此对正数反码的移位运算也和原码相同。<ul><li>右移：<strong>高位补0</strong>，低位舍弃。</li><li>左移：<strong>低位补0</strong>，高位舍弃。</li></ul></li><li>负数的反码数值位与原码相反，因此负数反码的移位在补位上有所变化。<ul><li>右移：<strong>高位补1</strong>，低位舍弃。</li><li>左移：<strong>低位补1</strong>，高位舍弃。</li></ul></li></ul></li><li><p>补码的算数移位</p><ul><li>正数的补码与原码相同，因此对正数补码的移位运算也和原码相同。<ul><li>右移：<strong>高位补0</strong>，低位舍弃。</li><li>左移：<strong>低位补0</strong>，高位舍弃。</li></ul></li><li>负数补码=反码末位+1，导致反码最右边几个连续的1都因进位而变为0，直到进位碰到第一个0为止。<ul><li>负数补码中：最右边的1及其右边同原码；最右边的1的左边同反码负数补码。</li><li>右移（同反码）：<strong>高位补1</strong>，低位舍弃。</li><li>左移（同原码）：<strong>低位补0</strong>，高位舍弃。</li></ul></li></ul></li><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part2/image-20211008121454539.png" alt="image-20211008121454539" style="zoom:100%;"></li><li><p>Eg：-20×7 = -20×(2^0^+2^1^+2^2^) = (-20左移0位) + (-20左移1位) + (-20左移2位)</p></li></ul><h4 id="逻辑移位"><a href="#逻辑移位" class="headerlink" title="逻辑移位"></a>逻辑移位</h4><ul><li>逻辑右移：高位补0，低位舍弃。</li><li>逻辑左移：低位补0，高位舍弃。</li><li>可以把逻辑移位看作是对“无符号数”的算数移位</li><li>Eg：<img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part2/image-20211008122429002.png" alt="image-20211008122429002" style="zoom:100%;"></li></ul><h4 id="循环移位"><a href="#循环移位" class="headerlink" title="循环移位"></a>循环移位</h4><ul><li>不带进位位：用<strong>移出的位补上空缺</strong></li><li>带进位位：用<strong>进位位的值补上空缺</strong>，而<strong>移出的位放到进位位</strong></li><li>Eg：交换高低位字节时常用（大端存储&lt;=&gt;小端存储）</li></ul><h3 id="加减运算和溢出判断"><a href="#加减运算和溢出判断" class="headerlink" title="加减运算和溢出判断"></a>加减运算和溢出判断</h3><h4 id="原码的加减法"><a href="#原码的加减法" class="headerlink" title="原码的加减法"></a>原码的加减法</h4><ul><li>要考虑 2*2 种情况，并且同时实现加法器和减法器</li><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part2/image-20211008124354552.png" alt="image-20211008124354552"></li></ul><h4 id="补码的加减法"><a href="#补码的加减法" class="headerlink" title="补码的加减法"></a>补码的加减法</h4><ul><li><p>负数的补码转原码：</p><ul><li>数值位取反，+1</li><li>-1，数值位取反</li><li>负数补码中，最右边的1及其右边同原码，最右边的1的左边同反码</li></ul></li><li><p>[(负数)]补 &lt;=&gt; [(负数)]原：<strong>取负数补码最右边的一位1，其本身与其右侧不变，左侧数值位全部取反</strong>。（常用）</p></li><li><p>[x]补 =&gt; [-x]补：<strong>连同符号位一起取反加1</strong>。</p></li></ul><h4 id="溢出判断"><a href="#溢出判断" class="headerlink" title="溢出判断"></a>溢出判断</h4><ul><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part2/image-20211008151859101.png" alt="image-20211008151859101"></li><li>溢出情况：<ul><li>只有“正数+正数 ”才会上溢 —— 正+正=负</li><li>只有“负数+负数 ”才会下溢 —— 负+负=正</li></ul></li><li>判断方法：<ul><li>法一：采用一位符号位设 A 的符号为 A<del>S</del>，B 的符号为 B<del>S</del>，运算结果的符号为 S<del>S</del>，则溢出逻辑表达式为：<ul><li>$V = A_{s}B_{s}\overline{S_{s}} + \overline{A_{s}}\overline{B_{s}}S_{s}$</li><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part2/image-20211008163931615.png" alt="image-20211008163931615" style="zoom:100%;"></li><li>若 V=0，表示无溢出；若 V=1，表示有溢出。</li><li><strong>A<del>S</del> 为 1 且 B<del>S</del> 为 1 且 S<del>S</del> 为 0</strong> 或 <strong>A<del>S</del> 为 0 且 B<del>S</del> 为 0 且 S<del>S</del> 为 1</strong>。</li></ul></li><li>法二：采用一位符号位，根据数据位进位情况判断溢出符号位的进位 C<del>S</del>，最高数值位的进位 C<del>1</del><ul><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part2/image-20211008163814192.png" alt="image-20211008163814192" style="zoom:100%;"></li><li>$V=C_{S}⊕ C_{1}$</li><li>若 V=0，表示无溢出；若 V=1，表示有溢出。</li><li><strong>最高数值位进位且符号位不进位</strong> 或 <strong>符号位进位而最高数值位不进位</strong>。</li></ul></li><li>法三：<ul><li>采用双符号位：正数符号为 00，负数符号为 11</li><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part2/image-20211008163848872.png" alt="image-20211008163848872" style="zoom:100%;"></li><li>记两个符号位为 S<del>S1</del>S<del>S2</del> ，则 $V=S_{S1}\otimes S_{S2}$。若 V=0，表示无溢出；若 V=1，表示有溢出。</li><li><strong>第一个符号位表明应该得到的符号，第二个符号位表明实际得到的符号。</strong></li><li>双符号位补码又称：模 4 补码；单符号位补码又称：模 2 补码。</li><li>实际存储时只存储一个符号位，运算时会复制一个符号位</li></ul></li></ul></li><li>同+同=异  =&gt;  发生溢出</li></ul><h4 id="符号扩展"><a href="#符号扩展" class="headerlink" title="符号扩展"></a>符号扩展</h4><ul><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part2/image-20211008164330993.png" alt="image-20211008164330993" style="zoom:100%;"></li><li>定点整数的符号扩展：在原符号位和数值位<strong>中间</strong>添加新位，正数都添0；负数<strong>原码添0，反码、补码添1</strong></li><li>定点小数的符号扩展：在原符号位和数值位<strong>后面</strong>添加新位，正数都添0；负数<strong>原码、补码添0，反码添1</strong></li></ul><h3 id="乘法运算"><a href="#乘法运算" class="headerlink" title="乘法运算"></a>乘法运算</h3><h4 id="乘法运算的实现思想"><a href="#乘法运算的实现思想" class="headerlink" title="乘法运算的实现思想"></a>乘法运算的实现思想</h4><ul><li>用移位实现乘数累加</li><li>Eg：0.1101×0.1011 = (1101×1×2^-8^ ) + (1101×1×2^-7^) + (1101×0×2^-6^) + (1101×1×2^-5^)</li></ul><h4 id="原码的一位乘法"><a href="#原码的一位乘法" class="headerlink" title="原码的一位乘法"></a>原码的一位乘法</h4><ul><li><strong>符号单独处理</strong>：符号位 = x<del>s</del>⊕y<del>s</del></li><li><strong>数值位取绝对值进行乘法</strong>计算</li><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part2/image-20211009130101904.png" alt="image-20211009130101904" style="zoom:100%;"></li><li>在机器实现乘法中：<ul><li>ACC 存放<strong>乘积高位</strong>，MQ 存放<strong>乘数与乘积低位</strong>，X 存放<strong>被乘数</strong></li><li>在正式进行乘法之前，<strong>ACC 置零</strong></li><li>先将 X 中被乘数与 MQ 最低位的乘积结果<strong>加到 ACC 中</strong></li><li>再将 ACC、MQ 整体<strong>逻辑右移</strong>一位<ul><li>逻辑右移，高位补零</li><li>ACC 的低位移到 MQ 的高位</li><li>MQ 的低位用完之后直接丢弃</li><li>此时，AC、MQ 中运算得到的位上的结果称作<strong>部分积</strong></li></ul></li><li>数值位一共 n 位，则<strong>循环 n 次</strong><ul><li>乘数的符号位不用参与运算。ACC+MQ 是一个整体，而 MQ 由取绝对值，所以最多只有 4 为有效，原本的符号位不会对结果造成影响。</li><li>小数点隐含位置在 ACC 的第二位</li></ul></li><li><strong>修改 ACC 的符号位</strong>：x<del>s</del>⊕y<del>s</del>=1</li></ul></li><li>之所以称为“一位乘法”是因为每次都使用 MQ 的最后一位进行乘积相加，还有更快的“二位乘法”但不做要求。</li><li>Tips：<ul><li>乘数的符号位不参与运算，可以省略</li><li>原码一位乘可以只用单符号位，也可以用双符号位</li><li>答题时最终结果最好写为原码机器数</li></ul></li></ul><h4 id="补码的一位乘法（Booth算法）"><a href="#补码的一位乘法（Booth算法）" class="headerlink" title="补码的一位乘法（Booth算法）"></a>补码的一位乘法（Booth算法）</h4><ul><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part2/image-20211009134039359.png" alt="image-20211009134039359" style="zoom:100%;"></li><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part2/image-20211009143142389.png" alt="image-20211009143142389" style="zoom:100%;"></li><li>机器实现补码乘法时：<ul><li>MQ 相比原码乘法需要在最低位后面加一位辅助位。同时 CPU 中寄存器大小应当一致，所以<ul><li>ACC、X 使用<strong>双符号位</strong>，MQ 使用<strong>单符号位以及一位辅助位</strong>，部分积也是使用<strong>双符号位</strong></li></ul></li><li>与原码乘法不同，每次加法是：<code>ACC + [(辅助位-MQ最低位)x]补</code></li><li>与原码乘法不同，每次移位是：<strong>补码的算数移位</strong><ul><li>符号位不动，数值位右移，正数右移补0，负数右移补1（符号位是啥就补啥）</li></ul></li><li>加法与移位的循环分别是 n+1 和 n 次，即<strong>乘数的单符号位也会参与计算</strong></li><li>与原码乘法不同，最后的符号确定已在计算过程中完成，无需再次校验。</li></ul></li></ul><h3 id="除法运算"><a href="#除法运算" class="headerlink" title="除法运算"></a>除法运算</h3><h4 id="除法运算的实现思想"><a href="#除法运算的实现思想" class="headerlink" title="除法运算的实现思想"></a>除法运算的实现思想</h4><ul><li>被除数、余数本质相同，是我们还需要去拼凑的数</li><li>商是我们尽可能去接近需要拼凑的数但不能超过</li></ul><h4 id="原码的除法运算"><a href="#原码的除法运算" class="headerlink" title="原码的除法运算"></a>原码的除法运算</h4><h5 id="恢复余数法"><a href="#恢复余数法" class="headerlink" title="恢复余数法"></a>恢复余数法</h5><ul><li>ACC 放被除数和余数，MQ 放商，X 放除数</li><li><strong>符号单独处理</strong>：符号位 = x<del>s</del>⊕y<del>s</del></li><li><strong>数值位取绝对值进行除法</strong>计算</li><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part2/image-20211011153443169.png" alt="image-20211011153443169" style="zoom:100%;"></li><li>在机器实现除法中：<ul><li>在正式进行乘法之前，<strong>MQ 置零</strong></li><li>首先<strong>默认商/MQ最低位为 1</strong>，将除数的相反数的补码与被除数/余数（ ACC ）相加（将 ACC 减去除数）<ul><li>(ACC)+ [−|y|]补 -&gt; ACC</li><li><strong>若相减之后余数符号位为 1</strong>（小于 0），则表明商不应该为 1，而是 0</li><li><strong>则将 ACC 的值再次加上除数</strong>，恢复成原样</li><li>并<strong>将商改成 0</strong></li><li>若最后一步余数是负数，则一样要进行上面的纠正</li></ul></li><li>ACC、MQ 整体逻辑左移<ul><li>MQ 低位补零</li><li>ACC 高位丢弃</li></ul></li><li>机器字长有 n+1 位，就要算 n+1 位的商，左移 n 次</li><li><strong>修改 MQ 的符号位</strong>：x<del>s</del>⊕y<del>s</del>=0</li></ul></li></ul><h5 id="不恢复余数法（加减交替法）"><a href="#不恢复余数法（加减交替法）" class="headerlink" title="不恢复余数法（加减交替法）"></a>不恢复余数法（加减交替法）</h5><ul><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part2/image-20211011155159488.png" alt="image-20211011155159488" style="zoom:100%;"></li><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part2/image-20211011154706460.png" alt="image-20211011154706460" style="zoom:100%;"></li><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part2/image-20211011155635905.png" alt="image-20211011155635905" style="zoom:100%;"></li><li>当余数（ACC）为负时，商 0<ul><li>恢复余数法：+|除数（X）|，再左移，再-|除数（X）|</li><li>加减交替法：左移，再+|除数（X）|</li></ul></li><li>在加减交替法中<ul><li>余数（ACC）的正负性与商相同</li><li>符号位同样需要额外判定</li><li>若最后的余数（ACC）为负，需商0，并+[|y|]补得到正确余数</li></ul></li></ul><h4 id="补码的除法运算（加减交替法）"><a href="#补码的除法运算（加减交替法）" class="headerlink" title="补码的除法运算（加减交替法）"></a>补码的除法运算（加减交替法）</h4><ul><li>符号位参与运算</li><li>被除数/余数、除数采用双符号位</li><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part2/image-20211014133724204.png" alt="image-20211014133724204" style="zoom:100%;"></li><li>第一步，比较<strong>被除数</strong>（ACC）和除数（X）符号<ul><li>同号，则被除数-除数</li><li>异号，则被除数+除数</li></ul></li><li>然后，比较<strong>余数</strong>（ACC）和除数（X）符号（每次循环保证两者相加符号不同，结果与被除）<ul><li>同号，<strong>商1</strong>，余数左移，减去除数</li><li>异号，<strong>商0</strong>，余数左移，加上除数</li></ul></li><li>重复 n 次</li><li>MQ 的最后一位恒置 1（精度误差不超过 2^-n^）</li></ul><h4 id="除法运算总结"><a href="#除法运算总结" class="headerlink" title="除法运算总结"></a>除法运算总结</h4><table><thead><tr><th>除法类型</th><th>符号位参与运算</th><th>加减次数</th><th>移位方向</th><th>移位次数</th><th>上商、加减原则</th><th>说明</th></tr></thead><tbody><tr><td>原码加减交替法</td><td>否</td><td>N+1 或 N+2</td><td>左</td><td>N</td><td>余数的正负</td><td>若最终余数为负，则恢复余数</td></tr><tr><td>补码加减交替法</td><td>是</td><td>N+1</td><td>左</td><td>N</td><td>余数和除数是否同号</td><td>商末位恒置 1</td></tr></tbody></table><h3 id="强制类型转换"><a href="#强制类型转换" class="headerlink" title="强制类型转换"></a>强制类型转换</h3><ul><li>C 语言中定点整数（int、long、short）是用<strong>补码</strong>存储的。</li><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part2/image-20211015192650002.png" alt="image-20211015192650002" style="zoom:100%;"></li></ul><h3 id="数据的存储和排列"><a href="#数据的存储和排列" class="headerlink" title="数据的存储和排列"></a>数据的存储和排列</h3><ul><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part2/image-20211015195134394.png" alt="image-20211015195134394" style="zoom:100%;"></li><li>最高有效字节（<strong>MSB</strong>）最低有效字节（<strong>LSB</strong>）</li><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part2/image-20211015200927531.png" alt="image-20211015200927531"></li><li>现代计算机<strong>通常是按字节编址</strong>，即每个字节对应1个地址<ul><li>通常也支持按字、按半字、按字节寻址</li></ul></li><li>假设存储字长为32位，则1个字=32bit，半字=16bit<ul><li>要将按字寻址转成按字节寻址，则将值左移2位</li></ul></li><li><strong>每次访存只能读/写1个字</strong></li><li>c语言的数据类型长度<ul><li>char：1字节</li><li>short：2字节</li><li>int：4字节</li><li>long：8字节</li></ul></li><li>使用<strong>边界对齐方式</strong>可以<strong>提高读取效率</strong>，而使用<strong>边界不对齐方式</strong>可以<strong>减少存储开销</strong>。</li></ul><h2 id="浮点数的表示与运算"><a href="#浮点数的表示与运算" class="headerlink" title="浮点数的表示与运算"></a>浮点数的表示与运算</h2><h3 id="浮点数的表示"><a href="#浮点数的表示" class="headerlink" title="浮点数的表示"></a>浮点数的表示</h3><h4 id="浮点数的作用和基本原理"><a href="#浮点数的作用和基本原理" class="headerlink" title="浮点数的作用和基本原理"></a>浮点数的作用和基本原理</h4><ul><li>针对问题：定点数可表示的数字范围有限，但我们不能无限制地增加数据的长度</li><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part2/image-20211016153947660.png" alt="image-20211016153947660"></li><li>阶码：常用补码或移码表示的定点整数</li><li>尾数：常用原码或补码表示的定点小数</li><li>浮点数的真值：N=r^E^×M<ul><li>阶码的底 r，通常为 2</li><li>阶码 E 反映浮点数的<strong>表示范围</strong>及小数点的实际位置</li><li>尾数 M 的数值部分的位数 n 反映浮点数的<strong>精度</strong></li><li>尾数给出一个小数，阶码正负与数值指明了尾数左移/右移(小数点向后/向前移动)几位。</li></ul></li></ul><h4 id="浮点数规格化"><a href="#浮点数规格化" class="headerlink" title="浮点数规格化"></a>浮点数规格化</h4><ul><li>规格化浮点数：规定尾数的最高数值位必须是一个有效值 。</li><li>左规：当浮点数运算的结果为非规格化（尾数的最高数值位为 0）时，将尾数算数左移 1 位，阶码减 1。<ul><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part2/image-20211016194214228.png" alt="image-20211016194214228"></li></ul></li><li>右规：当浮点数运算的结果尾数出现溢出（双符号位为01或10）时，将尾数算数右移 1 位，阶码加 1。<ul><li>第一位符号位是正确的符号位</li><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part2/image-20211016194118837.png" alt="image-20211016194118837"></li></ul></li><li>规格化浮点数的特点：<ul><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part2/image-20211016204436786.png" alt="image-20211016204436786"></li><li>规格化的原码尾数，最高数值位一定是 1</li><li>规格化的补码尾数，符号位与最高数值位一定相反</li></ul></li></ul><h4 id="浮点数表示范围（大纲外）"><a href="#浮点数表示范围（大纲外）" class="headerlink" title="浮点数表示范围（大纲外）"></a>浮点数表示范围（大纲外）</h4><ul><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part2/image-20211016204413711.png" alt="image-20211016204413711"></li><li>对于下溢，只需要当做0处理</li><li>对于上溢，必须作为异常</li></ul><h3 id="浮点数标准IEEE75"><a href="#浮点数标准IEEE75" class="headerlink" title="浮点数标准IEEE75"></a>浮点数标准IEEE75</h3><ul><li><p>读音：I triple E——IEEE</p></li><li><p>移码的定义：<strong>移码 = 真值 + 偏置值</strong>（偏置值并不固定）</p><ul><li>在之前所学的移码中：偏置值为 128D=1000 0000B，即 2^n-1^</li><li>在 IEEE75 中，偏置值为 <strong>127D=0111 1111B</strong>，即 <strong>2^n-1^-1</strong></li></ul></li><li><p><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part2/image-20211018121445755.png" alt="image-20211018121445755"></p></li><li></li><li><p>阶码全1、全0时用作特殊用途。因此阶码的正常范围：**-126~127**</p><ul><li>规格化短浮点真值：(-1)^s^×1.M×2^E-127^</li><li>规格化长浮点真值：(-1)^s^×1.M×2^E-1023^</li><li>计算<strong>移码/阶码的真值</strong>时，不用在二进制上面计算，可以<strong>先把看见的移码当做无符号数计算值</strong>，然后<strong>减去偏置值127</strong></li></ul></li></ul><table><thead><tr><th>类型</th><th>数符</th><th>阶码</th><th>尾数</th><th>总位数</th><th>偏置值（十六进制）</th><th>偏置值（十进制）</th></tr></thead><tbody><tr><td>短浮点数(float)</td><td>1</td><td>8</td><td>23</td><td>32</td><td>7FH</td><td>127</td></tr><tr><td>长浮点数(double)</td><td>1</td><td>11</td><td>52</td><td>64</td><td>3FFH</td><td>1023</td></tr><tr><td>临时浮点数(long double)</td><td>1</td><td>15</td><td>64</td><td>80</td><td>3FFFH</td><td>16383</td></tr></tbody></table><ul><li><p><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part2/image-20211018115935229.png" alt="image-20211018115935229"></p></li><li><p>IEEE 754 单精度浮点型能表示的最小绝对值、最大绝对值</p><ul><li>最小绝对值：尾数全为0，阶码真值最小-126，对应移码机器数 0000 0001。此时整体的真值为 (1.0)<del>2</del>×2^-126^</li><li>最大绝对值：尾数全为1，阶码真值最大 127，对应移码机器数 1111 1110。此时整体的真值为 (1.111…11)<del>2</del>×2^127^</li></ul></li></ul><table><thead><tr><th>格式</th><th>格式化的最小绝对值</th><th>格式化的最大绝对值</th></tr></thead><tbody><tr><td>单精度</td><td>E=1，M=0：1.0×2^1−127^=2^-126^</td><td>E=254，M=.11…1：1.11…1×2^254−127^=2^127^×(2−2^−23^)</td></tr><tr><td>双精度</td><td>E=1，M=0：1.0×2^1−1023^=2^-1022^</td><td>E=254，M=.11…1：1.11…1×2^2046−1023^=2^1023^×(2−2^−52^)</td></tr></tbody></table><ul><li><strong>只有 1≤E≤254时，真值 = (−1)^s^×1.M×2^E−127^</strong></li><li>当阶码E全为0<ul><li>尾数M不全为0时，表示非规格化小数 ±(0.xx…x)<del>2</del>×2^-126^<ul><li>隐含最高位变为 0</li><li>阶码真值固定视为 -126</li></ul></li><li>尾数M全为0时，表示真值 ±0</li></ul></li><li>当阶码E全为1<ul><li>尾数M不全为0时，表示非数值 “NaN” (Not a Number)<ul><li>如：0/0、∞-∞ 等非法运算的结果就是 NaN</li></ul></li><li>尾数M全为0时，表示无穷大 ±∞</li></ul></li></ul><blockquote><p>由浮点数确定真值（阶码不是全0、也不是全1）：</p><ol><li>根据“某浮点数”确定数符、阶码、尾数的分布</li><li>确定尾数 1.M（注意补充最高的隐含位1）</li><li>确定阶码的真值 = 移码 - 偏置值 （可将移码看作无符号数，用无符号数的值减去偏置值）</li><li>(−1)^s^×1.M×2^E−偏置值^</li></ol></blockquote><h3 id="浮点数的运算"><a href="#浮点数的运算" class="headerlink" title="浮点数的运算"></a>浮点数的运算</h3><h4 id="浮点数的加减运算"><a href="#浮点数的加减运算" class="headerlink" title="浮点数的加减运算"></a>浮点数的加减运算</h4><ul><li>浮点数加减运算步骤<ul><li>转换格式（真值D-&gt;机器数B；注意审题：用补/移码表示阶码和尾数）</li><li>对阶（使两个数的阶码相等，小阶向大阶看齐，尾数毎右移一位，阶码加1）</li><li>尾数加减</li><li>规格化</li><li>舍入（可以有不同的舍入规则）<ul><li>0舍1入：移去为0则舍，为1则入（可能会使尾数又溢出，此时需再做一次右规。）</li><li>恒置1：无论移去0还是1，都使右移后的尾数末位置1（这种方法同样有使尾数变大和变小的两种可能。）</li></ul></li><li>判溢出（尾数溢出未必导致整体溢出，只有阶数溢出才是真正的溢出）</li></ul></li><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part2/image-20211018135039513.png" alt="image-20211018135039513"></li></ul><h4 id="强制类型转换-1"><a href="#强制类型转换-1" class="headerlink" title="强制类型转换"></a>强制类型转换</h4><table><thead><tr><th>类型</th><th>16位机器</th><th>32位机器</th><th>64位机器</th></tr></thead><tbody><tr><td>char</td><td>8</td><td>8</td><td>8</td></tr><tr><td>short</td><td>16</td><td>16</td><td>16</td></tr><tr><td>int</td><td>16</td><td>32</td><td>32</td></tr><tr><td>long</td><td>32</td><td>32</td><td>64</td></tr><tr><td>long long</td><td>64</td><td>64</td><td>64</td></tr><tr><td>float</td><td>16</td><td>32（23+1）</td><td>32</td></tr><tr><td>double</td><td>64</td><td>64（52+1）</td><td>64</td></tr></tbody></table><ul><li>没有特殊说明，则默认 32 位机器</li><li>无损转换：char -&gt; int -&gt; long -&gt; double；float -&gt; double。<ul><li>在 32 位中，这些转换过程没有损失</li><li>在 64 位中，long -&gt; double 会出现精度损失</li></ul></li><li>有损转换：int -&gt; float；float -&gt; int<ul><li>判断是否会有精度损失，要从有效数字方面考虑</li><li>int：表示整数，范围 -2^31^ ～ 2^31^-1 ，有效数字 <strong>32</strong> 位</li><li>float：表示整数及小数，范围 ±[2^-126^ ～ 2^127^×(2−2^−23^)]，有效数字 <strong>23+1=24</strong> 位</li><li>int -&gt; float：可能损失精度（如 2^24^~2^31^-1 中无法被 float 表示的）</li><li>float -&gt; int：可能溢出（范围过大）及损失精度（表示小数）</li></ul></li></ul><h2 id="算术逻辑单元（ALU）"><a href="#算术逻辑单元（ALU）" class="headerlink" title="算术逻辑单元（ALU）"></a>算术逻辑单元（ALU）</h2><h3 id="电路的基本原理、加法器设计"><a href="#电路的基本原理、加法器设计" class="headerlink" title="电路的基本原理、加法器设计"></a>电路的基本原理、加法器设计</h3><h4 id="作用与原理"><a href="#作用与原理" class="headerlink" title="作用与原理"></a>作用与原理</h4><ul><li>机器字长是 CPU（ALU）一次能够处理的长度，一般等于寄存器的长度。因为输入输出数据存放的寄存器也要和 CPU 处理长度一致。</li><li>ALU 的功能。由控制单元 CU 发出的控制信号决定<ul><li>算术运算：加、减、乘、除等</li><li>逻辑运算：与、或、非、异或等</li><li>辅助功能：移位、求补等</li></ul></li></ul><h4 id="电路基础知识"><a href="#电路基础知识" class="headerlink" title="电路基础知识"></a>电路基础知识</h4><p><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part2/image-20211018152119179.png" alt="image-20211018152119179"></p><h4 id="加法器的实现"><a href="#加法器的实现" class="headerlink" title="加法器的实现"></a>加法器的实现</h4><h5 id="一位全加器"><a href="#一位全加器" class="headerlink" title="一位全加器"></a>一位全加器</h5><p><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part2/image-20211018153352014.png" alt="image-20211018153352014">、</p><h5 id="串行加法器"><a href="#串行加法器" class="headerlink" title="串行加法器"></a>串行加法器</h5><p><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part2/image-20211018153857365.png" alt="image-20211018153857365"></p><ul><li>串行加法器：只有一个全加器，数据逐位串行送入加法器中进行运算。<ul><li>进位触发器用来寄存进位信号，以便参与下一次运算。</li></ul></li><li>如果操作数长 n 位，加法就要分 n 次进行，每次产生一位和，并且串行逐位地送回寄存器。</li></ul><h5 id="并行加法器"><a href="#并行加法器" class="headerlink" title="并行加法器"></a>并行加法器</h5><p><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part2/image-20211018153931233.png" alt="image-20211018153931233"></p><ul><li>串行进位的并行加法器：把 n 个全加器串接起来，就可进行两个 n 位数的相加。</li><li>串行进位又称为行波进位，每一级进位直接依赖于前一级的进位，即进位信号是逐级形成的。</li><li>其性能很大程度依赖于 <strong>FA 产生进位</strong>和<strong>传递进位</strong>的速度</li></ul><h3 id="加法器、ALU的改进"><a href="#加法器、ALU的改进" class="headerlink" title="加法器、ALU的改进"></a>加法器、ALU的改进</h3><ul><li>第 i 位向更高位的进位 C<del>i</del> 可根据 <strong>被加数、加数的第 1~i 位</strong>、<strong>C<del>0</del></strong> 即可确定</li><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part2/image-20211018171510387.png" alt="image-20211018171510387"></li><li>并行进位的<strong>并行加法器</strong>：各级进位信号同时形成，又称为<strong>先行进位</strong>、<strong>同时进位</strong></li><li>为了避免电路过于复杂，设计为 4 个 FA 为一组，组成一个 CLA</li><li>G<del>i</del>：进位产生函数。（由本位确定的是否进位）</li><li>P<del>i</del>：进位传递函数。（本位会控制/屏蔽前一位的进位信息）</li><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part2/image-20211018172125934.png" alt="image-20211018172125934"></li><li>完成组内并行之后，各组之间依然是串行的结构<ul><li><strong>单级先行进位方式</strong>，又称为<strong>组内并行、组间串行</strong>进位方式。</li></ul></li><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part2/image-20211018172358547.png" alt="image-20211018172358547"></li><li>通过 CLA 电路，同时产生各组之间的进位信息<ul><li><strong>多级先行进位</strong>方式，又称为<strong>组内并行、组间并行</strong>进位方式</li></ul></li><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part2/image-20211018173324132.png" alt="image-20211018173324132"></li></ul>]]></content>
    
    
    <summary type="html">数据的表示和运算</summary>
    
    
    
    <category term="计算机组成原理" scheme="https://nephrencake.gitee.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    
    
  </entry>
  
  <entry>
    <title>计算机组成原理-Part1</title>
    <link href="https://nephrencake.gitee.io/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part1/"/>
    <id>https://nephrencake.gitee.io/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part1/</id>
    <published>2021-10-02T02:52:28.000Z</published>
    <updated>2021-10-26T15:16:43.190Z</updated>
    
    <content type="html"><![CDATA[<h1 id="计算机组成原理-Part1——计算机系统概述"><a href="#计算机组成原理-Part1——计算机系统概述" class="headerlink" title="计算机组成原理-Part1——计算机系统概述"></a>计算机组成原理-Part1——计算机系统概述</h1><p>[TOC]</p><h2 id="开篇"><a href="#开篇" class="headerlink" title="开篇"></a>开篇</h2><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part1/image-20211002105534456.png" alt="image-20211002105534456" style="zoom:80%;"><ul><li><p>CPU、内存、硬盘上都有针脚。这些针脚就是用来接收高低电平的电信号的。</p></li><li><p>传递电信号就需要电脑主板上的印刷电路，这是可以导电的。</p></li><li><p>计算机体系结构 vs 计算机组成原理</p><ul><li><p>计算机体系结构：机器语言程序员所见到的计算机系统的属性概念性的结构与功能特性（指令系统、数据类型、寻址技术、I/O机理）</p><p>如何设计硬件与软件之间的接口。如：有无乘法指令</p></li><li><p>计算机组成原理：实现计算机体系结构所体现的属性，对程序员“透明”（具体指令的实现）</p><p>如何用硬件实现所定义的接口。如：如何实现乘法指令</p></li></ul></li></ul><h2 id="计算机发展历程（408大纲已删）"><a href="#计算机发展历程（408大纲已删）" class="headerlink" title="计算机发展历程（408大纲已删）"></a>计算机发展历程（408大纲已删）</h2><ul><li><p>计算机系统</p><ul><li><p>软件</p><ul><li><p>系统软件：用来管理整个计算机系统。</p><p>例如：操作系统、数据库管理系统(DBMS)、标准程序库(编程使用库)、网络软件(实现网络协议的模块)、语言处理程序(将高级语言转换成低级语言)、服务程序(调试程序)等。</p></li><li><p>应用软件：按任务需要编织成的各种程序。</p></li></ul></li><li><p>硬件</p></li></ul><p>计算机性能的好坏取决于“软”、“硬”件功能的总和。</p></li><li><p>硬件发展历程</p></li></ul><table><thead><tr><th>发展阶段</th><th>时间</th><th>逻辑元件</th><th>速度(次/秒)</th><th>内存</th><th>外存</th></tr></thead><tbody><tr><td>第一代</td><td>1946-1957</td><td><strong>电子管</strong></td><td>几千-几万</td><td>汞延迟线、磁鼓</td><td>穿孔卡片、纸带</td></tr><tr><td>第二代</td><td>1958-1964</td><td><strong>晶体管</strong></td><td>几万-几十万</td><td>磁芯存储器</td><td>磁带</td></tr><tr><td>第三代</td><td>1964-1971</td><td>中小规模<strong>集成电路</strong></td><td>几十万-几百万</td><td>半导体存储器</td><td>磁带、磁盘</td></tr><tr><td>第四代</td><td>1972-现在</td><td>大规模、超大规模集成电路</td><td>上千万-万亿</td><td>半导体存储器</td><td>磁盘、磁带、光盘、半导体存储器</td></tr></tbody></table><ul><li>发展趋势<ul><li>更微型、多用途</li><li>更巨型、超高速</li></ul></li></ul><h2 id="计算机系统层次结构"><a href="#计算机系统层次结构" class="headerlink" title="计算机系统层次结构"></a>计算机系统层次结构</h2><h3 id="计算机硬件的基本组成"><a href="#计算机硬件的基本组成" class="headerlink" title="计算机硬件的基本组成"></a>计算机硬件的基本组成</h3><h4 id="早期冯诺依曼结构"><a href="#早期冯诺依曼结构" class="headerlink" title="早期冯诺依曼结构"></a>早期冯诺依曼结构</h4><ul><li><strong>存储程序</strong>：将指令以二进制代码的形式事先输入计算机的主存储器，从首地址开始顺序执行指令至结束。<ul><li>针对问题：虽然早期冯诺依曼机的计算速度很快，但是 ENIAC 需要手动接线来控制计算，因此速度并不理想。</li></ul></li><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part1/image-20211002184657874.png" alt="image-20211002184657874" style="zoom:80%;"></li><li>在计算机系统中，软件和硬件在逻辑上是等效的。</li><li>冯·诺依曼计算机的特点：<ul><li><strong>计算机由五大部件组成：输入设备、输出设备、主存储器、运算器、控制器</strong></li><li>指令和数据以<strong>同等地位</strong>存于存储器，可<strong>按地址寻访</strong></li><li>指令和数据用二进制表示</li><li><strong>指令由操作码和地址码组成</strong></li><li>存储程序被首次提出</li><li><strong>以运算器为中心</strong>（输入/输出设备与存储器之间的数据传送通过运算器完成）</li></ul></li></ul><h4 id="现代计算机结构"><a href="#现代计算机结构" class="headerlink" title="现代计算机结构"></a>现代计算机结构</h4><ul><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part1/image-20211002185341049.png" alt="image-20211002185341049" style="zoom: 80%;"></li><li>现代计算机：<strong>以存储器为中心</strong></li><li><strong>CPU=运算器+控制器</strong></li><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part1/image-20211002185424956.png" alt="image-20211002185424956" style="zoom: 80%;"></li><li>计组中的主机只包括：<strong>CPU 和主存</strong>。硬盘等不属于主机。</li></ul><h3 id="认识各个硬件部件"><a href="#认识各个硬件部件" class="headerlink" title="认识各个硬件部件"></a>认识各个硬件部件</h3><h4 id="主存储器"><a href="#主存储器" class="headerlink" title="主存储器"></a>主存储器</h4><ul><li>MAR（Memory Address Register）：<strong>存储地址寄存器</strong>，专门存放单次操作的数据地址</li><li>MDR（Memory Data Register）：<strong>存储数据寄存器</strong>，专门存放单次操作的数据内容</li><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part1/image-20211002191934325.png" alt="image-20211002191934325" style="zoom:80%;"></li><li>存储单元：每个存储单元用来存放一串二进制代码。每个存储单元对应一个地址信息（即 MAR 中应当指明的信息）</li><li>存储字(<strong>word</strong>)：每个存储单元中的一串二进制代码，就是一个存储字</li><li>存储字长：存储单元/每个存储字中，包含的二进制代码的位数。*<em>长度一般为：k * 8 bit*</em></li><li>存储元：即存储二进制的电子元件（电容），每个存储元可存 1bit</li><li><strong>数据在存储体内按地址存储</strong></li><li><strong>MAR 位数反映存储单元的个数</strong>：MAR=4位 -&gt; 总共有 24 个存储单元</li><li><strong>MDR 位数 = 存储字长</strong>：MDR = 16位 -&gt; 每个存储单元可存放 16bit，1个字(word) = 16bit</li><li>易混淆：<ul><li><strong>1个字节（Byte）= 8bit</strong></li><li>1B = 1个字节，1b = 1个bit</li><li><strong>字(word)的长度由机器本身决定</strong></li></ul></li></ul><h4 id="运算器"><a href="#运算器" class="headerlink" title="运算器"></a>运算器</h4><ul><li>运算器：用于实现算术运算（如：加减乘除）、逻辑运算（如：与或非）</li><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part1/image-20211002193854953.png" alt="image-20211002193854953" style="zoom:80%;"></li><li>ACC：累加器，用于存放操作数，或运算结果</li><li>MQ：乘商寄存器，在乘、除运算时，用于存放操作数或运算结果</li><li>X：通用的操作数寄存器/通用寄存器，用于存放操作数。通常有多个，不过只需要一个就可以完成大部分运算</li><li>ALU：（※核心元件）算术逻辑单元，通过内部复杂的电路实现算数运算、逻辑运算</li></ul><h4 id="控制器"><a href="#控制器" class="headerlink" title="控制器"></a>控制器</h4><ul><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part1/image-20211002194312723.png" alt="image-20211002194312723" style="zoom:80%;"></li><li>CU（Control Unit）：（※核心元件）控制单元，分析指令，给出控制信号</li><li>IR（Instruction Register）：指令寄存器，存放<strong>当前执行的指令</strong></li><li>PC（Program Counter）：程序计数器，存放<strong>下一条指令地址</strong>，有自动加1功能</li></ul><h4 id="计算机工作流程"><a href="#计算机工作流程" class="headerlink" title="计算机工作流程"></a>计算机工作流程</h4><ul><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part1/image-20211002200948818.png" alt="image-20211002200948818" style="zoom:80%;"></li><li>工作过程：<ul><li>初始状态：指令、数据存入主存，PC 指向第一条指令</li><li>PC -&gt; MAR -&gt; 从存储体中取指令放入 MDR -&gt; 由于处于取指令周期，将指令数据放入 IR -&gt; 由 CU 分析指令（前半段二进制码） -&gt; 变量地址（后半段二进制）放入 MAR -&gt; 从存储体中取指令放入 MDR -&gt; 由于执行指令周期，将变量数据放入运算器寄存器中 -&gt; 执行运算并将结果放入 ACC -&gt; …… </li></ul></li><li>注：现在的计算机通常把 MAR、MDR 也集成在 CPU 内</li></ul><h3 id="计算机系统的多级层次结构"><a href="#计算机系统的多级层次结构" class="headerlink" title="计算机系统的多级层次结构"></a>计算机系统的多级层次结构</h3><h4 id="五层机器结构"><a href="#五层机器结构" class="headerlink" title="五层机器结构"></a>五层机器结构</h4><ul><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part1/image-20211003001409155.png" alt="image-20211003001409155" style="zoom:80%;"></li><li>下层是上层的基础，上层是下层的扩展<ul><li>高级语言机器</li><li>汇编语言机器</li><li>操作系统机器</li><li>传统机器</li><li>微程序机器</li></ul></li></ul><h4 id="三个级别语言"><a href="#三个级别语言" class="headerlink" title="三个级别语言"></a>三个级别语言</h4><ul><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part1/image-20211003002429374.png" alt="image-20211003002429374" style="zoom:80%;"></li><li>编译、汇编、解释程序，可统称“翻译程序”<ul><li>编译程序：将高级语言的源程序<strong>一次性</strong>翻译成汇编语言，或者直接翻译为机器语言的执行程序（只需翻译一次）</li><li>解释程序：将高级语言的源程序<strong>逐语句</strong>翻译成机器语言，并立即执行。（每次执行都要翻译）</li><li>汇编程序：将汇编语言翻译成机器语言。</li></ul></li></ul><h2 id="计算机的性能指标"><a href="#计算机的性能指标" class="headerlink" title="计算机的性能指标"></a>计算机的性能指标</h2><h3 id="存储器"><a href="#存储器" class="headerlink" title="存储器"></a>存储器</h3><ul><li><strong>MAR位数</strong>反映<strong>存储单元的个数</strong>（最多支持多少个）</li><li><strong>MDR位数</strong>=存储字长=<strong>每个存储单元的大小</strong></li><li><strong>总容量 = 存储单元个数×存储字长 bit = 存储单元个数×存储字长/8 Byte</strong> (1Byte=8bit)<ul><li>Eg：MAR为 32 位，MDR 为 8 位；总容量 = 2^32^ * 8 bit = 4 GB</li></ul></li></ul><blockquote><p>注：此处描述文件、容量大小等所用的 K、M、G、T </p><p>2^10^B：KB        2^20^B：MB        2^30^B：GB        2^40^B：TB</p></blockquote><h3 id="CPU"><a href="#CPU" class="headerlink" title="CPU"></a>CPU</h3><ul><li><strong>CPU 主频</strong>（时钟频率）：CPU内数字脉冲信号振荡的频率。<ul><li>1s 内进行的数字脉冲信号次数</li><li>CPU主频 = 1/CPU时钟周期</li><li>单位：赫兹，Hz</li></ul></li><li><strong>CPU 时钟周期</strong>：一次脉冲信号的周期。<ul><li>单位：微秒、纳秒</li></ul></li><li><strong>CPI</strong>（Clock cycle Per Instruction）：执行一条指令所需的时钟周期数<ul><li>不同的指令，CPI 有可能不同</li><li>相同的指令，根据不同 CPU 的实现方式不同、当前内存负载不同等等一系列状态，CPI 也可能不同</li><li>可以影响 CPI 的因素太多，一般只讨论平均 CPI</li></ul></li><li><strong>执行一条指令的耗时</strong> = CPI × CPU时钟周期</li><li><strong>CPU 执行时间</strong>（整个程序的耗时）= CPU时钟周期数 / 主频 =（指令条数 * CPI）/ 主频</li><li><strong>IPS</strong>（ Instructions Per Second ）：每秒执行多少条指令<ul><li>IPS =  主频 / 平均CPI</li><li>度量指标时经常使用 KIPS、MIPS</li></ul></li><li><strong>FLOPS</strong>（Floating-point Operations Per Second）：每秒执行多少次浮点运算<ul><li>度量指标时经常使用 KFLOPS、MFLOPS、GFLOPS、TFLOPS、PFLOPS、EFLOPS、ZFLOPS</li></ul></li></ul><blockquote><p>注：此处频率、速率常用的 K、M、G、T 为数量单位</p><p>K=Kilo=千=10^3^，M=Million=百万=10^6^，G=Giga=十亿=10^9^ ，T=Tera=万亿= 10^12^，P=10^3^T，E=10^3^P，Z=10^3^E</p></blockquote><h3 id="系统整体"><a href="#系统整体" class="headerlink" title="系统整体"></a>系统整体</h3><ul><li><p>数据通路带宽：数据总线一次所能并行传送信息的位数（各硬件部件通过数据总线传输数据）</p><ul><li>CPU &lt;=&gt; 主存储器 &lt;=&gt; I/O 设备。这之间的数据传输都需要依靠数据总线传输。</li></ul></li><li><p>吞吐量：指系统在单位时间内处理请求的数量。</p><ul><li>取决于信息能多快地输入内存，CPU能多快地取指令，数据能多快地从内存取出或存入，以及所得结果能多快地从内存送给一台外部设备。</li><li>这些步骤中的每一步都关系到主存，因此，系统吞吐量主要取决于主存的存取周期。</li></ul></li><li><p>响应时间：指从用户向计算机发送一个请求，到系统对该请求做出响应并获得它所需要的结果的等待时间。</p><ul><li>通常包括CPU时间（运行一个程序所花费的时间）与等待时间（用于磁盘访问、存储器访问、I/O操作、操作系统开销等时间）。</li></ul></li><li><p>基准程序：是用来测量计算机处理速度的一种实用程序，以便于被测量的计算机性能可以与运行相同程序的其它计算机性能进行比较。</p></li><li><p>思考：</p><ul><li>Q：主频高的 CPU 一定比主频低的CPU快吗？</li><li>A：不一定，如两个 CPU，A 的主频为 2GHz，平均 CPI=10；B 的主频 1GHz，平均 CPI=1…</li><li>Q：若 A、B 两个 CPU 的平均 CPI 相同，那么 A 一定更快吗？</li><li>A：也不一定，还要看指令系统。如：A 不支持乘法指令，只能用多次加法实现乘法；而 B 支持乘法指令。</li><li>Q：基准程序执行得越快说明机器性能越好吗？</li><li>A：基准程序中的语句存在频度差异，运行结果也不能完全说明问题，要看硬件具体的运用场景</li></ul></li></ul>]]></content>
    
    
    <summary type="html">计算机系统概述</summary>
    
    
    
    <category term="计算机组成原理" scheme="https://nephrencake.gitee.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    
    
  </entry>
  
</feed>
