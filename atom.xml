<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>浅幽丶奈芙莲的个人博客</title>
  
  <subtitle>NephrenCake Blog</subtitle>
  <link href="https://nephrencake.github.io/atom.xml" rel="self"/>
  
  <link href="https://nephrencake.github.io/"/>
  <updated>2022-08-01T15:45:16.006Z</updated>
  <id>https://nephrencake.github.io/</id>
  
  <author>
    <name>NephrenCake</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>考研作战记录-Part8</title>
    <link href="https://nephrencake.github.io/2022/8/%E8%80%83%E7%A0%94%E4%BD%9C%E6%88%98%E8%AE%B0%E5%BD%95-Part8/"/>
    <id>https://nephrencake.github.io/2022/8/%E8%80%83%E7%A0%94%E4%BD%9C%E6%88%98%E8%AE%B0%E5%BD%95-Part8/</id>
    <published>2022-08-01T01:11:48.000Z</published>
    <updated>2022-08-01T15:45:16.006Z</updated>
    
    <content type="html"><![CDATA[<h1 id="考研作战记录-Part8——8月份考研记录"><a href="#考研作战记录-Part8——8月份考研记录" class="headerlink" title="考研作战记录-Part8——8月份考研记录"></a>考研作战记录-Part8——8月份考研记录</h1><h2 id="8-1"><a href="#8-1" class="headerlink" title="8.1"></a>8.1</h2><ol><li>数学<ul><li>姜150：高数 1 讲</li><li>重做 660 概率 480~575</li><li>回顾线代</li><li>共创 18 模拟一（100/150）（怎么高数能出的这么难）</li></ul></li><li>英语<ul><li>背单词 400</li></ul></li></ol>]]></content>
    
    
    <summary type="html">8月份考研记录</summary>
    
    
    
    <category term="考研作战记录" scheme="https://nephrencake.github.io/categories/%E8%80%83%E7%A0%94%E4%BD%9C%E6%88%98%E8%AE%B0%E5%BD%95/"/>
    
    
  </entry>
  
  <entry>
    <title>考研作战记录-Part7</title>
    <link href="https://nephrencake.github.io/2022/7/%E8%80%83%E7%A0%94%E4%BD%9C%E6%88%98%E8%AE%B0%E5%BD%95-Part7/"/>
    <id>https://nephrencake.github.io/2022/7/%E8%80%83%E7%A0%94%E4%BD%9C%E6%88%98%E8%AE%B0%E5%BD%95-Part7/</id>
    <published>2022-07-07T02:31:56.000Z</published>
    <updated>2022-08-01T12:27:52.458Z</updated>
    
    <content type="html"><![CDATA[<h1 id="考研作战记录-Part7——7月份考研记录"><a href="#考研作战记录-Part7——7月份考研记录" class="headerlink" title="考研作战记录-Part7——7月份考研记录"></a>考研作战记录-Part7——7月份考研记录</h1><h2 id="7-31"><a href="#7-31" class="headerlink" title="7.31"></a>7.31</h2><ol><li>数学<ul><li>姜150：概率 7~8 讲</li><li>重做 660 概率 426~479</li></ul></li><li>英语<ul><li>背单词 400</li></ul></li></ol><h2 id="7-30"><a href="#7-30" class="headerlink" title="7.30"></a>7.30</h2><ol><li>数学<ul><li>姜150：概率 6~7 讲</li></ul></li><li>英语<ul><li>背单词 400</li></ul></li></ol><h2 id="7-29"><a href="#7-29" class="headerlink" title="7.29"></a>7.29</h2><ol><li>数学<ul><li>姜150：概率 4~5 讲</li></ul></li><li>英语<ul><li>背单词 200</li></ul></li></ol><h2 id="7-28"><a href="#7-28" class="headerlink" title="7.28"></a>7.28</h2><ol><li>数学<ul><li>姜150：概率 2~4 讲</li></ul></li><li>英语<ul><li>背单词 400</li></ul></li></ol><h2 id="7-27"><a href="#7-27" class="headerlink" title="7.27"></a>7.27</h2><ol><li>数学<ul><li>姜150：线代 10 讲</li><li>姜150：概率 1~2 讲</li></ul></li><li>英语<ul><li>背单词 200</li></ul></li></ol><h2 id="7-26"><a href="#7-26" class="headerlink" title="7.26"></a>7.26</h2><ol><li>数学<ul><li>姜150：线代 8~10 讲（写了一天大题，麻麻子）</li></ul></li><li>英语<ul><li>背单词 200</li></ul></li></ol><h2 id="7-25"><a href="#7-25" class="headerlink" title="7.25"></a>7.25</h2><ol><li>数学<ul><li>回顾线代</li><li>姜150：线代 8~10 讲</li><li>重做 660 线代 276~425（探望新手村）</li></ul></li><li>英语<ul><li>背单词 300</li></ul></li></ol><h2 id="7-24"><a href="#7-24" class="headerlink" title="7.24"></a>7.24</h2><ol><li>数学<ul><li>整理复习线代 6 章</li><li>姜晓千150：线代 6~7 讲</li></ul></li><li>英语<ul><li>背单词 200</li></ul></li></ol><h2 id="7-23"><a href="#7-23" class="headerlink" title="7.23"></a>7.23</h2><ol><li>数学<ul><li>整理复习线代 5、6 章</li><li>姜晓千150：线代 6~7 讲</li></ul></li><li>英语<ul><li>背单词 200</li></ul></li></ol><h2 id="7-22"><a href="#7-22" class="headerlink" title="7.22"></a>7.22</h2><ol><li>数学<ul><li>整理复习线代 5 章</li><li>共创 17 模拟一（87/150）（我的评价是高数忘完了）</li></ul></li><li>英语<ul><li>背单词 300</li></ul></li></ol><h2 id="7-21"><a href="#7-21" class="headerlink" title="7.21"></a>7.21</h2><ol><li>数学<ul><li>姜晓千150：线代 5 讲</li></ul></li><li>英语<ul><li>背单词 200</li></ul></li></ol><h2 id="7-20"><a href="#7-20" class="headerlink" title="7.20"></a>7.20</h2><ol><li>数学<ul><li>整理复习线代 1~4 章</li><li>姜晓千150：线代 5 讲</li></ul></li><li>英语<ul><li>背单词 400</li></ul></li></ol><h2 id="7-19"><a href="#7-19" class="headerlink" title="7.19"></a>7.19</h2><ol><li>数学<ul><li>整理复习线代 1~4 章（比想象中花的时间还多，也许是太摸了</li></ul></li><li>英语<ul><li>背单词 200</li></ul></li></ol><h2 id="7-18"><a href="#7-18" class="headerlink" title="7.18"></a>7.18</h2><ol><li>数学<ul><li>整理复习线代 1~4 章</li></ul></li></ol><h2 id="7-17"><a href="#7-17" class="headerlink" title="7.17"></a>7.17</h2><ol><li>数学<ul><li>姜晓千150：线代 1~4 讲（进行中）</li><li>重做线代基础强化 1~4 章（进行中）</li></ul></li><li>英语<ul><li>背单词 320</li></ul></li></ol><h2 id="7-16"><a href="#7-16" class="headerlink" title="7.16"></a>7.16</h2><ol><li>姜晓千150：线代 1、2 讲（进行中）</li><li>重做线代基础强化 1、2 章（进行中）</li><li>数据结构强化 1 讲（进行中）</li><li>背单词 100</li></ol><h2 id="7-15"><a href="#7-15" class="headerlink" title="7.15"></a>7.15</h2><ol><li>姜晓千150：线代 1 讲（进行中）</li><li>重做线代基础强化 1、2 章（进行中）</li><li>数据结构强化 1 讲（进行中）</li><li>背单词 300</li></ol><h2 id="7-14"><a href="#7-14" class="headerlink" title="7.14"></a>7.14</h2><ol><li>660 概率 526-575</li><li>背单词 400</li></ol><h2 id="7-13"><a href="#7-13" class="headerlink" title="7.13"></a>7.13</h2><ol><li>复习编译原理，编译原理考试</li><li>背单词 300</li></ol><h2 id="7-12"><a href="#7-12" class="headerlink" title="7.12"></a>7.12</h2><ol><li>660 概率 460-525</li><li>复习编译原理</li><li>背单词 500</li></ol><h2 id="7-11"><a href="#7-11" class="headerlink" title="7.11"></a>7.11</h2><ol><li>复习计网书，计网考试</li><li>复习编译原理</li><li>背单词 520</li></ol><h2 id="7-10"><a href="#7-10" class="headerlink" title="7.10"></a>7.10</h2><ol><li>概率强化 5、6、7 章，重做基础 5、6、7 章；</li><li>660 概率 453-459</li><li>背单词 320</li></ol><h2 id="7-9"><a href="#7-9" class="headerlink" title="7.9"></a>7.9</h2><ol><li>概率强化 3、4 章，重做基础 4 章</li><li>背单词 320</li></ol><h2 id="7-8"><a href="#7-8" class="headerlink" title="7.8"></a>7.8</h2><ol><li>重做概率基础强化 1、2、3 章例题</li><li>660 概率 426-453</li><li>概率强化 3 章（20%）</li><li>背单词 320 </li></ol><h2 id="7-7"><a href="#7-7" class="headerlink" title="7.7"></a>7.7</h2><ol><li>计网书一遍收尾（ip、tcp题啃了好几天啊）</li><li>复习660空间几何、多元函数积分</li><li>复习概率基础</li></ol>]]></content>
    
    
    <summary type="html">7月份考研记录</summary>
    
    
    
    <category term="考研作战记录" scheme="https://nephrencake.github.io/categories/%E8%80%83%E7%A0%94%E4%BD%9C%E6%88%98%E8%AE%B0%E5%BD%95/"/>
    
    
  </entry>
  
  <entry>
    <title>C++-完结目录</title>
    <link href="https://nephrencake.github.io/2022/1/C++-%E5%AE%8C%E7%BB%93%E7%9B%AE%E5%BD%95/"/>
    <id>https://nephrencake.github.io/2022/1/C++-%E5%AE%8C%E7%BB%93%E7%9B%AE%E5%BD%95/</id>
    <published>2022-01-03T07:15:09.000Z</published>
    <updated>2022-02-10T10:48:39.298Z</updated>
    
    <content type="html"><![CDATA[<h1 id="C-完结目录"><a href="#C-完结目录" class="headerlink" title="C++-完结目录"></a>C++-完结目录</h1><p>教程传送门：</p><ul><li><a href="https://www.bilibili.com/video/BV1et411b73Z">https://www.bilibili.com/video/BV1et411b73Z</a></li><li><a href="https://www.runoob.com/cplusplus/cpp-tutorial.html">https://www.runoob.com/cplusplus/cpp-tutorial.html</a></li></ul><table><thead><tr><th align="center"><a href="/2022/01/C++-Part1/">C++-Part1——入门编程</a></th></tr></thead><tbody><tr><td align="center"><strong><a href="/2022/01/C++-Part2/">C++-Part2——核心编程</a></strong></td></tr><tr><td align="center"><strong><a href="/2022/01/C++-Part3/">C++-Part3——提高编程</a></strong></td></tr></tbody></table>]]></content>
    
    
    <summary type="html">完结目录</summary>
    
    
    
    <category term="C++" scheme="https://nephrencake.github.io/categories/C/"/>
    
    
    <category term="Algorithms" scheme="https://nephrencake.github.io/tags/Algorithms/"/>
    
  </entry>
  
  <entry>
    <title>C++-Part3</title>
    <link href="https://nephrencake.github.io/2022/1/C++-Part3/"/>
    <id>https://nephrencake.github.io/2022/1/C++-Part3/</id>
    <published>2022-01-03T07:14:51.000Z</published>
    <updated>2022-02-10T10:46:19.234Z</updated>
    
    <content type="html"><![CDATA[<h1 id="C-Part3——提高编程"><a href="#C-Part3——提高编程" class="headerlink" title="C++-Part3——提高编程"></a>C++-Part3——提高编程</h1><p>[TOC]</p><h2 id="STL-概述"><a href="#STL-概述" class="headerlink" title="STL 概述"></a>STL 概述</h2><ul><li>诞生背景<ul><li>长久以来，软件界一直希望建立一种可重复利用的东西</li><li>C++ 的<strong>面向对象</strong>和<strong>泛型编程</strong>思想，目的就是<strong>复用性的提升</strong></li><li>大多情况下，数据结构和算法都未能有一套标准，导致被迫从事大量重复工作</li><li>为了建立数据结构和算法的一套标准，诞生了<strong>STL</strong></li></ul></li></ul><ul><li><p>基本概念</p><ul><li>STL（Standard Template Library，标准模板库）</li><li>STL 从广义上分为：<strong>容器（container）、算法（algorithm）、迭代器（iterator）</strong></li><li><strong>容器</strong>和<strong>算法</strong>之间通过<strong>迭代器</strong>进行无缝连接。</li><li>STL 几乎所有的代码都采用了模板类或者模板函数</li></ul></li><li><p>STL 六大组件：</p><ol><li>容器：各种数据结构，如 vector、list、deque、set、map 等，用来存放数据。</li><li>算法：各种常用的算法，如 sort、find、copy、for_each 等</li><li>迭代器：扮演了容器与算法之间的胶合剂。</li><li>仿函数：行为类似函数，可作为算法的某种策略。</li><li>适配器：一种用来修饰容器或者仿函数或迭代器接口的东西。</li><li>空间配置器：负责空间的配置与管理。</li></ol></li><li><p>STL 容器、算法、迭代器</p><ul><li><p>容器：</p><ul><li>STL<strong>容器</strong>就是将运用<strong>最广泛的一些数据结构</strong>实现出来</li><li>常用的数据结构：数组、链表、树、栈、队列、集合、映射表等</li><li>这些容器分为<strong>序列式容器</strong>和<strong>关联式容器</strong>两种:<ul><li><strong>序列式容器</strong>：强调值的排序，序列式容器中的每个元素均有固定的位置。</li><li><strong>关联式容器</strong>：二叉树结构，各元素之间没有严格的物理上的顺序关系</li></ul></li></ul></li><li><p>算法：</p><ul><li>有限的步骤，解决逻辑或数学上的问题</li><li>算法分为：<strong>质变算法</strong>和<strong>非质变算法</strong>。<ul><li>质变算法：是指运算过程中会更改区间内的元素的内容。例如拷贝、替换、删除等等</li><li>非质变算法：是指运算过程中不会更改区间内的元素内容，例如查找、计数、遍历、寻找极值等等</li></ul></li></ul></li><li><p>迭代器：</p><ul><li><p>提供一种方法，使之能够依序寻访某个容器所含的各个元素，而又无需暴露该容器的内部表示方式。</p></li><li><p><strong>每个容器都有自己专属的迭代器</strong></p></li><li><p>迭代器使用非常类似于指针</p></li><li><p>迭代器种类：</p><table><thead><tr><th>种类</th><th>功能</th><th>支持运算</th></tr></thead><tbody><tr><td>输入迭代器</td><td>对数据的只读访问</td><td>只读，支持++、==、！=</td></tr><tr><td>输出迭代器</td><td>对数据的只写访问</td><td>只写，支持++</td></tr><tr><td>前向迭代器</td><td>读写操作，并能向前推进迭代器</td><td>读写，支持++、==、！=</td></tr><tr><td>双向迭代器</td><td>读写操作，并能向前和向后操作</td><td>读写，支持++、–，</td></tr><tr><td>随机访问迭代器</td><td>读写操作，可以以跳跃的方式访问任意数据，功能最强的迭代器</td><td>读写，支持++、–、[n]、-n、&lt;、&lt;=、&gt;、&gt;=</td></tr></tbody></table></li><li><p>常用的容器中迭代器种类为双向迭代器，和随机访问迭代器</p></li></ul></li></ul></li></ul><h2 id="STL-常用容器"><a href="#STL-常用容器" class="headerlink" title="STL 常用容器"></a>STL 常用容器</h2><h3 id="string-容器"><a href="#string-容器" class="headerlink" title="string 容器"></a>string 容器</h3><h4 id="string-基本概念"><a href="#string-基本概念" class="headerlink" title="string 基本概念"></a>string 基本概念</h4><ul><li><p>本质：</p><ul><li>string 是 C++ 风格的字符串，而 string 本质上是一个类</li></ul></li><li><p>string 和 char* 区别：</p><ul><li>char* 是一个指针</li><li>string 是一个类，类内部封装了char*，管理这个字符串，是一个 char* 型的容器。</li></ul></li><li><p>特点：</p><ul><li>string 类内部封装了很多成员方法</li><li>string 管理 char* 所分配的内存，不用担心复制越界和取值越界等，由类内部进行负责</li></ul></li></ul><h4 id="string-构造函数"><a href="#string-构造函数" class="headerlink" title="string 构造函数"></a>string 构造函数</h4><ul><li><p>构造函数原型：</p><ul><li><p><code>string();</code>：创建一个空的字符串</p></li><li><p><code>string(const char* s);</code>：使用 c 风格字符串初始化</p><ul><li><blockquote><p>string 转 char*：<code>char*p=(char*)str.data();</code> 或 <code>char *p=(char*)str.c_str();</code></p></blockquote></li></ul></li><li><p><code>string(const string&amp; str);</code>：使用一个 string 对象初始化另一个 string 对象</p></li><li><p><code>string(int n, char c);</code>：使用 n 个字符 c 初始化 </p></li></ul></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// string构造</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">string</span> s1; <span class="comment">// 创建空字符串，调用无参构造函数</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;str1 = &quot;</span> &lt;&lt; s1 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *str = <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">s2</span><span class="params">(str)</span></span>; <span class="comment">// 把c_string转换成了string</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;str2 = &quot;</span> &lt;&lt; s2 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">s3</span><span class="params">(s2)</span></span>; <span class="comment">// 调用拷贝构造函数</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;str3 = &quot;</span> &lt;&lt; s3 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">s4</span><span class="params">(<span class="number">10</span>, <span class="string">&#x27;a&#x27;</span>)</span></span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;str4 = &quot;</span> &lt;&lt; s4 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    test01();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="string-赋值操作"><a href="#string-赋值操作" class="headerlink" title="string 赋值操作"></a>string 赋值操作</h4><ul><li>赋值的函数原型：<ul><li><code>string&amp; operator=(const char* s);</code>：char* 类型字符串赋值给当前的字符串</li><li><code>string&amp; operator=(const string &amp;s);</code>：把字符串 s 赋给当前的字符串</li><li><code>string&amp; operator=(char c);</code>：单字符赋值给当前的字符串</li><li><code>string&amp; assign(const char *s);</code>：把字符串 s 赋给当前的字符串</li><li><code>string&amp; assign(const char *s, int n);</code>：把字符串 s 的<strong>前 n 个字符</strong>赋给当前的字符串</li><li><code>string&amp; assign(const string &amp;s);</code>：把字符串 s 赋给当前字符串</li><li><code>string&amp; assign(int n, char c);</code>：用 n 个字符 c 赋给当前字符串</li></ul></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//赋值</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">string</span> str1;</span><br><span class="line">    str1 = <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;str1 = &quot;</span> &lt;&lt; str1 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">string</span> str2;</span><br><span class="line">    str2 = str1;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;str2 = &quot;</span> &lt;&lt; str2 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">string</span> str3;</span><br><span class="line">    str3 = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;str3 = &quot;</span> &lt;&lt; str3 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">string</span> str4;</span><br><span class="line">    str4.assign(<span class="string">&quot;hello c++&quot;</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;str4 = &quot;</span> &lt;&lt; str4 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">string</span> str5;</span><br><span class="line">    str5.assign(<span class="string">&quot;hello c++&quot;</span>, <span class="number">5</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;str5 = &quot;</span> &lt;&lt; str5 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">string</span> str6;</span><br><span class="line">    str6.assign(str5);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;str6 = &quot;</span> &lt;&lt; str6 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">string</span> str7;</span><br><span class="line">    str7.assign(<span class="number">5</span>, <span class="string">&#x27;x&#x27;</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;str7 = &quot;</span> &lt;&lt; str7 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    test01();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="string-字符串拼接"><a href="#string-字符串拼接" class="headerlink" title="string 字符串拼接"></a>string 字符串拼接</h4><ul><li>函数原型：<ul><li><code>string&amp; operator+=(const char* str);</code>：重载 += 操作符</li><li><code>string&amp; operator+=(const char c);</code>：重载 += 操作符</li><li><code>string&amp; operator+=(const string&amp; str);</code>：重载 += 操作符</li><li><code>string&amp; append(const char* s);</code>：把字符串 s 连接到当前字符串结尾</li><li><code>string&amp; append(const char* s, int n);</code>：把字符串 s 的前 n 个字符连接到当前字符串结尾</li><li><code>string&amp; append(const string&amp; s);</code>：同 operator+=(const string&amp; str)</li><li><code>string&amp; append(const string&amp; s, int pos, int n);</code>：字符串 s 中从 pos 开始的 n 个字符连接到字符串结尾</li></ul></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//字符串拼接</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">string</span> str1 = <span class="string">&quot;我&quot;</span>;</span><br><span class="line">    str1 += <span class="string">&quot;爱玩游戏&quot;</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;str1 = &quot;</span> &lt;&lt; str1 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    str1 += <span class="string">&#x27;:&#x27;</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;str1 = &quot;</span> &lt;&lt; str1 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">string</span> str2 = <span class="string">&quot;LOL DNF&quot;</span>;</span><br><span class="line">    str1 += str2;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;str1 = &quot;</span> &lt;&lt; str1 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">string</span> str3 = <span class="string">&quot;I&quot;</span>;</span><br><span class="line">    str3.append(<span class="string">&quot; love &quot;</span>);</span><br><span class="line">    str3.append(<span class="string">&quot;game abcde&quot;</span>, <span class="number">4</span>);</span><br><span class="line">    <span class="comment">//str3.append(str2);</span></span><br><span class="line">    str3.append(str2, <span class="number">4</span>, <span class="number">3</span>); <span class="comment">// 从下标4位置开始 ，截取3个字符，拼接到字符串末尾</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;str3 = &quot;</span> &lt;&lt; str3 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    test01();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="string-查找和替换"><a href="#string-查找和替换" class="headerlink" title="string 查找和替换"></a>string 查找和替换</h4><ul><li>函数原型：<ul><li><code>int find(const string&amp; str, int pos = 0) const;</code>：查找 str 第一次出现位置，从 pos 开始查找</li><li><code>int find(const char* s, int pos = 0) const;</code>：查找 s 第一次出现位置，从pos开始查找</li><li><code>int find(const char* s, int pos, int n) const;</code>：从 pos 位置查找 s 的前 n 个字符第一次位置</li><li><code>int find(const char c, int pos = 0) const;</code>：查找字符 c 第一次出现位置</li><li><code>int rfind(const string&amp; str, int pos = npos) const;</code>：从右查找 str 最后一次位置，从 pos 开始查找</li><li><code>int rfind(const char* s, int pos = npos) const;</code>：从右查找 s 最后一次出现位置，从 pos 开始查找</li><li><code>int rfind(const char* s, int pos, int n) const;</code>：从右从 pos 查找 s 的前 n 个字符最后一次位置</li><li><code>int rfind(const char c, int pos = 0) const;</code>：从右查找字符 c 最后一次出现位置</li><li><code>string&amp; replace(int pos, int n, const string&amp; str);</code>：替换从 pos 开始 n 个字符为字符串 str</li><li><code>string&amp; replace(int pos, int n, const char* s);</code>：替换从 pos 开始的 n 个字符为字符串 s</li></ul></li><li>find 找到字符串后返回查找的第一个字符位置，找不到返回 -1</li><li>replace 在替换时，要指定起始位置，替换的目标长度，替换的结果</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//查找和替换</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//查找</span></span><br><span class="line">    <span class="built_in">string</span> str1 = <span class="string">&quot;abcdefgde&quot;</span>;</span><br><span class="line">    <span class="keyword">int</span> pos = str1.find(<span class="string">&quot;de&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (pos == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;未找到&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;pos = &quot;</span> &lt;&lt; pos &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pos = str1.rfind(<span class="string">&quot;de&quot;</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;pos = &quot;</span> &lt;&lt; pos &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//替换</span></span><br><span class="line">    <span class="built_in">string</span> str1 = <span class="string">&quot;abcdefgde&quot;</span>;</span><br><span class="line">    str1.replace(<span class="number">1</span>, <span class="number">3</span>, <span class="string">&quot;1111&quot;</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;str1 = &quot;</span> &lt;&lt; str1 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    test01();</span><br><span class="line">    test02();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="string-字符串比较"><a href="#string-字符串比较" class="headerlink" title="string 字符串比较"></a>string 字符串比较</h4><ul><li>比较方式：比较字符的 ASCII 码值（意义不大）<ul><li>= 返回 0</li><li>&gt; 返回 1 </li><li>&lt; 返回 -1</li></ul></li><li>函数原型：<ul><li><code>int compare(const string&amp; s) const;</code>：与字符串 s 比较</li><li><code>int compare(const char* s) const;</code>：与字符串 s 比较</li></ul></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 字符串比较</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">string</span> s1 = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">    <span class="built_in">string</span> s2 = <span class="string">&quot;aello&quot;</span>;</span><br><span class="line">    <span class="keyword">int</span> ret = s1.compare(s2);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (ret == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;s1 等于 s2&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ret &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;s1 大于 s2&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;s1 小于 s2&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    test01();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="string-字符存取"><a href="#string-字符存取" class="headerlink" title="string 字符存取"></a>string 字符存取</h4><ul><li><p>string 中单个字符存取方式有两种</p><ul><li><code>char&amp; operator[](int n); </code>：通过 [] 方式取字符</li><li><code>char&amp; at(int n);   </code>：通过 at() 获取字符</li></ul></li><li><blockquote><p>可以直接使用增强 for 进行遍历</p></blockquote></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">string</span> str = <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">char</span> i : str) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//字符修改</span></span><br><span class="line">    str[<span class="number">0</span>] = <span class="string">&#x27;x&#x27;</span>;</span><br><span class="line">    str.at(<span class="number">1</span>) = <span class="string">&#x27;x&#x27;</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; str &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    test01();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="string-插入和删除"><a href="#string-插入和删除" class="headerlink" title="string 插入和删除"></a>string 插入和删除</h4><ul><li>函数原型：<ul><li><code>string&amp; insert(int pos, const char* s);</code>：插入字符串</li><li><code>string&amp; insert(int pos, const string&amp; str);</code>：插入字符串</li><li><code>string&amp; insert(int pos, int n, char c);</code>：在指定位置插入 n 个字符 c</li><li><code>string&amp; erase(int pos, int n = npos);</code>：删除从 Pos 开始的 n 个字符 </li></ul></li><li>注意：插入和删除的起始下标都是从 0 开始</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//字符串插入和删除</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">string</span> str = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">    </span><br><span class="line">    str.insert(<span class="number">1</span>, <span class="string">&quot;111&quot;</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; str &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">// h111ello</span></span><br><span class="line"></span><br><span class="line">    str.erase(<span class="number">1</span>, <span class="number">3</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; str &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">// h111ello</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    test01();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="string-子串"><a href="#string-子串" class="headerlink" title="string 子串"></a>string 子串</h4><ul><li>函数原型：<ul><li><code>string substr(int pos = 0, int n = npos) const;</code>：返回由 pos 开始的 n 个字符组成的字符串</li></ul></li><li>总结：灵活的运用求子串功能，可以在实际开发中获取有效的信息</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//子串</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 验证</span></span><br><span class="line">    <span class="built_in">string</span> str = <span class="string">&quot;abcdefg&quot;</span>;</span><br><span class="line">    <span class="built_in">string</span> subStr = str.substr(<span class="number">1</span>, <span class="number">3</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;subStr = &quot;</span> &lt;&lt; subStr &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">// subStr = bcd</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 应用</span></span><br><span class="line">    <span class="built_in">string</span> email = <span class="string">&quot;hello@sina.com&quot;</span>;</span><br><span class="line">    <span class="keyword">int</span> pos = email.find(<span class="string">&#x27;@&#x27;</span>);</span><br><span class="line">    <span class="built_in">string</span> username = email.substr(<span class="number">0</span>, pos);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;username: &quot;</span> &lt;&lt; username &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">// username: hello</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    test01();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="string-大小"><a href="#string-大小" class="headerlink" title="string 大小"></a>string 大小</h4><blockquote><ul><li><code>size()</code>：获得字符串的长度</li><li><code>capacity()</code>：获得该字符串的总空间大小</li></ul></blockquote><h3 id="vector-容器"><a href="#vector-容器" class="headerlink" title="vector 容器"></a>vector 容器</h3><h4 id="vector-基本概念"><a href="#vector-基本概念" class="headerlink" title="vector 基本概念"></a>vector 基本概念</h4><ul><li><p>功能：</p><ul><li>vector 数据结构和数组非常相似，也称为单端数组</li></ul></li><li><p>vector 与普通数组区别：</p><ul><li>不同之处在于数组是静态空间，而 vector 封装了动态扩展</li></ul></li><li><p>动态扩展：</p><ul><li>并不是在原空间之后续接新空间，而是找更大的内存空间，然后将原数据拷贝新空间，释放原空间</li></ul></li><li><p>vector 容器的迭代器是支持随机访问的迭代器</p></li><li><img src="/2022/1/C++-Part3/clip_image002.jpg" alt="说明: 2015-11-10_151152" style="zoom:150%;"></li></ul><h4 id="vector-构造函数"><a href="#vector-构造函数" class="headerlink" title="vector 构造函数"></a>vector 构造函数</h4><ul><li>函数原型：<ul><li><code>vector&lt;T&gt; v;</code>：采用模板实现类实现，默认构造函数</li><li><code>vector(v.begin(), v.end());</code>：将 [begin(), end()) 区间中的元素拷贝给本身。</li><li><code>vector(n, elem);</code>：构造函数将 n 个 elem 拷贝给本身。</li><li><code>vector(const vector &amp;vec);</code>：拷贝构造函数。</li></ul></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printVector</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> &amp;it : v) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v1;  <span class="comment">// 无参构造</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        v1.push_back(i);</span><br><span class="line">    &#125;</span><br><span class="line">    printVector(v1);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">v2</span><span class="params">(v1.begin(), v1.end())</span></span>;</span><br><span class="line">    printVector(v2);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">v3</span><span class="params">(<span class="number">10</span>, <span class="number">100</span>)</span></span>;</span><br><span class="line">    printVector(v3);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">v4</span><span class="params">(v3)</span></span>;</span><br><span class="line">    printVector(v4);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    test01();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="vector-赋值操作"><a href="#vector-赋值操作" class="headerlink" title="vector 赋值操作"></a>vector 赋值操作</h4><ul><li><p>函数原型：</p><ul><li><p><code>vector&amp; operator=(const vector &amp;vec);</code>：重载等号操作符</p></li><li><p><code>assign(beg, end);</code>：将[beg, end)区间中的数据拷贝赋值给本身。</p></li><li><p><code>assign(n, elem);</code>：将n个elem拷贝赋值给本身。</p></li></ul></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 赋值操作</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v1;  <span class="comment">// 无参构造</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        v1.push_back(i);</span><br><span class="line">    &#125;</span><br><span class="line">    printVector(v1);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v2;</span><br><span class="line">    v2 = v1;</span><br><span class="line">    printVector(v2);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v3;</span><br><span class="line">    v3.assign(v1.begin(), v1.end());</span><br><span class="line">    printVector(v3);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v4;</span><br><span class="line">    v4.assign(<span class="number">10</span>, <span class="number">100</span>);</span><br><span class="line">    printVector(v4);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    test01();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="vector-容量和大小"><a href="#vector-容量和大小" class="headerlink" title="vector 容量和大小"></a>vector 容量和大小</h4><ul><li>函数原型：<ul><li><code>empty();</code>：判断容器是否为空</li><li><code>capacity();</code>：返回容器的容量</li><li><code>size();</code>：返回容器中元素的个数</li><li><code>resize(int num, elem);</code>：重新指定容器的长度为 num<ul><li>若容器变长，则以 elem 填充新位置。若没有提供 elem，则填充默认值 0。</li><li>如果容器变短，则末尾超出容器长度的元素被删除。</li></ul></li></ul></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v1;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        v1.push_back(i);</span><br><span class="line">    &#125;</span><br><span class="line">    printVector(v1);</span><br><span class="line">    <span class="keyword">if</span> (v1.empty()) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;v1为空&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;v1不为空&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;v1的容量 = &quot;</span> &lt;&lt; v1.capacity() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;v1的大小 = &quot;</span> &lt;&lt; v1.size() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//resize 重新指定大小 ，若指定的更大，默认用0填充新位置，可以利用重载版本替换默认填充</span></span><br><span class="line">    v1.resize(<span class="number">15</span>, <span class="number">10</span>);</span><br><span class="line">    printVector(v1);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//resize 重新指定大小 ，若指定的更小，超出部分元素被删除</span></span><br><span class="line">    v1.resize(<span class="number">5</span>);</span><br><span class="line">    printVector(v1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    test01();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="vector-插入和删除"><a href="#vector-插入和删除" class="headerlink" title="vector 插入和删除"></a>vector 插入和删除</h4><ul><li>函数原型：<ul><li><code>push_back(ele);</code>：尾部插入元素 ele</li><li><code>pop_back();</code>：删除最后一个元素</li><li><code>insert(const_iterator pos, ele);</code>：迭代器指向位置 pos 插入元素 ele</li><li><code>insert(const_iterator pos, int count,ele);</code>：迭代器指向位置 pos 插入 count 个元素 ele</li><li><code>erase(const_iterator pos);</code>：删除迭代器指向的元素</li><li><code>erase(const_iterator start, const_iterator end);</code>：删除迭代器从 start 到 end 之间的元素</li><li><code>clear();</code>：删除容器中所有元素</li></ul></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//插入和删除</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v1;</span><br><span class="line"></span><br><span class="line">    v1.push_back(<span class="number">10</span>);</span><br><span class="line">    v1.push_back(<span class="number">20</span>);</span><br><span class="line">    v1.push_back(<span class="number">30</span>);</span><br><span class="line">    v1.push_back(<span class="number">40</span>);</span><br><span class="line">    v1.push_back(<span class="number">50</span>);  <span class="comment">// 尾插</span></span><br><span class="line">    printVector(v1);</span><br><span class="line"></span><br><span class="line">    v1.pop_back();  <span class="comment">// 尾删</span></span><br><span class="line">    printVector(v1);</span><br><span class="line"></span><br><span class="line">    v1.insert(v1.begin(), <span class="number">100</span>);  <span class="comment">// 插入</span></span><br><span class="line">    printVector(v1);</span><br><span class="line"></span><br><span class="line">    v1.insert(v1.begin(), <span class="number">2</span>, <span class="number">1000</span>);</span><br><span class="line">    printVector(v1);</span><br><span class="line"></span><br><span class="line">    v1.erase(v1.begin());  <span class="comment">// 删除</span></span><br><span class="line">    printVector(v1);</span><br><span class="line"></span><br><span class="line">    v1.erase(v1.begin(), v1.end());  <span class="comment">// 清空</span></span><br><span class="line">    v1.clear();</span><br><span class="line">    printVector(v1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    test01();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="vector-数据存取"><a href="#vector-数据存取" class="headerlink" title="vector 数据存取"></a>vector 数据存取</h4><ul><li><p>函数原型：</p><ul><li><code>at(int idx); </code>：返回索引 idx 所指的数据</li><li><code>operator[]; </code>：返回索引 idx 所指的数据</li><li><code>front(); </code>：返回容器中第一个数据元素</li><li><code>back();</code>：返回容器中最后一个数据元素</li></ul></li><li><blockquote><p>建议直接使用增强 for</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printVector</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;v)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> &amp;it : v) &#123;</span><br><span class="line">           <span class="built_in">cout</span> &lt;&lt; it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v1;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        v1.push_back(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; v1.size(); i++) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; v1[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; v1.size(); i++) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; v1.at(i) &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;v1的第一个元素为： &quot;</span> &lt;&lt; v1.front() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;v1的最后一个元素为： &quot;</span> &lt;&lt; v1.back() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    test01();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="vector-互换容器"><a href="#vector-互换容器" class="headerlink" title="vector 互换容器"></a>vector 互换容器</h4></li><li><p>函数原型：</p><ul><li><code>swap(vec);</code>：将 vec 与本身的元素互换</li></ul></li><li><p>总结：swap 可以使两个容器互换，可以达到实用的收缩内存效果（因为使用的当前容器的 size 来初始化了匿名对象）</p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v1;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        v1.push_back(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v2;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">10</span>; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">        v2.push_back(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//互换容器</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;互换前&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    printVector(v1);</span><br><span class="line">    printVector(v2);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;互换后&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    v1.swap(v2);</span><br><span class="line">    printVector(v1);</span><br><span class="line">    printVector(v2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100000</span>; i++) &#123;</span><br><span class="line">        v.push_back(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;v的大小为：&quot;</span> &lt;&lt; v.size() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;v的容量为：&quot;</span> &lt;&lt; v.capacity() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    v.resize(<span class="number">3</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;v的大小为：&quot;</span> &lt;&lt; v.size() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;v的容量为：&quot;</span> &lt;&lt; v.capacity() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//收缩内存</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(v).swap(v);  <span class="comment">// 匿名对象</span></span><br><span class="line">    v.shrink_to_fit();  <span class="comment">// 等价方法</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;v的大小为：&quot;</span> &lt;&lt; v.size() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;v的容量为：&quot;</span> &lt;&lt; v.capacity() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    test01();</span><br><span class="line">    test02();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="vector-预留空间"><a href="#vector-预留空间" class="headerlink" title="vector 预留空间"></a>vector 预留空间</h4><ul><li><p>函数原型：</p><ul><li><code>reserve(int len);</code>：容器预留 len 个元素长度，预留位置不初始化，元素不可访问。</li></ul></li><li><p>总结：如果数据量较大，可以一开始利用 reserve 预留空间，以免添加数据时不断复制扩张</p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">    <span class="comment">//预留空间</span></span><br><span class="line">    v.reserve(<span class="number">100000</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> *p = <span class="literal">nullptr</span>;  <span class="comment">// 追踪 vector 首地址</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100000</span>; i++) &#123;</span><br><span class="line">        v.push_back(i);</span><br><span class="line">        <span class="keyword">if</span> (p != &amp;v[<span class="number">0</span>]) &#123;</span><br><span class="line">            p = &amp;v[<span class="number">0</span>];</span><br><span class="line">            num++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;num:&quot;</span> &lt;&lt; num &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    test01();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="deque-容器"><a href="#deque-容器" class="headerlink" title="deque 容器"></a>deque 容器</h3><h4 id="deque-容器基本概念"><a href="#deque-容器基本概念" class="headerlink" title="deque 容器基本概念"></a>deque 容器基本概念</h4><ul><li><p>功能：</p><ul><li>双端数组，可以对头端进行插入删除操作</li></ul></li><li><p>deque 与 vector 区别：</p><ul><li>vector 对于头部的插入删除效率低，数据量越大，效率越低</li><li>deque 相对而言，对头部的插入删除速度回比 vector 快</li><li>vector 访问元素时的速度会比 deque 快</li></ul></li><li><p><img src="/2022/1/C++-Part3/clip_image002-1547547642923.jpg" alt="说明: 2015-11-19_204101"></p></li></ul><ul><li>deque 内部工作原理:<ul><li>deque 内部有个<strong>中控器</strong>，维护每段缓冲区中的内容，缓冲区中存放真实数据</li><li>中控器维护的是每个缓冲区的地址，使得使用 deque 时像一片连续的内存空间</li><li><img src="/2022/1/C++-Part3/clip_image002-1547547896341.jpg" alt="clip_image002-1547547896341"></li></ul></li></ul><ul><li>deque 容器的迭代器也是支持随机访问的</li></ul><h4 id="deque-构造函数"><a href="#deque-构造函数" class="headerlink" title="deque 构造函数"></a>deque 构造函数</h4><ul><li>函数原型：<ul><li><code>deque&lt;T&gt; deqT;</code>：默认构造形式</li><li><code>deque(beg, end);</code>：构造函数将 [beg, end) 区间中的元素拷贝给本身。</li><li><code>deque(n, elem);</code>：构造函数将 n 个 elem 拷贝给本身。</li><li><code>deque(const deque &amp;deq);</code>：拷贝构造函数</li></ul></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deque&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printDeque</span><span class="params">(<span class="keyword">const</span> <span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; &amp;d)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> it = d.begin(); it != d.end(); it++) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// deque构造</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; d1;  <span class="comment">// 无参构造函数</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        d1.push_back(i);</span><br><span class="line">    &#125;</span><br><span class="line">    printDeque(d1);</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; <span class="title">d2</span><span class="params">(d1.begin(), d1.end())</span></span>;</span><br><span class="line">    printDeque(d2);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; <span class="title">d3</span><span class="params">(<span class="number">10</span>, <span class="number">100</span>)</span></span>;</span><br><span class="line">    printDeque(d3);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; d4 = d3;</span><br><span class="line">    printDeque(d4);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    test01();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="deque-赋值操作"><a href="#deque-赋值操作" class="headerlink" title="deque 赋值操作"></a>deque 赋值操作</h4><ul><li><p>函数原型：</p><ul><li><p><code>deque&amp; operator=(const deque&amp; deq); </code>：重载等号操作符</p></li><li><p><code>assign(beg, end);</code>：将 [beg, end) 区间中的数据拷贝赋值给本身。</p></li><li><p><code>assign(n, elem);</code>：将 n 个 elem 拷贝赋值给本身。</p></li></ul></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 赋值操作</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; d1;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        d1.push_back(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; d2;</span><br><span class="line">    d2 = d1;</span><br><span class="line">    printDeque(d2);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; d3;</span><br><span class="line">    d3.assign(d1.begin(), d1.end());</span><br><span class="line">    printDeque(d3);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; d4;</span><br><span class="line">    d4.assign(<span class="number">10</span>, <span class="number">100</span>);</span><br><span class="line">    printDeque(d4);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    test01();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="deque-大小操作"><a href="#deque-大小操作" class="headerlink" title="deque 大小操作"></a>deque 大小操作</h4><ul><li><p>函数原型：</p><ul><li><p><code>deque.empty();</code>：判断容器是否为空</p></li><li><p><code>deque.size();</code>：返回容器中元素的个数</p></li><li><p><code>deque.resize(num, elem);</code>：重新指定容器的长度为 num，若容器变长，</p></li><li><p>若容器变长，则以 elem 值填充新位置。若没有提供 elem，则以默认值填充新位置。</p><ul><li>如果容器变短，则末尾超出容器长度的元素被删除。</li></ul></li></ul></li><li><p>deque 没有容量的概念</p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 大小操作</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; d1;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        d1.push_back(i);</span><br><span class="line">    &#125;</span><br><span class="line">    printDeque(d1);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断容器是否为空</span></span><br><span class="line">    <span class="keyword">if</span> (d1.empty()) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;d1为空!&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;d1不为空!&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="comment">//统计大小</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;d1的大小为：&quot;</span> &lt;&lt; d1.size() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//重新指定大小</span></span><br><span class="line">    d1.resize(<span class="number">15</span>, <span class="number">1</span>);</span><br><span class="line">    printDeque(d1);</span><br><span class="line"></span><br><span class="line">    d1.resize(<span class="number">5</span>);</span><br><span class="line">    printDeque(d1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    test01();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="deque-插入和删除"><a href="#deque-插入和删除" class="headerlink" title="deque 插入和删除"></a>deque 插入和删除</h4><ul><li><p>函数原型：</p><ul><li><p>两端插入操作：</p><ul><li><code>push_back(elem);</code>：在容器尾部添加一个数据</li><li><code>push_front(elem);</code>：在容器头部插入一个数据</li><li><code>pop_back();</code>：删除容器最后一个数据</li><li><code>pop_front();</code>：删除容器第一个数据</li></ul></li><li><p>指定位置操作：</p><ul><li><code>insert(pos, elem);</code>：在 pos 位置插入一个 elem 元素的拷贝，返回新数据的位置。</li><li><code>insert(pos, n, elem);</code>：在 pos 位置插入 n 个 elem 数据，无返回值。</li><li><code>insert(pos, beg, end);</code>：在 pos 位置插入 [beg,end) 区间的数据，无返回值。</li><li><code>clear();</code>：清空容器的所有数据</li><li><code>erase(beg, end);</code>：删除 [beg,end) 区间的数据，返回下一个数据的位置。</li><li><code>erase(pos);</code>：删除 pos 位置的数据，返回下一个数据的位置。</li></ul></li></ul></li><li><p><strong>插入和删除提供的位置是迭代器</strong></p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//两端操作</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; d;</span><br><span class="line"></span><br><span class="line">    d.push_back(<span class="number">10</span>);</span><br><span class="line">    d.push_back(<span class="number">20</span>);  <span class="comment">//尾插</span></span><br><span class="line">    d.push_front(<span class="number">100</span>);</span><br><span class="line">    d.push_front(<span class="number">200</span>);  <span class="comment">//头插</span></span><br><span class="line">    printDeque(d);  <span class="comment">// 200 100 10 20</span></span><br><span class="line"></span><br><span class="line">    d.pop_back();  <span class="comment">//尾删</span></span><br><span class="line">    d.pop_front();  <span class="comment">//头删</span></span><br><span class="line">    printDeque(d);  <span class="comment">// 100 10</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//插入</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; d;</span><br><span class="line">    d.push_back(<span class="number">10</span>);</span><br><span class="line">    d.push_back(<span class="number">20</span>);</span><br><span class="line">    d.push_front(<span class="number">100</span>);</span><br><span class="line">    d.push_front(<span class="number">200</span>);</span><br><span class="line"></span><br><span class="line">    d.insert(d.begin(), <span class="number">1000</span>);</span><br><span class="line">    printDeque(d);  <span class="comment">// 1000 200 100 10 20</span></span><br><span class="line"></span><br><span class="line">    d.insert(d.begin(), <span class="number">2</span>, <span class="number">10000</span>);</span><br><span class="line">    printDeque(d);  <span class="comment">// 10000 10000 1000 200 100 10 20</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; d2;</span><br><span class="line">    d2.push_back(<span class="number">1</span>);</span><br><span class="line">    d2.push_back(<span class="number">2</span>);</span><br><span class="line">    d2.push_back(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    d.insert(d.begin(), d2.begin(), d2.end());</span><br><span class="line">    printDeque(d);  <span class="comment">// 1 2 3 10000 10000 1000 200 100 10 20</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test03</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; d;</span><br><span class="line">    d.push_back(<span class="number">10</span>);</span><br><span class="line">    d.push_back(<span class="number">20</span>);</span><br><span class="line">    d.push_front(<span class="number">100</span>);</span><br><span class="line">    d.push_front(<span class="number">200</span>);</span><br><span class="line"></span><br><span class="line">    d.erase(d.begin());</span><br><span class="line">    printDeque(d);  <span class="comment">// 100 10 20</span></span><br><span class="line"></span><br><span class="line">    d.erase(d.begin(), d.end());</span><br><span class="line">    d.clear();</span><br><span class="line">    printDeque(d);  <span class="comment">// 空</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    test01();</span><br><span class="line">    test02();</span><br><span class="line">    test03();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="deque-数据存取"><a href="#deque-数据存取" class="headerlink" title="deque 数据存取"></a>deque 数据存取</h4><ul><li><p>函数原型：</p><ul><li><code>at(int idx); </code>：返回索引 idx 所指的数据</li><li><code>operator[]; </code>：返回索引 idx 所指的数据</li><li><code>front(); </code>：返回容器中第一个数据元素</li><li><code>back();</code>：返回容器中最后一个数据元素</li></ul></li><li><blockquote><p>可以直接使用增强 for</p></blockquote></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//数据存取</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; d;</span><br><span class="line">    d.push_back(<span class="number">10</span>);</span><br><span class="line">    d.push_back(<span class="number">20</span>);</span><br><span class="line">    d.push_front(<span class="number">100</span>);</span><br><span class="line">    d.push_front(<span class="number">200</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; d.size(); i++) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; d[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; d.size(); i++) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; d.at(i) &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;front:&quot;</span> &lt;&lt; d.front() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;back:&quot;</span> &lt;&lt; d.back() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    test01();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="deque-排序"><a href="#deque-排序" class="headerlink" title="deque 排序"></a>deque 排序</h4><ul><li>算法：<ul><li><code>sort(iterator beg, iterator end)</code>：对 beg 和 end 区间内元素进行排序</li></ul></li><li>使用时包含头文件 algorithm</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; d;</span><br><span class="line">    d.push_back(<span class="number">10</span>);</span><br><span class="line">    d.push_back(<span class="number">20</span>);</span><br><span class="line">    d.push_front(<span class="number">100</span>);</span><br><span class="line">    d.push_front(<span class="number">200</span>);</span><br><span class="line"></span><br><span class="line">    printDeque(d);</span><br><span class="line">    sort(d.begin(), d.end());</span><br><span class="line">    printDeque(d);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    test01();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="stack-容器"><a href="#stack-容器" class="headerlink" title="stack 容器"></a>stack 容器</h3><h4 id="stack-基本概念"><a href="#stack-基本概念" class="headerlink" title="stack 基本概念"></a>stack 基本概念</h4><ul><li><p>概念：stack 是一种<strong>先进后出</strong>（First In Last Out, FILO）的数据结构，它只有一个出口</p></li><li><p><img src="/2022/1/C++-Part3/clip_image002-1547604555425.jpg" alt="说明: 2015-11-15_195707"></p></li><li><p>栈中只有顶端的元素才可以被外界使用，因此栈不允许有遍历行为</p></li></ul><h4 id="stack-常用接口"><a href="#stack-常用接口" class="headerlink" title="stack 常用接口"></a>stack 常用接口</h4><ul><li><p>构造函数：</p><ul><li><code>stack&lt;T&gt; stk;</code>：stack 采用模板类实现，stack 对象的默认构造形式</li><li><code>stack(const stack &amp;stk);</code>：拷贝构造函数</li></ul></li><li><p>赋值操作：</p><ul><li><code>stack&amp; operator=(const stack &amp;stk);</code>：重载等号操作符</li></ul></li><li><p>数据存取：</p><ul><li><code>push(elem);</code>：向栈顶添加元素</li><li><code>pop();</code>：从栈顶移除第一个元素</li><li><code>top(); </code>：返回栈顶元素</li></ul></li><li><p>大小操作：</p><ul><li><code>empty();</code>：判断堆栈是否为空</li><li><code>size(); </code>：返回栈的大小</li></ul></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//栈容器常用接口</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建栈容器 栈容器必须符合先进后出</span></span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 向栈中添加元素，叫做 压栈 入栈</span></span><br><span class="line">    s.push(<span class="number">10</span>);</span><br><span class="line">    s.push(<span class="number">20</span>);</span><br><span class="line">    s.push(<span class="number">30</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!s.empty()) &#123;</span><br><span class="line">        <span class="comment">//输出栈顶元素</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;栈顶元素为： &quot;</span> &lt;&lt; s.top() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="comment">//弹出栈顶元素</span></span><br><span class="line">        s.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;栈的大小为：&quot;</span> &lt;&lt; s.size() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    test01();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="queue-容器"><a href="#queue-容器" class="headerlink" title="queue 容器"></a>queue 容器</h3><h4 id="queue-基本概念"><a href="#queue-基本概念" class="headerlink" title="queue 基本概念"></a>queue 基本概念</h4><ul><li><p>概念：Queue 是一种<strong>先进先出</strong>（First In First Out, FIFO）的数据结构，它有两个出口</p></li><li><p><img src="/2022/1/C++-Part3/clip_image002-1547606475892.jpg" alt="说明: 2015-11-15_214429"></p></li><li><p>队列容器允许从一端新增元素，从另一端移除元素</p></li><li><p>队列中只有队头和队尾才可以被外界使用，因此队列不允许有遍历行为</p></li></ul><h4 id="queue-常用接口"><a href="#queue-常用接口" class="headerlink" title="queue 常用接口"></a>queue 常用接口</h4><ul><li><p>构造函数：</p><ul><li><code>queue&lt;T&gt; que;</code>：queue 采用模板类实现，queue 对象的默认构造形式</li><li><code>queue(const queue &amp;que);</code>：拷贝构造函数</li></ul></li><li><p>赋值操作：</p><ul><li><code>queue&amp; operator=(const queue &amp;que);</code>：重载等号操作符</li></ul></li><li><p>数据存取：</p><ul><li><code>push(elem);</code>：往队尾添加元素</li><li><code>pop();</code>：从队头移除第一个元素</li><li><code>back();</code>：返回最后一个元素</li><li><code>front(); </code>：返回第一个元素</li></ul></li><li><p>大小操作：</p><ul><li><code>empty();</code>：判断堆栈是否为空</li><li><code>size(); </code>：返回栈的大小</li></ul></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">string</span> m_Name;</span><br><span class="line">    <span class="keyword">int</span> m_Age;</span><br><span class="line"></span><br><span class="line">    Person(<span class="built_in">string</span> name, <span class="keyword">int</span> age) &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;m_Name = name;</span><br><span class="line">        <span class="keyword">this</span>-&gt;m_Age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建队列</span></span><br><span class="line">    <span class="built_in">queue</span>&lt;Person&gt; q;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 向队列中添加元素  入队操作</span></span><br><span class="line">    q.push(Person(<span class="string">&quot;唐僧&quot;</span>, <span class="number">30</span>));</span><br><span class="line">    q.push(Person(<span class="string">&quot;孙悟空&quot;</span>, <span class="number">1000</span>));</span><br><span class="line">    q.push(Person(<span class="string">&quot;猪八戒&quot;</span>, <span class="number">900</span>));</span><br><span class="line">    q.push(Person(<span class="string">&quot;沙僧&quot;</span>, <span class="number">800</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 队列不提供迭代器，更不支持随机访问</span></span><br><span class="line">    <span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">        <span class="comment">//输出队头元素</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;队头元素-- 姓名： &quot;</span> &lt;&lt; q.front().m_Name</span><br><span class="line">             &lt;&lt; <span class="string">&quot; 年龄： &quot;</span> &lt;&lt; q.front().m_Age &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;队尾元素-- 姓名： &quot;</span> &lt;&lt; q.back().m_Name</span><br><span class="line">             &lt;&lt; <span class="string">&quot; 年龄： &quot;</span> &lt;&lt; q.back().m_Age &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="comment">//弹出队头元素</span></span><br><span class="line">        q.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;队列大小为：&quot;</span> &lt;&lt; q.size() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    test01();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="list容器"><a href="#list容器" class="headerlink" title="list容器"></a>list容器</h3><h4 id="list-基本概念"><a href="#list-基本概念" class="headerlink" title="list 基本概念"></a>list 基本概念</h4><ul><li><p>链表（list）是一种物理存储单元上非连续的存储结构，数据元素的逻辑顺序是通过链表中的指针链接实现的</p><ul><li>链表的组成：链表由一系列<strong>结点</strong>组成</li><li>结点的组成：一个是存储数据元素的<strong>数据域</strong>，另一个是存储下一个结点地址的<strong>指针域</strong></li></ul></li><li><p>STL 中的链表是一个双向循环链表</p><ul><li><img src="/2022/1/C++-Part3/clip_image002-1547608564071.jpg" alt="说明: 2015-11-15_225145"></li></ul></li><li><p>由于链表的存储方式并不是连续的内存空间，因此链表 list 中的迭代器只支持前移和后移，属于<strong>双向迭代器</strong></p></li><li><p>list 的优点：</p><ul><li>采用动态存储分配，不会造成内存浪费和溢出</li><li>链表执行插入和删除操作十分方便，修改指针即可，不需要移动大量元素</li></ul></li><li><p>list 的缺点：</p><ul><li>链表灵活，但是空间（指针域）和 时间（遍历）额外耗费较大</li></ul></li><li><p>List 有一个重要的性质，插入操作和删除操作都不会造成原有 list 迭代器的失效，这在 vector 是不成立的。</p></li><li><p>总结：STL 中 <strong>List 和 vector 是两个最常被使用的容器</strong>，各有优缺点</p></li></ul><h4 id="list-构造函数"><a href="#list-构造函数" class="headerlink" title="list 构造函数"></a>list 构造函数</h4><ul><li>函数原型：<ul><li><code>list&lt;T&gt; lst;</code>：list采用采用模板类实现,对象的默认构造形式：</li><li><code>list(beg,end);</code>：构造函数将[beg, end)区间中的元素拷贝给本身。</li><li><code>list(n,elem);</code>：构造函数将n个elem拷贝给本身。</li><li><code>list(const list &amp;lst);</code>：拷贝构造函数。</li></ul></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printList</span><span class="params">(<span class="keyword">const</span> <span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; &amp;L)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> it : L) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; L1;</span><br><span class="line">    L1.push_back(<span class="number">10</span>);</span><br><span class="line">    L1.push_back(<span class="number">20</span>);</span><br><span class="line">    L1.push_back(<span class="number">30</span>);</span><br><span class="line">    L1.push_back(<span class="number">40</span>);</span><br><span class="line"></span><br><span class="line">    printList(L1);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; <span class="title">L2</span><span class="params">(L1.begin(), L1.end())</span></span>;</span><br><span class="line">    printList(L2);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; <span class="title">L3</span><span class="params">(L2)</span></span>;</span><br><span class="line">    printList(L3);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; <span class="title">L4</span><span class="params">(<span class="number">10</span>, <span class="number">1000</span>)</span></span>;</span><br><span class="line">    printList(L4);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    test01();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="list-赋值和交换"><a href="#list-赋值和交换" class="headerlink" title="list 赋值和交换"></a>list 赋值和交换</h4><ul><li>函数原型：<ul><li><code>assign(beg, end);</code>：将 [beg, end) 区间中的数据拷贝赋值给本身。</li><li><code>assign(n, elem);</code>：将 n 个 elem 拷贝赋值给本身。</li><li><code>list&amp; operator=(const list &amp;lst);</code>：重载等号操作符</li><li><code>swap(lst);</code>：将lst与本身的元素互换。</li></ul></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 赋值</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; L1;</span><br><span class="line">    L1.push_back(<span class="number">10</span>);</span><br><span class="line">    L1.push_back(<span class="number">20</span>);</span><br><span class="line">    L1.push_back(<span class="number">30</span>);</span><br><span class="line">    L1.push_back(<span class="number">40</span>);</span><br><span class="line">    printList(L1);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; L2;</span><br><span class="line">    L2 = L1;</span><br><span class="line">    printList(L2);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; L3;</span><br><span class="line">    L3.assign(L2.begin(), L2.end());</span><br><span class="line">    printList(L3);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; L4;</span><br><span class="line">    L4.assign(<span class="number">10</span>, <span class="number">100</span>);</span><br><span class="line">    printList(L4);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 交换</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; L1;</span><br><span class="line">    L1.push_back(<span class="number">10</span>);</span><br><span class="line">    L1.push_back(<span class="number">20</span>);</span><br><span class="line">    L1.push_back(<span class="number">30</span>);</span><br><span class="line">    L1.push_back(<span class="number">40</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; L2;</span><br><span class="line">    L2.assign(<span class="number">10</span>, <span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;交换前： &quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    printList(L1);</span><br><span class="line">    printList(L2);</span><br><span class="line"></span><br><span class="line">    L1.swap(L2);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;交换后： &quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    printList(L1);</span><br><span class="line">    printList(L2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    test01();</span><br><span class="line">    test02();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="list-大小操作"><a href="#list-大小操作" class="headerlink" title="list 大小操作"></a>list 大小操作</h4><ul><li><p>函数原型：</p><ul><li><p><code>size(); </code>：返回容器中元素的个数</p></li><li><p><code>empty(); </code>：判断容器是否为空</p></li><li><p><code>resize(num);</code>：重新指定容器的长度为 num</p><ul><li>若容器变长，则以 elem 值填充新位置。若没有提供 elem，则以默认值填充新位置。</li><li>若容器变短，则末尾超出容器长度的元素被删除。</li></ul></li></ul></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//大小操作</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; L1;</span><br><span class="line">    L1.push_back(<span class="number">10</span>);</span><br><span class="line">    L1.push_back(<span class="number">20</span>);</span><br><span class="line">    L1.push_back(<span class="number">30</span>);</span><br><span class="line">    L1.push_back(<span class="number">40</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (L1.empty()) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;L1为空&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;L1不为空&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;L1的大小为： &quot;</span> &lt;&lt; L1.size() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//重新指定大小</span></span><br><span class="line">    L1.resize(<span class="number">10</span>);</span><br><span class="line">    printList(L1);</span><br><span class="line"></span><br><span class="line">    L1.resize(<span class="number">2</span>);</span><br><span class="line">    printList(L1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    test01();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="list-插入和删除"><a href="#list-插入和删除" class="headerlink" title="list 插入和删除"></a>list 插入和删除</h4><ul><li>函数原型：<ul><li><code>push_back(elem);</code>：在容器尾部加入一个元素</li><li><code>pop_back();</code>：删除容器中最后一个元素</li><li><code>push_front(elem);</code>：在容器开头插入一个元素</li><li><code>pop_front();</code>：从容器开头移除第一个元素</li><li><code>insert(pos, elem);</code>：在 pos 位置插 elem 元素的拷贝，返回新数据的位置。</li><li><code>insert(pos, n, elem);</code>：在 pos 位置插入 n 个 elem 数据，无返回值。</li><li><code>insert(pos, beg, end);</code>：在 pos 位置插入 [beg,end) 区间的数据，无返回值。</li><li><code>clear();</code>：移除容器的所有数据</li><li><code>erase(beg, end);</code>：删除 [beg,end) 区间的数据，返回下一个数据的位置。</li><li><code>erase(pos);</code>：删除 pos 位置的数据，返回下一个数据的位置。</li><li><code>remove(elem);</code>：删除容器中所有与 elem 值匹配的元素。</li></ul></li><li><strong>插入和删除提供的位置是迭代器</strong></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//插入和删除</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; L;</span><br><span class="line"></span><br><span class="line">    L.push_back(<span class="number">10</span>);</span><br><span class="line">    L.push_back(<span class="number">20</span>);</span><br><span class="line">    L.push_back(<span class="number">30</span>);  <span class="comment">// 尾插</span></span><br><span class="line">    L.push_front(<span class="number">100</span>);</span><br><span class="line">    L.push_front(<span class="number">200</span>);</span><br><span class="line">    L.push_front(<span class="number">300</span>);  <span class="comment">// 头插</span></span><br><span class="line">    printList(L);  <span class="comment">// 300 200 100 10 20 30</span></span><br><span class="line"></span><br><span class="line">    L.pop_back();  <span class="comment">// 尾删</span></span><br><span class="line">    printList(L);  <span class="comment">// 300 200 100 10 20</span></span><br><span class="line">    </span><br><span class="line">    L.pop_front();  <span class="comment">// 头删</span></span><br><span class="line">    printList(L);  <span class="comment">// 200 100 10 20</span></span><br><span class="line">    </span><br><span class="line">    L.insert(++L.begin(), <span class="number">1000</span>);  <span class="comment">// 插入</span></span><br><span class="line">    printList(L);  <span class="comment">// 200 1000 100 10 20</span></span><br><span class="line">    </span><br><span class="line">    L.erase(++L.begin());  <span class="comment">//删除</span></span><br><span class="line">    printList(L);  <span class="comment">// 200 100 10 20</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//移除</span></span><br><span class="line">    L.push_back(<span class="number">10000</span>);</span><br><span class="line">    L.push_back(<span class="number">10000</span>);</span><br><span class="line">    L.push_back(<span class="number">10000</span>);</span><br><span class="line">    printList(L);  <span class="comment">// 200 100 10 20 10000 10000 10000</span></span><br><span class="line">    L.remove(<span class="number">10000</span>);</span><br><span class="line">    printList(L);  <span class="comment">// 200 100 10 20</span></span><br><span class="line">    </span><br><span class="line">    L.clear();  <span class="comment">//清空</span></span><br><span class="line">    printList(L);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    test01();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="list-数据存取"><a href="#list-数据存取" class="headerlink" title="list 数据存取"></a>list 数据存取</h4><ul><li>函数原型：<ul><li><code>front();</code>：返回第一个元素。</li><li><code>back();</code>：返回最后一个元素。</li></ul></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 数据存取</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; L1;</span><br><span class="line">    L1.push_back(<span class="number">10</span>);</span><br><span class="line">    L1.push_back(<span class="number">20</span>);</span><br><span class="line">    L1.push_back(<span class="number">30</span>);</span><br><span class="line">    L1.push_back(<span class="number">40</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//cout &lt;&lt; L1.at(0) &lt;&lt; endl;  // 错误 不支持at访问数据</span></span><br><span class="line">    <span class="comment">//cout &lt;&lt; L1[0] &lt;&lt; endl;  // 错误  不支持[]方式访问数据</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;第一个元素为： &quot;</span> &lt;&lt; L1.front() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;最后一个元素为： &quot;</span> &lt;&lt; L1.back() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// list容器的迭代器是双向迭代器，不支持随机访问</span></span><br><span class="line">    <span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt;::iterator it = L1.begin();</span><br><span class="line">    <span class="comment">//it = it + 1;  // 错误，不可以跳跃访问，即使是+1</span></span><br><span class="line">    it++;  <span class="comment">// 只能不断 ++ 才能能够移动迭代器</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    test01();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="list-反转和排序"><a href="#list-反转和排序" class="headerlink" title="list 反转和排序"></a>list 反转和排序</h4><ul><li>函数原型：<ul><li><code>reverse();</code>：反转链表</li><li><code>sort();</code>：链表排序</li></ul></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">myCompare</span><span class="params">(<span class="keyword">int</span> val1, <span class="keyword">int</span> val2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> val1 &gt; val2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 反转和排序</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; L;</span><br><span class="line">    L.push_back(<span class="number">90</span>);</span><br><span class="line">    L.push_back(<span class="number">30</span>);</span><br><span class="line">    L.push_back(<span class="number">20</span>);</span><br><span class="line">    L.push_back(<span class="number">70</span>);</span><br><span class="line">    printList(L);  <span class="comment">// 90 30 20 70</span></span><br><span class="line"></span><br><span class="line">    L.reverse();  <span class="comment">// 反转容器的元素</span></span><br><span class="line">    printList(L);  <span class="comment">// 70 20 30 90</span></span><br><span class="line"></span><br><span class="line">    L.sort(); <span class="comment">// 默认的排序规则 从小到大</span></span><br><span class="line">    printList(L);  <span class="comment">// 20 30 70 90</span></span><br><span class="line"></span><br><span class="line">    L.sort(myCompare); <span class="comment">// 指定规则，从大到小</span></span><br><span class="line">    printList(L);  <span class="comment">// 90 70 30 20</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    test01();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="set-multiset-容器"><a href="#set-multiset-容器" class="headerlink" title="set/multiset 容器"></a>set/multiset 容器</h3><h4 id="set-基本概念"><a href="#set-基本概念" class="headerlink" title="set 基本概念"></a>set 基本概念</h4><ul><li><p>简介：</p><ul><li>所有元素都会在插入时自动被排序</li></ul></li><li><p>本质：</p><ul><li>set/multiset 属于<strong>关联式容器</strong>，底层结构是用<strong>二叉树</strong>实现。</li></ul></li><li><p>set 和 multiset 区别：</p><ul><li>set <strong>不允许</strong>容器中有重复的元素</li><li>multiset <strong>允许</strong>容器中有重复的元素</li></ul></li></ul><h4 id="set-构造和赋值"><a href="#set-构造和赋值" class="headerlink" title="set 构造和赋值"></a>set 构造和赋值</h4><ul><li><p>构造：</p><ul><li><code>set&lt;T&gt; st;</code>：默认构造函数：</li><li><code>set(const set &amp;st);</code>：拷贝构造函数</li></ul></li><li><p>赋值：</p><ul><li><code>set&amp; operator=(const set &amp;st);</code>：重载等号操作符</li></ul></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printSet</span><span class="params">(<span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; &amp;s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> it : s) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//构造和赋值</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; s1;</span><br><span class="line"></span><br><span class="line">    s1.insert(<span class="number">10</span>);</span><br><span class="line">    s1.insert(<span class="number">30</span>);</span><br><span class="line">    s1.insert(<span class="number">20</span>);</span><br><span class="line">    s1.insert(<span class="number">40</span>);</span><br><span class="line">    printSet(s1);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//拷贝构造</span></span><br><span class="line">    <span class="function"><span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; <span class="title">s2</span><span class="params">(s1)</span></span>;</span><br><span class="line">    printSet(s2);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//赋值</span></span><br><span class="line">    <span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; s3;</span><br><span class="line">    s3 = s2;</span><br><span class="line">    printSet(s3);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    test01();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="set-大小和交换"><a href="#set-大小和交换" class="headerlink" title="set 大小和交换"></a>set 大小和交换</h4><ul><li>函数原型：<ul><li><code>size();</code>：返回容器中元素的数目</li><li><code>empty();</code>：判断容器是否为空</li><li><code>swap(st);</code>：交换两个集合容器</li></ul></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 大小</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; s1;</span><br><span class="line"></span><br><span class="line">    s1.insert(<span class="number">10</span>);</span><br><span class="line">    s1.insert(<span class="number">30</span>);</span><br><span class="line">    s1.insert(<span class="number">20</span>);</span><br><span class="line">    s1.insert(<span class="number">40</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (s1.empty()) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;s1为空&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;s1不为空&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;s1的大小为： &quot;</span> &lt;&lt; s1.size() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 交换</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; s1;</span><br><span class="line">    s1.insert(<span class="number">10</span>);</span><br><span class="line">    s1.insert(<span class="number">30</span>);</span><br><span class="line">    s1.insert(<span class="number">20</span>);</span><br><span class="line">    s1.insert(<span class="number">40</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; s2;</span><br><span class="line">    s2.insert(<span class="number">100</span>);</span><br><span class="line">    s2.insert(<span class="number">300</span>);</span><br><span class="line">    s2.insert(<span class="number">200</span>);</span><br><span class="line">    s2.insert(<span class="number">400</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;交换前&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    printSet(s1);</span><br><span class="line">    printSet(s2);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;交换后&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    s1.swap(s2);</span><br><span class="line">    printSet(s1);</span><br><span class="line">    printSet(s2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    test01();</span><br><span class="line">    test02();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="set-插入和删除"><a href="#set-插入和删除" class="headerlink" title="set 插入和删除"></a>set 插入和删除</h4><ul><li>函数原型：<ul><li><code>insert(elem);</code>：在容器中插入元素。</li><li><code>clear();</code>：清除所有元素</li><li><code>erase(pos);</code>：删除 pos 迭代器所指的元素，返回下一个元素的迭代器。</li><li><code>erase(beg, end);</code>：删除区间 [beg,end) 的所有元素 ，返回下一个元素的迭代器。</li><li><code>erase(elem);</code>：删除容器中值为 elem 的元素。</li></ul></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 插入和删除</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; s1;</span><br><span class="line">    <span class="comment">//插入</span></span><br><span class="line">    s1.insert(<span class="number">10</span>);</span><br><span class="line">    s1.insert(<span class="number">30</span>);</span><br><span class="line">    s1.insert(<span class="number">20</span>);</span><br><span class="line">    s1.insert(<span class="number">40</span>);</span><br><span class="line">    printSet(s1);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//删除</span></span><br><span class="line">    s1.erase(s1.begin());</span><br><span class="line">    printSet(s1);</span><br><span class="line"></span><br><span class="line">    s1.erase(<span class="number">30</span>);</span><br><span class="line">    printSet(s1);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//清空</span></span><br><span class="line">    <span class="comment">//s1.erase(s1.begin(), s1.end());</span></span><br><span class="line">    s1.clear();</span><br><span class="line">    printSet(s1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    test01();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="set-查找和统计"><a href="#set-查找和统计" class="headerlink" title="set 查找和统计"></a>set 查找和统计</h4><ul><li>函数原型：<ul><li><code>find(key);</code>：查找 key 是否存在，若存在，返回该键的元素的迭代器；若不存在，返回 <code>set.end();</code>。</li><li><code>count(key);</code>：统计 key 的元素个数（对于set，结果为 0 或者 1）</li></ul></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 查找和统计</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; s1;</span><br><span class="line">    s1.insert(<span class="number">10</span>);</span><br><span class="line">    s1.insert(<span class="number">30</span>);</span><br><span class="line">    s1.insert(<span class="number">20</span>);</span><br><span class="line">    s1.insert(<span class="number">40</span>);</span><br><span class="line">  </span><br><span class="line">    <span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt;::iterator pos = s1.find(<span class="number">30</span>);  <span class="comment">// 查找</span></span><br><span class="line">    <span class="keyword">if</span> (pos != s1.end()) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;找到了元素 ： &quot;</span> &lt;&lt; *pos &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;未找到元素&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> num = s1.count(<span class="number">30</span>);  <span class="comment">// 统计</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;num = &quot;</span> &lt;&lt; num &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    test01();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="set-和-multiset-区别"><a href="#set-和-multiset-区别" class="headerlink" title="set 和 multiset 区别"></a>set 和 multiset 区别</h4><ul><li>区别：<ul><li>set 不可以插入重复数据，而 multiset 可以插入重复数据</li><li>set 插入数据会返回<strong>迭代器与结果的对组</strong> <code>pair&lt;set&lt;int&gt;::iterator, bool&gt;</code> ，取 <code>.second</code> 表示插入是否成功</li><li>multiset 插入数据时，仅返回插入结果的迭代器</li></ul></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// set和multiset区别</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line">    <span class="built_in">pair</span>&lt;<span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt;::iterator, <span class="keyword">bool</span>&gt; ret = s.insert(<span class="number">10</span>);</span><br><span class="line">    <span class="keyword">if</span> (ret.second) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;第一次插入成功!&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;第一次插入失败!&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ret = s.insert(<span class="number">10</span>);</span><br><span class="line">    <span class="keyword">if</span> (ret.second) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;第二次插入成功!&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;第二次插入失败!&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// multiset</span></span><br><span class="line">    <span class="built_in">multiset</span>&lt;<span class="keyword">int</span>&gt; ms;</span><br><span class="line">    ms.insert(<span class="number">10</span>);</span><br><span class="line">    ms.insert(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> m : ms) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; m &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    test01();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="pair-对组创建"><a href="#pair-对组创建" class="headerlink" title="pair 对组创建"></a>pair 对组创建</h4><ul><li>两种创建方式：<ul><li><code>pair&lt;type, type&gt; p ( value1, value2 );</code></li><li><code>pair&lt;type, type&gt; p = make_pair( value1, value2 );</code></li></ul></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 对组创建</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    pair&lt;string, int&gt; p(string(&quot;Tom&quot;), 20);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;姓名： &quot;</span> &lt;&lt; p.first &lt;&lt; <span class="string">&quot; 年龄： &quot;</span> &lt;&lt; p.second &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">pair</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt; p2 = <span class="built_in">make_pair</span>(<span class="string">&quot;Jerry&quot;</span>, <span class="number">10</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;姓名： &quot;</span> &lt;&lt; p2.first &lt;&lt; <span class="string">&quot; 年龄： &quot;</span> &lt;&lt; p2.second &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    test01();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="set-容器排序"><a href="#set-容器排序" class="headerlink" title="set 容器排序"></a>set 容器排序</h4><ul><li>总结：<ul><li>只能使用仿函数指定 set 容器的排序规则，不能传递普通函数</li><li>仿函数必须用 const 修饰为常函数</li><li>对于自定义数据类型，set 必须指定排序规则才可以插入数据</li></ul></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">string</span> m_Name;</span><br><span class="line">    <span class="keyword">int</span> m_Age;</span><br><span class="line"></span><br><span class="line">    Person(<span class="built_in">string</span> name, <span class="keyword">int</span> age) &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;m_Name = name;</span><br><span class="line">        <span class="keyword">this</span>-&gt;m_Age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">comparePerson</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 必须要用 const 修饰为常函数</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> Person &amp;p1, <span class="keyword">const</span> Person &amp;p2)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 按照年龄进行降序排序</span></span><br><span class="line">        <span class="keyword">return</span> p1.m_Age &gt; p2.m_Age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">set</span>&lt;Person, comparePerson&gt; s;</span><br><span class="line"></span><br><span class="line">    s.insert(Person(<span class="string">&quot;刘备&quot;</span>, <span class="number">23</span>));</span><br><span class="line">    s.insert(Person(<span class="string">&quot;关羽&quot;</span>, <span class="number">27</span>));</span><br><span class="line">    s.insert(Person(<span class="string">&quot;张飞&quot;</span>, <span class="number">25</span>));</span><br><span class="line">    s.insert(Person(<span class="string">&quot;赵云&quot;</span>, <span class="number">21</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp; it : s) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;姓名： &quot;</span> &lt;&lt; it.m_Name &lt;&lt; <span class="string">&quot; 年龄： &quot;</span> &lt;&lt; it.m_Age &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    test01();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="map-multimap-容器"><a href="#map-multimap-容器" class="headerlink" title="map/multimap 容器"></a>map/multimap 容器</h3><h4 id="map-基本概念"><a href="#map-基本概念" class="headerlink" title="map 基本概念"></a>map 基本概念</h4><ul><li><p>简介：</p><ul><li>map 中所有元素都是 pair</li><li>pair 中第一个元素为 key（键值），第二个元素为 value（实值）</li><li>所有元素都会根据元素的键值自动排序</li></ul></li><li><p>本质：</p><ul><li>map/multimap 属于<strong>关联式容器</strong>，底层结构是用二叉树实现。</li></ul></li><li><p>优点：</p><ul><li>可以根据 key 值快速找到 value 值</li></ul></li><li><p>map 和 multimap 区别：</p><ul><li>map 不允许容器中有重复 key 值元素</li><li>multimap 允许容器中有重复 key 值元素</li></ul></li></ul><h4 id="map-构造和赋值"><a href="#map-构造和赋值" class="headerlink" title="map 构造和赋值"></a>map 构造和赋值</h4><ul><li><p>函数原型：</p><ul><li><p>构造：</p><ul><li><code>map&lt;T1, T2&gt; mp;</code>：map 默认构造函数: </li><li><code>map(const map &amp;mp);</code>：拷贝构造函数</li></ul></li><li><p>赋值：</p><ul><li><code>map&amp; operator=(const map &amp;mp);</code>：重载等号操作符</li></ul></li></ul></li><li><p>总结：map 中所有元素都是成对出现，插入数据时候要使用对组</p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printMap</span><span class="params">(<span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; &amp;m)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp; it : m) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;key = &quot;</span> &lt;&lt; it.first &lt;&lt; <span class="string">&quot; value = &quot;</span> &lt;&lt; it.second &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; m;  <span class="comment">// 默认构造</span></span><br><span class="line">    m.insert(<span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;(<span class="number">1</span>, <span class="number">10</span>));</span><br><span class="line">    m.insert(<span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;(<span class="number">2</span>, <span class="number">20</span>));</span><br><span class="line">    m.insert(<span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;(<span class="number">3</span>, <span class="number">30</span>));</span><br><span class="line">    printMap(m);</span><br><span class="line"></span><br><span class="line">    map&lt;int, int&gt; m2(m);  // 拷贝构造</span><br><span class="line">    printMap(m2);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; m3;</span><br><span class="line">    m3 = m2;  <span class="comment">// 赋值</span></span><br><span class="line">    printMap(m3);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    test01();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="map-大小和交换"><a href="#map-大小和交换" class="headerlink" title="map 大小和交换"></a>map 大小和交换</h4><ul><li>函数原型：<ul><li><code>size();</code>：返回容器中元素的数目</li><li><code>empty();</code>：判断容器是否为空</li><li><code>swap(st);</code>：交换两个集合容器</li></ul></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; m;</span><br><span class="line">    m.insert(<span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;(<span class="number">1</span>, <span class="number">10</span>));</span><br><span class="line">    m.insert(<span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;(<span class="number">2</span>, <span class="number">20</span>));</span><br><span class="line">    m.insert(<span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;(<span class="number">3</span>, <span class="number">30</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (m.empty()) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;m为空&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;m不为空&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;m的大小为： &quot;</span> &lt;&lt; m.size() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 交换</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; m;</span><br><span class="line">    m.insert(<span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;(<span class="number">1</span>, <span class="number">10</span>));</span><br><span class="line">    m.insert(<span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;(<span class="number">2</span>, <span class="number">20</span>));</span><br><span class="line">    m.insert(<span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;(<span class="number">3</span>, <span class="number">30</span>));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; m2;</span><br><span class="line">    m2.insert(<span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;(<span class="number">4</span>, <span class="number">100</span>));</span><br><span class="line">    m2.insert(<span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;(<span class="number">5</span>, <span class="number">200</span>));</span><br><span class="line">    m2.insert(<span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;(<span class="number">6</span>, <span class="number">300</span>));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;交换前&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    printMap(m);</span><br><span class="line">    printMap(m2);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;交换后&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    m.swap(m2);</span><br><span class="line">    printMap(m);</span><br><span class="line">    printMap(m2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    test01();</span><br><span class="line">    test02();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="map-插入和删除"><a href="#map-插入和删除" class="headerlink" title="map 插入和删除"></a>map 插入和删除</h4><ul><li><p>函数原型：</p><ul><li><code>insert(elem);</code>：在容器中插入元素。</li><li><code>clear();</code>：清除所有元素</li><li><code>erase(pos);</code>：删除 pos 迭代器所指的元素，返回下一个元素的迭代器。</li><li><code>erase(beg, end);</code>：删除区间 [beg,end) 的所有元素 ，返回下一个元素的迭代器。</li><li><code>erase(key);</code>：删除容器中值为 key 的元素。</li></ul></li><li><p>提供的 pos 可以为迭代器或者直接为 key</p></li><li><blockquote><p>中括号重载调用，在数据不存在的情况下，会直接初始化一个 0 值，因此<strong>不推荐读取时使用</strong>。</p></blockquote></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 1. 插入</span></span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; m;</span><br><span class="line">    <span class="comment">// 第一种插入方式</span></span><br><span class="line">    m.insert(<span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;(<span class="number">1</span>, <span class="number">10</span>));</span><br><span class="line">    <span class="comment">// 第二种插入方式</span></span><br><span class="line">    m.insert(<span class="built_in">make_pair</span>(<span class="number">2</span>, <span class="number">20</span>));</span><br><span class="line">    <span class="comment">// 第三种插入方式</span></span><br><span class="line">    m.insert(<span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;::value_type(<span class="number">3</span>, <span class="number">30</span>));</span><br><span class="line">    <span class="comment">// 第四种插入方式</span></span><br><span class="line">    m[<span class="number">4</span>] = <span class="number">40</span>;</span><br><span class="line">    printMap(m);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 删除</span></span><br><span class="line">    m.erase(m.begin());</span><br><span class="line">    printMap(m);</span><br><span class="line"></span><br><span class="line">    m.erase(<span class="number">3</span>);</span><br><span class="line">    printMap(m);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 清空</span></span><br><span class="line">    m.erase(m.begin(), m.end());</span><br><span class="line">    m.clear();</span><br><span class="line">    printMap(m);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    test01();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="map-查找和统计"><a href="#map-查找和统计" class="headerlink" title="map 查找和统计"></a>map 查找和统计</h4><ul><li>函数原型：<ul><li><code>find(key);</code>：查找 key 是否存在,若存在，返回该键的元素的迭代器；若不存在，返回 <code>set.end();</code>。</li><li><code>count(key);</code>：统计 key 的元素个数（对于 map，结果为 0 或者 1）</li></ul></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 查找和统计</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; m;</span><br><span class="line">    m.insert(<span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;(<span class="number">1</span>, <span class="number">10</span>));</span><br><span class="line">    m.insert(<span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;(<span class="number">2</span>, <span class="number">20</span>));</span><br><span class="line">    m.insert(<span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;(<span class="number">3</span>, <span class="number">30</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查找</span></span><br><span class="line">    <span class="keyword">auto</span> pos = m.find(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pos != m.end()) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;找到了元素 key = &quot;</span> &lt;&lt; (*pos).first &lt;&lt; <span class="string">&quot; value = &quot;</span> &lt;&lt; (*pos).second &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;未找到元素&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//统计</span></span><br><span class="line">    <span class="keyword">int</span> num = m.count(<span class="number">3</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;num = &quot;</span> &lt;&lt; num &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    test01();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="map-容器排序"><a href="#map-容器排序" class="headerlink" title="map 容器排序"></a>map 容器排序</h4><ul><li><p>总结：</p><ul><li>只能使用仿函数指定 map 容器的排序规则，不能传递普通函数</li><li>仿函数必须用 const 修饰为常函数</li><li>对于自定义数据类型，map 必须指定排序规则才可以插入数据</li></ul></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyCompare</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> v1, <span class="keyword">int</span> v2)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> v1 &gt; v2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 默认从小到大排序</span></span><br><span class="line">    <span class="comment">// 利用仿函数实现从大到小排序</span></span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>, MyCompare&gt; m;</span><br><span class="line"></span><br><span class="line">    m.insert(<span class="built_in">make_pair</span>(<span class="number">1</span>, <span class="number">10</span>));</span><br><span class="line">    m.insert(<span class="built_in">make_pair</span>(<span class="number">2</span>, <span class="number">20</span>));</span><br><span class="line">    m.insert(<span class="built_in">make_pair</span>(<span class="number">3</span>, <span class="number">30</span>));</span><br><span class="line">    m.insert(<span class="built_in">make_pair</span>(<span class="number">4</span>, <span class="number">40</span>));</span><br><span class="line">    m.insert(<span class="built_in">make_pair</span>(<span class="number">5</span>, <span class="number">50</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp; it : m) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;key:&quot;</span> &lt;&lt; it.first &lt;&lt; <span class="string">&quot; value:&quot;</span> &lt;&lt; it.second &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    test01();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="STL-函数对象"><a href="#STL-函数对象" class="headerlink" title="STL 函数对象"></a>STL 函数对象</h2><h3 id="函数对象"><a href="#函数对象" class="headerlink" title="函数对象"></a>函数对象</h3><h4 id="函数对象概念"><a href="#函数对象概念" class="headerlink" title="函数对象概念"></a>函数对象概念</h4><ul><li><p>概念：</p><ul><li>重载<strong>函数调用操作符</strong>的类，其对象常称为<strong>函数对象</strong></li><li><strong>函数对象</strong>使用重载的 <code>()</code> 时，行为类似函数调用，也叫<strong>仿函数</strong></li></ul></li><li><p>本质：</p><ul><li>函数对象（仿函数）是一个<strong>类</strong>，不是一个函数</li></ul></li></ul><h4 id="函数对象使用"><a href="#函数对象使用" class="headerlink" title="函数对象使用"></a>函数对象使用</h4><ul><li>特点：<ul><li>函数对象在使用时，可以像普通函数那样调用，可以有参数，可以有返回值</li><li>函数对象超出普通函数的概念，函数对象可以有自己的状态</li><li>函数对象可以作为参数传递</li></ul></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 函数对象在使用时，可以像普通函数那样调用, 可以有参数，可以有返回值</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyAdd</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span> :</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> v1, <span class="keyword">int</span> v2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> v1 + v2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    MyAdd myAdd;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; myAdd(<span class="number">10</span>, <span class="number">10</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 函数对象可以有自己的状态</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyPrint</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> count;  <span class="comment">// 内部状态</span></span><br><span class="line"></span><br><span class="line">    MyPrint() &#123;</span><br><span class="line">        count = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="built_in">string</span> test)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; test &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        count++; <span class="comment">//统计使用次数</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    MyPrint myPrint;</span><br><span class="line">    myPrint(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">    myPrint(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">    myPrint(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;myPrint调用次数为： &quot;</span> &lt;&lt; myPrint.count &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 函数对象可以作为参数传递</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doPrint</span><span class="params">(MyPrint &amp;mp, <span class="built_in">string</span> test)</span> </span>&#123;</span><br><span class="line">    mp(test);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test03</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    MyPrint myPrint;</span><br><span class="line">    doPrint(myPrint, <span class="string">&quot;Hello C++&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    test01();</span><br><span class="line">    test02();</span><br><span class="line">    test03();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="谓词"><a href="#谓词" class="headerlink" title="谓词"></a>谓词</h3><h4 id="谓词概念"><a href="#谓词概念" class="headerlink" title="谓词概念"></a>谓词概念</h4><ul><li><p>概念：</p><ul><li><strong>返回 bool 类型</strong>的仿函数称为<strong>谓词</strong></li><li>一元谓词：operator() 接受一个参数</li><li>二元谓词：operator() 接受两个参数</li></ul></li><li><blockquote><p>此处与之前不同，可以传递 struct、class、普通函数。</p></blockquote></li></ul><h4 id="一元谓词"><a href="#一元谓词" class="headerlink" title="一元谓词"></a>一元谓词</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 一元谓词</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">GreaterFive</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> val &gt; <span class="number">5</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        v.push_back(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> it = find_if(v.begin(), v.end(), GreaterFive());</span><br><span class="line">    <span class="keyword">if</span> (it == v.end()) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;没找到!&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;找到: &quot;</span> &lt;&lt; *it &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    test01();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="二元谓词"><a href="#二元谓词" class="headerlink" title="二元谓词"></a>二元谓词</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printVector</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> &amp;it : v) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 二元谓词</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyCompare</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> num1, <span class="keyword">int</span> num2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> num1 &gt; num2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">myCompare</span><span class="params">(<span class="keyword">int</span> val1, <span class="keyword">int</span> val2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> val1 &gt; val2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">    v.push_back(<span class="number">10</span>);</span><br><span class="line">    v.push_back(<span class="number">40</span>);</span><br><span class="line">    v.push_back(<span class="number">20</span>);</span><br><span class="line">    v.push_back(<span class="number">30</span>);</span><br><span class="line">    v.push_back(<span class="number">50</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 默认从小到大</span></span><br><span class="line">    sort(v.begin(), v.end());</span><br><span class="line">    printVector(v);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;----------------------------&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用函数对象改变算法策略，排序从大到小</span></span><br><span class="line">    sort(v.begin(), v.end(), MyCompare());</span><br><span class="line">    <span class="comment">// sort(v.begin(), v.end(), myCompare);  // 等价</span></span><br><span class="line">    printVector(v);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    test01();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="内建函数对象"><a href="#内建函数对象" class="headerlink" title="内建函数对象"></a>内建函数对象</h3><h4 id="内建函数对象意义"><a href="#内建函数对象意义" class="headerlink" title="内建函数对象意义"></a>内建函数对象意义</h4><ul><li><p>概念：</p><ul><li>STL 内建的一些函数对象</li></ul></li><li><p>分类:</p><ul><li><p>算术仿函数</p></li><li><p>关系仿函数</p></li><li><p>逻辑仿函数</p></li></ul></li><li><p>使用内建函数对象，需要引入头文件 <code>#include&lt;functional&gt;</code></p></li></ul><h4 id="算术仿函数"><a href="#算术仿函数" class="headerlink" title="算术仿函数"></a>算术仿函数</h4><ul><li>仿函数原型：<ul><li><code>template&lt;class T&gt; T plus&lt;T&gt;</code>：加法仿函数</li><li><code>template&lt;class T&gt; T minus&lt;T&gt;</code>：减法仿函数</li><li><code>template&lt;class T&gt; T multiplies&lt;T&gt;</code>：乘法仿函数</li><li><code>template&lt;class T&gt; T divides&lt;T&gt;</code>：除法仿函数</li><li><code>template&lt;class T&gt; T modulus&lt;T&gt;</code>：取模仿函数</li><li><code>template&lt;class T&gt; T negate&lt;T&gt;</code>：取反仿函数</li></ul></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// negate</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    negate&lt;<span class="keyword">int</span>&gt; n;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; n(<span class="number">50</span>) &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">// -50</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// plus</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    plus&lt;<span class="keyword">int</span>&gt; p;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; p(<span class="number">10</span>, <span class="number">20</span>) &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">// 30</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    test01();</span><br><span class="line">    test02();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="关系仿函数"><a href="#关系仿函数" class="headerlink" title="关系仿函数"></a>关系仿函数</h4><ul><li>仿函数原型：<ul><li><code>template&lt;class T&gt; bool equal_to&lt;T&gt;</code>：等于</li><li><code>template&lt;class T&gt; bool not_equal_to&lt;T&gt;</code>：不等于</li><li><code>template&lt;class T&gt; bool greater&lt;T&gt;</code>：大于</li><li><code>template&lt;class T&gt; bool greater_equal&lt;T&gt;</code>：大于等于</li><li><code>template&lt;class T&gt; bool less&lt;T&gt;</code>：小于</li><li><code>template&lt;class T&gt; bool less_equal&lt;T&gt;</code>：小于等于</li></ul></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printVector</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> &amp;it : v) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyCompare</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> v1, <span class="keyword">int</span> v2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> v1 &gt; v2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">    v.push_back(<span class="number">10</span>);</span><br><span class="line">    v.push_back(<span class="number">30</span>);</span><br><span class="line">    v.push_back(<span class="number">50</span>);</span><br><span class="line">    v.push_back(<span class="number">40</span>);</span><br><span class="line">    v.push_back(<span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">    printVector(v);</span><br><span class="line">    <span class="comment">//sort(v.begin(), v.end(), MyCompare());  // 自己实现仿函数</span></span><br><span class="line">    sort(v.begin(), v.end(), greater&lt;<span class="keyword">int</span>&gt;());  <span class="comment">// STL 内建仿函数</span></span><br><span class="line">    printVector(v);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    test01();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="逻辑仿函数"><a href="#逻辑仿函数" class="headerlink" title="逻辑仿函数"></a>逻辑仿函数</h4><ul><li>函数原型：<ul><li><code>template&lt;class T&gt; bool logical_and&lt;T&gt;</code>：逻辑与</li><li><code>template&lt;class T&gt; bool logical_or&lt;T&gt;</code>：逻辑或</li><li><code>template&lt;class T&gt; bool logical_not&lt;T&gt;</code>：逻辑非</li></ul></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printVector</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; &amp;v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;&amp; it : v) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; v;</span><br><span class="line">    v.push_back(<span class="literal">true</span>);</span><br><span class="line">    v.push_back(<span class="literal">false</span>);</span><br><span class="line">    v.push_back(<span class="literal">true</span>);</span><br><span class="line">    v.push_back(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">    printVector(v);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 逻辑非  将v容器搬运到v2中，并执行逻辑非运算</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; v2;</span><br><span class="line">    v2.resize(v.size());</span><br><span class="line">    transform(v.begin(), v.end(), v2.begin(), logical_not&lt;<span class="keyword">bool</span>&gt;());</span><br><span class="line">    printVector(v2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    test01();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="STL-常用算法"><a href="#STL-常用算法" class="headerlink" title="STL 常用算法"></a>STL 常用算法</h2><ul><li>概述:<ul><li>算法主要是由头文件<code>&lt;algorithm&gt;</code> <code>&lt;functional&gt;</code> <code>&lt;numeric&gt;</code>组成。</li></ul></li><li><code>&lt;algorithm&gt;</code>：是所有 STL 头文件中最大的一个，范围涉及到比较、 交换、查找、遍历操作、复制、修改等</li><li><code>&lt;numeric&gt;</code>：体积很小，只包括几个在序列上面进行简单数学运算的模板函数</li><li><code>&lt;functional&gt;</code>：定义了一些模板类，用以声明函数对象。</li></ul><h3 id="常用遍历算法"><a href="#常用遍历算法" class="headerlink" title="常用遍历算法"></a>常用遍历算法</h3><ul><li>算法简介：<ul><li><code>for_each</code>：遍历容器（常用）</li><li><code>transform</code>：搬运容器到另一个容器中</li></ul></li></ul><h4 id="for-each"><a href="#for-each" class="headerlink" title="for_each"></a>for_each</h4><ul><li>函数原型：<ul><li><code>for_each(iterator beg, iterator end, _func);  </code>：遍历算法 遍历容器元素<ul><li>beg 开始迭代器</li><li>end 结束迭代器</li><li>_func 函数或者函数对象</li></ul></li></ul></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 普通函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print01</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数对象</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">print02</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// for_each 算法基本用法</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        v.push_back(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//遍历算法</span></span><br><span class="line">    for_each(v.begin(), v.end(), print01);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    for_each(v.begin(), v.end(), print02());</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    test01();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="transform"><a href="#transform" class="headerlink" title="transform"></a>transform</h4><ul><li><p>函数原型：</p><ul><li><p><code>transform(iterator beg1, iterator end1, iterator beg2, _func);</code></p><ul><li>beg1：源容器开始迭代器</li><li>end1：源容器结束迭代器</li><li>beg2：目标容器开始迭代器</li><li>_func：函数或者函数对象</li></ul></li></ul></li><li><p>注意：搬运的目标容器必须要提前开辟空间，否则无法正常搬运</p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//常用遍历算法  搬运 transform</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TransForm</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyPrint</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; val + <span class="number">1</span> &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">    v.reserve(<span class="number">10</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        v.push_back(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vTarget;  <span class="comment">// 目标容器</span></span><br><span class="line"></span><br><span class="line">    vTarget.resize(v.size());  <span class="comment">// 目标容器需要提前开辟空间</span></span><br><span class="line"></span><br><span class="line">    transform(v.begin(), v.end(), vTarget.begin(), TransForm());</span><br><span class="line"></span><br><span class="line">    for_each(vTarget.begin(), vTarget.end(), MyPrint());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    test01();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="常用查找算法"><a href="#常用查找算法" class="headerlink" title="常用查找算法"></a>常用查找算法</h3><ul><li>算法简介：<ul><li><code>find</code>：查找元素</li><li><code>find_if</code>：按条件查找元素</li><li><code>adjacent_find</code>：查找相邻重复元素</li><li><code>binary_search</code>：二分查找法</li><li><code>count</code>：统计元素个数</li><li><code>count_if</code>：按条件统计元素个数</li></ul></li></ul><h4 id="find"><a href="#find" class="headerlink" title="find"></a>find</h4><ul><li>函数原型：<ul><li><code>find(iterator beg, iterator end, value);  </code>：按值查找元素，找到返回指定位置迭代器，找不到返回结束迭代器位置<ul><li>beg：开始迭代器</li><li>end：结束迭代器</li><li>value：查找的元素</li></ul></li></ul></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">    v.reserve(<span class="number">10</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        v.push_back(i + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//查找容器中是否有 5 这个元素</span></span><br><span class="line">    <span class="keyword">auto</span> it = find(v.begin(), v.end(), <span class="number">5</span>);</span><br><span class="line">    <span class="keyword">if</span> (it == v.end()) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;没有找到!&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;找到:&quot;</span> &lt;&lt; *it &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">string</span> m_Name;</span><br><span class="line">    <span class="keyword">int</span> m_Age;</span><br><span class="line"></span><br><span class="line">    Person(<span class="built_in">string</span> name, <span class="keyword">int</span> age) &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;m_Name = name;</span><br><span class="line">        <span class="keyword">this</span>-&gt;m_Age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>==(<span class="keyword">const</span> Person &amp;p) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>-&gt;m_Name == p.m_Name &amp;&amp; <span class="keyword">this</span>-&gt;m_Age == p.m_Age) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;Person&gt; v;</span><br><span class="line">    <span class="function">Person <span class="title">p1</span><span class="params">(<span class="string">&quot;aaa&quot;</span>, <span class="number">10</span>)</span></span>;</span><br><span class="line">    <span class="function">Person <span class="title">p2</span><span class="params">(<span class="string">&quot;bbb&quot;</span>, <span class="number">20</span>)</span></span>;</span><br><span class="line">    <span class="function">Person <span class="title">p3</span><span class="params">(<span class="string">&quot;ccc&quot;</span>, <span class="number">30</span>)</span></span>;</span><br><span class="line">    <span class="function">Person <span class="title">p4</span><span class="params">(<span class="string">&quot;ddd&quot;</span>, <span class="number">40</span>)</span></span>;</span><br><span class="line">    v.push_back(p1);</span><br><span class="line">    v.push_back(p2);</span><br><span class="line">    v.push_back(p3);</span><br><span class="line">    v.push_back(p4);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> it = find(v.begin(), v.end(), p2);</span><br><span class="line">    <span class="keyword">if</span> (it == v.end()) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;没有找到!&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;找到姓名:&quot;</span> &lt;&lt; it-&gt;m_Name &lt;&lt; <span class="string">&quot; 年龄: &quot;</span> &lt;&lt; it-&gt;m_Age &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    test01();</span><br><span class="line">    test02();</span><br><span class="line">    <span class="keyword">return</span> EXIT_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="find-if"><a href="#find-if" class="headerlink" title="find_if"></a>find_if</h4><ul><li>函数原型：<ul><li><code>find_if(iterator beg, iterator end, _Pred);  </code>：按值查找元素，找到返回指定位置迭代器，找不到返回结束迭代器位置<ul><li>beg：开始迭代器</li><li>end：结束迭代器</li><li>_Pred：函数或者谓词（返回bool类型的仿函数）</li></ul></li></ul></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 内置数据类型</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GreaterFive</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> val &gt; <span class="number">5</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        v.push_back(i + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> it = find_if(v.begin(), v.end(), GreaterFive());</span><br><span class="line">    <span class="keyword">if</span> (it == v.end()) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;没有找到!&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;找到大于5的数字:&quot;</span> &lt;&lt; *it &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//自定义数据类型</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">string</span> m_Name;</span><br><span class="line">    <span class="keyword">int</span> m_Age;</span><br><span class="line">    </span><br><span class="line">    Person(<span class="built_in">string</span> name, <span class="keyword">int</span> age) &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;m_Name = name;</span><br><span class="line">        <span class="keyword">this</span>-&gt;m_Age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Greater20</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(Person &amp;p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> p.m_Age &gt; <span class="number">20</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;Person&gt; v;</span><br><span class="line">    v.emplace_back(<span class="string">&quot;aaa&quot;</span>, <span class="number">10</span>);</span><br><span class="line">    v.emplace_back(<span class="string">&quot;bbb&quot;</span>, <span class="number">20</span>);</span><br><span class="line">    v.emplace_back(<span class="string">&quot;ccc&quot;</span>, <span class="number">30</span>);</span><br><span class="line">    v.emplace_back(<span class="string">&quot;ddd&quot;</span>, <span class="number">40</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> it = find_if(v.begin(), v.end(), Greater20());</span><br><span class="line">    <span class="keyword">if</span> (it == v.end()) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;没有找到!&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;找到姓名:&quot;</span> &lt;&lt; it-&gt;m_Name &lt;&lt; <span class="string">&quot; 年龄: &quot;</span> &lt;&lt; it-&gt;m_Age &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    test01();</span><br><span class="line">    test02();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="adjacent-find"><a href="#adjacent-find" class="headerlink" title="adjacent_find"></a>adjacent_find</h4><ul><li>函数原型：<ul><li><code>adjacent_find(iterator beg, iterator end);  </code>：查找相邻重复元素,返回相邻元素的第一个位置的迭代器<ul><li>beg：开始迭代器</li><li>end：结束迭代器</li></ul></li></ul></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">    v.push_back(<span class="number">1</span>);</span><br><span class="line">    v.push_back(<span class="number">2</span>);</span><br><span class="line">    v.push_back(<span class="number">5</span>);</span><br><span class="line">    v.push_back(<span class="number">2</span>);</span><br><span class="line">    v.push_back(<span class="number">4</span>);</span><br><span class="line">    v.push_back(<span class="number">4</span>);</span><br><span class="line">    v.push_back(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查找相邻重复元素</span></span><br><span class="line">    <span class="keyword">auto</span> it = adjacent_find(v.begin(), v.end());</span><br><span class="line">    <span class="keyword">if</span> (it == v.end()) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;找不到!&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;找到相邻重复元素为:&quot;</span> &lt;&lt; *it &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    test01();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="binary-search"><a href="#binary-search" class="headerlink" title="binary_search"></a>binary_search</h4><ul><li>函数原型：<ul><li><code>bool binary_search(iterator beg, iterator end, value);  </code>：查找指定的元素，查到则返回 true，否则 false。<ul><li>beg：开始迭代器</li><li>end：结束迭代器</li><li>value：查找的元素</li></ul></li></ul></li><li>注意：在无序序列中不可用</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">    v.reserve(<span class="number">10</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        v.push_back(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 二分查找</span></span><br><span class="line">    <span class="keyword">bool</span> ret = binary_search(v.begin(), v.end(), <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">if</span> (ret) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;找到了&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;未找到&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    test01();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="count"><a href="#count" class="headerlink" title="count"></a>count</h4><ul><li>函数原型：<ul><li><code>count(iterator beg, iterator end, value);  </code>：统计元素出现次数<ul><li>beg：开始迭代器</li><li>end：结束迭代器</li><li>value：统计的元素</li></ul></li></ul></li><li>统计自定义数据类型时候，需要配合重载 <code>operator==</code>。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 内置数据类型</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">    v.push_back(<span class="number">1</span>);</span><br><span class="line">    v.push_back(<span class="number">2</span>);</span><br><span class="line">    v.push_back(<span class="number">4</span>);</span><br><span class="line">    v.push_back(<span class="number">5</span>);</span><br><span class="line">    v.push_back(<span class="number">3</span>);</span><br><span class="line">    v.push_back(<span class="number">4</span>);</span><br><span class="line">    v.push_back(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;4的个数为： &quot;</span> &lt;&lt; count(v.begin(), v.end(), <span class="number">4</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义数据类型</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">string</span> m_Name;</span><br><span class="line">    <span class="keyword">int</span> m_Age;</span><br><span class="line">    </span><br><span class="line">    Person(<span class="built_in">string</span> name, <span class="keyword">int</span> age) &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;m_Name = name;</span><br><span class="line">        <span class="keyword">this</span>-&gt;m_Age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>==(<span class="keyword">const</span> Person &amp;p) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>-&gt;m_Age == p.m_Age) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;Person&gt; v;</span><br><span class="line">    v.emplace_back(<span class="string">&quot;刘备&quot;</span>, <span class="number">35</span>);</span><br><span class="line">    v.emplace_back(<span class="string">&quot;关羽&quot;</span>, <span class="number">35</span>);</span><br><span class="line">    v.emplace_back(<span class="string">&quot;张飞&quot;</span>, <span class="number">35</span>);</span><br><span class="line">    v.emplace_back(<span class="string">&quot;赵云&quot;</span>, <span class="number">30</span>);</span><br><span class="line">    v.emplace_back(<span class="string">&quot;曹操&quot;</span>, <span class="number">25</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;num = &quot;</span> &lt;&lt; count(v.begin(), v.end(), Person(<span class="string">&quot;诸葛亮&quot;</span>, <span class="number">35</span>)) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    test01();</span><br><span class="line">    test02();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="count-if"><a href="#count-if" class="headerlink" title="count_if"></a>count_if</h4><ul><li>函数原型：<ul><li><code>count_if(iterator beg, iterator end, _Pred);  </code>：按条件统计元素出现次数<ul><li>beg：开始迭代器</li><li>end：结束迭代器</li><li>_Pred：谓词</li></ul></li></ul></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Greater4</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> val &gt;= <span class="number">4</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 置数据类型</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">    v.push_back(<span class="number">1</span>);</span><br><span class="line">    v.push_back(<span class="number">2</span>);</span><br><span class="line">    v.push_back(<span class="number">4</span>);</span><br><span class="line">    v.push_back(<span class="number">5</span>);</span><br><span class="line">    v.push_back(<span class="number">3</span>);</span><br><span class="line">    v.push_back(<span class="number">4</span>);</span><br><span class="line">    v.push_back(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;大于4的个数为： &quot;</span> &lt;&lt; count_if(v.begin(), v.end(), Greater4()) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义数据类型</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">string</span> m_Name;</span><br><span class="line">    <span class="keyword">int</span> m_Age;</span><br><span class="line">    </span><br><span class="line">    Person(<span class="built_in">string</span> name, <span class="keyword">int</span> age) &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;m_Name = name;</span><br><span class="line">        <span class="keyword">this</span>-&gt;m_Age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AgeLess35</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> Person &amp;p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> p.m_Age &lt; <span class="number">35</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;Person&gt; v;</span><br><span class="line">    v.emplace_back(<span class="string">&quot;刘备&quot;</span>, <span class="number">35</span>);</span><br><span class="line">    v.emplace_back(<span class="string">&quot;关羽&quot;</span>, <span class="number">35</span>);</span><br><span class="line">    v.emplace_back(<span class="string">&quot;张飞&quot;</span>, <span class="number">35</span>);</span><br><span class="line">    v.emplace_back(<span class="string">&quot;赵云&quot;</span>, <span class="number">30</span>);</span><br><span class="line">    v.emplace_back(<span class="string">&quot;曹操&quot;</span>, <span class="number">25</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;小于35岁的个数：&quot;</span> &lt;&lt; count_if(v.begin(), v.end(), AgeLess35()) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    test01();</span><br><span class="line">    test02();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="常用排序算法"><a href="#常用排序算法" class="headerlink" title="常用排序算法"></a>常用排序算法</h3><ul><li>算法简介：<ul><li><code>sort</code>：对容器内元素进行排序</li><li><code>random_shuffle</code>：洗牌   指定范围内的元素随机调整次序</li><li><code>merge </code>：容器元素合并，并存储到另一容器中</li><li><code>reverse</code>：反转指定范围的元素</li></ul></li></ul><h4 id="sort"><a href="#sort" class="headerlink" title="sort"></a>sort</h4><ul><li>函数原型：<ul><li><code>sort(iterator beg, iterator end, _Pred);  </code>：按值查找元素，找到返回指定位置迭代器，找不到返回结束迭代器位置<ul><li>beg：开始迭代器</li><li>end：结束迭代器</li><li>_Pred：谓词</li></ul></li></ul></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myPrint</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">    v.push_back(<span class="number">10</span>);</span><br><span class="line">    v.push_back(<span class="number">30</span>);</span><br><span class="line">    v.push_back(<span class="number">50</span>);</span><br><span class="line">    v.push_back(<span class="number">20</span>);</span><br><span class="line">    v.push_back(<span class="number">40</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// sort 默认从小到大排序</span></span><br><span class="line">    sort(v.begin(), v.end());</span><br><span class="line">    for_each(v.begin(), v.end(), myPrint);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从大到小排序</span></span><br><span class="line">    sort(v.begin(), v.end(), greater&lt;<span class="keyword">int</span>&gt;());</span><br><span class="line">    for_each(v.begin(), v.end(), myPrint);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    test01();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="random-shuffle"><a href="#random-shuffle" class="headerlink" title="random_shuffle"></a>random_shuffle</h4><ul><li>函数原型：<ul><li><code>random_shuffle(iterator beg, iterator end);  </code>：指定范围内的元素随机调整次序<ul><li>beg：开始迭代器</li><li>end：结束迭代器、</li></ul></li></ul></li><li><code>random_shuffle</code> 在 C++11 中被标记 deprecated，在 C++14 中被 removed。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctime&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">myPrint</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    srand((<span class="keyword">unsigned</span> <span class="keyword">int</span>) time(<span class="literal">nullptr</span>));</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        v.push_back(i);</span><br><span class="line">    &#125;</span><br><span class="line">    for_each(v.begin(), v.end(), myPrint());</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//打乱顺序</span></span><br><span class="line">    random_shuffle(v.begin(), v.end());</span><br><span class="line">    for_each(v.begin(), v.end(), myPrint());</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    test01();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="merge"><a href="#merge" class="headerlink" title="merge"></a>merge</h4><ul><li>函数原型：<ul><li><code>merge(iterator beg1, iterator end1, iterator beg2, iterator end2, iterator dest);  </code>：容器元素合并，并存储到另一容器中<ul><li>beg1：容器 1 开始迭代器</li><li>end1：容器 1 结束迭代器</li><li>beg2：容器 2 开始迭代器</li><li>end2：容器 2 结束迭代器</li><li>dest：目标容器开始迭代器</li></ul></li></ul></li><li>注意: 两个容器必须是<strong>有序的</strong></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">myPrint</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v1;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v2;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        v1.push_back(i);</span><br><span class="line">        v2.push_back(i + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vtarget;</span><br><span class="line">    vtarget.resize(v1.size() + v2.size());  <span class="comment">// 目标容器需要提前开辟空间</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//合并: 需要两个有序序列</span></span><br><span class="line">    merge(v1.begin(), v1.end(), v2.begin(), v2.end(), vtarget.begin());</span><br><span class="line">    for_each(vtarget.begin(), vtarget.end(), myPrint());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    test01();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="reverse"><a href="#reverse" class="headerlink" title="reverse"></a>reverse</h4><ul><li>函数原型：<ul><li><code>reverse(iterator beg, iterator end);  </code>：反转指定范围的元素<ul><li>beg：开始迭代器</li><li>end：结束迭代器</li></ul></li></ul></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">myPrint</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">    v.push_back(<span class="number">10</span>);</span><br><span class="line">    v.push_back(<span class="number">30</span>);</span><br><span class="line">    v.push_back(<span class="number">50</span>);</span><br><span class="line">    v.push_back(<span class="number">20</span>);</span><br><span class="line">    v.push_back(<span class="number">40</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;反转前： &quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    for_each(v.begin(), v.end(), myPrint());</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;反转后： &quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    reverse(v.begin(), v.end());</span><br><span class="line">    for_each(v.begin(), v.end(), myPrint());</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    test01();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="常用拷贝和替换算法"><a href="#常用拷贝和替换算法" class="headerlink" title="常用拷贝和替换算法"></a>常用拷贝和替换算法</h3><ul><li>算法简介：<ul><li><code>copy</code>：容器内指定范围的元素拷贝到另一容器中</li><li><code>replace</code>：将容器内指定范围的旧元素修改为新元素</li><li><code>replace_if </code>：容器内指定范围满足条件的元素替换为新元素</li><li><code>swap</code>：互换两个容器的元素</li></ul></li></ul><h4 id="copy"><a href="#copy" class="headerlink" title="copy"></a>copy</h4><ul><li>函数原型：<ul><li><code>copy(iterator beg, iterator end, iterator dest);  </code>：按值查找元素，找到返回指定位置迭代器，找不到返回结束迭代器位置<ul><li>beg：源开始迭代器</li><li>end：源结束迭代器</li><li>dest：目标起始迭代器</li></ul></li></ul></li><li>拷贝前需要提前开辟空间</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">myPrint</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v1;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        v1.push_back(i + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v2;</span><br><span class="line">    v2.resize(v1.size());  <span class="comment">// 提前开辟空间</span></span><br><span class="line">    copy(v1.begin(), v1.end(), v2.begin());</span><br><span class="line"></span><br><span class="line">    for_each(v2.begin(), v2.end(), myPrint());</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    test01();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="replace"><a href="#replace" class="headerlink" title="replace"></a>replace</h4><ul><li>函数原型：<ul><li><code>replace(iterator beg, iterator end, oldvalue, newvalue);  </code>：将区间内旧元素替换成新元素<ul><li>beg：开始迭代器</li><li>end：结束迭代器</li><li>oldvalue：旧元素</li><li>newvalue：新元素</li></ul></li></ul></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">myPrint</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">    v.push_back(<span class="number">20</span>);</span><br><span class="line">    v.push_back(<span class="number">30</span>);</span><br><span class="line">    v.push_back(<span class="number">20</span>);</span><br><span class="line">    v.push_back(<span class="number">40</span>);</span><br><span class="line">    v.push_back(<span class="number">50</span>);</span><br><span class="line">    v.push_back(<span class="number">10</span>);</span><br><span class="line">    v.push_back(<span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;替换前：&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    for_each(v.begin(), v.end(), myPrint());</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将容器中的 20 替换成 2000</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;替换后：&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    replace(v.begin(), v.end(), <span class="number">20</span>, <span class="number">2000</span>);</span><br><span class="line">    for_each(v.begin(), v.end(), myPrint());</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    test01();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="replace-if"><a href="#replace-if" class="headerlink" title="replace_if"></a>replace_if</h4><ul><li>函数原型：<ul><li><code>replace_if(iterator beg, iterator end, _pred, newvalue);  </code>：按条件替换元素，满足条件的替换成指定元素<ul><li>beg：开始迭代器</li><li>end：结束迭代器</li><li>_pred：谓词</li><li>newvalue：替换的新元素</li></ul></li></ul></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">myPrint</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ReplaceGreater30</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> val &gt;= <span class="number">30</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">    v.push_back(<span class="number">20</span>);</span><br><span class="line">    v.push_back(<span class="number">30</span>);</span><br><span class="line">    v.push_back(<span class="number">20</span>);</span><br><span class="line">    v.push_back(<span class="number">40</span>);</span><br><span class="line">    v.push_back(<span class="number">50</span>);</span><br><span class="line">    v.push_back(<span class="number">10</span>);</span><br><span class="line">    v.push_back(<span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;替换前：&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    for_each(v.begin(), v.end(), myPrint());</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将容器中大于等于的30 替换成 3000</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;替换后：&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    replace_if(v.begin(), v.end(), ReplaceGreater30(), <span class="number">3000</span>);</span><br><span class="line">    for_each(v.begin(), v.end(), myPrint());</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    test01();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="swap"><a href="#swap" class="headerlink" title="swap"></a>swap</h4><ul><li>函数原型：<ul><li><code>swap(container c1, container c2);  </code>：互换两个容器的元素<ul><li>c1：容器1</li><li>c2：容器2</li></ul></li></ul></li><li>swap 交换容器时，注意交换的容器要同种类型</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">myPrint</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v1;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v2;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        v1.push_back(i);</span><br><span class="line">        v2.push_back(i + <span class="number">100</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;交换前： &quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    for_each(v1.begin(), v1.end(), myPrint());</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    for_each(v2.begin(), v2.end(), myPrint());</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;交换后： &quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    swap(v1, v2);</span><br><span class="line">    for_each(v1.begin(), v1.end(), myPrint());</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    for_each(v2.begin(), v2.end(), myPrint());</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    test01();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="常用算术生成算法"><a href="#常用算术生成算法" class="headerlink" title="常用算术生成算法"></a>常用算术生成算法</h3><ul><li><p>注意：</p><ul><li>算术生成算法属于小型算法，使用时包含的头文件为 <code>#include &lt;numeric&gt;</code></li><li>通常比较实用</li></ul></li><li><p>算法简介：</p><ul><li><p><code>accumulate</code>：计算容器元素累计总和</p></li><li><p><code>fill</code>：向容器中添加元素</p></li></ul></li></ul><h4 id="accumulate"><a href="#accumulate" class="headerlink" title="accumulate"></a>accumulate</h4><ul><li>函数原型：<ul><li><code>accumulate(iterator beg, iterator end, value);  </code>：计算容器元素累计总和<ul><li>beg：开始迭代器</li><li>end：结束迭代器</li><li>value：起始值</li></ul></li></ul></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;numeric&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">100</span>; i++) &#123;</span><br><span class="line">        v.push_back(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> total = accumulate(v.begin(), v.end(), <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;total = &quot;</span> &lt;&lt; total &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    test01();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="fill"><a href="#fill" class="headerlink" title="fill"></a>fill</h4><ul><li>函数原型：<ul><li><code>fill(iterator beg, iterator end, value);  </code>：向容器中填充元素<ul><li>beg：开始迭代器</li><li>end：结束迭代器</li><li>value：填充的值</li></ul></li></ul></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;numeric&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">myPrint</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">    v.resize(<span class="number">10</span>);</span><br><span class="line">    <span class="comment">//填充</span></span><br><span class="line">    fill(v.begin(), v.end(), <span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">    for_each(v.begin(), v.end(), myPrint());</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    test01();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="常用集合算法"><a href="#常用集合算法" class="headerlink" title="常用集合算法"></a>常用集合算法</h3><ul><li><p>算法简介：</p><ul><li><p><code>set_intersection</code>：求两个容器的交集</p></li><li><p><code>set_union</code>：求两个容器的并集</p></li><li><p><code>set_difference </code>：求两个容器的差集</p></li></ul></li></ul><h4 id="set-intersection"><a href="#set-intersection" class="headerlink" title="set_intersection"></a>set_intersection</h4><ul><li><p>函数原型：</p><ul><li><code>set_intersection(iterator beg1, iterator end1, iterator beg2, iterator end2, iterator dest);  </code>：求两个集合的交集<ul><li>beg1：容器 1 开始迭代器</li><li>end1：容器 1 结束迭代器</li><li>beg2：容器 2 开始迭代器</li><li>end2：容器 2 结束迭代器</li><li>dest：目标容器开始迭代器</li></ul></li></ul></li><li><p>注意： </p><ul><li>求交集的两个集合必须是<strong>有序序列</strong>。</li><li>目标容器开辟空间需要从<strong>两个容器中取小值</strong>。</li><li>set_intersection 返回值是交集中最后一个元素的位置。</li></ul></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">myPrint</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v1;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v2;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        v1.push_back(i);</span><br><span class="line">        v2.push_back(i + <span class="number">5</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vTarget;</span><br><span class="line">    vTarget.resize(min(v1.size(), v2.size()));  <span class="comment">// 取两个里面较小的值给目标容器开辟空间</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回目标容器的最后一个元素的迭代器地址</span></span><br><span class="line">    <span class="keyword">auto</span> itEnd = set_intersection(v1.begin(), v1.end(), v2.begin(), v2.end(), vTarget.begin());</span><br><span class="line"></span><br><span class="line">    for_each(vTarget.begin(), itEnd, myPrint());</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    test01();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="set-union"><a href="#set-union" class="headerlink" title="set_union"></a>set_union</h4><ul><li>函数原型：<ul><li><code>set_union(iterator beg1, iterator end1, iterator beg2, iterator end2, iterator dest);  </code>：求两个集合的并集<ul><li>beg1：容器 1 开始迭代器</li><li>end1：容器 1 结束迭代器</li><li>beg2：容器 2 开始迭代器</li><li>end2：容器 2 结束迭代器</li><li>dest：目标容器开始迭代器</li></ul></li></ul></li><li>注意：<ul><li>求并集的两个集合必须的<strong>有序序列</strong>。</li><li>目标容器开辟空间需要<strong>两个容器相加</strong>。</li><li>set_union 返回值既是并集中最后一个元素的位置。</li></ul></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">myPrint</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v1;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v2;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        v1.push_back(i);</span><br><span class="line">        v2.push_back(i + <span class="number">5</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vTarget;</span><br><span class="line">    vTarget.resize(v1.size() + v2.size());  <span class="comment">// 取两个容器的和给目标容器开辟空间</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回目标容器的最后一个元素的迭代器地址</span></span><br><span class="line">    <span class="keyword">auto</span> itEnd = set_union(v1.begin(), v1.end(), v2.begin(), v2.end(), vTarget.begin());</span><br><span class="line"></span><br><span class="line">    for_each(vTarget.begin(), itEnd, myPrint());</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    test01();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="set-difference"><a href="#set-difference" class="headerlink" title="set_difference"></a>set_difference</h4><ul><li>函数原型：<ul><li><code>set_difference(iterator beg1, iterator end1, iterator beg2, iterator end2, iterator dest);  </code>：求两个集合的差集<ul><li>beg1：容器 1 开始迭代器</li><li>end1：容器 1 结束迭代器</li><li>beg2：容器 2 开始迭代器</li><li>end2：容器 2 结束迭代器</li><li>dest：目标容器开始迭代器</li></ul></li></ul></li><li>注意： <ul><li>v1 和 v2 的差集与 v2 和 v1 的差集是不一样的。</li><li>求差集的两个集合必须是<strong>有序序列</strong>。</li><li>目标容器开辟空间需要从<strong>两个容器取较大值</strong>。</li><li>set_difference 返回值既是差集中最后一个元素的位置。</li></ul></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">myPrint</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v1;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v2;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        v1.push_back(i);</span><br><span class="line">        v2.push_back(i + <span class="number">5</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vTarget;</span><br><span class="line"></span><br><span class="line">    vTarget.resize(max(v1.size(), v2.size()));  <span class="comment">// 取两个里面较大的值给目标容器开辟空间</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回目标容器的最后一个元素的迭代器地址</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;v1与v2的差集为： &quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">auto</span> itEnd =set_difference(v1.begin(), v1.end(), v2.begin(), v2.end(), vTarget.begin());</span><br><span class="line">    for_each(vTarget.begin(), itEnd, myPrint());</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;v2与v1的差集为： &quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    itEnd = set_difference(v2.begin(), v2.end(), v1.begin(), v1.end(), vTarget.begin());</span><br><span class="line">    for_each(vTarget.begin(), itEnd, myPrint());</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    test01();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">提高编程</summary>
    
    
    
    <category term="C++" scheme="https://nephrencake.github.io/categories/C/"/>
    
    
  </entry>
  
  <entry>
    <title>C++-Part2</title>
    <link href="https://nephrencake.github.io/2022/1/C++-Part2/"/>
    <id>https://nephrencake.github.io/2022/1/C++-Part2/</id>
    <published>2022-01-03T07:14:47.000Z</published>
    <updated>2022-02-10T10:46:16.863Z</updated>
    
    <content type="html"><![CDATA[<h1 id="C-Part2——核心编程"><a href="#C-Part2——核心编程" class="headerlink" title="C++-Part2——核心编程"></a>C++-Part2——核心编程</h1><p>[TOC]</p><h2 id="内存分区模型"><a href="#内存分区模型" class="headerlink" title="内存分区模型"></a>内存分区模型</h2><h3 id="内存分区概述"><a href="#内存分区概述" class="headerlink" title="内存分区概述"></a>内存分区概述</h3><ul><li><p>C++ 程序在执行时，将内存大方向划分为 4 个区域</p><ul><li>代码区：存放函数体的二进制代码，<strong>由操作系统进行管理的</strong></li><li>全局区：存放全局变量、静态变量、字符串常量、全局常量，<strong>在程序结束后由操作系统释放</strong></li><li>栈区：<strong>由编译器自动分配释放</strong>，存放函数的参数值、局部变量、局部常量等</li><li>堆区：<strong>由程序员分配和释放</strong>，若程序员不释放，则程序结束时由操作系统回收</li></ul></li><li><p>内存分区的意义：</p><ul><li>不同区域存放的数据，赋予不同的生命周期，提供更大的灵活编程</li></ul></li></ul><h3 id="程序运行前"><a href="#程序运行前" class="headerlink" title="程序运行前"></a>程序运行前</h3><ul><li>在程序编译后，生成了 exe 可执行程序，在程序运行前分为<strong>全局区</strong>和<strong>代码区</strong>。</li></ul><ul><li>代码区：<ul><li>存放 CPU 执行的机器指令</li><li>代码区是<strong>共享</strong>的，共享的目的是对于频繁被执行的程序，只需要在内存中有一份代码即可</li><li>代码区是<strong>只读</strong>的，使其只读的原因是防止程序意外地修改了它的指令</li></ul></li><li>全局区：<ul><li><strong>全局变量、静态变量</strong>存放在此.</li><li>全局区包含常量区，存放<strong>字符串常量、const 修饰的全局常量</strong>.</li><li><strong>该区域的数据仅在程序结束后由操作系统释放</strong></li></ul></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//全局变量</span></span><br><span class="line"><span class="keyword">int</span> g_a = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> g_b = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//全局常量</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> c_g_a = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> c_g_b = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//局部变量</span></span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">int</span> b = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//打印地址</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;局部变量a地址为： &quot;</span> &lt;&lt; (<span class="keyword">int</span>) &amp;a &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;局部变量b地址为： &quot;</span> &lt;&lt; (<span class="keyword">int</span>) &amp;b &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;全局变量g_a地址为： &quot;</span> &lt;&lt; (<span class="keyword">int</span>) &amp;g_a &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;全局变量g_b地址为： &quot;</span> &lt;&lt; (<span class="keyword">int</span>) &amp;g_b &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//静态变量</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> s_a = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> s_b = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;静态变量s_a地址为： &quot;</span> &lt;&lt; (<span class="keyword">int</span>) &amp;s_a &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;静态变量s_b地址为： &quot;</span> &lt;&lt; (<span class="keyword">int</span>) &amp;s_b &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;字符串常量地址为： &quot;</span> &lt;&lt; (<span class="keyword">int</span>) &amp;<span class="string">&quot;hello world&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;字符串常量地址为： &quot;</span> &lt;&lt; (<span class="keyword">int</span>) &amp;<span class="string">&quot;hello world1&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;全局常量c_g_a地址为： &quot;</span> &lt;&lt; (<span class="keyword">int</span>) &amp;c_g_a &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;全局常量c_g_b地址为： &quot;</span> &lt;&lt; (<span class="keyword">int</span>) &amp;c_g_b &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> c_l_a = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> c_l_b = <span class="number">10</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;局部常量c_l_a地址为： &quot;</span> &lt;&lt; (<span class="keyword">int</span>) &amp;c_l_a &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;局部常量c_l_b地址为： &quot;</span> &lt;&lt; (<span class="keyword">int</span>) &amp;c_l_b &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 局部变量a地址为： 14088016</span></span><br><span class="line"><span class="comment"> * 局部变量b地址为： 14088004</span></span><br><span class="line"><span class="comment"> * 全局变量g_a地址为： 15974400</span></span><br><span class="line"><span class="comment"> * 全局变量g_b地址为： 15974404</span></span><br><span class="line"><span class="comment"> * 静态变量s_a地址为： 15974412</span></span><br><span class="line"><span class="comment"> * 静态变量s_b地址为： 15974416</span></span><br><span class="line"><span class="comment"> * 字符串常量地址为： 15965632</span></span><br><span class="line"><span class="comment"> * 字符串常量地址为： 15965664</span></span><br><span class="line"><span class="comment"> * 全局常量c_g_a地址为： 15965260</span></span><br><span class="line"><span class="comment"> * 全局常量c_g_b地址为： 15965472</span></span><br><span class="line"><span class="comment"> * 局部常量c_l_a地址为： 14087992</span></span><br><span class="line"><span class="comment"> * 局部常量c_l_b地址为： 14087980</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><h3 id="程序运行后"><a href="#程序运行后" class="headerlink" title="程序运行后"></a>程序运行后</h3><ul><li>栈区：<ul><li>由编译器自动分配释放, 存放函数的参数值,局部变量等</li><li>注意事项：不要返回局部变量的地址，栈区开辟的数据由编译器自动释放</li></ul></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> *<span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">return</span> &amp;a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> *p = func();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; *p &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">// 在外部第一次调用时，编译器会对数据做一次保留</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; *p &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">// 第二次调用时彻底消失</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>堆区：<ul><li>由程序员分配释放，若程序员不释放，程序结束时由操作系统回收</li><li>在 C++ 中主要利用 new 在堆区开辟内存</li></ul></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> *<span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> *a = <span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">10</span>);</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> *p = func();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; *p &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; *p &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="new-操作符"><a href="#new-操作符" class="headerlink" title="new 操作符"></a>new 操作符</h3><ul><li><p>利用 new 操作符在堆区<strong>开辟</strong>数据</p></li><li><p>利用 delete 操作符在堆区<strong>释放</strong>数据</p></li></ul><ul><li><p>语法：</p><ul><li><code> new 数据类型</code></li><li><code>delete 变量名</code></li></ul></li><li><blockquote><p>返回的是该类型的指针/地址</p><p>删除的类型应当是指针/地址</p></blockquote></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 堆区创建int</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> *<span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> *a = <span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">10</span>);  <span class="comment">// 利用new创建的数据，会返回该数据对应的类型的指针</span></span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> *p = func();</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; *p &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 利用delete释放堆区数据</span></span><br><span class="line">    <span class="keyword">delete</span> p;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; *p &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">// 报错，释放的空间不可访问</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 堆区开辟数组</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> *arr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>]&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>,&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        arr[i] = i + <span class="number">100</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; arr[i] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//释放数组 delete 后加 []</span></span><br><span class="line">    <span class="keyword">delete</span>[] arr;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><blockquote><p>参考：<a href="https://www.zhihu.com/question/37608201/answer/1601079930">c++中，引用和指针的区别是什么？ - 编程指北的回答 - 知乎</a> </p></blockquote><h3 id="引用的基本使用"><a href="#引用的基本使用" class="headerlink" title="引用的基本使用"></a>引用的基本使用</h3><ul><li><p>作用：给变量起别名</p></li><li><p>语法：<code>数据类型 &amp;别名 = 原名</code></p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">int</span> &amp;b = a;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;b = &quot;</span> &lt;&lt; b &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    b = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;b = &quot;</span> &lt;&lt; b &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="引用注意事项"><a href="#引用注意事项" class="headerlink" title="引用注意事项"></a>引用注意事项</h3><ul><li>引用必须初始化</li><li>引用在初始化后，不可以改变</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">int</span> b = <span class="number">20</span>;</span><br><span class="line">    <span class="comment">// int &amp;c;  // 错误，引用必须初始化</span></span><br><span class="line">    <span class="keyword">int</span> &amp;c = a;  <span class="comment">// 一旦初始化后，就不可以更改</span></span><br><span class="line">    c = b;  <span class="comment">// 这是赋值操作，不是更改引用</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;b = &quot;</span> &lt;&lt; b &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;c = &quot;</span> &lt;&lt; c &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="引用做函数参数"><a href="#引用做函数参数" class="headerlink" title="引用做函数参数"></a>引用做函数参数</h3><ul><li><p>作用：函数传参时，可以利用引用的技术让形参修饰实参</p></li><li><p>优点：可以简化指针修改实参</p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1. 值传递</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mySwap01</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp = a;</span><br><span class="line">    a = b;</span><br><span class="line">    b = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2. 地址传递</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mySwap02</span><span class="params">(<span class="keyword">int</span> *a, <span class="keyword">int</span> *b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp = *a;</span><br><span class="line">    *a = *b;</span><br><span class="line">    *b = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//3. 引用传递</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mySwap03</span><span class="params">(<span class="keyword">int</span> &amp;a, <span class="keyword">int</span> &amp;b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp = a;</span><br><span class="line">    a = b;</span><br><span class="line">    b = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">int</span> b = <span class="number">20</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;a:&quot;</span> &lt;&lt; a &lt;&lt; <span class="string">&quot; b:&quot;</span> &lt;&lt; b &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">// a:10 b:20</span></span><br><span class="line"></span><br><span class="line">    mySwap01(a, b);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;a:&quot;</span> &lt;&lt; a &lt;&lt; <span class="string">&quot; b:&quot;</span> &lt;&lt; b &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">// a:10 b:20</span></span><br><span class="line"></span><br><span class="line">    mySwap02(&amp;a, &amp;b);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;a:&quot;</span> &lt;&lt; a &lt;&lt; <span class="string">&quot; b:&quot;</span> &lt;&lt; b &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">// a:20 b:10</span></span><br><span class="line"></span><br><span class="line">    mySwap03(a, b);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;a:&quot;</span> &lt;&lt; a &lt;&lt; <span class="string">&quot; b:&quot;</span> &lt;&lt; b &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">// a:10 b:20</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="引用做函数返回值"><a href="#引用做函数返回值" class="headerlink" title="引用做函数返回值"></a>引用做函数返回值</h3><ul><li><p>作用：引用是可以作为函数的返回值存在的</p></li><li><p>注意：<strong>不要返回局部变量引用</strong></p></li><li><p>用法：函数调用作为左值</p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回局部变量引用</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> &amp;<span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">10</span>;  <span class="comment">// 局部变量</span></span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回静态变量引用</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> &amp;<span class="title">test02</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> a = <span class="number">20</span>;  <span class="comment">// 静态变量，操作的是位于全局区的变量，不会新建一个对象</span></span><br><span class="line">    <span class="comment">// int &amp;a = *(new int(20));  // 堆区变量，两次调用返回两个不同的对象</span></span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 不能返回局部变量的引用</span></span><br><span class="line">    <span class="keyword">int</span> &amp;ref = test01();</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;ref = &quot;</span> &lt;&lt; ref &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">// ref = 13630156</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;ref = &quot;</span> &lt;&lt; ref &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">// ref = 13630156</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果函数做左值，那么必须返回引用</span></span><br><span class="line">    <span class="keyword">int</span> &amp;ref2 = test02();</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;ref2 = &quot;</span> &lt;&lt; ref2 &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">// ref2 = 20</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;ref2 = &quot;</span> &lt;&lt; ref2 &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">// ref2 = 20</span></span><br><span class="line"></span><br><span class="line">    test02() = <span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;ref2 = &quot;</span> &lt;&lt; ref2 &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">// ref2 = 1000</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;ref2 = &quot;</span> &lt;&lt; ref2 &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">// ref2 = 1000</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="引用的本质"><a href="#引用的本质" class="headerlink" title="引用的本质"></a>引用的本质</h3><ul><li>本质：<strong>引用的本质在 C++ 内部实现是一个指针常量</strong>。</li><li>C++ 推荐用引用技术，因为语法方便，引用本质是指针常量，但是所有的指针操作编译器都帮我们做了</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 发现是引用，转换为 int* const ref = &amp;a;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> &amp;ref)</span> </span>&#123;</span><br><span class="line">    ref = <span class="number">100</span>;  <span class="comment">// ref是引用，转换为*ref = 100</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 自动转换为 int* const ref = &amp;a; 指针常量是指针指向不可改，也说明为什么引用不可更改</span></span><br><span class="line">    <span class="keyword">int</span> &amp;ref = a;</span><br><span class="line">    ref = <span class="number">20</span>;  <span class="comment">// 内部发现ref是引用，自动帮我们转换为: *ref = 20;</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;a:&quot;</span> &lt;&lt; a &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;ref:&quot;</span> &lt;&lt; ref &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    func(a);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="常量引用"><a href="#常量引用" class="headerlink" title="常量引用"></a>常量引用</h3><ul><li>作用：常量引用主要用来修饰形参，防止误操作</li><li>在函数形参列表中，<strong>加 const 修饰形参，防止形参改变实参</strong></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 发现是引用，转换为 int* const ref = &amp;a;</span></span><br><span class="line"><span class="comment">// 引用使用的场景，通常用来修饰形参</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">showValue</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> &amp;v)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// v += 10;</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; v &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// int&amp; ref = 10;  引用本身需要一个合法的内存空间，因此这行错误</span></span><br><span class="line">    <span class="comment">// 加入const就可以了，编译器优化代码，int temp = 10; const int&amp; ref = temp;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> &amp;ref = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ref = 100;  // 加入const后不可以修改变量</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ref &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 函数中利用常量引用防止误操作修改实参</span></span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">    showValue(a);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="函数提高"><a href="#函数提高" class="headerlink" title="函数提高"></a>函数提高</h2><h3 id="函数默认参数"><a href="#函数默认参数" class="headerlink" title="函数默认参数"></a>函数默认参数</h3><ul><li><p>在 C++ 中，函数的形参列表中的形参是可以有默认值的。</p></li><li><p>语法：<code> 返回值类型 函数名 (参数= 默认值) &#123;&#125;</code></p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">func1</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b = <span class="number">10</span>, <span class="keyword">int</span> c = <span class="number">10</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b + c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. 如果某个位置参数有默认值，那么从这个位置往后，从左向右，必须都要有默认值</span></span><br><span class="line"><span class="comment">// 2. 如果函数声明/实现有默认值，则函数实现/声明的时候就不能有默认参数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">func2</span><span class="params">(<span class="keyword">int</span> a = <span class="number">10</span>, <span class="keyword">int</span> b = <span class="number">10</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">func2</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;ret = &quot;</span> &lt;&lt; func1(<span class="number">20</span>, <span class="number">20</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;ret = &quot;</span> &lt;&lt; func2(<span class="number">100</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="函数占位参数"><a href="#函数占位参数" class="headerlink" title="函数占位参数"></a>函数占位参数</h3><ul><li><p>C++ 中函数的形参列表里可以有占位参数，用来做占位，调用函数时必须填补该位置</p></li><li><p>语法： <code>返回值类型 函数名 (数据类型) &#123;&#125;</code></p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//函数占位参数 ，占位参数也可以有默认参数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> = <span class="number">10</span>)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;this is func&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    func(<span class="number">10</span>, <span class="number">10</span>); <span class="comment">//占位参数必须填补</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="函数重载"><a href="#函数重载" class="headerlink" title="函数重载"></a>函数重载</h3><h4 id="函数重载概述"><a href="#函数重载概述" class="headerlink" title="函数重载概述"></a>函数重载概述</h4><ul><li><p>作用：函数名可以相同，提高复用性</p></li><li><p>函数重载满足条件：</p><ul><li>同一个作用域下</li><li>函数名称相同</li><li>函数参数<strong>类型不同</strong>或者<strong>个数不同</strong>或者<strong>顺序不同</strong>。</li></ul></li><li><p>注意:  函数的返回值不可以作为函数重载的条件</p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//函数重载需要函数都在同一个作用域下</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;func 的调用！&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> a)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;func (int a) 的调用！&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">double</span> a)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;func (double a)的调用！&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">double</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;func (int a ,double b) 的调用！&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">double</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;func (double a ,int b)的调用！&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//函数返回值不可以作为函数重载条件</span></span><br><span class="line"><span class="comment">//int func(double a, int b)</span></span><br><span class="line"><span class="comment">//&#123;</span></span><br><span class="line"><span class="comment">//cout &lt;&lt; &quot;func (double a ,int b)的调用！&quot; &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    func();</span><br><span class="line">    func(<span class="number">10</span>);</span><br><span class="line">    func(<span class="number">3.14</span>);</span><br><span class="line">    func(<span class="number">10</span>, <span class="number">3.14</span>);</span><br><span class="line">    func(<span class="number">3.14</span>, <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="函数重载注意事项"><a href="#函数重载注意事项" class="headerlink" title="函数重载注意事项"></a>函数重载注意事项</h4><ul><li>引用作为重载条件</li><li>函数重载碰到函数默认参数</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1、引用作为重载条件</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func1</span><span class="params">(<span class="keyword">int</span> &amp;a)</span> </span>&#123;  <span class="comment">// int &amp;a = 10; 不合法</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;func (int &amp;a) 调用 &quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func1</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> &amp;a)</span> </span>&#123;  <span class="comment">// const int &amp;a = 10; 合法</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;func (const int &amp;a) 调用 &quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2、函数重载碰到函数默认参数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func2</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b = <span class="number">10</span>)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;func2(int a, int b = 10) 调用&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func2</span><span class="params">(<span class="keyword">int</span> a)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;func2(int a) 调用&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">    func1(a); <span class="comment">// 调用无const</span></span><br><span class="line">    func1(<span class="number">10</span>);<span class="comment">// 调用有const</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//func2(10); // 碰到默认参数产生歧义，需要避免</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="类和对象"><a href="#类和对象" class="headerlink" title="类和对象"></a>类和对象</h2><blockquote><p>面向对象的三大特性为：<strong>封装</strong>、<strong>继承</strong>、<strong>多态</strong>。</p><p><strong>万事万物都皆为对象</strong>，对象上有其属性和行为。</p></blockquote><h3 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h3><h4 id="封装的意义"><a href="#封装的意义" class="headerlink" title="封装的意义"></a>封装的意义</h4><ul><li><p>封装的意义：</p><ul><li>将属性和行为作为一个整体</li><li>将属性和行为加以权限控制<ul><li>公共权限（public）：类内可以访问，类外可以访问，子类可以访问</li><li>保护权限（protected）：类内可以访问，类外不可以访问，子类可以访问</li><li>私有权限（private）：类内可以访问，类外不可以访问，子类不可以访问</li></ul></li></ul></li><li><p>语法：<code>class 类名 &#123; 访问权限： 属性 / 行为 &#125;;</code></p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line">    <span class="comment">//姓名  公共权限</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">string</span> m_Name;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//汽车  保护权限</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="built_in">string</span> m_Car;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//银行卡密码  私有权限</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> m_Password;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        m_Name = <span class="string">&quot;张三&quot;</span>;</span><br><span class="line">        m_Car = <span class="string">&quot;拖拉机&quot;</span>;</span><br><span class="line">        m_Password = <span class="number">123456</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Person p;</span><br><span class="line">    p.m_Name = <span class="string">&quot;李四&quot;</span>;</span><br><span class="line">    <span class="comment">//p.m_Car = &quot;奔驰&quot;;  // 保护权限类外访问不到</span></span><br><span class="line">    <span class="comment">//p.m_Password = 123; // 私有权限类外访问不到</span></span><br><span class="line">    p.func();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="truct-和-class-区别"><a href="#truct-和-class-区别" class="headerlink" title="truct 和 class 区别"></a>truct 和 class 区别</h4><ul><li><p>在 C++ 中 struct 和 class 唯一的区别就在于默认的访问权限不同</p></li><li><p>区别：</p><ul><li>struct：默认权限为公共</li><li>class：默认权限为私有</li></ul></li></ul><h4 id="成员属性设置为私有"><a href="#成员属性设置为私有" class="headerlink" title="成员属性设置为私有"></a>成员属性设置为私有</h4><ul><li>优点<ul><li>将所有成员属性设置为私有，可以自己控制读写权限</li><li>对于写权限，我们可以检测数据的有效性</li></ul></li></ul><h3 id="对象的初始化和清理"><a href="#对象的初始化和清理" class="headerlink" title="对象的初始化和清理"></a>对象的初始化和清理</h3><h4 id="构造函数和析构函数"><a href="#构造函数和析构函数" class="headerlink" title="构造函数和析构函数"></a>构造函数和析构函数</h4><ul><li><p>对象的<strong>初始化和清理</strong>是两个非常重要的安全问题</p><ul><li>一个对象或者变量没有初始状态，对其使用后果是未知</li><li>同样的使用完一个对象或变量，没有及时清理，也会造成一定的安全问题</li></ul></li><li><p>c++利用了<strong>构造函数</strong>和<strong>析构函数</strong>解决上述问题，这两个函数将会被编译器自动调用，完成对象初始化和清理工作。</p><ul><li>对象的初始化和清理工作是编译器强制要我们做的事情，因此如果<strong>我们不提供构造和析构，编译器会提供</strong></li><li><strong>编译器提供的构造函数和析构函数是空实现。</strong></li></ul></li></ul><ul><li>构造函数 <code>类名()&#123;&#125;</code>：主要作用在于<strong>创建对象时</strong>为对象的成员属性赋值，构造函数由编译器自动调用，无须手动调用。<ol><li>构造函数，没有返回值也不写 void</li><li>函数名称与类名相同</li><li>构造函数可以有参数，因此可以发生重载</li><li>程序在调用对象时候会自动调用构造，无须手动调用，而且只会调用一次</li></ol></li><li>析构函数 <code>~类名()&#123;&#125;</code>：主要作用在于对象<strong>销毁前</strong>系统自动调用，执行一些清理工作。<ol><li>析构函数，没有返回值也不写 void</li><li>函数名称与类名相同,在名称前加上符号  ~</li><li>析构函数不可以有参数，因此不可以发生重载</li><li>程序在对象销毁前会自动调用析构，无须手动调用，而且只会调用一次</li></ol></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//构造函数</span></span><br><span class="line">    Person() &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Person的构造函数调用&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//析构函数</span></span><br><span class="line">    ~Person() &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Person的析构函数调用&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Person p;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="构造函数的分类及调用"><a href="#构造函数的分类及调用" class="headerlink" title="构造函数的分类及调用"></a>构造函数的分类及调用</h4><ul><li>两种分类方式：<ul><li>按参数分为：有参构造和无参构造<ul><li>无参又称为默认构造函数</li></ul></li><li>按类型分为：普通构造和拷贝构造</li></ul></li><li>三种调用方式：<ul><li>括号法</li><li>显示法</li><li>隐式转换法</li></ul></li><li>注意<ul><li>调用无参构造函数不能加括号，如果加了编译器认为这是一个函数声明</li><li>不能利用拷贝构造函数初始化匿名对象，否则编译器认为是对象声明（老版本）</li></ul></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1、构造函数分类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 无参(默认)构造函数</span></span><br><span class="line">    Person() &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;无参构造函数!&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 有参普通构造函数</span></span><br><span class="line">    Person(<span class="keyword">int</span> a) &#123;</span><br><span class="line">        age = a;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;有参构造函数!&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 拷贝构造函数</span></span><br><span class="line">    <span class="comment">// 可以不写，编译器提供的拷贝函数自动复制成员变量值</span></span><br><span class="line">    Person(<span class="keyword">const</span> Person &amp;p) &#123;</span><br><span class="line">        age = p.age;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;拷贝构造函数!&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 析构函数</span></span><br><span class="line">    ~Person() &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;析构函数!&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2、构造函数的调用</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 调用无参构造函数</span></span><br><span class="line">    Person p; <span class="comment">//调用无参构造函数</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用有参的构造函数</span></span><br><span class="line">    <span class="comment">// 2.1  括号法，常用</span></span><br><span class="line">    <span class="function">Person <span class="title">p1</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">    <span class="comment">//注意1：调用无参构造函数不能加括号，如果加了编译器认为这是一个函数声明</span></span><br><span class="line">    <span class="comment">//Person p2();</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.2 显式法</span></span><br><span class="line">    Person p2 = Person(<span class="number">10</span>);</span><br><span class="line">    Person p3 = Person(p2);</span><br><span class="line">    Person(<span class="number">10</span>);  <span class="comment">// 单独写就是匿名对象  当前行结束之后，马上析构</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.3 隐式转换法</span></span><br><span class="line">    Person p4 = <span class="number">10</span>; <span class="comment">// Person p4 = Person(10);</span></span><br><span class="line">    Person p5 = p4; <span class="comment">// Person p5 = Person(p4);</span></span><br><span class="line">    <span class="comment">//注意2：不能利用 拷贝构造函数 初始化匿名对象 编译器认为是对象声明</span></span><br><span class="line">    <span class="comment">//Person p6(p4);</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="拷贝构造函数调用时机"><a href="#拷贝构造函数调用时机" class="headerlink" title="拷贝构造函数调用时机"></a>拷贝构造函数调用时机</h4><ul><li>C++ 中拷贝构造函数调用时机通常有三种情况<ul><li>使用一个已经创建完毕的对象来初始化一个新对象</li><li>值传递的方式给函数参数传值</li><li>以值方式返回局部对象</li></ul></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 使用一个已经创建完毕的对象来初始化一个新对象</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">Person <span class="title">man</span><span class="params">(<span class="number">100</span>)</span></span>;  <span class="comment">// p对象已经创建完毕</span></span><br><span class="line">    <span class="function">Person <span class="title">newman</span><span class="params">(man)</span></span>;  <span class="comment">// 调用拷贝构造函数</span></span><br><span class="line">    Person newman2 = man;  <span class="comment">// 拷贝构造</span></span><br><span class="line">    Person newman3;</span><br><span class="line">    newman3 = man;  <span class="comment">// 不是调用拷贝构造函数，赋值操作</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 值传递的方式给函数参数传值</span></span><br><span class="line"><span class="comment">// 相当于 Person p1 = p;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doWork</span><span class="params">(Person p1)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Person p;  <span class="comment">// 无参构造函数</span></span><br><span class="line">    doWork(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 以值方式返回局部对象</span></span><br><span class="line"><span class="function">Person <span class="title">doWork2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Person p1;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; (<span class="keyword">int</span> *) &amp;p1 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> p1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test03</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Person p = doWork2();</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; (<span class="keyword">int</span> *) &amp;p &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    test01();</span><br><span class="line">    <span class="comment">// test02();</span></span><br><span class="line">    <span class="comment">// test03();</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="构造函数调用规则"><a href="#构造函数调用规则" class="headerlink" title="构造函数调用规则"></a>构造函数调用规则</h4><ul><li><p>默认情况下，c++ 编译器至少给一个类添加 3 个函数</p><ol><li>默认构造函数（无参，函数体为空）</li><li>默认析构函数（无参，函数体为空）</li><li>默认拷贝构造函数，对属性进行值拷贝</li></ol></li><li><p>构造函数调用规则如下：</p><ul><li><p>如果用户定义有参构造函数，C++ 不会提供默认无参构造，但是会提供默认拷贝构造</p></li><li><p>如果用户定义拷贝构造函数，C++ 不会再提供其他构造函数</p></li></ul></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">Person <span class="title">p1</span><span class="params">(<span class="number">18</span>)</span></span>;</span><br><span class="line">    <span class="function">Person <span class="title">p2</span><span class="params">(p1)</span></span>;  <span class="comment">//如果不写拷贝构造，编译器会自动添加拷贝构造，并且做浅拷贝操作</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;p2的年龄为： &quot;</span> &lt;&lt; p2.age &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 如果用户提供有参构造，编译器不会提供默认构造，但会提供拷贝构造</span></span><br><span class="line">    Person p1;  <span class="comment">// 此时如果用户自己没有提供默认构造，会出错</span></span><br><span class="line">    <span class="function">Person <span class="title">p2</span><span class="params">(<span class="number">10</span>)</span></span>;  <span class="comment">// 用户提供的有参</span></span><br><span class="line">    <span class="function">Person <span class="title">p3</span><span class="params">(p2)</span></span>;  <span class="comment">// 此时如果用户没有提供拷贝构造，编译器会提供</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果用户提供拷贝构造，编译器不会提供其他构造函数</span></span><br><span class="line">    Person p4;  <span class="comment">// 此时如果用户自己没有提供默认构造，会出错</span></span><br><span class="line">    <span class="function">Person <span class="title">p5</span><span class="params">(<span class="number">10</span>)</span></span>;  <span class="comment">// 此时如果用户自己没有提供有参，会出错</span></span><br><span class="line">    <span class="function">Person <span class="title">p6</span><span class="params">(p5)</span></span>;  <span class="comment">// 用户自己提供拷贝构造</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    test01();</span><br><span class="line">    test02();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="深拷贝与浅拷贝"><a href="#深拷贝与浅拷贝" class="headerlink" title="深拷贝与浅拷贝"></a>深拷贝与浅拷贝</h4><ul><li><p>浅拷贝：简单的赋值拷贝操作</p></li><li><p>深拷贝：在堆区重新申请空间，进行拷贝操作</p></li><li><blockquote><p>注意：如果属性有在堆区开辟的，一定要自己提供拷贝构造函数，防止浅拷贝带来的问题</p></blockquote></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> m_age&#123;&#125;;</span><br><span class="line">    <span class="keyword">int</span> *m_height&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//无参（默认）构造函数</span></span><br><span class="line">    Person() &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;无参构造函数!&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//有参构造函数</span></span><br><span class="line">    Person(<span class="keyword">int</span> age, <span class="keyword">int</span> height) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;有参构造函数!&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        m_age = age;</span><br><span class="line">        m_height = <span class="keyword">new</span> <span class="keyword">int</span>(height);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//拷贝构造函数</span></span><br><span class="line">    Person(<span class="keyword">const</span> Person &amp;p) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;拷贝构造函数!&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="comment">//如果不利用深拷贝在堆区创建新内存，有可能会导致浅拷贝带来的重复释放堆区问题</span></span><br><span class="line">        m_age = p.m_age;</span><br><span class="line">        m_height = <span class="keyword">new</span> <span class="keyword">int</span>(*p.m_height);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//析构函数</span></span><br><span class="line">    ~Person() &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;析构函数!&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">if</span> (m_height != <span class="literal">nullptr</span> &amp;&amp; *m_height != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">delete</span> m_height;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">Person <span class="title">p1</span><span class="params">(<span class="number">18</span>, <span class="number">180</span>)</span></span>;</span><br><span class="line">    <span class="function">Person <span class="title">p2</span><span class="params">(p1)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;p1的年龄： &quot;</span> &lt;&lt; p1.m_age &lt;&lt; <span class="string">&quot; 身高： &quot;</span> &lt;&lt; *p1.m_height &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;p2的年龄： &quot;</span> &lt;&lt; p2.m_age &lt;&lt; <span class="string">&quot; 身高： &quot;</span> &lt;&lt; *p2.m_height &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="初始化列表"><a href="#初始化列表" class="headerlink" title="初始化列表"></a>初始化列表</h4><ul><li>作用：C++ 提供了初始化列表语法，用来初始化属性</li><li>语法：<code>构造函数()：属性1(值1),属性2（值2）... &#123;&#125;</code></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> m_A;</span><br><span class="line">    <span class="keyword">int</span> m_B;</span><br><span class="line">    <span class="keyword">int</span> m_C;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 传统方式初始化</span></span><br><span class="line">    <span class="comment">//Person(int a, int b, int c) &#123;</span></span><br><span class="line">    <span class="comment">//m_A = a;</span></span><br><span class="line">    <span class="comment">//m_B = b;</span></span><br><span class="line">    <span class="comment">//m_C = c;</span></span><br><span class="line">    <span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//初始化列表方式初始化</span></span><br><span class="line">    Person(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c) : m_A(a), m_B(b), m_C(c) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">PrintPerson</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;mA:&quot;</span> &lt;&lt; m_A &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;mB:&quot;</span> &lt;&lt; m_B &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;mC:&quot;</span> &lt;&lt; m_C &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">Person <span class="title">p</span><span class="params">(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span></span>;</span><br><span class="line">    p.PrintPerson();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="类对象作为类成员"><a href="#类对象作为类成员" class="headerlink" title="类对象作为类成员"></a>类对象作为类成员</h4><ul><li>C++ 类中的成员可以是另一个类的对象，我们称该成员为<strong>对象成员</strong>。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> &#123;</span></span><br><span class="line">    A a；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>一个对象 A 与其对象成员 B 的构造和析构的先后顺序？<ul><li>先构造对象成员 B</li><li>先析构对象 A</li><li>析构顺序与构造相反</li></ul></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Phone</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">string</span> m_PhoneName;</span><br><span class="line"></span><br><span class="line">    Phone(<span class="built_in">string</span> name) &#123;</span><br><span class="line">        m_PhoneName = name;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Phone构造&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~Phone() &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Phone析构&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">string</span> m_Name;</span><br><span class="line">    Phone m_Phone;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//初始化列表可以告诉编译器调用哪一个构造函数</span></span><br><span class="line">    Person(<span class="built_in">string</span> name, <span class="built_in">string</span> pName) : m_Name(name), m_Phone(pName) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="keyword">this</span>-&gt;m_Name &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Person构造&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~Person() &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Person析构&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">playGame</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; m_Name &lt;&lt; <span class="string">&quot; 使用&quot;</span> &lt;&lt; m_Phone.m_PhoneName &lt;&lt; <span class="string">&quot; 牌手机! &quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">Person <span class="title">p</span><span class="params">(<span class="string">&quot;张三&quot;</span>, <span class="string">&quot;苹果X&quot;</span>)</span></span>;</span><br><span class="line">    p.playGame();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="静态成员"><a href="#静态成员" class="headerlink" title="静态成员"></a>静态成员</h4><ul><li><p>静态成员就是在成员变量和成员函数前加上关键字 static，称为静态成员</p></li><li><p>静态成员分为：</p><ul><li>静态成员变量<ul><li> 所有对象共享同一份数据</li><li> 在编译阶段分配内存</li><li> 类内声明，类外初始化</li></ul></li><li>静态成员函数<ul><li> 所有对象共享同一个函数</li><li> 静态成员函数只能访问静态成员变量</li></ul></li></ul></li><li><p>静态成员变量特点：</p><ol><li>在编译阶段分配内存</li><li>类内声明，类外初始化</li><li>所有对象共享同一份数据</li></ol></li><li><p>静态成员函数特点：</p><ol><li>程序共享一个函数</li><li>静态成员函数只能访问静态成员变量</li></ol></li><li><p>静态成员变量与函数都可以设定访问权限</p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> m_C;  <span class="comment">// 静态成员变量也是有访问权限的</span></span><br><span class="line">    <span class="keyword">int</span> m_B;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 静态成员函数也是有访问权限的</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">func2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;func2调用&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> m_A;  <span class="comment">// 静态成员变量</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;func调用&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        m_A = <span class="number">100</span>;</span><br><span class="line">        <span class="comment">//m_B = 100;  // 错误，不可以访问非静态成员变量</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> Person::m_A = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> Person::m_C = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//静态成员变量两种访问方式</span></span><br><span class="line">    <span class="comment">//1、通过对象</span></span><br><span class="line">    Person p1;</span><br><span class="line">    p1.m_A = <span class="number">100</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;p1.m_A = &quot;</span> &lt;&lt; p1.m_A &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    Person p2;</span><br><span class="line">    p2.m_A = <span class="number">200</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;p1.m_A = &quot;</span> &lt;&lt; p1.m_A &lt;&lt; <span class="built_in">endl</span>; <span class="comment">//共享同一份数据</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;p2.m_A = &quot;</span> &lt;&lt; p2.m_A &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2、通过类名</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;m_A = &quot;</span> &lt;&lt; Person::m_A &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//cout &lt;&lt; &quot;m_C = &quot; &lt;&lt; Person::m_C &lt;&lt; endl; //私有权限访问不到</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//静态成员变量两种访问方式</span></span><br><span class="line">    <span class="comment">//1、通过对象</span></span><br><span class="line">    Person p1;</span><br><span class="line">    p1.func();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2、通过类名</span></span><br><span class="line">    Person::func();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Person::func2(); // 私有权限访问不到</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    test01();</span><br><span class="line">    test02();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="C-对象模型和-this-指针"><a href="#C-对象模型和-this-指针" class="headerlink" title="C++ 对象模型和 this 指针"></a>C++ 对象模型和 this 指针</h3><h4 id="成员变量和成员函数分开存储"><a href="#成员变量和成员函数分开存储" class="headerlink" title="成员变量和成员函数分开存储"></a>成员变量和成员函数分开存储</h4><ul><li><p>在 C++ 中，类内的成员变量和成员函数分开存储</p></li><li><p>注意：只有<strong>非静态成员变量</strong>才属于类的对象上</p></li><li><blockquote><ol><li>空对象占用的是 1 字节<ul><li>C++ 为每个空对象分配一个字节的空间，为了区分空对象占内存的位置</li></ul></li><li>存在<strong>非静态成员变量</strong>时，按照非静态成员变量的大小和分配空间</li></ol></blockquote></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 非静态成员变量占对象空间</span></span><br><span class="line">    <span class="keyword">int</span> mA;</span><br><span class="line">    <span class="comment">// 静态成员变量不占对象空间</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> mB;</span><br><span class="line"></span><br><span class="line">    Person() &#123;</span><br><span class="line">        mA = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 函数也不占对象空间，所有函数共享一个函数实例</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//静态成员函数也不占对象空间</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">s_func</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="keyword">sizeof</span>(Person) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="this-指针概念"><a href="#this-指针概念" class="headerlink" title="this 指针概念"></a>this 指针概念</h4><ul><li><p><strong>每一个非静态成员函数只会诞生一份函数实例</strong>，即多个同类的对象会共用一块代码</p></li><li><p>针对问题：非静态成员函数如何区分调用自己的对象</p><ul><li><p>this 指针指向调用的成员函数的对象</p></li><li><p>this 指针是隐含在每一个非静态成员函数内的一种指针</p></li><li><p>this 指针不需要定义，直接使用即可</p></li></ul></li><li><p>this 指针的用途：</p><ul><li>当形参和成员变量同名时，可用 this 指针来区分</li><li>在类的非静态成员函数中返回对象本身，可使用 <code>return *this</code>。</li></ul></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    Person(<span class="keyword">int</span> age) &#123;</span><br><span class="line">        <span class="comment">//1、当形参和成员变量同名时，可用this指针来区分</span></span><br><span class="line">        <span class="keyword">this</span>-&gt;age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">Person &amp;<span class="title">PersonAddPerson</span><span class="params">(Person p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;age += p.age;</span><br><span class="line">        <span class="comment">//返回对象本身</span></span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">Person <span class="title">p1</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;p1.age = &quot;</span> &lt;&lt; p1.age &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">Person <span class="title">p2</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">    p2.PersonAddPerson(p1).PersonAddPerson(p1).PersonAddPerson(p1);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;p2.age = &quot;</span> &lt;&lt; p2.age &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="空指针访问成员函数"><a href="#空指针访问成员函数" class="headerlink" title="空指针访问成员函数"></a>空指针访问成员函数</h4><ul><li><p>C++ 中空指针也是可以调用非静态成员函数，但是要注意不能用到 this 指针</p></li><li><p>首先要避免空指针</p><ul><li>如果空指针对象调用的函数必须用到 this 指针，需要加以判断保证代码的健壮性</li></ul></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//空指针访问成员函数</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> mAge;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">ShowClassName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;我是Person类!&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">ShowPerson</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; mAge &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Person *p = <span class="literal">nullptr</span>;</span><br><span class="line">    p-&gt;ShowClassName();  <span class="comment">// 空指针，可以非静态调用成员函数</span></span><br><span class="line">    p-&gt;ShowPerson();  <span class="comment">// 但是如果成员函数中用到了this指针，就不可以了</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="const-修饰成员函数"><a href="#const-修饰成员函数" class="headerlink" title="const 修饰成员函数"></a>const 修饰成员函数</h4><ul><li><p>常函数：</p><ul><li>声明成员函数时在函数名后加 const ，即常函数</li><li>常函数内不可以修改非静态成员变量</li></ul></li><li><p>常对象：</p><ul><li>声明对象前加 const ，则该对象为常对象</li><li>常对象只能调用常函数</li></ul></li><li><p>用 mutable 修饰的非静态成员变量，在常函数、常变量中依然可以修改</p></li><li><blockquote><p>this 指针的本质是一个指针常量，指针的指向不可修改。</p><p>如果想让指针指向的值也不可以修改，需要声明常函数。</p></blockquote></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> m_A;</span><br><span class="line">    <span class="keyword">mutable</span> <span class="keyword">int</span> m_B;  <span class="comment">// 可修改、可变的</span></span><br><span class="line"></span><br><span class="line">    Person() &#123;</span><br><span class="line">        m_A = <span class="number">0</span>;</span><br><span class="line">        m_B = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">ShowPerson</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">        <span class="comment">// const Type* const pointer;</span></span><br><span class="line">        <span class="comment">// const 修饰成员函数，表示指针指向的内存空间的数据不能修改，除了 mutable 修饰的变量</span></span><br><span class="line">        <span class="keyword">this</span>-&gt;m_B = <span class="number">100</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">MyFunc</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">        <span class="comment">//mA = 10000;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> Person person;  <span class="comment">// 常量对象</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; person.m_A &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">//person.mA = 100;  // 常对象不能修改成员变量的值,但是可以访问</span></span><br><span class="line">    person.m_B = <span class="number">100</span>;  <span class="comment">// 但是常对象可以修改mutable修饰成员变量</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 常对象访问成员函数</span></span><br><span class="line">    person.MyFunc();  <span class="comment">// 常对象只能调用常函数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="友元"><a href="#友元" class="headerlink" title="友元"></a>友元</h3><ul><li><p>针对问题：对于有些私有属性，也想让类外特殊的函数或类访问</p></li><li><p>友元 <code>friend</code> 的目的：让一个函数或者类访问另一个类中私有成员</p></li><li><p>友元的三种实现：</p><ul><li>全局函数做友元</li><li>类做友元</li><li>成员函数做友元</li></ul></li></ul><h4 id="全局函数做友元"><a href="#全局函数做友元" class="headerlink" title="全局函数做友元"></a>全局函数做友元</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Building</span> &#123;</span></span><br><span class="line">    <span class="comment">// 告诉编译器 goodGay 全局函数 是 Building类的好朋友，可以访问类中的私有内容</span></span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="keyword">void</span> <span class="title">goodGay</span><span class="params">(Building *building)</span></span>;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">string</span> m_BedRoom; <span class="comment">//卧室</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">string</span> m_SittingRoom; <span class="comment">//客厅</span></span><br><span class="line">    </span><br><span class="line">    Building() &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;m_SittingRoom = <span class="string">&quot;客厅&quot;</span>;</span><br><span class="line">        <span class="keyword">this</span>-&gt;m_BedRoom = <span class="string">&quot;卧室&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">goodGay</span><span class="params">(Building *building)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;好基友正在访问： &quot;</span> &lt;&lt; building-&gt;m_SittingRoom &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;好基友正在访问： &quot;</span> &lt;&lt; building-&gt;m_BedRoom &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Building b;</span><br><span class="line">    goodGay(&amp;b);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="类做友元"><a href="#类做友元" class="headerlink" title="类做友元"></a>类做友元</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 先声明类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Building</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">goodGay</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Building *building;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    goodGay();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">visit</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Building</span> &#123;</span></span><br><span class="line">    <span class="comment">// 告诉编译器 goodGay 类是 Building 类的好朋友，可以访问到 Building 类中私有内容</span></span><br><span class="line">    <span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">goodGay</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">string</span> m_BedRoom;  <span class="comment">// 卧室</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">string</span> m_SittingRoom;  <span class="comment">// 客厅</span></span><br><span class="line"></span><br><span class="line">    Building();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类外实现函数</span></span><br><span class="line">Building::Building() &#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;m_SittingRoom = <span class="string">&quot;客厅&quot;</span>;</span><br><span class="line">    <span class="keyword">this</span>-&gt;m_BedRoom = <span class="string">&quot;卧室&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">goodGay::goodGay() &#123;</span><br><span class="line">    building = <span class="keyword">new</span> Building;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">goodGay::visit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;好基友正在访问&quot;</span> &lt;&lt; building-&gt;m_SittingRoom &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;好基友正在访问&quot;</span> &lt;&lt; building-&gt;m_BedRoom &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    goodGay gg;</span><br><span class="line">    gg.visit();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="成员函数做友元"><a href="#成员函数做友元" class="headerlink" title="成员函数做友元"></a>成员函数做友元</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Building</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">goodGay</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Building *building;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    goodGay();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">visit</span><span class="params">()</span></span>;  <span class="comment">// 只让 visit 函数作为 Building 的好朋友，可以发访问 Building 中私有内容</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">visit2</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Building</span> &#123;</span></span><br><span class="line">    <span class="comment">// 告诉编译器 goodGay 类中的 visit 成员函数是 Building 好朋友，可以访问私有内容</span></span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="keyword">void</span> <span class="title">goodGay::visit</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">string</span> m_BedRoom;<span class="comment">//卧室</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">string</span> m_SittingRoom; <span class="comment">//客厅</span></span><br><span class="line"></span><br><span class="line">    Building();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Building::Building() &#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;m_SittingRoom = <span class="string">&quot;客厅&quot;</span>;</span><br><span class="line">    <span class="keyword">this</span>-&gt;m_BedRoom = <span class="string">&quot;卧室&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">goodGay::goodGay() &#123;</span><br><span class="line">    building = <span class="keyword">new</span> Building;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">goodGay::visit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;好基友正在访问&quot;</span> &lt;&lt; building-&gt;m_SittingRoom &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;好基友正在访问&quot;</span> &lt;&lt; building-&gt;m_BedRoom &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">goodGay::visit2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;好基友正在访问&quot;</span> &lt;&lt; building-&gt;m_SittingRoom &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">//cout &lt;&lt; &quot;好基友正在访问&quot; &lt;&lt; building-&gt;m_BedRoom &lt;&lt; endl;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    goodGay gg;</span><br><span class="line">    gg.visit();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="运算符重载"><a href="#运算符重载" class="headerlink" title="运算符重载"></a>运算符重载</h3><h4 id="加号运算符重载"><a href="#加号运算符重载" class="headerlink" title="加号运算符重载"></a>加号运算符重载</h4><ul><li>作用：实现两个自定义数据类型相加的运算</li><li>总结<ul><li>对于内置的数据类型的表达式的的运算符是不可能改变的</li><li>不要滥用运算符重载</li></ul></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> m_A&#123;&#125;;</span><br><span class="line">    <span class="keyword">int</span> m_B&#123;&#125;;</span><br><span class="line"></span><br><span class="line">    Person() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">    Person(<span class="keyword">int</span> a, <span class="keyword">int</span> b) &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;m_A = a;</span><br><span class="line">        <span class="keyword">this</span>-&gt;m_B = b;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过成员函数实现 + 号运算符重载</span></span><br><span class="line">    Person <span class="keyword">operator</span>+(<span class="keyword">const</span> Person &amp;p) <span class="keyword">const</span> &#123;</span><br><span class="line">        Person temp;</span><br><span class="line">        temp.m_A = <span class="keyword">this</span>-&gt;m_A + p.m_A;</span><br><span class="line">        temp.m_B = <span class="keyword">this</span>-&gt;m_B + p.m_B;</span><br><span class="line">        <span class="keyword">return</span> temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过全局函数实现 + 号运算符重载</span></span><br><span class="line"><span class="comment">// 但是等价的运算符重载只能实现一次</span></span><br><span class="line"><span class="comment">//Person operator+(const Person&amp; p1, const Person&amp; p2) &#123;</span></span><br><span class="line"><span class="comment">//Person temp(0, 0);</span></span><br><span class="line"><span class="comment">//temp.m_A = p1.m_A + p2.m_A;</span></span><br><span class="line"><span class="comment">//temp.m_B = p1.m_B + p2.m_B;</span></span><br><span class="line"><span class="comment">//return temp;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//运算符重载 可以发生函数重载</span></span><br><span class="line">Person <span class="keyword">operator</span>+(<span class="keyword">const</span> Person &amp;p2, <span class="keyword">int</span> val) &#123;</span><br><span class="line">    Person temp;</span><br><span class="line">    temp.m_A = p2.m_A + val;</span><br><span class="line">    temp.m_B = p2.m_B + val;</span><br><span class="line">    <span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">Person <span class="title">p1</span><span class="params">(<span class="number">10</span>, <span class="number">10</span>)</span></span>;</span><br><span class="line">    <span class="function">Person <span class="title">p2</span><span class="params">(<span class="number">20</span>, <span class="number">20</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    Person p3 = p2 + p1;  <span class="comment">//相当于 p2.operaor+(p1)</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;mA:&quot;</span> &lt;&lt; p3.m_A &lt;&lt; <span class="string">&quot; mB:&quot;</span> &lt;&lt; p3.m_B &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    Person p4 = p3 + <span class="number">10</span>; <span class="comment">//相当于 operator+(p3,10)</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;mA:&quot;</span> &lt;&lt; p4.m_A &lt;&lt; <span class="string">&quot; mB:&quot;</span> &lt;&lt; p4.m_B &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    test();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="左移运算符重载"><a href="#左移运算符重载" class="headerlink" title="左移运算符重载"></a>左移运算符重载</h4><ul><li><p>作用：可以输出自定义数据类型</p></li><li><p>总结：</p><ul><li><strong>一般不会利用成员函数重载左移运算符</strong>，因为无法实现 cout 在左侧</li><li>重载左移运算符<strong>配合友元</strong>可以实现输出自定义数据类型</li></ul></li><li><blockquote><p>注意</p><ol><li>ostream 对象只能有一个，因此要使用引用</li><li>要返回输出流对象，再能链式地追加输出</li></ol></blockquote></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line">    <span class="keyword">friend</span> ostream &amp;<span class="keyword">operator</span>&lt;&lt;(ostream &amp;out, Person &amp;p);</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> m_A;</span><br><span class="line">    <span class="keyword">int</span> m_B;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Person(<span class="keyword">int</span> a, <span class="keyword">int</span> b) &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;m_A = a;</span><br><span class="line">        <span class="keyword">this</span>-&gt;m_B = b;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 成员函数实现的 p &lt;&lt; cout 不是我们想要的效果</span></span><br><span class="line">    <span class="comment">//void operator&lt;&lt;(Person&amp; p)&#123;</span></span><br><span class="line">    <span class="comment">//&#125;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 全局函数实现左移重载</span></span><br><span class="line">ostream &amp;<span class="keyword">operator</span>&lt;&lt;(ostream &amp;out, Person &amp;p) &#123;</span><br><span class="line">    out &lt;&lt; <span class="string">&quot;a:&quot;</span> &lt;&lt; p.m_A &lt;&lt; <span class="string">&quot; b:&quot;</span> &lt;&lt; p.m_B;</span><br><span class="line">    <span class="keyword">return</span> out;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">Person <span class="title">p1</span><span class="params">(<span class="number">10</span>, <span class="number">20</span>)</span></span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; p1 &lt;&lt; <span class="string">&quot;hello world&quot;</span> &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">// 链式编程</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="递增运算符重载"><a href="#递增运算符重载" class="headerlink" title="递增运算符重载"></a>递增运算符重载</h4><ul><li>作用：通过重载递增运算符，实现自己的整型数据</li><li>总结：前置递增返回引用，后置递增返回值</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyInteger</span> &#123;</span></span><br><span class="line">    <span class="keyword">friend</span> ostream &amp;<span class="keyword">operator</span>&lt;&lt;(ostream &amp;out, MyInteger myint);</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> m_Num;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    MyInteger() &#123;</span><br><span class="line">        m_Num = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 前置++</span></span><br><span class="line">    MyInteger &amp;<span class="keyword">operator</span>++() &#123;</span><br><span class="line">        <span class="comment">//先++</span></span><br><span class="line">        m_Num++;</span><br><span class="line">        <span class="comment">//再返回</span></span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 后置++</span></span><br><span class="line">    <span class="comment">// int 占位符可以区分前置后置</span></span><br><span class="line">    MyInteger <span class="keyword">operator</span>++(<span class="keyword">int</span>) &#123;</span><br><span class="line">        MyInteger temp = *<span class="keyword">this</span>;  <span class="comment">// 记录当前本身的值，然后让本身的值加1，但是返回的是以前的值，达到先返回后++；</span></span><br><span class="line">        m_Num++;</span><br><span class="line">        <span class="keyword">return</span> temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ostream &amp;<span class="keyword">operator</span>&lt;&lt;(ostream &amp;out, MyInteger myint) &#123;</span><br><span class="line">    out &lt;&lt; myint.m_Num;</span><br><span class="line">    <span class="keyword">return</span> out;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//前置++: 先++, 再返回</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    MyInteger myInt;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ++myInt &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; myInt &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//后置++: 先返回, 再++</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    MyInteger myInt;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; myInt++ &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; myInt &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    test01();</span><br><span class="line">    test02();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="赋值运算符重载"><a href="#赋值运算符重载" class="headerlink" title="赋值运算符重载"></a>赋值运算符重载</h4><ul><li><p>C++ 编译器至少给一个类添加4个函数</p><ol><li>默认构造函数（无参，函数体为空）</li><li>默认析构函数（无参，函数体为空）</li><li>默认拷贝构造函数，对属性进行值拷贝</li><li>赋值运算符 operator=，对属性进行值拷贝</li></ol></li><li><p>针对问题：如果类中有属性指向堆区，则编译器提供的赋值操作会出现深浅拷贝问题</p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 年龄的指针</span></span><br><span class="line">    <span class="keyword">int</span> *m_Age;</span><br><span class="line">    </span><br><span class="line">    Person(<span class="keyword">int</span> age) &#123;</span><br><span class="line">        <span class="comment">// 将年龄数据开辟到堆区</span></span><br><span class="line">        m_Age = <span class="keyword">new</span> <span class="keyword">int</span>(age);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重载赋值运算符 </span></span><br><span class="line">    Person &amp;<span class="keyword">operator</span>=(Person &amp;p) &#123;</span><br><span class="line">        <span class="keyword">if</span> (m_Age != <span class="literal">nullptr</span>) &#123;  <span class="comment">// 删除之前的数据，防止内存泄漏</span></span><br><span class="line">            <span class="keyword">delete</span> m_Age;</span><br><span class="line">            m_Age = <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 编译器提供的代码是浅拷贝</span></span><br><span class="line">        <span class="comment">//m_Age = p.m_Age;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 提供深拷贝 解决浅拷贝的问题</span></span><br><span class="line">        m_Age = <span class="keyword">new</span> <span class="keyword">int</span>(*p.m_Age);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 返回自身</span></span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ~Person() &#123;</span><br><span class="line">        <span class="keyword">if</span> (m_Age != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">delete</span> m_Age;</span><br><span class="line">            m_Age = <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">Person <span class="title">p1</span><span class="params">(<span class="number">18</span>)</span></span>;</span><br><span class="line">    <span class="function">Person <span class="title">p2</span><span class="params">(<span class="number">20</span>)</span></span>;</span><br><span class="line">    <span class="function">Person <span class="title">p3</span><span class="params">(<span class="number">30</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    p3 = p2 = p1;  <span class="comment">// 赋值操作</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;p1的年龄为：&quot;</span> &lt;&lt; *p1.m_Age &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;p2的年龄为：&quot;</span> &lt;&lt; *p2.m_Age &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;p3的年龄为：&quot;</span> &lt;&lt; *p3.m_Age &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    test01();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">int</span> b = <span class="number">20</span>;</span><br><span class="line">    <span class="keyword">int</span> c = <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line">    c = b = a;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;b = &quot;</span> &lt;&lt; b &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;c = &quot;</span> &lt;&lt; c &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="关系运算符重载"><a href="#关系运算符重载" class="headerlink" title="关系运算符重载"></a>关系运算符重载</h4><ul><li>作用：重载关系运算符，可以让两个自定义类型对象进行对比操作</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">string</span> m_Name;</span><br><span class="line">    <span class="keyword">int</span> m_Age;</span><br><span class="line">    </span><br><span class="line">    Person(<span class="built_in">string</span> name, <span class="keyword">int</span> age) &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;m_Name = name;</span><br><span class="line">        <span class="keyword">this</span>-&gt;m_Age = age;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>==(Person &amp;p) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>-&gt;m_Name == p.m_Name &amp;&amp; <span class="keyword">this</span>-&gt;m_Age == p.m_Age) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>!=(Person &amp;p) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>-&gt;m_Name == p.m_Name &amp;&amp; <span class="keyword">this</span>-&gt;m_Age == p.m_Age) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">Person <span class="title">a</span><span class="params">(<span class="string">&quot;孙悟空&quot;</span>, <span class="number">18</span>)</span></span>;</span><br><span class="line">    <span class="function">Person <span class="title">b</span><span class="params">(<span class="string">&quot;孙悟空&quot;</span>, <span class="number">18</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (a == b) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;a和b相等&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;a和b不相等&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (a != b) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;a和b不相等&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;a和b相等&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    test01();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="函数调用运算符重载"><a href="#函数调用运算符重载" class="headerlink" title="函数调用运算符重载"></a>函数调用运算符重载</h4><ul><li>函数调用运算符 ()  也可以重载</li><li>由于重载后使用的方式非常像函数的调用，因此称为仿函数</li><li>仿函数没有固定写法，非常灵活</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyPrint</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="built_in">string</span> text)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; text &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 重载的()操作符 也称为仿函数</span></span><br><span class="line">    MyPrint myFunc;</span><br><span class="line">    myFunc(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyAdd</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> v1, <span class="keyword">int</span> v2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> v1 + v2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    MyAdd add;</span><br><span class="line">    <span class="keyword">int</span> ret = add(<span class="number">10</span>, <span class="number">10</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;ret = &quot;</span> &lt;&lt; ret &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">//匿名对象调用</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;MyAdd()(100,100) = &quot;</span> &lt;&lt; MyAdd()(<span class="number">100</span>, <span class="number">100</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    test01();</span><br><span class="line">    test02();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><blockquote><p>子类是对父类的扩展。</p></blockquote><h4 id="继承的基本语法"><a href="#继承的基本语法" class="headerlink" title="继承的基本语法"></a>继承的基本语法</h4><ul><li>继承的好处：可以减少重复的代码</li><li><code>class A : public B;</code> <ul><li>A 类称为子类、派生类</li><li>B 类称为父类、基类</li></ul></li><li>派生类中的成员，包含两大部分：<ul><li>一部分是从基类继承过来的，一部分是自己增加的成员。</li><li>从基类继承过来的成员表现其共性，而新增的成员体现了其个性。</li></ul></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//公共页面</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BasePage</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">header</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;首页、公开课、登录、注册...（公共头部）&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">footer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;帮助中心、交流合作、站内地图...(公共底部)&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">left</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Java,Python,C++...(公共分类列表)&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Java页面</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Java</span> :</span> <span class="keyword">public</span> BasePage &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">content</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;JAVA学科视频&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Python页面</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Python</span> :</span> <span class="keyword">public</span> BasePage &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">content</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Python学科视频&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//C++页面</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CPP</span> :</span> <span class="keyword">public</span> BasePage &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">content</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;C++学科视频&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//Java页面</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Java下载视频页面如下： &quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    Java::header();</span><br><span class="line">    Java::footer();</span><br><span class="line">    Java::left();</span><br><span class="line">    Java::content();</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;--------------------&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Python页面</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Python下载视频页面如下： &quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    Python::header();</span><br><span class="line">    Python::footer();</span><br><span class="line">    Python::left();</span><br><span class="line">    Python::content();</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;--------------------&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//C++页面</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;C++下载视频页面如下： &quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    CPP::header();</span><br><span class="line">    CPP::footer();</span><br><span class="line">    CPP::left();</span><br><span class="line">    CPP::content();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="继承方式"><a href="#继承方式" class="headerlink" title="继承方式"></a>继承方式</h4><ul><li>继承的语法：<code>class 子类 : 继承方式  父类</code></li><li>继承方式一共有三种：<ul><li>公共继承</li><li>保护继承</li><li>私有继承</li></ul></li></ul><table><thead><tr><th></th><th>公共继承</th><th>保护继承</th><th>私有继承</th></tr></thead><tbody><tr><td>公共成员</td><td>公共成员</td><td>保护成员</td><td>私有成员</td></tr><tr><td>保护成员</td><td>保护成员</td><td>保护成员</td><td>私有成员</td></tr><tr><td>私有成员</td><td>不可访问</td><td>不可访问</td><td>不可访问</td></tr></tbody></table><h4 id="继承中的对象模型"><a href="#继承中的对象模型" class="headerlink" title="继承中的对象模型"></a>继承中的对象模型</h4><ul><li>总结：父类中私有成员也是被子类继承下去了，只是由编译器给隐藏后访问不到</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> m_A;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="keyword">int</span> m_B;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> m_C; <span class="comment">//私有成员只是被隐藏了，但是还是会继承下去</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//公共继承</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son</span> :</span> <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> m_D;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;sizeof Son = &quot;</span> &lt;&lt; <span class="keyword">sizeof</span>(Son) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">// sizeof Son = 16</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="继承中构造和析构顺序"><a href="#继承中构造和析构顺序" class="headerlink" title="继承中构造和析构顺序"></a>继承中构造和析构顺序</h4><ul><li>总结：<ul><li>子类继承父类后，当创建子类对象，也会调用父类的构造函数</li><li>继承中，先调用父类构造函数，再调用子类构造函数，析构顺序与构造相反</li></ul></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Base() &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Base构造函数!&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~Base() &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Base析构函数!&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son</span> :</span> <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Son() &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Son构造函数!&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~Son() &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Son析构函数!&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//继承中 先调用父类构造函数，再调用子类构造函数，析构顺序与构造相反</span></span><br><span class="line">    Son s;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="继承同名（非）静态成员处理方式"><a href="#继承同名（非）静态成员处理方式" class="headerlink" title="继承同名（非）静态成员处理方式"></a>继承同名（非）静态成员处理方式</h4><ul><li><p>针对问题：当子类与父类出现同名的成员，通过子类对象，访问到子类或父类中同名的成员变量。</p></li><li><p>方法：</p><ul><li>访问子类同名成员   直接访问即可</li><li>访问父类同名成员   需要加作用域</li></ul></li><li><p>总结：</p><ol><li>子类对象可以直接访问到子类中同名成员</li><li>子类对象加作用域可以访问到父类同名成员</li><li><strong>子类的成员函数会隐藏父类中所有版本的同名成员函数（包括重载函数）</strong>，只有加作用域才可以访问到父类中同名函数</li></ol></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> m_A;</span><br><span class="line"></span><br><span class="line">    Base() &#123;</span><br><span class="line">        m_A = <span class="number">100</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Base - func()调用&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> a)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Base - func(int a)调用&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son</span> :</span> <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> m_A;</span><br><span class="line"></span><br><span class="line">    Son() : m_A(<span class="number">200</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 子类会隐藏父类中所有版本的同名成员函数</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Son - func()调用&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Son s;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Son下的m_A = &quot;</span> &lt;&lt; s.m_A &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Base下的m_A = &quot;</span> &lt;&lt; s.Base::m_A &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    s.func();</span><br><span class="line">    s.Base::func();</span><br><span class="line">    s.Base::func(<span class="number">10</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> EXIT_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="多继承语法"><a href="#多继承语法" class="headerlink" title="多继承语法"></a>多继承语法</h4><ul><li><p>C++ 允许一个类继承多个类</p></li><li><p>语法：<code>class 子类: 继承方式 父类1, 继承方式 父类2...</code></p></li><li><p>总结： 多继承中如果引发父类中有同名成员出现，子类使用时候要加作用域</p><ul><li>C++ 实际开发中不建议用多继承</li></ul></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base1</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> m_A;</span><br><span class="line"></span><br><span class="line">    Base1() : m_A(<span class="number">100</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base2</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> m_A;</span><br><span class="line"></span><br><span class="line">    Base2() : m_A(<span class="number">200</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son</span> :</span> <span class="keyword">public</span> Base2, <span class="keyword">public</span> Base1 &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> m_C;</span><br><span class="line">    <span class="keyword">int</span> m_D;</span><br><span class="line"></span><br><span class="line">    Son() : m_C(<span class="number">300</span>), m_D(<span class="number">400</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//多继承容易产生成员同名的情况</span></span><br><span class="line">    <span class="comment">//通过使用类名作用域可以区分调用哪一个基类的成员</span></span><br><span class="line">    Son s;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;sizeof Son = &quot;</span> &lt;&lt; <span class="keyword">sizeof</span>(s) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;s.Base1::m_A = &quot;</span> &lt;&lt; s.Base1::m_A &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;s.Base2::m_A = &quot;</span> &lt;&lt; s.Base2::m_A &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="菱形继承"><a href="#菱形继承" class="headerlink" title="菱形继承"></a>菱形继承</h4><ul><li><p>菱形（钻石）继承概念：</p><ul><li>两个派生类继承同一个基类</li><li>又有某个类同时继承者两个派生类</li></ul></li><li><p>典型的菱形继承案例：</p></li><li><p><img src="/2022/1/C++-Part2/clip_image002.jpg" alt="IMG_256"></p></li><li><p>菱形继承问题：</p><ol><li><pre><code>羊继承了动物的数据，驼同样继承了动物的数据，当草泥马使用数据时，就会产生二义性。</code></pre></li><li><pre><code>草泥马继承自动物的数据继承了两份，其实这份数据我们只需要一份就可以，此为资源浪费。</code></pre></li></ol></li><li><p>总结：</p><ul><li>菱形继承带来的主要问题是子类继承两份相同的数据，导致资源浪费以及毫无意义</li><li>利用虚继承可以解决菱形继承问题，从虚基类继承的成员变量只会有一份内存空间。</li></ul></li><li><blockquote><ul><li>虚基类是子类以虚继承方式继承的父类的别称，并不是抽象类，其依然能够创建实例对象</li><li>虚继承的本质是将自己继承过来的成员作为一个指针（virtual base pointer，vbptr）指向父类的空间（vbtable）<ul><li>因此修改任何一个父类或者子类，实际上都是在修改同一份数据</li><li>类似于 Java 的重写</li></ul></li></ul></blockquote></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> m_Age&#123;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 继承前加virtual关键字后，变为虚继承</span></span><br><span class="line"><span class="comment">// 此时公共的父类Animal称为虚基类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sheep</span> :</span> <span class="keyword">virtual</span> <span class="keyword">public</span> Animal &#123;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tuo</span> :</span> <span class="keyword">virtual</span> <span class="keyword">public</span> Animal &#123;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SheepTuo</span> :</span> <span class="keyword">public</span> Sheep, <span class="keyword">public</span> Tuo &#123;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Animal a;</span><br><span class="line">    a.m_Age = <span class="number">15</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;s.m_Age = &quot;</span> &lt;&lt; a.m_Age &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    Sheep s;</span><br><span class="line">    s.m_Age = <span class="number">10</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;s.m_Age = &quot;</span> &lt;&lt; s.m_Age &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    Tuo t;</span><br><span class="line">    t.m_Age = <span class="number">20</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;t.m_Age = &quot;</span> &lt;&lt; t.m_Age &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    SheepTuo st;</span><br><span class="line">    st.Sheep::m_Age = <span class="number">100</span>;</span><br><span class="line">    st.Tuo::m_Age = <span class="number">200</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;st.Sheep::m_Age = &quot;</span> &lt;&lt; st.Sheep::m_Age &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;st.Tuo::m_Age = &quot;</span> &lt;&lt; st.Tuo::m_Age &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;st.m_Age = &quot;</span> &lt;&lt; st.m_Age &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><h4 id="多态的基本概念"><a href="#多态的基本概念" class="headerlink" title="多态的基本概念"></a>多态的基本概念</h4><ul><li><p>多态分为两类</p><ul><li>静态多态：<strong>函数重载</strong>和<strong>运算符重载</strong>属于静态多态（复用函数名）</li><li>动态多态：派生类和虚函数实现运行时多态</li></ul></li><li><p>静态多态和动态多态区别：</p><ul><li>静态多态的函数地址早绑定：编译阶段确定函数地址</li><li>动态多态的函数地址晚绑定：运行阶段确定函数地址</li></ul></li><li><p>总结：</p><ul><li>多态满足条件<ul><li>有继承关系</li><li>子类重写父类中的虚函数</li></ul></li><li>多态使用条件<ul><li>父类指针或引用指向子类对象</li></ul></li><li>我们希望传入什么对象，那么就调用什么对象的函数<ul><li>如果函数地址在编译阶段就能确定，那么静态联编</li><li>如果函数地址在运行阶段才能确定，就是动态联编</li></ul></li><li>重写：<code>函数返回值类型  函数名 参数列表</code> 需要完全一致才称为重写</li></ul></li><li><p>多态的优点：</p><ul><li>代码组织结构清晰</li><li>可读性强</li><li>利于前期和后期的扩展以及维护</li></ul></li><li><blockquote><p>多态的原理</p><ul><li>加上 virtual 关键字之前，Animal 类的成员函数不存储在类对象中，<strong>因此一个 Animal 实例的大小为 1 字节</strong></li><li>加上 virtual 关键字之后，Animal 类将保存一个虚函数指针（virtual function pointer，vfptr）指向自己的虚函数表（virtual function table，vftable），并存储在该类对象中，<strong>因此一个 Animal 实例（无论有多少个虚函数）的大小为 4 字节</strong><ul><li>一个类只有一个虚函数指针，虚函数表内部记录各个虚函数的地址</li><li>继承时复制一份虚函数指针和虚函数表，虚函数表不占实例空间</li></ul></li><li>当子类重写父类虚函数时，即重写/替换父类内部（继承过来）的虚函数指针指向的虚函数表中的函数，因此使用父类指针指向的子类实例调用父类函数时，实际是调用子类重写的函数内容</li></ul></blockquote></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 函数前面加上 virtual 关键字就是虚函数，编译器在编译的时候不能确定函数调用。</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">speak</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;动物在说话&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">speak2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;动物在说话&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span> :</span> <span class="keyword">public</span> Animal &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">speak</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;小猫在说话&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span> :</span> <span class="keyword">public</span> Animal &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">speak</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;小狗在说话&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DoSpeak</span><span class="params">(Animal &amp;animal)</span> </span>&#123;</span><br><span class="line">    animal.speak();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Cat cat;</span><br><span class="line">    DoSpeak(cat);</span><br><span class="line">    Dog dog;</span><br><span class="line">    DoSpeak(dog);</span><br><span class="line">    Animal animal;</span><br><span class="line">    DoSpeak(animal);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;sizeof animal = &quot;</span> &lt;&lt; <span class="keyword">sizeof</span> animal &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="纯虚函数和抽象类"><a href="#纯虚函数和抽象类" class="headerlink" title="纯虚函数和抽象类"></a>纯虚函数和抽象类</h4><ul><li><p>针对问题：在多态中，通常父类中虚函数的实现是无意义的，主要都是调用子类重写的内容</p></li><li><p>解决：因此可以将虚函数改为<strong>纯虚函数</strong>，要求子类必须重写纯虚函数</p></li><li><p>语法：<code>virtual 返回值类型 函数名 （参数列表）= 0 ;</code></p></li><li><p>只要类中有一个纯虚函数，这个类就称为抽象类</p></li><li><p>抽象类特点：</p><ul><li>无法实例化对象</li><li>子类必须重写抽象类中的纯虚函数，否则也属于抽象类</li></ul></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son</span> :</span> <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;func调用&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//Base * = new Base; // 错误，抽象类无法实例化对象</span></span><br><span class="line">    Base *base = <span class="keyword">new</span> Son;</span><br><span class="line">    base-&gt;func();</span><br><span class="line">    <span class="keyword">delete</span> base;<span class="comment">//记得销毁</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="虚析构和纯虚析构"><a href="#虚析构和纯虚析构" class="headerlink" title="虚析构和纯虚析构"></a>虚析构和纯虚析构</h4><ul><li><p>父类指针在释放时无法调用到子类的析构代码，因此如果子类中有属性开辟到堆区，那么会有内存泄漏的隐患</p></li><li><p>解决方式：将父类中的析构函数改为<strong>虚析构</strong>或者<strong>纯虚析构</strong></p></li><li><p>虚析构和纯虚析构共性：</p><ul><li>都可以解决父类指针释放子类对象</li><li><strong>虚析构和纯虚析构都需要有具体的函数实现</strong>，父类成员变量在父类的析构函数中释放</li></ul></li><li><p>虚析构和纯虚析构区别：</p><ul><li>如果是纯虚析构，该类属于抽象类，无法实例化对象</li></ul></li><li><p>虚析构语法：<code>virtual ~类名() &#123;&#125;</code></p></li></ul><ul><li><p>纯虚析构语法：</p><ul><li><pre><code class="c++">virtual ~类名() = 0;类名::~类名() &#123;&#125;<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 总结：</span><br><span class="line"></span><br><span class="line">  1. 虚析构或纯虚析构就是用来解决通过父类指针释放子类对象</span><br><span class="line"></span><br><span class="line">  2. 如果子类中没有堆区数据，可以不写为虚析构或纯虚析构</span><br><span class="line"></span><br><span class="line">  3. 拥有纯虚析构函数的类也属于抽象类</span><br><span class="line"></span><br><span class="line">&#96;&#96;&#96;C++</span><br><span class="line">class Animal &#123;</span><br><span class="line">public:</span><br><span class="line">    Animal() &#123;</span><br><span class="line">        cout &lt;&lt; &quot;Animal 构造函数调用！&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 析构函数加上virtual关键字，变成虚析构函数</span><br><span class="line">    &#x2F;&#x2F;virtual ~Animal()</span><br><span class="line">    &#x2F;&#x2F;&#123;</span><br><span class="line">    &#x2F;&#x2F;cout &lt;&lt; &quot;Animal虚析构函数调用！&quot; &lt;&lt; endl;</span><br><span class="line">    &#x2F;&#x2F;&#125;</span><br><span class="line">    virtual ~Animal() &#x3D; 0;</span><br><span class="line"></span><br><span class="line">    virtual void Speak() &#x3D; 0;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Animal::~Animal() &#123;</span><br><span class="line">    cout &lt;&lt; &quot;Animal 纯虚析构函数调用！&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Cat : public Animal &#123;</span><br><span class="line">public:</span><br><span class="line">    string *m_Name;</span><br><span class="line"></span><br><span class="line">    explicit Cat(string name) &#123;</span><br><span class="line">        cout &lt;&lt; &quot;Cat 构造函数调用！&quot; &lt;&lt; endl;</span><br><span class="line">        m_Name &#x3D; new string(std::move(name));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~Cat() override &#123;</span><br><span class="line">        cout &lt;&lt; &quot;Cat 析构函数调用!&quot; &lt;&lt; endl;</span><br><span class="line">        if (this-&gt;m_Name !&#x3D; nullptr) &#123;</span><br><span class="line">            delete m_Name;</span><br><span class="line">            m_Name &#x3D; nullptr;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void Speak() override &#123;</span><br><span class="line">        cout &lt;&lt; *m_Name &lt;&lt; &quot; 小猫在说话!&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    Animal *animal &#x3D; new Cat(&quot;Tom&quot;);</span><br><span class="line">    animal-&gt;Speak();</span><br><span class="line">    delete animal;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>## 文件操作</code></pre></li></ul></li></ul><h3 id="文件操作概述"><a href="#文件操作概述" class="headerlink" title="文件操作概述"></a>文件操作概述</h3><ul><li><p>C++ 中对文件操作需要包含头文件 <code>#include &lt;fstream&gt;</code></p></li><li><p>文件类型分为两种：</p><ol><li>文本文件：文件以文本的 ASCII 码形式存储在计算机中</li><li>二进制文件：文件以文本的二进制形式存储在计算机中，用户一般不能直接读懂它们</li></ol></li><li><p>操作文件的三大类：</p><ol><li>ofstream：写操作</li><li>ifstream：读操作</li><li>fstream：读写操作</li></ol></li><li><p>文件打开方式：</p></li></ul><table><thead><tr><th>打开方式</th><th>解释</th></tr></thead><tbody><tr><td>ios::in</td><td>为读文件而打开文件</td></tr><tr><td>ios::out</td><td>为写文件而打开文件</td></tr><tr><td>ios::ate</td><td>初始位置：文件尾</td></tr><tr><td>ios::app</td><td>追加方式写文件</td></tr><tr><td>ios::trunc</td><td>如果文件存在先删除，再创建</td></tr><tr><td>ios::binary</td><td>二进制方式</td></tr></tbody></table><ul><li>注意：文件打开方式可以配合使用，利用 <code>|</code> 操作符<ul><li>例如：用二进制方式写文件 <code>ios::binary |  ios:: out</code></li></ul></li></ul><h3 id="文本文件"><a href="#文本文件" class="headerlink" title="文本文件"></a>文本文件</h3><h4 id="写文件"><a href="#写文件" class="headerlink" title="写文件"></a>写文件</h4><ul><li><p>写文件步骤如下：</p><ol><li><p>包含头文件：<code>#include &lt;fstream&gt;</code></p></li><li><p>创建流对象：<code>ofstream ofs;</code></p></li><li><p>打开文件：<code>ofs.open(&quot;文件路径&quot;, 打开方式);</code></p></li><li><p>写数据：<code>ofs &lt;&lt; &quot;写入的数据&quot;;</code></p></li><li><p>关闭文件：<code>ofs.close();</code></p></li></ol></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fstream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ofstream ofs;</span><br><span class="line">    ofs.open(<span class="string">&quot;test.txt&quot;</span>, ios::out);</span><br><span class="line"></span><br><span class="line">    ofs &lt;&lt; <span class="string">&quot;姓名：张三&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    ofs &lt;&lt; <span class="string">&quot;性别：男&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    ofs &lt;&lt; <span class="string">&quot;年龄：18&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    ofs.close();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    test01();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="读文件"><a href="#读文件" class="headerlink" title="读文件"></a>读文件</h4><ul><li>读文件步骤如下：<ol><li>包含头文件：<code>#include &lt;fstream&gt;</code></li><li>创建流对象：<code>ifstream ofs;</code></li><li>打开文件：<code>ifs.open(&quot;文件路径&quot;,打开方式);</code></li><li>检查是否打开成功：<code>!ifs.is_open()</code></li><li>读数据，四种方式读取</li><li>关闭文件：<code>ifs.close();</code></li></ol></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ifstream ifs;</span><br><span class="line">    ifs.open(<span class="string">&quot;test.txt&quot;</span>, ios::in);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!ifs.is_open()) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;文件打开失败&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. 第一种方式</span></span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">1024</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    <span class="keyword">while</span> (ifs &gt;&gt; buf) &#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; buf &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 第二种方式</span></span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">1024</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    <span class="keyword">while</span> (ifs.getline(buf, <span class="keyword">sizeof</span>(buf))) &#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; buf &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 第三种方式</span></span><br><span class="line">    <span class="built_in">string</span> buf;</span><br><span class="line">    <span class="keyword">while</span> (getline(ifs, buf)) &#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; buf &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4. 第四种方式（不推荐）</span></span><br><span class="line">    <span class="keyword">char</span> c;</span><br><span class="line">    <span class="keyword">while</span> ((c = ifs.get()) != EOF) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; c;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ifs.close();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    test01();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="二进制文件"><a href="#二进制文件" class="headerlink" title="二进制文件"></a>二进制文件</h3><h4 id="写文件-1"><a href="#写文件-1" class="headerlink" title="写文件"></a>写文件</h4><ul><li><p>写二进制文件主要利用流对象的成员函数 <code>write()</code></p><ul><li>函数原型 ：<code>ostream&amp; write(const char * buffer, int len);</code></li><li>参数解释：<ul><li>字符指针 buffer 指向内存中一段存储空间</li><li>len 是读写的字节数</li></ul></li></ul></li><li><p>建议使用 char[] 进行二进制的写入</p></li><li><p>对象指针要强转为 <code>char *</code>，同时计算读写的大小空间。</p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">char</span> m_Name[<span class="number">64</span>];</span><br><span class="line">    <span class="keyword">int</span> m_Age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写二进制文件</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">ofstream <span class="title">ofs</span><span class="params">(<span class="string">&quot;person.txt&quot;</span>, ios::out | ios::binary)</span></span>;</span><br><span class="line"></span><br><span class="line">    Person p = &#123;<span class="string">&quot;张三&quot;</span>, <span class="number">18</span>&#125;;</span><br><span class="line">    ofs.write((<span class="keyword">const</span> <span class="keyword">char</span> *) &amp;p, <span class="keyword">sizeof</span>(p));</span><br><span class="line"></span><br><span class="line">    ofs.close();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    test01();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="读文件-1"><a href="#读文件-1" class="headerlink" title="读文件"></a>读文件</h4><ul><li>读二进制文件主要利用流对象的成员函数 <code>read()</code><ul><li>函数原型：<code>istream&amp; read(char *buffer, int len);</code></li><li>参数解释：<ul><li>字符指针 buffer 指向内存中一段存储空间</li><li>len 是读写的字节数</li></ul></li></ul></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">char</span> m_Name[<span class="number">64</span>];</span><br><span class="line">    <span class="keyword">int</span> m_Age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">ifstream <span class="title">ifs</span><span class="params">(<span class="string">&quot;person.txt&quot;</span>, ios::in | ios::binary)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (!ifs.is_open()) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;文件打开失败&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Person p;</span><br><span class="line">    ifs.read((<span class="keyword">char</span> *) &amp;p, <span class="keyword">sizeof</span>(p));</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;姓名： &quot;</span> &lt;&lt; p.m_Name &lt;&lt; <span class="string">&quot; 年龄： &quot;</span> &lt;&lt; p.m_Age &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    </span><br><span class="line">    ifs.close();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    test01();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h2><h3 id="模板的概念"><a href="#模板的概念" class="headerlink" title="模板的概念"></a>模板的概念</h3><ul><li>模板的特点：<ul><li>模板不可以直接使用，只是一个框架</li><li>模板的通用并不是万能的</li></ul></li><li>C++ 另一种编程思想称为<strong>泛型编程</strong>，主要利用的技术就是模板</li></ul><ul><li>C++ 提供两种模板机制:<strong>函数模板</strong>和<strong>类模板</strong> </li></ul><h3 id="函数模板"><a href="#函数模板" class="headerlink" title="函数模板"></a>函数模板</h3><h4 id="函数模板语法"><a href="#函数模板语法" class="headerlink" title="函数模板语法"></a>函数模板语法</h4><ul><li><p>函数模板作用：</p><ul><li>建立一个通用函数，其函数返回值类型和形参类型可以不具体制定，用一个<strong>虚拟的类型</strong>来代表。</li></ul></li><li><p>语法： </p><ul><li><pre><code class="c++">template&lt;typename/class T&gt;函数声明或定义<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 解释：</span><br><span class="line"></span><br><span class="line">  - &#96;template&#96;：声明创建模板</span><br><span class="line">  - &#96;typename&#x2F;class&#96;：表面其后面的符号是一种数据类型，可以用 class 代替</span><br><span class="line">  - &#96;T&#96;：通用的数据类型，名称可以替换，通常为大写字母</span><br><span class="line"></span><br><span class="line">- 总结：</span><br><span class="line"></span><br><span class="line">  - 使用函数模板有两种方式：自动类型推导、显式指定类型</span><br><span class="line">  - 模板的目的是将类型参数化、为了提高复用性，需要熟练掌握</span><br><span class="line"></span><br><span class="line">- 注意：</span><br><span class="line"></span><br><span class="line">  - 必须**确定出数据类型 T** 并且**同一个 T 推导结果一致**，才可以使用。</span><br><span class="line"></span><br><span class="line">&#96;&#96;&#96;C++</span><br><span class="line">&#x2F;&#x2F; 利用模板提供通用的交换函数</span><br><span class="line">template&lt;typename T&gt;  &#x2F;&#x2F; typename 可以换成 class</span><br><span class="line">void mySwap(T &amp;a, T &amp;b) &#123;</span><br><span class="line">    T temp &#x3D; a;</span><br><span class="line">    a &#x3D; b;</span><br><span class="line">    b &#x3D; temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void test01() &#123;</span><br><span class="line">    int a &#x3D; 10;</span><br><span class="line">    int b &#x3D; 20;</span><br><span class="line">    char c &#x3D; &#39;c&#39;;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 利用模板实现交换</span><br><span class="line">    &#x2F;&#x2F; 1、自动类型推导</span><br><span class="line">    mySwap(a, b);</span><br><span class="line">    &#x2F;&#x2F;mySwap(a, c);  &#x2F;&#x2F; 错误，推导不出一致的 T 类型</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 2、显式指定类型</span><br><span class="line">    mySwap&lt;int&gt;(a, b);</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; &quot;a &#x3D; &quot; &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; &quot;b &#x3D; &quot; &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template&lt;class T&gt;</span><br><span class="line">void func() &#123;</span><br><span class="line">    cout &lt;&lt; &quot;func 调用&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void test02() &#123;</span><br><span class="line">    &#x2F;&#x2F;func();  &#x2F;&#x2F; 错误，模板不能独立使用，必须确定出 T 的类型</span><br><span class="line">    func&lt;int&gt;();  &#x2F;&#x2F; 利用显示指定类型的方式，给 T 一个类型，才可以使用该模板</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    test01();</span><br><span class="line">    test02();</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>#### 普通函数与函数模板的区别</code></pre></li></ul></li><li><p>普通函数与函数模板区别：</p><ul><li>普通函数调用时可以发生自动类型转换（隐式类型转换）</li><li>函数模板调用时，如果利用自动类型推导，不会发生隐式类型转换（因为需要确保推导的 T 结果一致）</li><li>如果利用显示指定类型的方式，则可以发生隐式类型转换</li></ul></li><li><p>总结：建议使用显示指定类型的方式，调用函数模板，因为可以自己确定通用类型 T</p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 普通函数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">myAdd01</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数模板</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="function">T <span class="title">myAdd02</span><span class="params">(T a, T b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用函数模板时，如果用自动类型推导，不会发生自动类型转换,即隐式类型转换</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">int</span> b = <span class="number">20</span>;</span><br><span class="line">    <span class="keyword">char</span> c = <span class="string">&#x27;c&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; myAdd01(a, c) &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">// 正确，将char类型的&#x27;c&#x27;隐式转换为int类型  &#x27;c&#x27; 对应 ASCII码 99</span></span><br><span class="line">    <span class="comment">//myAdd02(a, c);  // 报错，使用自动类型推导时，不会发生隐式类型转换</span></span><br><span class="line">    myAdd02&lt;<span class="keyword">int</span>&gt;(a, c);  <span class="comment">// 正确，如果用显示指定类型，可以发生隐式类型转换</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    test01();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="普通函数与函数模板的调用规则"><a href="#普通函数与函数模板的调用规则" class="headerlink" title="普通函数与函数模板的调用规则"></a>普通函数与函数模板的调用规则</h4><ul><li>调用规则如下：<ol><li>如果函数模板和普通函数都可以实现，优先调用普通函数</li><li>可以通过空模板参数列表来强制调用函数模板</li><li>函数模板也可以发生重载</li><li>如果函数模板可以产生更好的匹配，优先调用函数模板</li></ol></li><li>总结：既然提供了函数模板，最好就不要提供普通函数，否则容易出现二义性</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myPrint</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;调用的普通函数&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myPrint</span><span class="params">(T a, T b)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;调用的模板&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myPrint</span><span class="params">(T a, T b, T c)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;调用重载的模板&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 1. 如果函数模板和普通函数都可以实现，优先调用普通函数</span></span><br><span class="line">    <span class="comment">// 注意 如果告诉编译器  普通函数是有的，但只是声明没有实现，或者不在当前文件内实现，就会报错找不到</span></span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">int</span> b = <span class="number">20</span>;</span><br><span class="line">    myPrint(a, b);  <span class="comment">// 调用普通函数</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 可以通过空模板参数列表来强制调用函数模板</span></span><br><span class="line">    myPrint&lt;&gt;(a, b);  <span class="comment">// 调用函数模板</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 函数模板也可以发生重载</span></span><br><span class="line">    <span class="keyword">int</span> c = <span class="number">30</span>;</span><br><span class="line">    myPrint(a, b, c);  <span class="comment">// 调用重载的函数模板</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4. 如果函数模板可以产生更好的匹配,优先调用函数模板</span></span><br><span class="line">    <span class="keyword">char</span> c1 = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">    <span class="keyword">char</span> c2 = <span class="string">&#x27;b&#x27;</span>;</span><br><span class="line">    myPrint(c1, c2);  <span class="comment">// 调用函数模板</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    test01();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="模板的局限性"><a href="#模板的局限性" class="headerlink" title="模板的局限性"></a>模板的局限性</h4><ul><li>模板函数的成功运行，要求传入的数据类型能够支持函数内部的代码<ul><li>以下情况不可能直接运行：<ul><li>数组的直接赋值</li><li>自定义数据类型的直接比较</li></ul></li></ul></li><li>解决方向：模板的重载，可以为这些<strong>特定的类型</strong>提供<strong>具体化的模板</strong></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">string</span> m_Name;</span><br><span class="line">    <span class="keyword">int</span> m_Age;</span><br><span class="line"></span><br><span class="line">    Person(<span class="built_in">string</span> name, <span class="keyword">int</span> age) &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;m_Name = name;</span><br><span class="line">        <span class="keyword">this</span>-&gt;m_Age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 普通函数模板</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">myCompare</span><span class="params">(T &amp;a, T &amp;b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (a == b) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以 template&lt;&gt; 开头，具体化特定数据类型的重载模板函数，将优先于常规模板</span></span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">myCompare</span><span class="params">(Person &amp;p1, Person &amp;p2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p1.m_Name == p2.m_Name &amp;&amp; p1.m_Age == p2.m_Age) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">int</span> b = <span class="number">20</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">bool</span> ret = myCompare(a, b);</span><br><span class="line">    <span class="keyword">if</span> (ret) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;a == b &quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;a != b &quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">Person <span class="title">p1</span><span class="params">(<span class="string">&quot;Tom&quot;</span>, <span class="number">10</span>)</span></span>;</span><br><span class="line">    <span class="function">Person <span class="title">p2</span><span class="params">(<span class="string">&quot;Tom&quot;</span>, <span class="number">10</span>)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 可以创建具体化的Person数据类型的模板，用于特殊处理这个类型</span></span><br><span class="line">    <span class="keyword">bool</span> ret = myCompare(p1, p2);</span><br><span class="line">    <span class="keyword">if</span> (ret) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;p1 == p2 &quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;p1 != p2 &quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    test01();</span><br><span class="line">    test02();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="类模板"><a href="#类模板" class="headerlink" title="类模板"></a>类模板</h3><h4 id="类模板语法"><a href="#类模板语法" class="headerlink" title="类模板语法"></a>类模板语法</h4><ul><li><p>类模板作用：</p></li><li><p>建立一个通用类，类中的成员 数据类型可以不具体制定，用一个<strong>虚拟的类型</strong>来代表。</p></li><li><p>语法： </p><ul><li><pre><code class="c++">template&lt;typename T&gt;类<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 解释：</span><br><span class="line"></span><br><span class="line">  - template：声明创建模板</span><br><span class="line">  - typename：表面其后面的符号是一种数据类型，可以用class代替</span><br><span class="line">  - T：通用的数据类型，名称可以替换，通常为大写字母</span><br><span class="line"></span><br><span class="line">&#96;&#96;&#96;C++</span><br><span class="line">&#x2F;&#x2F;类模板</span><br><span class="line">template&lt;class NameType, class AgeType&gt;</span><br><span class="line">class Person &#123;</span><br><span class="line">public:</span><br><span class="line">    NameType mName;</span><br><span class="line">    AgeType mAge;</span><br><span class="line">    </span><br><span class="line">    Person(NameType name, AgeType age) &#123;</span><br><span class="line">        this-&gt;mName &#x3D; name;</span><br><span class="line">        this-&gt;mAge &#x3D; age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void showPerson() &#123;</span><br><span class="line">        cout &lt;&lt; &quot;name: &quot; &lt;&lt; this-&gt;mName &lt;&lt; &quot; age: &quot; &lt;&lt; this-&gt;mAge &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">void test01() &#123;</span><br><span class="line">    &#x2F;&#x2F; 指定 NameType 为 string 类型，AgeType 为 int 类型</span><br><span class="line">    Person&lt;string, int&gt; P1(&quot;孙悟空&quot;, 999);</span><br><span class="line">    P1.showPerson();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    test01();</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>#### 类模板与函数模板区别</code></pre></li></ul></li><li><p>类模板与函数模板区别主要有两点：</p><ol><li>类模板没有自动类型推导的使用方式</li><li>类模板在模板参数列表中可以有默认参数</li></ol></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//类模板</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">NameType</span>, <span class="keyword">class</span> <span class="title">AgeType</span> =</span> <span class="keyword">int</span>&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    NameType mName;</span><br><span class="line">    AgeType mAge;</span><br><span class="line">    </span><br><span class="line">    Person(NameType name, AgeType age) &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;mName = name;</span><br><span class="line">        <span class="keyword">this</span>-&gt;mAge = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">showPerson</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;name: &quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;mName &lt;&lt; <span class="string">&quot; age: &quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;mAge &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. 类模板没有自动类型推导的使用方式</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Person p(&quot;孙悟空&quot;, 1000);  // 错误 类模板使用时候，不可以用自动类型推导</span></span><br><span class="line">    Person&lt;string, int&gt; p(&quot;孙悟空&quot;, 1000);  // 必须使用显示指定类型的方式，使用类模板</span><br><span class="line">    p.showPerson();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 类模板在模板参数列表中可以有默认参数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">Person&lt;<span class="built_in">string</span>&gt; <span class="title">p</span><span class="params">(<span class="string">&quot;猪八戒&quot;</span>, <span class="number">999</span>)</span></span>; <span class="comment">//类模板中的模板参数列表 可以指定默认参数</span></span><br><span class="line">    p.showPerson();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    test01();</span><br><span class="line">    test02();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="类模板中成员函数创建时机"><a href="#类模板中成员函数创建时机" class="headerlink" title="类模板中成员函数创建时机"></a>类模板中成员函数创建时机</h4><ul><li>类模板中成员函数和普通类中成员函数创建时机是有区别的：<ul><li>普通类中的成员函数一开始就可以创建</li><li>类模板中的成员函数在调用时才创建，并检查是否该数据类型能够调用函数</li></ul></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person1</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">showPerson1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Person1 show&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person2</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">showPerson2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Person2 show&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    T obj;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">fun1</span><span class="params">()</span> </span>&#123; obj.showPerson1(); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">fun2</span><span class="params">()</span> </span>&#123; obj.showPerson2(); &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    MyClass&lt;Person1&gt; m&#123;&#125;;</span><br><span class="line">    m.fun1();</span><br><span class="line">    <span class="comment">//m.fun2();  // 编译会出错，说明只有函数被调用才会去创建成员函数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    test01();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="类模板对象做函数参数"><a href="#类模板对象做函数参数" class="headerlink" title="类模板对象做函数参数"></a>类模板对象做函数参数</h4><ul><li><p>学习目标：</p></li><li><p>类模板实例化出的对象，向函数传参的方式</p></li><li><p>一共有三种传入方式：</p><ol><li>指定传入的类型：直接显示对象的数据类型</li><li>参数模板化：将对象中的参数变为模板进行传递</li><li>整个类模板化：将这个对象类型 模板化进行传递</li></ol></li><li><p>总结：</p><ul><li>通过类模板创建的对象，可以有三种方式向函数中进行传参</li><li>使用比较广泛是第一种：指定传入的类型</li></ul></li><li><blockquote><p>在 C++ 中查看一个模板类型 T 或者变量 var 的数据类型：<code>typeid(T/var).name()</code></p></blockquote></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 类模板</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">NameType</span>, <span class="keyword">class</span> <span class="title">AgeType</span> =</span> <span class="keyword">int</span>&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    NameType mName;</span><br><span class="line">    AgeType mAge;</span><br><span class="line"></span><br><span class="line">    Person(NameType name, AgeType age) &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;mName = name;</span><br><span class="line">        <span class="keyword">this</span>-&gt;mAge = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">showPerson</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;name: &quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;mName &lt;&lt; <span class="string">&quot; age: &quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;mAge &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1、指定传入的类型</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printPerson1</span><span class="params">(Person&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt; &amp;p)</span> </span>&#123;</span><br><span class="line">    p.showPerson();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Person&lt;string, int&gt; p(&quot;孙悟空&quot;, 100);</span><br><span class="line">    printPerson1(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2、类模板参数的模板化</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T1</span>, <span class="keyword">class</span> <span class="title">T2</span>&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printPerson2</span><span class="params">(Person&lt;T1, T2&gt; &amp;p)</span> </span>&#123;</span><br><span class="line">    p.showPerson();</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;T1的类型为： &quot;</span> &lt;&lt; <span class="keyword">typeid</span>(T1).name() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;T2的类型为： &quot;</span> &lt;&lt; <span class="keyword">typeid</span>(T2).name() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Person&lt;string, int&gt; p(&quot;猪八戒&quot;, 90);</span><br><span class="line">    printPerson2(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3、整个类的模板化</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printPerson3</span><span class="params">(T &amp;p)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;T的类型为： &quot;</span> &lt;&lt; <span class="keyword">typeid</span>(T).name() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    p.showPerson();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test03</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Person&lt;string, int&gt; p(&quot;唐僧&quot;, 30);</span><br><span class="line">    printPerson3(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    test01();</span><br><span class="line">    test02();</span><br><span class="line">    test03();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="类模板与继承"><a href="#类模板与继承" class="headerlink" title="类模板与继承"></a>类模板与继承</h4><ul><li>当类模板碰到继承时，需要注意一下几点：<ul><li>当子类继承的父类是一个类模板时，子类在声明的时候，要指定出父类中T的类型</li><li>如果不指定，编译器无法给子类分配内存</li><li>如果想灵活指定出父类中T的类型，子类也需变为类模板</li></ul></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> &#123;</span></span><br><span class="line">    T m;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//class Son:public Base  //错误，c++编译需要给子类分配内存，必须知道父类中T的类型才可以向下继承</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. 必须指定父类的模板类型</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son</span> :</span> <span class="keyword">public</span> Base&lt;<span class="keyword">int</span>&gt; &#123;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 用类模板继承类模板，用T2指定父类中的T类型</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T1</span>, <span class="keyword">class</span> <span class="title">T2</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son2</span> :</span> <span class="keyword">public</span> Base&lt;T2&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Son2() &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="keyword">typeid</span>(T1).name() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="keyword">typeid</span>(T2).name() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Son c;</span><br><span class="line">    Son2&lt;<span class="keyword">int</span>, <span class="keyword">char</span>&gt; child1;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="类模板成员函数类外实现"><a href="#类模板成员函数类外实现" class="headerlink" title="类模板成员函数类外实现"></a>类模板成员函数类外实现</h4><ul><li>类模板中成员函数类外实现时，需要加上模板参数列表</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T1</span>, <span class="keyword">class</span> <span class="title">T2</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    T1 m_Name;</span><br><span class="line">    T2 m_Age;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//成员函数类内声明</span></span><br><span class="line">    Person(T1 name, T2 age);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">showPerson</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//构造函数 类外实现</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T1</span>, <span class="keyword">class</span> <span class="title">T2</span>&gt;</span></span><br><span class="line">Person&lt;T1, T2&gt;::Person(T1 name, T2 age) &#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;m_Name = name;</span><br><span class="line">    <span class="keyword">this</span>-&gt;m_Age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//成员函数 类外实现</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T1</span>, <span class="keyword">class</span> <span class="title">T2</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> Person&lt;T1, T2&gt;::showPerson() &#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;姓名: &quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;m_Name &lt;&lt; <span class="string">&quot; 年龄:&quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;m_Age &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Person&lt;string, int&gt; p(&quot;Tom&quot;, 20);</span><br><span class="line">    p.showPerson();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    test01();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="类模板分文件编写"><a href="#类模板分文件编写" class="headerlink" title="类模板分文件编写"></a>类模板分文件编写</h4><ul><li><p>针对问题：类模板中成员函数创建时机是在调用阶段，导致分文件编写时链接不到</p></li><li><p>解决方向：</p><ol><li><p>直接包含 .cpp 源文件：<code>#include &quot;person.cpp&quot;</code></p></li><li><p>将声明和实现写到同一个文件中，并更改后缀名为 .hpp：<code>#include &quot;person.hpp&quot;</code>（常用方法）</p><ul><li><pre><code class="c++">#ifndef CLEARNING_PERSON_HPP#define CLEARNING_PERSON_HPP</code></pre></li></ul></li></ol></li></ul><pre><code>   #include &lt;iostream&gt;   #include &lt;string&gt;   using namespace std;   template&lt;class T1, class T2&gt;   class Person &#123;   public:       T1 m_Name;       T2 m_Age;       Person(T1 name, T2 age);       void showPerson();   &#125;;   //构造函数 类外实现   template&lt;class T1, class T2&gt;   Person&lt;T1, T2&gt;::Person(T1 name, T2 age) &#123;       this-&gt;m_Name = name;       this-&gt;m_Age = age;   &#125;   //成员函数 类外实现   template&lt;class T1, class T2&gt;   void Person&lt;T1, T2&gt;::showPerson() &#123;       cout &lt;&lt; &quot;姓名: &quot; &lt;&lt; this-&gt;m_Name &lt;&lt; &quot; 年龄:&quot; &lt;&lt; this-&gt;m_Age &lt;&lt; endl;   &#125;   #endif //CLEARNING_PERSON_HPP   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- &#96;&#96;&#96;c++</span><br><span class="line">  #include &quot;Person.hpp&quot;</span><br><span class="line">  </span><br><span class="line">  void test01() &#123;</span><br><span class="line">      Person&lt;string, int&gt; p(&quot;Tom&quot;, 10);</span><br><span class="line">      p.showPerson();</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  int main() &#123;</span><br><span class="line">      test01();</span><br><span class="line">      return 0;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></code></pre><h4 id="类模板与友元"><a href="#类模板与友元" class="headerlink" title="类模板与友元"></a>类模板与友元</h4><ul><li><p>全局函数类内实现：直接在类内声明友元即可（推荐）</p></li><li><p>全局函数类外实现：需要提前让编译器知道全局函数的存在</p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 2. 全局函数配合友元  类外实现 - 先做函数模板声明，下方在做函数模板定义，在做友元</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T1</span>, <span class="keyword">class</span> <span class="title">T2</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果声明了函数模板，可以将实现写到后面，否则需要将实现体写到类的前面让编译器提前看到</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T1</span>, <span class="keyword">class</span> <span class="title">T2</span>&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printPerson2</span><span class="params">(Person&lt;T1, T2&gt; &amp;p)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;类外实现 ---- 姓名： &quot;</span> &lt;&lt; p.m_Name &lt;&lt; <span class="string">&quot; 年龄：&quot;</span> &lt;&lt; p.m_Age &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T1</span>, <span class="keyword">class</span> <span class="title">T2</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line">    <span class="comment">// 1. 全局函数配合友元   类内实现</span></span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="keyword">void</span> <span class="title">printPerson</span><span class="params">(Person&lt;T1, T2&gt; &amp;p)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;姓名： &quot;</span> &lt;&lt; p.m_Name &lt;&lt; <span class="string">&quot; 年龄：&quot;</span> &lt;&lt; p.m_Age &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 全局函数配合友元  类外实现</span></span><br><span class="line">    <span class="comment">// 添加空模板参数 &lt;&gt; 表示为类模板的函数</span></span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">void</span> printPerson2&lt;&gt;(Person&lt;T1, T2&gt; &amp;p);</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T1 m_Name;</span><br><span class="line">    T2 m_Age;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Person(T1 name, T2 age) &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;m_Name = name;</span><br><span class="line">        <span class="keyword">this</span>-&gt;m_Age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. 全局函数在类内实现</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Person&lt;string, int&gt; p(&quot;Tom&quot;, 20);</span><br><span class="line">    printPerson(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 全局函数在类外实现</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Person&lt;string, int&gt; p(&quot;Jerry&quot;, 30);</span><br><span class="line">    printPerson2(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    test01();</span><br><span class="line">    test02();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">核心编程</summary>
    
    
    
    <category term="C++" scheme="https://nephrencake.github.io/categories/C/"/>
    
    
  </entry>
  
  <entry>
    <title>C++-Part1</title>
    <link href="https://nephrencake.github.io/2022/1/C++-Part1/"/>
    <id>https://nephrencake.github.io/2022/1/C++-Part1/</id>
    <published>2022-01-03T07:14:04.000Z</published>
    <updated>2022-05-07T08:59:49.304Z</updated>
    
    <content type="html"><![CDATA[<h1 id="C-Part1——入门编程"><a href="#C-Part1——入门编程" class="headerlink" title="C++-Part1——入门编程"></a>C++-Part1——入门编程</h1><p>[TOC]</p><h2 id="CLion-环境配置"><a href="#CLion-环境配置" class="headerlink" title="CLion 环境配置"></a>CLion 环境配置</h2><h3 id="无-Virtual-Studio-方案"><a href="#无-Virtual-Studio-方案" class="headerlink" title="无 Virtual Studio 方案"></a>无 Virtual Studio 方案</h3><blockquote><p>参考：</p><ul><li>Cygwin（推荐）：<a href="https://zhuanlan.zhihu.com/p/40776005">https://zhuanlan.zhihu.com/p/40776005</a></li><li>MinGW：<a href="http://c.biancheng.net/view/8077.html">http://c.biancheng.net/view/8077.html</a></li></ul></blockquote><ol><li>下载 <a href="http://www.cygwin.com/">Cygwin</a></li><li>安装 - 选择国内镜像</li><li>安装 - 选择 gcc-core、gcc-g++、make、gdb、binutils</li><li>配置工具链</li></ol><h3 id="乱码解决方案"><a href="#乱码解决方案" class="headerlink" title="乱码解决方案"></a>乱码解决方案</h3><blockquote><p>根本原因在于移植的编译环境一般只支持 UTF-8，因此要以编译环境为中心，把可能的文件都改成 UTF-8 编码。</p><p>否则编码错误会出现在各种地方，包括 Release、ssh。以后使用其他项目，也统一使用 UTF-8 编码。</p></blockquote><ol><li><p>设置搜索 UTF-8，修改文件的编码设置。</p><p><img src="/2022/1/C++-Part1/image-20220506211715471.png" alt="image-20220506211715471"></p></li><li><p>修改 ssh 终端的编码设置</p><p><img src="/2022/1/C++-Part1/image-20220506211759176.png" alt="image-20220506211759176"></p></li><li><p>项目下所有文件全部转换成 UTF-8 编码</p><p><img src="/2022/1/C++-Part1/image-20220506211843056.png" alt="image-20220506211843056"></p></li></ol><h2 id="C-初识"><a href="#C-初识" class="headerlink" title="C++ 初识"></a>C++ 初识</h2><h3 id="Hello-World"><a href="#Hello-World" class="headerlink" title="Hello, World!"></a>Hello, World!</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    std::cout &lt;&lt; &quot;Hello, World!&quot; &lt;&lt; std::endl;</span><br><span class="line">    system(&quot;pause&quot;);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h3><ol><li><p>单行注释：</p><ul><li><p><code>// 描述信息</code> </p></li><li><p>通常在一行代码的上方或者一条语句的末尾，对该行代码说明</p></li></ul></li><li><p>多行注释： </p><ul><li><code>/* 描述信息 */</code></li><li>通常在一段代码的上方，对该段代码做整体说明</li></ul></li><li><p>条件编译：</p><ul><li><p><code>#if 0 ... #endif</code></p></li><li><p>可以使用条件编译来实现注释，且可以实现嵌套</p></li><li><p>通过改变参数 0/1 来开启/屏蔽代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">if</span> 0</span></span><br><span class="line">code1</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> </span></span><br></pre></td></tr></table></figure><h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3></li></ul></li></ol><ul><li><p>作用：给一段指定的内存空间起名，方便操作这段内存</p></li><li><p>语法：<code>数据类型 变量名 = 初始值</code>;</p></li></ul><h3 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h3><ul><li>作用：用于记录程序中不可更改的数据</li></ul><ol><li>#define 宏常量： <ul><li><code>#define 常量名 常量值</code></li><li>通常在文件上方定义，表示一个常量</li></ul></li></ol><ol start="2"><li>const 修饰的变量 <ul><li><code>const 数据类型 常量名 = 常量值</code></li><li>通常在变量定义前加关键字 const，修饰该变量为常量，不可修改</li></ul></li></ol><h3 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h3><table><thead><tr><th>asm</th><th>do</th><th>if</th><th>return</th><th>typedef</th></tr></thead><tbody><tr><td>auto</td><td>double</td><td>inline</td><td>short</td><td>typeid</td></tr><tr><td>bool</td><td>dynamic_cast</td><td>int</td><td>signed</td><td>typename</td></tr><tr><td>break</td><td>else</td><td>long</td><td>sizeof</td><td>union</td></tr><tr><td>case</td><td>enum</td><td>mutable</td><td>static</td><td>unsigned</td></tr><tr><td>catch</td><td>explicit</td><td>namespace</td><td>static_cast</td><td>using</td></tr><tr><td>char</td><td>export</td><td>new</td><td>struct</td><td>virtual</td></tr><tr><td>class</td><td>extern</td><td>operator</td><td>switch</td><td>void</td></tr><tr><td>const</td><td>false</td><td>private</td><td>template</td><td>volatile</td></tr><tr><td>const_cast</td><td>float</td><td>protected</td><td>this</td><td>wchar_t</td></tr><tr><td>continue</td><td>for</td><td>public</td><td>throw</td><td>while</td></tr><tr><td>default</td><td>friend</td><td>register</td><td>true</td><td></td></tr><tr><td>delete</td><td>goto</td><td>reinterpret_cast</td><td>try</td><td></td></tr></tbody></table><h3 id="标识符命名规则"><a href="#标识符命名规则" class="headerlink" title="标识符命名规则"></a>标识符命名规则</h3><ul><li>标识符不能是关键字</li><li>标识符只能由字母、数字、下划线组成</li><li>第一个字符必须为字母或下划线</li><li>标识符中字母区分大小写</li></ul><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><h3 id="整型"><a href="#整型" class="headerlink" title="整型"></a>整型</h3><ul><li><p>作用：整型变量表示的是整数类型的数据</p></li><li><p>C++ 中能够表示整型的类型有以下几种方式，<strong>区别在于所占内存空间不同</strong>：</p></li></ul><table><thead><tr><th><strong>数据类型</strong></th><th><strong>占用空间</strong></th><th>取值范围</th></tr></thead><tbody><tr><td>short（短整型）</td><td>2 字节</td><td>-2^15 ~ 2^15-1</td></tr><tr><td>int（整型）</td><td>4 字节</td><td>-2^31 ~ 2^31-1</td></tr><tr><td>long（长整形）</td><td>Windows 为 4 字节，Linux 为 4 字节（32位）8 字节（64位）</td><td>-2^31 ~ 2^31-1</td></tr><tr><td>long long（长长整形）</td><td>8 字节</td><td>-2^63 ~ 2^63-1</td></tr></tbody></table><h3 id="sizeof-关键字"><a href="#sizeof-关键字" class="headerlink" title="sizeof 关键字"></a>sizeof 关键字</h3><ul><li>作用：利用 sizeof 关键字可以统计数据类型所占内存大小</li><li>语法： <code>sizeof( 数据类型 / 变量)</code></li><li>结论：short &lt; int &lt;= long &lt;= long long</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;short 类型所占内存空间为： &quot;</span> &lt;&lt; <span class="keyword">sizeof</span>(<span class="keyword">short</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;int 类型所占内存空间为： &quot;</span> &lt;&lt; <span class="keyword">sizeof</span>(<span class="keyword">int</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;long 类型所占内存空间为： &quot;</span> &lt;&lt; <span class="keyword">sizeof</span>(<span class="keyword">long</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;long long 类型所占内存空间为： &quot;</span> &lt;&lt; <span class="keyword">sizeof</span>(<span class="keyword">long</span> <span class="keyword">long</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * short 类型所占内存空间为： 2</span></span><br><span class="line"><span class="comment"> * int 类型所占内存空间为： 4</span></span><br><span class="line"><span class="comment"> * long 类型所占内存空间为： 4</span></span><br><span class="line"><span class="comment"> * long long 类型所占内存空间为： 8</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><h3 id="实型（浮点型）"><a href="#实型（浮点型）" class="headerlink" title="实型（浮点型）"></a>实型（浮点型）</h3><ul><li><p>作用：用于表示小数</p></li><li><p>浮点型变量分为两种：</p><ul><li>单精度 float </li><li>双精度 double</li></ul></li><li><p>有效数字指所有出现的数字个数，浮点数的精度取决于其尾数</p></li></ul><table><thead><tr><th><strong>数据类型</strong></th><th><strong>占用空间</strong></th><th><strong>有效数字范围</strong></th></tr></thead><tbody><tr><td>float</td><td>4 字节</td><td>7 位有效数字</td></tr><tr><td>double</td><td>8 字节</td><td>15～16 位有效数字</td></tr></tbody></table><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">float</span> f1 = <span class="number">3.1415926f</span>;  <span class="comment">// f 指定为 float，否则会经过 double 转型</span></span><br><span class="line">    <span class="keyword">double</span> d1 = <span class="number">3.1415926</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; f1 &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">// 默认都只能打印 6 位有效</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; d1&lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;float  sizeof = &quot;</span> &lt;&lt; <span class="keyword">sizeof</span>(f1) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;double sizeof = &quot;</span> &lt;&lt; <span class="keyword">sizeof</span>(d1) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//科学计数法</span></span><br><span class="line">    <span class="keyword">float</span> f2 = <span class="number">3e2</span>; <span class="comment">// 3 * 10 ^ 2</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;f2 = &quot;</span> &lt;&lt; f2 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">float</span> f3 = <span class="number">3e-2</span>;  <span class="comment">// 3 * 0.1 ^ 2</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;f3 = &quot;</span> &lt;&lt; f3 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 3.14159</span></span><br><span class="line"><span class="comment"> * 31.4159</span></span><br><span class="line"><span class="comment"> * float  sizeof = 4</span></span><br><span class="line"><span class="comment"> * double sizeof = 8</span></span><br><span class="line"><span class="comment"> * f2 = 300</span></span><br><span class="line"><span class="comment"> * f3 = 0.03</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><h3 id="字符型"><a href="#字符型" class="headerlink" title="字符型"></a>字符型</h3><ul><li><p>作用：字符型变量用于显示单个字符</p></li><li><p>语法：<code>char ch = &#39;a&#39;;</code></p></li><li><p>注意：</p><ul><li>在显示字符型变量时，用单引号将字符括起来，不要用双引号</li><li>单引号内只能有一个字符，不可以是字符串</li></ul></li><li><p>C 和 C++ 中字符型变量只占用 1 个字节。</p></li><li><p>字符型变量是将对应的 ASCII 编码放入到存储单元</p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> ch = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ch &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="keyword">sizeof</span>(<span class="keyword">char</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; (<span class="keyword">int</span>)ch &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">//查看字符a对应的ASCII码</span></span><br><span class="line">    ch = <span class="number">97</span>; <span class="comment">//可以直接用ASCII给字符型变量赋值</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ch &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * a</span></span><br><span class="line"><span class="comment"> * 1</span></span><br><span class="line"><span class="comment"> * 97</span></span><br><span class="line"><span class="comment"> * a</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><p>ASCII 码大致由以下两部分组成：</p><ul><li>ASCII 非打印控制字符： ASCII 表上的数字 <strong>0-31</strong> 分配给了控制字符，用于控制像打印机等一些外围设备。</li><li>ASCII 打印字符：数字 <strong>32-126</strong> 分配给了能在键盘上找到的字符，当查看或打印文档时就会出现。</li></ul><table><thead><tr><th><strong>ASCII</strong>值</th><th><strong>控制字符</strong></th><th><strong>ASCII</strong>值</th><th><strong>字符</strong></th><th><strong>ASCII</strong>值</th><th><strong>字符</strong></th><th><strong>ASCII</strong>值</th><th><strong>字符</strong></th></tr></thead><tbody><tr><td>0</td><td>NUT</td><td>32</td><td>(space)</td><td>64</td><td>@</td><td>96</td><td>、</td></tr><tr><td>1</td><td>SOH</td><td>33</td><td>!</td><td>65</td><td>A</td><td>97</td><td>a</td></tr><tr><td>2</td><td>STX</td><td>34</td><td>“</td><td>66</td><td>B</td><td>98</td><td>b</td></tr><tr><td>3</td><td>ETX</td><td>35</td><td>#</td><td>67</td><td>C</td><td>99</td><td>c</td></tr><tr><td>4</td><td>EOT</td><td>36</td><td>$</td><td>68</td><td>D</td><td>100</td><td>d</td></tr><tr><td>5</td><td>ENQ</td><td>37</td><td>%</td><td>69</td><td>E</td><td>101</td><td>e</td></tr><tr><td>6</td><td>ACK</td><td>38</td><td>&amp;</td><td>70</td><td>F</td><td>102</td><td>f</td></tr><tr><td>7</td><td>BEL</td><td>39</td><td>,</td><td>71</td><td>G</td><td>103</td><td>g</td></tr><tr><td>8</td><td>BS</td><td>40</td><td>(</td><td>72</td><td>H</td><td>104</td><td>h</td></tr><tr><td>9</td><td>HT</td><td>41</td><td>)</td><td>73</td><td>I</td><td>105</td><td>i</td></tr><tr><td>10</td><td>LF</td><td>42</td><td>*</td><td>74</td><td>J</td><td>106</td><td>j</td></tr><tr><td>11</td><td>VT</td><td>43</td><td>+</td><td>75</td><td>K</td><td>107</td><td>k</td></tr><tr><td>12</td><td>FF</td><td>44</td><td>,</td><td>76</td><td>L</td><td>108</td><td>l</td></tr><tr><td>13</td><td>CR</td><td>45</td><td>-</td><td>77</td><td>M</td><td>109</td><td>m</td></tr><tr><td>14</td><td>SO</td><td>46</td><td>.</td><td>78</td><td>N</td><td>110</td><td>n</td></tr><tr><td>15</td><td>SI</td><td>47</td><td>/</td><td>79</td><td>O</td><td>111</td><td>o</td></tr><tr><td>16</td><td>DLE</td><td>48</td><td>0</td><td>80</td><td>P</td><td>112</td><td>p</td></tr><tr><td>17</td><td>DCI</td><td>49</td><td>1</td><td>81</td><td>Q</td><td>113</td><td>q</td></tr><tr><td>18</td><td>DC2</td><td>50</td><td>2</td><td>82</td><td>R</td><td>114</td><td>r</td></tr><tr><td>19</td><td>DC3</td><td>51</td><td>3</td><td>83</td><td>S</td><td>115</td><td>s</td></tr><tr><td>20</td><td>DC4</td><td>52</td><td>4</td><td>84</td><td>T</td><td>116</td><td>t</td></tr><tr><td>21</td><td>NAK</td><td>53</td><td>5</td><td>85</td><td>U</td><td>117</td><td>u</td></tr><tr><td>22</td><td>SYN</td><td>54</td><td>6</td><td>86</td><td>V</td><td>118</td><td>v</td></tr><tr><td>23</td><td>TB</td><td>55</td><td>7</td><td>87</td><td>W</td><td>119</td><td>w</td></tr><tr><td>24</td><td>CAN</td><td>56</td><td>8</td><td>88</td><td>X</td><td>120</td><td>x</td></tr><tr><td>25</td><td>EM</td><td>57</td><td>9</td><td>89</td><td>Y</td><td>121</td><td>y</td></tr><tr><td>26</td><td>SUB</td><td>58</td><td>:</td><td>90</td><td>Z</td><td>122</td><td>z</td></tr><tr><td>27</td><td>ESC</td><td>59</td><td>;</td><td>91</td><td>[</td><td>123</td><td>{</td></tr><tr><td>28</td><td>FS</td><td>60</td><td>&lt;</td><td>92</td><td>/</td><td>124</td><td>|</td></tr><tr><td>29</td><td>GS</td><td>61</td><td>=</td><td>93</td><td>]</td><td>125</td><td>}</td></tr><tr><td>30</td><td>RS</td><td>62</td><td>&gt;</td><td>94</td><td>^</td><td>126</td><td>`</td></tr><tr><td>31</td><td>US</td><td>63</td><td>?</td><td>95</td><td>_</td><td>127</td><td>DEL</td></tr></tbody></table><h3 id="转义字符"><a href="#转义字符" class="headerlink" title="转义字符"></a>转义字符</h3><ul><li>作用：用于表示一些不能显示出来的 ASCII 字符</li></ul><table><thead><tr><th><strong>转义字符</strong></th><th><strong>含义</strong></th><th><strong>ASCII</strong>码值（十进制）</th></tr></thead><tbody><tr><td>\a</td><td>警报</td><td>007</td></tr><tr><td>\b</td><td>退格(BS) ，将当前位置移到前一列</td><td>008</td></tr><tr><td>\f</td><td>换页(FF)，将当前位置移到下页开头</td><td>012</td></tr><tr><td>\n</td><td>换行(LF) ，将当前位置移到下一行开头</td><td>010</td></tr><tr><td>\r</td><td>回车(CR) ，将当前位置移到本行开头</td><td>013</td></tr><tr><td>\t</td><td>水平制表(HT)  （跳到下一个TAB位置/8个字符位）</td><td>009</td></tr><tr><td>\v</td><td>垂直制表(VT)</td><td>011</td></tr><tr><td>\\</td><td>代表一个反斜线字符”\“</td><td>092</td></tr><tr><td>\&#39;</td><td>代表一个单引号（撇号）字符</td><td>039</td></tr><tr><td>\&quot;</td><td>代表一个双引号字符</td><td>034</td></tr><tr><td>?</td><td>代表一个问号</td><td>063</td></tr><tr><td>\0</td><td>数字0</td><td>000</td></tr><tr><td>\\ddd</td><td>8 进制转义字符，d 范围 0~7</td><td>3位8进制</td></tr><tr><td>\\xhh</td><td>16 进制转义字符，h 范围 0<del>9， a</del>f， A~F</td><td>3位16进制</td></tr></tbody></table><h3 id="字符串型"><a href="#字符串型" class="headerlink" title="字符串型"></a>字符串型</h3><ul><li>作用：用于表示一串字符</li></ul><ul><li><p>两种风格：</p><ol><li><p>C 风格字符串：<code>char 变量名[] = &quot;字符串值&quot;</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> str1[] = <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; str1 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>C++ 风格字符串：<code>string  变量名 = &quot;字符串值&quot;</code></p><ul><li>需要加入 <code>#include &lt;string&gt;</code></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">string</span> str = <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; str &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol></li><li><blockquote><p>注意：string 对象不要和 char 数组混用</p></blockquote></li></ul><h3 id="布尔类型"><a href="#布尔类型" class="headerlink" title="布尔类型"></a>布尔类型</h3><ul><li><p>作用：布尔数据类型代表真或假的值</p></li><li><p>bool 类型只有两个值：</p><ul><li>true  — 真（本质是1）</li><li>false — 假（本质是0）</li></ul></li><li><p>bool 类型占 1 个字节大小</p></li></ul><h3 id="数据的输入"><a href="#数据的输入" class="headerlink" title="数据的输入"></a>数据的输入</h3><ul><li><p>作用：用于从键盘获取数据</p></li><li><p>语法： <code>cin &gt;&gt; 变量</code></p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//整型输入</span></span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;请输入整型变量：&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; a;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; a &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//浮点型输入</span></span><br><span class="line">    <span class="keyword">double</span> d = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;请输入浮点型变量：&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; d;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; d &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//字符型输入</span></span><br><span class="line">    <span class="keyword">char</span> ch = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;请输入字符型变量：&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; ch;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ch &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//字符串型输入</span></span><br><span class="line">    <span class="built_in">string</span> str;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;请输入字符串型变量：&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; str;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; str &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//布尔类型输入</span></span><br><span class="line">    <span class="keyword">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;请输入布尔型变量：&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; flag;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; flag &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> EXIT_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h2><h3 id="算术运算符"><a href="#算术运算符" class="headerlink" title="算术运算符"></a>算术运算符</h3><ul><li>作用：用于处理四则运算 </li></ul><table><thead><tr><th><strong>运算符</strong></th><th><strong>术语</strong></th><th><strong>示例</strong></th><th><strong>结果</strong></th></tr></thead><tbody><tr><td>+</td><td>正号</td><td>+3</td><td>3</td></tr><tr><td>-</td><td>负号</td><td>-3</td><td>-3</td></tr><tr><td>+</td><td>加</td><td>10 + 5</td><td>15</td></tr><tr><td>-</td><td>减</td><td>10 - 5</td><td>5</td></tr><tr><td>*</td><td>乘</td><td>10 * 5</td><td>50</td></tr><tr><td>/</td><td>除</td><td>10 / 5</td><td>2</td></tr><tr><td>%</td><td>取模（取余）</td><td>10 % 3</td><td>1</td></tr><tr><td>++</td><td>前置递增</td><td>a=2; b=++a;</td><td>a=3; b=3;</td></tr><tr><td>++</td><td>后置递增</td><td>a=2; b=a++;</td><td>a=3; b=2;</td></tr><tr><td>–</td><td>前置递减</td><td>a=2; b=–a;</td><td>a=1; b=1;</td></tr><tr><td>–</td><td>后置递减</td><td>a=2; b=a–;</td><td>a=1; b=2;</td></tr></tbody></table><h3 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符"></a>赋值运算符</h3><ul><li>作用：用于将表达式的值赋给变量</li></ul><table><thead><tr><th><strong>运算符</strong></th><th><strong>术语</strong></th><th><strong>示例</strong></th><th><strong>结果</strong></th></tr></thead><tbody><tr><td>=</td><td>赋值</td><td>a=2; b=3;</td><td>a=2; b=3;</td></tr><tr><td>+=</td><td>加等于</td><td>a=0; a+=2;</td><td>a=2;</td></tr><tr><td>-=</td><td>减等于</td><td>a=5; a-=3;</td><td>a=2;</td></tr><tr><td>*=</td><td>乘等于</td><td>a=2; a*=2;</td><td>a=4;</td></tr><tr><td>/=</td><td>除等于</td><td>a=4; a/=2;</td><td>a=2;</td></tr><tr><td>%=</td><td>模等于</td><td>a=3; a%2;</td><td>a=1;</td></tr></tbody></table><h3 id="比较运算符"><a href="#比较运算符" class="headerlink" title="比较运算符"></a>比较运算符</h3><ul><li>作用：用于表达式的比较，并返回一个真值或假值</li></ul><table><thead><tr><th><strong>运算符</strong></th><th><strong>术语</strong></th><th><strong>示例</strong></th><th><strong>结果</strong></th></tr></thead><tbody><tr><td>==</td><td>相等于</td><td>4 == 3</td><td>0</td></tr><tr><td>!=</td><td>不等于</td><td>4 != 3</td><td>1</td></tr><tr><td>&lt;</td><td>小于</td><td>4 &lt; 3</td><td>0</td></tr><tr><td>&gt;</td><td>大于</td><td>4 &gt; 3</td><td>1</td></tr><tr><td>&lt;=</td><td>小于等于</td><td>4 &lt;= 3</td><td>0</td></tr><tr><td>&gt;=</td><td>大于等于</td><td>4 &gt;= 1</td><td>1</td></tr></tbody></table><h3 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h3><ul><li>作用：用于根据表达式的值返回真值或假值</li></ul><table><thead><tr><th><strong>运算符</strong></th><th><strong>术语</strong></th><th><strong>示例</strong></th><th><strong>结果</strong></th></tr></thead><tbody><tr><td>!</td><td>非</td><td>!a</td><td>如果a为假，则!a为真；  如果a为真，则!a为假。</td></tr><tr><td>&amp;&amp;</td><td>与</td><td>a &amp;&amp; b</td><td>如果a和b都为真，则结果为真，否则为假。</td></tr><tr><td>||</td><td>或</td><td>a || b</td><td>如果a和b有一个为真，则结果为真，二者都为假时，结果为假。</td></tr></tbody></table><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> b = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> c = <span class="number">3</span>;</span><br><span class="line">    a += b || c;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; a &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; b &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; c &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> EXIT_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="程序流程结构"><a href="#程序流程结构" class="headerlink" title="程序流程结构"></a>程序流程结构</h2><blockquote><p>C/C++支持最基本的三种程序运行结构：</p><ul><li>顺序结构：程序按顺序执行，不发生跳转</li><li>选择结构：依据条件是否满足，有选择的执行相应功能</li><li>循环结构：依据条件是否满足，循环多次执行某段代码</li></ul></blockquote><h3 id="选择结构"><a href="#选择结构" class="headerlink" title="选择结构"></a>选择结构</h3><h4 id="if-语句"><a href="#if-语句" class="headerlink" title="if 语句"></a>if 语句</h4><ul><li><p>作用：执行满足条件的语句</p></li><li><p>if 语句的三种形式</p><ul><li><p>单行格式 if 语句</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ( 条件 ) &#123; </span><br><span class="line">    条件满足执行的语句</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>多行格式 if 语句</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ( 条件 ) &#123; </span><br><span class="line">    条件满足执行的语句</span><br><span class="line">&#125; <span class="keyword">else</span> &#123; </span><br><span class="line">    条件不满足执行的语句</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>多条件的 if 语句</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ( 条件<span class="number">1</span> ) &#123; </span><br><span class="line">条件<span class="number">1</span>满足执行的语句</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> ( 条件<span class="number">2</span> ) &#123;</span><br><span class="line">    条件<span class="number">2</span>满足执行的语句</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">else</span> &#123; </span><br><span class="line">都不满足执行的语句</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="三目运算符"><a href="#三目运算符" class="headerlink" title="三目运算符"></a>三目运算符</h4></li></ul></li><li><p>作用： 通过三目运算符实现简单的判断</p></li><li><p>语法：<code>表达式1 ? 语句2 ：语句3</code></p></li><li><p>C++ 中三目运算符返回的是变量，可以继续赋值</p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">int</span> b = <span class="number">20</span>;</span><br><span class="line">    <span class="keyword">int</span> c = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    c = a &gt; b ? a : b;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;c = &quot;</span> &lt;&lt; c &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">// c = 20</span></span><br><span class="line"></span><br><span class="line">    (a &gt; b ? a : b) = <span class="number">100</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">// a = 10</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;b = &quot;</span> &lt;&lt; b &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">// b = 100</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;c = &quot;</span> &lt;&lt; c &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">// c = 20</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="switch-语句"><a href="#switch-语句" class="headerlink" title="switch 语句"></a>switch 语句</h4><ul><li><p>作用：执行多条件分支语句</p></li><li><p>注意：</p><ul><li>switch 语句中表达式类型只能是整型或者字符型</li><li>case 里如果没有 break，那么程序会一直向下执行</li><li>与 if 语句比，对于多条件判断时，switch 结构清晰，执行效率高，缺点是 switch 不可以直接判断区间</li></ul></li><li><p>语法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> ( 表达式 ) &#123;</span><br><span class="line">    <span class="keyword">case</span> 结果<span class="number">1</span>: 执行语句; <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> 结果<span class="number">2</span>: 执行语句; <span class="keyword">break</span>;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">default</span>: 执行语句; <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//请给电影评分 </span></span><br><span class="line"><span class="comment">//10 ~ 9   经典   </span></span><br><span class="line"><span class="comment">// 8 ~ 7   非常好</span></span><br><span class="line"><span class="comment">// 6 ~ 5   一般</span></span><br><span class="line"><span class="comment">// 5分以下 烂片</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> score = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;请给电影打分&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; score;</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> (score) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">10</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="number">9</span>:</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;经典&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">8</span>:</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;非常好&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">7</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="number">6</span>:</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;一般&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;烂片&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="循环结构"><a href="#循环结构" class="headerlink" title="循环结构"></a>循环结构</h3></li></ul><h4 id="while-循环语句"><a href="#while-循环语句" class="headerlink" title="while 循环语句"></a>while 循环语句</h4><ul><li><p>作用：满足循环条件，执行循环语句</p></li><li><p>语法： </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> ( 循环条件 ) &#123; </span><br><span class="line">    循环语句 </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="do…while-循环语句"><a href="#do…while-循环语句" class="headerlink" title="do…while 循环语句"></a>do…while 循环语句</h4></li><li><p>作用： 先执行一次语句，之后满足循环条件，执行循环语句</p></li><li><p>注意：</p><ul><li>while 后面要加分号</li></ul></li><li><p>语法： </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; num &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    num++;</span><br><span class="line">&#125; <span class="keyword">while</span> (num &lt; <span class="number">10</span>);</span><br></pre></td></tr></table></figure><h4 id="for-循环语句"><a href="#for-循环语句" class="headerlink" title="for 循环语句"></a>for 循环语句</h4></li><li><p>作用： 满足循环条件，执行循环语句</p></li><li><p>语法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="跳转语句"><a href="#跳转语句" class="headerlink" title="跳转语句"></a>跳转语句</h3></li></ul><h4 id="break-语句"><a href="#break-语句" class="headerlink" title="break 语句"></a>break 语句</h4><ul><li><p>作用：用于跳出选择结构或者循环结构</p></li><li><p>break 使用的时机：</p><ul><li>出现在 switch 条件语句中，作用是终止 case 并跳出 switch</li><li>出现在循环语句中，作用是跳出当前的循环语句</li><li>出现在嵌套循环中，跳出最近的内层循环语句</li></ul></li></ul><h4 id="continue-语句"><a href="#continue-语句" class="headerlink" title="continue 语句"></a>continue 语句</h4><ul><li>作用：在循环语句中，跳过本次循环中余下尚未执行的语句，继续执行下一次循环</li></ul><ul><li>注意：continue 并没有使整个循环终止，而 break 会跳出循环</li></ul><h4 id="goto-语句"><a href="#goto-语句" class="headerlink" title="goto 语句"></a>goto 语句</h4><ul><li><p>作用：可以无条件跳转语句</p></li><li><p>注意</p><ul><li>在程序中不建议使用 goto 语句，以免造成程序流程混乱</li></ul></li><li><p>语法： <code>goto 标记;</code></p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;1&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">goto</span> FLAG;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;2&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;3&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;4&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">FLAG:</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;5&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><h3 id="一维数组"><a href="#一维数组" class="headerlink" title="一维数组"></a>一维数组</h3><h4 id="一维数组定义方式"><a href="#一维数组定义方式" class="headerlink" title="一维数组定义方式"></a>一维数组定义方式</h4><ul><li>一维数组定义的三种方式：<ol><li><code>数据类型 数组名[ 数组长度 ];</code></li><li><code>数据类型 数组名[ 数组长度 ] = &#123; 值1，值2 ... &#125;;</code></li><li><code>数据类型 数组名[ ] = &#123; 值1，值2 ... &#125;;</code></li></ol></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 1. 第一种定义方式</span></span><br><span class="line">    <span class="comment">// 数据类型 数组名[元素个数];</span></span><br><span class="line">    <span class="keyword">int</span> arr1[<span class="number">10</span>];</span><br><span class="line">    arr1[<span class="number">0</span>] = <span class="number">100</span>;  <span class="comment">// 利用下标赋值</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; arr1[<span class="number">0</span>] &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">// 利用下标输出</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 第二种定义方式</span></span><br><span class="line">    <span class="comment">// 数据类型 数组名[元素个数] =  &#123;值1，值2 ，值3 ...&#125;;</span></span><br><span class="line">    <span class="comment">// 如果&#123;&#125;内不足10个数据，剩余数据用0补全</span></span><br><span class="line">    <span class="keyword">int</span> arr2[<span class="number">10</span>] = &#123;<span class="number">100</span>, <span class="number">90</span>, <span class="number">80</span>, <span class="number">70</span>, <span class="number">60</span>, <span class="number">50</span>, <span class="number">40</span>, <span class="number">30</span>, <span class="number">20</span>, <span class="number">10</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; arr2[i] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 第三种定义方式</span></span><br><span class="line">    <span class="comment">// 数据类型 数组名[] =  &#123;值1，值2 ，值3 ...&#125;;</span></span><br><span class="line">    <span class="keyword">int</span> arr3[] = &#123;<span class="number">100</span>, <span class="number">90</span>, <span class="number">80</span>, <span class="number">70</span>, <span class="number">60</span>, <span class="number">50</span>, <span class="number">40</span>, <span class="number">30</span>, <span class="number">20</span>, <span class="number">10</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i : arr3) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="一维数组数组名"><a href="#一维数组数组名" class="headerlink" title="一维数组数组名"></a>一维数组数组名</h4><ul><li><p>一维数组名称的用途：</p><ol><li>可以统计整个数组在内存中的长度：<code>sizeof(arr)</code></li><li>可以获取数组在内存中的首地址：<code>(int) &amp;arr[0]</code></li></ol></li><li><p>数组名是指针常量，不可以赋值</p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//数组名用途</span></span><br><span class="line">    <span class="comment">//1、可以获取整个数组占用内存空间大小</span></span><br><span class="line">    <span class="keyword">int</span> arr[<span class="number">10</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;整个数组所占内存空间为： &quot;</span> &lt;&lt; <span class="keyword">sizeof</span>(arr) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;每个元素所占内存空间为： &quot;</span> &lt;&lt; <span class="keyword">sizeof</span>(arr[<span class="number">0</span>]) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;数组的元素个数为： &quot;</span> &lt;&lt; <span class="keyword">sizeof</span>(arr) / <span class="keyword">sizeof</span>(arr[<span class="number">0</span>]) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2、可以通过数组名获取到数组首地址</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;数组首地址为： &quot;</span> &lt;&lt; (<span class="keyword">int</span>) arr &lt;&lt; <span class="string">&quot; - &quot;</span> &lt;&lt; arr &lt;&lt;  <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;数组中第一个元素地址为： &quot;</span> &lt;&lt; (<span class="keyword">int</span>) &amp;arr[<span class="number">0</span>] &lt;&lt; <span class="string">&quot; - &quot;</span> &lt;&lt; &amp;arr[<span class="number">0</span>] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;数组中第二个元素地址为： &quot;</span> &lt;&lt; (<span class="keyword">int</span>) &amp;arr[<span class="number">1</span>] &lt;&lt; <span class="string">&quot; - &quot;</span> &lt;&lt; &amp;arr[<span class="number">1</span>] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 整个数组所占内存空间为： 40</span></span><br><span class="line"><span class="comment"> * 每个元素所占内存空间为： 4</span></span><br><span class="line"><span class="comment"> * 数组的元素个数为： 10</span></span><br><span class="line"><span class="comment"> * 数组首地址为： 7338512 - 006FFA10</span></span><br><span class="line"><span class="comment"> * 数组中第一个元素地址为： 7338512 - 006FFA10</span></span><br><span class="line"><span class="comment"> * 数组中第二个元素地址为： 7338516 - 006FFA14</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><h3 id="二维数组"><a href="#二维数组" class="headerlink" title="二维数组"></a>二维数组</h3><h4 id="二维数组定义方式"><a href="#二维数组定义方式" class="headerlink" title="二维数组定义方式"></a>二维数组定义方式</h4><ul><li>二维数组定义的四种方式：<ol><li><code>数据类型 数组名[ 行数 ][ 列数 ];</code></li><li><code>数据类型 数组名[ 行数 ][ 列数 ] = &#123; &#123;数据1，数据2 &#125; ，&#123;数据3，数据4 &#125; &#125;;</code>（推荐）</li><li><code>数据类型 数组名[ 行数 ][ 列数 ] = &#123; 数据1，数据2，数据3，数据4&#125;;</code></li><li><code> 数据类型 数组名[  ][ 列数 ] = &#123; 数据1，数据2，数据3，数据4&#125;;</code></li></ol></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 1. 方式1</span></span><br><span class="line">    <span class="comment">// 数组类型 数组名 [行数][列数]</span></span><br><span class="line">    <span class="keyword">int</span> arr[<span class="number">2</span>][<span class="number">3</span>];</span><br><span class="line">    arr[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    arr[<span class="number">0</span>][<span class="number">1</span>] = <span class="number">2</span>;</span><br><span class="line">    arr[<span class="number">0</span>][<span class="number">2</span>] = <span class="number">3</span>;</span><br><span class="line">    arr[<span class="number">1</span>][<span class="number">0</span>] = <span class="number">4</span>;</span><br><span class="line">    arr[<span class="number">1</span>][<span class="number">1</span>] = <span class="number">5</span>;</span><br><span class="line">    arr[<span class="number">1</span>][<span class="number">2</span>] = <span class="number">6</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;i : arr) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j : i) &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; j &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 方式2</span></span><br><span class="line">    <span class="comment">// 数据类型 数组名[行数][列数] = &#123; &#123;数据1，数据2 &#125; ，&#123;数据3，数据4 &#125; &#125;;</span></span><br><span class="line">    <span class="keyword">int</span> arr2[<span class="number">2</span>][<span class="number">3</span>] = &#123;&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;,</span><br><span class="line">                      &#123;<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&#125;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 方式3</span></span><br><span class="line">    <span class="comment">// 数据类型 数组名[行数][列数] = &#123; 数据1，数据2 ,数据3，数据4  &#125;;</span></span><br><span class="line">    <span class="keyword">int</span> arr3[<span class="number">2</span>][<span class="number">3</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4. 方式4</span></span><br><span class="line">    <span class="comment">// 数据类型 数组名[][列数] = &#123; 数据1，数据2 ,数据3，数据4  &#125;;</span></span><br><span class="line">    <span class="keyword">int</span> arr4[][<span class="number">3</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="二维数组数组名"><a href="#二维数组数组名" class="headerlink" title="二维数组数组名"></a>二维数组数组名</h4><ul><li>用途<ul><li>查看二维数组所占内存空间：<code>sizeof(arr)</code></li><li>获取二维数组首地址：<code>&amp;arr[0][0]</code></li></ul></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> arr[<span class="number">2</span>][<span class="number">3</span>] = &#123;&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;,</span><br><span class="line">                     &#123;<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&#125;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 大小</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;二维数组大小：&quot;</span> &lt;&lt; <span class="keyword">sizeof</span>(arr) &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">// 二维数组大小：24</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;二维数组一行大小：&quot;</span> &lt;&lt; <span class="keyword">sizeof</span>(arr[<span class="number">0</span>]) &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">// 二维数组一行大小：12</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;二维数组元素大小：&quot;</span> &lt;&lt; <span class="keyword">sizeof</span>(arr[<span class="number">0</span>][<span class="number">0</span>]) &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">// 二维数组元素大小：4</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;二维数组行数：&quot;</span> &lt;&lt; <span class="keyword">sizeof</span>(arr) / <span class="keyword">sizeof</span>(arr[<span class="number">0</span>]) &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">// 二维数组行数：2</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;二维数组列数：&quot;</span> &lt;&lt; <span class="keyword">sizeof</span>(arr[<span class="number">0</span>]) / <span class="keyword">sizeof</span>(arr[<span class="number">0</span>][<span class="number">0</span>]) &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">// 二维数组列数：3</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 地址</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;二维数组首地址：&quot;</span> &lt;&lt; arr &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">// 二维数组首地址：009AFC94</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;二维数组第一行地址：&quot;</span> &lt;&lt; arr[<span class="number">0</span>] &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">// 二维数组第一行地址：009AFC94</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;二维数组第二行地址：&quot;</span> &lt;&lt; arr[<span class="number">1</span>] &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">// 二维数组第二行地址：009AFCA0</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;二维数组第一个元素地址：&quot;</span> &lt;&lt; &amp;arr[<span class="number">0</span>][<span class="number">0</span>] &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">// 二维数组第一个元素地址：009AFC94</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;二维数组第二个元素地址：&quot;</span> &lt;&lt; &amp;arr[<span class="number">0</span>][<span class="number">1</span>] &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">// 二维数组第二个元素地址：009AFC98</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><h3 id="函数的定义"><a href="#函数的定义" class="headerlink" title="函数的定义"></a>函数的定义</h3><ul><li><p>函数的定义的 5 个要素：</p><ul><li>返回值类型 ：一个函数可以返回一个值</li><li>函数名：给函数起个名称</li><li>参数列表：使用该函数时，传入的数据</li><li>函数体语句：花括号内的代码，函数内需要执行的语句</li><li>return 表达式： 和返回值类型挂钩，函数执行完后，返回相应的数据</li></ul></li><li><p>函数定义里小括号内称为<strong>形参</strong>，函数调用时传入的参数称为<strong>实参</strong></p></li><li><p>语法： </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">返回值类型 函数名(形参<span class="number">1</span>类型 形参<span class="number">1</span>名[, ...]) &#123;</span><br><span class="line">函数体</span><br><span class="line">[<span class="keyword">return</span> 表达式;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="函数的调用"><a href="#函数的调用" class="headerlink" title="函数的调用"></a>函数的调用</h3></li><li><p>功能：使用定义好的函数</p></li><li><p>语法：<code>函数名(参数)</code></p></li></ul><h3 id="值传递"><a href="#值传递" class="headerlink" title="值传递"></a>值传递</h3><ul><li>值传递，指函数调用时，<strong>实参将数值传入给形参（赋值传递）</strong></li><li>值传递时，局部变量的改变，不会影响到外部变量</li></ul><h3 id="函数的常见样式"><a href="#函数的常见样式" class="headerlink" title="函数的常见样式"></a>函数的常见样式</h3><ul><li>常见的函数样式有4种<ol><li>无参无返</li><li>有参无返</li><li>无参有返</li><li>有参有返</li></ol></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1. 无参无返</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;this is test01&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2. 有参无返</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">(<span class="keyword">int</span> a)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;this is test02&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//3. 无参有返</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">test03</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;this is test03 &quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//4. 有参有返</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">test04</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;this is test04 &quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">int</span> sum = a + b;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="函数的声明"><a href="#函数的声明" class="headerlink" title="函数的声明"></a>函数的声明</h3><ul><li>作用： 告诉编译器函数名称及如何调用函数。</li><li>函数的实际主体可以单独定义。</li><li>函数的<strong>声明可以多次</strong>，但是函数的<strong>定义只能有一次</strong></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//声明</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">max</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">max</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">max</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a &gt; b ? a : b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">int</span> b = <span class="number">200</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; max(a, b) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="函数的分文件编写"><a href="#函数的分文件编写" class="headerlink" title="函数的分文件编写"></a>函数的分文件编写</h3><ul><li><p>作用：让代码结构更加清晰</p></li><li><p>函数分文件编写一般有 4 个步骤</p><ol><li>创建后缀名为 .h 的头文件  </li><li>创建后缀名为 .cpp 的源文件</li><li>在头文件中写函数的声明</li><li>在源文件中写函数的定义</li></ol></li><li><blockquote><p>使用 CMakeLists.txt 时，需要编辑：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">cmake_minimum_required(VERSION <span class="number">3.19</span>)</span><br><span class="line">project(CLearning)</span><br><span class="line"></span><br><span class="line"><span class="built_in">set</span>(CMAKE_CXX_STANDARD <span class="number">20</span>)</span><br><span class="line"></span><br><span class="line">add_executable(CLearning main.cpp swap.cpp swap.h)</span><br></pre></td></tr></table></figure></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// -&gt; swap.h文件</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> CLEARNING_SWAP_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CLEARNING_SWAP_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现两个数字交换的函数声明</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">//CLEARNING_SWAP_H</span></span></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// -&gt; swap.cpp文件</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;swap.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp = a;</span><br><span class="line">    a = b;</span><br><span class="line">    b = temp;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;b = &quot;</span> &lt;&lt; b &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// -&gt; main函数文件</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;swap.h&quot;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> a = <span class="number">100</span>;</span><br><span class="line"><span class="keyword">int</span> b = <span class="number">200</span>;</span><br><span class="line">swap(a, b);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h2></li></ul><h3 id="指针变量的定义和使用"><a href="#指针变量的定义和使用" class="headerlink" title="指针变量的定义和使用"></a>指针变量的定义和使用</h3><ul><li><blockquote><p>指针也是一种数据类型，可以使用 <code>(int *)</code> 强转</p></blockquote></li><li><p>指针变量定义语法： <code>数据类型 * 变量名；</code></p></li><li><p>指针变量和普通变量的区别</p><ul><li>普通变量存放的是数据,指针变量存放的是地址</li><li>指针变量可以通过解引用操作符 <code>*</code>，操作指针变量指向的内存空间</li></ul></li><li><p>总结</p><ul><li>我们可以通过 <code>&amp;</code> 符号获取变量的地址</li><li>利用指针可以记录地址</li><li>对指针变量解引用，可以操作指针指向的内存</li></ul></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 1. 指针的定义</span></span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">10</span>; <span class="comment">//定义整型变量a</span></span><br><span class="line">    <span class="comment">// 指针定义语法： 数据类型 * 变量名 ;</span></span><br><span class="line">    <span class="keyword">int</span> *p;</span><br><span class="line">    <span class="comment">// 指针变量赋值</span></span><br><span class="line">    p = &amp;a; <span class="comment">// 指针指向变量a的地址</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; &amp;a &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 打印数据a的地址</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; p &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">// 打印指针变量p</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 指针的使用</span></span><br><span class="line">    <span class="comment">// 通过*解引用符操作指针变量指向的内存</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;*p = &quot;</span> &lt;&lt; *p &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="指针所占内存空间"><a href="#指针所占内存空间" class="headerlink" title="指针所占内存空间"></a>指针所占内存空间</h3><ul><li>所有指针类型在 32 位操作系统下是 4 个字节</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> * p;</span><br><span class="line">p = &amp;a; <span class="comment">// 指针指向数据a的地址</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; *p &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// * 解引用</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="keyword">sizeof</span>(p) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="keyword">sizeof</span>(<span class="keyword">char</span> *) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="keyword">sizeof</span>(<span class="keyword">float</span> *) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="keyword">sizeof</span>(<span class="keyword">double</span> *) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="空指针和野指针"><a href="#空指针和野指针" class="headerlink" title="空指针和野指针"></a>空指针和野指针</h3><ul><li>空指针：指针变量指向内存中编号为 0 的空间</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// 指针变量p指向内存地址编号为0的空间</span></span><br><span class="line"><span class="keyword">int</span> * p = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 访问空指针报错 </span></span><br><span class="line"><span class="comment">// 内存编号 0 ~255 为系统占用内存，不允许用户访问</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; *p &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>野指针：指针变量指向非法的内存空间</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// 指针变量p指向内存地址编号为0x1100的空间</span></span><br><span class="line"><span class="keyword">int</span> * p = (<span class="keyword">int</span> *)<span class="number">0x1100</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 访问野指针报错 </span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; *p &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="const-修饰指针"><a href="#const-修饰指针" class="headerlink" title="const 修饰指针"></a>const 修饰指针</h3><ul><li><p>const 修饰指针的三种情况</p><ol><li>常量指针：const 修饰指针</li><li>指针常量：const 修饰常量</li><li>const 即修饰指针，又修饰常量</li></ol></li><li><blockquote><p>技巧：看 const 右侧紧跟着的是指针还是常量，是指针就是常量指针，是常量就是指针常量</p></blockquote></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">int</span> b = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 常量指针：const修饰的是指针，指针的值可以改，指针指向的值不可以更改</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> *p1 = &amp;a;</span><br><span class="line">    p1 = &amp;b;  <span class="comment">// 正确</span></span><br><span class="line">    <span class="comment">// *p1 = 100;  // 报错</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 指针常量：const修饰的是常量，指针的值不可以改，指针指向的值可以更改</span></span><br><span class="line">    <span class="keyword">int</span> *<span class="keyword">const</span> p2 = &amp;a;</span><br><span class="line">    <span class="comment">// p2 = &amp;b;  // 错误</span></span><br><span class="line">    *p2 = <span class="number">100</span>;  <span class="comment">// 正确</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// const既修饰指针又修饰常量</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> *<span class="keyword">const</span> p3 = &amp;a;</span><br><span class="line">    <span class="comment">// p3 = &amp;b;  // 错误</span></span><br><span class="line">    <span class="comment">// *p3 = 100;  // 错误</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="指针和数组"><a href="#指针和数组" class="headerlink" title="指针和数组"></a>指针和数组</h3><ul><li><p>作用：利用指针访问数组中元素</p></li><li><blockquote><p>指向数组的指针，进行 +1 操作，其到底移动多少在于指针的类型（若是 int，则为 4 字节）</p></blockquote></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> arr[] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> *p = arr;  <span class="comment">//指向数组的指针</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;第一个元素： &quot;</span> &lt;&lt; arr[<span class="number">0</span>] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;指针访问第一个元素： &quot;</span> &lt;&lt; *p &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; *p &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        p++;  <span class="comment">// 此处往后移 4 个字节</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="指针和函数"><a href="#指针和函数" class="headerlink" title="指针和函数"></a>指针和函数</h3><ul><li><p>作用：利用指针作函数参数，可以修改实参的值</p></li><li><blockquote><p>如果不想修改实参，就用值传递；如果想修改实参，就用地址传递。</p></blockquote></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//值传递</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap1</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp = a;</span><br><span class="line">    a = b;</span><br><span class="line">    b = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//地址传递</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap2</span><span class="params">(<span class="keyword">int</span> *p1, <span class="keyword">int</span> *p2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp = *p1;</span><br><span class="line">    *p1 = *p2;</span><br><span class="line">    *p2 = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">int</span> b = <span class="number">20</span>;</span><br><span class="line">    </span><br><span class="line">    swap1(a, b); <span class="comment">// 值传递不会改变实参</span></span><br><span class="line">    swap2(&amp;a, &amp;b); <span class="comment">//地址传递会改变实参</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;b = &quot;</span> &lt;&lt; b &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="指针、数组、函数"><a href="#指针、数组、函数" class="headerlink" title="指针、数组、函数"></a>指针、数组、函数</h3><ul><li><p>案例描述：封装一个函数，利用冒泡排序，实现对整型数组的升序排序</p></li><li><blockquote><p>总结：当数组名传入到函数作为参数时，被退化为指向首元素的指针</p></blockquote></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//冒泡排序函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bubbleSort</span><span class="params">(<span class="keyword">int</span> *arr, <span class="keyword">int</span> len)</span> </span>&#123;  <span class="comment">//int * arr 也可以写为int arr[]</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; len - <span class="number">1</span> - i; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[j] &gt; arr[j + <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="keyword">int</span> temp = arr[j];</span><br><span class="line">                arr[j] = arr[j + <span class="number">1</span>];</span><br><span class="line">                arr[j + <span class="number">1</span>] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//打印数组函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printArray</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; arr[i] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> arr[<span class="number">10</span>] = &#123;<span class="number">4</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">9</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">10</span>, <span class="number">8</span>, <span class="number">7</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> len = <span class="keyword">sizeof</span>(arr) / <span class="keyword">sizeof</span>(<span class="keyword">int</span>);</span><br><span class="line"></span><br><span class="line">    bubbleSort(arr, len);</span><br><span class="line">    printArray(arr, len);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h2><h3 id="结构体定义和使用"><a href="#结构体定义和使用" class="headerlink" title="结构体定义和使用"></a>结构体定义和使用</h3><ul><li>语法：<code>struct 结构体名 &#123; 结构体成员列表 &#125;；</code></li><li>通过结构体创建变量的方式有三种：（建议使用前两种）<ol><li>[struct] 结构体名 变量名</li><li>[struct] 结构体名 变量名 = { 成员1值 , … }</li><li>定义结构体时顺便创建变量</li></ol></li><li>利用 <code>.</code> 访问结构体属性</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 结构体定义</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">student</span> &#123;</span></span><br><span class="line">    <span class="built_in">string</span> name;  <span class="comment">// 姓名</span></span><br><span class="line">    <span class="keyword">int</span> age&#123;&#125;;    <span class="comment">// 年龄</span></span><br><span class="line">    <span class="keyword">int</span> score&#123;&#125;;  <span class="comment">// 分数</span></span><br><span class="line">&#125; stu3;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 结构体变量创建方式1</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">student</span> <span class="title">stu1</span>;</span>  <span class="comment">// struct 关键字可以省略</span></span><br><span class="line">    stu1.name = <span class="string">&quot;张三&quot;</span>;</span><br><span class="line">    stu1.age = <span class="number">18</span>;</span><br><span class="line">    stu1.score = <span class="number">100</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;姓名：&quot;</span> &lt;&lt; stu1.name &lt;&lt; <span class="string">&quot; 年龄：&quot;</span> &lt;&lt; stu1.age &lt;&lt; <span class="string">&quot; 分数：&quot;</span> &lt;&lt; stu1.score &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 结构体变量创建方式2</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">student</span> <span class="title">stu2</span> =</span> &#123;<span class="string">&quot;李四&quot;</span>, <span class="number">19</span>, <span class="number">60</span>&#125;;  <span class="comment">// struct 关键字可以省略</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;姓名：&quot;</span> &lt;&lt; stu2.name &lt;&lt; <span class="string">&quot; 年龄：&quot;</span> &lt;&lt; stu2.age &lt;&lt; <span class="string">&quot; 分数：&quot;</span> &lt;&lt; stu2.score &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 结构体变量创建方式3</span></span><br><span class="line">    stu3.name = <span class="string">&quot;王五&quot;</span>;</span><br><span class="line">    stu3.age = <span class="number">18</span>;</span><br><span class="line">    stu3.score = <span class="number">80</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;姓名：&quot;</span> &lt;&lt; stu3.name &lt;&lt; <span class="string">&quot; 年龄：&quot;</span> &lt;&lt; stu3.age &lt;&lt; <span class="string">&quot; 分数：&quot;</span> &lt;&lt; stu3.score &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="结构体数组"><a href="#结构体数组" class="headerlink" title="结构体数组"></a>结构体数组</h3><ul><li><p>作用：将自定义的结构体放入到数组中方便维护</p></li><li><p>语法：<code> struct  结构体名 数组名[元素个数] = &#123;  &#123;&#125; , &#123;&#125; , ... &#123;&#125; &#125;</code></p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 结构体定义</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">student</span> &#123;</span> </span><br><span class="line">    <span class="built_in">string</span> name;  <span class="comment">// 姓名</span></span><br><span class="line">    <span class="keyword">int</span> age&#123;&#125;;    <span class="comment">// 年龄</span></span><br><span class="line">    <span class="keyword">int</span> score&#123;&#125;;  <span class="comment">// 分数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 结构体数组</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">student</span> <span class="title">arr</span>[3] =</span> &#123;&#123;<span class="string">&quot;张三&quot;</span>, <span class="number">18</span>, <span class="number">80</span>&#125;,</span><br><span class="line">                             &#123;<span class="string">&quot;李四&quot;</span>, <span class="number">19</span>, <span class="number">60</span>&#125;,</span><br><span class="line">                             &#123;<span class="string">&quot;王五&quot;</span>, <span class="number">20</span>, <span class="number">70</span>&#125;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp; i : arr) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;姓名：&quot;</span> &lt;&lt; i.name &lt;&lt; <span class="string">&quot; 年龄：&quot;</span> &lt;&lt; i.age &lt;&lt; <span class="string">&quot; 分数：&quot;</span> &lt;&lt; i.score &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="结构体指针"><a href="#结构体指针" class="headerlink" title="结构体指针"></a>结构体指针</h3><ul><li>作用：通过指针访问结构体中的成员</li></ul><ul><li>利用 <code>-&gt; </code> 可以通过结构体指针访问结构体属性</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 结构体定义</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">student</span> &#123;</span> </span><br><span class="line">    <span class="built_in">string</span> name;  <span class="comment">// 姓名</span></span><br><span class="line">    <span class="keyword">int</span> age&#123;&#125;;    <span class="comment">// 年龄</span></span><br><span class="line">    <span class="keyword">int</span> score&#123;&#125;;  <span class="comment">// 分数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">student</span> <span class="title">stu</span> =</span> &#123;<span class="string">&quot;张三&quot;</span>, <span class="number">18</span>, <span class="number">100</span>,&#125;;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">student</span> *<span class="title">p</span> =</span> &amp;stu;</span><br><span class="line"></span><br><span class="line">    p-&gt;name = <span class="string">&quot;张三&quot;</span>; <span class="comment">// 指针通过 -&gt; 操作符可以访问成员</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;姓名：&quot;</span> &lt;&lt; p-&gt;name &lt;&lt; <span class="string">&quot; 年龄：&quot;</span> &lt;&lt; p-&gt;age &lt;&lt; <span class="string">&quot; 分数：&quot;</span> &lt;&lt; p-&gt;score &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="结构体嵌套结构体"><a href="#结构体嵌套结构体" class="headerlink" title="结构体嵌套结构体"></a>结构体嵌套结构体</h3><ul><li>作用： 结构体中的成员可以包含另一个结构体，用来解决实际问题</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 学生结构体定义</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">student</span> &#123;</span></span><br><span class="line">    <span class="built_in">string</span> name;  <span class="comment">// 姓名</span></span><br><span class="line">    <span class="keyword">int</span> age&#123;&#125;;    <span class="comment">// 年龄</span></span><br><span class="line">    <span class="keyword">int</span> score&#123;&#125;;  <span class="comment">// 分数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 教师结构体定义</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">teacher</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> id&#123;&#125;;     <span class="comment">// 职工编号</span></span><br><span class="line">    <span class="built_in">string</span> name;  <span class="comment">// 教师姓名</span></span><br><span class="line">    <span class="keyword">int</span> age&#123;&#125;;    <span class="comment">// 教师年龄</span></span><br><span class="line">    student stu;  <span class="comment">// 子结构体 学生</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    teacher t1;</span><br><span class="line">    t1.id = <span class="number">10000</span>;</span><br><span class="line">    t1.name = <span class="string">&quot;老王&quot;</span>;</span><br><span class="line">    t1.age = <span class="number">40</span>;</span><br><span class="line"></span><br><span class="line">    t1.stu.name = <span class="string">&quot;张三&quot;</span>;</span><br><span class="line">    t1.stu.age = <span class="number">18</span>;</span><br><span class="line">    t1.stu.score = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;教师 职工编号： &quot;</span> &lt;&lt; t1.id &lt;&lt; <span class="string">&quot; 姓名： &quot;</span> &lt;&lt; t1.name &lt;&lt; <span class="string">&quot; 年龄： &quot;</span> &lt;&lt; t1.age &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;辅导学员 姓名： &quot;</span> &lt;&lt; t1.stu.name &lt;&lt; <span class="string">&quot; 年龄：&quot;</span> &lt;&lt; t1.stu.age &lt;&lt; <span class="string">&quot; 考试分数： &quot;</span> &lt;&lt; t1.stu.score &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="结构体做函数参数"><a href="#结构体做函数参数" class="headerlink" title="结构体做函数参数"></a>结构体做函数参数</h3><ul><li><p>作用：将结构体作为参数向函数中传递</p></li><li><p>传递方式有两种：</p><ul><li>值传递</li><li>地址传递</li></ul></li><li><p>如果不想修改主函数中的数据，用值传递，反之用地址传递</p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 学生结构体定义</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">student</span> &#123;</span></span><br><span class="line">    <span class="built_in">string</span> name;    <span class="comment">// 姓名</span></span><br><span class="line">    <span class="keyword">int</span> age&#123;&#125;;      <span class="comment">// 年龄</span></span><br><span class="line">    <span class="keyword">int</span> score&#123;&#125;;    <span class="comment">// 分数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 值传递</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printStudent</span><span class="params">(student stu)</span> </span>&#123;</span><br><span class="line">    stu.age = <span class="number">28</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;子函数中 姓名：&quot;</span> &lt;&lt; stu.name &lt;&lt; <span class="string">&quot; 年龄： &quot;</span> &lt;&lt; stu.age &lt;&lt; <span class="string">&quot; 分数：&quot;</span> &lt;&lt; stu.score &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 地址传递</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printStudent2</span><span class="params">(student *stu)</span> </span>&#123;</span><br><span class="line">    stu-&gt;age = <span class="number">28</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;子函数中 姓名：&quot;</span> &lt;&lt; stu-&gt;name &lt;&lt; <span class="string">&quot; 年龄： &quot;</span> &lt;&lt; stu-&gt;age &lt;&lt; <span class="string">&quot; 分数：&quot;</span> &lt;&lt; stu-&gt;score &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    student stu = &#123;<span class="string">&quot;张三&quot;</span>, <span class="number">18</span>, <span class="number">100</span>&#125;;</span><br><span class="line">    <span class="comment">// 值传递</span></span><br><span class="line">    printStudent(stu);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;主函数中 姓名：&quot;</span> &lt;&lt; stu.name &lt;&lt; <span class="string">&quot; 年龄： &quot;</span> &lt;&lt; stu.age &lt;&lt; <span class="string">&quot; 分数：&quot;</span> &lt;&lt; stu.score &lt;&lt; <span class="built_in">endl</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 地址传递</span></span><br><span class="line">    printStudent2(&amp;stu);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;主函数中 姓名：&quot;</span> &lt;&lt; stu.name &lt;&lt; <span class="string">&quot; 年龄： &quot;</span> &lt;&lt; stu.age &lt;&lt; <span class="string">&quot; 分数：&quot;</span> &lt;&lt; stu.score &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="结构体中使用-const"><a href="#结构体中使用-const" class="headerlink" title="结构体中使用 const"></a>结构体中使用 const</h3><ul><li>作用：用 const 来防止误操作</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 学生结构体定义</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">student</span> &#123;</span></span><br><span class="line">    <span class="built_in">string</span> name;  <span class="comment">// 姓名</span></span><br><span class="line">    <span class="keyword">int</span> age;      <span class="comment">// 年龄</span></span><br><span class="line">    <span class="keyword">int</span> score;    <span class="comment">// 分数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// const使用场景</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printStudent</span><span class="params">(<span class="keyword">const</span> student *stu)</span> </span>&#123;  <span class="comment">// 加const防止函数体中的误操作</span></span><br><span class="line">    <span class="comment">// stu-&gt;age = 100;  // 操作失败，因为加了const修饰</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;姓名：&quot;</span> &lt;&lt; stu-&gt;name &lt;&lt; <span class="string">&quot; 年龄：&quot;</span> &lt;&lt; stu-&gt;age &lt;&lt; <span class="string">&quot; 分数：&quot;</span> &lt;&lt; stu-&gt;score &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    student stu = &#123;<span class="string">&quot;张三&quot;</span>, <span class="number">18</span>, <span class="number">100</span>&#125;;</span><br><span class="line">    printStudent(&amp;stu);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">入门编程</summary>
    
    
    
    <category term="C++" scheme="https://nephrencake.github.io/categories/C/"/>
    
    
  </entry>
  
  <entry>
    <title>计算机网络-完结目录</title>
    <link href="https://nephrencake.github.io/2021/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E5%AE%8C%E7%BB%93%E7%9B%AE%E5%BD%95/"/>
    <id>https://nephrencake.github.io/2021/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E5%AE%8C%E7%BB%93%E7%9B%AE%E5%BD%95/</id>
    <published>2021-12-03T05:56:16.000Z</published>
    <updated>2022-02-10T10:42:22.684Z</updated>
    
    <content type="html"><![CDATA[<h1 id="计算机网络-完结目录"><a href="#计算机网络-完结目录" class="headerlink" title="计算机网络-完结目录"></a>计算机网络-完结目录</h1><p>推荐资源：</p><ol><li>王道配套书</li></ol><p>感觉王道小姐姐讲的并不是很好，建议多看书。</p><table><thead><tr><th align="center"><a href="/2021/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-Part1/">计算机网络-Part1——计算机网络体系结构</a></th></tr></thead><tbody><tr><td align="center"><strong><a href="/2021/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-Part2/">计算机网络-Part2——物理层</a></strong></td></tr><tr><td align="center"><strong><a href="/2021/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-Part3/">计算机网络-Part3——数据链路层</a></strong></td></tr><tr><td align="center"><strong><a href="/2021/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-Part4/">计算机网络-Part4——网络层</a></strong></td></tr><tr><td align="center"><strong><a href="/2021/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-Part5/">计算机网络-Part5——传输层</a></strong></td></tr><tr><td align="center"><strong><a href="/2021/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-Part6/">计算机网络-Part6——应用层</a></strong></td></tr></tbody></table>]]></content>
    
    
    <summary type="html">完结目录</summary>
    
    
    
    <category term="计算机网络" scheme="https://nephrencake.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
    <category term="408" scheme="https://nephrencake.github.io/tags/408/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络-Part6</title>
    <link href="https://nephrencake.github.io/2021/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-Part6/"/>
    <id>https://nephrencake.github.io/2021/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-Part6/</id>
    <published>2021-12-03T05:56:08.000Z</published>
    <updated>2022-02-10T10:45:37.162Z</updated>
    
    <content type="html"><![CDATA[<h1 id="计算机网络-Part6——应用层"><a href="#计算机网络-Part6——应用层" class="headerlink" title="计算机网络-Part6——应用层"></a>计算机网络-Part6——应用层</h1><p>[TOC]</p><p><img src="/2021/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-Part6/image-20211206204714816.png" alt="image-20211206204714816"></p><h2 id="网络应用模型"><a href="#网络应用模型" class="headerlink" title="网络应用模型"></a>网络应用模型</h2><ul><li>应用层概述<ul><li>应用层对应用程序的通信提供服务。</li></ul></li><li>应用层协议<strong>定义</strong>：<ul><li>应用进程交换的报文类型，请求 or 响应</li><li>各种报文类型的语法，如报文中的各个字段及其详细描述。</li><li>字段的语义，即包含在字段中的信息的含义。</li><li>进程何时、如何发送报文，以及对报文进行响应的规则。</li></ul></li><li>应用层的<strong>功能</strong>：<ul><li>文件传输、访问和管理</li><li>电子邮件</li><li>虚拟终端</li><li>查询服务和远程作业登录</li></ul></li><li>应用层的<strong>重要协议</strong>：<ul><li>FTP</li><li>SMTP、POP3</li><li>HTTP</li><li>DNS</li></ul></li><li>客户/服务器（Client/Server）模型<ul><li>服务器：<strong>提供计算服务</strong>的设备<ul><li>永久提供服务</li><li>永久性访问地址/域名</li></ul></li><li>客户机：<strong>请求计算服务</strong>的主机<ul><li>与服务器通信，使用服务器提供的服务</li><li>间歇性接入网络</li><li>可使用动态 IP 地址</li><li>不与其他客户机直接通信</li></ul></li><li>应用：Web，文件传输 FTP，远程登录，电子邮件</li></ul></li><li>P2P （Peer-to-Peer）模型<ul><li>不存在永远在线的服务器</li><li>每个主机既可以<strong>提供服务</strong>，也可以<strong>请求服务</strong></li><li>任意端系统/节点之间可以<strong>直接通讯</strong></li><li>节点间歇性接入网络</li><li>节点可能改变IP地址</li><li>可扩展性好</li><li>网络健壮性强</li></ul></li></ul><h2 id="DNS-系统"><a href="#DNS-系统" class="headerlink" title="DNS 系统"></a>DNS 系统</h2><ul><li>DNS 服务的作用：将域名解析成 IP 地址。</li><li>域名级别<ul><li>完整写法：<a href="http://www.cskaoyan.com.(最后一个点表示为根,根之前为顶/...%E7%BA%A7%E5%9F%9F%E5%90%8D%EF%BC%89">www.cskaoyan.com.（最后一个点表示为根，根之前为顶/...级域名）</a></li><li>顶级域名<ul><li>国家顶级域名：cn、us、uk</li><li>通用顶级域名：com、net、org、gov、int、aero、museum、travel</li><li>基础结构域名/反向域名：arpa</li></ul></li><li>二级域名<ul><li>类别域名：ac、com、edu、gov、mil、net、org</li><li>行政区域名：bj、js</li></ul></li><li>三级域名</li><li>四级域名</li><li><img src="/2021/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-Part6/image-20211206210944573.png" alt="image-20211206210944573" style="zoom:80%;"></li></ul></li><li>域名服务器<ul><li><img src="/2021/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-Part6/image-20211207090429846.png" alt="image-20211207090429846"></li></ul></li><li>域名解析过程<ul><li>本地域名服务器中设有高速缓存，能够暂存各个服务器及域名的解析 ip。</li><li><img src="/2021/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-Part6/image-20211207091244405.png" alt="image-20211207091244405"></li></ul></li></ul><h2 id="文件传输协议-FTP"><a href="#文件传输协议-FTP" class="headerlink" title="文件传输协议 FTP"></a>文件传输协议 FTP</h2><ul><li>文件传送协议 FTP（File Transfer Protocol）<ul><li>提供不同种类主机系统（硬、软件体系等都可以不同）之间的文件传输能力。</li><li>简单文件传送协议 TFTP（Trivial File Transfer Protocol）</li></ul></li><li>FTP 是基于客户/服务器（C/S）的协议<ul><li>依照 FTP 协议提供服务，进行文件传送的计算机就是 <strong>FTP 服务器</strong>。</li><li>连接 FTP 服务器，遵循 FTP 协议与服务器传送文件的电脑就是 <strong>FTP 客户端</strong>。</li></ul></li><li>工作原理<ul><li>FTP 使用 TCP 实现可靠传输。<ul><li><strong>控制</strong>连接始终保持（会话期间打开）</li><li><strong>数据</strong>连接不会始终保持（文件传输期间打开）</li></ul></li><li>是否使用 TCP 20 端口建立数据连接与传输模式有关<ul><li>主动方式使用 TCP 20 端口 （含端口的 Port 命令）</li><li>被动方式由服务器和客户端自行协商决定，服务器的端口 &gt;1024（Pasvt 命令）</li></ul></li><li><img src="/2021/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-Part6/image-20211207092821036.png" alt="image-20211207092821036" style="zoom:80%;"></li></ul></li><li>传输模式：<ul><li>文本模式：ASCII 模式，以文本序列传输数据；</li><li>二进制模式：Binary 模式，以二进制序列传输数据。</li></ul></li></ul><h2 id="电子邮件"><a href="#电子邮件" class="headerlink" title="电子邮件"></a>电子邮件</h2><p><img src="/2021/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-Part6/image-20211207124939809.png" alt="image-20211207124939809"></p><ul><li><img src="/2021/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-Part6/image-20211207094450303.png" alt="image-20211207094450303"><ul><li>用户代理（Foxmail、Outlook）：1. 撰写；2. 显示；3. 处理；4. 通信</li><li>邮件服务器：1. 发送&amp;接收邮件；2. 向发件人报告邮件传送结果</li></ul></li><li><strong>SMTP</strong>（简单邮件传送协议）<ul><li>SMTP 规定了在两个相互通信的 <strong>SMTP 进程</strong>之间应如何交换信息。<ul><li>负责发送邮件的 SMTP 进程就是 <strong>SMTP 客户</strong>，负责接收邮件的进程就是 <strong>SMTP 服务器</strong>。</li></ul></li><li>TCP 连接、端口号 25、C/S</li><li>SMTP 规定了 14 条命令（几个字母）和 21 种应答信息（三位数字代码+简单文字说明）。（考研不会考察具体细节）<ul><li><img src="/2021/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-Part6/image-20211207122248575.png" alt="image-20211207122248575"></li></ul></li><li>SMTP 的缺点：<ul><li>SMTP 不能传送可执行文件或者其他二进制对象。</li><li>SMTP 仅限于传送 7 位 ASCII 码，不能传送其他非英语国家的文字。</li><li>SMTP 服务器会拒绝超过一定长度的邮件。</li></ul></li></ul></li><li><strong>MIME</strong>（通用因特网邮件扩充）<ul><li>是 SMTP、POP3 的扩充。使传输内容支持声音、图像、视频、多国家语言。</li><li><img src="/2021/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-Part6/image-20211207124117062.png" alt="image-20211207124117062"></li></ul></li><li><strong>POP3</strong>（邮局协议）<ul><li>只存在于查阅邮件的环节</li><li>TCP 连接、端口号 100、C/S</li><li>POP3 对于用户查阅邮件之后的操作<ul><li>下载并保留（在服务器）</li><li>下载并删除</li></ul></li></ul></li><li><strong>IMAP</strong>（网际报文存取协议）<ul><li>IMAP 协议比 POP 协议复杂。</li><li>IMAP 协议与 POP 协议一样处于查阅邮件的部分。</li><li>IMAP 允许只读取邮件中的某一个部分（先看标题正文，有 WiFi 的时候再下载附件）。</li></ul></li><li><strong>基于万维网的电子邮件</strong><ul><li>用户与服务器的交互都转为 HTTP，服务器之间还是 SMTP。</li><li>特点：更方便</li><li><img src="/2021/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-Part6/image-20211207125727764.png" alt="image-20211207125727764"></li></ul></li></ul><h2 id="万维网和-HTTP-协议"><a href="#万维网和-HTTP-协议" class="headerlink" title="万维网和 HTTP 协议"></a>万维网和 HTTP 协议</h2><ul><li><p>万维网概述</p><ul><li>万维网WWW（World Wide Web）是一个大规模的、联机式的信息储藏所/资料空间，是无数个网络站点和网页的集合。</li><li>统一资源定位符 URL 唯一标识资源（文字、视频、音频…）</li><li>URL 一般形式：&lt;协议&gt;://&lt;主机&gt;:&lt;端口&gt;/&lt;路径&gt;</li><li>万维网以客户/服务器方式工作，用户使用的浏览器就是万维网客户程序，万维网文档所驻留的主机运行服务器程序。</li></ul></li><li><p>HTTP 具体过程：</p><ol><li><p>浏览器分析 URL</p></li><li><p>浏览器向 DNS 请求解析 IP 地址</p></li><li><p>DNS 解析出 IP 地址</p></li><li><p>浏览器与服务器建立 TCP 连接</p></li><li><p>浏览器发出取文件命令</p></li><li><p>服务器响应</p></li><li><p>释放 TCP 连接</p></li><li><p>浏览器显示</p></li></ol><ul><li><img src="/2021/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-Part6/image-20211207130752214.png" alt="image-20211207130752214" style="zoom: 50%;"></li></ul></li><li><p>HTTP 协议的特点：</p><ul><li>HTTP 协议是<strong>无状态</strong>的。</li><li>Cookie 是存储在用户主机中的<strong>文本文件</strong>。</li><li>HTTP 采用 <strong>TCP</strong> 作为运输层协议，但 HTTP 协议本身是<strong>无连接</strong>的（通信双方在交换 HTTP 报文之前不需要先建立 HTTP 连接）。</li><li><img src="/2021/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-Part6/image-20211207131011431.png" alt="image-20211207131011431" style="zoom:80%;"></li><li><img src="/2021/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-Part6/image-20211207131105541.png" alt="image-20211207131105541"></li></ul></li><li><p>超文本传输协议 HTTP 报文结构</p><ul><li>HTTP 请求/响应报文是<strong>面向文本</strong>的，因此在报文中的每一个字段都是一些 ASCII 码串。</li><li><img src="/2021/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-Part6/image-20211207140137732.png" alt="image-20211207140137732"></li></ul></li></ul>]]></content>
    
    
    <summary type="html">应用层</summary>
    
    
    
    <category term="计算机网络" scheme="https://nephrencake.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
  </entry>
  
  <entry>
    <title>计算机网络-Part5</title>
    <link href="https://nephrencake.github.io/2021/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-Part5/"/>
    <id>https://nephrencake.github.io/2021/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-Part5/</id>
    <published>2021-12-03T05:56:04.000Z</published>
    <updated>2022-02-10T10:45:34.365Z</updated>
    
    <content type="html"><![CDATA[<h1 id="计算机网络-Part5——传输层"><a href="#计算机网络-Part5——传输层" class="headerlink" title="计算机网络-Part5——传输层"></a>计算机网络-Part5——传输层</h1><p>[TOC]</p><h2 id="传输层概述"><a href="#传输层概述" class="headerlink" title="传输层概述"></a>传输层概述</h2><ul><li>只有主机才有的层次</li><li>传输层的功能：<ul><li>传输层提供进程和进程之间的逻辑通信</li><li>复用和分用<ul><li>复用：应用层所有的应用进程都可以通过传输层再传输到网络层。</li><li>分用：传输层从网络层收到数据后交付指明的应用进程。</li></ul></li><li>传输层对收到的报文进行差错检测</li><li>传输层的两种协议</li></ul></li><li>传输层的两个协议：<ul><li>面向连接的传输控制协议 TCP<ul><li>传送数据之前必须建立连接，数据传送结束后要释放连接。</li><li>不提供广播或多播服务。</li><li>由于 TCP 要提供可靠的面向连接的传输服务，因此不可避免增加了许多开销：确认、流量控制、计时器及连接管理等。</li><li>特点：<strong>可靠，面向连接，时延大，适用于大文件</strong>。</li></ul></li><li>无连接的用户数据报协议 UDP<ul><li>传送数据之前不需要建立连接，收到 UDP 报文后也不需要给出任何确认。</li><li>特点：<strong>不可靠，无连接，时延小，适用于小文件</strong>。</li></ul></li></ul></li><li>传输层的寻址与端口<ul><li>端口号<ul><li>端口（逻辑端口/软件端口，区别于硬件端口）是传输层的SAP，标识主机中的应用进程。</li><li>端口号只有本地意义，在因特网中不同计算机的相同端口是没有联系的。</li><li>端口号长度为 16bit，能表示 65536 个不同的端口号。</li><li><img src="/2021/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-Part5/image-20211220143918200.png" alt="image-20211220143918200"></li></ul></li><li>寻址：<ul><li><img src="/2021/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-Part5/image-20211220144448803.png" alt="image-20211220144448803"></li><li>在网络中采用发送方和接收方的套接字组合来识别端点，<strong>套接字</strong>唯一标识了网络中的一个主机和它上面的一个进程。</li><li>套接字 Socket =（主机地址，端口号）</li></ul></li></ul></li></ul><h2 id="UDP-协议"><a href="#UDP-协议" class="headerlink" title="UDP 协议"></a>UDP 协议</h2><ul><li>UDP 只在 IP 数据报服务之上增加了很少功能，即复用分用和差错检测功能。</li><li>UDP的主要特点：<ul><li><strong>无连接</strong>，减少开销和发送数据之前的时延</li><li><strong>不保证可靠交付</strong>，使用最大努力交付</li><li><strong>面向报文</strong>，适合一次性传输少量数据的网络应用</li><li>无拥塞控制，适合很多实时应用</li><li>首部开销小，大小为 8B，TCP 是 20B</li></ul></li><li>应用层给 UDP 多长的报文，UDP 就照样发送，即一次发一个完整报文。<ul><li>使用 UDP 需要选择合适的报文长度。<ul><li>过长会被网络层分片（链路层有 MTU 要求）；</li><li>过短会使 IP 首部相对过大，降低网络层效率（希望尽可能减少负压信息、尽可能多的数据信息）。</li></ul></li><li><img src="/2021/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-Part5/image-20211220144949185.png" alt="image-20211220144949185" style="zoom:80%;"></li></ul></li><li>UDP 首部格式<ul><li>分用时，找不到对应的目的端口号，就丢弃报文，并给发送方发送ICMP“端口不可达”差错报告报文。</li><li><img src="/2021/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-Part5/image-20211220150455794.png" alt="image-20211220150455794" style="zoom:80%;"></li></ul></li><li>UDP 校验<ul><li><img src="/2021/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-Part5/image-20211220150544166.png" alt="image-20211220150544166" style="zoom:80%;"></li><li>使用伪首部检验 UDP 用户数据报<ul><li>伪首部只有在计算检验和时才出现，不向下传送也不向上递交。</li><li>17：<strong>封装 UDP 报文的 IP 数据报首部协议字段是 17</strong>。</li><li>UDP 长度：UDP 首部 8B+ 数据部分长度（不包括伪首部）。</li></ul></li><li>在发送端：<ul><li>填上伪首部</li><li>全 0 填充检验和字段</li><li>全 0 填充数据部分（UDP 数据报要看成许多 4B 的字串接起来）</li><li>伪首部+首部+数据部分采用二进制反码求和</li><li>把和求反码填入检验和字段</li><li>去掉伪首部，发送</li></ul></li><li>在接收端：<ul><li>填上伪首部</li><li>伪首部+首部+数据部分采用二进制反码求和</li><li>结果全为 1 则无差错，否则丢弃数据报/交给应用层附上出差错的警告。</li></ul></li><li><img src="/2021/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-Part5/image-20211220150955461.png" alt="image-20211220150955461" style="zoom:80%;"></li></ul></li></ul><h2 id="TCP-协议"><a href="#TCP-协议" class="headerlink" title="TCP 协议"></a>TCP 协议</h2><h3 id="TCP-协议特点和报文段格式"><a href="#TCP-协议特点和报文段格式" class="headerlink" title="TCP 协议特点和报文段格式"></a>TCP 协议特点和报文段格式</h3><ul><li>特点：<ul><li><strong>面向连接</strong>（虚连接）</li><li><strong>点对点</strong>：每一条 TCP 连接只能有两个端点</li><li><strong>可靠有序，不丢不重</strong>：TCP 提供可靠交付的服务，无差错、不丢失、不重复、按序到达</li><li>提供<strong>全双工通信</strong>：<ul><li>发送缓存：准备发送的数据 &amp; 已发送但尚未收到确认的数据</li><li>接收缓存：按序到达但尚未被接受应用程序读取的数据 &amp; 不按序到达的数据</li></ul></li><li><strong>面向字节流</strong>：把应用程序交下来的数据看成仅仅是一连串的<strong>无结构的字节流</strong></li></ul></li><li><strong>TCP 报文段首部格式</strong>（重点）<ul><li><strong>序号</strong>：在一个 TCP 连接中传送的字节流中的每一个<strong>字节</strong>都按顺序编号，本字段表示本报文段所发送数据的<strong>第一个字节的序号</strong>。</li><li><strong>确认号</strong>：<strong>期望</strong>收到对方下一个报文段的第一个数据字节的序号。若确认号为 N， 则证明到序号 N-1 为止的所有数据都已正确收到。</li><li><strong>数据偏移</strong>（<strong>首部长度</strong>）：TCP 报文段的数据起始处距离 TCP 报文段的起始处有多远，以 4B 位单位，即 1 个数值是 4B。</li><li>控制位：<ul><li><strong>紧急位 URG</strong>：URG=1 时，标明此报文段中有紧急数据，是高优先级的数据，应尽快传送，不用在缓存里排队，配合紧急指针字段使用。</li><li><strong>确认位 ACK</strong>：ACK=1 时，确认号有效，在连接建立后所有传送的报文段都必须把 ACK 置为 1。</li><li>推送位 PSH：PSH=1时，接收方尽快交付接收应用进程，不再等到缓存填满再向上交付。</li><li>复位 RST：RST=1时，表明 TCP 连接中出现严重差错，必须释放连接，然后再重新建立传输链接。</li><li><strong>同步位 SYN</strong>：SYN=1时，表明是一个连接请求/连接接受报文。</li><li><strong>终止位 FIN</strong>：FIN=1时，表明此报文段发送方数据已发完，要求释放连接。</li></ul></li><li><strong>窗口：</strong>指的是发送本报文段的一方的接收窗口大小，即现在允许对方发送的数据量。</li><li><strong>检验和：</strong>检验首部+数据，检验时要加上 12B 伪首部，第四个字段为 6（UDP 是 17）。</li><li><strong>紧急指针：</strong>URG=1 时才有意义，指出本报文段中紧急数据的字节数。</li><li><strong>选项：</strong>最大报文段长度 MSS、窗口扩大、时间戳、选择确认…</li><li><img src="/2021/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-Part5/image-20211220165457244.png" alt="image-20211220165457244" style="zoom:80%;"></li></ul></li></ul><h3 id="TCP-连接管理"><a href="#TCP-连接管理" class="headerlink" title="TCP 连接管理"></a>TCP 连接管理</h3><ul><li>TCP 连接传输三个阶段：连接建立、数据传送、连接释放</li><li>TCP 连接的建立采用<strong>客户服务器方式</strong>，主动发起连接建立的应用进程叫做客户，而被动等待连接建立的应用进程叫服务器。</li><li>过程：（三次握手）<ul><li>客户端发送<strong>连接请求报文段</strong>，无应用层数据。</li><li>服务器端为该 TCP 连接<strong>分配缓存和变量</strong>，并向客户端返回<strong>确认报文段</strong>，允许连接，无应用层数据。</li><li>客户端为该TCP连接<strong>分配缓存和变量</strong>，并向服务器端返回确认的确认，<strong>可以携带数据</strong>。</li><li><img src="/2021/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-Part5/image-20211220172255417.png" alt="image-20211220172255417"></li></ul></li><li>SYN 洪泛攻击：<ul><li>SYN 洪泛攻击，发生在 OSI 第四层，利用 TCP 协议的特性（三次握手）。</li><li>攻击者发送 TCP SYN，SYN 是 TCP 三次握手中的<strong>第一个数据包</strong>，而当服务器返回 ACK 后，该攻击者不对其进行再确认，导致这个 TCP 连接就处于挂起状态，即所谓的半连接状态。</li><li>同时服务器收不到再确认，还会重复发送 ACK 给攻击者，进一步浪费服务器的资源。</li><li>攻击者就对服务器发送非常大量的这种 TCP 连接，由于每一个都没法完成三次握手，所以服务器上，这些TCP连接会因为挂起状态而消耗CPU和内存，最后服务器可能死机，就无法为正常用户提供服务了。</li></ul></li><li>TCP 的连接释放：（四次挥手）<ul><li>客户端发送<strong>连接释放报文段</strong>，停止发送数据，主动关闭 TCP 连接。</li><li>服务器端回送一个确认报文段，客户到服务器这个方向的连接就释放了——半关闭状态。</li><li>服务器端发完数据，就发出连接释放报文段，主动关闭 TCP 连接。</li><li>客户端回送一个确认报文段，再等到时间等待计时器设置的 2MSL（最长报文段寿命）后，连接彻底关闭。</li><li><img src="/2021/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-Part5/image-20211220181742363.png" alt="image-20211220181742363"></li></ul></li></ul><h3 id="TCP-可靠传输（非重点）"><a href="#TCP-可靠传输（非重点）" class="headerlink" title="TCP 可靠传输（非重点）"></a>TCP 可靠传输（非重点）</h3><ul><li>网络层，提供尽最大努力交付、不可靠传输；传输层，使用 TCP 实现可靠传输。<ul><li>可靠：保证接收方进程从缓存区读出的字节流与发送方发出的字节流是完全一样的。</li></ul></li><li>TCP 实现可靠传输的机制<ul><li>校验（与UDP校验一样，<strong>增加伪首部</strong>）</li><li>序号（<strong>序号字段</strong>指的是一个报文段第一个字节的序号，保证传输有序）</li><li>确认（TCP 默认使用累计确认）</li><li>重传（发送方在<strong>重传时间</strong>内<strong>没有收到确认</strong>就要重传已发送的报文段）<ul><li>超时：TCP 采用自适应算法，动态改变重传时间 RTTs（加权平均往返时间）</li><li>冗余 ACK（冗余确认）：每当比期望序号大的失序报文段到达时，发送一个冗余 ACK，指明下一个期待字节的序号。<ul><li>例如，发送方收到 3 个对于报文段 1 的冗余 ACK，则认为 2 报文段丢失并只重传 2 号报文段（<strong>快速重传</strong>）</li></ul></li></ul></li></ul></li></ul><h3 id="TCP-流量控制（重点）"><a href="#TCP-流量控制（重点）" class="headerlink" title="TCP 流量控制（重点）"></a>TCP 流量控制（重点）</h3><ul><li>流量控制：让<strong>发送方慢点</strong>，要让接收方来得及接收。<ul><li>TCP 利用<strong>滑动窗口</strong>机制实现流量控制。</li></ul></li><li>在通信过程中，接收方根据自己<strong>接收缓存的大小</strong>，设置确认报文段的窗口字段，动态通知并调整发送方的发送窗口大小。<ul><li>发送方的发送窗口 = Min { 接收窗口 rwnd，拥塞窗口 cwnd }。</li></ul></li><li>TCP 为每一个连接设有一个持续计时器，只要 TCP 连接的一方收到对方的零窗口通知，就启动持续计时器。<ul><li>若持续计时器设置的时间到期，就发送一个零窗口<strong>探测报文段</strong>。接收方收到探测报文段时给出现在的窗口值。</li><li>若窗口仍然是 0，那么发送方就重新设置持续计时器。</li></ul></li><li><img src="/2021/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-Part5/image-20211220190918520.png" alt="image-20211220190918520"></li></ul><h3 id="TCP-拥塞控制（重点）"><a href="#TCP-拥塞控制（重点）" class="headerlink" title="TCP 拥塞控制（重点）"></a>TCP 拥塞控制（重点）</h3><ul><li>出现拥塞的条件：<ul><li>对资源需求的总和 &gt; 可用资源</li><li>网络中有许多资源同时呈现供应不足 -&gt; 网络性能变坏 -&gt; 网络吞吐量将随输入负荷增大而下降</li></ul></li><li>拥塞控制：<ul><li>防止过多的数据注入到网络中。</li></ul></li><li>拥塞控制与流量控制的区别：<ul><li>流量控制是点对点的控制，拥塞控制是全局性问题</li><li>流量控制是发送过快，拥塞控制是迟迟接收不到</li></ul></li><li>假定：<ul><li>数据单方向传送，而另一个方向只传送确认</li><li>接收方总是有足够大的缓存空间，因而发送窗口大小取决于拥塞程度</li><li>发送窗口 = Min { 接收窗口 rwnd，拥塞窗口 cwnd }<ul><li>接收窗口：<strong>接收方</strong>根据接受缓存设置的值，并告知给发送方，反映接收方容量。</li><li>拥塞窗口：<strong>发送方</strong>根据自己估算的网络拥塞程度而设置的窗口值，反映网络当前容量。</li></ul></li><li>一个<strong>传输轮次</strong>：一个往返时延<strong>RTT</strong>。发送并收到确认。</li></ul></li><li>拥塞控制两种算法<ul><li><strong>慢开始和拥塞避免</strong><ul><li>一收到确认，就提高拥塞窗口数量</li><li>新的门限值 = 网络拥塞时的拥塞窗口 ÷ 2</li><li><img src="/2021/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-Part5/image-20211220194719790.png" alt="image-20211220194719790"></li></ul></li><li><strong>快重传和快恢复</strong><ul><li><strong>收到 3 个重复确认</strong>时，不重新开始，而是降为当前窗口的一半。</li><li><img src="/2021/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-Part5/image-20211220194814988.png" alt="image-20211220194814988"></li></ul></li></ul></li></ul>]]></content>
    
    
    <summary type="html">传输层</summary>
    
    
    
    <category term="计算机网络" scheme="https://nephrencake.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
  </entry>
  
  <entry>
    <title>计算机网络-Part4</title>
    <link href="https://nephrencake.github.io/2021/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-Part4/"/>
    <id>https://nephrencake.github.io/2021/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-Part4/</id>
    <published>2021-12-03T05:56:00.000Z</published>
    <updated>2022-02-10T10:45:31.611Z</updated>
    
    <content type="html"><![CDATA[<h1 id="计算机网络-Part4——网络层"><a href="#计算机网络-Part4——网络层" class="headerlink" title="计算机网络-Part4——网络层"></a>计算机网络-Part4——网络层</h1><p>[TOC]</p><h2 id="网络层功能概述"><a href="#网络层功能概述" class="headerlink" title="网络层功能概述"></a>网络层功能概述</h2><h3 id="网络层功能"><a href="#网络层功能" class="headerlink" title="网络层功能"></a>网络层功能</h3><p><img src="/2021/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-Part4/image-20211221134208504.png" alt="image-20211221134208504"></p><ul><li>主要任务是把<strong>分组</strong>从源端传到目的端，为分组交换网上的不同主机提供通信服务。<ul><li>网络层传输单位是<strong>数据报</strong>。</li></ul></li><li>功能：<ul><li>路由选择与分组转发（寻找最佳路径）</li><li>异构网络互联</li><li>拥塞控制<ul><li>开环控制（静态）</li><li>闭环控制（动态）</li></ul></li></ul></li></ul><h3 id="IP-数据报格式"><a href="#IP-数据报格式" class="headerlink" title="IP 数据报格式"></a>IP 数据报格式</h3><ul><li>TCP/IP 协议栈<ul><li><img src="/2021/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-Part4/image-20211221135135704.png" alt="image-20211221135135704" style="zoom: 67%;"></li></ul></li><li>IP 数据报格式<ul><li>版本：IPv4 / IPv6</li><li>首部长度：单位是 <strong>4B</strong>，最小为 5.</li><li>区分服务：指示期望获得哪种类型的服务。</li><li>总长度：首部+数据，单位是<strong>1B</strong>。2^16^-1=65525B</li><li>生存时间（TTL）：IP 分组的保质期。经过一个路由器 -1，变成 0 则丢弃。</li><li>协议：数据部分的协议。TCP=6，UDP=17。</li><li>检验首部和：只检验首部</li><li>源地址和目的地址：32 位。</li><li>可选字段：0~40B，用来支持排错、测量以及安全等措施。</li><li>填充：全 0，把首部补成 4B 的整数倍。</li><li><img src="/2021/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-Part4/image-20211221140112405.png" alt="image-20211221140112405"></li></ul></li></ul><h3 id="IP-数据报分片"><a href="#IP-数据报分片" class="headerlink" title="IP 数据报分片"></a>IP 数据报分片</h3><ul><li>最大传送单元 MTU<ul><li>链路层数据帧可封装数据的上限，超过则在 IP 分组中进行分片，否则无法往下传递。</li><li>以太网的 MTU 是 1500 字节。</li><li><img src="/2021/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-Part4/image-20211221141348483.png" alt="image-20211221141348483" style="zoom:80%;"></li></ul></li><li>IP 数据报格式<ul><li>标识：同一数据报的分片使用同一标识。</li><li>标志：只有2位有意义<ul><li>中间位DF（Don’t Fragment）：<ul><li>DF=1，禁止分片</li><li>DF=0，允许分片</li></ul></li><li>最低位MF （More Fragment） ：<ul><li>MF=1，后面“还有分片”</li><li>MF=0，代表最后一片/没分片</li></ul></li></ul></li><li>片偏移：指出较长分组分片后，某片在原分组中的相对位置。以 <strong>8B</strong> 为单位（所以片偏移的长度是 13bit）。<ul><li>除了最后一个分片，每个分片长度一定是 <strong>8B</strong> 的整数倍。</li></ul></li><li><img src="/2021/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-Part4/image-20211221140112405.png" alt="image-20211221140112405" style="zoom: 67%;"></li></ul></li><li>IP 数据报分片例题<ul><li><img src="/2021/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-Part4/image-20211221142919264.png" alt="image-20211221142919264"></li></ul></li><li>注意单位<ul><li>总长度单位是 1B</li><li>片偏移单位是 8B</li><li>首部长度单位是 4B</li><li>口诀：一种八片首饰（1总8片首4）</li></ul></li></ul><h2 id="IPv4（重要）"><a href="#IPv4（重要）" class="headerlink" title="IPv4（重要）"></a>IPv4（重要）</h2><h3 id="IPv4-地址"><a href="#IPv4-地址" class="headerlink" title="IPv4 地址"></a>IPv4 地址</h3><ul><li><p>IP 编址的历史阶段</p><ul><li>分类的 IP 地址</li><li>子网的划分</li><li>构成超网（无分类编址方案）</li></ul></li><li><p>IP地址：全世界唯一的 <strong>32位/4字节</strong> 标识符，标识路由器主机的接口。</p><ul><li>IP地址::={&lt;网络号&gt;,&lt;主机号&gt;}</li><li>点分十进制</li></ul></li><li><p>互联网中的 IP 地址</p><ul><li>同一个网络中，网络号相同</li><li><img src="/2021/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-Part4/image-20211221144310762.png" alt="image-20211221144310762" style="zoom:80%;"></li></ul></li><li><p>IP 地址分类</p><ul><li>主要熟悉 A、B、C 类</li><li><img src="/2021/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-Part4/image-20211221144405995.png" alt="image-20211221144405995"></li><li><img src="/2021/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-Part4/image-20211221150228337.png" alt="image-20211221150228337"></li></ul></li><li><p>特殊 IP 地址</p><ul><li><img src="/2021/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-Part4/image-20211221145029209.png" alt="image-20211221145029209"></li></ul></li><li><p>私有 IP 地址</p><ul><li>路由器对目的地址是私有IP地址的数据报一律不进行转发。</li><li><img src="/2021/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-Part4/image-20211221145144605.png" alt="image-20211221145144605"></li></ul></li></ul><h3 id="网络地址转换-NAT"><a href="#网络地址转换-NAT" class="headerlink" title="网络地址转换 NAT"></a>网络地址转换 NAT</h3><ul><li>网络地址转换 NAT（Network Address Translation）：<ul><li>在<strong>专用网</strong>连接到<strong>因特网</strong>的路由器上安装 NAT 软件（安装了 NAT 软件的路由器叫 NAT 路由器）</li><li>它至少有一个有效的<strong>外部全球 IP 地址</strong>。</li></ul></li><li><img src="/2021/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-Part4/image-20211221151054767.png" alt="image-20211221151054767"></li></ul><h3 id="子网划分和子网掩码"><a href="#子网划分和子网掩码" class="headerlink" title="子网划分和子网掩码"></a>子网划分和子网掩码</h3><ul><li>针对问题：（分类的 IP 地址）<ul><li>IP 地址空间的利用率有时很低。</li><li>两级 IP 地址不够灵活。</li></ul></li><li>子网划分<ul><li>子网号能否全 0 全 1 要看情况<ul><li>最初不可以</li><li>后续 CIDR 广泛应用就可以了</li></ul></li><li>主机号不能全 0 全 1（0：本机；1：广播）</li><li>某单位划分子网后，对外仍<strong>表现为一个网络</strong>，即本单位外的网络看不见本单位内子网的划分。</li><li><img src="/2021/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-Part4/image-20211221151749123.png" alt="image-20211221151749123"></li><li><img src="/2021/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-Part4/image-20211221154628241.png" alt="image-20211221154628241" style="zoom:80%;"></li></ul></li><li>子网掩码<ul><li><img src="/2021/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-Part4/image-20211221154854041.png" alt="image-20211221154854041" style="zoom:80%;"></li><li>熟记常用的二进制转换，会提高效率<ul><li><img src="/2021/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-Part4/image-20211221155236311.png" alt="image-20211221155236311" style="zoom: 67%;"></li></ul></li></ul></li><li>路由表中：<ul><li>目的网络地址</li><li>目的网络子网掩码</li><li>下一跳地址</li></ul></li><li>路由器转发分组的算法：<ol><li>提取目的 IP 地址</li><li>是否直接交付（目的地址和子网掩码相与，查看是否有对应的子网，否则为间接交付给下一个路由）</li><li>特定主机路由（路由表中特殊指定的 IP 地址）</li><li>检测路由表中有无路径（和路由表中所有的子网掩码相与，类似于第二条？）</li><li>默认路由 0.0.0.0</li><li>丢弃，报告转发分组出错</li></ol></li></ul><h3 id="无分类编址-CIDR（常考）"><a href="#无分类编址-CIDR（常考）" class="headerlink" title="无分类编址 CIDR（常考）"></a>无分类编址 CIDR（常考）</h3><ul><li>针对问题：<ul><li>B 类地址很快将分配完毕</li><li>路由表中的项目急剧增长</li></ul></li><li><strong>无分类域间路由选择 CIDR（Classless Inter-Domain Routing）</strong>：<ul><li>消除了传统的 A、B、C 类地址以及划分子网的概念。<ul><li>将网络号和子网号合并成了网络前缀</li><li>CIDR 记法：IP 地址后加上“/”，并写上网络前缀的位数。</li><li><img src="/2021/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-Part4/image-20211221161620670.png" alt="image-20211221161620670" style="zoom: 67%;"></li></ul></li><li>融合子网地址与子网掩码，方便子网划分。<ul><li>CIDR把<strong>网络前缀都相同</strong>的连续的IP地址组成一个“CIDR 地址块”。</li><li><img src="/2021/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-Part4/image-20211221161800913.png" alt="image-20211221161800913" style="zoom:67%;"></li></ul></li></ul></li><li>构成超网（路由聚合）<ul><li>构成超网：将多个子网聚合成一个较大的子网。</li><li>方法：将网络前缀缩短（所有网络地址取交集）。</li><li>划分子网是少 -&gt; 多 </li><li>构成超网是多 -&gt; 少</li></ul></li><li>最长前缀匹配<ul><li>使用 CIDR 时，查找路由表可能得到几个匹配结果（<strong>跟网络掩码按位相与</strong>），应选择具有最长网络前缀的路由。</li><li><strong>前缀越长，地址块越小，路由越具体</strong>。</li></ul></li></ul><h3 id="ARP-协议"><a href="#ARP-协议" class="headerlink" title="ARP 协议"></a>ARP 协议</h3><ul><li><p>ARP 高速缓存：IP 地址与 MAC 地址的映射</p></li><li><p><strong>发送数据的过程</strong></p><ul><li><img src="/2021/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-Part4/image-20211223135416993.png" alt="image-20211223135416993"></li><li>网关具备 MAC 地址，但交换机不具备。</li><li>网关将解封装到网络层<ul><li>在不进行 NAT 的情况下，将更换数据的源 MAC 和目标 MAC。</li><li>在进行 NAT 的情况下，还将更换数据的源 IP。</li></ul></li><li>主机与主机、主机与网关、网关与网关之间，通过带 IP 的广播，请求目标设备带 IP-MAC 映射的响应，以获得数据链路层所需要的封装信息（目标的物理 MAC 地址）。</li></ul></li><li><p><strong>ARP（Address Resolution Protocol）协议</strong></p></li><li><p>针对问题：在实际网络的链路上传送数据帧时，最终必须使用 MAC 地址。</p></li><li><p>ARP 协议：完成主机或路由器 IP 地址到 MAC 地址的映射。（解决下一跳走哪的问题）</p></li><li><p>使用过程：</p><ul><li><strong>检查 ARP 高速缓存</strong>，有对应表项则写入 MAC 帧。<ul><li>没有则用目的 MAC 地址为 FF-FF-FF-FF-FF-FF 的帧封装并<strong>广播 ARP 请求分组</strong>，同一局域网中所有主机都能收到该请求。</li><li>目的主机收到请求后就会向源主机<strong>单播 ARP 响应分组</strong>，源主机收到后将此映射<strong>写入 ARP 缓存</strong>（10-20min 更新一次）。</li></ul></li></ul></li><li><p>ARP 协议 4 种典型情况：</p><ul><li><p>主机 A 发给<strong>本网络</strong>上的主机 B：用 ARP 找到主机B的硬件地址；</p></li><li><p>主机 A 发给<strong>另一网络</strong>上的主机 B：用 ARP 找到本网络上一个路由器（网关）的硬件地址；</p></li><li><p>路由器发给<strong>本网络</strong>的主机 A：用 ARP 找到主机 A 的硬件地址；</p></li><li><p>路由器发给<strong>另一网络</strong>的主机 B：用 ARP 找到本网络上的一个路由器的硬件地址。</p></li></ul></li><li><p>ARP 协议自动进行。</p></li></ul><h3 id="DHCP-协议"><a href="#DHCP-协议" class="headerlink" title="DHCP 协议"></a>DHCP 协议</h3><ul><li>获得 IP 地址<ul><li>静态配置</li><li>动态配置</li></ul></li><li>DHCP（Dynamic Host Configuration Protocol）协议<ul><li>动态主机配置协议 DHCP 是<strong>应用层协议</strong>，使用<strong>客户/服务器</strong>方式，客户端和服务端通过<strong>广播</strong>方式进行交互，基于 <strong>UDP</strong>。</li><li>DHCP 功能<ul><li>提供<strong>即插即用</strong>联网的机制；</li><li>主机可以从服务器动态获取 IP 地址、子网掩码、默认网关、DNS 服务器名称与 IP 地址；</li><li>允许<strong>地址重用</strong>（IP 地址池）；</li><li>支持<strong>移动用户加入网络</strong>；</li><li>支持<strong>在用地址续租</strong>（IP 地址租用期）。</li></ul></li><li>过程<ul><li>主机广播 DHCP <strong>发现</strong>报文（试图找到网络中的服务器，服务器获得一个IP地址）</li><li>DHCP 服务器广播 DHCP <strong>提供</strong>报文（服务器拟分配给主机一个 IP 地址及相关配置）</li><li>主机广播 DHCP <strong>请求</strong>报文（主机向服务器请求提供 IP 地址）</li><li>DHCP 服务器广播 DHCP <strong>确认</strong>报文（正式将 IP 地址分配给主机）</li></ul></li></ul></li></ul><h3 id="ICMP-协议"><a href="#ICMP-协议" class="headerlink" title="ICMP 协议"></a>ICMP 协议</h3><ul><li>网际控制报文协议 ICMP（Internet Control Message Protocol）是<strong>网络层协议</strong>。<ul><li>差错（或异常）报告：ICMP 查错报文</li><li>网络探询：ICMP 询问报文</li></ul></li><li>ICMP 差错报告报文<ul><li><strong>终点不可达</strong>：当路由器或主机<strong>不能交付数据报时</strong>就向源点发送终点不可达报文。</li><li><del><strong>源点抑制</strong>：当路由器或主机由于<strong>拥塞而丢弃数据报时</strong>，就向源点发送源点抑制报文，使源点知道应当把数据报的发送速率放慢。（不再使用）</del></li><li><strong>时间超过</strong>：<ul><li>当路由器<strong>收到生存时间 TTL=0 的数据报时</strong>，除丢弃该数据报外，还要向源点发送时间超过报文。</li><li>当终点在预先规定的时间内<strong>不能收到一个数据报的全部数据报片时</strong>，就把已收到的数据报片都丢弃，并向源点发送时间超过报文。</li></ul></li><li><strong>参数问题</strong>：当路由器或目的主机收到的<strong>数据报的首部中有的字段的值不正确时</strong>，就丢弃该数据报，并向源点发送参数问题报文。</li><li><strong>改变路由（重定向）</strong>：<strong>路由器把改变路由报文发送给主机</strong>，让主机知道下次应将数据报发送给另外的路由器（可通过更好的路由）。</li><li><img src="/2021/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-Part4/image-20211223150014117.png" alt="image-20211223150014117"></li></ul></li><li>不应发送 ICMP 差错报文的情况<ul><li>对 <strong>ICMP 差错报告报文</strong>不再发送 ICMP 差错报告报文。（IP 数据报不会检查数据部分，即 ICMP 差错报文有无出错）</li><li>对第一个分片的数据报片的所有<strong>后续数据报片</strong>都不发送 ICMP 差错报告报文。</li><li>对具有<strong>组播地址</strong>（一对指定多，区别于广播为一对所有多）的数据报都不发送 ICMP 差错报告报文。</li><li>对具有<strong>特殊地址</strong>（如 127.0.0.0 或 0.0.0.0）的数据报不发送 ICMP 差错报告报文。</li></ul></li><li>ICMP 询问报文<ul><li>回送请求和回答报文<ul><li>主机或路由器向特定目的主机发出的询问，收到此报文的主机必须给源主机或路由器发送 ICMP 回送回答报文。<strong>测试目的站是否可达以及了解其相关状态</strong>。</li></ul></li><li>时间戳请求和回答报文<ul><li>请某个主机或路由器回答当前的日期和时间。<strong>用来进行时钟同步和测量时间</strong>。</li></ul></li><li><del>掩码地址请求和回答报文（不再使用）</del></li><li><del>路由器询问和通告报文（不再使用）</del></li></ul></li><li>ICMP 的应用<ul><li>PING：测试两个主机之间的连通性，使用了 <strong>ICMP 回送请求和回答报文</strong>。</li><li>Traceroute：跟踪一个分组从源点到终点的路径，使用了 <strong>ICMP 时间超过差错报告报文</strong>。</li></ul></li></ul><h2 id="IPv6"><a href="#IPv6" class="headerlink" title="IPv6"></a>IPv6</h2><p><img src="/2021/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-Part4/image-20211223154240704.png" alt="image-20211223154240704"></p><ul><li>针对问题：<ul><li>32 位 IPv4 地址空间已分配殆尽</li><li>CIDR、NAT 只能延缓</li></ul></li><li>改进方向：<ul><li>IPv6 改进首部格式 -&gt; 快速处理/转发数据报、支持 QoS</li></ul></li><li>数据报格式：<ul><li>版本：6</li><li>优先级：区分数据报的类别和<strong>优先级</strong>。</li><li>流标签：互联网络上<strong>从特定源点到特定终点的一系列数据报</strong>。所有属于同一个流的数据报都具有同样的流标签。（区别于 IPv4 的标识位是标识同一组分片的数据报）</li><li>有效载荷长度：标识<strong>有效载荷 [扩展首部+数据] 的长度</strong>（区别于 IPv4 的首部长度 [首部+扩展首部] +总长度 [首部+扩展首部+数据] ）</li><li>下一个首部：标识<strong>下一个扩展首部</strong>（扩展首部可能有多个，每一个扩展首部都会有该字段来标识下一个首部）或<strong>上层协议首部</strong>（即数据部分）。</li><li>跳数限制：相当于 IPv4 的 TTL。</li><li><img src="/2021/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-Part4/image-20211223152037845.png" alt="image-20211223152037845" style="zoom: 80%;"></li></ul></li><li><strong>IPv6 和 IPv4 的区别</strong><ul><li>IPv6 将地址从 32 位（4B）扩大到 <strong>128 位（16B）</strong>，更大的地址空间。</li><li>IPv6 将 IPv4 的<strong>校验和字段彻底移除</strong>，以减少每跳的处理时间。</li><li>IPv6 将 IPv4 的可选字段移出首部，变成了<strong>扩展首部</strong>，成为灵活的首部格式，路由器通常不对扩展首部进行检查，大大提高了路由器的处理效率。</li><li>IPv6 支持<strong>即插即用</strong>（即自动配置），不需要 DHCP 协议。</li><li>IPv6 首部长度必须是 <strong>8B 的整数倍</strong>，IPv4 首部是 4B 的整数倍。</li><li>IPv6 <strong>只能在主机处分片</strong>，IPv4 可以在路由器和主机处分片。</li><li>ICMPv6：附加报文类型“分组过大”。</li><li>IPv6 支持资源的预分配， 支持实时视像等要求，保证一定的带宽和时延的应用。</li><li>IPv6 取消了协议字段，改成下一个首部字段。</li><li>IPv6 取消了总长度字段，改用有效载荷长度字段。</li><li>IPv6 取消了服务类型字段。</li></ul></li><li><strong>IPv6 地址表示形式</strong><ul><li>一般形式：<ul><li>冒号十六进制记法：<ul><li>4BF5:AA12:0216:FEBC:BA5F:039A:BE9A:2170</li></ul></li></ul></li><li>压缩形式：<ul><li>连续的 0 压缩成一个 0：<ul><li>4BF5:0000:0000:0000:BA 5F:039A:000A:2176 -&gt; 4BF5:0:0:0:BA5F:39A:A:2176</li></ul></li><li>零压缩：一连串连续的 0 可以被一对冒号取代（<strong>在一个地址中仅可出现一次</strong>）<ul><li>FF05:0:0:0:0:0:0:B3 -&gt; FF05::B3</li></ul></li></ul></li></ul></li><li>IPv6 基本地址类型<ul><li>单播：一对一通信，可做源地址+目的地址</li><li>多播：一对多通信，可做目的地址</li><li>任播：一对多中的一个通信，可做目的地址</li></ul></li><li>IPv6 向 IPv4 过渡的策略<ul><li>双栈协议<ul><li>指在一台路由器或主机上<strong>同时启用 lPv4 和 IPv6 协议栈</strong>，则既能和 IPv4 网络通信，又能和 IPv6 网络通信。</li></ul></li><li>隧道技术<ul><li>通过使用互联网络的基础设施在网络之间传递数据的方式。使用隧道传递的数据（或负载）可以是不同协议的数据帧或包。</li><li>隧道协议将其它协议（IPv6）的数据帧或包<strong>重新封装</strong>（成 IPv4）然后通过隧道发送。</li></ul></li></ul></li></ul><h2 id="路由算法与路由协议"><a href="#路由算法与路由协议" class="headerlink" title="路由算法与路由协议"></a>路由算法与路由协议</h2><h3 id="路由算法与路由协议概述"><a href="#路由算法与路由协议概述" class="headerlink" title="路由算法与路由协议概述"></a>路由算法与路由协议概述</h3><ul><li>最佳路由：“最佳”只能是相对于某一种特定要求下得出的较为合理的选择而已。</li><li>路由表表项：<ul><li>目的网络 IP 地址 </li><li>子网掩码 </li><li>下一跳 IP 地址 </li><li>接口</li></ul></li><li>路由算法分类<ul><li><strong>静态路由算法</strong>（非自适应路由算法）：管理员手工配置路由信息。<ul><li>优点：简便、可靠，在负荷稳定、拓扑变化不大的网络中运行效果很好，广泛用于高度安全性的军事网络和较小的商业网络。</li><li>缺点：路由更新慢，不适用大型网络。</li></ul></li><li><strong>动态路由算法</strong>（自适应路由算法）：路由器间彼此交换信息，按照路由算法优化出路由表项。<ul><li>优点：路由更新快，适用大型网络，及时响应链路费用或网络拓扑变化。</li><li>缺点：算法复杂，增加网络负担。</li></ul></li></ul></li><li>动态路由算法<ul><li><strong>全局性</strong>：链路状态路由算法（OSPF）<ul><li>所有路由器掌握完整的网络拓扑和链路费用信息。</li></ul></li><li><strong>分散性</strong>：距离向量路由算法（RIP）<ul><li>路由器只掌握物理相连的邻居及链路费用。</li></ul></li></ul></li><li>分层次的路由选择协议<ul><li>针对原因：1. 因特网规模很大，会导致路由表过于庞大；2. 许多单位不想让外界知道自己的路由选择协议，但还想连入因特网。</li><li>自治系统AS：<ul><li>在单一的技术管理下的一组路由器，而这些路由器使用一种AS内部的路由选择协议和共同的度量以确定分组在该AS内的路由，同时还使用一种AS之间的路由协议以确定在AS之间的路由。</li><li>一个AS内的所有网络都属于一个行政单位来管辖，一个自治系统的所有路由器在本自治系统内都必须连通。</li></ul></li><li>路由选择协议：<ul><li>内部网关协议 IGP：一个 AS 内使用（如 RIP、OSPF）</li><li>外部网关协议 EGP：AS 之间使用（如 BGP）</li></ul></li><li><img src="/2021/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-Part4/image-20211223162824830.png" alt="image-20211223162824830"></li></ul></li></ul><h3 id="RIP-协议与距离向量算法"><a href="#RIP-协议与距离向量算法" class="headerlink" title="RIP 协议与距离向量算法"></a>RIP 协议与距离向量算法</h3><p><img src="/2021/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-Part4/image-20211223170633629.png" alt="image-20211223170633629"></p><ul><li><p>RIP（Routing Information Protocol）是一种分布式的基于<strong>距离向量</strong>的路由选择协议，是因特网的协议标准，最大优点是<strong>简单</strong>。</p><ul><li>RIP 协议只适用于<strong>小互联网</strong>。</li></ul></li><li><p>RIP 协议要求网络中每一个路由器都维护<strong>从它自己到其他每一个目的网络的唯一最佳距离记录</strong>（即一组距离）。</p><ul><li>距离：通常为“跳数”，即从源端口到目的端口所经过的路由器个数，经过一个路由器跳数+1。</li><li>特别的，从一路由器到直接连接的网络距离为 1。</li><li>RIP 允许一条路由最多只能包含 15 个路由器，因此距离为 16 表示网络不可达。</li></ul></li><li><p>RIP 特点</p><ul><li>RIP 协议和谁交换？<ul><li>仅和<strong>相邻路由器</strong>交换信息。</li></ul></li><li>多久交换一次？<ul><li>每 <strong>30秒</strong> 交换一次路由信息，然后路由器根据新信息更新路由表。若超过 180s 没收到邻居路由器的通告，则判定邻居没了，并更新自己路由表。</li></ul></li><li>交换什么？<ul><li>路由器交换的信息是<strong>自己的路由表</strong>。</li></ul></li><li>路由器刚开始工作时，只知道直接连接的网络的距离（距离为1），接着每一个路由器也只和数目非常有限的相邻路由器交换并更新路由信息。</li><li>经过若干次更新后，所有路由器最终都会知道到达本自治系统任何一个网络的最短距离和下一跳路由器的地址，即“<strong>收敛</strong>”。</li></ul></li><li><p>RIP 更新</p><ol><li><p>修改相邻路由器发来的RIP报文中<strong>所有表项</strong>：</p><ul><li><p><strong>下一跳字段改为 X</strong>，并且<strong>距离字段 +1</strong>。</p></li><li><p><img src="/2021/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-Part4/image-20211223164554692.png" alt="image-20211223164554692"></p></li></ul></li><li><p>对修改后的 RIP 报文中的每一个项目，进行以下步骤：</p><ul><li>R1 路由表中若没有 Net3，则把该项目填入 R1 路由表</li><li>R1 路由表中若有 Net3，则查看下一跳路由器地址：<ul><li>若下一跳是 X，则用收到的项目替换源路由表中的项目（即更新距离）；</li><li>若下一跳不是 X， 原记录距离比新记录距离远则更新，否则不作处理。</li></ul></li></ul></li><li><p>若 <strong>180s</strong> 还没收到相邻路由器X的更新路由表，则把 X 记为不可达的路由器，即把距离设置为 16。</p></li></ol></li><li><p>RIP 协议的报文格式（了解）</p><ul><li><img src="/2021/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-Part4/image-20211223170035763.png" alt="image-20211223170035763"></li></ul></li><li><p>RIP 协议好消息传得快，坏消息传得慢</p><ul><li><strong>真正的无法到达的消息总会被虚假的可达到消息覆盖</strong>，只有在双方一次次相互传递消息之后才缓慢收敛成无法到达。</li><li><img src="/2021/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-Part4/image-20211223170432089.png" alt="image-20211223170432089"></li></ul></li></ul><h3 id="OSPF-协议与链路状态算法"><a href="#OSPF-协议与链路状态算法" class="headerlink" title="OSPF 协议与链路状态算法"></a>OSPF 协议与链路状态算法</h3><ul><li>OSPF（Open Shortest Path First）开放式最短路径优先<ul><li>“开放”标明 OSPF 协议不是受某一家厂商控制，而是公开发表的；“最短路径优先”是因为使用了 Dijkstra 提出的最短路径算法 SPF。</li><li>OSPF 最主要的特征就是<strong>使用分布式的链路状态协议</strong>。</li></ul></li><li>OSPF 的特点：<ul><li>和谁交换：<ul><li>使用<strong>洪泛法</strong>向自治系统内<strong>所有路由器</strong>发送信息，即路由器向所有相邻的路由器发送信息（广播），而每一个相邻路由器又再次将此信息发往其所有的相邻路由器。</li><li>最终整个区域内所有路由器都得到了这个信息的一个副本。</li></ul></li><li>交换什么：<ul><li>发送的信息就是与本路由器<strong>相邻的所有路由器的链路状态</strong>（与本路由器相邻的路由器，以及对应链路的度量/代价——费用、距离、时延、带宽等）。</li></ul></li><li>多久交换：<ul><li>只有当<strong>链路状态发生变化时</strong>，路由器才向所有路由器洪泛发送此信息。</li></ul></li><li>最后，所有路由器都能建立一个<strong>链路状态数据库</strong>，即<strong>全网拓扑图</strong>。</li></ul></li><li>链路状态路由算法<ul><li>构造网络拓扑<ol><li>每个路由器发现它的邻居结点【问候分组】，并了解邻居节点的网络地址。</li><li>设置到它的每个邻居的成本度量 metric。</li><li>构造【DD 数据库描述分组】，向邻站给出自己的链路状态数据库中的所有链路状态项目的摘要信息。</li><li>如果 DD 分组中的摘要自己都有，则邻站不做处理；如果有没有的或者是更新的，则发送【LSR 链路状态请求分组】 请求自己没有的和比自己更新的信息。</li><li>收到邻站的 LSR 分组后，发送【LSU 链路状态更新分组】进行更新。</li><li>更新完毕后，邻站返回一个【LSAck 链路状态确认分组】进行确认。</li></ol></li><li>若一个路由器的链路状态发生变化：<ol start="5"><li>向邻居泛洪发送【LSU 链路状态更新分组】进行更新。</li><li>更新完毕后，其他站返回一个【LSAck 链路状态确认分组】进行确认。</li><li>使用 Dijkstra 根据自己的链路状态数据库构造到其他节点间的最短路径。</li></ol></li></ul></li><li>OSPF 的区域（了解）<ul><li>为了使 OSPF 能够用于规模很大的网络，OSPF 将一个自治系统再划分为若干个更小的范围，叫做<strong>区域</strong>。</li><li>每一个区域都有一个 32 位的区域标识符（用点分十进制表示）。</li><li>区域也不能太大，在一个区域内的路由器最好不超过 200 个。</li><li><img src="/2021/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-Part4/image-20211224104028583.png" alt="image-20211224104028583"></li></ul></li><li>OSPF 分组<ul><li>OSPF 直接用 IP 数据报传送。（<strong>网络层协议</strong>）</li><li><img src="/2021/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-Part4/image-20211224104144658.png" alt="image-20211224104144658" style="zoom:80%;"></li></ul></li><li>OSPF 其他特点<ul><li>每隔 <strong>30min</strong>，要刷新一次数据库中的链路状态。</li><li>由于一个路由器的链路状态只涉及到与相邻路由器的连通状态，因而与网络的规模并无直接关系。因此当<strong>互联网规模很大</strong>时，OSPF 协议要比距离向量协议 RIP 好得多。</li><li>OSPF 不存在坏消息传的慢的问题，<strong>收敛速度很快</strong>。</li></ul></li></ul><h3 id="BGP-协议"><a href="#BGP-协议" class="headerlink" title="BGP 协议"></a>BGP 协议</h3><ul><li>BGP（Border Gateway Protocol）边界网关协议<ul><li>每个自治系统至少选择一位发言人，通常为边界路由器。</li><li>两个 BGP 发言人通过一个网络连接在一起。</li><li>自治系统连通图是一个树形结构</li><li><img src="/2021/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-Part4/image-20211224104947913.png" alt="image-20211224104947913"></li></ul></li><li>特点：<ul><li>和谁交换<ul><li>与其他 AS 的邻站 BGP 发言人交换信息。</li></ul></li><li>交换什么<ul><li>交换的网络可达性的信息，即要<strong>到达某个网络所要经过的一系列 AS</strong>（<strong>路径向量</strong>）。</li></ul></li><li>多久交换<ul><li>发生变化时更新有变化的部分。</li></ul></li></ul></li><li>BGP 协议报文格式<ul><li>一个 BGP 发言人与其他自治系统中的 BGP 发言人要交换路由信息<ul><li><strong>先建立 TCP 连接</strong>；</li><li>然后在此连接上<strong>交换 BGP 报文以建立 BGP 会话（session）</strong>；</li><li>利用 BGP 会话交换路由信息。</li></ul></li><li>BGP是<strong>应用层</strong>协议，借助<strong>TCP</strong>传送。</li><li><img src="/2021/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-Part4/image-20211224105743360.png" alt="image-20211224105743360"></li></ul></li><li>BGP 协议特点<ul><li>BGP 支持 <strong>CIDR</strong>，因此 BGP 的路由表也就应当包括<strong>目的网络前缀</strong>、<strong>下一跳路由器</strong>，以及<strong>到达该目的网络所要经过的各个自治系统序列</strong>。 </li><li>BGP 启动时，邻站交换整个 BGP 路由表。但以后只需要在<strong>发生变化时更新有变化的部分</strong>。<ul><li>由此，节省网络带宽、减少路由器的处理开销。</li></ul></li></ul></li><li>BGP-4 的四种报文<ul><li><strong>OPEN（打开）报文</strong>：用来与相邻的另一个 BGP 发言人建立关系，并认证发送方。</li><li><strong>UPDATE（更新）报文</strong>：通告新路径或撤销原路径。</li><li><strong>KEEPALIVE（保活）报文</strong>：在无 UPDATE 时，周期性证实邻站的连通性；也作为 OPEN 的确认。</li><li><strong>NOTIFICATION（通知）报文</strong>：报告先前报文的差错；也被用于关闭连接。</li></ul></li><li><strong>三种路由协议比较</strong><ul><li>RIP 是一种分布式的基于距离向量的内部网关路由选择协议，通过广播 UDP 报文来交换路由信息。</li><li>OSPF 是一个内部网关协议，要交换的信息量较大，应使报文的长度尽量短，所以<strong>不使用传输层协议（如 UDP 或 TCP），而是直接采用 IP</strong>。</li><li>BGP 是一个外部网关协议，在不同的自治系统之间交换路由信息，由于网络环境复杂，需要保证可靠传输，所以采用 TCP。</li><li><img src="/2021/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-Part4/image-20211224110705488.png" alt="image-20211224110705488"></li></ul></li></ul><h2 id="IP-组播"><a href="#IP-组播" class="headerlink" title="IP 组播"></a>IP 组播</h2><p><img src="/2021/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-Part4/image-20211224130048760.png" alt="image-20211224130048760"></p><ul><li>IP 数据报的三种传输方式<ul><li>单播：单播用于发送数据包到单个目的地，且每发送一份单播报文都使用一个单播IP地址作为目的地址。是一种<strong>点对点</strong>传输方式。</li><li>广播：广播是指发送数据包到同一广播域或子网内的所有设备的一种数据传输方式，是一种<strong>点对多点</strong>传输方式。</li><li>组播（多播）：当网络中的某些用户需要特定数据时，组播数据发送者仅发送一次数据，借助组播路由协议为组播数据包建立组播分发树，<strong>被传递的数据到达距离用户端尽可能近的节点后才开始复制和分发</strong>，是一种<strong>点对多点</strong>传输方式。</li></ul></li><li>组播地址<ul><li>IP 组播地址让源设备能够将分组发送给一组设备。属于多播组的设备将被分配一个<strong>组播组 IP 地址</strong>（一群共同需求主机的相同标识）。</li><li>组播地址范围为 224.0.0.0～239.255.255.255（D 类地址），一个 D 类地址表示一个组播组。<strong>只能用作分组的目标地址，源地址总是为单播地址</strong>。</li><li>组播数据报也是“尽最大努力交付”，不提供可靠交付，应用于 UDP。</li><li>对组播数据报不产生 ICMP 差错报文。</li><li>并非所有 D 类地址都可以作为组播地址。</li><li><img src="/2021/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-Part4/image-20211224132506030.png" alt="image-20211224132506030"></li></ul></li><li><strong>硬件组播</strong><ul><li>同单播地址一样，组播 IP 地址也需要相应的组播 MAC 地址在本地网络中实际传送帧。</li><li>组播 MAC 地址以十六进制值 01-00-5E 开头，余下的 6 个十六进制位是根据 IP 组播组地址的最后 23 位转换得到。</li><li>TCP/IP 协议使用的以太网多播地址的范围是: <ul><li>从 <strong>01-00-5E-00-00-00</strong> 到 <strong>01-00-5E-7F-FF-FF</strong></li></ul></li><li>收到多播数据报的主机，还要在 IP 层利用软件进行过滤，把不是本主机要接收的数据报丢弃。</li><li><img src="/2021/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-Part4/image-20211224132654866.png" alt="image-20211224132654866"></li></ul></li><li>IGMP 协议与组播路由选择协议<ul><li>网际组管理协议 IGMP<ul><li>IGMP 协议让路由器知道本局域网上<strong>是否有主机（的进程）参加或退出了某个组播组</strong>。</li><li>ICMP 和 IGMP 都使用 <strong>IP 数据报传递报文</strong>。</li><li><img src="/2021/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-Part4/image-20211224133147877.png" alt="image-20211224133147877"></li><li>IGMP 工作的两个阶段<ul><li>某主机要加入组播组时，该主机向组播组的组播地址发送一个 IGMP 报文，声明自己要称为该组的成员。本地组播路由器收到 IGMP 报文后，要利用组播路由选择协议把这组成员关系发给因特网上的其他组播路由器。</li><li>本地组播路由器周期性探询本地局域网上的主机，以便知道这些主机是否还是组播组的成员。只要有一个主机对某个组响应，那么组播路由器就认为这个组是活跃的；如果经过几次探询后没有一个主机响应，组播路由器就认为本网络上的没有此组播组的主机，因此就不再把这组的成员关系发给其他的组播路由器。</li><li>组播路由器知道的成员关系只是所连接的局域网中有无组播组的成员。</li></ul></li></ul></li><li>组播路由选择协议<ul><li>组播路由选择协议目的是找出以源主机为根节点的<strong>组播转发树</strong>。</li><li>对不同的多播组对应于不同的多播转发树；同一个多播组，对不同的源点也会有不同的多播转发树。</li><li>组播路由选择协议常使用的三种算法：<ul><li>基于链路状态的路由选择</li><li>基于距离-向量的路由选择</li><li>协议无关的组播（稀疏/密集）</li></ul></li></ul></li></ul></li></ul><h2 id="移动-IP（不常考）"><a href="#移动-IP（不常考）" class="headerlink" title="移动 IP（不常考）"></a>移动 IP（不常考）</h2><ul><li><p>移动 IP 相关概念</p><ul><li>移动 IP 技术是移动结点（计算机/服务器等）以<strong>固定的网络 IP 地址</strong>，实现跨越不同网段的漫游功能，并保证了基于网络 IP 的网络权限在漫游过程中不发生任何改变。</li><li>移动结点：<ul><li>具有永久IP地址的移动设备。</li></ul></li><li>归属代理（本地代理）：<ul><li>一个移动结点的永久“居所”称为<strong>归属网络</strong>，在归属网络中代表移动节点执行移动管理功能的实体叫做归属代理。（路由器也可以作为归属代理）</li></ul></li><li>永久地址（归属地址/主地址）：<ul><li>移动站点在归属网络中的原始地址。</li></ul></li><li>外部代理（外地代理）：<ul><li>在<strong>外部网络</strong>中帮助移动节点完成移动管理功能的实体称为外部代理。（一个外部网络的路由器）</li></ul></li><li>转交地址（辅地址）：<ul><li>可以是外部代理的地址或动态配置的一个地址</li></ul></li></ul></li><li><p>工作流程：</p><ul><li><p>A 刚进入外部网络：</p><ol><li>获得外部代理的转交地址（外部代理广播报文）。<ul><li>主动获得：主机发布报文以获得转交地址</li><li>被动获得：路由器广播转交地址</li></ul></li><li>移动节点<strong>通过外部代理发送注册报文给归属代理</strong>（包含永久地址 &amp; 转交地址）。</li><li>归属代理接收请求，并<strong>将移动节点的永久地址和转交地址绑定</strong>（以后到达该归属代理的数据报且要发往移动节点的数据报将被封装并以隧道方式发给转交地址），并返回一注册响应报文。</li><li>外部代理接收注册 <strong>A</strong> 响应，并转发给移动节点。</li></ol></li><li><p>A 移动到了下一个网络：</p><ol><li><p>在新外部代理登记注册一个转交地址。</p></li><li><p>新外部代理给本地代理发送新的转交地址（覆盖旧的）。</p></li></ol></li><li><p>A 回到了归属网络：</p><ol><li><p>A 向本地代理注销转交地址。</p></li><li><p>按原始方式通信。</p></li></ol></li></ul></li></ul><h2 id="网络层设备"><a href="#网络层设备" class="headerlink" title="网络层设备"></a>网络层设备</h2><ul><li>路由器<ul><li>路由器，是一种具有多个输入端口和多个输出端口的专用计算机，其任务是<strong>转发分组</strong>。</li><li><img src="/2021/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-Part4/image-20211224113104910.png" alt="image-20211224113104910"></li></ul></li><li>路由选择：<ul><li>根据所选定的路由选择协议<strong>构造出路由表</strong>，同时经常或定期地和相邻路由器交换路由信息而不断地<strong>更新和维护路由表</strong>。</li></ul></li><li>分组转发：<ul><li>交换结构：根据<strong>转发表（路由表得来）</strong>对分组进行<strong>转发</strong>。</li><li>若收到 RIP/OSPF 分组等，则把分组送往路由选择处理机；若收到数据分组，则查找转发表并输出。</li></ul></li><li>输入端口对线路上收到的分组的处理，将交换结构传送来的分组发送到线路<ul><li>输入端口中的查找和转发功能在路由器的交换功能中是最重要的。</li><li>若路由器处理分组的速率赶不上分组进入队列的速率，则队列的存储空间最终必定减少到零，这就使后面再进入队列的分组由于没有存储空间而只能被丢弃。<ul><li><strong>路由器中的输入或输出队列产生溢出是造成分组丢失的重要原因。</strong></li></ul></li><li><img src="/2021/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-Part4/image-20211224113631995.png" alt="image-20211224113631995"></li></ul></li><li><strong>三层设备的区别</strong><ul><li>网络层设备（路由器）：可以互联两个不同网络层协议的网段。</li><li>链路层设备（网桥、交换机）：可以互联两个物理层和链路层不同的网段。</li><li>物理层设备（中继器、集线器）：不能互联两个物理层不同的网段。</li></ul></li><li><strong>路由表与路由转发</strong><ul><li>路由表<ul><li>路由表根据<strong>路由选择算法</strong>得出的，主要用途是路由选择，总用软件来实现。</li></ul></li><li>转发表<ul><li>由<strong>路由表</strong>得来，可以用软件实现，也可以用特殊的硬件来实现。</li><li>转发表必须包含完成转发功能所必需的信息，即从要到达的目的网络到输出端口和某些 MAC 地址信息的映射。</li></ul></li></ul></li></ul>]]></content>
    
    
    <summary type="html">网络层</summary>
    
    
    
    <category term="计算机网络" scheme="https://nephrencake.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
  </entry>
  
  <entry>
    <title>计算机网络-Part3</title>
    <link href="https://nephrencake.github.io/2021/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-Part3/"/>
    <id>https://nephrencake.github.io/2021/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-Part3/</id>
    <published>2021-12-03T05:55:56.000Z</published>
    <updated>2022-07-01T14:06:54.839Z</updated>
    
    <content type="html"><![CDATA[<h1 id="计算机网络-Part3——数据链路层"><a href="#计算机网络-Part3——数据链路层" class="headerlink" title="计算机网络-Part3——数据链路层"></a>计算机网络-Part3——数据链路层</h1><p>[TOC]</p><p><img src="/2021/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-Part3/image-20211206141619999.png" alt="image-20211206141619999"></p><h2 id="数据链路层功能概述"><a href="#数据链路层功能概述" class="headerlink" title="数据链路层功能概述"></a>数据链路层功能概述</h2><ul><li>研究思想：只关心同级的数据链路层如何封装与解封装</li><li>基本概念<ul><li>结点：主机、路由器</li><li>链路：网络中两个结点之间的<strong>物理通道</strong>，链路的传输介质主要有双绞线、光纤和微波。分为有线链路、无线链路。</li><li>数据链路：网络中两个结点之间的<strong>逻辑通道</strong>，把实现控制数据传输<strong>协议</strong>的硬件和软件加到链路上就构成数据链路。</li><li>帧：链路层的协议数据单元，封装网络层数据报。</li><li><strong>数据链路层</strong>负责通过一条链路从一个结点向另一个物理链路直接相连的相邻结点传送数据报。</li></ul></li><li>功能概述<ul><li>数据链路层在物理层提供服务的基础上<strong>向网络层提供服务</strong>，其最基本的服务是将源自网络层来的数据可靠地传输到相邻节点的目标机网络层。</li><li>主要作用是<strong>加强物理层传输原始比特流的功能</strong>，将物理层提供的可能出错的物理连接改造成为逻辑上无差错的数据链路，使之对网络层表现为一条无差错的链路。</li><li>功能<ul><li>为网络层提供服务。无确认无连接服务，有确认无连接服务，有确认面向连接服务</li><li>链路管理，即连接的建立、维持、释放（用于面向连接的服务）</li><li>组帧</li><li>流量控制</li><li>差错控制（帧错/位错）</li></ul></li></ul></li></ul><h2 id="封装成帧和透明传输"><a href="#封装成帧和透明传输" class="headerlink" title="封装成帧和透明传输"></a>封装成帧和透明传输</h2><ul><li><strong>封装成帧</strong>是在一段数据上添加首部和尾部，构成一个帧。接收端在收到物理层上的比特流后，就能根据首部和尾部的标记，来识别帧的开始和结束。<ul><li>首部和尾部包含许多的控制信息，只有帧定界符才是实现了<strong>帧定界</strong>。</li><li><strong>帧同步</strong>：<strong>接收方</strong>应当能从接收到的二进制比特流中区分出帧的起始和终止。</li><li><strong>组帧的四种方法</strong>：1. 字符计数法；2. 字符（节）填充法；3. 零比特填充法；4. 违规编码法。</li><li><img src="/2021/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-Part3/image-20211206193517041.png" alt="image-20211206193517041"></li></ul></li><li><strong>透明传输</strong>是指不管所传数据是什么样的比特组合，都应当能够在链路上传送。因此，链路层就“看不见”有什么妨碍数据传输的东西。<ul><li>当所传<strong>数据中的比特组合</strong>恰巧与<strong>某一个控制信息</strong>完全一样时，就必须采取适当的措施，使收方不会将这样的数据误认为是某种控制信息。这样才能保证数据链路层的传输是透明的。</li><li>字符计数法<ul><li>帧首部使用一个计数字段（第一个<strong>字节</strong>，八位）来标明帧内字符数。</li><li>缺点：当首部出错时，后面会跟着出错</li><li><img src="/2021/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-Part3/image-20211206194718116.png" alt="image-20211206194718116" style="zoom:80%;"></li></ul></li><li>字符填充法<ul><li>在控制字符之前增添转义，表示按照数据读取。<ul><li>SOH：Start of header</li><li>EOT：End of transmission</li></ul></li><li><img src="/2021/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-Part3/image-20211206195050505.png" alt="image-20211206195050505" style="zoom:80%;"></li></ul></li><li>零比特填充法<ul><li>流程（5110）<ul><li>在发送端，扫描整个信息字段，只要连续 5 个 1，就立即填入 1 个 0。</li><li>在接收端收到一个帧时，先找到标志字段确定边界，再用硬件对比特流进行扫描。发现连续 5 个 1 时，就把后面的 0 删除。</li></ul></li><li>实现了：在传送的比特流中可以传送任意比特组合，而不会引起对帧边界的判断错误。</li><li><img src="/2021/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-Part3/image-20211206195623869.png" alt="image-20211206195623869" style="zoom:80%;"></li></ul></li><li>违规编码法<ul><li>使用不会用到的编码方式，“高-高”、“低-低”来定界帧的起始和终止。</li><li><img src="/2021/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-Part3/image-20211206195924114.png" alt="image-20211206195924114" style="zoom:80%;"></li></ul></li><li>总结：<ul><li>字节计数法中 Count 字段很脆弱</li><li>字符填充实现上复杂且不兼容</li><li>普遍使用的帧同步法是<strong>比特填充</strong>和<strong>违规编码法</strong>。</li></ul></li></ul></li></ul><h2 id="差错控制"><a href="#差错控制" class="headerlink" title="差错控制"></a>差错控制</h2><ul><li><p>差错的来源（传输中的差错都是由于噪声引起的）</p><ul><li>全局性<ul><li>由于线路本身电气特性所产生的<strong>随机热噪声</strong>，是信道固有的，随机存在的。</li><li>解决办法：提高信噪比来减少或避免干扰。（对传感器下手）</li></ul></li><li>局部性<ul><li>外界特定的短暂原因所造成的<strong>冲击噪声</strong>，是产生差错的主要原因。</li><li>解决办法：通常利用编码技术来解决。</li></ul></li></ul></li><li><p>差错的种类</p><ul><li>位错<ul><li>比特位出错，1 变成 0，0 变成 1。</li></ul></li><li>帧错<ul><li>丢失：收到[#1]-[#3] </li><li>重复：收到[#1]-[#2]-[#2]-[#3]</li><li>失序：收到[#1]-[#3]-[#2]</li></ul></li></ul></li><li><p>分不同的链路选择不同的连接方式</p><ul><li><img src="/2021/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-Part3/image-20211206200547917.png" alt="image-20211206200547917" style="zoom:80%;"></li></ul></li><li><p>数据链路层与物理层的编码意义</p><ul><li>物理层编码针对的是<strong>单个比特</strong>，解决传输过程中<strong>比特的同步</strong>等问题，如曼彻斯特编码。</li><li>数据链路层的编码针对的是<strong>一组比特</strong>，通过冗余码的技术实现对<strong>二进制比特流的跳变问题</strong>。</li></ul></li><li><p>冗余编码</p><ul><li><strong>附加</strong>一定的冗余位，以实现检错、纠错。</li></ul></li></ul><h3 id="检错编码"><a href="#检错编码" class="headerlink" title="检错编码"></a>检错编码</h3><ul><li>奇偶校验码<ul><li>特点：只能检查出<strong>奇数个比特</strong>错误，检错能力为50%。</li><li><img src="/2021/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-Part3/image-20211206201829051.png" alt="image-20211206201829051"></li></ul></li><li>CRC 循环冗余码<ul><li>除数为 r+1 位，生成多项式为 r 阶，FCS 为 r 位。</li><li>在数据链路层 CRC，只能做到对帧的无差错接收，即“凡是接收端数据链路层接受的帧，我们都能以非常接近于 1 的概率认为这些帧在传输过程中没有产生差错”。<ul><li><strong>可靠传输</strong>：数据链路层发送端发送什么，接收端就收到什么。</li><li>CRC，能够实现无比特差错的传输，但这不属于可靠传输。因为，接收端会<strong>丢弃</strong>曾收到但因为有差错被丢弃的帧。</li></ul></li><li><img src="/2021/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-Part3/image-20211206202346800.png" alt="image-20211206202346800"></li><li><img src="/2021/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-Part3/image-20211206204015149.png" alt="image-20211206204015149"></li></ul></li></ul><h3 id="纠错编码"><a href="#纠错编码" class="headerlink" title="纠错编码"></a>纠错编码</h3><ul><li>海明距离<ul><li>两个码字的海明距离（码距）：两个合法编码（码字）的对应比特取值不同的比特数。</li><li>一个编码集的海明距离（码距）：一个有效编码集中，任意两个合法编码（码字）海明距离的最小值。</li><li>将两个字符串异或（同 0 异 1）：码距 = 1 的个数</li></ul></li><li>公式：<ul><li>检测 d 位错，需要 d+1 位码距</li><li>纠正 d 位错，需要 2d+1 位码距</li></ul></li><li>海明校验码算法流程<ul><li>确定校验码位数 r（数据/信息有 m 位，冗余码/校验码有 r 位）<ul><li>校验码一共有 2^r^ 种取值</li><li><strong>2^r^ ≥ m+r+1</strong>（海明不等式）</li><li>凑出合适的 r</li></ul></li><li>确定校验码和数据的位置<ul><li>校验码放在序号为 2^n^ 的位置，数据按序填上</li><li>从右到左，由低到高</li></ul></li><li>求出校验码的值<ul><li><img src="/2021/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-Part3/image-20211207203531042.png" alt="image-20211207203531042" style="zoom: 67%;"></li></ul></li><li>检错并纠错<ul><li>法一：找交并集<ul><li><img src="/2021/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-Part3/image-20211207204157940.png" alt="image-20211207204157940" style="zoom:67%;"></li></ul></li><li>法二：普适法<ul><li><img src="/2021/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-Part3/image-20211207204453806.png" alt="image-20211207204453806" style="zoom:80%;"></li></ul></li></ul></li></ul></li></ul><h2 id="流量控制与可靠传输机制（重要）"><a href="#流量控制与可靠传输机制（重要）" class="headerlink" title="流量控制与可靠传输机制（重要）"></a>流量控制与可靠传输机制（重要）</h2><h3 id="流量控制、可靠传输与滑动窗口机制"><a href="#流量控制、可靠传输与滑动窗口机制" class="headerlink" title="流量控制、可靠传输与滑动窗口机制"></a>流量控制、可靠传输与滑动窗口机制</h3><p><img src="/2021/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-Part3/image-20211207211509126.png" alt="image-20211207211509126"></p><ul><li>针对问题：<strong>较高的发送速度</strong>和<strong>较低的接收能力</strong>的不匹配，会造成<strong>传输出错、资源浪费</strong>，因此流量控制也是数据链路层的一项重要工作。<ul><li>数据链路层的流量控制是点对点的，而传输层的流量控制是端到端的。</li><li><strong>数据链路层</strong>流量控制手段：接收方收不下就不回复确认（不包含数据的确认帧）。</li><li><strong>传输层</strong>流量控制手段：接收端给发送端一个窗口公告（提示可承受的缓冲区容量）。</li></ul></li><li>滑动窗口机制：同时发送和接收窗口的数据，确认后移动窗口<ul><li>停止-等待协议：发送窗口大小=1，接收窗口大小=1；</li><li>后退 N 帧协议：发送窗口大小&gt;1，接收窗口大小=1；</li><li>选择重传协议：发送窗口大小&gt;1，接收窗口大小&gt;1；</li><li>数据链路层的这三种滑动窗口大小在发送过程中是固定值</li><li>传输层的窗口可能不固定</li></ul></li><li>滑动窗口解决<strong>流量控制</strong>（收不下就不给确认，想发也发不了）、<strong>可靠传输</strong>（发送方自动重传）<ul><li>可靠传输：发送端发啥，接收端收啥。</li><li>流量控制：控制发送速率，使接收方有足够的缓冲空间来接收每一个帧。</li></ul></li></ul><h3 id="单帧滑动窗口与停止-等待协议"><a href="#单帧滑动窗口与停止-等待协议" class="headerlink" title="单帧滑动窗口与停止-等待协议"></a>单帧滑动窗口与停止-等待协议</h3><p><img src="/2021/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-Part3/image-20211211134349640.png" alt="image-20211211134349640"></p><ul><li>三个协议在哪一层<ul><li>在以往通信质量不好的时候，数据链路层要承担可靠传输的职责，因此会使用这三种协议</li><li>如今差错不如之前那么大，因此可靠传输的职责可以交由传输层负责，数据链路层主要负责差错控制</li><li>不需要过度在意，属于不同层只是称呼对象不同，传输层为分组、链路层为帧，本质都是传输的数据</li></ul></li><li>为什么要有停止-等待协议<ul><li>为了实现流量控制、解决丢包问题。</li></ul></li><li>研究停等协议的前提<ul><li>虽然现在常用全双工通信方式，但为了讨论问题方便，仅考虑一方发送数据（发送方），一方接收数据（接收方）</li><li>因为是在讨论可靠传输的原理，所以并不考虑数据是在哪一个层次上传送的。</li></ul></li><li>停等协议的无差错情况&amp;有差错情况<ul><li>无差错情况<ul><li>每发送 1 个数据帧就停止并等待，因此用 1bit 来编号足够。</li><li><img src="/2021/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-Part3/image-20211207213049809.png" alt="image-20211207213049809" style="zoom: 50%;"></li></ul></li><li>有差错情况——数据帧丢失或检测到帧出错<ul><li>超时计时器：每次发送一个帧就启动一个计时器。</li><li>超时计时器设置的重传时间应当比帧传输的平均 RTT 更长一些。</li><li>发完一个帧后，必须保留它的副本。（发送方以备重传）</li><li>数据帧和确认帧必须编号。（接受方响应重传）</li><li><img src="/2021/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-Part3/image-20211207213606881.png" alt="image-20211207213606881" style="zoom: 50%;"></li></ul></li><li>有差错情况——有差错情况<ul><li><img src="/2021/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-Part3/image-20211207213642669.png" alt="image-20211207213642669" style="zoom:50%;"></li></ul></li><li>有差错情况——ACK 迟到<ul><li><img src="/2021/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-Part3/image-20211207213733189.png" alt="image-20211207213733189" style="zoom:50%;"></li></ul></li></ul></li><li>停等协议的性能分析<ul><li>简单；信道利用率低</li><li><img src="/2021/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-Part3/image-20211207214234621.png" alt="image-20211207214234621" style="zoom:80%;"></li><li><strong>信道利用率</strong>：<strong>发送方</strong>在一个发送周期内，<strong>有效地发送数据所需要的时间</strong>占整个发送周期的比率。<ul><li><img src="/2021/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-Part3/image-20211207214357171.png" alt="image-20211207214357171" style="zoom: 67%;"></li></ul></li><li>*<em>信道吞吐率 = 信道利用率 * 发送方的发送速率*</em></li><li><img src="/2021/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-Part3/image-20211211134308548.png" alt="image-20211211134308548" style="zoom:80%;"></li></ul></li></ul><h3 id="多帧滑动窗口与后退-N-帧协议（GBN）"><a href="#多帧滑动窗口与后退-N-帧协议（GBN）" class="headerlink" title="多帧滑动窗口与后退 N 帧协议（GBN）"></a>多帧滑动窗口与后退 N 帧协议（GBN）</h3><p><img src="/2021/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-Part3/image-20211211150917861.png" alt="image-20211211150917861"></p><ul><li>针对问题：停等利用率低</li><li>改进方向：流水线技术<ul><li>发送窗口 ：发送方维持一组连续的允许发送的帧的序号。</li><li>接收窗口 ：接收方维持一组连续的允许接收帧的序号。</li></ul></li><li>改进注意：<ul><li>必须增加序号的范围</li><li>发送方需要缓存多个分组</li></ul></li><li>GBN 发送方必须响应的三件事<ul><li>上层（网络层）的调用（要发送数据时）：<ul><li>先检查发送窗口是否已满，如果未满，则产生一个帧并将其发送；</li><li>如果窗口已满，则不接收数据并使上层等待。实际实现中，可以缓存上层的数据，在窗口有空时再发送帧。</li></ul></li><li>收到 ACK：GBN 协议中，对 n 号帧的确认采用<strong>累积确认</strong>的方式，表明接收方已经收到 n 号帧和它之前的全部帧。</li><li>超时事件：协议名为后退/回退 N 帧，来源于出现<strong>丢失和时延过长帧</strong>时发送方的行为：发送方重传<strong>所有一连串已发送但未被确认</strong>的帧。</li></ul></li><li>GBN 接收方要做的事<ul><li>如果<strong>正确且按序</strong>收到 n 号帧，那么接收方为 n 帧发送<strong>一个 ACK</strong>，并将该帧中的数据<strong>交付给上层</strong>。</li><li>若接收的帧不是按序，则<strong>丢弃该帧</strong>并为<strong>最近按序接收的帧发送 ACK</strong>。接收方无需缓存任何失序帧，只需要维护一个信息：ExpectedSeqNum（下一个按序的帧序号）</li></ul></li><li><img src="/2021/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-Part3/image-20211211143229117.png" alt="image-20211211143229117" style="zoom:80%;"></li><li>滑动窗口长度<ul><li>若采用 n 个比特对帧编号，那么发送窗口的尺寸 W<del>T</del> 应满足：1≤ W<del>T</del> ≤ 2^n^-1。</li><li>因为发送窗口尺寸过大，就会使得接收方无法区别新帧（下一个循环）和旧帧（当前循环）。</li></ul></li><li>重点总结：<ul><li>累积确认（偶尔会有接收方发送数据给发送方，此时会在数据中<strong>捎带确认</strong>）</li><li>接收方只按顺序接收帧，不按序则丢弃</li><li>确认序列号最大且按序到达的帧</li><li>发送窗口最大为 2^n^-1，接收窗口大小为 1</li></ul></li><li>GBN 协议性能分析<ul><li>优点：因连续发送数据帧而提高了信道利用率</li><li>缺点：在重传时必须把原来已经正确传送的数据帧重传，是传送效率降低。</li></ul></li></ul><h3 id="多帧滑动窗口与选择重传协议（SR）"><a href="#多帧滑动窗口与选择重传协议（SR）" class="headerlink" title="多帧滑动窗口与选择重传协议（SR）"></a>多帧滑动窗口与选择重传协议（SR）</h3><p><img src="/2021/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-Part3/image-20211211154027330.png" alt="image-20211211154027330"></p><ul><li>针对问题：GBN 累积确认是一个优点，但是出现差错时代价较大。</li><li>改进方向：选择重传协议（Selective Repeat，SR）设置为单个确认，扩大接收窗口，设置接收缓存，缓存乱序到达的帧。<ul><li><img src="/2021/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-Part3/image-20211211151735241.png" alt="image-20211211151735241" style="zoom:80%;"></li></ul></li><li>SR 发送方必须响应的三件事<ul><li>上层的调用：从上层收到数据后，SR 发送方检查下一个可用于该帧的序号，如果序号位于发送窗口内，则发送数据帧；否则，将数据缓存，或者拒绝接收数据并使上层等待。</li><li>收到一个 ACK：<ul><li>如果收到 ACK，加入该帧序号在窗口内，则 SR 发送方将那个被确认的帧标记为已接收。</li><li>如果该帧序号是窗口的下界，则窗口向前移动到具有最小序号的未确认帧处；如果窗口移动并且有序号帧在窗口内未发送，则发送这些帧。</li></ul></li><li>超时事件：每个帧都有自己的定时器，一个超时事件发生后<strong>只重传一个帧</strong>。</li></ul></li><li>SR 接收方要做的事<ul><li>SR 接收方将<strong>确认一个正确接收的帧</strong>而不管其是否按序。失序的帧将被<strong>缓存</strong>，并返回发送方一个该帧的确认帧（<strong>收谁确认谁</strong>）。</li><li>直到序号更小的帧皆被接收为止，才可以将一批帧按序交付给上层，然后<strong>向前移动滑动窗口</strong>。</li><li>如果收到小于窗口下界的帧，就返回一个 ACK</li><li>其他情况，就忽略该帧</li></ul></li><li><img src="/2021/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-Part3/image-20211211152901928.png" alt="image-20211211152901928"></li><li>滑动窗口长度<ul><li>发送窗口最好等于接收窗口。（大了会溢出，小了没意义）、</li><li>W<del>Tmax</del> = W<del>Rmax</del> = 2^n−1^</li><li><img src="/2021/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-Part3/image-20211211153858924.png" alt="image-20211211153858924" style="zoom:67%;"></li></ul></li><li>SR 协议重点总结<ul><li>对数据帧逐一确认。收一个确认一个</li><li>只重传出错帧</li><li>接收方有缓存</li><li>W<del>Tmax</del> = W<del>Rmax</del> = 2^n−1^</li></ul></li></ul><h2 id="介质访问控制（重要）"><a href="#介质访问控制（重要）" class="headerlink" title="介质访问控制（重要）"></a>介质访问控制（重要）</h2><h3 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h3><ul><li>介质访问控制：采取一定的措施，使得两对节点之间的通信不会发生互相干扰的情况。<ul><li><img src="/2021/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-Part3/image-20211212104228185.png" alt="image-20211212104228185"></li></ul></li><li>信道划分介质访问控制（Multiple Access Control，MAC）协议：<ul><li>基于<strong>多路复用</strong>技术划分资源。</li><li>网络负载重：共享信道效率高，且公平</li><li>网络负载轻：共享信道效率低</li></ul></li><li>随机访问MAC协议：（只有这个会产生冲突）<ul><li>用户根据意愿<strong>随机</strong>发送信息，发送信息时可独占信道带宽。</li><li>网络负载重：产生冲突开销</li><li>网络负载轻：共享信道效率高，单个结点可利用信道全部带宽</li></ul></li><li>轮询访问MAC协议/轮流协议/轮转访问MAC协议：<ul><li>既要<strong>不产生冲突</strong>，又要发送时<strong>占全部带宽</strong>。<ul><li>轮询协议</li><li>令牌传递协议</li></ul></li></ul></li></ul><h3 id="信道划分介质访问控制"><a href="#信道划分介质访问控制" class="headerlink" title="信道划分介质访问控制"></a>信道划分介质访问控制</h3><ul><li>传输数据使用的两种链路<ul><li>点对点链路：两个相邻节点通过一个链路相连，没有第三者。应用：PPP 协议，常用于<strong>广域网</strong>。</li><li>广播式链路：所有主机共享通信介质。应用：早期的总线以太网、无线局域网，常用于<strong>局域网</strong>。</li></ul></li><li>信道划分介质访问控制：将使用介质的每个设备与来自同一信道上的其他设备的通信隔离开，把时域和频域资源合理地分配给网络上的设备。<ul><li>多路复用技术：<ul><li>把多个信号组合在一条物理信道上进行传输，使得多个计算机或终端设备共享信道资源,提高信道利用率。</li><li>把一条广播信道，逻辑上分成几条用于两个节点之间通信的互不干扰的子信道，实际就是把广播信道转变为点对点信道。</li><li><img src="/2021/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-Part3/image-20211211155217508.png" alt="image-20211211155217508" style="zoom:67%;"></li></ul></li><li><strong>频分复用技术 FDM</strong>：<ul><li>用户在分配到一定的频带后，在通信过程中自始至终都占用这个频带。频分复用的所有用户在同样的时间占用不同的带宽（频率带宽）资源。</li><li>优点：充分利用传输介质带宽，系统效率较高;由于技术比较成熟，实现也比较容易。</li><li><img src="/2021/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-Part3/image-20211211155523995.png" alt="image-20211211155523995" style="zoom:50%;"></li></ul></li><li><strong>时分多路复用 TDM</strong>：<ul><li>将时间划分为一段段等长的时分复用帧（TDM帧）。每一个时分复用的用户在每一个TDM帧中占用固定序号的时隙，所有用户轮流占用信道。</li><li>TDM 帧是在物理层传送的比特流所划分的帧，标志一个周期。</li><li><img src="/2021/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-Part3/image-20211211155553965.png" alt="image-20211211155553965" style="zoom:50%;"></li><li>改进的时分复用——统计时分复用 STDM：<ul><li>每一个STDM帧中的时隙数小于连接在集中器上的用户数。各用户有了数据就随时发往集中器的输入缓存，然后集中器按顺序依次扫描输入缓存，把缓存中的输入数据放入STDM帧中，一个STDM帧满了就发出。STDM帧不是固定分配时隙，而是按需动态分配时隙。</li><li><img src="/2021/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-Part3/image-20211211160122515.png" alt="image-20211211160122515" style="zoom: 67%;"></li></ul></li></ul></li><li><strong>波分多路复用 WDM</strong>：<ul><li>波分多路复用就是光的频分多路复用，在一根光纤中传输多种不同波长（频率）的光信号，由于波长（频率)不同，所以各路光信号互不干扰，最后再用波长分解复用器将各路波长分解出来。</li><li><img src="/2021/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-Part3/image-20211211160309680.png" alt="image-20211211160309680" style="zoom:50%;"></li></ul></li><li><strong>码分多路复用 CDM</strong>：<ul><li>码分多址（CDMA）是码分复用的一种方式。<ul><li>发送 1bit 的时间称为 <strong>1bit 的时隙时间</strong>。把 1bit 的时间<strong>分割为 n 位的芯片序列</strong>（可以看做是向量），即 <strong>n 个微时隙</strong>，每一个站点被指定一个唯一的 n 位的芯片序列。</li><li>站点在，发送 1 时即<strong>直接发送芯片序列</strong>（通常把 0 写成 -1），发送 0 时即<strong>发送芯片序列的反码</strong>。</li></ul></li><li>流程：<ul><li>多个站点同时发送数据的时候，要求各个站点<strong>芯片序列相互正交</strong>，<strong>规格化内积为 0</strong>。<ul><li><img src="/2021/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-Part3/image-20211212103543665.png" alt="image-20211212103543665" style="zoom:67%;"></li></ul></li><li>两个向量到了公共信道上，线性相加。<ul><li><img src="/2021/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-Part3/image-20211212103701770.png" alt="image-20211212103701770" style="zoom:67%;"></li></ul></li><li>数据分离：合并的数据和源站规格化内积。<ul><li><img src="/2021/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-Part3/image-20211212103732713.png" alt="image-20211212103732713" style="zoom:67%;"></li></ul></li></ul></li></ul></li></ul></li></ul><h3 id="随机访问介质访问控制"><a href="#随机访问介质访问控制" class="headerlink" title="随机访问介质访问控制"></a>随机访问介质访问控制</h3><h4 id="ALOHA-协议"><a href="#ALOHA-协议" class="headerlink" title="ALOHA 协议"></a>ALOHA 协议</h4><ul><li>纯 ALOHA 协议<ul><li>思想：不监听信道，不按时间槽发送，随机重发。</li><li>检测冲突：如果发生冲突，接收方在就会检测出差错，然后不予确认，发送方在一定时间内收不到就判断发生冲突。</li><li>解决冲突：超时后等一随机时间再重传。</li><li><img src="/2021/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-Part3/image-20211212104905851.png" alt="image-20211212104905851" style="zoom:67%;"></li></ul></li><li>时隙 ALOHA 协议<ul><li>思想：把时间分成若干个相同的时间片，所有用户在时间片开始时刻同步接入网络信道，若发生冲突，则必须等到下一个时间片开始时刻再发送。</li><li><img src="/2021/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-Part3/image-20211212104934017.png" alt="image-20211212104934017" style="zoom:67%;"></li></ul></li><li>区别：（不是很重点）<ul><li>纯 ALOHA 比时隙 ALOHA <strong>吞吐量更低，效率更低</strong>。</li><li>纯 ALOHA <strong>想发就发</strong>，时隙 ALOHA <strong>只有在时间片段开始时才能发</strong>。</li></ul></li></ul><h4 id="CSMA-协议"><a href="#CSMA-协议" class="headerlink" title="CSMA 协议"></a>CSMA 协议</h4><ul><li><p>载波监听多路访问协议 CSMA（carrier sense multiple access）</p><ul><li><strong>CS</strong>：载波侦听/监听，每一个站在发送数据之前要检测一下总线上是否有其他计算机在发送数据。</li><li><strong>MA</strong>：多点接入，表示许多计算机以多点接入的方式连接在一根总线上。</li><li><strong>协议思想：</strong>发送帧之前，<strong>监听</strong>信道。</li><li>监听结果：<ul><li>信道空闲 ：发送完整帧</li><li>信道忙 ：推迟发送</li></ul></li><li>行为分类：<ul><li>1-坚持CSMA</li><li>非坚持CSMA</li><li>p-坚持CSMA</li></ul></li></ul></li><li><p>1-坚持CSMA</p><ul><li>坚持指的是对于监听信道<strong>忙</strong>之后的坚持。</li><li>思想：如果一个主机要发送消息，那么它先监听信道。<ul><li><strong>空闲则直接传输，不必等待。</strong></li><li><strong>忙则一直监听，直到空闲马上传输。</strong></li><li>如果有冲突（一段时间内未收到肯定回复），则等待一个随机长的时间再监听，重复上述过程。</li></ul></li><li>优点：只要媒体空闲，站点就马上发送，避免了媒体利用率的损失。 </li><li>缺点：假如有两个或两个以上的站点有数据要发送，冲突就不可避免。</li></ul></li><li><p>非坚持CSMA</p><ul><li><p>非坚持指的是对于监听信道<strong>忙</strong>之后就不继续监听。</p></li><li><p>思想：如果一个主机要发送消息，那么它先监听信道。</p><ul><li><p><strong>空闲则直接传输，不必等待。</strong></p></li><li><p><strong>忙则等待一个随机的时间之后再进行监听。</strong></p></li></ul></li><li><p>优点：采用随机的重发延迟时间可以减少冲突发生的可能性。</p></li><li><p>缺点：可能存在大家都在延迟等待过程中，使得媒体仍可能处于空闲状态，媒体使用率降低。</p></li></ul></li><li><p>p-坚持CSMA</p><ul><li>p-坚持指的是对于监听信道<strong>空闲</strong>的处理。 </li><li>思想：如果一个主机要发送消息，那么它先监听信道。<ul><li><strong>空闲则以 p 概率直接传输，不必等待；概率 1-p 等待到下一个时间槽再传输。</strong></li><li><strong>忙则持续监听直到信道空闲再以 p 概率发送。</strong></li><li>若冲突则等到下一个时间槽开始再监听并重复上述过程。</li></ul></li><li>优点：既能像非坚持算法那样减少冲突，又能像1-坚持算法那样减少媒体空闲时间的这种方案。</li></ul></li><li><p>三者共同缺点：发生冲突后还是要坚持把数据帧发送完，造成了浪费。</p></li><li><p><img src="/2021/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-Part3/image-20211212110506181.png" alt="image-20211212110506181"></p></li></ul><h4 id="CSMA-CD-协议（非常重点）"><a href="#CSMA-CD-协议（非常重点）" class="headerlink" title="CSMA/CD 协议（非常重点）"></a>CSMA/CD 协议（非常重点）</h4><p><img src="/2021/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-Part3/image-20211215185127687.png" alt="image-20211215185127687"></p><ul><li>载波监听多点接入/碰撞检测，CSMA/CD（carrier sense multiple access with collision detection）<ul><li><strong>CS</strong>：载波侦听/监听，每一个站在<strong>发送数据之前</strong>以及<strong>发送数据时</strong>都要检测一下总线上是否有其他计算机在发送数据。</li><li><strong>MA</strong>：多点接入，表示许多计算机以多点接入的方式连接在一根总线上。</li><li><strong>CD</strong>：碰撞/冲突检测，“<strong>边发送边监听</strong>”，适配器边发送数据边检测信道上信号电压的变化情况，以便判断自己在发送数据时其他站是否也在发送数据。</li></ul></li><li><strong>传播时延对载波监听的影响</strong><ul><li>检测碰撞的时间：0~1τ</li><li><img src="/2021/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-Part3/image-20211212111810053.png" alt="image-20211212111810053" style="zoom:80%;"></li></ul></li><li><strong>确定碰撞后的重传时机</strong>(截断二进制指数规避算法)<ol><li>确定基本退避（推迟）时间为争用期 2τ。</li><li>定义参数 k，使得 **k=min[重传次数，10]**。</li><li>从离散的整数集合 <strong>[0, 1, … , 2k-1]</strong> 中随机取出一个数 r，重传所需要退避的时间就是 r 倍的基本退避时间，即 <strong>2r*τ</strong> 。</li><li>当重传达 <strong>16</strong> 次仍不能成功时，说明网络太拥挤，认为此帧永远无法正确发出，抛弃此帧并向高层报告出错。</li></ol></li><li><strong>最小帧长问题</strong><ul><li><strong>帧的传输时延至少要两倍于信号在总线中的传播时延</strong>。</li><li><img src="/2021/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-Part3/image-20211215184828238.png" alt="image-20211215184828238" style="zoom:80%;"></li><li>以太网规定最短帧长为 64B，凡是长度小于 64B 的都是由于冲突而异常终止的无效帧。</li></ul></li></ul><h4 id="CSMA-CA-协议（非重点）"><a href="#CSMA-CA-协议（非重点）" class="headerlink" title="CSMA/CA 协议（非重点）"></a>CSMA/CA 协议（非重点）</h4><ul><li>载波监听多点接入/碰撞避免，CSMA/CA（carrier sense multiple access with collision avoidance）</li><li>针对问题：CSMA/CD 无法应用于无线局域网<ul><li>无法做到 360° 全面检测碰撞</li><li>隐蔽站：当 A 和 C 都检测不到信号，认为信道空闲，从而导致同时向终端B发送数据帧，导致冲突</li></ul></li><li>工作原理<ol><li>发送数据前，先检测信道是否空闲。</li><li>空闲则发出 <strong>RTS（request to send）</strong>，包括发射端的地址、接收端的地址、下一份数据将持续发送的时间等信息；信道忙则等待。（可选步骤）</li><li>接收端收到 RTS 后，将响应 <strong>CTS（clear to send）</strong>。（可选步骤）</li><li>发送端收到 CTS 后，才开始发送数据帧（同时<strong>预约信道</strong>：发送方告知其他站点自己要传多久数据）。</li><li>接收端收到数据帧后，将用 CRC 来检验数据是否正确，正确则<strong>响应 ACK 帧</strong>。</li><li>发送方收到 ACK 就可以进行下一个数据帧的发送，若没有则一直重传至规定重发次数为止（采用<strong>二进制指数退避算法</strong>来确定随机的推迟时间）。</li></ol></li><li>CSMA/CD 与 CSMA/CA<ul><li><strong>相同点：</strong><ul><li>都从属于 CSMA 的思路，其核心是<strong>先听再说</strong>。</li><li>二者出现冲突后都会进行有上限的重传。</li></ul></li><li><strong>不同点：</strong><ul><li><strong>传输介质/应用场景不同</strong>：CSMA/CD 用于总线式以太网（有线网络），CSMA/CA 用于无线局域网（无线网络）。 </li><li>因传输介质不同，而<strong>载波检测方式不同</strong>：CSMA/CD 通过电缆中电压的变化来检测；CSMA/CA 采用能量检测（ED）、载波检测（CS）和能量载波混合检测。</li><li>核心目的：CSMA/CD 检测冲突，CSMA/CA 避免冲突。</li></ul></li></ul></li></ul><h3 id="轮询访问介质访问控制（存在重点）"><a href="#轮询访问介质访问控制（存在重点）" class="headerlink" title="轮询访问介质访问控制（存在重点）"></a>轮询访问介质访问控制（存在重点）</h3><ul><li><p>轮询协议</p><ul><li>主结点轮流询问从属结点发送数据。<ul><li><img src="/2021/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-Part3/image-20211215192553168.png" alt="image-20211215192553168" style="zoom:50%;"></li></ul></li><li>存在问题：1. 轮询开销；2.等待延迟；3.单点（主机）故障。</li></ul></li><li><p>令牌传递协议（重点）</p><ul><li>令牌：一个特殊格式的MAC控制帧，不含任何信息。<ul><li>控制信道的使用，确保同一时刻只有一个结点独占信道。</li><li>每个结点都可以在一定的时间内（令牌持有时间）获得发送数据的权利，并不是无限制地持有令牌。</li><li><img src="/2021/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-Part3/image-20211215192850642.png" alt="image-20211215192850642" style="zoom:67%;"></li><li>逻辑上为环形，物理上为星型</li></ul></li><li>问题：<ul><li>与轮询协议相同：1. 令牌开销；2. 等待延迟；3. 单点故障。</li><li>应用于令牌环网（物理星型拓扑，逻辑环形拓扑）。</li><li>采用令牌传送方式的网络常用于<strong>负载较重、通信量较大</strong>的网络中。</li></ul></li></ul></li></ul><h2 id="局域网"><a href="#局域网" class="headerlink" title="局域网"></a>局域网</h2><h3 id="局域网基本概念和体系结构"><a href="#局域网基本概念和体系结构" class="headerlink" title="局域网基本概念和体系结构"></a>局域网基本概念和体系结构</h3><p><img src="/2021/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-Part3/image-20211218213256062.png" alt="image-20211218213256062"></p><ul><li>局域网（Local Area Network）：简称 LAN，是指在<strong>某一区域内</strong>由多台计算机互联成的计算机组，使用<strong>广播信道</strong>（而不是点对点信道）。</li><li>特点：<ul><li>覆盖的地理范围较小，只在一个相对独立的局部范围内联，如一座或集中的建筑群内。</li><li>使用专门铺设的传输介质（双绞线、同轴电缆）进行联网，数据传输速率高（10Mb/s～10Gb/s）。</li><li>通信延迟时间短，误码率低，可靠性较高。</li><li>各站为平等关系，共享传输信道。</li><li>多采用分布式控制和广播式通信，能进行广播和组播。</li></ul></li><li>决定局域网的主要要素为：网络拓扑，传输介质与介质访问控制方法。</li><li><strong>局域网拓扑结构</strong><ul><li><img src="/2021/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-Part3/image-20211215194700897.png" alt="image-20211215194700897"></li></ul></li><li><strong>局域网传输介质</strong><ul><li>有线局域网：双绞线、同轴电缆、光纤</li><li>无线局域网：电磁波</li></ul></li><li><strong>局域网介质访问控制方法</strong><ul><li>CSMA/CD：常用于<strong>总线型局域网</strong>，也用于树型网络（基本不会考树形）</li><li>令牌总线：常用于<strong>总线型局域网</strong>，也用于树型网络</li><li>令牌环 ：用于<strong>环形局域网</strong>，如令牌环网</li></ul></li><li><strong>局域网的分类</strong><ul><li>以太网：以太网是应用最为广泛的局域网，包括标准以太网（10Mbps）、快速以太网（100Mbps）、千兆以太网（1000 Mbps）和10G以太网，它们都符合 IEEE802.3 系列标准规范。逻辑拓扑总线型，物理拓扑是星型或拓展星型。使用 CSMA/CD。</li><li>令牌环网：物理上采用了星形拓扑结构，逻辑上是环形拓扑结构。已弃用。</li><li>FDDI 网（Fiber Distributed Data Interface）：物理上采用了双环拓扑结构，逻辑上是环形拓扑结构。 （不需要记）</li><li>ATM 网（Asynchronous Transfer Mode）：较新型的单元交换技术，使用 53 字节固定长度的单元进行交换。</li><li>无限局域网（Wireless Local Area Network，WLAN）：采用 IEEE 802.11 标准。</li></ul></li><li>IEEE 802 标准<ul><li>IEEE 802 系列标准是 IEEE 802 LAN/MAN 标准委员会制定的局域网、城域网技术标准（1980年2月成立）。</li><li>其中最广泛使用的有以太网（802.3）、令牌环（802.5）、无线局域网（802.11）、光纤 FDDI（802.8）等。</li></ul></li><li>MAC 子层和 LLC 子层<ul><li>IEEE 802标准所描述的局域网参考模型只对应 OSI 参考模型的数据链路层与物理层，它将数据链路层划分为逻辑链路层 LLC 子层和介质访问控制 MAC 子层。</li><li>LLC 子层：<ul><li>LLC 负责识别网络层协议，然后对它们进行封装。</li><li>LLC 报头告诉数据链路层一旦帧被接收到时，应当对数据包做何处理。</li><li>为网络层提供服务：<strong>无确认无连接、面向连接、带确认无连接、高速传送</strong>。</li></ul></li><li>MAC 子层：<ul><li>MAC子层的主要功能包括数据<strong>帧的封装/卸装、帧的寻址和识别、帧的接收与发送、链路的管理、帧的差错控制</strong>等。</li><li>MAC子层的存在屏蔽了不同物理链路种类的差异性。</li></ul></li><li><img src="/2021/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-Part3/image-20211218212652373.png" alt="image-20211218212652373"></li></ul></li></ul><h3 id="以太网"><a href="#以太网" class="headerlink" title="以太网"></a>以太网</h3><p><img src="/2021/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-Part3/image-20211219173818591.png" alt="image-20211219173818591"></p><ul><li>以太网概述<ul><li>以太网（Ethernet）是由 Xerox 公司创建并由 Xerox、Intel、DEC 公司联合开发的<strong>基带总线局域网规范</strong>，是当今现有局域网采用的最通用的通信协议标准。</li><li>以太网络使用 <strong>CSMA/CD</strong>（载波监听多路访问及冲突检测）技术。</li></ul></li><li>以太网在局域网各种技术中占<strong>统治性</strong>地位：<ul><li>造价低廉（以太网网卡不到100块）；</li><li>是应用最广泛的局域网技术；</li><li>比令牌环网、ATM 网便宜，简单；</li><li>满足网络速率要求：10Mb/s~10Gb/s.</li></ul></li><li>以太网两个标准<ul><li>DIX Ethernet V2（以太网）：第一个局域网产品规约。</li><li>IEEE 802.3（802.3 局域网）：IEEE 802 委员会 802.3 工作组制定的第一个 IEEE 的以太网标准。（帧格式有细小的改动）</li></ul></li><li>以太网提供无连接、不可靠的服务<ul><li>无连接：发送方和接收方之间无“握手过程”。</li><li>不可靠：不对发送方的数据帧<strong>编号</strong>，接收方不向发送方进行<strong>确认</strong>，差错帧直接丢弃，差错纠正由高层负责。</li><li><strong>以太网只实现无差错接收，不实现可靠传输</strong>。</li></ul></li><li>以太网传输介质与拓扑结构的发展<ul><li>介质：粗同轴电缆 -&gt; 细同轴电缆 -&gt; 双绞线+集线器</li><li>物理拓扑：总线型 -&gt; 总线型 -&gt; 星型</li><li>逻辑上总线型，物理上星型。使用的还是 CSMA/CD 协议。</li></ul></li><li><strong>10BASE-T 以太网</strong>（常考！）<ul><li>10BASE-T 是传送<strong>基带信号</strong>的双绞线以太网，T 表示采用双绞线，现 10BASE-T 采用的是<strong>无屏蔽双绞线</strong>（UTP），传输速率是 <strong>10Mb/s</strong>。</li><li><strong>物理上星型拓扑，逻辑上总线型</strong>，每段双绞线最长为 <strong>100m</strong>。 </li><li>采用<strong>曼彻斯特编码</strong>。</li><li>采用 <strong>CSMA/CD 介质访问控制</strong>。 </li></ul></li><li>适配器与 MAC 地址<ul><li>计算机与外界有局域网的连接是通过<strong>通信适配器</strong>的。<ul><li>网络接口卡：NIC（Network Interface Card）</li><li>适配器上装有处理器和存储器（包括RAM和ROM）。</li><li>ROM上有计算机硬件地址 <strong>MAC</strong> 地址。</li></ul></li><li>在局域网中，硬件地址又称为物理地址，或 MAC 地址。</li><li>MAC 地址：每个适配器有一个全球唯一的 48 位二进制地址，前 24 位代表厂家（由 IEEE 规定），后 24 位厂家自己指定。常用 6 个十六进制数表示，如 02-60-8c-e4-b1-21。</li></ul></li><li>以太网 MAC 帧<ul><li><img src="/2021/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-Part3/image-20211219171554968.png" alt="image-20211219171554968" style="zoom:80%;"></li></ul></li><li>高速以太网<ul><li>速率 ≥100Mb/s 的以太网称为高速以太网。</li><li>100BASE-T以太网<ul><li>在双绞线上传送 100Mb/s 基带信号的星型拓扑以太网，仍使用 IEEE802.3 的 CSMA/CD 协议。</li><li>支持全双工和半双工，可在全双工方式下工作而无冲突（交换机隔离冲突域）。</li></ul></li><li>吉比特以太网<ul><li>在光纤或双绞线上传送 1Gb/s 信号。</li><li>支持全双工和半双工，可在全双工方式下工作而无冲突。</li></ul></li><li>10 吉比特<ul><li>10 吉比特以太网在光纤上传送 10Gb/s 信号。</li><li>只支持全双工，无争用问题。</li></ul></li></ul></li></ul><h3 id="无线局域网"><a href="#无线局域网" class="headerlink" title="无线局域网"></a>无线局域网</h3><ul><li><strong>IEEE 802.11</strong>：<ul><li>是<strong>无线局域网</strong>通用的标准，它是由 IEEE 所定义的无线网络通信的标准。</li><li>WIFI 属于无线局域网（IEEE 802.11 b、IEEE 802.11 g），但无线局域网的范围一般更大</li></ul></li><li>802.11 的 MAC 帧头格式：<ul><li><img src="/2021/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-Part3/image-20211219174356857.png" alt="image-20211219174356857" style="zoom:80%;"></li><li>假设 A 手机在基站 AP<del>1</del> 登记，B 手机在基站 AP<del>2</del> 登记，则<ul><li>接收端：mac(AP<del>2</del>)</li><li>发送端：mac(AP<del>1</del>)</li><li>目的地址：mac(B)</li><li>源地址：mac(A)</li></ul></li><li><img src="/2021/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-Part3/image-20211219175425414.png" alt="image-20211219175425414" style="zoom:80%;"></li></ul></li><li><strong>无线局域网的分类</strong>：<ul><li>有固定的基础设施无线局域网<ul><li><img src="/2021/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-Part3/image-20211219175650693.png" alt="image-20211219175650693" style="zoom:67%;"></li></ul></li><li>无固定基础设施无线局域网的自组织网络（基本不考）<ul><li><img src="/2021/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-Part3/image-20211219175727315.png" alt="image-20211219175727315" style="zoom:80%;"></li></ul></li></ul></li></ul><h2 id="广域网"><a href="#广域网" class="headerlink" title="广域网"></a>广域网</h2><p><img src="/2021/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-Part3/image-20211219214621576.png" alt="image-20211219214621576"></p><h3 id="概览-1"><a href="#概览-1" class="headerlink" title="概览"></a>概览</h3><ul><li>广域网（WAN，Wide Area Network），通常跨接很大的物理范围，所覆盖的范围从几十公里到几千公里，能连接多个城市或国家、横跨几个洲并能提供远距离通信，形成国际性的远程网络。</li><li>广域网的通信子网主要使用<strong>分组交换</strong>技术。可以利用公用分组交换网、卫星通信网和无线分组交换网，将分布在不同地区的<strong>局域网或计算机系统</strong>互连起来，达到<strong>资源共享</strong>的目的。</li><li>因特网（Internet）是世界范围内最大的广域网。</li><li><img src="/2021/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-Part3/image-20211219180702012.png" alt="image-20211219180702012" style="zoom:80%;"></li></ul><h3 id="PPP-协议和-HDLC-协议"><a href="#PPP-协议和-HDLC-协议" class="headerlink" title="PPP 协议和 HDLC 协议"></a>PPP 协议和 HDLC 协议</h3><ul><li>PPP 协议<ul><li>点对点协议PPP（Point-to-Point Protocol）是目前使用最广泛的数据链路层协议，用户使用拨号电话接入因特网时一般都使用 PPP 协议。</li><li>特点：只支持全双工链路。</li><li>需要满足的要求：<ul><li>简单：对于链路层的帧，无需纠错，无需序号，无需流量控制</li><li>封装成帧：帧定界符</li><li>透明传输：与帧定界符一样比特组合的数据应该如何处理：异步线路用字节填充，同步线路用比特填充</li><li>多种网络层协议：封装的 IP 数据报可以采用多种协议</li><li>多种类型链路：串行/并行，同步/异步，电/光……</li><li>差错检测：CRC，错就丢弃</li><li>检测连接状态 ：链路是否正常工作</li><li>最大传送单元：数据部分最大长度 MTU</li><li>网络层地址协商：知道通信双方的网络层地址</li><li>数据压缩协商</li></ul></li><li>无需满足的要求：（为了更快的传输速率）<ul><li>纠错</li><li>流量控制</li><li>序号</li><li>不支持多点线路</li></ul></li><li>三个组成部分<ul><li>一个将 IP 数据报封装到串行链路（同步串行/异步串行）的方法</li><li>链路控制协议 LCP：建立并维护数据链路连接（身份验证）</li><li>网络控制协议 NCP：PPP 可支持多种网络层协议，每个不同的网络层协议都要一个相应的 NCP 来配置，为网络层协议建立和配置逻辑连接</li></ul></li><li>状态图<ul><li><img src="/2021/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-Part3/image-20211219181135816.png" alt="image-20211219181135816" style="zoom: 67%;"></li></ul></li><li>帧格式<ul><li><img src="/2021/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-Part3/image-20211219181314070.png" alt="image-20211219181314070" style="zoom:67%;"></li></ul></li></ul></li><li>HDLC 协议：<ul><li>高级数据链路控制（High-Level Data Link Control或简称HDLC），是一个在同步网上传输数据、<strong>面向比特</strong>的数据链路层协议，它是由国际标准化组织(<strong>ISO</strong>)根据IBM公司的 SDLC(SynchronousData Link Control)协议扩展开发而成的.<ul><li>数据报文可透明传输，用于实现透明传输的“0比特插入法”易于硬件实现 </li><li>采用全双工通信</li><li>所有帧采用 CRC 检验，对信息帧进行顺序编号，可防止漏收或重份，传输可靠性高。</li></ul></li><li>主站、从站、复合站<ul><li>主站的主要功能是发送命令（包括数据信息）帧、接收响应帧，并负责对整个链路的控制系统的初启、流程的控制、差错检测或恢复等。</li><li>从站的主要功能是接收由主站发来的命令帧，向主站发送响应帧，并且配合主站参与差错恢复等链路控制。</li><li>复合站的主要功能是既能发送，又能接收命令帧和响应帧，并且负责整个链路的控制。</li></ul></li><li>三种数据操作方式：<ul><li>正常响应方式</li><li>异步平衡方式</li><li>异步响应方式</li></ul></li><li>帧格式<ul><li><img src="/2021/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-Part3/image-20211219182554499.png" alt="image-20211219182554499" style="zoom:80%;"></li><li>控制C（记住三种类型即可“无奸细”）<ul><li>信息帧：开头为 0，⽤来传输数据信息，或使⽤捎带技术对数据进⾏确认</li><li>监督帧：开头为 10，⽤于流量控制和差错控制，执⾏对信息帧的确认、请求重发和请求暂停发送等功能</li><li>⽆编号帧：开头为 11，⽤于提供对链路的建⽴、拆除等多种控制功能。</li></ul></li></ul></li></ul></li><li>PPP协议＆HDLC协议<ul><li>HDLC、PPP 都只支持<strong>全双工</strong>链路。</li><li>都可以实现透明传输。（PPP 协议既可以比特填充，也可以字节填充；HDLC 只能比特填充“5110”）</li><li>都可以实现差错检测，但不纠正差错。</li><li>PPP 协议：<ul><li>面向字节</li><li>2B 协议字段</li><li>无序号和确认机制</li><li>不可靠</li></ul></li><li>HDLC 协议：<ul><li>面向比特</li><li>没有协议字段</li><li>有编号和确认机制</li><li>可靠</li></ul></li></ul></li></ul><h2 id="链路层设备"><a href="#链路层设备" class="headerlink" title="链路层设备"></a>链路层设备</h2><p><img src="/2021/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-Part3/image-20211220135420209.png" alt="image-20211220135420209"></p><ul><li><strong>物理层扩展以太网</strong><ul><li><img src="/2021/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-Part3/image-20211220131953915.png" alt="image-20211220131953915" style="zoom:80%;"></li></ul></li><li><strong>链路层扩展以太网</strong><ul><li>网桥&amp;交换机，根据 <strong>MAC 帧的目的地址</strong>对帧进行<strong>转发和过滤</strong>。<ul><li>当网桥收到一个帧时，并不像集线器那样向所有接口转发此帧，而是先检查此帧的目的 MAC 地址，然后再确定将该帧转发到哪一个接口，或者是把它丢弃（即过滤）。</li></ul></li><li>网桥优点：<ul><li>过滤通信量，增大吞吐量。</li><li>扩大了物理范围。</li><li>提高了可靠性。</li><li>可互连不同物理层、不同 MAC 子层和不同速率的以太网。</li></ul></li><li>网段：一般指一个计算机网络中使用同一物理层设备（传输介质，中继器，集线器等）能够直接通讯的那一部分。<ul><li>一个冲突域就是一个网段</li><li><img src="/2021/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-Part3/image-20211220132426109.png" alt="image-20211220132426109"></li></ul></li><li>网桥分类<ul><li><strong>透明网桥：</strong>“透明”指以太网上的站点并不知道所发送的帧将经过哪几个网桥，是一种即插即用设备——自学习。<ul><li>每次在网桥的转发表中，只记录源地址的方向，过滤目的地址。</li><li>只要连接网桥上的每一个主机都作为源地址发送一次信息，那么网桥就可以理解以太网的拓扑结构了。</li><li>会经常清空转发表重新学习，以获取最新的网络拓扑。</li><li><img src="/2021/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-Part3/image-20211220134014812.png" alt="image-20211220134014812" style="zoom:80%;"></li></ul></li><li><strong>源路由网桥：</strong>在发送帧时，把详细的最佳路由信息（路由最少/时间最短）放在帧的首部中。<ul><li><strong>方法：</strong>源站以广播方式向欲通信的目的站发送一个<strong>发现帧</strong>。</li><li>到达终点时原路返回起点，以获得最短路径。</li></ul></li></ul></li></ul></li><li>多接口网桥——以太网交换机：<ul><li>可以独占传输媒体带宽</li><li><img src="/2021/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-Part3/image-20211220134640767.png" alt="image-20211220134640767" style="zoom:80%;"></li></ul></li><li>以太网交换机的两种交换方式<ul><li>直通式交换机：<ul><li>只检查目的地址（<strong>6B</strong>）就立刻转发。</li><li>延迟小，可靠性低，无法支持具有不同速率的端口的交换。</li></ul></li><li>存储转发式交换机：<ul><li>将帧放入高速缓存，并检查否正确，正确则转发，错误则丢弃。</li><li>延迟大，可靠性高，可以支持具有不同速率的端口的交换。</li></ul></li></ul></li><li>冲突域和广播域<ul><li><strong>冲突域</strong>：在同一个冲突域中的每一个节点都能收到所有被发送的帧。简单的说就是同一时间内只能有一台设备发送信息的范围。 </li><li><strong>广播域</strong>：网络中能接收任一设备发出的广播帧的所有设备的集合。简单的说如果站点发出一个广播信号，所有能接收到这个信号的设备范围称为一个广播域。</li></ul></li></ul><table><thead><tr><th></th><th><strong>能否隔离冲突域</strong></th><th><strong>能否隔离广播域</strong></th></tr></thead><tbody><tr><td>物理层设备（中继器、集线器）</td><td>不行</td><td>不行</td></tr><tr><td>链路层设备（网桥、交换机）</td><td>可以</td><td>不行</td></tr><tr><td>网络层设备（路由器）</td><td>可以</td><td>可以</td></tr></tbody></table>]]></content>
    
    
    <summary type="html">数据链路层</summary>
    
    
    
    <category term="计算机网络" scheme="https://nephrencake.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
  </entry>
  
  <entry>
    <title>计算机网络-Part2</title>
    <link href="https://nephrencake.github.io/2021/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-Part2/"/>
    <id>https://nephrencake.github.io/2021/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-Part2/</id>
    <published>2021-12-03T05:55:52.000Z</published>
    <updated>2022-06-25T06:41:46.303Z</updated>
    
    <content type="html"><![CDATA[<h1 id="计算机网络-Part2——物理层"><a href="#计算机网络-Part2——物理层" class="headerlink" title="计算机网络-Part2——物理层"></a>计算机网络-Part2——物理层</h1><p>[TOC]</p><p><img src="/2021/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-Part2/image-20211205133036029.png" alt="image-20211205133036029"></p><h2 id="通信基础"><a href="#通信基础" class="headerlink" title="通信基础"></a>通信基础</h2><h3 id="物理层基本概念"><a href="#物理层基本概念" class="headerlink" title="物理层基本概念"></a>物理层基本概念</h3><ul><li>物理层解决如何在连接各种计算机的传输媒体上<strong>传输数据比特流</strong>，而不是指具体的传输媒体（传输介质不包括于物理层）。</li><li>物理层主要任务：确定与传输媒体<strong>接口</strong>有关的一些特性（定义标准）</li><li>物理层接口特性<ul><li>机械特性：定义物理连接的特性，规定物理连接时所采用的规格、接口形状、<strong>引线数目</strong>、<strong>引脚数量</strong>和排列情况。</li><li>电气特性：规定传输二进制位时，线路上信号的<strong>电压范围</strong>、阻抗匹配、传输<strong>速率</strong>和<strong>距离</strong>限制等。<ul><li>某网络在物理层规定，信号的电平用+10V～+15V表示二进制0，用−10V～−15V表示二进制1，电线长度限于15m以内</li></ul></li><li>功能特性：指明某条线上出现的某一<strong>电平表示何种意义</strong>，接口部件的信号线的用途。<ul><li>描述一个物理层接口引脚处于高电平时的含义时（一般不会出现数字）</li></ul></li><li>规程特性（过程特性）：定义各条物理线路的工作<strong>规程和时序</strong>关系。</li></ul></li></ul><h3 id="数据通信基础知识"><a href="#数据通信基础知识" class="headerlink" title="数据通信基础知识"></a>数据通信基础知识</h3><p><img src="/2021/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-Part2/image-20211206121555060.png" alt="image-20211206121555060"></p><ul><li>典型的数据通信模型<ul><li><img src="/2021/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-Part2/image-20211205133834588.png" alt="image-20211205133834588"></li></ul></li><li>数据通信相关术语<ul><li>数据通信<ul><li>指在不同计算机之间传输表示信息的二进制数 0、1 序列的过程。</li><li>目的，是传送消息（消息：语音、文字、图像、视频等）。</li></ul></li><li>数据：传送信息的实体，通常是有意义的符号序列。</li><li>信号：数据的电气/电磁的表现，是数据在传输过程中的<strong>存在形式</strong>。<ul><li><img src="/2021/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-Part2/image-20211205133944619.png" alt="image-20211205133944619" style="zoom:80%;"></li></ul></li><li>信源：产生和发送数据的源头。</li><li>信宿：接收数据的终点 。</li><li>信道：信号的传输媒介。一般用来表示向某一个方向传送信息的介质，因此一条通信线路往往包含一 条发送信道和一条接收信道。<ul><li><img src="/2021/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-Part2/image-20211205134022389.png" alt="image-20211205134022389" style="zoom:80%;"></li></ul></li></ul></li><li>三种数据通信方式<ul><li>单工通信<ul><li>只有一个方向的通信而没有反方向的交互，仅需要<strong>一条</strong>信道。</li></ul></li><li>半双工通信/双向交替通信<ul><li>通信的双方都可以发送或接收信息，但任何一方都不能同时发送和接收，</li><li>需要<strong>两条</strong>信道（信道类似于矢量）。</li></ul></li><li>全双工通信/双向同时通信<ul><li>通信双方可以同时发送和接受信息，也需要<strong>两条</strong>信道。</li></ul></li></ul></li><li>两种传输方式<ul><li>串行传输<ul><li>将表示一个字符的8位二进制数按由低位到高位的顺序依次发送。</li><li>速度<strong>慢</strong>，费用<strong>低</strong>，适合<strong>远</strong>距离</li></ul></li><li>并行传输<ul><li>将表示一个字符的8位二进制数同时通过8条信道发送。</li><li>速度<strong>快</strong>，费用<strong>高</strong>，适合<strong>近</strong>距离</li></ul></li></ul></li><li>实现同步的传输/通信方式<ul><li>同步传输：在同步传输的模式下，数据的传送是以一个<strong>数据区块</strong>为单位，因此同步传输又称为区块传输。在传送数据时，需先送出1个或多个同步字符，再送出整批的数据。</li><li>异步传输：异步传输将比特分成小组进行传送，小组可以是8位的1个字符或更长。发送方可以在任何时刻发送这些比特组，而接收方不知道它们会在什么时候到达。传送数据时，加一个字符起始位和一个字符终止位。</li></ul></li><li>码元<ul><li>指用一个<strong>固定时长的信号波形</strong>（数字脉冲）代表不同离散数值的基本波形，是数字通信中数字信号的计量单位，这个时长内的信号称为 <strong>k 进制码元</strong>，而该时长称为<strong>码元宽度</strong>。</li><li>当码元的离散状态有 M 个时（M ＞ 2），此时码元为 M 进制码元。</li><li><strong>1 码元可以携带多个比特的信息量</strong>。<ul><li>在使用二进制编码时，只有两种不同的码元，一种代表 0 状态，另一种代表 1 状态。</li><li>在使用四进制编码时，有四种不同的码元，分别为 00/0110/11。</li></ul></li></ul></li><li>速率<ul><li>速率也叫数据率，是指<strong>数据的传输速率</strong>，表示单位时间内传输的数据量。可以用<strong>码元传输速率</strong>和<strong>信息传输速率</strong>表示。<ul><li><strong>码元传输速率</strong>：别名码元速率、波形速率、调制速率、符号速率等，它表示<strong>单位时间内数字通信系统所传输的码元个数</strong>（也可称为<strong>脉冲个数</strong>或<strong>信号变化的次数</strong>），单位是<strong>波特</strong>（Baud）。1 波特表示数字通信系统每秒传输一个码元。<ul><li><strong>码元速率与进制数无关</strong>，只与<strong>码元长度T</strong>有关。</li><li>$$R_{B} = \frac{1}{T} (B)$$</li></ul></li><li><strong>信息传输速率</strong>：别名信息速率、比特率等，表示单位时间内数字通信系统传输的二进制码元个数（即比特数），单位是比特/秒（b/s）。</li><li>关系：若一个码元携带 n bit 的信息量，则 M Baud 的码元传输速率所对应的信息传输速率为 M×n bit/s。</li><li><img src="/2021/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-Part2/image-20211205184138618.png" alt="image-20211205184138618" style="zoom: 80%;"></li></ul></li></ul></li><li>带宽（Bandwidth）<ul><li><strong>模拟信号系统中</strong>：最高频率和最低频率间的差值就代表了系统的通频带宽，单位为**赫兹(Hz)**。（了解）</li><li><strong>数字设备中</strong>：表示在单位时间内能通过的<strong>最高数据率</strong>（单位时间内通过链路的数量），常用来表示网络的通信线路所能传输数据的能力。 单位是**比特每秒(bps)**。</li></ul></li></ul><h3 id="奈氏准则和香农定理（重要）"><a href="#奈氏准则和香农定理（重要）" class="headerlink" title="奈氏准则和香农定理（重要）"></a>奈氏准则和香农定理（重要）</h3><ul><li>影响失真程度的因素：1. 码元传输速率；2. 信号传输距离；3. 噪声干扰；4. 传输媒体质量</li><li>码间串扰：<strong>接收端</strong>收到的信号波形失去了码元之间清晰界限的<strong>现象</strong>。</li><li>奈氏准则（奈奎斯特定理）<ul><li>在理想低通（无噪声，带宽受限）条件下，为了避免码间串扰，极限码元传输速率为 2*W Baud，W 是信道带宽，单位是 Hz。<ul><li><img src="/2021/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-Part2/image-20211205185635334.png" alt="image-20211205185635334" style="zoom:67%;"></li></ul></li><li>推论<ul><li>在任何信道中，码元传输的速率是有<strong>上限</strong>的。若传输速率超过此上限，就会出现严重的码间串扰问题，使接收端对码元无法正确识别。</li><li>信道的<strong>频带越宽</strong>（即能通过的信号高频分量越多），就可以用更高的速率进行码元的有效传输。</li><li>奈氏准则给出了码元传输速率的限制，但并没有对信息传输速率给出限制。</li><li>由于码元的传输速率受奈氏准则的制约，所以要提高数据的传输速率，就必须设法使每个码元能携带更多个比特的信息量，这就需要采用多元制的调制方法。</li></ul></li></ul></li><li>香农定理<ul><li><strong>噪声</strong>存在于所有的电子设备和通信信道中。由于噪声随机产生，它的瞬时值有时会很大，因此噪声会使接收端对码元的判决产生错误。但是噪声的影响是相对的，若信号较强，那么噪声影响相对较小。<ul><li>因此，信噪比就很重要。信噪比=<strong>信号</strong>的平均功率/<strong>噪声</strong>的平均功率，常记为S/N，并用分贝（dB）作为度量单位，即：</li><li><img src="/2021/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-Part2/image-20211205190151682.png" alt="image-20211205190151682" style="zoom:80%;"></li></ul></li><li>香农定理：在带宽受限且有噪声的信道中，为了不产生误差，信息的数据传输速率有上限值。<ul><li><img src="/2021/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-Part2/image-20211205185848058.png" alt="image-20211205185848058" style="zoom: 67%;"></li></ul></li><li>推论<ul><li>信道的<strong>带宽</strong>或信道中的<strong>信噪比</strong>越大，则信息的极限传输速率就<strong>越高</strong>。</li><li>对一定的传输带宽和一定的信噪比，信息传输速率的上限就确定了。 </li><li>只要信息的传输速率低于信道的极限传输速率，就一定能找到某种方法来实现<strong>无差错的传输</strong>。</li><li>香农定理得出的为极限信息传输速率，实际信道能达到的传输速率要比它低不少。 </li><li>从香农定理可以看出，若信道带宽W或信噪比S/N没有上限（不可能），那么信道的极限信息传输速率也就没有上限。</li></ul></li></ul></li><li><img src="/2021/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-Part2/image-20211205191024013.png" alt="image-20211205191024013"><ul><li>当两个方法都是用时，都计算，并选择其较小的一个结果</li></ul></li></ul><h3 id="编码与调制（重要）"><a href="#编码与调制（重要）" class="headerlink" title="编码与调制（重要）"></a>编码与调制（重要）</h3><p><img src="/2021/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-Part2/image-20211206121502139.png" alt="image-20211206121502139"></p><ul><li><strong>信道</strong>：信号的传输媒介。一般用来表示向某一个方向传送信息的介质，因此一条通信线路往往包含一条发送信道和一条接收信道。<ul><li>按传输信号分：1. 模拟信道（传送模拟信号）；2. 数字信道（传送数字信号）。</li><li>按传输介质分：1. 无线信道；2. 有线信道</li></ul></li><li>信道上传送的信号<ul><li>基带信号：将数字信号1和0直接用两种不同的电压表示，再送到<strong>数字信道</strong>上去传输（<strong>基带传输</strong>）。<ul><li>基带信号，是<strong>来自信源</strong>的信号，是发出的<strong>直接表达了要传输的信息的信号</strong>，计算机输出的数据信号、我们说话的声波都是基带信号。</li></ul></li><li>宽带信号：将基带信号进行调制后形成的频分复用模拟信号，再传送到模拟信道上去传输（<strong>宽带传输</strong>）。<ul><li>把基带信号经过<strong>载波调制</strong>后，把信号的<strong>频率范围搬移</strong>到<strong>较高的频段</strong>以便在信道中传输（即仅在一段频率范围内能够通过信道）。</li></ul></li><li>应用场景：<ul><li>在传输距离较近时，计算机网络采用<strong>基带传输</strong>方式（近距离衰减小，从而信号内容不易发生变化）</li><li>在传输距离较远时，计算机网络采用<strong>宽带传输</strong>方式（远距离衰减大，即使信号变化大也能最后过滤出来基带信号）</li></ul></li></ul></li><li>编码与调制<ul><li><img src="/2021/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-Part2/image-20211205193430091.png" alt="image-20211205193430091" style="zoom:80%;"></li><li>编码：把数据转为数字信号的过程</li><li>调制：把数字信号转为模拟信号的过程</li></ul></li><li>数字数据编码为数字信号<ul><li><img src="/2021/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-Part2/image-20211205194356706.png" alt="image-20211205194356706" style="zoom:80%;"></li><li>非归零编码（NRZ）：编码容易实现；但没有检错功能、无法判断一个码元的开始和结束、收发双方<strong>难以保持同步</strong>。</li><li>归零编码（RZ）：信号电平在一个码元之内都要恢复到零的这种编码成编码方式。</li><li>反向不归零编码（NRZI）：信号电平翻转表示 0，信号电平不变表示 1。</li><li>曼彻斯特编码：前低后高为 1、前高后低为 0，相反亦可。<ul><li>特点：每个码元中间<strong>都有电平跳变</strong>，既作时钟信号（可用于同步），又作数据信号；但所占的频带宽度是原始的两倍、数据传输速率<strong>只有调制速率的 1/2</strong>。</li></ul></li><li>差分曼彻斯特编码：同 1 异 0<ul><li>若码元为 1，则前半个码元的电平与上一个码元的后半个码元的电平相同，若为0，则相反。</li><li>特点：每个码元中间<strong>都有电平跳变</strong>，且抗干扰性<strong>强</strong>于曼彻斯特编码。</li></ul></li><li>4B/5B 编码<ul><li>用第 5 个比特位来包装 4 个比特位的数据（帧的开始和结束，线路的状态信息等）。编码效率为 80%。</li></ul></li></ul></li><li>数字数据调制为模拟信号<ul><li>数字数据调制技术在发送端将数字信号转换为模拟信号，而在接收端将模拟信号还原为数字信号，分别对应于调制解调器的调制和解调过程。</li><li><img src="/2021/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-Part2/image-20211205200743328.png" alt="image-20211205200743328" style="zoom:80%;"></li><li>调幅+调相（QAM）：<strong>做题时遇到 n 个相位 m 种振幅，则可知有 n*m 种码元（n*m 进制码元），需要机器用 log<del>2</del>(n*m) 个 bit 来表示</strong>。</li></ul></li><li>模拟数据编码为数字信号<ul><li>计算机内部处理的是二进制数据，处理的都是<strong>数字音频</strong>，所以需要将模拟音频通过采样、量化转换成有限个数字表示的离散序列（即实现<strong>音频数字化</strong>）。</li><li>例如，对音频信号进行编码的脉码调制（<strong>PCM</strong>），能够达到<strong>最高保真水平</strong>。</li><li>过程<ul><li>抽样：对模拟信号周期性扫描，把时间上<strong>连续的信号变成离散的信号</strong>。<ul><li>为了使所得的离散信号能无失真地代表被抽样的模拟数据，要使用采样定理进行采样：</li><li>f<del>采样频率</del> ≥ 2 * f<del>信号最高频率</del></li></ul></li><li>量化：把抽样取得的电平幅值按照分级标度转化为对应的<strong>整数值</strong>，即把连续的电平幅值转换为离散的数字量。</li><li>编码：把量化的结果转换为与之对应的二进制编码。</li></ul></li></ul></li><li>模拟数据调制为模拟信号<ul><li>为了实现传输的有效性，可能需要较高的频率。这种调制方式可以使用<strong>频分复用技术</strong>，充分利用带宽资源。模拟的声音数据是加载到模拟的载波信号中传输的。</li><li>例如：在电话机和本地交换机所传输的信号</li></ul></li></ul><h3 id="数据交换方式（重要）"><a href="#数据交换方式（重要）" class="headerlink" title="数据交换方式（重要）"></a>数据交换方式（重要）</h3><ul><li><p><strong>电路（线路）交换</strong></p><ul><li>原理：在数据传输期间，源结点与目的结点之间有一条由中间结点构成的<strong>专用物理连接线路</strong>，在数据传输结束之前，这条线路一直保持。</li><li>特点：<ul><li><strong>独占资源</strong>，用户始终占用端到端的固定传输带宽。</li><li>适用于远程批处理信息传输或系统间<strong>实时性要求高</strong>、<strong>大量数据传输</strong>的情况。</li></ul></li><li><img src="/2021/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-Part2/image-20211206122433869.png" alt="image-20211206122433869" style="zoom:80%;"></li><li><img src="/2021/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-Part2/image-20211206122457184.png" alt="image-20211206122457184"></li></ul></li><li><p><strong>报文交换</strong>(Message Exchanging)</p><ul><li>报文，是网络中交换与传输的数据单元，即站点<strong>一次性要发送的数据块</strong>。报文包含了将要发送的完整的数据信息，其长短很不一致，长度不限且可变。</li><li>原理：无需在两个站点之间建立一条专用通路，其数据传输的单位是报文。采用<strong>存储转发</strong>方式。</li><li><img src="/2021/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-Part2/image-20211206123015772.png" alt="image-20211206123015772"></li><li><img src="/2021/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-Part2/image-20211206122844463.png" alt="image-20211206122844463"></li></ul></li><li><p><strong>分组交换</strong>(Packet Exchanging)</p><ul><li><p>分组：大多数计算机网络都不能连续地传送任意长的数据，所以实际上网络系统把数据分割成小块，然后逐块地发送，这种小块就称作分组（packet）。</p></li><li><p>原理：</p><ul><li>分组交换与报文交换的工作方式基本相同，<strong>都采用存储转发方式</strong>，形式上的主要差别在于，分组交换网中要<strong>限制所传输的数据单位的长度</strong>，一般选 128B。</li><li><strong>发送节点</strong>首先对从终端设备送来的数据报文进行接收、存储，而后将报文划分成一定长度的分组，并以分组为单位进行传输和交换。<strong>接收结点</strong>将收到的分组组装成信息或报文。</li></ul></li><li><p><img src="/2021/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-Part2/image-20211206123615739.png" alt="image-20211206123615739"></p></li><li><p><img src="/2021/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-Part2/image-20211206123652425.png" alt="image-20211206123652425"></p></li><li><p>数据交换方式的选择</p><ul><li><img src="/2021/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-Part2/image-20211206124243420.png" alt="image-20211206124243420"></li></ul></li><li><p><strong>数据报方式</strong></p><ul><li>流程<ul><li>源主机（A）<strong>将报文分成多个分组</strong>，依次发送到直接相连的结点（A）。</li><li>结点A收到分组后，对每个分组<strong>差错检测</strong>和<strong>路由选择</strong>，不同分组的下一跳结点可能不同。</li><li>结点 C 收到分组 P1 后，对分组 P1 进行<strong>差错检测</strong>，若正确则向 A 发送<strong>确认信息</strong>，A 收到 C 确认后则丢弃分组 P1 副本。</li><li>所有分组到达目标主机（B）</li></ul></li><li>特点<ul><li><strong>数据报方式</strong>为网络层提供<strong>无连接服务</strong>。即，发送方可随时发送分组，网络中的结点可随时接收分组。</li><li>同一报文的不同分组达到目的结点时可能发生<strong>乱序、重复与丢失</strong>。</li><li>每个分组在传输过程中都必须携带<strong>源地址、目的地址、分组号</strong>。</li><li>导致时延的情况：1. 分组在交换结点存储转发时，需要排队等候处理；2. 通过交换结点的通信量较大或网络发生拥塞，此时交换结点还可根据情况丢弃部分分组。</li><li>网络具有冗余路径，当某一交换结点或一段链路出现故障时，可相应地更新转发表，寻找另一条路径转发分组。对故障的适应能力强，适用于突发性通信，不适于长报文、会话式通信。</li></ul></li><li><img src="/2021/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-Part2/image-20211206130257240.png" alt="image-20211206130257240"></li></ul></li><li><p><strong>虚电路方式</strong></p><ul><li>虚电路：<ul><li>结合数据报方式和电路交换方式，发挥两者优点。</li><li>一条源主机到目的主机类似于电路的路径（<strong>逻辑连接</strong>），路径上所有结点都要维持这条虚电路的建立，都维持一张虚电路表，每一项记录了一个打开的虚电路的信息。</li></ul></li><li>流程<ul><li><img src="/2021/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-Part2/image-20211206131854783.png" alt="image-20211206131854783" style="zoom:80%;"></li></ul></li><li>特点<ul><li><strong>虚电路方式</strong>为网络层提供<strong>连接服务</strong>。源节点与目的结点之间建立一条逻辑连接，而非实际物理连接。</li><li>一次通信的所有分组都通过虚电路顺序传送，分组不需携带源地址、目的地址等信息，只包含<strong>虚电路号</strong>，相对数据报方式开销小，同一报文的不同分组到达目的结点时不会乱序、重复或丢失。</li><li>分组通过虚电路上的每个节点时，节点只进行差错检测，不需进行路由选择。</li><li>每个节点可能与多个节点之间建立<strong>多条虚电路</strong>（不独占），每条虚电路支持特定的两个端系统之间的数据传输，可以在两个数据端点之间进行<strong>流量控制</strong>，两个端系统之间也可以有多条虚电路为<strong>不同的进程</strong>服务。</li><li>致命弱点：当网络中的某个结点或某条链路出故障而彻底失效时，则所有经过该结点或该链路的虚电路将遭到破坏</li></ul></li></ul></li><li><p><img src="/2021/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-Part2/image-20211206132026937.png" alt="image-20211206132026937"></p></li></ul></li></ul><h2 id="物理层传输介质"><a href="#物理层传输介质" class="headerlink" title="物理层传输介质"></a>物理层传输介质</h2><p><img src="/2021/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-Part2/image-20211206121626839.png" alt="image-20211206121626839"></p><ul><li><strong>传输介质</strong>，也称<strong>传输媒体/传输媒介</strong>，它就是数据传输系统中在发送设备和接收设备之间的<strong>物理通路</strong>。<ul><li><strong>传输媒体并不是物理层</strong>。</li></ul></li><li>导向传输介质<ul><li>双绞线<ul><li>双绞线，是古老、又最常用的传输介质，由<strong>两根</strong>采用一定规则并排<strong>绞合</strong>的、相互绝缘的<strong>铜导线</strong>组成。<ul><li><strong>绞合可以减少对相邻导线的电磁干扰</strong>。</li><li>为了进一步提高抗电磁干扰能力，可在双绞线的外面再加上一个由<strong>金属丝</strong>编织成的屏蔽层，即<strong>屏蔽双绞线</strong>（STP），无屏蔽层的则称为<strong>非屏蔽双绞线</strong>（UTP）。</li></ul></li><li>特点：<ul><li>价格<strong>便宜</strong>，是最常用的传输介质之一，在局域网和传统电话网中普遍使用。</li><li>模拟传输和数字传输都可以使用双绞线，其通信距离一般为几公里到数十公里。</li><li>距离太远时，对于<strong>模拟传输</strong>，要用<strong>放大器</strong>放大衰减的信号；对于<strong>数字传输</strong>，要用<strong>中继器</strong>将失真的信号整形。</li></ul></li><li><img src="/2021/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-Part2/image-20211206133115815.png" alt="image-20211206133115815" style="zoom:80%;"></li></ul></li><li>同轴电缆<ul><li>同轴电缆由<strong>导体铜质芯线</strong>、<strong>绝缘层</strong>、<strong>网状编织屏蔽层</strong>和<strong>塑料外层</strong>构成。</li><li>按特性阻抗数值的不同，通常将同轴电缆分为两类：<ul><li>50Ω同轴电缆主要用于传送基带数字信号，又称为<strong>基带同轴电缆</strong>，在<strong>局域网</strong>中得到广泛应用；</li><li>75Ω同轴电缆主要用于传送宽带信号，又称为<strong>宽带同轴电缆</strong>，主要用于<strong>有线电视系统</strong>。</li></ul></li><li>由于外导体屏蔽层的作用，同轴电缆<strong>抗干扰特性</strong>比双绞线好，被广泛用于传输较高速率的数据，其<strong>传输距离</strong>更远，但<strong>价格</strong>较双绞线贵。</li><li><img src="/2021/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-Part2/image-20211206133400309.png" alt="image-20211206133400309" style="zoom:80%;"></li></ul></li><li>光纤<ul><li>光纤通信，利用光导纤维（光纤）传递光脉冲进行通信。有光脉冲表示1，无光脉冲表示0。<ul><li>可见光的频率大约是 108MHz，因此光纤通信系统的<strong>带宽远远大于</strong>目前其他各种传输媒体。</li><li>光纤主要由纤芯（实心的）和包层（低折射率）构成，入射角足够大，就会出现全反射，从而传输下去</li><li><img src="/2021/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-Part2/image-20211206134627537.png" alt="image-20211206134627537" style="zoom:80%;"></li></ul></li><li>特点：<ul><li>传输<strong>损耗小</strong>，中继距离长，对远距离传输特别经济。</li><li><strong>抗雷电和电磁干扰性能好</strong>。</li><li>无串音干扰，保密性好，也<strong>不易被窃听或截取数据</strong>。</li><li><strong>体积小，重量轻</strong>。</li></ul></li><li><img src="/2021/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-Part2/image-20211206133438500.png" alt="image-20211206133438500" style="zoom:80%;"></li></ul></li></ul></li><li>非导向传输介质<ul><li>无线电波（信号向所有方向传播）<ul><li>较强<strong>穿透能力</strong>，可传远距离，广泛用于通信领域（如手机通信）。</li></ul></li><li>微波（信号固定方向传播）<ul><li>微波通信频率较高、频段范 围宽，因此数据率很高。</li><li>可用于<ul><li>地面微波接力通信</li><li>卫星通信<ul><li>优点：<ul><li>通信容量大</li><li>距离远</li><li>覆盖广</li><li>广播通信和多址通信</li></ul></li><li>缺点：<ul><li>传播时延长（250-270ms）</li><li>受气候影响大（eg：强风、太阳黑子爆发、日凌）</li><li>误码率较高</li><li>成本高（指卫星）</li></ul></li></ul></li></ul></li></ul></li><li>红外线、激光（信号固定方向传播）<ul><li>把要传输的信号分别<strong>转换为各自的信号格式</strong>（相比微波的区别），即红外光信号和激光信号，再在空间中传播。</li></ul></li></ul></li></ul><h2 id="物理层设备"><a href="#物理层设备" class="headerlink" title="物理层设备"></a>物理层设备</h2><ul><li>中继器<ul><li><strong>诞生原因</strong>：由于存在损耗，在线路上传输的信号功率会逐渐衰减，衰减到一定程度时将造成信号失真，因此会导致接收错误。</li><li><strong>中继器的功能</strong>： 对<strong>数字信号</strong>进行<strong>再生和还原</strong>，对衰减的信号进行放大，保持与原数据相同，以增加信号传输的距离，延长网络的长度。</li><li><strong>中继器的两端</strong>：两端的网络部分是网段，而不是子网，适用于完全相同的<strong>两类</strong>网络的互连，且两个网段速率要相同。<ul><li>中继器只将任何电缆段上的数据发送到另一段电缆上，它仅作用于信号的电气部分，并不管数据中是否有错误数据或不适于网段的数据（<strong>不会校验</strong>）。</li><li>两端可连相同媒体，也可连不同媒体。 </li><li>中继器两端的网段一定要是同一个协议。（<strong>不会存储转发</strong>）</li></ul></li><li><strong>5-4-3规则：</strong>网络标准中都对信号的延迟范围作了具体的规定，因而中继器只能在规定的范围内进行，否则会网络故障。<ul><li>最多只能由 5 个网段（一个中继器连两个网段）、4 个物理设备（中继器或集线器）、只有三个段可以连接计算机</li><li><img src="/2021/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-Part2/image-20211206140813646.png" alt="image-20211206140813646"></li></ul></li></ul></li><li>集线器（多口中继器）<ul><li><strong>集线器的功能</strong>： 对信号进行再生<strong>放大转发</strong>，对衰减的信号进行放大，接着转发到其他所有（除输入端口外）处于工作状态的端口上，以增加信号传输的距离，延长网络的长度。</li><li>不具备信号的定向传送能力，是一个共享式设备（广播）。</li><li><img src="/2021/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-Part2/image-20211206141116263.png" alt="image-20211206141116263" style="zoom:80%;"></li></ul></li></ul>]]></content>
    
    
    <summary type="html">物理层</summary>
    
    
    
    <category term="计算机网络" scheme="https://nephrencake.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
  </entry>
  
  <entry>
    <title>计算机网络-Part1</title>
    <link href="https://nephrencake.github.io/2021/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-Part1/"/>
    <id>https://nephrencake.github.io/2021/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-Part1/</id>
    <published>2021-12-03T05:55:21.000Z</published>
    <updated>2022-02-10T10:45:23.524Z</updated>
    
    <content type="html"><![CDATA[<h1 id="计算机网络-Part1——计算机网络体系结构"><a href="#计算机网络-Part1——计算机网络体系结构" class="headerlink" title="计算机网络-Part1——计算机网络体系结构"></a>计算机网络-Part1——计算机网络体系结构</h1><p>[TOC]</p><p><img src="/2021/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-Part1/image-20211205131631404.png" alt="image-20211205131631404"></p><h2 id="408计算机网络大纲【考查目标】"><a href="#408计算机网络大纲【考查目标】" class="headerlink" title="408计算机网络大纲【考查目标】"></a>408计算机网络大纲【考查目标】</h2><ol><li><p>掌握计算机网络的<strong>基本概念、基本原理和基本方法</strong>。 </p></li><li><p>掌握计算机网络的<strong>体系结构</strong>和典型<strong>网络协议</strong>，了解典型<strong>网络设备</strong>的组成和特点，理解典型网络设备的工作原理。</p></li><li><p>能够运用计算机网络的基本概念、基本原理和基本方法进行<strong>网络系统的分析、设计和应用</strong>。</p></li></ol><h2 id="计算机网络概述"><a href="#计算机网络概述" class="headerlink" title="计算机网络概述"></a>计算机网络概述</h2><h3 id="概念及功能"><a href="#概念及功能" class="headerlink" title="概念及功能"></a>概念及功能</h3><img src="/2021/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-Part1/image-20211204141800509.png" alt="image-20211204141800509" style="zoom:80%;"><ul><li><p>计算机网络：是一个将分散的、具有独立功能的<strong>计算机系统</strong>，通过<strong>通信设备与线路</strong>连接起来，由功能<strong>完善的软件</strong>实现<strong>资源共享</strong>和<strong>信息传递</strong>的系统。</p></li><li><p>计算机网络是<strong>互连的、自治的</strong>计算机集合。</p><ul><li>互连：通过通信链路互联互通</li><li>自治：无主从关系</li></ul></li><li><p>功能：</p><ul><li>数据通信<ul><li>通信指的是<strong>两台主机各自的一个进程之间</strong>的通信</li></ul></li><li>资源共享（网络打印机）</li><li>分布式处理（Hadoop）<ul><li>提高可靠性</li><li>负载均衡</li></ul></li></ul></li><li><p>发展：</p><ul><li>第一阶段：<ul><li>ARPAnet 阿帕网（无线分组交换网&amp;卫星通信网）</li><li>internet(interconnected network) 互联网（希望实现不同网络互联）</li><li>Internet 因特网（1983年阿帕网接受 TCP/IP 选定 Internet 为主要的计算机通信系统）<ul><li>因特网是世界上最大的互联网。</li></ul></li></ul></li><li>第二阶段（三级结构）：<ul><li>国家科学基金网 NSFNET。</li></ul></li><li>第三阶段（多层次 ISP 结构）：<ul><li><strong>ISP</strong>：因特网服务提供者/因特网服务提供商，是一个向广大用户综合提供互联网接入业务、信息业务、和增值业务的公司，如中国电信、中国联动、中国移动等。分为主干 ISP、地区 ISP 和本地 ISP。</li><li><img src="/2021/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-Part1/image-20211204141621780.png" alt="image-20211204141621780" style="zoom: 67%;"></li></ul></li></ul></li></ul><h3 id="组成与分类"><a href="#组成与分类" class="headerlink" title="组成与分类"></a>组成与分类</h3><p><img src="/2021/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-Part1/image-20211204143531048.png" alt="image-20211204143531048"></p><p>组成</p><ul><li>组成部分：硬件、软件、协议（一系列规则和约定的集合）</li><li>工作方式：<ul><li>边缘部分：用户直接使用<ul><li>C/S（client-server）方式：专门的的提供和被服务对象</li><li>P2P（peer-to-peer）方式：人人为我，我为人人</li></ul></li><li>核心部分：为边缘部分服务</li></ul></li><li>功能组成：<ul><li>通信子网：实现数据通信</li><li>资源子网：实现资源共享 /数据处理</li><li><img src="/2021/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-Part1/image-20211204143007160.png" alt="image-20211204143007160" style="zoom:67%;"></li></ul></li></ul><p>分类</p><ul><li>按分布范围：广域网WAN（交换技术）、城域网MAN、局域网LAN（广播技术）、个人区域网PAN<ul><li>优先按传输技术来区分广域网、局域网</li></ul></li><li>按使用者：公用网、专用网</li><li>按交换技术：<strong>电路交换</strong>（独享占线，结束释放资源）、<strong>报文交换</strong>（存储转发，整体）、<strong>分组交换</strong>（存储转发，切分）</li><li>按拓扑结构：<img src="/2021/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-Part1/image-20211204143437137.png" alt="image-20211204143437137"><ul><li>网状型常用于广域网</li></ul></li><li>按传输技术：<strong>广播式网络</strong>（共享公共通信信道，总线型）、<strong>点对点网络</strong>（使用<strong>分组存储转发</strong>和<strong>路由选择</strong>机制，网状型）</li></ul><h3 id="标准化工作及相关组织（大纲已删）"><a href="#标准化工作及相关组织（大纲已删）" class="headerlink" title="标准化工作及相关组织（大纲已删）"></a>标准化工作及相关组织（大纲已删）</h3><ul><li>标准分类：<ul><li>法定标准：由权威机构指定的正式、合法的标准（如，OSI）</li><li>事实标准：公司产品在竞争中占据了主流（如，TCP/IP、NanoSIM卡）</li></ul></li><li>RCP（Request For Comments）上升为因特网正式标准的四个阶段<ol><li>因特网草案（Internet Draft）这个阶段还不是 RFC 文档。</li><li>建议标准（Proposed Standard）从这个阶段开始成为 RFC 文档。</li><li>草案标准（Draft Standard）现在已经无了</li><li>因特网标准（Internet Standard）</li></ol></li><li>标准化工作的相关组织<ul><li>国际标准化组织 ISO：OSI 模型、HDLC 协议</li><li>国际电信联盟 ITU：制定通信规则</li><li>电气和电子工程师协会 IEEE：学术机构、IEEE802 系列标准、5G</li><li>lnternet 工程任务组 ETF：负责因特网相关标准的制定 RFC XXXX</li></ul></li></ul><h3 id="性能指标（重要）"><a href="#性能指标（重要）" class="headerlink" title="性能指标（重要）"></a>性能指标（重要）</h3><ul><li>速率<ul><li>速率（即数据率、数据传输率、比特率）。</li><li>连接在计算机网络上的<strong>主机</strong>在数字信道上传送数据<strong>位数的速率</strong>。</li><li><img src="/2021/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-Part1/image-20211204145448528.png" alt="image-20211204145448528" style="zoom:80%;"></li></ul></li><li>带宽<ul><li>带宽，表示网络的通信线路传送数据的能力，指单位时间内从网络中的某一点到另一点所能通过的<strong>最高数据率</strong>。单位是“比特每秒”，b/s，kb/s，Mb/s，Gb/s。</li></ul></li><li>吞吐量（严格受速率、带宽影响）<ul><li>吞吐量，表示在单位时间内通过某个网络（或信道、接口）的数据量。单位 b/s</li><li>吞吐量受网络的带宽或网络的额定速率的限制。</li><li><img src="/2021/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-Part1/image-20211204161447674.png" alt="image-20211204161447674" style="zoom:80%;"></li></ul></li><li>时延<ul><li>指数据（报文/分组/比特流）从网络（或链路）的一端传送到另一端所需的时间。也叫延迟或迟延。单位是s。<ul><li>发送时延是在主机上发生的，是打包数据的一个过程</li></ul></li><li><img src="/2021/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-Part1/image-20211204162252397.png" alt="image-20211204162252397" style="zoom:80%;"></li></ul></li><li>时延带宽积<ul><li>时延带宽积又称为以<strong>比特为单位的链路长度</strong>。即“某段链路现在有多少比特”。</li><li><strong>时延带宽积（bit）=传播时延（s） X 带宽（b/s）</strong></li><li><img src="/2021/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-Part1/image-20211204162602897.png" alt="image-20211204162602897" style="zoom:80%;"></li></ul></li><li>往返时间 RTT<ul><li>从发送方发送数据开始，到发送方收到接收方的确认（接收方收到数据后立即发送确认），总共经历的时延。<ul><li>RTT 越大，在收到确认之前，可以发送的数据越多。</li></ul></li><li>RTT 包括：往返传播时延 = 传播时延 * 2 + 末端处理时间</li></ul></li><li>利用率<ul><li><img src="/2021/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-Part1/image-20211204162734961.png" alt="image-20211204162734961" style="zoom:80%;"></li></ul></li></ul><h2 id="计算机网络体系结构与参考模型"><a href="#计算机网络体系结构与参考模型" class="headerlink" title="计算机网络体系结构与参考模型"></a>计算机网络体系结构与参考模型</h2><h3 id="分层结构、协议、接口、服务"><a href="#分层结构、协议、接口、服务" class="headerlink" title="分层结构、协议、接口、服务"></a>分层结构、协议、接口、服务</h3><ul><li>分层的基本原则：<ol><li>各层之间相互<strong>独立</strong>，每层只实现一种相对独立的功能。</li><li>每层之间<strong>界面自然清晰</strong>，易于理解，相互交流尽可能少。</li><li>结构上可分割开。每层都采用<strong>最合适的技术</strong>来实现。</li><li>保持<strong>下层对上层的独立性</strong>，<strong>上层单向使用下层提供的服务</strong>。</li><li>整个分层结构应该能促进标准化工作。</li></ol></li><li>分层结构：<ul><li>实体：第 n 层中的活动元素称为 <strong>n 层实体</strong>。同一层的实体叫<strong>对等实体</strong>。</li><li>协议：为进行网络中的<strong>对等实体</strong>数据交换而建立的规则、标准或约定称为网络协议。（水平）<ul><li>语法：规定传输数据的格式</li><li>语义：规定所要完成的功能</li><li>同步：规定各种操作的顺序</li></ul></li><li>接口（访问服务点 SAP）：上层使用下层服务的入口。</li><li>服务：下层为相邻上层提供的功能调用。（垂直）</li><li><img src="/2021/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-Part1/image-20211204164510627.png" alt="image-20211204164510627"></li><li>SDU 服务数据单元：为完成用户所要求的功能而应传送的数据。</li><li>PCI 协议控制信息：控制协议操作的信息。</li><li>PDU 协议数据单元：对等层次之间传送的数据单位。</li></ul></li><li>概念总结：<ul><li>网络体系结构是从<strong>功能</strong>上描述计算机网络结构。</li><li>计算机网络体系结构，简称网络体系结构，是<strong>分层结构</strong>。</li><li>每层遵循某个/些<strong>网络协议</strong>以完成本层功能。</li><li><strong>计算机网络体系结构</strong>是计算机网络的<strong>各层及其协议</strong>的集合。</li><li>第 n 层在向 n+1 层提供服务时，此服务不仅包含第 n 层本身的功能，还包含由下层服务提供的功能。</li><li>仅仅在<strong>相邻层间有接口</strong>，且所提供服务的具体实现细节对上一层完全屏蔽。</li><li>体系结构是<strong>抽象</strong>的，而实现是指能运行的一些软件和硬件。</li></ul></li></ul><h3 id="ISO-OSI-参考模型（重要）"><a href="#ISO-OSI-参考模型（重要）" class="headerlink" title="ISO/OSI 参考模型（重要）"></a>ISO/OSI 参考模型（重要）</h3><ul><li>目的：支持异构网络系统的互联互通。<ul><li>国际标准化组织（ISO）于1984年提出开放系统互连（OSI）参考模型。理论成功，市场失败。</li></ul></li><li>记忆技巧：<ul><li><img src="/2021/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-Part1/image-20211204165949730.png" alt="image-20211204165949730" style="zoom:67%;"></li></ul></li><li>ISO/OSI 参考模型解释通信过程<ul><li><img src="/2021/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-Part1/image-20211204170249416.png" alt="image-20211204170249416"></li><li>记忆：由于数据链路层是5个字，比其他的多2个字，因此不仅头部要加，尾部也要加。</li><li><img src="/2021/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-Part1/image-20211204170440095.png" alt="image-20211204170440095"></li></ul></li><li>应用层<ul><li>所有能和用户交互产生网络流量的程序</li><li>典型应用层服务：<ul><li>文件传输（FTP）</li><li>电子邮件（SMTP）</li><li>万维网（HTTP）</li></ul></li></ul></li><li>表示层<ul><li>功能<ul><li>数据格式变换</li><li>数据加密解密</li><li>数据压缩和恢复</li></ul></li><li>主要协议：JPEG、ASCII</li></ul></li><li>会话层<ul><li>向表示层实体/用户进程提供<strong>建立连接</strong>并在连接上<strong>有序</strong>地<strong>传输</strong>数据。适用于传输大文件。</li><li>这是会话，也是<strong>建立同步</strong>（SYN）</li><li>功能<ul><li>建立、管理、终止会话</li><li>使用校验点可使会话在通信失效时从<strong>校验点/同步点</strong>继续恢复通信，实现<strong>数据同步</strong>。</li></ul></li><li>主要协议：ADSP、ASP</li></ul></li><li>传输层<ul><li>负责主机中<strong>两个进程</strong>的通信，即<strong>端到端的通信</strong>。</li><li>传输单位是<strong>报文段</strong>或<strong>用户数据报</strong>。</li><li>功能<ul><li><strong>可</strong>靠传输、不可靠传输<ul><li>可靠：必须收到确认才发送下一段数据</li><li>不可靠：直接尽可能快地发送</li></ul></li><li><strong>差</strong>错控制</li><li><strong>流</strong>量控制</li><li>复<strong>用</strong>分用<ul><li>复用：多个应用层进程可同时使用下面运输层的服务。</li><li>分用：运输层把收到的信息分别交付给上面应用层中相应的进程。</li></ul></li></ul></li></ul></li><li>网络层（重要）<ul><li>主要任务是把<strong>分组</strong>从源端传到目的端，为分组交换网上的不同主机提供通信服务。</li><li>网络层传输单位是<strong>数据报</strong>。（将数据报切割成分组）</li><li>功能<ul><li>路由选择</li><li>流量控制</li><li>差错控制</li><li>拥塞控制<ul><li>若所有结点都来不及接受分组，而要丢弃大量分组的话，网络就处于<strong>拥塞</strong>状态。因此要采取一定措施，缓解这种拥塞。</li></ul></li></ul></li><li>主要协议：IP、IPX、ICMP、IGMP、ARP、RARP、OSPF</li></ul></li><li>数据链路层<ul><li>主要任务是把网络层传下来的数据报<strong>组装成帧</strong>。</li><li>数据链路层/链路层的传输单位是<strong>帧</strong>。</li><li>功能<ul><li>成帧（定义帧的开始和结束）</li><li>差错控制（帧错+位错）</li><li>流量控制</li><li>访问/接入控制（控制对信道的访问）</li></ul></li><li>主要协议：SDLC、HDLC、PPP、STP</li></ul></li><li>物理层<ul><li>主要任务是在<strong>物理媒体</strong>上实现比特流的<strong>透明传输</strong>。<ul><li>透明传输：指不管所传数据是什么样的比特组合,都应当能够在链路上传送。</li></ul></li><li>物理层传输单位是<strong>比特</strong>。</li><li>功能<ul><li>定义接口特性</li><li>定义传输模式（单工、半双工、双工）</li><li>定义传输速率</li><li>比特同步</li><li>比特编码</li></ul></li><li>主要协议：Rj45、802.3</li></ul></li></ul><h3 id="TCP-IP-参考模型（重要）"><a href="#TCP-IP-参考模型（重要）" class="headerlink" title="TCP/IP 参考模型（重要）"></a>TCP/IP 参考模型（重要）</h3><ul><li><img src="/2021/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-Part1/image-20211205130054831.png" alt="image-20211205130054831"></li><li>相同点：<ul><li>都分层</li><li>基于独立的协议栈的概念</li><li>可以实现异构网络互联</li></ul></li><li>不同点：<ul><li>OSI 定义三点：服务、协议、接口 </li><li>OSI 先出现，参考模型先于协议发明，不偏向特定协议</li><li>TCP/IP 设计之初就考虑到异构网互联问题，将 IP 作为重要层次</li><li><img src="/2021/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-Part1/image-20211205130712299.png" alt="image-20211205130712299"><ul><li>面向连接分为三个阶段：1. 建立连接，发出一个建立连接的请求；2. 只有在连接成功建立之后，才能开始数据传输；3. 数据传输完毕时，必须释放连接。</li><li>面向无连接：直接进行数据传输。</li></ul></li></ul></li><li><strong>5层参考模型</strong><ul><li><img src="/2021/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-Part1/image-20211205130931484.png" alt="image-20211205130931484"></li><li><img src="/2021/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-Part1/image-20211205130951873.png" alt="image-20211205130951873"></li></ul></li></ul>]]></content>
    
    
    <summary type="html">计算机网络体系结构</summary>
    
    
    
    <category term="计算机网络" scheme="https://nephrencake.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
  </entry>
  
  <entry>
    <title>Python后端部署-Part5</title>
    <link href="https://nephrencake.github.io/2021/11/Python%E5%90%8E%E7%AB%AF%E9%83%A8%E7%BD%B2-Part5/"/>
    <id>https://nephrencake.github.io/2021/11/Python%E5%90%8E%E7%AB%AF%E9%83%A8%E7%BD%B2-Part5/</id>
    <published>2021-11-22T11:46:38.000Z</published>
    <updated>2021-11-26T09:24:00.929Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Python后端部署-Part5——MySQL数据库容器"><a href="#Python后端部署-Part5——MySQL数据库容器" class="headerlink" title="Python后端部署-Part5——MySQL数据库容器"></a>Python后端部署-Part5——MySQL数据库容器</h1><p>[TOC]</p><h2 id="服务器-Mysql-容器配置"><a href="#服务器-Mysql-容器配置" class="headerlink" title="服务器 Mysql 容器配置"></a>服务器 Mysql 容器配置</h2><blockquote><p>参考：<a href="https://www.cnblogs.com/sablier/p/11605606.html#%E4%B8%80%E3%80%81%E5%AE%89%E8%A3%85docker">https://www.cnblogs.com/sablier/p/11605606.html#%E4%B8%80%E3%80%81%E5%AE%89%E8%A3%85docker</a></p></blockquote><h3 id="创建-MySQL-的-Docker-容器"><a href="#创建-MySQL-的-Docker-容器" class="headerlink" title="创建 MySQL 的 Docker 容器"></a>创建 MySQL 的 Docker 容器</h3><ol><li><p>拉取官方镜像（暂时选择5.7）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker pull mysql:5.7   <span class="comment"># 拉取 mysql 5.7</span></span><br></pre></td></tr></table></figure></li><li><p>检查是否拉取成功</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker images</span><br></pre></td></tr></table></figure></li><li><p>创建容器，暂时不建立目录映射</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -p 9050:3306 --name WebService_mysql -e MYSQL_ROOT_PASSWORD=password1 -d mysql:5.7</span><br></pre></td></tr></table></figure><ul><li>–name：容器名，此处命名为 <code>mysql</code></li><li>-e：配置 mysql 的 root 用户的登陆密码</li><li>-p：映射主机9050端口到容器的3306端口</li><li>-d：后台运行容器，保证在退出终端后容器继续运行</li></ul></li><li><p>如果要建立目录映射</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -p 9050:3306 --name WebService_mysql \</span><br><span class="line">    -v /usr/<span class="built_in">local</span>/docker/mysql/conf:/etc/mysql \</span><br><span class="line">    -v /usr/<span class="built_in">local</span>/docker/mysql/logs:/var/<span class="built_in">log</span>/mysql \</span><br><span class="line">    -v /usr/<span class="built_in">local</span>/docker/mysql/data:/var/lib/mysql \</span><br><span class="line">    -e MYSQL_ROOT_PASSWORD=password1 \</span><br><span class="line">    -d mysql:5.7</span><br></pre></td></tr></table></figure><ul><li>-v：主机和容器的目录映射关系，”:”前为主机目录，之后为容器目录</li></ul></li><li><p>检查容器是否正确运行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker ps</span><br></pre></td></tr></table></figure><h3 id="连接-MySql"><a href="#连接-MySql" class="headerlink" title="连接 MySql"></a>连接 MySql</h3></li><li><p>需要进入 docker 本地客户端设置远程访问账号（否则只能在容器内连接数据库）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker <span class="built_in">exec</span> -it mysql bash</span><br><span class="line">$ mysql -uroot -ppassword1</span><br><span class="line">mysql&gt; grant all privileges on *.* to root@<span class="string">&#x27;%&#x27;</span> identified by <span class="string">&quot;password2&quot;</span>;</span><br></pre></td></tr></table></figure></li><li><p>使用远程连接软件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">host: 127.0.0.1</span><br><span class="line">port: 9050</span><br><span class="line">user: root</span><br><span class="line">password: password2</span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    
    <summary type="html">MySQL数据库容器</summary>
    
    
    
    <category term="Python后端部署" scheme="https://nephrencake.github.io/categories/Python%E5%90%8E%E7%AB%AF%E9%83%A8%E7%BD%B2/"/>
    
    
  </entry>
  
  <entry>
    <title>Python后端部署-Part4</title>
    <link href="https://nephrencake.github.io/2021/11/Python%E5%90%8E%E7%AB%AF%E9%83%A8%E7%BD%B2-Part4/"/>
    <id>https://nephrencake.github.io/2021/11/Python%E5%90%8E%E7%AB%AF%E9%83%A8%E7%BD%B2-Part4/</id>
    <published>2021-11-22T11:46:34.000Z</published>
    <updated>2021-11-26T09:24:10.549Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Python后端部署-Part4——uWSGI与Nginx部署"><a href="#Python后端部署-Part4——uWSGI与Nginx部署" class="headerlink" title="Python后端部署-Part4——uWSGI与Nginx部署"></a>Python后端部署-Part4——uWSGI与Nginx部署</h1><p>[TOC]</p><h2 id="uWSGI"><a href="#uWSGI" class="headerlink" title="uWSGI"></a>uWSGI</h2><h3 id="WSGI-与-uWSGI"><a href="#WSGI-与-uWSGI" class="headerlink" title="WSGI 与 uWSGI"></a>WSGI 与 uWSGI</h3><ul><li>WSGI：<ul><li>WSGI（Web Server Gateway Interface 或者 Python Web Server Gateway Interface），是为 Python 语言定义的 Web 服务器和 Web 应用或框架之间的一种简单而通用的接口。</li><li>WSGI，是网关（Gateway）。网关的作用就是在协议之间进行转换。</li><li>很多框架都自带了 WSGI server，如 Flask、Django 等。但性能都不好，自带的 WebServer 更多的是测试用途，发布时则使用生产环境的 WSGI server。</li></ul></li><li>uWSGI：<ul><li>是一个Web服务器，实现了 WSGI、uwsgi、http 等协议。<ul><li>uwsgi 协议是 uWSGI 服务器自有的协议，用于定义传输信息的类型。</li><li>每一个 uwsgi packet 前 4byte 为传输信息类型描述，uwsgi 与 WSGI 相比是两样东西。</li></ul></li><li>Nginx 中 HttpUwsgiModule 的作用是与 uWSGI 服务器进行交换。</li></ul></li><li>WSGI / uwsgi / uWSGI 区分：<ul><li>WSGI 是一种通信协议。</li><li>uwsgi 同 WSGI 一样是一种通信协议。</li><li>uWSGI 是实现了 uwsgi 和 WSGI 两种协议的 Web 服务器。</li></ul></li><li>为什么有了 uWSGI 为什么还需要 nginx？<ul><li>因为 nginx 具备优秀的静态内容处理能力，然后将动态内容转发给 uWSGI 服务器，这样可以达到很好的客户端响应。 </li></ul></li></ul><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pip install uwsgi<span class="comment"># 安装</span></span><br><span class="line">uwsgi --version    <span class="comment"># 查看 uwsgi 版本</span></span><br></pre></td></tr></table></figure><h3 id="自定义配置文件（常用）"><a href="#自定义配置文件（常用）" class="headerlink" title="自定义配置文件（常用）"></a>自定义配置文件（常用）</h3><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[uwsgi]</span></span><br><span class="line"><span class="comment"># 项目所在的根目录</span></span><br><span class="line"><span class="attr">chdir</span> = /data/WebService/backend</span><br><span class="line"><span class="comment"># 指定项目的application,启动程序文件</span></span><br><span class="line"><span class="comment"># wsgi-file = WebService/wsgi.py</span></span><br><span class="line"><span class="attr">module</span> = WebService.wsgi</span><br><span class="line"><span class="comment"># 指定sock的文件路径，这个sock文件会在nginx的uwsgi_pass配置，用来nginx与uwsgi通信       </span></span><br><span class="line"><span class="comment"># 支持 ip+port 模式以及 socket file 模式</span></span><br><span class="line"><span class="comment"># socket = %(chdir)/uwsgi_conf/uwsgi.sock</span></span><br><span class="line"><span class="attr">socket</span> = <span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">8000</span></span><br><span class="line"><span class="comment"># 指定IP端口，web访问入口</span></span><br><span class="line"><span class="attr">http</span> = <span class="number">0.0</span>.<span class="number">0.0</span>:<span class="number">8000</span></span><br><span class="line"><span class="comment"># 进程个数、线程数</span></span><br><span class="line"><span class="attr">processes</span> = <span class="number">2</span></span><br><span class="line"><span class="attr">threads</span> = <span class="number">4</span></span><br><span class="line"><span class="comment"># 每个进程worker数</span></span><br><span class="line"><span class="attr">workers</span> = <span class="number">5</span></span><br><span class="line"><span class="comment"># uwsgi的进程名称前缀</span></span><br><span class="line"><span class="attr">procname-prefix-spaced</span> = WebService</span><br><span class="line"><span class="comment"># py文件修改，自动加载</span></span><br><span class="line"><span class="attr">py-autoreload</span> = <span class="number">1</span></span><br><span class="line"><span class="comment"># 指定多个静态文件：static目录和media目录,也可以不用指定该静态文件，在nginx中配置静态文件目录</span></span><br><span class="line"><span class="comment"># uwsgi有自己的配置语法，详细可参考官网，无需写绝对路径，可以用循环、判断等高级配置语法</span></span><br><span class="line"><span class="attr">for</span> = static media</span><br><span class="line"><span class="attr">static-map</span> = /static=%(chdir)/static</span><br><span class="line"><span class="comment"># 启动uwsgi的用户名和用户组</span></span><br><span class="line"><span class="attr">uid</span> = root</span><br><span class="line"><span class="attr">gid</span> = root</span><br><span class="line"><span class="comment"># 启动主进程，来管理其他进程，其它的uwsgi进程都是这个master进程的子进程，如果kill这个master进程，相当于重启所有的uwsgi进程。</span></span><br><span class="line"><span class="attr">master</span> = <span class="literal">true</span></span><br><span class="line"><span class="comment"># 当服务停止的时候自动移除unix Socket和pid文件</span></span><br><span class="line"><span class="attr">vacuum</span> = <span class="literal">true</span></span><br><span class="line"><span class="comment"># 序列化接受的内容，如果可能的话</span></span><br><span class="line"><span class="attr">thunder-lock</span> = <span class="literal">true</span></span><br><span class="line"><span class="comment"># 启用线程</span></span><br><span class="line"><span class="attr">enable-threads</span> = <span class="literal">true</span></span><br><span class="line"><span class="comment"># 设置一个超时，用于中断那些超过服务器请求上限的额外请求</span></span><br><span class="line"><span class="attr">harakiri</span>=<span class="number">30</span></span><br><span class="line"><span class="attr">http-timeout</span> = <span class="number">180</span></span><br><span class="line"><span class="attr">socket-timeout</span> = <span class="number">180</span></span><br><span class="line"><span class="comment"># 设置缓冲</span></span><br><span class="line"><span class="attr">post-buffering</span>=<span class="number">4096</span></span><br><span class="line"><span class="attr">buffer-size</span> = <span class="number">65536</span></span><br><span class="line"><span class="comment"># 设置日志目录</span></span><br><span class="line"><span class="attr">daemonize</span>=%(chdir)/uwsgi_conf/uwsgi.log</span><br><span class="line"><span class="comment"># uWSGI进程号存放</span></span><br><span class="line"><span class="attr">pidfile</span>=%(chdir)/uwsgi_conf/uwsgi.pid</span><br><span class="line"><span class="comment"># monitor uwsgi status  通过该端口可以监控 uwsgi 的负载情况</span></span><br><span class="line"><span class="comment"># 支持 ip+port 模式以及 socket file 模式</span></span><br><span class="line"><span class="comment"># stats=%(chdir)/uwsgi_conf/uwsgi.status </span></span><br><span class="line"><span class="attr">stats</span> = <span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">9001</span></span><br><span class="line"><span class="attr">max-requests</span> = <span class="number">1000</span>   </span><br></pre></td></tr></table></figure><h3 id="指令（常用）"><a href="#指令（常用）" class="headerlink" title="指令（常用）"></a>指令（常用）</h3><ul><li>启动 uWSGI：<code>uwsgi --ini uwsgi.ini</code></li><li>关闭 uWSGI：<code>uwsgi --stop uwsgi.pid</code></li></ul><h3 id="管理静态文件"><a href="#管理静态文件" class="headerlink" title="管理静态文件"></a>管理静态文件</h3><blockquote><p>参考：<a href="https://note.qidong.name/2017/07/uwsgi-serve-django-static/">https://note.qidong.name/2017/07/uwsgi-serve-django-static/</a></p></blockquote><p>现象：</p><ul><li>在 uWSGI 下无法访问静态资源，而在 runserver 下则没有问题。</li></ul><p>原因：</p><ul><li>一个 Django 应用，一般有两类静态文件。 一是<strong>应用内的静态文件</strong>，二是 <strong>Django 本身以及第三方库的静态文件</strong>。<ul><li>应用内的静态文件：在与 settings.py 设定的 STATICFILES_DIRS 目录列表中。</li><li>Django 本身以及第三方库的静态文件：INSTALLED_APPS 中配置的 django.contrib.admin、rest_framework 等。<ul><li>例，admin 的静态文件在：/usr/local/lib/python3.6/site-packages/django/contrib/admin/static/admin/。</li></ul></li></ul></li><li>因此 STATICFILES_DIRS 不仅包含了自己存放的应用内的静态文件，还隐含了 Django 本身以及第三方库的静态文件</li><li>而 uWSGI 根本不知道静态文件在什么位置，只有 Django 自己知道。</li></ul><p>解决：</p><ul><li><p>在 Django 的 <code>setting.py</code> 中配置：</p><ul><li>```python<br>STATIC_ROOT = ‘./collectedstatic’  # /data/WebService/backend/collectedstatic<br>STATIC_URL = ‘/static/‘<br>STATICFILES_DIRS = (  # 不能与 STATIC_ROOT 重名<pre><code>os.path.join(BASE_DIR, &#39;static&#39;),</code></pre>)<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 运行 Django 命令：&#96;python3 manage.py collectstatic&#96;</span><br><span class="line"></span><br><span class="line">  - 把所有 STATICFILES_DIRS 目录下的文件，都复制到 STATIC_ROOT 中。 </span><br><span class="line"></span><br><span class="line">- 在配置文件中添加：</span><br><span class="line"></span><br><span class="line">  - &#96;&#96;&#96;ini</span><br><span class="line">    static-map &#x3D; &#x2F;static&#x3D;&#x2F;data&#x2F;WebService&#x2F;backend&#x2F;collectedstatic</span><br></pre></td></tr></table></figure></li><li>通常使用绝对路径，但也支持相对路径。</li></ul></li><li><p>启动 uWSGI ：<code>uwsgi --ini uwsgi.ini</code></p></li></ul><h2 id="Nginx"><a href="#Nginx" class="headerlink" title="Nginx"></a>Nginx</h2><h3 id="安装-1"><a href="#安装-1" class="headerlink" title="安装"></a>安装</h3><ol><li><p>apt</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">   apt-get install nginx</span><br><span class="line"></span><br><span class="line">2. wget</span><br><span class="line"></span><br><span class="line">   ```bash</span><br><span class="line">   wget http://nginx.org/download/nginx-1.5.6.tar.gz</span><br><span class="line">   tar xf nginx-1.5.6.tar.gz</span><br><span class="line">   <span class="built_in">cd</span> nginx-1.5.6</span><br><span class="line">   ./configure --prefix=/usr/<span class="built_in">local</span>/nginx-1.5.6 \</span><br><span class="line">   --with-http_stub_status_module \</span><br><span class="line">   --with-http_gzip_static_module</span><br><span class="line">   make &amp;&amp; make install</span><br></pre></td></tr></table></figure></li><li><p>检查 nginx 是否安装、启动成功</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ /etc/init.d/nginx start</span><br><span class="line">[ ok ] Starting nginx (via systemctl): nginx.service.</span><br><span class="line">$ ps -ef |grep -i nginx</span><br><span class="line">root       6961      1  0 03:56 ?        00:00:00 nginx: master process /usr/sbin/nginx -g daemon on; master_process on;</span><br><span class="line">www-data   6962   6961  0 03:56 ?        00:00:00 nginx: worker process</span><br><span class="line">pala       6985   2090  0 03:57 pts/0    00:00:00 grep --color=auto -i nginx</span><br></pre></td></tr></table></figure></li><li><p>打开浏览器，访问 ip 地址，可以看见 Welcome to nginx!</p></li></ol><h3 id="常用命令（常用）"><a href="#常用命令（常用）" class="headerlink" title="常用命令（常用）"></a>常用命令（常用）</h3><ul><li>启动：<code>/etc/init.d/nginx start</code></li><li>关闭：<code>/etc/init.d/nginx stop</code></li><li>重启：<code>/etc/init.d/nginx restart</code></li></ul><h3 id="自定义配置文件（常用）-1"><a href="#自定义配置文件（常用）-1" class="headerlink" title="自定义配置文件（常用）"></a>自定义配置文件（常用）</h3><ol><li><p>Nginx 的配置目录为 /etc/nginx/conf.d/ 或 /etc/nginx/sites-enabled/</p></li><li><p>创建配置文件：<code>$ vim /etc/nginx/conf.d/xxx.conf</code></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">server&#123;</span><br><span class="line">    <span class="comment"># 需要监听的端口</span></span><br><span class="line">    listen 80;</span><br><span class="line">    <span class="comment"># 如果有域名就是买的域名</span></span><br><span class="line">    server_name 0.0.0.0;</span><br><span class="line">    <span class="comment"># 日志配置</span></span><br><span class="line">    access_log  /var/log/nginx/access.log  main;  </span><br><span class="line">    <span class="comment"># 编码</span></span><br><span class="line">    charset utf-8;</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 启用压缩,这个的作用就是给用户一个网页,比如3M压缩后1M这样传输速度就会提高很多</span></span><br><span class="line">    gzip on;  </span><br><span class="line">    <span class="comment"># 支持压缩的类型</span></span><br><span class="line">    gzip_types text/plain application/x-javascript text/css text/javascript application/x-httpd-php application/json text/json image/jpeg image/gif image/png application/octet-stream;  </span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 错误页面</span></span><br><span class="line">    error_page  404           /404.html;  </span><br><span class="line">    error_page   500 502 503 504  /50x.html;  </span><br><span class="line"></span><br><span class="line">    <span class="comment"># todo 加载静态文件的路径</span></span><br><span class="line">    location /media  &#123;</span><br><span class="line">        alias /data/WebService/backend/media;  # your Django project&#x27;s media files - amend as required</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    location /static &#123;</span><br><span class="line">        alias /data/WebService/backend/static;  # your Django project&#x27;s static files - amend as required</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    location /&#123;</span><br><span class="line">        <span class="comment"># 在nginx里面的文件uwsgi_params</span></span><br><span class="line">        include uwsgi_params;</span><br><span class="line">        <span class="comment"># 跟uwsgi通信的端口</span></span><br><span class="line">        uwsgi_pass 127.0.0.1:8000;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>若还未移动到目录下，则：<code>cp /data/WebService/backend/nginx.conf /etc/nginx/sites-enabled/nginx.conf</code></p></li><li><p>重启 Nginx：<code>$ /etc/init.d/nginx restart</code>  </p></li></ol>]]></content>
    
    
    <summary type="html">uWSGI与Nginx部署</summary>
    
    
    
    <category term="Python后端部署" scheme="https://nephrencake.github.io/categories/Python%E5%90%8E%E7%AB%AF%E9%83%A8%E7%BD%B2/"/>
    
    
  </entry>
  
  <entry>
    <title>Python后端部署-Part3</title>
    <link href="https://nephrencake.github.io/2021/11/Python%E5%90%8E%E7%AB%AF%E9%83%A8%E7%BD%B2-Part3/"/>
    <id>https://nephrencake.github.io/2021/11/Python%E5%90%8E%E7%AB%AF%E9%83%A8%E7%BD%B2-Part3/</id>
    <published>2021-11-22T11:46:29.000Z</published>
    <updated>2022-05-14T15:33:05.283Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Python后端部署-Part3——Supervisor进程管理"><a href="#Python后端部署-Part3——Supervisor进程管理" class="headerlink" title="Python后端部署-Part3——Supervisor进程管理"></a>Python后端部署-Part3——Supervisor进程管理</h1><p>[TOC]</p><h2 id="nohup"><a href="#nohup" class="headerlink" title="nohup"></a>nohup</h2><ul><li><p>用途：不挂断地运行命令。</p></li><li><p>语法：<code>nohup Command [ Arg … ] [　&amp; ]</code></p><ul><li>Command：要执行的命令。</li><li>Arg：一些参数，可以指定输出文件。</li><li>&amp;：让命令在后台执行，终端退出后命令仍旧执行。</li></ul></li><li><p>启动进程：</p><ul><li><pre><code class="bash">nohup python3 /data/WebService/backend/manage.py runserver 0.0.0.0:8000 &gt;&gt;/data/WebService/backend/log/output.log 2&gt;&amp;1 &amp;<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  - 2&gt;&amp;1：将标准错误 2 重定向到标准输出 &amp;1 ，标准输出 &amp;1 再被重定向输入到 runoob.log 文件中。</span><br><span class="line"></span><br><span class="line">    - 0 – stdin（standard input，标准输入）</span><br><span class="line">    - 1 – stdout（standard output，标准输出）</span><br><span class="line">    - 2 – stderr（standard error，标准错误输出）</span><br><span class="line"></span><br><span class="line">- 终止进程：</span><br><span class="line"></span><br><span class="line">  - &#96;&#96;&#96;bash</span><br><span class="line">    ps -aux | grep manage.py</span><br><span class="line">    ps -aux | grep manage.py | grep -v grep | awk &#39;&#123;print $2&#125;&#39;</span><br></pre></td></tr></table></figure></code></pre></li><li><p>参数说明：</p><ul><li>a : 显示所有程序</li><li>u : 以用户为主的格式来显示</li><li>x : 显示所有程序，不区分终端机</li></ul></li><li><p>```bash<br>kill -9  进程号PID</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">## Supervisor</span><br><span class="line"></span><br><span class="line">### 简介</span><br><span class="line"></span><br><span class="line">- Supervisor 是用 Python 开发的一套通用的进程管理程序，能将一个普通的命令行进程变为后台 daemon，并监控进程状态，异常退出时能自动重启。</span><br><span class="line">- 它是通过 fork&#x2F;exec 的方式把这些被管理的进程当作 supervisor 的子进程来启动，这样只要在 supervisor 的配置文件中，把要管理的进程的可执行文件的路径写进去即可。也实现当子进程挂掉的时候，父进程可以准确获取子进程挂掉的信息的，可以选择是否自己启动和报警。</span><br><span class="line">- Supervisor 还提供了一个功能，可以为 supervisord 或者每个子进程，设置一个非 root 的 user，这个 user 就可以管理它对应的进程。</span><br><span class="line"></span><br><span class="line">### 安装</span><br><span class="line"></span><br><span class="line">1. 配置好 yum 源后，可以直接安装</span><br><span class="line"></span><br><span class="line">   &#96;&#96;&#96;bash</span><br><span class="line">   yum install supervisor</span><br></pre></td></tr></table></figure></li></ul></li></ul><ol start="2"><li><p>Debian/Ubuntu 可通过 apt 安装</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt-get install supervisor</span><br></pre></td></tr></table></figure></li><li><p>pip 安装</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install supervisor</span><br></pre></td></tr></table></figure><h3 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h3></li></ol><h4 id="默认配置文件"><a href="#默认配置文件" class="headerlink" title="默认配置文件"></a>默认配置文件</h4><ul><li>默认配置文件：<code>/etc/supervisor/supervisord.conf</code>（可能会在不同的地方）</li><li>默认配置文件一般不需要改动，直接定义自己的配置文件即可</li></ul><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[unix_http_server]</span></span><br><span class="line"><span class="attr">file</span>=/tmp/supervisor.sock   <span class="comment">;UNIX socket 文件，supervisorctl 会使用</span></span><br><span class="line"><span class="comment">;chmod=0700                 ;socket文件的mode，默认是0700</span></span><br><span class="line"><span class="comment">;chown=nobody:nogroup       ;socket文件的owner，格式：uid:gid</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">;[inet_http_server]         ;HTTP服务器，提供web管理界面</span></span><br><span class="line"><span class="comment">;port=127.0.0.1:9001        ;Web管理后台运行的IP和端口，如果开放到公网，需要注意安全性</span></span><br><span class="line"><span class="comment">;username=user              ;登录管理后台的用户名</span></span><br><span class="line"><span class="comment">;password=123               ;登录管理后台的密码</span></span><br><span class="line"> </span><br><span class="line"><span class="section">[supervisord]</span></span><br><span class="line"><span class="attr">logfile</span>=/tmp/supervisord.log <span class="comment">;日志文件，默认是 $CWD/supervisord.log</span></span><br><span class="line"><span class="attr">logfile_maxbytes</span>=<span class="number">50</span>MB        <span class="comment">;日志文件大小，超出会rotate，默认 50MB，如果设成0，表示不限制大小</span></span><br><span class="line"><span class="attr">logfile_backups</span>=<span class="number">10</span>           <span class="comment">;日志文件保留备份数量默认10，设为0表示不备份</span></span><br><span class="line"><span class="attr">loglevel</span>=info                <span class="comment">;日志级别，默认info，其它: debug,warn,trace</span></span><br><span class="line"><span class="attr">pidfile</span>=/tmp/supervisord.pid <span class="comment">;pid 文件</span></span><br><span class="line"><span class="attr">nodaemon</span>=<span class="literal">false</span>               <span class="comment">;是否在前台启动，默认是false，即以 daemon 的方式启动</span></span><br><span class="line"><span class="attr">minfds</span>=<span class="number">1024</span>                  <span class="comment">;可以打开的文件描述符的最小值，默认 1024</span></span><br><span class="line"><span class="attr">minprocs</span>=<span class="number">200</span>                 <span class="comment">;可以打开的进程数的最小值，默认 200</span></span><br><span class="line"> </span><br><span class="line"><span class="section">[supervisorctl]</span></span><br><span class="line"><span class="attr">serverurl</span>=unix:///tmp/supervisor.sock <span class="comment">;通过UNIX socket连接supervisord，路径与unix_http_server部分的file一致</span></span><br><span class="line"><span class="comment">;serverurl=http://127.0.0.1:9001 ; 通过HTTP的方式连接supervisord</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">; [program:xx]是被管理的进程配置参数，xx是进程的名称</span></span><br><span class="line"><span class="section">[program:xx]</span></span><br><span class="line"><span class="attr">command</span>=/opt/apache-tomcat-<span class="number">8.0</span>.<span class="number">35</span>/bin/catalina.sh run  <span class="comment">; 程序启动命令</span></span><br><span class="line"><span class="attr">autostart</span>=<span class="literal">true</span>       <span class="comment">; 在supervisord启动的时候也自动启动</span></span><br><span class="line"><span class="attr">startsecs</span>=<span class="number">10</span>         <span class="comment">; 启动10秒后没有异常退出，就表示进程正常启动了，默认为1秒</span></span><br><span class="line"><span class="attr">autorestart</span>=<span class="literal">true</span>     <span class="comment">; 程序退出后自动重启,可选值：[unexpected,true,false]，默认为unexpected，表示进程意外杀死后才重启</span></span><br><span class="line"><span class="attr">startretries</span>=<span class="number">3</span>       <span class="comment">; 启动失败自动重试次数，默认是3</span></span><br><span class="line"><span class="attr">user</span>=tomcat          <span class="comment">; 用哪个用户启动进程，默认是root</span></span><br><span class="line"><span class="attr">priority</span>=<span class="number">999</span>         <span class="comment">; 进程启动优先级，默认999，值小的优先启动</span></span><br><span class="line"><span class="attr">redirect_stderr</span>=<span class="literal">true</span> <span class="comment">; 把stderr重定向到stdout，默认false</span></span><br><span class="line"><span class="attr">stdout_logfile_maxbytes</span>=<span class="number">20</span>MB  <span class="comment">; stdout 日志文件大小，默认50MB</span></span><br><span class="line"><span class="attr">stdout_logfile_backups</span> = <span class="number">20</span>   <span class="comment">; stdout 日志文件备份数，默认是10</span></span><br><span class="line"><span class="comment">; stdout 日志文件，需要注意当指定目录不存在时无法正常启动，所以需要手动创建目录（supervisord 会自动创建日志文件）</span></span><br><span class="line"><span class="attr">stdout_logfile</span>=/opt/apache-tomcat-<span class="number">8.0</span>.<span class="number">35</span>/logs/catalina.out</span><br><span class="line"><span class="attr">stopasgroup</span>=<span class="literal">false</span>     <span class="comment">;默认为false,进程被杀死时，是否向这个进程组发送stop信号，包括子进程</span></span><br><span class="line"><span class="attr">killasgroup</span>=<span class="literal">false</span>     <span class="comment">;默认为false，向进程组发送kill信号，包括子进程</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">;包含其它配置文件</span></span><br><span class="line"><span class="section">[include]</span></span><br><span class="line"><span class="attr">files</span> = relative/directory/*.ini    <span class="comment">;可以指定一个或多个以.ini结束的配置文件</span></span><br></pre></td></tr></table></figure><h4 id="自定义子进程配置文件（常用）"><a href="#自定义子进程配置文件（常用）" class="headerlink" title="自定义子进程配置文件（常用）"></a>自定义子进程配置文件（常用）</h4><ul><li>自定义的子进程配置文件路径：<code>/etc/supervisor/conf.d/</code></li></ul><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 项目名</span></span><br><span class="line"><span class="section">[program:WebService]</span></span><br><span class="line"><span class="comment"># 脚本目录</span></span><br><span class="line"><span class="attr">directory</span>=/data/WebService/backend</span><br><span class="line"><span class="comment"># 脚本执行命令</span></span><br><span class="line"><span class="attr">command</span>=python3 /data/WebService/backend/manage.py runserver <span class="number">0.0</span>.<span class="number">0.0</span>:<span class="number">8000</span></span><br><span class="line"><span class="comment">; command=uwsgi --ini /data/WebService/backend/start.ini</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#supervisor启动的时候是否随着同时启动，默认True</span></span><br><span class="line"><span class="attr">autostart</span>=<span class="literal">true</span></span><br><span class="line"><span class="comment"># 当程序exit的时候，这个program不会自动重启,默认unexpected，设置子进程挂掉后自动重启的情况，</span></span><br><span class="line"><span class="comment"># 有三个选项，false,unexpected和true。</span></span><br><span class="line"><span class="comment"># 如果为false的时候，无论什么情况下，都不会被重新启动，</span></span><br><span class="line"><span class="comment"># 如果为unexpected，只有当进程的退出码不在下面的exitcodes里面定义的</span></span><br><span class="line"><span class="attr">autorestart</span>=unexpected</span><br><span class="line"><span class="comment"># 这个选项是子进程启动多少秒之后，此时状态如果是running，则我们认为启动成功了。默认值为1</span></span><br><span class="line"><span class="attr">startsecs</span>=<span class="number">1</span></span><br><span class="line"><span class="comment"># 脚本运行的用户身份</span></span><br><span class="line"><span class="attr">user</span> = test</span><br><span class="line"><span class="comment"># 日志输出</span></span><br><span class="line"><span class="attr">stderr_logfile</span>=/data/WebService/backend/log/web_err.log</span><br><span class="line"><span class="attr">stdout_logfile</span>=/data/WebService/backend/log/web_out.log</span><br><span class="line"><span class="comment"># 把stderr重定向到stdout，默认 false</span></span><br><span class="line"><span class="attr">redirect_stderr</span> = <span class="literal">true</span></span><br><span class="line"><span class="comment"># stdout日志文件大小，默认 50MB</span></span><br><span class="line"><span class="attr">stdout_logfile_maxbytes</span> = <span class="number">50</span>MB</span><br><span class="line"><span class="comment"># stdout日志文件备份数</span></span><br><span class="line"><span class="attr">stdout_logfile_backups</span> = <span class="number">20</span></span><br></pre></td></tr></table></figure><blockquote><p>注意：supervisor 不能监控后台进程，因此 command 不能为后台运行命令</p></blockquote><h3 id="启动服务"><a href="#启动服务" class="headerlink" title="启动服务"></a>启动服务</h3><h4 id="supervisord-直接启动"><a href="#supervisord-直接启动" class="headerlink" title="supervisord 直接启动"></a>supervisord 直接启动</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">supervisord -c /etc/supervisor/supervisord.conf</span><br></pre></td></tr></table></figure><h4 id="systemctl-命令启动"><a href="#systemctl-命令启动" class="headerlink" title="systemctl 命令启动"></a>systemctl 命令启动</h4><ul><li>编辑配置文件</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /usr/lib/systemd/system/supervisord.service</span><br></pre></td></tr></table></figure><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[Unit]</span></span><br><span class="line"><span class="attr">Description</span>=Supervisor daemon</span><br><span class="line"></span><br><span class="line"><span class="section">[Service]</span></span><br><span class="line"><span class="attr">Type</span>=forking</span><br><span class="line"><span class="attr">PIDFile</span>=/home/supervisor/supervisord.pid</span><br><span class="line"><span class="attr">ExecStart</span>=/usr/local/python3/bin/supervisord -c /etc/supervisord.conf</span><br><span class="line"><span class="attr">ExecStop</span>=/usr/local/python3/bin/supervisorctl shutdown</span><br><span class="line"><span class="attr">ExecReload</span>=/usr/local/python3/bin/supervisorctl reload</span><br><span class="line"><span class="attr">KillMode</span>=process</span><br><span class="line"><span class="attr">Restart</span>=<span class="literal">on</span>-failure</span><br><span class="line"><span class="attr">RestartSec</span>=<span class="number">42</span>s</span><br><span class="line"></span><br><span class="line"><span class="section">[Install]</span></span><br><span class="line"><span class="attr">WantedBy</span>=multi-user.target</span><br></pre></td></tr></table></figure><ul><li>常用命令</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">systemctl stop supervisord</span><br><span class="line">systemctl start supervisord</span><br><span class="line">systemctl status supervisord</span><br><span class="line">systemctl reload supervisord</span><br><span class="line">systemctl restart supervisord</span><br></pre></td></tr></table></figure><h3 id="常用命令（常用）"><a href="#常用命令（常用）" class="headerlink" title="常用命令（常用）"></a>常用命令（常用）</h3><ol><li><p><code>supervisorctl status all</code>：查看所有进程的状态</p></li><li><p><code>supervisorctl stop [program]</code>：停止 program</p><ul><li>program 换成 all 可以管理配置中的所有进程</li></ul></li><li><p><code>supervisorctl start [program]</code>：启动 program</p></li><li><p><code>supervisorctl restart [program]</code>：重启 program</p></li><li><p><code>supervisorctl update</code>：配置文件修改后可以使用该命令加载新的配置</p><ul><li><pre><code class="bash">$ cp /data/WebService/backend/supervisor.conf /etc/supervisor/conf.d/supervisor.conf$ supervisorctl updateWebService: added process group  # 其实这个时候已经开始运行后台了<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">6. &#96;supervisorctl reload&#96;：重新启动 supervisor</span><br><span class="line"></span><br><span class="line">   - &#96;&#96;&#96;bash</span><br><span class="line">     $ supervisorctl reload</span><br><span class="line">     Restarted supervisord</span><br></pre></td></tr></table></figure>### 常见问题</code></pre></li></ul></li><li><p>unix:///var/run/supervisor/supervisor.sock no such file</p><ul><li>没有开启服务。<code>supervisord -c /etc/supervisor/supervisord.conf</code> </li></ul></li><li><p>启动了多个 supervisord 服务，导致无法正常关闭服务</p><ul><li>使用 <code>ps -fe | grep supervisord</code> 查看所有启动过的 supervisord 服务，kill 相关的进程 <code>kill -9 进程号</code>。</li></ul></li><li><p>启动 uwsgi 时要注释 uwsgi 里的如下配置，否则 supervisorctl 启动时会报错</p><ul><li><pre><code class="ini">; daemonize = /home/apps/logManage/logs/uwsgi.log; pidfile = /home/apps/logManage/conf/uwsgi.pid; 可以增加 logto配置logto = /home/apps/logManage/logs/uwsgi.log  </code></pre></li></ul></li><li><p>bind(): Address already in use [core/socket.c line 769]</p></li></ol>]]></content>
    
    
    <summary type="html">Supervisor进程管理</summary>
    
    
    
    <category term="Python后端部署" scheme="https://nephrencake.github.io/categories/Python%E5%90%8E%E7%AB%AF%E9%83%A8%E7%BD%B2/"/>
    
    
  </entry>
  
  <entry>
    <title>Python后端部署-Part2</title>
    <link href="https://nephrencake.github.io/2021/11/Python%E5%90%8E%E7%AB%AF%E9%83%A8%E7%BD%B2-Part2/"/>
    <id>https://nephrencake.github.io/2021/11/Python%E5%90%8E%E7%AB%AF%E9%83%A8%E7%BD%B2-Part2/</id>
    <published>2021-11-22T11:46:24.000Z</published>
    <updated>2022-01-04T15:01:33.144Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Python后端部署-Part2——Django登录验证"><a href="#Python后端部署-Part2——Django登录验证" class="headerlink" title="Python后端部署-Part2——Django登录验证"></a>Python后端部署-Part2——Django登录验证</h1><p>[TOC]</p><h2 id="登录验证的实现思路"><a href="#登录验证的实现思路" class="headerlink" title="登录验证的实现思路"></a>登录验证的实现思路</h2><blockquote><p>参考：</p><ul><li><a href="https://blog.csdn.net/weixin_41861301/article/details/119519785">https://blog.csdn.net/weixin_41861301/article/details/119519785</a></li><li><a href="https://www.jianshu.com/p/902b18a6bd78">https://www.jianshu.com/p/902b18a6bd78</a></li></ul></blockquote><ul><li>采用 token 认证方式，使用 rest_framework_simplejwt 库配置权限认证。</li><li>Simple JWT 为 Django REST Framework 框架提供了一个 JSON Web 令牌认证后端。</li><li>注意：使用 rest_framework_simplejwt 进行身份认证时并不需要去对数据库进行查询校验，所以并不会将 token 保存在数据库中。</li></ul><h2 id="安装使用-rest-framework"><a href="#安装使用-rest-framework" class="headerlink" title="安装使用 rest_framework"></a>安装使用 rest_framework</h2><ol><li><p>安装</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install djangorestframework</span><br></pre></td></tr></table></figure></li><li><p>添加 <code>rest_framework</code> 到 <code>INSTALLED_APPS</code> 设置中</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -&gt; backend/WebService/settings.py</span></span><br><span class="line"></span><br><span class="line">INSTALLED_APPS = [</span><br><span class="line">    ...</span><br><span class="line">    <span class="string">&#x27;rest_framework&#x27;</span>,  <span class="comment"># DRF</span></span><br><span class="line">]</span><br></pre></td></tr></table></figure></li><li><p>若使用 DRF 的可浏览 API，则修改路由 <code>urls.py</code>（在生产环境中是不需要的）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -&gt; backend/WebService/urls.py</span></span><br><span class="line"></span><br><span class="line">urlpatterns = [</span><br><span class="line">    ...</span><br><span class="line">    path(<span class="string">&#x27;api-auth/&#x27;</span>, include(<span class="string">&#x27;rest_framework.urls&#x27;</span>)),</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h2 id="安装使用-rest-framework-simplejwt"><a href="#安装使用-rest-framework-simplejwt" class="headerlink" title="安装使用 rest_framework_simplejwt"></a>安装使用 rest_framework_simplejwt</h2></li><li><p>安装</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install djangorestframework_simplejwt</span><br></pre></td></tr></table></figure></li><li><p>添加 <code>rest_framework_simplejwt</code> 到 <code>INSTALLED_APPS</code> 设置中</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -&gt; backend/WebService/settings.py</span></span><br><span class="line"></span><br><span class="line">INSTALLED_APPS = [</span><br><span class="line">    ...</span><br><span class="line">    <span class="string">&#x27;rest_framework.authtoken&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;rest_framework_simplejwt&#x27;</span>,  <span class="comment"># jwt</span></span><br><span class="line">]</span><br></pre></td></tr></table></figure></li><li><p>将 Simple JWT 的 JSON Web 令牌认证添加到身份验证类列表中</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -&gt; backend/WebService/settings.py</span></span><br><span class="line"></span><br><span class="line">REST_FRAMEWORK = &#123;</span><br><span class="line">    <span class="comment"># 全局的权限认证，只有通过认证后才赋予用户权限</span></span><br><span class="line">    <span class="string">&#x27;DEFAULT_PERMISSION_CLASSES&#x27;</span>: (</span><br><span class="line">        <span class="string">&#x27;rest_framework.permissions.IsAuthenticated&#x27;</span>,</span><br><span class="line">    ),</span><br><span class="line">    <span class="comment"># 身份验证类列表，可以设定多个身份验证</span></span><br><span class="line">    <span class="string">&#x27;DEFAULT_AUTHENTICATION_CLASSES&#x27;</span>: (</span><br><span class="line">        <span class="string">&#x27;rest_framework_simplejwt.authentication.JWTAuthentication&#x27;</span>,</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>配置 JWT 相关参数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -&gt; backend/WebService/settings.py</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> timedelta</span><br><span class="line"></span><br><span class="line">SIMPLE_JWT = &#123;</span><br><span class="line">    <span class="string">&#x27;ACCESS_TOKEN_LIFETIME&#x27;</span>: timedelta(minutes=<span class="number">1</span>),  <span class="comment"># token 的过期时间</span></span><br><span class="line">    <span class="string">&#x27;REFRESH_TOKEN_LIFETIME&#x27;</span>: timedelta(days=<span class="number">15</span>),  <span class="comment"># 刷新 token 的过期时间</span></span><br><span class="line">    <span class="comment"># &#x27;AUTH_HEADER_TYPES&#x27;: (&#x27;Bearer&#x27;, &#x27;JWT&#x27;),  # token 的请求头类型</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在任意的路由配置中添加 Simple JWT 提供的视图（这里将登录验证模块集成到 login 应用下）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -&gt; backend/login/urls.py</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> django.urls <span class="keyword">import</span> path</span><br><span class="line"><span class="keyword">from</span> rest_framework_simplejwt.views <span class="keyword">import</span> TokenObtainPairView, TokenRefreshView, TokenVerifyView</span><br><span class="line"></span><br><span class="line">urlpatterns = [</span><br><span class="line">    path(<span class="string">&#x27;token/&#x27;</span>, TokenObtainPairView.as_view(), name=<span class="string">&#x27;token_obtain_pair&#x27;</span>),  <span class="comment"># POST 登录接口</span></span><br><span class="line">    path(<span class="string">&#x27;token/refresh/&#x27;</span>, TokenRefreshView.as_view(), name=<span class="string">&#x27;token_refresh&#x27;</span>),  <span class="comment"># POST 刷新token接口</span></span><br><span class="line">    path(<span class="string">&#x27;token/verify/&#x27;</span>, TokenVerifyView.as_view(), name=<span class="string">&#x27;token_verify&#x27;</span>),  <span class="comment"># POST 验证token接口 用于vue前端写路由守卫</span></span><br><span class="line">...</span><br><span class="line">]</span><br></pre></td></tr></table></figure></li><li><p>如果自定义用户表</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -&gt; backend/WebService/settings.py</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># AUTH_USER_MODEL 配置默认的校验用户表</span></span><br><span class="line">AUTH_USER_MODEL = <span class="string">&#x27;login.UserInfo&#x27;</span> </span><br></pre></td></tr></table></figure><h2 id="安装使用-django-simple-captcha"><a href="#安装使用-django-simple-captcha" class="headerlink" title="安装使用 django-simple-captcha"></a>安装使用 django-simple-captcha</h2></li><li><p>安装</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install django-simple-captcha</span><br></pre></td></tr></table></figure></li><li><p>添加 <code>captcha</code> 到 <code>INSTALLED_APPS</code> 中</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -&gt; backend/WebService/settings.py</span></span><br><span class="line"></span><br><span class="line">INSTALLED_APPS = [</span><br><span class="line">    ...</span><br><span class="line">    <span class="string">&#x27;captcha&#x27;</span>,  <span class="comment"># 生成验证码</span></span><br><span class="line">]</span><br></pre></td></tr></table></figure></li><li><p>需要更新数据库</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">python manage.py makemigrations</span><br><span class="line">python manage.py migrate</span><br></pre></td></tr></table></figure><h2 id="无验证码的登录验证"><a href="#无验证码的登录验证" class="headerlink" title="无验证码的登录验证"></a>无验证码的登录验证</h2></li><li><p>其实配置完 simplejwt 时，即可直接使用登录验证。</p><ul><li><p>创建超级用户，命令行输入：<code>python3 manage.py createsuperuser</code></p></li><li><p>使用 post 请求获取 token 令牌</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">headers：Content-Type:application/json</span><br><span class="line">body：&#123;&quot;username&quot;: &quot;admin&quot;, &quot;password&quot;: &quot;admin&quot;&#125;</span><br></pre></td></tr></table></figure></li><li><p>携带 token 令牌请求访问后端</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">body: &#123;&quot;token&quot;: &quot;token&quot;&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>之后编写的其他视图函数，都要继承 <code>from rest_framework.views import APIView </code>，否则将无法进行身份验证。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -&gt; backend/login/views.py</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> rest_framework.views <span class="keyword">import</span> APIView</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">test</span>(<span class="params">APIView</span>):</span>  <span class="comment"># 使用 token 之后，应当继承 APIView 类</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span>(<span class="params">self, request</span>):</span></span><br><span class="line">        <span class="keyword">return</span> JsonResponse(&#123;<span class="string">&quot;msg&quot;</span>: <span class="string">&quot;ok&quot;</span>&#125;, json_dumps_params=&#123;<span class="string">&quot;ensure_ascii&quot;</span>: <span class="literal">False</span>&#125;)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">test_no_login</span>(<span class="params">APIView</span>):</span>  <span class="comment"># 不需要进行登录验证的逻辑则添加 permission_classes = []</span></span><br><span class="line">    permission_classes = []</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span>(<span class="params">self, request</span>):</span></span><br><span class="line">        <span class="keyword">return</span> JsonResponse(&#123;<span class="string">&quot;msg&quot;</span>: <span class="string">&quot;ok&quot;</span>&#125;, json_dumps_params=&#123;<span class="string">&quot;ensure_ascii&quot;</span>: <span class="literal">False</span>&#125;)</span><br></pre></td></tr></table></figure><h2 id="带验证码的登录验证"><a href="#带验证码的登录验证" class="headerlink" title="带验证码的登录验证"></a>带验证码的登录验证</h2></li></ol><h3 id="构造返回验证码的视图"><a href="#构造返回验证码的视图" class="headerlink" title="构造返回验证码的视图"></a>构造返回验证码的视图</h3><ol><li><p>返回验证码的视图接口</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -&gt; backend/login/views.py</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">from</span> django.http <span class="keyword">import</span> HttpResponse</span><br><span class="line"><span class="keyword">from</span> captcha.views <span class="keyword">import</span> CaptchaStore, captcha_image</span><br><span class="line"><span class="keyword">from</span> django.views <span class="keyword">import</span> View</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CaptchaAPIView</span>(<span class="params">View</span>):</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span>(<span class="params">self, request</span>):</span></span><br><span class="line">        hash_key = CaptchaStore.generate_key()</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="comment"># 获取图片id</span></span><br><span class="line">            id_ = CaptchaStore.objects.<span class="built_in">filter</span>(hashkey=hash_key).first().<span class="built_in">id</span></span><br><span class="line">            image = captcha_image(request, hash_key)</span><br><span class="line">            <span class="comment"># 将图片转换为base64</span></span><br><span class="line">            image_base = <span class="string">&#x27;data:image/png;base64,%s&#x27;</span> % base64.b64encode(image.content).decode(<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">            json_data = json.dumps(&#123;<span class="string">&quot;id&quot;</span>: id_, <span class="string">&quot;image_base&quot;</span>: image_base&#125;)</span><br><span class="line">            <span class="comment"># 批量删除过期验证码</span></span><br><span class="line">            CaptchaStore.remove_expired()</span><br><span class="line">        <span class="keyword">except</span>:</span><br><span class="line">            json_data = <span class="literal">None</span></span><br><span class="line">        <span class="keyword">return</span> HttpResponse(json_data, content_type=<span class="string">&quot;application/json&quot;</span>)</span><br></pre></td></tr></table></figure></li><li><p>添加验证码视图的接口路由</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -&gt; backend/login/urls.py</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> django.urls <span class="keyword">import</span> path</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> login.views <span class="keyword">import</span> CaptchaAPIView</span><br><span class="line"></span><br><span class="line">urlpatterns = [</span><br><span class="line">    ...</span><br><span class="line">    path(<span class="string">&#x27;captcha/&#x27;</span>, CaptchaAPIView.as_view(), name=<span class="string">&#x27;captcha_api&#x27;</span>),  <span class="comment"># GET 返回验证码接口</span></span><br><span class="line">]</span><br></pre></td></tr></table></figure><h3 id="重写带验证码的登录视图"><a href="#重写带验证码的登录视图" class="headerlink" title="重写带验证码的登录视图"></a>重写带验证码的登录视图</h3></li><li><p>构造一个手动返回令牌的方法</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -&gt; backend/login/utils/get_token.py</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> rest_framework_simplejwt.tokens <span class="keyword">import</span> RefreshToken</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_tokens_for_user</span>(<span class="params">user</span>):</span></span><br><span class="line">    <span class="comment"># 手动返回令牌</span></span><br><span class="line">    refresh = RefreshToken.for_user(user)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="string">&#x27;refresh&#x27;</span>: <span class="built_in">str</span>(refresh),</span><br><span class="line">        <span class="string">&#x27;access&#x27;</span>: <span class="built_in">str</span>(refresh.access_token),</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li><li><p>在扩展 <code>TokenObtainPairView</code> 视图前先扩展该序列化类 <code>TokenObtainPairSerializer</code> </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -&gt; backend/login/serializer.py</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> django.utils <span class="keyword">import</span> timezone</span><br><span class="line"><span class="keyword">from</span> rest_framework <span class="keyword">import</span> serializers</span><br><span class="line"><span class="keyword">from</span> rest_framework_simplejwt.serializers <span class="keyword">import</span> TokenObtainPairSerializer</span><br><span class="line"><span class="keyword">from</span> django.contrib.auth <span class="keyword">import</span> authenticate</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> captcha.fields <span class="keyword">import</span> CaptchaStore</span><br><span class="line"><span class="keyword">from</span> login.utils.get_token <span class="keyword">import</span> get_tokens_for_user</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DmallTokenObtainPairSerializer</span>(<span class="params">TokenObtainPairSerializer</span>):</span></span><br><span class="line">    captcha = serializers.CharField(max_length=<span class="number">4</span>, required=<span class="literal">True</span>,</span><br><span class="line">                                    trim_whitespace=<span class="literal">True</span>, min_length=<span class="number">4</span>,</span><br><span class="line">                                    error_messages=&#123;</span><br><span class="line">                                        <span class="string">&quot;max_length&quot;</span>: <span class="string">&quot;图片验证码仅允许4位&quot;</span>,</span><br><span class="line">                                        <span class="string">&quot;min_length&quot;</span>: <span class="string">&quot;图片验证码仅允许4位&quot;</span>,</span><br><span class="line">                                        <span class="string">&quot;required&quot;</span>: <span class="string">&quot;请输入图片验证码&quot;</span></span><br><span class="line">                                    &#125;, help_text=<span class="string">&quot;图片验证码&quot;</span>)</span><br><span class="line">    imgcode_id = serializers.CharField(required=<span class="literal">True</span>, write_only=<span class="literal">True</span>,</span><br><span class="line">                                       help_text=<span class="string">&quot;图片验证码id&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_token</span>(<span class="params">cls, user</span>):</span></span><br><span class="line">        token = <span class="built_in">super</span>().get_token(user)</span><br><span class="line">        token[<span class="string">&#x27;captcha&#x27;</span>] = user.captcha</span><br><span class="line">        token[<span class="string">&#x27;imgcode_id&#x27;</span>] = user.imgcode_id</span><br><span class="line">        <span class="keyword">return</span> token</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">validate_captcha</span>(<span class="params">self, captcha</span>):</span></span><br><span class="line">        <span class="comment"># 验证码验证</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            captcha = captcha.lower()</span><br><span class="line">        <span class="keyword">except</span>:</span><br><span class="line">            <span class="keyword">raise</span> serializers.ValidationError(<span class="string">&quot;验证码错误&quot;</span>)</span><br><span class="line">        img_code = CaptchaStore.objects.<span class="built_in">filter</span>(</span><br><span class="line">            <span class="built_in">id</span>=<span class="built_in">int</span>(self.initial_data[<span class="string">&#x27;imgcode_id&#x27;</span>])</span><br><span class="line">        ).first()</span><br><span class="line">        <span class="keyword">if</span> img_code <span class="keyword">and</span> timezone.now() &gt; img_code.expiration:</span><br><span class="line">            <span class="keyword">raise</span> serializers.ValidationError(<span class="string">&quot;图片验证码过期&quot;</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">if</span> img_code <span class="keyword">and</span> img_code.response == captcha:</span><br><span class="line">                <span class="keyword">pass</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">raise</span> serializers.ValidationError(<span class="string">&quot;验证码错误&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">validate</span>(<span class="params">self, attrs</span>):</span></span><br><span class="line">        <span class="comment"># 删除验证码</span></span><br><span class="line">        <span class="keyword">del</span> attrs[<span class="string">&#x27;captcha&#x27;</span>]</span><br><span class="line">        <span class="keyword">del</span> attrs[<span class="string">&#x27;imgcode_id&#x27;</span>]</span><br><span class="line">        authenticate_kwargs = &#123;</span><br><span class="line">            <span class="string">&#x27;username&#x27;</span>: attrs[<span class="string">&#x27;username&#x27;</span>],</span><br><span class="line">            <span class="string">&#x27;password&#x27;</span>: attrs[<span class="string">&#x27;password&#x27;</span>],</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment"># 验证当前登录用户</span></span><br><span class="line">        self.user = authenticate(**authenticate_kwargs)</span><br><span class="line">        <span class="keyword">if</span> self.user <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">raise</span> serializers.ValidationError(<span class="string">&#x27;账号或密码不正确&#x27;</span>)</span><br><span class="line">        <span class="comment"># 登录成功返回token信息</span></span><br><span class="line">        token = get_tokens_for_user(self.user)</span><br><span class="line">        <span class="keyword">return</span> token</span><br></pre></td></tr></table></figure></li><li><p>重写 <code>TokenObtainPairView</code> 视图函数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -&gt; backend/login/views.py</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> rest_framework_simplejwt.views <span class="keyword">import</span> TokenObtainPairView</span><br><span class="line"><span class="keyword">from</span> login.serializer <span class="keyword">import</span> DmallTokenObtainPairSerializer</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DmallTokenObtainPairView</span>(<span class="params">TokenObtainPairView</span>):</span></span><br><span class="line">    <span class="comment"># 登录成功返回token</span></span><br><span class="line">    serializer_class = DmallTokenObtainPairSerializer</span><br></pre></td></tr></table></figure></li><li><p>添加登录视图的接口路由</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -&gt; backend/login/urls.py</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> django.urls <span class="keyword">import</span> path</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> login.views <span class="keyword">import</span> DmallTokenObtainPairView</span><br><span class="line"></span><br><span class="line">urlpatterns = [</span><br><span class="line">    ...</span><br><span class="line">    path(<span class="string">&#x27;captcha/token/&#x27;</span>, DmallTokenObtainPairView.as_view(), name=<span class="string">&#x27;mytoken&#x27;</span>),</span><br><span class="line">]</span><br></pre></td></tr></table></figure></li><li><p>测试</p><img src="/2021/11/Python%E5%90%8E%E7%AB%AF%E9%83%A8%E7%BD%B2-Part2/image-20211126124446649.png" alt="image-20211126124446649" style="zoom:150%;"></li></ol>]]></content>
    
    
    <summary type="html">Django登录验证</summary>
    
    
    
    <category term="Python后端部署" scheme="https://nephrencake.github.io/categories/Python%E5%90%8E%E7%AB%AF%E9%83%A8%E7%BD%B2/"/>
    
    
  </entry>
  
  <entry>
    <title>Python后端部署-Part1</title>
    <link href="https://nephrencake.github.io/2021/11/Python%E5%90%8E%E7%AB%AF%E9%83%A8%E7%BD%B2-Part1/"/>
    <id>https://nephrencake.github.io/2021/11/Python%E5%90%8E%E7%AB%AF%E9%83%A8%E7%BD%B2-Part1/</id>
    <published>2021-11-22T11:46:18.000Z</published>
    <updated>2022-03-20T11:51:23.692Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Python后端部署-Part1——Web项目总览"><a href="#Python后端部署-Part1——Web项目总览" class="headerlink" title="Python后端部署-Part1——Web项目总览"></a>Python后端部署-Part1——Web项目总览</h1><p>[TOC]</p><h2 id="快速使用"><a href="#快速使用" class="headerlink" title="快速使用"></a>快速使用</h2><p>施工中……</p><h2 id="手动部署全流程"><a href="#手动部署全流程" class="headerlink" title="手动部署全流程"></a>手动部署全流程</h2><h2 id="服务器-Nginx-uwsgi-Django-配置"><a href="#服务器-Nginx-uwsgi-Django-配置" class="headerlink" title="服务器 Nginx+uwsgi+Django 配置"></a>服务器 Nginx+uwsgi+Django 配置</h2><h3 id="创建项目的-Docker-容器"><a href="#创建项目的-Docker-容器" class="headerlink" title="创建项目的 Docker 容器"></a>创建项目的 Docker 容器</h3><ol><li><p>拉取 ubuntu 镜像</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker pull django/ubuntu:20.04</span><br></pre></td></tr></table></figure></li><li><p>创建容器</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -it --name WebService -p 9045:22 -p 9046:80 -p 9048:8000 -p 9049:8080 -v /data/WebService:/data/WebService -d ubuntu:20.04 /bin/bash</span><br></pre></td></tr></table></figure><ul><li>-p 9045:22 用于 ssh 连接</li><li>-p 9046:80 用于 Nginx 代理</li><li>-p 9048:8000 用于 Django 测试</li><li>-p 9049:8080 用于 Vue 测试</li><li>-v /data/WebService:/data/WebService 将宿主机与容器内的项目根目录进行挂载</li></ul></li><li><p>进入容器（后续操作都在容器中进行）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker <span class="built_in">exec</span> -it WebService bash</span><br></pre></td></tr></table></figure></li><li><p>保持运行并退出容器</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ctrl + p + q</span><br></pre></td></tr></table></figure><h3 id="ssh-连接（可选）"><a href="#ssh-连接（可选）" class="headerlink" title="ssh 连接（可选）"></a>ssh 连接（可选）</h3></li></ol><h4 id="服务端搭建-ssh-服务"><a href="#服务端搭建-ssh-服务" class="headerlink" title="服务端搭建 ssh 服务"></a>服务端搭建 ssh 服务</h4><blockquote><p>参考：<a href="https://www.cnblogs.com/linuxAndMcu/p/10766589.html">https://www.cnblogs.com/linuxAndMcu/p/10766589.html</a></p></blockquote><ol><li><p>安装服务器</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ apt-get update</span><br><span class="line">$ apt-get install openssh-server</span><br></pre></td></tr></table></figure></li><li><p>生成秘钥</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">$ ssh-keygen -t rsa</span><br><span class="line">Generating public/private rsa key pair.</span><br><span class="line">Enter file <span class="keyword">in</span> <span class="built_in">which</span> to save the key (/root/.ssh/id_rsa): <span class="comment"># 这里回车</span></span><br><span class="line">Created directory <span class="string">&#x27;/root/.ssh&#x27;</span>.</span><br><span class="line">Enter passphrase (empty <span class="keyword">for</span> no passphrase): <span class="comment"># 这里回车</span></span><br><span class="line">Enter same passphrase again: <span class="comment"># 这里回车</span></span><br><span class="line">Your identification has been saved <span class="keyword">in</span> /root/.ssh/id_rsa</span><br><span class="line">Your public key has been saved <span class="keyword">in</span> /root/.ssh/id_rsa.pub</span><br><span class="line">The key fingerprint is:</span><br><span class="line">SHA256:7JmFyqQScZ5pTgQPro31HbSRQ0WhOXfaj36OlVW6rTY root@ac5b1c2f2ed8</span><br><span class="line">The key<span class="string">&#x27;s randomart image is:</span></span><br><span class="line"><span class="string">+---[RSA 3072]----+</span></span><br><span class="line"><span class="string">|  o  .+++.       |</span></span><br><span class="line"><span class="string">| . + .o=         |</span></span><br><span class="line"><span class="string">|  + + *.. .     .|</span></span><br><span class="line"><span class="string">| = * + = =     o |</span></span><br><span class="line"><span class="string">|o o B o S o   o  |</span></span><br><span class="line"><span class="string">|   = + o + o o o |</span></span><br><span class="line"><span class="string">|  . o o + . + . .|</span></span><br><span class="line"><span class="string">|   .     . o. E. |</span></span><br><span class="line"><span class="string">|          oo.... |</span></span><br><span class="line"><span class="string">+----[SHA256]-----+</span></span><br></pre></td></tr></table></figure></li><li><p>开放通过密码登录（如果没有开放的话）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ apt-get -y install vim  <span class="comment"># 如果没有 vim 的话</span></span><br><span class="line">$ vim /etc/ssh/sshd_config  <span class="comment"># 编辑</span></span><br><span class="line"></span><br><span class="line">输入/Permi，回车，找到</span><br><span class="line"><span class="comment">#PermitRootLogin prohibit-password</span></span><br><span class="line">取消注释, 修改成</span><br><span class="line">PermitRootLogin yes</span><br><span class="line"></span><br><span class="line">esc+:wq!退出</span><br></pre></td></tr></table></figure></li><li><p>设置密码</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ passwd</span><br><span class="line">New password: </span><br><span class="line">Retype new password: </span><br><span class="line">passwd: password updated successfully</span><br></pre></td></tr></table></figure></li><li><p>重启 ssh 服务</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ service ssh restart</span><br><span class="line"> * Restarting OpenBSD Secure Shell server sshd</span><br></pre></td></tr></table></figure><h4 id="使用-Pycharm-连接服务器"><a href="#使用-Pycharm-连接服务器" class="headerlink" title="使用 Pycharm 连接服务器"></a>使用 Pycharm 连接服务器</h4></li></ol><ul><li><p>pycharm 中找到远程主机</p><ul><li><img src="/2021/11/Python%E5%90%8E%E7%AB%AF%E9%83%A8%E7%BD%B2-Part1/image-20211113151601673.png" alt="image-20211113151601673"></li></ul></li><li><p>选择 SFTP</p><ul><li><img src="/2021/11/Python%E5%90%8E%E7%AB%AF%E9%83%A8%E7%BD%B2-Part1/image-20211113151849146.png" alt="image-20211113151849146"></li></ul></li><li><p>通信使用 utf-8</p><ul><li><img src="/2021/11/Python%E5%90%8E%E7%AB%AF%E9%83%A8%E7%BD%B2-Part1/image-20211113152019895.png" alt="image-20211113152019895"></li></ul></li><li><p>编辑 SSH 配置。由于 docker 容器的端口映射，这里的 9045 会连到容器的 22 端口。</p><ul><li><img src="/2021/11/Python%E5%90%8E%E7%AB%AF%E9%83%A8%E7%BD%B2-Part1/image-20211113152227627.png" alt="image-20211113152227627"></li></ul></li><li><p>设置映射</p><ul><li><img src="/2021/11/Python%E5%90%8E%E7%AB%AF%E9%83%A8%E7%BD%B2-Part1/image-20211113152505113.png" alt="image-20211113152505113"></li></ul></li><li><p>最终结果</p><ul><li><img src="/2021/11/Python%E5%90%8E%E7%AB%AF%E9%83%A8%E7%BD%B2-Part1/image-20211113152740086.png" alt="image-20211113152740086"></li></ul></li><li><p>同时，你可以通过 <code>ssh -p 9045 root@120.27.135.145</code> 在控制台登录</p><ul><li><img src="/2021/11/Python%E5%90%8E%E7%AB%AF%E9%83%A8%E7%BD%B2-Part1/image-20211113153636630.png" alt="image-20211113153636630"></li></ul></li><li><p>启动服务端的服务建议使用本地控制台连接服务器，后面会有启动命令</p></li></ul><blockquote><p>之后，你有两种方法来部署项目代码</p><ol><li>使用 ssh 连接服务器，在服务器上 git pull（当然，在此之前，你需要把代码 push 到 git 仓库）</li><li>使用 pycharm 直接部署代码（但是同样要记得 push 代码到仓库，否则在服务器上很难察觉版本迭代）</li></ol><p>同时，对于服务器上的文件修改，不需要再使用命令行，可以直接在 IDE 中编辑并上传。</p></blockquote><h3 id="容器内环境配置与测试"><a href="#容器内环境配置与测试" class="headerlink" title="容器内环境配置与测试"></a>容器内环境配置与测试</h3><blockquote><p>参考：</p><ul><li><a href="https://blog.csdn.net/yilovexing/article/details/82969103">https://blog.csdn.net/yilovexing/article/details/82969103</a></li><li><a href="https://blog.csdn.net/weixin_42292991/article/details/95937600">https://blog.csdn.net/weixin_42292991/article/details/95937600</a></li><li><a href="https://hub.docker.com/r/dockerfiles/django-uwsgi-nginx">https://hub.docker.com/r/dockerfiles/django-uwsgi-nginx</a></li><li><a href="https://www.cnblogs.com/Skyda/p/10030121.html">https://www.cnblogs.com/Skyda/p/10030121.html</a></li></ul></blockquote><ol><li><p>更新源，准备必要环境：git、py3、nginx、uwsgi</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">apt-get update &amp;&amp; \</span><br><span class="line">apt-get upgrade -y &amp;&amp; \ </span><br><span class="line">apt-get install -y \</span><br><span class="line">git \</span><br><span class="line">python3 \</span><br><span class="line">python3-dev \</span><br><span class="line">python3-setuptools \</span><br><span class="line">python3-pip \</span><br><span class="line">nginx \</span><br><span class="line">supervisor &amp;&amp; \</span><br><span class="line">pip3 install -U pip setuptools &amp;&amp; \</span><br><span class="line">pip3 install uwsgi &amp;&amp; \</span><br><span class="line">rm -rf /var/lib/apt/lists/*</span><br></pre></td></tr></table></figure></li><li><p>检查 python3</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ python3</span><br><span class="line">Python <span class="number">3.8</span><span class="number">.10</span> (default, Sep <span class="number">28</span> <span class="number">2021</span>, <span class="number">16</span>:<span class="number">10</span>:<span class="number">42</span>) </span><br><span class="line">[GCC <span class="number">9.3</span><span class="number">.0</span>] on linux</span><br><span class="line">Type <span class="string">&quot;help&quot;</span>, <span class="string">&quot;copyright&quot;</span>, <span class="string">&quot;credits&quot;</span> <span class="keyword">or</span> <span class="string">&quot;license&quot;</span> <span class="keyword">for</span> more information.</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span></span><br></pre></td></tr></table></figure></li><li><p>拉取仓库</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /data</span><br><span class="line">git <span class="built_in">clone</span> https://gitee.com/NephrenCake/WebService.git</span><br></pre></td></tr></table></figure><p>之后更新本地仓库</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /data/WebService</span><br><span class="line">git pull</span><br></pre></td></tr></table></figure></li><li><p>安装 pip 依赖</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd /data/WebService</span><br><span class="line">pip3 install -r backend/requirements.txt</span><br></pre></td></tr></table></figure></li><li><p>使用 Django 测试服务器启动服务</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python3 /data/WebService/backend/manage.py runserver <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span>:<span class="number">8000</span></span><br></pre></td></tr></table></figure><ul><li>浏览器打开 <a href="http://120.27.135.145:9048/">http://120.27.135.145:9048/</a></li></ul></li><li><p>使用 uwsgi 服务器启动服务</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">uwsgi --ini /data/WebService/backend/start.ini</span><br></pre></td></tr></table></figure><ul><li>浏览器打开 <a href="http://120.27.135.145:9048/%EF%BC%88%E5%9C%A8%E4%BD%BF%E7%94%A8">http://120.27.135.145:9048/（在使用</a> Django 或 uwsgi 服务器时，需要确保互相不同时使用，否则会有端口占用冲突）</li></ul></li><li><p>使用 Nginx 启动服务</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ cp /data/WebService/backend/nginx.conf /etc/nginx/sites-enabled/nginx.conf</span><br><span class="line">$ /etc/init.d/nginx restart</span><br><span class="line">$ nginx -s reload</span><br></pre></td></tr></table></figure><ul><li>浏览器打开 <a href="http://120.27.135.145:9046/%EF%BC%88%E5%90%8E%E9%9D%A2%E5%AE%9E%E9%99%85%E9%83%A8%E7%BD%B2%E4%BC%9A%E4%BD%BF%E7%94%A8%E8%AF%A5%E5%9C%B0%E5%9D%80%EF%BC%89">http://120.27.135.145:9046/（后面实际部署会使用该地址）</a></li></ul></li><li><p>使用 nohup 后台运行</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">nohup python3 /data/WebService/backend/manage.py runserver <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span>:<span class="number">8000</span> &gt;&gt;/data/WebService/backend/log/output.log <span class="number">2</span>&gt;&amp;<span class="number">1</span> &amp;</span><br><span class="line">ps -aux|grep manage.py| grep -v grep | awk <span class="string">&#x27;&#123;print $2&#125;&#x27;</span></span><br><span class="line">kill -<span class="number">9</span>  <span class="number">2619</span></span><br></pre></td></tr></table></figure></li><li><p>使用 Supervisor 运行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ supervisord -c /etc/supervisord.conf</span><br><span class="line">$ cp /data/WebService/backend/supervisor.conf /etc/supervisor/conf.d/supervisor.conf</span><br><span class="line">$ supervisorctl update</span><br><span class="line">WebService: added process group  <span class="comment"># 其实这个时候已经开始运行后台了</span></span><br><span class="line">$ supervisorctl restart WebService</span><br></pre></td></tr></table></figure><blockquote><p>注意：单独使用 uwsgi 和使用 Nginx+uwsgi 组合，使用的是同一个配置文件，即 start.ini，切换时需要修改对应项。当直接使用 Django 时不需要修改该配置文件。</p><ul><li><img src="/2021/11/Python%E5%90%8E%E7%AB%AF%E9%83%A8%E7%BD%B2-Part1/image-20211113171103506.png" alt="image-20211113171103506"></li></ul></blockquote></li></ol>]]></content>
    
    
    <summary type="html">Web项目总览</summary>
    
    
    
    <category term="Python后端部署" scheme="https://nephrencake.github.io/categories/Python%E5%90%8E%E7%AB%AF%E9%83%A8%E7%BD%B2/"/>
    
    
  </entry>
  
  <entry>
    <title>Python后端部署-完结目录</title>
    <link href="https://nephrencake.github.io/2021/11/Python%E5%90%8E%E7%AB%AF%E9%83%A8%E7%BD%B2-%E5%AE%8C%E7%BB%93%E7%9B%AE%E5%BD%95/"/>
    <id>https://nephrencake.github.io/2021/11/Python%E5%90%8E%E7%AB%AF%E9%83%A8%E7%BD%B2-%E5%AE%8C%E7%BB%93%E7%9B%AE%E5%BD%95/</id>
    <published>2021-11-22T11:20:17.000Z</published>
    <updated>2021-11-26T09:22:57.049Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Python后端部署-完结目录"><a href="#Python后端部署-完结目录" class="headerlink" title="Python后端部署-完结目录"></a>Python后端部署-完结目录</h1><table><thead><tr><th align="center"><a href="/2021/11/Python%E5%90%8E%E7%AB%AF%E9%83%A8%E7%BD%B2-Part1/">Python后端部署-Part1——Web项目总览</a></th></tr></thead><tbody><tr><td align="center"><strong><a href="/2021/11/Python%E5%90%8E%E7%AB%AF%E9%83%A8%E7%BD%B2-Part2/">Python后端部署-Part2——Django登录验证</a></strong></td></tr><tr><td align="center"><strong><a href="/2021/11/Python%E5%90%8E%E7%AB%AF%E9%83%A8%E7%BD%B2-Part3/">Python后端部署-Part3——Supervisor进程管理</a></strong></td></tr><tr><td align="center"><strong><a href="Python%E5%90%8E%E7%AB%AF%E9%83%A8%E7%BD%B2-Part4/">Python后端部署-Part4——uWSGI与Nginx部署</a></strong></td></tr><tr><td align="center"><strong><a href="/2021/11/Python%E5%90%8E%E7%AB%AF%E9%83%A8%E7%BD%B2-Part5/">Python后端部署-Part5——MySQL数据库容器</a></strong></td></tr></tbody></table><p>在本系列中，主要采取以下技术栈：（以后可能会不定期更新）</p><ol><li>容器工具：Docker</li><li>后端框架：Django+DjangoRestfulFramwork</li><li>进程管理：Supervisor</li><li>Web服务器：uWSGI</li><li>反向代理：Nginx</li><li>数据库：MySQL</li></ol>]]></content>
    
    
    <summary type="html">Python后端部署-完结目录</summary>
    
    
    
    <category term="Python后端部署" scheme="https://nephrencake.github.io/categories/Python%E5%90%8E%E7%AB%AF%E9%83%A8%E7%BD%B2/"/>
    
    
    <category term="Web" scheme="https://nephrencake.github.io/tags/Web/"/>
    
  </entry>
  
  <entry>
    <title>操作系统-完结目录</title>
    <link href="https://nephrencake.github.io/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E5%AE%8C%E7%BB%93%E7%9B%AE%E5%BD%95/"/>
    <id>https://nephrencake.github.io/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E5%AE%8C%E7%BB%93%E7%9B%AE%E5%BD%95/</id>
    <published>2021-11-01T01:44:19.000Z</published>
    <updated>2021-11-16T08:40:49.523Z</updated>
    
    <content type="html"><![CDATA[<h1 id="操作系统-完结目录"><a href="#操作系统-完结目录" class="headerlink" title="操作系统-完结目录"></a>操作系统-完结目录</h1><p>教程视频传送门：</p><ol><li><a href="https://www.bilibili.com/video/BV1YE411D7nH">王道计算机考研 操作系统</a></li></ol><p>推荐资源：</p><ol><li>王道配套书</li></ol><p>不多说，==做题==！</p><table><thead><tr><th align="center"><a href="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part1/">操作系统-Part1——计算机系统概述</a></th></tr></thead><tbody><tr><td align="center"><strong><a href="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part2/">操作系统-Part2——进程管理</a></strong></td></tr><tr><td align="center"><strong><a href="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part3/">操作系统-Part3——内存管理</a></strong></td></tr><tr><td align="center"><strong><a href="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part4/">操作系统-Part4——文件管理</a></strong></td></tr><tr><td align="center"><strong><a href="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part5/">操作系统-Part5——I/O 管理</a></strong></td></tr></tbody></table>]]></content>
    
    
    <summary type="html">完结目录</summary>
    
    
    
    <category term="操作系统" scheme="https://nephrencake.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="408" scheme="https://nephrencake.github.io/tags/408/"/>
    
  </entry>
  
</feed>
