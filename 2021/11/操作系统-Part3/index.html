<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>操作系统-Part3 | 浅幽丶奈芙莲的个人博客</title><meta name="author" content="NephrenCake"><meta name="copyright" content="NephrenCake"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><meta name="description" content="内存管理">
<meta property="og:type" content="article">
<meta property="og:title" content="操作系统-Part3">
<meta property="og:url" content="https://nephrencake.gitee.io/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part3/index.html">
<meta property="og:site_name" content="浅幽丶奈芙莲的个人博客">
<meta property="og:description" content="内存管理">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://nephrencake.gitee.io/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E5%AE%8C%E7%BB%93%E7%9B%AE%E5%BD%95/%E4%BA%8Ced12.jpg">
<meta property="article:published_time" content="2021-11-01T01:43:49.000Z">
<meta property="article:modified_time" content="2021-11-16T08:41:07.964Z">
<meta property="article:author" content="NephrenCake">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://nephrencake.gitee.io/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E5%AE%8C%E7%BB%93%E7%9B%AE%E5%BD%95/%E4%BA%8Ced12.jpg"><link rel="shortcut icon" href="/img/favicon.jpg"><link rel="canonical" href="https://nephrencake.gitee.io/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part3/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: {"limitDay":365,"position":"top","messagePrev":"It has been","messageNext":"days since the last update, the content of the article may be outdated."},
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
};

var saveToLocal = {
  set: function setWithExpiry(key, value, ttl) {
    const now = new Date()
    const expiryDay = ttl * 86400000
    const item = {
      value: value,
      expiry: now.getTime() + expiryDay,
    }
    localStorage.setItem(key, JSON.stringify(item))
  },

  get: function getWithExpiry(key) {
    const itemStr = localStorage.getItem(key)

    if (!itemStr) {
      return undefined
    }
    const item = JSON.parse(itemStr)
    const now = new Date()

    if (now.getTime() > item.expiry) {
      localStorage.removeItem(key)
      return undefined
    }
    return item.value
  }
}

// https://stackoverflow.com/questions/16839698/jquery-getscript-alternative-in-native-javascript
const getScript = url => new Promise((resolve, reject) => {
  const script = document.createElement('script')
  script.src = url
  script.async = true
  script.onerror = reject
  script.onload = script.onreadystatechange = function() {
    const loadState = this.readyState
    if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
    script.onload = script.onreadystatechange = null
    resolve()
  }
  document.head.appendChild(script)
})</script><script id="config_change">var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2021-11-16 16:41:07'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(function () {const asideStatus = saveToLocal.get('aside-status')
if (asideStatus !== undefined) {
   if (asideStatus === 'hide') {
     document.documentElement.classList.add('hide-aside')
   } else {
     document.documentElement.classList.remove('hide-aside')
   }
}})()</script><link rel="stylesheet" href="/css/background.css"><link rel="stylesheet" href="/css/mouse.css"><link rel="stylesheet" href="/css/scrollbar.css"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/iconfont.css"><meta name="generator" content="Hexo 5.3.0"><link rel="alternate" href="/atom.xml" title="浅幽丶奈芙莲的个人博客" type="application/atom+xml">
</head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="author-avatar"><img class="avatar-img" src="/img/avatar.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">102</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">10</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">17</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/photo/"><i class="fa-fw fas fa-heart"></i><span> 相册</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友情链接</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E5%AE%8C%E7%BB%93%E7%9B%AE%E5%BD%95/%E4%BA%8Ced12.jpg)"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">浅幽丶奈芙莲的个人博客</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/photo/"><i class="fa-fw fas fa-heart"></i><span> 相册</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友情链接</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">操作系统-Part3</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2021-11-01T01:43:49.000Z" title="发表于 2021-11-01 09:43:49">2021-11-01</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2021-11-16T08:41:07.964Z" title="更新于 2021-11-16 16:41:07">2021-11-16</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">操作系统</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">10.7k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>31分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="操作系统-Part3——内存管理"><a href="#操作系统-Part3——内存管理" class="headerlink" title="操作系统-Part3——内存管理"></a>操作系统-Part3——内存管理</h1><p>[TOC]</p>
<h2 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h2><h3 id="内存的基础知识"><a href="#内存的基础知识" class="headerlink" title="内存的基础知识"></a>内存的基础知识</h3><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part3/image-20211106201311424.png" alt="image-20211106201311424" style="zoom:100%;">

<ul>
<li>编译：由编译程序将用户<strong>源代码</strong>编译成若干个<strong>目标模块</strong>（编译就是把高级语言翻译为机器语言）</li>
<li>链接：由链接程序将编译后形成的一组目标模块，以及所需库函数链接在一起，形成一个完整的<strong>装入模块</strong></li>
<li>装入（装载）：由装入程序<strong>将装入模块装入内存</strong>运行</li>
<li><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part3/image-20211106201147384.png" alt="image-20211106201147384"></li>
</ul>
<h4 id="装入的三种方式"><a href="#装入的三种方式" class="headerlink" title="装入的三种方式"></a>装入的三种方式</h4><ul>
<li><strong>绝对装入</strong>：<ul>
<li>编译后，在可执行文件中<strong>直接指出程序装入内存后的绝对地址</strong>。</li>
<li><strong>由编译器完成</strong>，因为此时还未出现操作系统。</li>
<li><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part3/image-20211106184745104.png" alt="image-20211106184745104" style="zoom:67%;"></li>
<li>缺点：<ul>
<li>只适用于一台机器</li>
<li>只适用于单道程序环境</li>
</ul>
</li>
<li>程序中使用的绝对地址，可在编译或汇编时给出，也可由程序员直接赋予。通常情况下都是编译或汇编时再转换为绝对地址。</li>
</ul>
</li>
<li><strong>静态重定位</strong>（可重定位装入）：<ul>
<li>编译后，装入模块的地址都是从 0 开始的，指令中使用的地址、数据存放的地址都是相对于起始地址而言的<strong>逻辑地址</strong>。</li>
<li>根据内存的情况，将装入模块装入到内存的适当位置。装入时对地址进行“重定位”，将逻辑地址变换为物理地址（<strong>地址变换是在装入时一次完成的</strong>）。</li>
<li><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part3/image-20211106184445773.png" alt="image-20211106184445773" style="zoom: 67%;"></li>
<li>特点：<ul>
<li>在一个作业装入内存时，<strong>必须分配其要求的全部内存空间</strong>，如果没有足够的内存，就不能装入该作业。</li>
<li>作业一旦进入内存后，<strong>在运行期间就不能再移动</strong>，也不能再申请内存空间。</li>
</ul>
</li>
</ul>
</li>
<li><strong>动态重定位</strong>（动态运行时装入）：<ul>
<li>编译后，装入模块的地址都是从 0 开始的，指令中使用的地址、数据存放的地址都是相对于起始地址而言的<strong>逻辑地址</strong>。（同静态重定位）</li>
<li>装入程序把装入模块装入内存后，<strong>并不会把逻辑地址转换为物理地址</strong>，而是<strong>把地址转换推迟到程序真正执行时进行</strong>。因此装入内存后所有的地址依然是<strong>逻辑地址</strong>。这种方式需要一个<strong>重定位寄存器</strong>的支持，用于<strong>存放装入模块的起始位置</strong>。</li>
<li><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part3/image-20211106200839645.png" alt="image-20211106200839645" style="zoom:67%;"></li>
<li>特点：<ul>
<li><strong>可将程序分配到不连续的存储区中</strong></li>
<li>程序<strong>只需装入部分代码</strong>即可运行，并根据需要<strong>动态申请分配内存</strong></li>
<li>便于程序段的共享，可以向用户提供一个比存储空间大得多的地址空间</li>
<li>采用动态重定位时<strong>允许程序在内存中发生移动</strong></li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="链接的三种方式"><a href="#链接的三种方式" class="headerlink" title="链接的三种方式"></a>链接的三种方式</h4><ul>
<li><strong>静态链接</strong>：<ul>
<li>在程序运行之前，先将各目标模块及它们所需的库函数连接成一个完整的可执行文件（装入模块），之后不再拆开。</li>
<li><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part3/image-20211106201450752.png" alt="image-20211106201450752" style="zoom: 67%;"></li>
</ul>
</li>
<li><strong>装入时动态链接</strong>：<ul>
<li>将各目标模块装入内存时，边装入边链接的链接方式。</li>
<li><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part3/image-20211106201530718.png" alt="image-20211106201530718" style="zoom:67%;"></li>
</ul>
</li>
<li><strong>运行时动态链接</strong>：<ul>
<li>在程序执行中需要该目标模块时，才对它进行链接。其优点是便 于修改和更新，便于实现对目标模块的共享。</li>
<li>优点：灵活性更高，提高对内存的利用率</li>
<li><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part3/image-20211106201608804.png" alt="image-20211106201608804" style="zoom:67%;">

</li>
</ul>
</li>
</ul>
<h3 id="内存管理的概念"><a href="#内存管理的概念" class="headerlink" title="内存管理的概念"></a>内存管理的概念</h3><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part3/image-20211106203022788.png" alt="image-20211106203022788" style="zoom:100%;">

<p>操作系统对内存管理需要实现的四个功能</p>
<ul>
<li>操作系统需要负责<strong>内存空间的分配与回收</strong></li>
<li>操作系统需要提供某种技术从逻辑上<strong>对内存空间进行扩充</strong></li>
<li>操作系统需要提供<strong>地址转换功能</strong>，负责程序的逻辑地址与物理地址的转换<ul>
<li>即装入的三种方式：绝对装入、可重定位装入（静态重定位）、动态运行时装入（动态重定位）</li>
</ul>
</li>
<li>操作系统需要提供<strong>内存保护</strong>功能。保证各进程在各自存储空间内运行，互不干扰<ul>
<li>方法一：在 CPU 中设置<strong>一对上、下限寄存器</strong>，存放进程的上、下限地址。进程的指令要访问某个地址时，CPU 检查是否越界。</li>
<li>方法二：采用<strong>重定位寄存器（基址寄存器）</strong>和<strong>界地址寄存器（限长寄存器）</strong>进行越界检查。分别存放进程的<strong>起始物理地址</strong>和<strong>最大逻辑地址</strong>。</li>
</ul>
</li>
</ul>
<h3 id="覆盖与交换"><a href="#覆盖与交换" class="headerlink" title="覆盖与交换"></a>覆盖与交换</h3><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part3/image-20211106204129149.png" alt="image-20211106204129149" style="zoom:100%;">

<ul>
<li><strong>覆盖技术</strong><ul>
<li>思想：将程序分为多个段（多个模块）。常用的段常驻内存，不常用的段在需要时调入内存。</li>
<li>内存中分为一个“<strong>固定区</strong>”和若干个“<strong>覆盖区</strong>”。<ul>
<li>需要常驻内存的段放在“固定区”中，<strong>调入后就不再调出</strong>（除非运行结束）</li>
<li>不常用的段放在“覆盖区”，<strong>需要用到时调入内存，用不到时调出内存</strong><ul>
<li>按照自身逻辑结构，让那些<strong>不可能同时被访问</strong>的程序段共享同一个覆盖区，覆盖区大小以最大的程序段为准</li>
<li><strong>必须由程序员声明覆盖结构</strong>，操作系统完成自动覆盖。</li>
</ul>
</li>
</ul>
</li>
<li><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part3/image-20211106204512297.png" alt="image-20211106204512297" style="zoom:80%;"></li>
<li>缺点：对用户不透明，<strong>增加了编程负担</strong>。因此，只用于早期的操作系统中，现在已成为历史。</li>
</ul>
</li>
<li><strong>交换技术</strong><ul>
<li>思想：内存空间紧张时，系统将内存中某些进程暂时<strong>换出</strong>外存，把外存中某些已具备运行条件的进程<strong>换入</strong>内存（进程在内存与磁盘间动态调度）<ul>
<li>中级调度（内存调度），决定将哪个处于挂起状态的进程重新调入内存。</li>
<li>挂起队列中的 <strong>PCB 要负责记录挂起进程在磁盘中的位置</strong>。因此，<strong>PCB 会常驻内存</strong>，不会被换出外存</li>
<li>暂时换出外存等待的进程状态为<strong>挂起状态</strong>（suspend），进一步细分为<strong>就绪挂起</strong>、<strong>阻塞挂起</strong>两种状态</li>
</ul>
</li>
<li><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part3/image-20211107092841147.png" alt="image-20211107092841147" style="zoom:67%;"></li>
<li>交换的进程在外存中保存的位置<ul>
<li>具有对换功能的操作系统中，通常把磁盘空间分为<strong>文件区</strong>和<strong>对换区</strong>两部分。</li>
<li>文件区主要用于存放文件，主要追求<strong>存储空间的利用率</strong>，因此对文件区空间的管理采用<strong>离散分配方式</strong></li>
<li>对换区空间只占磁盘空间的小部分，用于存放被换出的进程数据，主要追求<strong>换入换出速度</strong>以提升系统的整体速度，因此通常对换区采用<strong>连续分配方式</strong>。</li>
<li>总之，对换区的 I/O 速度比文件区的更快。</li>
</ul>
</li>
<li>交换的时机<ul>
<li>交换通常在许多进程运行且内存吃紧（经常发生缺页）时进行，而系统负荷降低（缺页率明显下降）就暂停。</li>
</ul>
</li>
<li>交换的对象进程<ul>
<li>可优先换出<strong>阻塞进程</strong></li>
<li>可换出<strong>优先级低的进程</strong></li>
<li>为了防止优先级低的进程在频繁调入调出内存，有的系统还会考虑<strong>进程在内存的驻留时间</strong></li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="连续分配管理方式"><a href="#连续分配管理方式" class="headerlink" title="连续分配管理方式"></a>连续分配管理方式</h3><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part3/image-20211107094033664.png" alt="image-20211107094033664" style="zoom:100%;">

<ul>
<li><strong>连续分配</strong>：为用户进程分配的必须是一个<strong>连续的内存空间</strong>。</li>
<li><strong>非连续分配</strong>：为用户进程分配的可以是一些<strong>分散的内存空间</strong>。</li>
</ul>
<p>三种连续分配方式：</p>
<ul>
<li><strong>单一连续分配</strong><ul>
<li>在单一连续分配方式中，内存被分为<strong>系统区</strong>和<strong>用户区</strong>。<ul>
<li>系统区通常位于<strong>内存的低地址部分</strong>，用于存放操作系统相关数据；用户区用于存放用户进程相关数据。</li>
<li>内存中只能有一道用户程序，用户程序<strong>独占</strong>整个用户区空间。</li>
<li><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part3/image-20211107095633275.png" alt="image-20211107095633275" style="zoom:50%;"></li>
</ul>
</li>
<li>优点：<ul>
<li>实现简单</li>
<li><strong>无外部碎片</strong></li>
<li>可以采用覆盖技术扩充内存</li>
<li><strong>不一定</strong>需要采取内存保护（eg：早期的 PC 操作系统 MS-DOS）。</li>
</ul>
</li>
<li>缺点：<ul>
<li>只能用于<strong>单用户、单任务</strong>的操作系统中</li>
<li><strong>有内部碎片</strong>（分配给某进程的内存区域中，没有使用的部分）</li>
<li><strong>存储器利用率极低</strong>。</li>
</ul>
</li>
</ul>
</li>
<li><strong>固定分区分配</strong><ul>
<li>将整个<strong>用户空间</strong>划分为<strong>若干个固定大小的分区</strong>，在<strong>每个分区中只装入一道作业</strong>。是最早的、最简单的一种可运行多道程序、不会相互干扰的内存管理方式。<ul>
<li><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part3/image-20211107095934415.png" alt="image-20211107095934415" style="zoom: 50%;"></li>
</ul>
</li>
<li>特点：<ul>
<li><strong>分区大小相等</strong>：缺乏灵活性，但是很适合用于用一台计算机控制多个相同对象的场合<ul>
<li>比如：钢铁厂有 n 个相同的炼钢炉，就可把内存分为 n 个大小相等的区域存放 n 个炼钢炉控制程序</li>
</ul>
</li>
<li><strong>分区大小不等</strong>：增加了灵活性，可以满足不同大小的进程需求。根据常在系统中运行的作业大小情况进行划分<ul>
<li>比如：划分多个小分区、适量中等分区、少量大分区</li>
</ul>
</li>
</ul>
</li>
<li><strong>分区说明表</strong><ul>
<li>实现各个分区的分配与回收。每个表项对应一个分区，通常按分区大小排列。每个表项包括对应分区的<strong>大小</strong>、<strong>起始地址</strong>、<strong>状态</strong>（是否已分配）。</li>
<li><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part3/image-20211107100114456.png" alt="image-20211107100114456" style="zoom:67%;"></li>
<li>优点：实现简单，<strong>无外部碎片</strong>。</li>
<li>缺点：<ul>
<li>当用户程序太大时，可能所有的分区都不能满足需求，此时不得不采用覆盖技术来解决，但这又会降低性能</li>
<li>会产生内部碎片，内存利用率低。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><strong>动态分区分配</strong><ul>
<li>动态分区分配（可变分区分配），<strong>不会预先划分内存分区</strong>，而是在进程装入内存时，<strong>根据进程的大小动态地建立分区</strong>，并使分区的大小正好适合进程的需要。<ul>
<li>因此系统分区的大小和数目是可变的。</li>
</ul>
</li>
<li>记录内存使用情况的数据结构<ul>
<li>两种常用的数据结构：<strong>空闲分区表</strong>、<strong>空闲分区链</strong></li>
<li><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part3/image-20211107101014557.png" alt="image-20211107101014557"></li>
</ul>
</li>
<li>多个空闲分区的分配选择<ul>
<li>四种<strong>动态分区分配算法</strong></li>
</ul>
</li>
<li>分区的分配与回收<ul>
<li>回收内存分区时，相邻分区需要合并<ul>
<li>回收区的后面有一个相邻的空闲分区（修改分区大小和起始地址）</li>
<li>回收区的前面有一个相邻的空闲分区（修改分区大小）</li>
<li>回收区的前、后各有一个相邻的空闲分区（合并分区表项，修改分区大小）</li>
<li>回收区的前、后都没有相邻的空闲分区（新建分区表项）</li>
</ul>
</li>
<li>注：各表项的顺序不一定按照地址递增顺序排列，需要依据动态分区分配算法来确定。</li>
</ul>
</li>
<li>动态分区分配<strong>没有内部碎片</strong>，但是<strong>有外部碎片</strong>。<ul>
<li>内部碎片，内存中<strong>进程所属的分区中</strong>没有利用的部分</li>
<li>外部碎片，内存中<strong>非进程所属分区中</strong>没有利用的部分</li>
<li>可以通过<strong>紧凑</strong>（拼凑，Compaction）技术来解决外部碎片。<ul>
<li>移动进程分区首地址以腾出连续空间</li>
<li>适用于<strong>动态重定位</strong></li>
<li>紧凑之后需要修改 CPB 中的起始地址信息</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="动态分区分配算法"><a href="#动态分区分配算法" class="headerlink" title="动态分区分配算法"></a>动态分区分配算法</h3><ul>
<li>首次适应算法（First Fit）<ul>
<li>算法思想：从低地址开始找到第一个适合的分区</li>
<li>分区排列顺序：空闲分区以<strong>地址递增</strong>次序排列</li>
<li>优点：<ul>
<li><strong>综合看性能最好</strong>。<strong>算法开销小</strong>（回收分区后不需要对空闲分区队列重新排序）</li>
<li>每次都需要检索低地址的小分区。有可能把高地址部分的大分区保留下来（最佳适应算法的优点）</li>
</ul>
</li>
</ul>
</li>
<li>最佳适应算法（Best Fit）<ul>
<li>算法思想：优先使用更小的分区，以保留更多大分区</li>
<li>分区排列顺序：空闲分区以<strong>容量递增</strong>次序排列</li>
<li>优点：会有更多的大分区被保留下来，更能满足大进程需求</li>
<li>缺点：会产生越来越多太小的、难以利用的碎片；<strong>算法开销大</strong>（回收分区后可能需要对空闲分区队列重新排序）</li>
</ul>
</li>
<li>最坏适用算法（Worst Fit）<ul>
<li>算法思想：优先使用更大的分区，以防止产生太小的不可用的碎片</li>
<li>分区排列顺序：空闲分区以<strong>容量递减</strong>次序排列</li>
<li>优点：可以减少难以利用的小碎片</li>
<li>缺点：大分区容易被用完，不利于后续的大进程；<strong>算法开销大</strong></li>
</ul>
</li>
<li>临近适应算法（Next Fit）<ul>
<li>算法思想：由首次适应演变而来，每次从上次查找结束位置开始查找</li>
<li>分区排列顺序：空闲分区以<strong>地址递增</strong>次序排列（可排列成循环链表）</li>
<li>优点：不用每次都从低地址的小分区开始检索。<strong>算法开销小</strong></li>
<li>缺点：可能会使高地址的大分区也被用完</li>
</ul>
</li>
</ul>
<h3 id="基本分页存储管理的基本概念（重点）"><a href="#基本分页存储管理的基本概念（重点）" class="headerlink" title="基本分页存储管理的基本概念（重点）"></a>基本分页存储管理的基本概念（重点）</h3><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part3/image-20211108133534598.png" alt="image-20211108133534598" style="zoom:100%;">

<ul>
<li><p>分页存储：</p>
<ul>
<li>将内存空间分为一个个<strong>大小相等的分区</strong>，每个分区就是一个<strong>页框</strong>（<strong>页框=页帧=内存块=物理块=物理页面</strong>）。<ul>
<li>每个页框有一个<strong>页框号</strong>（<strong>页框号=页帧号=内存块号=物理块号=物理页号</strong>），页框号从 0 开始。</li>
</ul>
</li>
<li>将<strong>进程的逻辑地址空间</strong>也分为<strong>与页框大小相等</strong>的一个个部分，每个部分称为一个<strong>页</strong>（<strong>页=页面</strong>） 。<ul>
<li>每个页面有一个“页号”，页号从 0 开始。</li>
</ul>
</li>
<li>注意区别：页、页面 vs 页框、页帧、物理页</li>
<li>操作系统<strong>以页框为单位</strong>为各个进程分配内存空间。进程的每个页面分别放入一个页框中。进程的页面与内存的页框有一一对应的关系。<ul>
<li>各个页面不必连续存放，可以放到不相邻的各个页框中。</li>
</ul>
</li>
<li>注：进程的最后一个页面可能没有一个页框那么大。即，<strong>分页存储有可能产生内部碎片</strong>。因此页框不能太大，否则可能产生过大的内部碎片造成浪费</li>
</ul>
</li>
<li><p>页表：</p>
<ul>
<li>一个进程对应一张页表</li>
<li>进程的每个页面对应一个页表项</li>
<li>每个<strong>页表项</strong>由“页号”和“块号”组成</li>
<li>页表记录<strong>进程页面</strong>和<strong>实际存放的内存块</strong>之间的映射关系</li>
<li>每个页表项的长度是相同的</li>
<li><strong>指向页表的指针存在于 PCB（进程控制块）中</strong></li>
<li><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part3/image-20211108115320995.png" alt="image-20211108115320995"></li>
</ul>
</li>
<li><p>每个页表项的长度计算</p>
<ul>
<li>Eg：假设某系统物理内存大小为 4GB，页面大小为 4KB，则每个页表项至少应该为多少字节？</li>
<li><strong>内存块大小</strong>=<strong>页面大小</strong>=4KB= 2^12^B <ul>
<li>4GB 的内存总共会被分为 2^32^ / 2^12^ = 2^20^ 个内存块</li>
<li>内存块号的范围应该是 0 ~ 2^20^-1 </li>
<li>内存块号至少要用 20bit 来表示</li>
<li>至少要用 3B 来表示块号（3*8=24bit）<ul>
<li>重要考点：计算机中<strong>内存块的数量</strong> -&gt; 页表项中<strong>块号至少占多少字节</strong></li>
</ul>
</li>
<li>页表中的<strong>页号是隐含的</strong>，即<strong>页号不占用存储空间</strong></li>
</ul>
</li>
<li>每个页表项占 3B，存储整个页表至少需要 (n+1)*3B</li>
<li>注意：页表记录的只是内存块号，而不是内存块的起始地址。*<em>J 号内存块的起始地址 = J * 内存块大小*</em></li>
</ul>
</li>
<li><p>实现地址的转换（重点）</p>
<ul>
<li><blockquote>
<p>逻辑地址A对应的物理地址 = P号页面在内存中的起始地址 + 页内偏移量W</p>
</blockquote>
<ul>
<li><strong>页号 = 逻辑地址 / 页面长度</strong></li>
<li><strong>页内偏移量 = 逻辑地址 % 页面长度</strong></li>
<li>*<em>起始地址 = 页表[页号] * 内存块大小*</em></li>
</ul>
</li>
<li><p>如果页面大小为 2^K^B，逻辑地址可以快速拆分为页号、页内偏移量</p>
<ul>
<li>在逻辑地址中，<strong>末尾 K 位为页内偏移量</strong>，其余前半部分为页号</li>
<li>在物理地址中，末尾 K 位为页内偏移量，<strong>其余前半部分为页表[页号]</strong></li>
<li><blockquote>
<p>即，对于页面大小为 2^K^B 的情况来说，直接将逻辑地址的<strong>页号</strong>部分替换成<strong>页框号</strong></p>
</blockquote>
</li>
</ul>
</li>
</ul>
</li>
<li><p>逻辑地址结构</p>
<ul>
<li><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part3/image-20211108133314602.png" alt="image-20211108133314602" style="zoom:80%;"></li>
<li>地址长度为 32 位；其中 0<del>11位 为“<strong>页内偏移量</strong>”（<strong>页内地址</strong>）；12</del>31 位为“<strong>页号</strong>”。</li>
<li><strong>如果有 K 位表示“页内偏移量”，则说明该系统中一个页面的大小是 2^K^ 个内存单元</strong></li>
<li><strong>如果有 M 位表示“页号”，则说明在该系统中一个进程最多允许有 2^M^ 个页面</strong></li>
</ul>
</li>
</ul>
<h3 id="基本地址变换机构（重点）"><a href="#基本地址变换机构（重点）" class="headerlink" title="基本地址变换机构（重点）"></a>基本地址变换机构（重点）</h3><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part3/image-20211108133940207.png" alt="image-20211108133940207" style="zoom:100%;">

<ul>
<li>基本地址变换机构可以借助进程的页表将逻辑地址转换为物理地址：（重点）<ul>
<li><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part3/image-20211108134704399.png" alt="image-20211108134704399" style="zoom: 80%;"></li>
<li>进程未执行时，<strong>页表的始址</strong>和<strong>页表长度</strong>放在<strong>进程控制块</strong>（PCB）中；当进程被调度时，操作系统内核会把它们放到页表寄存器中。</li>
<li>设页面大小为 L、起始地址 F、页表长度 M、逻辑地址 A 到物理地址 E 的变换过程：<ol>
<li>计算页号 P 和页内偏移量 W<ul>
<li>P=A/L，W=A%L</li>
</ul>
</li>
<li>比较页号 P 和页表长度 M，<strong>若 P≥M</strong>，则产生越界中断</li>
<li>页表中页号 P 对应的*<em>页表项地址 = 页表起始地址 F + 页号 P * 页表项长度*</em>。取出该页表项内容 b，即为内存块号。<ul>
<li>注意：区分<strong>页表项长度</strong>、<strong>页表长度</strong>、<strong>页面大小</strong>。</li>
<li>页表长度，指这个页表中总共有几个页表项，即总共有几个页</li>
<li>页表项长度，指的是每个页表项占多大的存储空间</li>
<li>页面大小，指的是一个页面占多大的存储空间</li>
</ul>
</li>
<li>计算 E = b * L + W，用得到的物理地址 E 去访存。<ul>
<li>如果内存块号、页面偏移量是用二进制表示的，则直接把二者拼接即物理地址</li>
</ul>
</li>
</ol>
</li>
<li>在分页存储管理（页式管理）的系统中：<ul>
<li><strong>页面的大小和逻辑地址结构是互相确定的</strong>：页面大小 L 为 1K 字节 == 某系统<strong>按字节寻址</strong>，逻辑地址结构中，<strong>页内偏移量占 10 位</strong></li>
<li><strong>页式管理中地址是一维的</strong>（只需要一个参数）：只要给出一个逻辑地址，就可以直接求得页号、页内偏移量</li>
</ul>
</li>
</ul>
</li>
<li>对页表项大小的进一步探讨<ul>
<li><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part3/image-20211110103417636.png" alt="image-20211110103417636"></li>
<li>一般不会考察，当问最小的页表长度时，按 3B 回答</li>
</ul>
</li>
</ul>
<h3 id="具有快表的地址变换机构"><a href="#具有快表的地址变换机构" class="headerlink" title="具有快表的地址变换机构"></a>具有快表的地址变换机构</h3><ul>
<li><strong>快表，联想寄存器</strong>（<strong>TLB</strong>， translation lookaside buffer）<ul>
<li><strong>TLB 不是内存，是 cache</strong></li>
<li>用来存放最近访问的页表项的<strong>副本</strong></li>
<li>与此对应，内存中的页表常称为<strong>慢表</strong>。</li>
</ul>
</li>
<li>引入快表之后的地址变换过程<ul>
<li><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part3/image-20211110181512724.png" alt="image-20211110181512724"></li>
<li>CPU 给出逻辑地址，由硬件算得页号、页内偏移量，将页号与<strong>快表中的所有页号</strong>进行比较。</li>
<li>若命中，则直接从 TLB 取出目标的内存块号，与页内偏移量拼接形成物理地址，访问对应的内存单元。<ul>
<li>因此，若<strong>快表命中</strong>，则访问某个逻辑地址<strong>仅需一次访存</strong>即可。</li>
</ul>
</li>
<li>若没有命中，则需要访问内存中的页表，通过页表始址和页号定位对应页表项，得到目标的内存块号，再将内存块号与页内偏移量拼接形成物理地址，访问该对应的内存单元。<ul>
<li>因此，若<strong>快表未命中</strong>，则访问某个逻辑地址<strong>需要两次访存</strong></li>
<li>在找到页表项后，应同时将其存入快表，以便后面可能的再次访问。</li>
<li>若快表已满，则必须按照一定的算法对旧的页表项进行替换</li>
<li><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part3/image-20211110182850496.png" alt="image-20211110182850496" style="zoom:80%;"></li>
</ul>
</li>
</ul>
</li>
<li>局部性原理<ul>
<li>时间局部性：如果执行了程序中的某条指令，那么不久后这条指令很有可能再次执行；如果某个数据被访问过，不久之后该数据很可能再次被访问。<ul>
<li>因为程序中存在大量的循环</li>
</ul>
</li>
<li>空间局部性：一旦程序访问了某个存储单元，在不久之后，其附近的存储单元也很有可能被访问。<ul>
<li>因为很多数据在内存中都是连续存放的</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>总结</p>
<ul>
<li><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part3/image-20211110183624691.png" alt="image-20211110183624691"></li>
</ul>
<h3 id="两级页表"><a href="#两级页表" class="headerlink" title="两级页表"></a>两级页表</h3><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part3/image-20211110192048406.png" alt="image-20211110192048406" style="zoom:100%;">

<ul>
<li>针对问题：<ul>
<li>单级页表必须连续存放，因此<strong>当页表很大时，需要占用很多个连续的页框</strong>，与离散分配存储管理相悖。</li>
<li>没有必要让整个页表常驻内存，因为根据局部性原理，<strong>进程在一段时间内可能只需要访问某几个特定的页面</strong>。</li>
</ul>
</li>
<li>改进方向：<ul>
<li>把页表再分页并离散存储，建立一张页表记录页表各个部分的存放位置</li>
<li>该页表称为<strong>页目录表/外层页表/顶层页表</strong></li>
</ul>
</li>
<li>二级页表的结构<ul>
<li><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part3/image-20211110190608035.png" alt="image-20211110190608035"></li>
<li>与单级页表的结构意义是相同的，前半部分来找到<strong>内存块号</strong>，后半部分为<strong>页内偏移量</strong></li>
<li>页目录表的 item 记录<strong>二级页表在内存中的内存块号</strong>，二级页表的 item 记录<strong>数据在内存中的内存块号</strong></li>
<li>页目录表、二级页表的每个页表项都增加一个标志位，用于<strong>表示该页面是否已经调入内存</strong>，否则产生<strong>缺页中断</strong>（内中断/异常）</li>
</ul>
</li>
<li>注意：<ul>
<li>若分为两级页表后，页表依然很长，则可以采用更多级页表，<strong>各级页表的大小不能超过一个页面</strong><ul>
<li><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part3/image-20211110191953863.png" alt="image-20211110191953863"></li>
</ul>
</li>
<li>两级页表的访存次数分析（假设没有快表机构）<ul>
<li>第一次访存：访问内存中的页目录表</li>
<li>第二次访存：访问内存中的二级页表</li>
<li>第三次访存：访问目标内存单元</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="基本分段存储管理方式"><a href="#基本分段存储管理方式" class="headerlink" title="基本分段存储管理方式"></a>基本分段存储管理方式</h3><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part3/image-20211111112309332.png" alt="image-20211111112309332" style="zoom:100%;">

<ul>
<li><p>进程的地址空间：按照程序<strong>自身的逻辑</strong>关系<strong>划分为若干个段</strong>，每个段都有一个段名，<strong>每段从 0 开始编址</strong>。</p>
</li>
<li><p>内存分配规则：以段为单位进行分配，<strong>每个段在内存中占据连续空间</strong>，但<strong>各段之间可以不相邻</strong>。</p>
</li>
<li><p>分段存储管理方式的优点：按逻辑功能模块划分，<strong>编程更方便</strong>，<strong>程序的可读性更高</strong>。</p>
</li>
<li><p>分段系统的逻辑地址结构：</p>
<ul>
<li><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part3/image-20211110193605564.png" alt="image-20211110193605564" style="zoom:80%;"></li>
<li><strong>段号的位数决定了每个进程最多可以分几个段</strong></li>
<li><strong>段内地址位数决定了每个段的最大长度是多少</strong></li>
</ul>
</li>
<li><p>段表</p>
<ul>
<li><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part3/image-20211110194243704.png" alt="image-20211110194243704"></li>
<li>每个段对应一个段表项，其中记录了该段在内存中的<strong>基址</strong>和<strong>长度</strong>。</li>
<li><strong>各个段表项的长度是相同的</strong>。因此，<strong>段号也是隐含的</strong>。<ul>
<li>例如：某系统按字节寻址，采用分段存储管理，逻辑地址结构为（段号 16 位, 段内地址 16 位），因此用 16 位即可表示最大段长。物理内存大小为4GB（可用 32 位表示整个物理内存地址空间）。因此，可以让每个段表项占 16+32 = 48位，即 6B。</li>
</ul>
</li>
</ul>
</li>
<li><p>地址变换过程</p>
<ul>
<li><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part3/image-20211110194425962.png" alt="image-20211110194425962"></li>
</ul>
</li>
<li><p>信息的共享和保护</p>
<ul>
<li><p>不可修改的代码（纯代码/可重入代码）是可以共享的。可修改的代码是不能共享的。</p>
<ul>
<li>不可修改的代码<strong>不属于临界资源</strong>。</li>
<li>可修改的代码（代码段）可能包含很多变量，各进程并发访问可能造成数据不一致</li>
</ul>
</li>
<li><p>只需让各进程的<strong>段表项指向同一个段</strong>即可实现共享</p>
</li>
<li><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part3/image-20211111111620647.png" alt="image-20211111111620647" style="zoom:80%;">


</li>
</ul>
</li>
</ul>
<blockquote>
<p><strong>分段、分页管理的对比</strong></p>
<ul>
<li>目的<ul>
<li><strong>页</strong>是<strong>信息的物理单位</strong>。分页的主要目的是为了实现离散分配，提高内存利用率。分页仅仅是系统管理上的需要，完全是系统行为，<strong>对用户是不可见的</strong>。 </li>
<li><strong>段</strong>是<strong>信息的逻辑单位</strong>。分段的主要目的是更好地满足用户需求。一个段通常包含着一组属于一个逻辑模块的信息。<strong>分段对用户是可见的</strong>，用户编程时需要显式地给出段名。</li>
</ul>
</li>
<li>长度<ul>
<li>页的大小固定且由系统决定。段的长度却不固定，决定于用户编写的程序。</li>
</ul>
</li>
<li>维度<ul>
<li><strong>分页</strong>的用户进程地址空间是<strong>一维</strong>的，只需给出<strong>一个记忆符</strong>即可表示一个地址。</li>
<li><strong>分段</strong>的用户进程地址空间是<strong>二维</strong>的，在标识一个地址时，既要给出<strong>段名</strong>，也要给出<strong>段内地址</strong>。</li>
</ul>
</li>
<li>共享与保护<ul>
<li>分段比分页<strong>更容易实现信息的共享和保护</strong>。不可修改的代码（纯代码/可重入代码）是可以共享的。可修改的代码是不能共享的。</li>
</ul>
</li>
<li>访存次数<ul>
<li>分页（单级页表）：查内存中的页表（第一次访存）+ 访问目标内存单元（第二次访存）。总共两次访存</li>
<li>分段：查内存中的段表（第一次访存）+ 访问目标内存单元（第二次访存）。总共两次访存。<ul>
<li>分段系统中也可以引入<strong>快表</strong>机构，将近期访问过的段表项放到快表中，这样可以少一次访问，加快地址变换速度。</li>
</ul>
</li>
</ul>
</li>
</ul>
</blockquote>
<h3 id="段页式管理方式"><a href="#段页式管理方式" class="headerlink" title="段页式管理方式"></a>段页式管理方式</h3><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part3/image-20211111112409226.png" alt="image-20211111112409226" style="zoom:100%;">

<ul>
<li>针对问题：<ul>
<li>分页管理<ul>
<li><strong>优点</strong>：内存空间利用率高，<strong>不会产生外部碎片</strong>，只会有少量的页内碎片</li>
<li><strong>缺点</strong>：不方便按照逻辑模块实现信息的共享和保护</li>
</ul>
</li>
<li>分段管理<ul>
<li><strong>优点</strong>：很方便按照逻辑模块实现信息的共享和保护</li>
<li><strong>缺点</strong>：1. 当段长过大时，分配很大的连续空间会很不方便。2. <strong>会产生外部碎片</strong>（可以用“紧凑”来解决，只是需要付出较大的时间代价）</li>
</ul>
</li>
</ul>
</li>
<li>段页式管理的实现<ul>
<li><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part3/image-20211111113416029.png" alt="image-20211111113416029" style="zoom:80%;"></li>
<li>理论：将进程按逻辑<strong>先按模块分段</strong>，<strong>再将各段分页</strong></li>
<li>段页式系统的逻辑地址结构：<ul>
<li>由段号、页号、页内地址（页内偏移量）组成。</li>
<li><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part3/image-20211111114030310.png" alt="image-20211111114030310" style="zoom:80%;"></li>
<li><strong>段号的位数</strong>决定了<strong>每个进程最大段数</strong><ul>
<li>段号占 16 位，每个进程最多有 2^16^=64K 个段</li>
</ul>
</li>
<li><strong>页号位数</strong>决定了<strong>每个段最大页数</strong><ul>
<li>页号占 4 位，每个段最多有 2^4^=16 页</li>
</ul>
</li>
<li><strong>页内偏移量</strong>决定了<strong>页面/内存块大小</strong><ul>
<li>页内偏移量占 12 位，每个页面\每个内存块大小为 2^12^=4096=4KB</li>
</ul>
</li>
</ul>
</li>
<li>分段对用户是可见的，编程时需要<strong>显式地给出段号、段内地址</strong>。而将各段分页对用户是不可见的，系统会根据段内地址<strong>自动划分页号和页内偏移量</strong>。<ul>
<li><strong>段页式管理的地址结构是二维的</strong>。</li>
</ul>
</li>
<li><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part3/image-20211111114731857.png" alt="image-20211111114731857"><ul>
<li>每个段对应一个段表项，每个段表项由<strong>段号、页表长度、页表存放块号（页表起始地址）</strong>组成。每个段表项长度相等，段号是隐含的。</li>
<li>每个页面对应一个页表项，每个页表项由<strong>页号、页面存放的内存块号</strong>组成。每个页表项长度相等，页号是隐含的。</li>
</ul>
</li>
<li>地址转换过程<ul>
<li><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part3/image-20211111115141951.png" alt="image-20211111115141951"></li>
<li>得到段号、页号、页内偏移量</li>
<li>检查段号越界</li>
<li>根据段号找到段表项，取页表起始块号、长度</li>
<li>检查页号越界</li>
<li>根据页号找到页表项，取目标数据的内存块号</li>
<li>访问目标内存单元</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="虚拟内存管理"><a href="#虚拟内存管理" class="headerlink" title="虚拟内存管理"></a>虚拟内存管理</h2><h3 id="虚拟内存的基本概念"><a href="#虚拟内存的基本概念" class="headerlink" title="虚拟内存的基本概念"></a>虚拟内存的基本概念</h3><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part3/image-20211111120739916.png" alt="image-20211111120739916" style="zoom:100%;">

<ul>
<li>传统存储管理方式的特征、缺点<ul>
<li>一次性：作业<strong>必须一次性全部装入</strong>内存后才能开始运行。这会造成两个问题：<ul>
<li>作业很大时，不能全部装入内存，导致大作业无法运行</li>
<li>当大量作业要求运行时，由于内存无法容纳所有作业，因此只有少量作业能运行，导致多道程序并发度下降。</li>
</ul>
</li>
<li>驻留性：一旦作业被装入内存，就会<strong>一直驻留在内存中</strong>，直至作业运行结束。<ul>
<li>事实上，在一个时间段内，只需要访问作业的一小部分数据即可正常运行，这就导致了内存中会驻留大量暂时用不到的数据，浪费了宝贵的内存资源。</li>
</ul>
</li>
</ul>
</li>
<li>虚拟内存的定义：<ul>
<li>基于局部性原理，在程序装入时，可以将程序中<strong>很快会用到的部分装入内存，暂时用不到的部分留在外存</strong>，就可以让程序开始执行。</li>
<li>在程序执行过程中，当所访问的<strong>信息不在内存时，由操作系统负责将所需信息从外存调入内存</strong>，然后继续执行程序。<ul>
<li>操作系统要提供<strong>请求调页（请求调段）</strong>功能</li>
</ul>
</li>
<li>若内存空间不够，由<strong>操作系统负责将内存中暂时用不到的信息换出到外存</strong>。<ul>
<li>操作系统要提供<strong>页面置换（段置换）</strong>的功能</li>
</ul>
</li>
<li>在操作系统的管理下，在用户角度看虚拟内存比实际内存大得多</li>
</ul>
</li>
<li>易混知识点：<ul>
<li>虚拟内存的<strong>最大容量</strong>是由计算机的地址结构（CPU寻址范围）确定的</li>
<li>虚拟内存的<strong>实际容量</strong> = min（内存和外存容量之和，CPU寻址范围）</li>
</ul>
</li>
<li>虚拟内存的三个主要特征：<ul>
<li>多次性：无需将作业一次性全部装入内存，而是<strong>允许分多次调入内存</strong>。</li>
<li>对换性：在作业运行时无需一直常驻内存，而是<strong>允许将作业换入、换出</strong>。</li>
<li>虚拟性：<strong>从逻辑上扩充了内存的容量</strong>，使用户看到的内存容量，远大于实际的容量。</li>
</ul>
</li>
<li>实现虚拟内存技术：<ul>
<li>传统的非连续分配存储管理：基本分页存储管理，基本分段存储管理，基本段页式存储管理</li>
<li>虚拟内存实现：请求分页存储管理，请求分段存储管理，请求段页式存储管理</li>
</ul>
</li>
</ul>
<h3 id="请求分页管理方式"><a href="#请求分页管理方式" class="headerlink" title="请求分页管理方式"></a>请求分页管理方式</h3><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part3/image-20211111133427802.png" alt="image-20211111133427802" style="zoom:100%;">

<ul>
<li>页表机制<ul>
<li><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part3/image-20211111134046407.png" alt="image-20211111134046407"></li>
</ul>
</li>
<li>缺页中断机构<ul>
<li>在请求分页系统中，每当要访问的<strong>页面不在内存时</strong>，便产生一个<strong>缺页中断</strong>，然后<strong>由操作系统的缺页中断处理程序处理中断</strong>。</li>
<li>此时<strong>缺页的进程阻塞</strong>，放入阻塞队列，调页<strong>完成后再将其唤醒</strong>，放回就绪队列。</li>
<li>如果内存中<strong>有空闲块</strong>，则为进程<strong>分配一个空闲块</strong>，将所缺页面装入该块，并修改页表中相应的页表项。</li>
<li>如果内存中<strong>没有空闲块</strong>，则<strong>由页面置换算法选择一个页面淘汰</strong>，若该页面在内存期间<strong>被修改过</strong>，则要将其<strong>写回外存</strong>。未修改过的页面不用写回外存。</li>
<li><strong>缺页中断</strong>是因为当前执行的指令想要访问的目标页面未调入内存而产生的，因此属于内中断、故障（fault）</li>
<li><strong>一条指令</strong>在执行期间，<strong>可能产生多次缺页中断</strong>。</li>
</ul>
</li>
<li>地址变换机构<ul>
<li>新增步骤<ul>
<li>请求调页（查到页表项时根据状态位判断）</li>
<li>页面置换（需要调入页面，但没有空闲内存块时进行）</li>
<li>需要修改请求页表中新增的表项</li>
</ul>
</li>
<li><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part3/image-20211111135241839.png" alt="image-20211111135241839"><ul>
<li>查快表（未命中）—— 查慢表（发现未调入内存）—— 调页（调入的页面对应的表项会直接加入快表）—— 查快表（命中）—— 访问目标内存单元</li>
</ul>
</li>
<li>注意<ul>
<li><strong>快表中的页面一定是在内存中的</strong>。若某个页面被换出外存，则<strong>快表中的相应表项也要删除</strong>，否则可能访问错误的页面</li>
<li><strong>只有写指令才需要修改修改位</strong>。并且，一般只需修改快表中的数据，只有<strong>当将快表项删除时才需要写回内存中的慢表</strong>。这样可以减少访存次数。</li>
<li>和普通的中断处理一样，缺页中断处理依然需要保留 CPU 现场。</li>
<li>换入/换出页面都需要启动慢速的 I/O 操作，如果<strong>换入/换出太频繁，会有很大的开销</strong>。</li>
<li>页面调入内存后，需要同时修改慢表、快表。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="页面置换算法"><a href="#页面置换算法" class="headerlink" title="页面置换算法"></a>页面置换算法</h3><p><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part3/image-20211111100054045.png" alt="image-20211111100054045"></p>
<ul>
<li><p>最佳置换算法（OPT，Optimal）：</p>
<ul>
<li>每次选择淘汰的页面都是<strong>以后永不使用</strong>，或者<strong>在最长时间内不再被访问</strong>的页面。<ul>
<li><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part3/image-20211111140714145.png" alt="image-20211111140714145" style="zoom:80%;"></li>
</ul>
</li>
<li>最佳置换算法<strong>可以保证最低的缺页率</strong>，但实际上，操作系统无法提前预判页面访问序列。因此，<strong>最佳置换算法是无法实现的</strong>。</li>
</ul>
</li>
<li><p>先进先出置换算法（FIFO）</p>
<ul>
<li>每次选择淘汰的页面是<strong>最早进入内存</strong>的页面<ul>
<li><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part3/image-20211111140930234.png" alt="image-20211111140930234" style="zoom:80%;"></li>
<li><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part3/image-20211111141136485.png" alt="image-20211111141136485"></li>
</ul>
</li>
<li><strong>Belady 异常</strong>：当为进程分配的物理块数增大时，缺页次数不减反增的异常现象。<ul>
<li><strong>只有 FIFO 算法会产生 Belady 异常</strong>。</li>
</ul>
</li>
<li>FIFO 算法虽然实现简单，但是该算法与进程实际运行时的规律不适应，因为先进入的页面也有可能最经常被访问。因此，<strong>算法性能差</strong>。</li>
</ul>
</li>
<li><p>最近最久未使用置换算法（LRU）</p>
<ul>
<li>每次淘汰的页面是最近最久未使用的页面</li>
<li>实现方法：<ul>
<li>赋予每个页面对应的页表项中，用访问字段记录该页面自上次被访问以来所经历的时间 t。</li>
<li>当需要淘汰一个页面时，选择现有页面中 t 值最大的，即最近最久未使用的页面。</li>
<li><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part3/image-20211111141926199.png" alt="image-20211111141926199" style="zoom:80%;"></li>
<li>虽然性能好，但是实现困难、开销大。</li>
</ul>
</li>
<li>做题时，仅需逆向扫描过程中最后出现的页号，即要淘汰的页面。</li>
</ul>
</li>
<li><p>时钟置换算法（CLOCK）</p>
<ul>
<li><p>时钟置换算法（CLOCK 算法/最近未用算法（NRU，Not Recently Used）），是一种性能和开销较均衡的算法。</p>
</li>
<li><p><strong>简单的 CLOCK 算法实现方法</strong>：</p>
<ul>
<li><p>为每个页面设置一个访问位，再将内存中的页面都通过链接指针链接成一个循环队列。</p>
</li>
<li><p>算法规则：</p>
<ul>
<li>当某页被访问时，其访问位置为 1。</li>
<li>当需要淘汰一个页面时，只需检查页的访问位：如果是 0，就选择该页换出；如果是 1，则将它置为 0，暂不换出</li>
<li>若第一轮扫描中所有页面都是 1，则将这些页面的访问位依次置为 0 后，再进行第二轮扫描</li>
</ul>
</li>
<li><p><strong>简单的 CLOCK 算法选择一个淘汰页面最多会经过两轮扫描</strong></p>
</li>
</ul>
</li>
<li><p><strong>改进型的时钟置换算法</strong>：</p>
<ul>
<li><p>针对问题：<strong>只有被淘汰的页面被修改过时，才需要写回外存</strong>。</p>
</li>
<li><p>改进方向：在其他条件都相同时，应优先淘汰没有修改过的页面，避免 I/O 操作。</p>
</li>
<li><p>修改位=0，表示页面没有被修改过；修改位=1，表示页面被修改过。用（访问位，修改位）的形式表示各页面状态。</p>
</li>
<li><p>算法规则：</p>
<ul>
<li><p>第一轮：从当前位置开始扫描到第一个（0, 0）的帧用于替换。本轮扫描不修改任何标志位</p>
<ul>
<li>第一优先级：<strong>最近没访问，且没修改的页面</strong></li>
</ul>
</li>
<li><p>第二轮：若第一轮扫描失败，则重新扫描，查找第一个（0, 1）的帧用于替换。本轮将所有扫描过的帧访问位设为 0 </p>
<ul>
<li>第二优先级：<strong>最近没访问，但修改过的页面</strong></li>
</ul>
</li>
<li><p>第三轮：若第二轮扫描失败，则重新扫描，查找第一个（0, 0）的帧用于替换。本轮扫描不修改任何标志位</p>
<ul>
<li>第三优先级：<strong>最近访问过，但没修改的页面</strong></li>
</ul>
</li>
<li><p>第四轮：若第三轮扫描失败，则重新扫描，查找第一个（0, 1）的帧用于替换。</p>
<ul>
<li>第四优先级：<strong>最近访问过，且修改过的页面</strong></li>
</ul>
</li>
</ul>
</li>
<li><p><strong>改进型 CLOCK 置换算法选择一个淘汰页面最多会进行四轮扫描</strong></p>
</li>
</ul>
</li>
<li><blockquote>
<p>NRU 相比 LRU：</p>
<ul>
<li>记录谁<strong>最早</strong>被使用很难，那么换一种思路，把时间分成一个个周期，<strong>如果最近一个周期都没有被使用，那就干脆当做一直没有被使用</strong>。</li>
<li><strong>不一定要最早被使用的被淘汰，只要不是最近被使用的被淘汰就好了</strong>。</li>
</ul>
</blockquote>
</li>
</ul>
</li>
</ul>
<h3 id="页面分配策略"><a href="#页面分配策略" class="headerlink" title="页面分配策略"></a>页面分配策略</h3><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part3/image-20211111100203514.png" alt="image-20211111100203514" style="zoom:100%;">

<ul>
<li>驻留集：<ul>
<li>指<strong>请求分页存储管理中给进程分配的物理块的集合</strong>。</li>
<li>在采用了虚拟存储技术的系统中，<strong>驻留集大小一般小于进程的总大小</strong>。</li>
<li>选择一个合适的驻留集大小<ul>
<li>若驻留集太小，会导致缺页频繁，系统要花大量的时间来处理缺页，实际用于进程推进的时间很少；</li>
<li>若驻留集太大，会导致多道程序并发度下降，资源利用率降低。</li>
</ul>
</li>
</ul>
</li>
<li>页面分配：<ul>
<li><strong>固定分配</strong>：操作系统为每个进程分配一组固定数目的物理块，在进程运行期间不再改变。即，<strong>驻留集大小不变</strong></li>
<li><strong>可变分配</strong>：先为每个进程分配一定数目的物理块，在进程运行期间，可根据情况做适当的增加或减少。即，<strong>驻留集大小可变</strong></li>
<li><strong>局部置换</strong>：发生缺页时<strong>只能选进程自己的物理块进行置换</strong>。</li>
<li><strong>全局置换</strong>：可以将内存中<strong>任意的物理块分配给缺页进程</strong>（包括操作系统保持的空闲物理块、争夺别的进程持有的物理块）</li>
</ul>
</li>
<li>置换策略：<ul>
<li><strong>固定分配局部置换</strong>：<ul>
<li>系统为每个进程分配一定数量的物理块，在整个运行期间都不改变。若进程在运行中发生缺页，则只能从该进程在内存中的页面中选出一页换出，然后再调入需要的页面。</li>
<li>缺点：<strong>很难在最初为每个进程确定分配合理的物理块数量</strong>。（采用这种策略的系统可以根据进程大小、优先级、或是根据程序员给出的参数来确定为一个进程分配的内存块数）</li>
</ul>
</li>
<li><strong>可变分配全局置换</strong>：<ul>
<li>刚开始会为每个进程分配一定数量的物理块。操作系统会<strong>保持一个空闲物理块队列</strong>。当某进程发生缺页时，从空闲物理块中取出一块分配给该进程；若已无空闲物理块，则可选择一个<strong>未锁定</strong>的页面换出外存，再将该物理块分配给缺页的进程。</li>
<li>特点：<strong>只要缺页就给分配新物理块</strong>。</li>
<li>缺点：当空闲物理块用完时，系统可以选择任意一个进程中未锁定的页面调出，因此这个<strong>被选中的进程拥有的物理块减少，缺页率增加</strong>。</li>
</ul>
</li>
<li><strong>可变分配局部置换</strong>：<ul>
<li>刚开始会为每个进程分配一定数量的物理块。当某进程发生缺页时，只允许从该进程自己的物理块中选出一个进行换出外存。如果进程在运行中频繁地缺页，系统会为该进程多分配几个物理块，直至该进程缺页率趋势适当程度；反之，如果进程在运行中缺页率特别低，则可适当减少分配给该进程的物理块。</li>
<li>特点：<strong>要根据发生缺页的频率来动态地增加或减少进程的物理块</strong></li>
</ul>
</li>
</ul>
</li>
<li>何时调入页面<ul>
<li>预调页策略：<ul>
<li>根据局部性原理，一次调入若干个相邻的页面可能比一次调入一个页面更高效。但如果提前调入的页面中大多数都没被访问过，则又是低效的。因此可以预测不久之后可能访问到的页面，将它们预先调入内存，但目前预测成功率只有 50% 左右。</li>
<li>故这种策略<strong>主要用于进程的首次调入</strong>（<strong>运行前调入</strong>），由程序员指出应该先调入哪些部分。<ul>
<li>主要指空间局部性，即：如果当前访问了某个内存单元，在之后很有可能会接着访问与其相邻的</li>
</ul>
</li>
</ul>
</li>
<li>请求调页策略：<ul>
<li>进程<strong>在运行期间发现缺页时才将所缺页面调入内存</strong>（<strong>运行时调入</strong>）。</li>
<li>由这种策略调入的页面一定会被访问到，但由于每次只能调入一页，而每次调页都要磁盘 I/O 操作，因此 I/O 开销较大。</li>
</ul>
</li>
</ul>
</li>
<li>从何处调入页<ul>
<li>系统拥有足够的对换区空间：<ul>
<li>页面的调入、调出都是在内存与对换区之间进行，这样可以<strong>保证页面的调入、调出速度很快</strong>。在进程运行前，需将进程相关的数据从文件区复制到对换区。</li>
<li><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part3/image-20211111153622301.png" alt="image-20211111153622301" style="zoom: 67%;"></li>
</ul>
</li>
<li>系统缺少足够的对换区空间：<ul>
<li>凡是不会被修改的数据都直接从文件区调入，由于这些页面不会被修改，因此<strong>换出时不必写回磁盘，下次需要时再从文件区调入即可</strong>。对于可能被修改的部分，<strong>换出时需写回磁盘对换区，下次需要时再从对换区调入</strong>。</li>
<li><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part3/image-20211111153712918.png" alt="image-20211111153712918" style="zoom: 67%;"></li>
</ul>
</li>
<li>UNIX 方式：<ul>
<li>运行之前进程有关的数据全部放在文件区，故未使用过的页面，都可从文件区调入。若被使用过的页面需要换出，则写回对换 区，下次需要时从对换区调入。</li>
<li><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part3/image-20211111153811349.png" alt="image-20211111153811349" style="zoom: 67%;"></li>
</ul>
</li>
</ul>
</li>
<li>抖动（颠簸）现象<ul>
<li><strong>刚刚换出的页面马上又要换入内存，刚刚换入的页面马上又要换出外存</strong>。<ul>
<li>产生原因：进程频繁访问的页面数目高于可用的物理块数（<strong>分配给进程的物理块不够</strong>）</li>
</ul>
</li>
<li>为进程分配的物理块太少，会使进程发生抖动现象。为进程分配的物理块太多，又会降低系统整体的并发度，降低某些资源的利用率</li>
<li>为了研究为应该为每个进程分配多少个物理块，Denning 提出了进程“工作集”的概念<ul>
<li>驻留集：指请求分页存储管理中给进程分配的内存块的集合。</li>
<li>工作集：指在某段时间间隔里，进程实际访问页面的集合。</li>
<li><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part3/image-20211111153945600.png" alt="image-20211111153945600" style="zoom:80%;"></li>
<li>工作集大小可能小于窗口尺寸，实际应用中，操作系统可以统计进程的工作集大小，根据工作集大小给进程分配若干内存块。</li>
<li>一般来说，<strong>驻留集大小不能小于工作集大小，否则进程运行过程中将频繁缺页</strong>。</li>
<li>拓展：可以根据进程近期访问的页面集合（工作集）来设计一种页面置换算法——选择一个不在工作集中的页面进行淘汰。</li>
</ul>
</li>
</ul>
</li>
</ul>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">NephrenCake</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://nephrencake.gitee.io/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part3/">https://nephrencake.gitee.io/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part3/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://nephrencake.gitee.io" target="_blank">浅幽丶奈芙莲的个人博客</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E5%AE%8C%E7%BB%93%E7%9B%AE%E5%BD%95/%E4%BA%8Ced12.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part4/"><img class="prev-cover" src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E5%AE%8C%E7%BB%93%E7%9B%AE%E5%BD%95/%E4%BA%8Ced12.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">操作系统-Part4</div></div></a></div><div class="next-post pull-right"><a href="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part2/"><img class="next-cover" src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E5%AE%8C%E7%BB%93%E7%9B%AE%E5%BD%95/%E4%BA%8Ced12.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">操作系统-Part2</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part3%E2%80%94%E2%80%94%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86"><span class="toc-number">1.</span> <span class="toc-text">操作系统-Part3——内存管理</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86"><span class="toc-number">1.1.</span> <span class="toc-text">内存管理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E7%9A%84%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86"><span class="toc-number">1.1.1.</span> <span class="toc-text">内存的基础知识</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A3%85%E5%85%A5%E7%9A%84%E4%B8%89%E7%A7%8D%E6%96%B9%E5%BC%8F"><span class="toc-number">1.1.1.1.</span> <span class="toc-text">装入的三种方式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%93%BE%E6%8E%A5%E7%9A%84%E4%B8%89%E7%A7%8D%E6%96%B9%E5%BC%8F"><span class="toc-number">1.1.1.2.</span> <span class="toc-text">链接的三种方式</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="toc-number">1.1.2.</span> <span class="toc-text">内存管理的概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A6%86%E7%9B%96%E4%B8%8E%E4%BA%A4%E6%8D%A2"><span class="toc-number">1.1.3.</span> <span class="toc-text">覆盖与交换</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9E%E7%BB%AD%E5%88%86%E9%85%8D%E7%AE%A1%E7%90%86%E6%96%B9%E5%BC%8F"><span class="toc-number">1.1.4.</span> <span class="toc-text">连续分配管理方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E5%88%86%E5%8C%BA%E5%88%86%E9%85%8D%E7%AE%97%E6%B3%95"><span class="toc-number">1.1.5.</span> <span class="toc-text">动态分区分配算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E5%88%86%E9%A1%B5%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%EF%BC%88%E9%87%8D%E7%82%B9%EF%BC%89"><span class="toc-number">1.1.6.</span> <span class="toc-text">基本分页存储管理的基本概念（重点）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E5%9C%B0%E5%9D%80%E5%8F%98%E6%8D%A2%E6%9C%BA%E6%9E%84%EF%BC%88%E9%87%8D%E7%82%B9%EF%BC%89"><span class="toc-number">1.1.7.</span> <span class="toc-text">基本地址变换机构（重点）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B7%E6%9C%89%E5%BF%AB%E8%A1%A8%E7%9A%84%E5%9C%B0%E5%9D%80%E5%8F%98%E6%8D%A2%E6%9C%BA%E6%9E%84"><span class="toc-number">1.1.8.</span> <span class="toc-text">具有快表的地址变换机构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%A4%E7%BA%A7%E9%A1%B5%E8%A1%A8"><span class="toc-number">1.1.9.</span> <span class="toc-text">两级页表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E5%88%86%E6%AE%B5%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86%E6%96%B9%E5%BC%8F"><span class="toc-number">1.1.10.</span> <span class="toc-text">基本分段存储管理方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AE%B5%E9%A1%B5%E5%BC%8F%E7%AE%A1%E7%90%86%E6%96%B9%E5%BC%8F"><span class="toc-number">1.1.11.</span> <span class="toc-text">段页式管理方式</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86"><span class="toc-number">1.2.</span> <span class="toc-text">虚拟内存管理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">1.2.1.</span> <span class="toc-text">虚拟内存的基本概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%B7%E6%B1%82%E5%88%86%E9%A1%B5%E7%AE%A1%E7%90%86%E6%96%B9%E5%BC%8F"><span class="toc-number">1.2.2.</span> <span class="toc-text">请求分页管理方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A1%B5%E9%9D%A2%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95"><span class="toc-number">1.2.3.</span> <span class="toc-text">页面置换算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A1%B5%E9%9D%A2%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5"><span class="toc-number">1.2.4.</span> <span class="toc-text">页面分配策略</span></a></li></ol></li></ol></li></ol></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2021 - 2022 By NephrenCake</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">这里是浅幽丶奈芙莲的个人博客~</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div></div><hr/><div id="local-search-results"></div><span class="search-close-button"><i class="fas fa-times"></i></span></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/search/local-search.js"></script><script>var preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',()=> {preloader.endLoading()})</script><div class="js-pjax"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><canvas class="fireworks" mobile="true"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/fireworks.min.js"></script></div></body></html>