<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>操作系统-Part4 | 浅幽丶奈芙莲的个人博客</title><meta name="author" content="NephrenCake"><meta name="copyright" content="NephrenCake"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="文件管理">
<meta property="og:type" content="article">
<meta property="og:title" content="操作系统-Part4">
<meta property="og:url" content="https://nephrencake.github.io/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part4/index.html">
<meta property="og:site_name" content="浅幽丶奈芙莲的个人博客">
<meta property="og:description" content="文件管理">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://nephrencake.github.io/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E5%AE%8C%E7%BB%93%E7%9B%AE%E5%BD%95/%E4%BA%8Ced12.jpg">
<meta property="article:published_time" content="2021-11-01T01:43:54.000Z">
<meta property="article:modified_time" content="2021-11-16T08:41:12.320Z">
<meta property="article:author" content="NephrenCake">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://nephrencake.github.io/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E5%AE%8C%E7%BB%93%E7%9B%AE%E5%BD%95/%E4%BA%8Ced12.jpg"><link rel="shortcut icon" href="/img/favicon.jpg"><link rel="canonical" href="https://nephrencake.github.io/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part4/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: {"limitDay":365,"position":"top","messagePrev":"It has been","messageNext":"days since the last update, the content of the article may be outdated."},
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '操作系统-Part4',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2021-11-16 16:41:12'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="/css/background.css"><link rel="stylesheet" href="/css/mouse.css"><link rel="stylesheet" href="/css/scrollbar.css"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/iconfont.css"><meta name="generator" content="Hexo 5.3.0"><link rel="alternate" href="/atom.xml" title="浅幽丶奈芙莲的个人博客" type="application/atom+xml">
</head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/avatar.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">103</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">10</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">18</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/photo/"><i class="fa-fw fas fa-heart"></i><span> 相册</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友情链接</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E5%AE%8C%E7%BB%93%E7%9B%AE%E5%BD%95/%E4%BA%8Ced12.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">浅幽丶奈芙莲的个人博客</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/photo/"><i class="fa-fw fas fa-heart"></i><span> 相册</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友情链接</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">操作系统-Part4</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2021-11-01T01:43:54.000Z" title="发表于 2021-11-01 09:43:54">2021-11-01</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2021-11-16T08:41:12.320Z" title="更新于 2021-11-16 16:41:12">2021-11-16</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">操作系统</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">8.6k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>25分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="操作系统-Part4"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="操作系统-Part4——文件管理"><a href="#操作系统-Part4——文件管理" class="headerlink" title="操作系统-Part4——文件管理"></a>操作系统-Part4——文件管理</h1><p>[TOC]</p>
<h2 id="文件系统基础"><a href="#文件系统基础" class="headerlink" title="文件系统基础"></a>文件系统基础</h2><h3 id="初识文件管理"><a href="#初识文件管理" class="headerlink" title="初识文件管理"></a>初识文件管理</h3><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part4/image-20211111183657165.png" alt="image-20211111183657165">

<ul>
<li>文件属性<ul>
<li><strong>文件名</strong>：由创建文件的用户决定文件名，主要是为了方便用户找到文件，<strong>同一目录下不允许有重名文件</strong>。</li>
<li><strong>标识符</strong>：一个系统内的各文件标识符唯一，对用户来说毫无可读性，因此标识符只是操作系统用于区分各个文件的一种内部名称。</li>
<li><strong>类型</strong>：指明文件的类型</li>
<li><strong>位置</strong>：文件存放的路径（让用户使用）、在外存中的地址（操作系统使用，对用户不可见）</li>
<li><strong>大小</strong>：指明文件大小</li>
<li><strong>创建时间、上次修改时间</strong></li>
<li><strong>文件所有者信息</strong></li>
<li><strong>保护信息</strong>：对文件进行保护的访问控制信息</li>
</ul>
</li>
<li>文件内部的数据组织<ul>
<li>无结构文件（如文本文件），由一些二进制或字符流组成，又称“流式文件”</li>
<li>有结构文件（如数据库表），由一组相似的记录组成，又称“记录式文件”<ul>
<li>记录是一组相关数据项的集合</li>
<li>数据项是文件系统中<strong>最基本的数据单位</strong></li>
<li><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part4/image-20211111182113600.png" alt="image-20211111182113600" style="zoom:67%;"></li>
</ul>
</li>
</ul>
</li>
<li>文件之间的组织<ul>
<li>目录（文件夹）其实也是一种特殊的有结构文件</li>
<li><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part4/image-20211111182238302.png" alt="image-20211111182238302" style="zoom:67%;"></li>
</ul>
</li>
<li>操作系统向上提供的功能<ul>
<li><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part4/image-20211111182641475.png" alt="image-20211111182641475" style="zoom: 50%;"></li>
<li>图形化交互操作的本质也是<strong>调用操作系统提供的接口</strong></li>
<li>可用几个基本操作完成更复杂的操作，比如：“复制文件”：先创建一个新的空文件，再把源文件读入内存，再将内存中的数据写到新文件中</li>
<li>读/写文件之前，需要“打开文件”</li>
<li>读/写文件结束之后，需要“关闭文件”</li>
</ul>
</li>
<li>文件在外存的存放<ul>
<li>外存也是由一个个存储单元组成的，每个存储单元可以存储一定量的数据（如 1B）。<ul>
<li>每个存储单元对应一个物理地址</li>
</ul>
</li>
<li>类似于内存分为一个个“内存块”，外存会分为一个个“块/磁盘块/物理块”。每个磁盘块的大小是相等的，每块一般包含 2 的整数幂个地址<ul>
<li>文件的逻辑地址也可以分为（逻辑块号，块内地址），操作系统同样需要将逻辑地址转 换为外存的物理地址（物理块号，块内地址）的形式。</li>
<li>块内地址的位数取决于磁盘块的大小</li>
</ul>
</li>
<li>操作系统<strong>以块为单位为文件分配存储空间、读入内存</strong><ul>
<li>即使一个文件大小只有 10B，但它依然需要占用 1KB 的磁盘块</li>
</ul>
</li>
</ul>
</li>
<li>其他需要由操作系统实现的文件管理功能<ul>
<li>文件共享：使多个用户可以共享使用一个文件</li>
<li>文件保护：如何保证不同的用户对文件有不同的操作权限</li>
</ul>
</li>
</ul>
<h3 id="文件的逻辑结构"><a href="#文件的逻辑结构" class="headerlink" title="文件的逻辑结构"></a>文件的逻辑结构</h3><p><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part4/image-20211111224112533.png" alt="image-20211111224112533"></p>
<ul>
<li>逻辑结构，指在用户看来，文件内部的数据应该是如何组织起来的。物理结构，指在操作系统看来，文件的数据是如何存放在外存中的。</li>
<li>按文件是否有结构分类，可以分为无结构文件、有结构文件两种。<ul>
<li><strong>无结构文件</strong>：文件内部的数据就是一系列二进制流或字符流组成。又称“<strong>流式文件</strong>”。</li>
<li><strong>有结构文件</strong>：由一组相似的记录组成，又称“<strong>记录式文件</strong>”。每条记录又若干个数据项组成。一般来说，每条记录有一个数据项可作为<strong>关键字</strong>（作为识别不同记录的ID）<ul>
<li>根据各条记录的长度（占用的存储空间）是否相等，又可分为<strong>定长记录</strong>和<strong>可变长记录</strong>两种。</li>
</ul>
</li>
</ul>
</li>
<li>有结构文件的逻辑结构<ul>
<li>顺序文件：文件中的记录一个接一个地顺序排列（逻辑上），记录可以是<strong>定长</strong>的或<strong>可变长</strong>的。各个记录在物理上可以<strong>顺序存储</strong>或<strong>链式存储</strong>。<ul>
<li><strong>串结构</strong>：记录之间的顺序与关键字无关</li>
<li><strong>顺序结构</strong>：记录之间的顺序按关键字顺序排序</li>
<li>一般来说，考试题目中所说的“顺序文件”指的是<strong>物理上顺序存储的顺序文件</strong>。<ul>
<li>顺序文件的缺点是增加/删除一个记录比较困难</li>
</ul>
</li>
<li><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part4/image-20211111223019417.png" alt="image-20211111223019417"></li>
</ul>
</li>
<li>索引文件：<ul>
<li>索引表本身是定长记录的顺序文件。</li>
<li>主要用于对信息处理的及时性要求比较高的场合。</li>
<li>可以用不同的数据项（属性）建立多个索引表。</li>
<li><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part4/image-20211111223256012.png" alt="image-20211111223256012" style="zoom: 67%;"></li>
</ul>
</li>
<li>索引顺序文件：<ul>
<li>是索引文件和顺序文件思想的结合。区别在于，不是每个记录对应一个索引表项，而是<strong>一组记录对应一个索引表项</strong>。</li>
<li><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part4/image-20211111223511426.png" alt="image-20211111223511426" style="zoom:67%;"></li>
</ul>
</li>
<li>多级索引顺序文件<ul>
<li><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part4/image-20211111223713847.png" alt="image-20211111223713847" style="zoom:67%;">

</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="文件目录"><a href="#文件目录" class="headerlink" title="文件目录"></a>文件目录</h3><p><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part4/image-20211111230036761.png" alt="image-20211111230036761"></p>
<ul>
<li><strong>文件控制块</strong>（File Control Block，FCB）<ul>
<li>目录本身就是一种有结构文件，由一条条记录组成。每条记录对应一个在该放在该目录下的文件</li>
<li><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part4/image-20211111230640935.png" alt="image-20211111230640935"></li>
<li>对目录进行的操作<ul>
<li>搜索：当用户要使用一个文件时，系统要根据文件名搜索目录，找到该文件对应的目录项</li>
<li>创建文件：创建一个新文件时，需要在其所属的目录中增加一个目录项</li>
<li>删除文件：当删除一个文件时，需要在目录中删除相应的目录项</li>
<li>显示目录：用户可以请求显示目录的内容，如显示该目录中的所有文件及相应属性</li>
<li>修改目录：某些文件属性保存在目录中，因此这些属性变化时需要修改相应的目录项（如：文件重命名）</li>
</ul>
</li>
</ul>
</li>
<li><strong>目录结构</strong><ul>
<li><strong>单级目录结构</strong><ul>
<li>早期操作系统并不支持多级目录，整个系统中只建立一张目录表，每个文件占一个目录项。</li>
<li>特点：单级目录实现了“按名存取”，但是不允许文件重名。</li>
<li>缺点：不适用于多用户操作系统。</li>
</ul>
</li>
<li><strong>两级目录结构</strong><ul>
<li>早期的多用户操作系统，采用两级目录结构。分为<strong>主文件目录</strong>（MFD，Master File Directory）和<strong>用户文件目录</strong>（UFD，User Flie Directory）。</li>
<li>特点：1. 允许不同用户的文件重名；2. 可以在目录上实现实现访问限制</li>
<li>缺点：依然缺乏灵活性，用户不能对自己的文件进行分类</li>
</ul>
</li>
<li><strong>多级目录结构</strong>（树形目录结构）<ul>
<li><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part4/image-20211111231141027.png" alt="image-20211111231141027" style="zoom:80%;"></li>
<li>系统根据<strong>绝对路径</strong>一层一层地找到下一级目录。刚开始从外存读入根目录的目录表；找到“照片”目录的存放位置后，从外存读入对应的目录表；再找到“2015-08”目录的存放位置，再从外存读入对应目录表；最后才找到文件“自拍.jpg”的存放位置。<strong>整个过程需要 3 次读磁盘 I/O 操作</strong>。</li>
<li>引入<strong>当前目录</strong>和<strong>相对路径</strong>后，磁盘 I/O 的次数减少，提升了访问文件的效率。</li>
<li>特点：可以很方便地对文件进行分类，层次结构清晰，也能够更有效地进行文件的管理和保护。</li>
<li>缺点：<strong>不便于实现文件的共享</strong>。</li>
</ul>
</li>
<li><strong>无环图目录结构</strong><ul>
<li><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part4/image-20211111231431422.png" alt="image-20211111231431422" style="zoom:80%;"></li>
<li>可以用不同的文件名指向同一个文件或目录</li>
<li>实现：<strong>为每个共享结点设置一个共享计数器</strong>，用于记录此时有多少个地方在共享该结点。用户提出删除结点的请求时，只是<strong>删除该用户的 FCB、并使共享计数器减 1</strong>，并不会直接删除共享结点。<strong>只有共享计数器减为 0 时，才删除结点</strong>。</li>
<li>共享文件不同于复制文件。在共享文件中，由于各用户指向的是同一个文件，因此只要其中一个用户修改了文件数据，那么所有用户都可以看到文件数据的变化。</li>
</ul>
</li>
</ul>
</li>
<li>索引结点（FCB的改进）<ul>
<li>使用索引结点机制，磁盘块可容纳的 FCB 增多，对于拥有较多目录项的目录来说，减少了 I/O 次数，大大提升文件检索速度。</li>
<li>存放<strong>在外存中</strong>的索引结点称为“<strong>磁盘索引结点</strong>”；当索引结点<strong>放入内存后</strong>称为“<strong>内存索引结点</strong>”。</li>
<li>相比之下<strong>内存索引结点中需要增加一些信息</strong>，比如：文件是否被修改、此时有几个进程正在访问该文件等</li>
<li><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part4/image-20211111231941136.png" alt="image-20211111231941136" style="zoom: 67%;">

</li>
</ul>
</li>
</ul>
<h3 id="文件保护"><a href="#文件保护" class="headerlink" title="文件保护"></a>文件保护</h3><p><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part4/image-20211112110535854.png" alt="image-20211112110535854"></p>
<ul>
<li><strong>口令保护</strong><ul>
<li>用户<strong>请求访问该文件时必须提供口令</strong>。<ul>
<li>口令一般存放在文件对应的 <strong>FCB</strong> 或<strong>索引结点</strong>中。</li>
</ul>
</li>
<li>优点：保存口令的空间开销不多，验证口令的时间开销也很小。</li>
<li>缺点：正确的口令存放在系统内部，<strong>不够安全</strong>。</li>
</ul>
</li>
<li><strong>加密保护</strong><ul>
<li>使用密码对文件进行加密保存，在访问文件时需要提供正确的密码才能对文件进行解密。</li>
<li>优点：保密性强，不需要在系统中存储“密码”</li>
<li>缺点：编码/译码，或者说加密/解密要花费一定时间。</li>
<li><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part4/image-20211112111542108.png" alt="image-20211112111542108" style="zoom: 80%;"></li>
</ul>
</li>
<li><strong>访问控制</strong><ul>
<li><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part4/image-20211112112011037.png" alt="image-20211112112011037"></li>
<li>在每个文件的 FCB（或索引结点）中增加一个<strong>访问控制列表</strong>（Access-Control List，ACL），该表中记录了各个用户可以对该文件执行哪些操作。</li>
<li><strong>精简的访问列表</strong>：<strong>以组为单位</strong>，标记各组用户可以对文件执行哪些操作。</li>
<li>如果对<strong>某个目录</strong>进行了访问权限的控制，那也要对<strong>目录下的所有文件</strong>进行相同的访问权限控制</li>
</ul>
</li>
</ul>
<h3 id="文件共享"><a href="#文件共享" class="headerlink" title="文件共享"></a>文件共享</h3><p><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part4/image-20211112112227710.png" alt="image-20211112112227710"></p>
<ul>
<li>注意：<ul>
<li>多个用户<strong>共享</strong>同一个文件，意味着系统中只有<strong>一份</strong>文件数据。用户对该文件的修改，在用户之间是共享的、可见的。</li>
<li>多个用户<strong>复制</strong>同一个文件，意味着系统中会有<strong>多份</strong>文件数据。用户对自己文件的修改，对其他用户的文件数据并没有影响。</li>
</ul>
</li>
<li><strong>基于索引结点的共享方式（硬链接）</strong><ul>
<li><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part4/image-20211112113309277.png" alt="image-20211112113309277"></li>
<li>索引结点中设置一个链接计数变量 count，用于表示链接到本索引结点上的用户目录项数。</li>
<li>若 count&gt;1，说明此时<strong>有多个用户目录项链接到该索引结点上</strong>，或者说<strong>有多个用户在共享此文件</strong>。</li>
<li>若某个用户删除该文件，则只是<strong>把目录中与该文件对应的目录项删除</strong>，且<strong>索引结点的 count 值减 1</strong>。 </li>
<li>若 count&gt;0，说明还有别的用户要使用该文件，暂时不能把文件数据删除，否则会导致指针悬空。</li>
<li>当 count=0 时系统负责删除文件。</li>
</ul>
</li>
<li><strong>基于符号链的共享方式（软链接）</strong><ul>
<li><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part4/image-20211112113608981.png" alt="image-20211112113608981" style="zoom:80%;"></li>
<li>当 Link 型文件被删除时，Link 指向的文件依然存在</li>
<li>当 Link 指向的文件被删除时，该 Link 型文件失效</li>
</ul>
</li>
</ul>
<h2 id="文件系统实现"><a href="#文件系统实现" class="headerlink" title="文件系统实现"></a>文件系统实现</h2><h3 id="文件的物理结构（重点）"><a href="#文件的物理结构（重点）" class="headerlink" title="文件的物理结构（重点）"></a>文件的物理结构（重点）</h3><p><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part4/image-20211112114305513.png" alt="image-20211112114305513"></p>
<ul>
<li><p>文件块、磁盘块</p>
<ul>
<li>文件的逻辑地址空间也被分为了一个个<strong>文件块</strong>，也可以表示为<strong>（逻辑块号，块内地址）</strong>的形式。</li>
<li>通常，<strong>磁盘块的大小与内存块、页面的大小相同</strong></li>
<li>内存与磁盘之间的数据交换（即读/写操作、磁盘 I/O）都是以块为单位进行的。</li>
</ul>
</li>
<li><p>连续分配</p>
<ul>
<li><p>连续分配方式要求<strong>每个文件在磁盘上占有一组连续的块</strong>。</p>
</li>
<li><p>逻辑地址到物理地址的映射</p>
<ul>
<li>（逻辑块号，块内地址）-&gt;（物理块号，块内地址）。只需转换块号就行，块内地址保持不变</li>
<li>物理块号 = 起始块号 + 逻辑块号</li>
<li>同时，还要检查逻辑块号是否合法（逻辑块号 ≤ 长度）</li>
</ul>
</li>
<li><p>优点</p>
<ul>
<li><strong>连续分配支持顺序访问和直接访问</strong>（随机访问）</li>
<li><strong>连续分配的文件在顺序读/写时速度最快</strong></li>
</ul>
</li>
<li><p>缺点</p>
<ul>
<li><strong>文件不方便拓展</strong>。</li>
<li><strong>存储空间利用率低</strong>，<strong>会产生难以利用的磁盘碎片</strong>（可以用<strong>紧凑</strong>来处理碎片，但是需要耗费很大的时间代价）</li>
</ul>
</li>
<li><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part4/image-20211112210113773.png" alt="image-20211112210113773" style="zoom: 67%;">


</li>
</ul>
</li>
</ul>
<ul>
<li>链接分配<ul>
<li>隐式链接<ul>
<li>除文件的最后一个盘块之外，每个盘块中都存有<strong>指向下一个盘块的指针</strong>。文件目录包括文件<strong>第一块</strong>的指针和<strong>最后一块</strong>的指针。</li>
<li>优点：<ul>
<li>很方便文件拓展</li>
<li>不会有碎片问题，外存利用率高。</li>
</ul>
</li>
<li>缺点：<ul>
<li>只支持顺序访问，查找效率低</li>
<li>指向下一个盘块的指针也需要耗费少量的存储空间</li>
</ul>
</li>
<li><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part4/image-20211112211102158.png" alt="image-20211112211102158" style="zoom:67%;"></li>
</ul>
</li>
<li>显式链接<ul>
<li>把用于链接文件各物理块的指针显式地存放在一张表中。即，<strong>文件分配表</strong>（<strong>FAT</strong>，File Allocation Table）</li>
<li>注意：<strong>一个磁盘仅设置一张FAT。开机时，将FAT读入内存，并常驻内存</strong>。<ul>
<li><strong>逻辑块号转换成物理块号的过程不需要读磁盘操作</strong>。</li>
</ul>
</li>
<li>优点：<ul>
<li>支持顺序访问，也<strong>支持随机访问</strong></li>
<li><strong>块号转换的过程不需要访问磁盘，文件的访问效率更高</strong></li>
<li><strong>不会产生外部碎片</strong>，也可以很方便地对文件进行拓展</li>
</ul>
</li>
<li>缺点：<ul>
<li>文件分配表的需要占用一定的存储空间。</li>
</ul>
</li>
<li><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part4/image-20211112211434277.png" alt="image-20211112211434277" style="zoom:67%;"></li>
</ul>
</li>
</ul>
</li>
<li>索引分配<ul>
<li>系统<strong>为每个文件建立一张索引表</strong>，索引表中<strong>记录了文件的各个逻辑块对应的物理块</strong>（内存管理中的页表：建立<strong>逻辑页面</strong>到<strong>物理页</strong>之间的映射关系）。</li>
<li>索引表存放的磁盘块称为<strong>索引块</strong>。文件数据存放的磁盘块称为<strong>数据块</strong>。</li>
<li>注意：<ul>
<li><strong>显式链接</strong>方式中，文件分配表 FAT 是<strong>一个磁盘对应一张</strong>。</li>
<li><strong>索引分配</strong>方式中，索引表是<strong>一个文件对应一张</strong>。</li>
</ul>
</li>
<li>优点：<ul>
<li>可以支持随机访问。</li>
<li>文件拓展也很容易实现</li>
</ul>
</li>
<li>缺点<ul>
<li>索引表需要占用一定的存储空间</li>
</ul>
</li>
<li><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part4/image-20211112212647379.png" alt="image-20211112212647379" style="zoom:67%;"></li>
<li><strong>链接方案</strong>：<ul>
<li>如果索引表太大，一个索引块装不下，那么可以将多个索引块链接起来存放。</li>
<li>缺点：若文件很大，索引表很长，就需要将很多个索引块链接起来。<strong>查找效率低下</strong>。</li>
<li><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part4/image-20211112213257207.png" alt="image-20211112213257207" style="zoom:67%;"></li>
</ul>
</li>
<li><strong>多层索引</strong>：<ul>
<li>建立多层索引（原理类似于多级页表）。</li>
<li>结论：<ul>
<li>采用 <strong>k</strong> 层索引结构时，且<strong>顶级索引表未调入内存</strong>，则访问一个数据块只需要 <strong>K+1</strong> 次磁盘操作</li>
</ul>
</li>
<li>缺点：<ul>
<li>即使是小文件，访问一个数据块依然需要 K+1 次读磁盘。</li>
</ul>
</li>
<li><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part4/image-20211112213345728.png" alt="image-20211112213345728" style="zoom:67%;"></li>
</ul>
</li>
<li><strong>混合索引</strong>：<ul>
<li>多种索引分配方式的结合。</li>
<li>优点：<ul>
<li><strong>对于小文件来说，访问一个数据块所需的读磁盘次数更少</strong>。</li>
</ul>
</li>
<li><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part4/image-20211112214310115.png" alt="image-20211112214310115" style="zoom:80%;"></li>
</ul>
</li>
<li><strong>超级超级超级重要考点</strong>：<ul>
<li>要会根据多层索引、混合索引的结构计算出文件的最大长度（Key：<strong>各级索引表最大不能超过一个块</strong>）；</li>
<li>要能自己分析访问某个数据块所需要的读磁盘次数Key：FCB 中会存有<strong>指向顶级索引块</strong>的指针，因此可以根据 FCB 读入顶级索引块。每次读入下一级的索引块都需要一次读磁盘操作。另外，要注意题目条件：<strong>顶级索引块是否已调入内存</strong>）</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="逻辑结构-VS-物理结构"><a href="#逻辑结构-VS-物理结构" class="headerlink" title="逻辑结构 VS 物理结构"></a>逻辑结构 VS 物理结构</h3><p><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part4/image-20211112215804531.png" alt="image-20211112215804531"><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part4/image-20211112215911132.png" alt="image-20211112215911132" style="zoom: 50%;"></p>
<ul>
<li>个人理解：<ul>
<li>逻辑结构，是用户针对<strong>文件中价值内容</strong>的组织，追求对内容的查询效率</li>
<li>物理结构，是操作系统针对<strong>空间利用率</strong>、<strong>物理查询速度</strong>的优化，对内容是无关的</li>
</ul>
</li>
</ul>
<h3 id="文件存储空间管理"><a href="#文件存储空间管理" class="headerlink" title="文件存储空间管理"></a>文件存储空间管理</h3><p><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part4/image-20211112221825169.png" alt="image-20211112221825169"></p>
<ul>
<li><p>存储空间的划分与初始化</p>
<ul>
<li><p>存储空间的划分：将物理磁盘划分为一个个<strong>文件卷</strong>（<strong>逻辑卷、逻辑盘</strong>）</p>
<ul>
<li>同时，也有系统可以支持<strong>由多个物理磁盘组成一个文件卷</strong></li>
</ul>
</li>
<li><p>存储空间的初始化：<strong>将各个文件卷划分为目录区、文件区</strong>。</p>
<ul>
<li><strong>目录区</strong>，主要存放文件目录信息（FCB）、用于磁盘存储空间管理的信息</li>
<li><strong>文件区</strong>，用于存放文件数据</li>
</ul>
</li>
<li><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part4/image-20211113222439483.png" alt="image-20211113222439483" style="zoom:67%;"></li>
</ul>
</li>
<li><p>从三个方面进行理解：</p>
<ol>
<li><p>用什么方式记录、组织空闲块？</p>
</li>
<li><p>如何分配磁盘块</p>
</li>
<li><p>如何回收磁盘块</p>
</li>
</ol>
</li>
<li><p>存储空间管理</p>
<ul>
<li><p>空闲表法</p>
<ul>
<li><p>特点：</p>
<ul>
<li>适用于“连续分配方式”</li>
</ul>
</li>
<li><p>如何分配磁盘块：</p>
<ul>
<li>与<strong>内存管理中的动态分区分配</strong>很类似，为一个文件<strong>分配连续的存储空间</strong>。</li>
<li>可采用<strong>首次适应、最佳适应、最坏适应等算法</strong>来决定要为文件分配哪个区间。</li>
</ul>
</li>
<li><p>如何回收磁盘块：</p>
<ul>
<li><p>与<strong>内存管理中的动态分区分配</strong>很类似，当回收某个存储区时需要有四种情况</p>
<ul>
<li>回收区的前后都没有相邻空闲区</li>
<li>回收区的前后都是空闲区</li>
<li>回收区前面是空闲区</li>
<li>回收区后面是空闲区。</li>
</ul>
</li>
<li><p>总之，回收时需要注意表项的合并问题。</p>
</li>
</ul>
</li>
<li><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part4/image-20211113223018472.png" alt="image-20211113223018472" style="zoom:80%;"></li>
</ul>
</li>
<li><p>空闲链表法</p>
<ul>
<li><p><strong>操作系统保存着链头、链尾指针</strong>。</p>
</li>
<li><p>空闲盘块链：</p>
<ul>
<li>如何分配：若某文件申请 K 个盘块，则<strong>从链头开始依次摘下 K 个盘块分配</strong>，并修改空闲链的链头指针。</li>
<li>如何回收：<strong>回收的盘块依次挂到链尾</strong>，并修改空闲链的链尾指针。</li>
</ul>
</li>
<li><p>空闲盘区链：</p>
<ul>
<li>如何分配：若某文件申请 K 个盘块，则可以<strong>采用首次适应、最佳适应等算法</strong>，从链头开始检索，按照算法规则找到一个大小符合要求的空闲盘区，分配给文件。若没有合适的连续空闲块，也可以将不同盘区的盘块同时分配给一个文件，注意分配后可能要修改相应的链指针、盘区大小等数据。</li>
<li>如何回收：若回收区和某个空闲盘区相邻，则需要将回收区<strong>合并</strong>到空闲盘区中。若回收区没有和任何空闲区相邻，将回收区作为单独的一个空闲盘区<strong>挂到链尾</strong>。</li>
</ul>
</li>
<li><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part4/image-20211113223526372.png" alt="image-20211113223526372" style="zoom:80%;"></li>
</ul>
</li>
<li><p>位示图法（常考）</p>
<ul>
<li>每个二进制位对应一个盘块。<ul>
<li>位示图一般用连续的“字”来表示，如本例中一个字的字长是 16 位，<strong>字中的每一位对应一个盘块</strong>。</li>
<li>可以用（<strong>字号，位号</strong>）对应一个盘块号。当然有的题目中也描述为（<strong>行号，列号</strong>）</li>
</ul>
</li>
<li>重要：要能自己推出盘块号与（字号，位号）相互转换的公式。<ul>
<li>注意题目条件，盘块号、字号、位号到底是从 0 开始还是从 1 开始</li>
<li>（字号，位号）=（i，j）的二进制位对应的*<em>盘块号 b = n * i + j*</em></li>
<li>b 号盘块对应的<strong>字号 i = b / n，位号 j = b % n</strong>。</li>
</ul>
</li>
<li>如何分配：若文件需要 K 个块<ul>
<li>顺序扫描位示图，找到 K 个相邻或不相邻的“0”</li>
<li>根据字号、位号算出对应的盘块号，将相应盘块分配给文件</li>
<li>将相应位设置为“1”。</li>
</ul>
</li>
<li>如何回收：<ul>
<li>根据回收的盘块号计算出对应的字号、位号</li>
<li>将相应二进制位设为“0” </li>
</ul>
</li>
<li><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part4/image-20211114190154046.png" alt="image-20211114190154046" style="zoom:80%;"></li>
</ul>
</li>
<li><p>成组链接法</p>
<ul>
<li>针对问题：<strong>空闲表法、空闲链表法不适用于大型文件系统</strong>，因为空闲表或空闲链表可能过大。</li>
<li>改进方向：UNIX 系统中采用了成组链接法对磁盘空闲块进行管理。</li>
<li>文件卷的<strong>目录区中专门用一个磁盘块作为“超级块”</strong>，当系统<strong>启动时需要将超级块读入内存</strong>。并且要<strong>保证内存与外存中的“超级块”数据一致</strong>。</li>
<li>下一组（指第二列）空闲盘块数为 100；（第一列）有 99 个指针指向真正空闲的盘区，第一个指针指向的盘块记录下下组（第三列）的空闲盘块信息。</li>
<li>如何分配：<ul>
<li>先从下一组（第二列）中取，同时删去第一列对应的指针，减少下一组空闲盘块数</li>
<li>若下一组（第二列）分配完，则超级块更新内容（复制第一个空闲块的信息），指向第三组的信息，同时第二列第一块空闲被分配。</li>
<li><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part4/image-20211114192427463.png" alt="image-20211114192427463"></li>
</ul>
</li>
<li>如何回收：<ul>
<li>需要将超级块中的数据复制到新回收的块中，并修改超级块的内容，让新回收的块成为第一个分组。</li>
<li><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part4/image-20211114193521443.png" alt="image-20211114193521443"></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="文件的基本操作"><a href="#文件的基本操作" class="headerlink" title="文件的基本操作"></a>文件的基本操作</h3><p><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part4/image-20211114203102662.png" alt="image-20211114203102662"></p>
<ul>
<li><p>创建文件</p>
<ul>
<li><p>需要提供的参数：</p>
<ul>
<li>所需的外存空间大小（如，一个盘块，即 1KB）</li>
<li>文件存放路径（如，“D:/Demo”）</li>
<li>文件名（如，“新建文本文档.txt”）</li>
</ul>
</li>
<li><p>操作系统处理 Create 系统调用：</p>
<ul>
<li><strong>在外存中找到文件所需的空间</strong>（<strong>分配空闲的磁盘空间</strong>）</li>
<li>根据文件存放路径的信息找到<strong>该目录对应的目录文件</strong>，在目录中<strong>创建该文件对应的目录项</strong>。目录项中包含了文件名、文件在外存中的存放位置等信息。</li>
</ul>
</li>
</ul>
</li>
<li><p>删除文件</p>
<ul>
<li><p>需要提供的参数：</p>
<ul>
<li>文件存放路径（如，“D:/Demo”）</li>
<li>文件名（如，“test.txt”）</li>
</ul>
</li>
<li><p>操作系统处理 Delete 系统调用：</p>
<ul>
<li>根据文件存放路径找到相应的目录文件，从目录中<strong>找到文件名对应的目录项</strong>。</li>
<li>根据该目录项记录的文件在外存的存放位置、文件大小等信息，<strong>回收文件占用的磁盘块</strong>。（<strong>回收空闲的磁盘空间</strong>）</li>
<li>从目录表中<strong>删除文件对应的目录项</strong>。</li>
</ul>
</li>
</ul>
</li>
<li><p>打开文件</p>
<ul>
<li><p>需要提供的参数：</p>
<ul>
<li>文件存放路径（如，“D:/Demo”）</li>
<li>文件名（如，“test.txt”）</li>
<li>要对文件的操作类型（如，r 只读、rw 读写等）</li>
</ul>
</li>
<li><p>操作系统处理 open 系统调用：</p>
<ul>
<li>根据文件存放路径找到相应的目录文件，从目录中<strong>找到文件名对应的的目录项</strong>，并<strong>检查该用户是否有指定的操作权限</strong>。</li>
<li><strong>将目录项复制到内存中的“打开文件表”中</strong>。并将对应表目的编号返回给用户。之后<strong>用户使用打开文件表的编号来指明要操作的文件</strong>。</li>
</ul>
</li>
<li><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part4/image-20211114195520247.png" alt="image-20211114195520247" style="zoom: 67%;"></li>
<li><p>进程的打开文件表和系统的打开文件表</p>
<ul>
<li><p>进程的打开文件表记录</p>
<ul>
<li>读写指针：记录了该进程对文件的读/写操作进行到的位置。每个进程都有不同的指针指向不同位置。</li>
<li>访问模式：如果打开文件时声明的是“只读”，则该进程不能对文件进行写操作</li>
</ul>
</li>
<li><p>系统的打开文件表记录（系统唯一）</p>
<ul>
<li>打开计数器：记录此时有多少个进程打开了此文件。若多个进程占用，则不允许删除。</li>
</ul>
</li>
<li><p><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part4/image-20211114200250821.png" alt="image-20211114200250821"></p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>关闭文件</p>
<ul>
<li>操作系统处理 Close 系统调用：<ul>
<li>将进程的打开文件表响应的表项删除</li>
<li>回收分配给该文件的内存空间等资源</li>
<li>系统打开文件表的打开计数器 -1，若 count=0，则删除对应表项</li>
</ul>
</li>
</ul>
</li>
<li><p>读文件</p>
<ul>
<li>需要提供的参数：<ul>
<li>指明哪个文件（<strong>在读文件之前已经打开文件了，所以只需要指明文件在进程的打开文件表中的索引号即可</strong>）</li>
<li>指明读入多少数据</li>
<li>指明<strong>从外存读入</strong>的数据要放在内存中的位置</li>
</ul>
</li>
<li>操作系统处理 Read 系统调用：<ul>
<li>从<strong>读指针指向的外存</strong>中，将用户指定大小的数据读入用户指定的内存区域中。</li>
</ul>
</li>
</ul>
</li>
<li><p>写文件</p>
<ul>
<li>需要提供的参数：<ul>
<li>指明哪个文件（<strong>指明文件在进程的打开文件表中的索引号</strong>）</li>
<li>指明写出多少数据</li>
<li>指明<strong>写回外存</strong>的数据放在内存中的位置</li>
</ul>
</li>
<li>操作系统处理 Write 系统调用：<ul>
<li>从用户指定的内存区域中，将指定大小的数据写回<strong>写指针指向的外存</strong>。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="文件系统的层次结构"><a href="#文件系统的层次结构" class="headerlink" title="文件系统的层次结构"></a>文件系统的层次结构</h3><p><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part4/image-20211114203949942.png" alt="image-20211114203949942"></p>
<p>辅助记忆：假设某用户请求删除文件 “D:/工作目录/学生信息.xlsx” 的最后100条记录。</p>
<ol>
<li><p>用户需要通过操作系统提供的接口发出请求——<strong>用户接口</strong></p>
</li>
<li><p>由于提供的是文件的存放路径，因此需要操作系统一层一层地查找目录，找到对应的目录项——<strong>文件目录系统</strong></p>
</li>
<li><p>不同的用户对文件有不同的操作权限，因此为了保证安全，需要检查用户是否有访问权限——<strong>存取控制模块（存取控制验证层）</strong></p>
</li>
<li><p>验证了用户的访问权限之后，需要把用户提供的“记录号”转变为对应的逻辑地址——<strong>逻辑文件系统与文件信息缓冲区</strong></p>
</li>
<li><p>知道了目标记录对应的逻辑地址后，还需要转换成实际的物理地址——<strong>物理文件系统</strong></p>
</li>
<li><p>要删除这条记录，必定要对磁盘设备发出请求——<strong>设备管理程序模块</strong></p>
</li>
<li><p>删除这些记录后，会有一些盘块空闲，因此要将这些空闲盘块回收——<strong>辅助分配模块</strong></p>
</li>
</ol>
<h2 id="磁盘组织与管理"><a href="#磁盘组织与管理" class="headerlink" title="磁盘组织与管理"></a>磁盘组织与管理</h2><h3 id="磁盘的结构"><a href="#磁盘的结构" class="headerlink" title="磁盘的结构"></a>磁盘的结构</h3><p><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part4/image-20211115125801360.png" alt="image-20211115125801360"></p>
<ul>
<li>磁盘：磁盘的<strong>表面由一些磁性物质组成</strong>，可以用这些磁性物质来<strong>记录二进制数据</strong>。</li>
<li>磁道：磁盘的盘面被划分成一个个磁道，一个“圈”就是一个磁道</li>
<li>扇区：一个磁道被划分成多个扇区，<strong>每个扇区</strong>就是一个“<strong>磁盘块</strong>”。各个扇区存放的数据量相同（如1KB）<ul>
<li>最内侧磁道上的扇区面积最小，因此数据密度最大</li>
<li>重要：<strong>每个扇区</strong>就是一个“<strong>磁盘块</strong>”！</li>
</ul>
</li>
<li>盘面：一个盘片可能会有两个盘面</li>
<li>磁头：每个盘面对应一个磁头。<strong>所有的磁头只能共进退</strong>。</li>
<li><strong>磁盘的物理地址</strong><ul>
<li><strong>可用（柱面号，盘面号，扇区号）来定位任意一个“磁盘块”</strong>。外存中的块号就可以转换成（柱面号，盘面号，扇区号）的地址形式。</li>
<li>读取一个“块”的流程<ul>
<li>根据“柱面号”移动磁臂，让磁头指向<strong>指定柱面</strong>；</li>
<li><strong>激活指定盘面对应的磁头</strong>；</li>
<li>磁盘旋转的过程中，指定的扇区从磁头下面划过，完成对指定扇区的读/写。</li>
</ul>
</li>
</ul>
</li>
<li>磁盘的分类<ul>
<li>根据磁头分类：<ul>
<li>磁头可以移动的称为<strong>活动头磁盘</strong>。磁臂可以来回伸缩来带动磁头定位磁道</li>
<li>磁头不可移动的称为<strong>固定头磁盘</strong>。这种磁盘中每个磁道有一个磁头</li>
</ul>
</li>
<li>根据是否可以更换分类：<ul>
<li>盘片可以更换的称为<strong>可换盘磁盘</strong>。</li>
<li>盘片不可更换的称为<strong>固定盘磁盘</strong>。</li>
</ul>
</li>
</ul>
</li>
<li><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part4/image-20211115125719713.png" alt="image-20211115125719713"></li>
</ul>
<h3 id="磁盘调度算法"><a href="#磁盘调度算法" class="headerlink" title="磁盘调度算法"></a>磁盘调度算法</h3><p><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part4/image-20211115125939512.png" alt="image-20211115125939512"></p>
<ul>
<li><p>一次磁盘读/写操作需要的时间</p>
<ul>
<li>**寻找时间（寻道时间）T<del>S</del>**：在读/写数据前，将磁头移动到指定磁道所花的时间。<ul>
<li><strong>启动磁头臂</strong>是需要时间的。假设耗时为 s；</li>
<li><strong>移动磁头</strong>也是需要时间的。假设磁头匀速移动，每跨越一个磁道耗时为 m，总共需要跨越 n 条磁道；</li>
<li>寻道时间 *<em>T<del>S</del> = s + m * n*</em> </li>
</ul>
</li>
<li>**延迟时间 T<del>R</del>**：通过旋转磁盘，使磁头定位到目标扇区所需要的时间。<ul>
<li>设磁盘转速为 r （单位：转/秒，或 转/分）<ul>
<li>硬盘的典型转速为 5400 转/分，或 7200 转/分</li>
</ul>
</li>
<li>平均所需的延迟时间 *<em>T<del>R</del> = (1/2)</em>(1/r) = 1/2r**<ul>
<li>找到目标扇区平均需要转半圈，因此再乘以 1/2</li>
</ul>
</li>
</ul>
</li>
<li>**传输时间 T<del>t</del>**：从磁盘读出或向磁盘写入数据所经历的时间<ul>
<li>假设磁盘转速为 r，此次读/写的字节数为 b，每个磁道上的字节数为 N</li>
<li>传输时间 *<em>T<del>t</del> = (1/r) * (b/N) = b/(rN)*</em></li>
</ul>
</li>
<li>延迟时间、传输时间都<strong>与磁盘转速为线性相关</strong>。而转速是硬件的固有属性，因此<strong>操作系统无法优化延迟时间和传输时间</strong></li>
<li><strong>移动磁头</strong>所花费的时间，是磁盘调度算法影响的指标</li>
</ul>
</li>
<li><p>磁盘调度算法</p>
<ul>
<li><p>先来先服务算法（FCFS）</p>
<ul>
<li>算法思想：根据进程请求访问磁盘的先后顺序进行调度。<ul>
<li><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part4/image-20211115131917033.png" alt="image-20211115131917033" style="zoom: 80%;"></li>
</ul>
</li>
<li>优点：公平；如果请求访问的磁道比较集中，则算法性能还行</li>
<li>缺点：如果有大量进程竞争使用磁盘，请求访问的磁道很分散，则 FCFS 在性能上很差，寻道时间长。</li>
</ul>
</li>
<li><p>最短寻找时间优先（SSTF）</p>
<ul>
<li>算法思想：SSTF 算法会优先处理的磁道是与当前磁头最近的磁道。<ul>
<li><strong>可以保证每次的寻道时间最短，但是并不能保证总的寻道时间最短</strong>。</li>
<li><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part4/image-20211115132033429.png" alt="image-20211115132033429" style="zoom:80%;"></li>
</ul>
</li>
<li>优点：性能较好，平均寻道时间短</li>
<li>缺点：<strong>可能产生“饥饿”现象</strong></li>
</ul>
</li>
<li><p>扫描算法（SCAN）</p>
<ul>
<li>针对问题：SSTF 算法会产生饥饿</li>
<li>问题原因：磁头有可能<strong>在一个小区域内来回移动</strong>。</li>
<li>算法思想：<strong>扫描算法（电梯算法）规定，只有磁头移动到最外侧磁道的时候才能往内移动，移动到最内侧磁道的时候才能往外移动</strong>。<ul>
<li><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part4/image-20211115132330637.png" alt="image-20211115132330637" style="zoom:80%;"></li>
</ul>
</li>
<li>优点：性能较好，平均寻道时间较短，不会产生饥饿现象</li>
<li>缺点：<ul>
<li>只有到达最边上的磁道才能改变磁头移动方向。</li>
<li><strong>对于各个位置磁道的响应频率不平均</strong></li>
</ul>
</li>
</ul>
</li>
<li><p>LOOK 调度算法</p>
<ul>
<li>针对问题：扫描算法只有到达最边上的磁道才能改变磁头移动方向。</li>
<li>算法思想：<strong>如果在磁头移动方向上已经没有别的请求，就可以立即改变磁头移动方向</strong>。（边移动边观察，因此叫 LOOK）<ul>
<li><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part4/image-20211115132956097.png" alt="image-20211115132956097" style="zoom:80%;"></li>
</ul>
</li>
<li>优点：比起 SCAN 算法，<strong>使寻道时间进一步缩短</strong>。</li>
</ul>
</li>
<li><p>循环扫描算法（C-SCAN）</p>
<ul>
<li>针对问题：扫描算法对于各个位置磁道的响应频率不平均。</li>
<li>算法思想：规定<strong>只有磁头朝某个特定方向移动时才处理磁道访问请求</strong>，而<strong>返回时直接快速移动至起始端而不处理任何请求</strong>。<ul>
<li><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part4/image-20211115133606481.png" alt="image-20211115133606481" style="zoom:80%;"></li>
</ul>
</li>
<li>优点：比起 SCAN，对于各个位置磁道的响应频率很平均。</li>
<li>缺点：<ul>
<li>只有到达最边上的磁道时才能改变磁头移动方向</li>
<li>磁头返回时其实只需要返回到 18 号磁道即可，不需要返回到最边缘的磁道。</li>
<li>比起 SCAN 算法，平均寻道时间更长。</li>
</ul>
</li>
</ul>
</li>
<li><p>C-LOOK 调度算法</p>
<ul>
<li>算法思想：如果磁头移动的方向上已经没有磁道访问请求了，就可以立即让磁头返回，并且磁头只需要返回到有磁道访问请求的位置即可。<ul>
<li>也就是 C-SCAN + LOOK</li>
<li><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part4/image-20211115133949701.png" alt="image-20211115133949701" style="zoom:80%;"></li>
</ul>
</li>
<li>优点：比起 C-SCAN 算法，不需要每次都移动到最外侧或最内侧才改变磁头方向，<strong>使寻道时间进一步缩短</strong></li>
</ul>
</li>
<li><blockquote>
<p>若题目中无特别说明， 则 SCAN 就是 LOOK， C-SCAN 就是 C-LOOK</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<h3 id="减少磁盘延迟时间的方法"><a href="#减少磁盘延迟时间的方法" class="headerlink" title="减少磁盘延迟时间的方法"></a>减少磁盘延迟时间的方法</h3><p><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part4/image-20211115150136330.png" alt="image-20211115150136330"></p>
<ul>
<li>针对问题：磁头读入一个扇区数据后需要一小段时间处理，如果<strong>逻辑上相邻的扇区在物理上也相邻，则将花费很长的延迟时间</strong></li>
<li>减少延迟时间的方法：<strong>交替编号</strong><ul>
<li>采用交替编号的策略，即让逻辑上相邻的扇区在物理上有一定的间隔，可以使读取连续的逻辑扇区所需要的延迟时间更小。</li>
<li><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part4/image-20211115145219763.png" alt="image-20211115145219763" style="zoom: 67%;"></li>
</ul>
</li>
<li><strong>磁盘地址结构的设计</strong><ul>
<li><strong>磁盘的物理地址是（柱面号，盘面号，扇区号）</strong>而不是（盘面号，柱面号，扇区号）</li>
<li>原因：读取地址连续的磁盘块时，采用（柱面号，盘面号，扇区号）的地址结构<strong>可以减少磁头移动消耗的时间</strong>，<strong>仅需激活不同盘面上的磁头</strong>。</li>
</ul>
</li>
<li>减少延迟时间的方法：<strong>错位命名</strong><ul>
<li>为了在读取地址连续的磁盘块、切换盘面激活磁头时，需要空出间隔保证磁头启动。</li>
<li><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part4/image-20211115145913456.png" alt="image-20211115145913456" style="zoom:67%;">

</li>
</ul>
</li>
</ul>
<h3 id="磁盘的管理"><a href="#磁盘的管理" class="headerlink" title="磁盘的管理"></a>磁盘的管理</h3><p><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part4/image-20211115150211019.png" alt="image-20211115150211019"></p>
<ul>
<li>磁盘初始化：<ol>
<li>进行<strong>低级格式化（物理格式化）</strong>，将磁盘的各个磁道划分为扇区。一个扇区通常可分为<strong>头</strong>、<strong>数据区域</strong>（如 512B 大小）、<strong>尾</strong>三个部分组成。<ul>
<li>管理扇区所需要的各种数据结构一般存放在<strong>头、尾</strong>两个部分，包括扇区校验码（如奇偶校验、CRC 循环冗余校验码等）</li>
</ul>
</li>
<li>将磁盘分区，每个分区由若干柱面组成（即分为我们熟悉的 C盘、D盘、E盘）<ul>
<li><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part4/image-20211115151139969.png" alt="image-20211115151139969" style="zoom:50%;"></li>
</ul>
</li>
<li>进行<strong>逻辑格式化</strong>，<strong>创建文件系统</strong>。包括创建文件系统的根目录、初始化存储空间管理所用的数据结构（如 位示图、空闲分区表）</li>
</ol>
</li>
<li>引导块：<ul>
<li>计算机开机时需要进行初始化，这些初始化工作是通过执行<strong>初始化程序（自举程序）</strong>完成的<ul>
<li>出厂时在主板上将集成一块<strong>不可修改的 ROM</strong>（只读存储器），其中只存放很小的“<strong>自举装入程序</strong>”</li>
<li>完整的自举程序放在磁盘的启动块（即<strong>引导块/启动分区</strong>）上，<strong>启动块位于磁盘的固定位置</strong>。</li>
<li>开机时计算机先运行“自举装入程序”，通过执行该程序就可找到引导块，并将完整的“自举程序”读入内存，完成初始化</li>
</ul>
</li>
<li>拥有启动分区的磁盘称为<strong>启动磁盘</strong>或<strong>系统磁盘</strong>。</li>
</ul>
</li>
<li>坏块的管理<ul>
<li>对于简单的磁盘，可以在<strong>逻辑格式化</strong>时对整个磁盘进行坏块检查，标明哪些扇区是坏扇区，比如：在文件分配表（FAT）上标明。<ul>
<li>在这种方式中，<strong>坏块对操作系统不透明</strong>。</li>
</ul>
</li>
<li>对于复杂的磁盘，磁盘控制器（磁盘设备内部的一个硬件部件）会维护一个坏块链表。<ul>
<li>在磁盘出厂前进行低级格式化（物理格式化）时就将坏块链进行初始化。</li>
<li>会保留一些<strong>备用扇区</strong>，用于替换坏块。这种方案称为<strong>扇区备用</strong>。</li>
<li>这种处理方式中，<strong>坏块对操作系统透明</strong>。 </li>
</ul>
</li>
</ul>
</li>
</ul>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://nephrencake.github.io">NephrenCake</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://nephrencake.github.io/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part4/">https://nephrencake.github.io/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part4/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://nephrencake.github.io" target="_blank">浅幽丶奈芙莲的个人博客</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E5%AE%8C%E7%BB%93%E7%9B%AE%E5%BD%95/%E4%BA%8Ced12.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part5/"><img class="prev-cover" src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E5%AE%8C%E7%BB%93%E7%9B%AE%E5%BD%95/%E4%BA%8Ced12.jpg" onerror="onerror=null;src='/img/404.png'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">操作系统-Part5</div></div></a></div><div class="next-post pull-right"><a href="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part3/"><img class="next-cover" src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E5%AE%8C%E7%BB%93%E7%9B%AE%E5%BD%95/%E4%BA%8Ced12.jpg" onerror="onerror=null;src='/img/404.png'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">操作系统-Part3</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part4%E2%80%94%E2%80%94%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86"><span class="toc-number">1.</span> <span class="toc-text">操作系统-Part4——文件管理</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80"><span class="toc-number">1.1.</span> <span class="toc-text">文件系统基础</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9D%E8%AF%86%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86"><span class="toc-number">1.1.1.</span> <span class="toc-text">初识文件管理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E7%9A%84%E9%80%BB%E8%BE%91%E7%BB%93%E6%9E%84"><span class="toc-number">1.1.2.</span> <span class="toc-text">文件的逻辑结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E7%9B%AE%E5%BD%95"><span class="toc-number">1.1.3.</span> <span class="toc-text">文件目录</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E4%BF%9D%E6%8A%A4"><span class="toc-number">1.1.4.</span> <span class="toc-text">文件保护</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E5%85%B1%E4%BA%AB"><span class="toc-number">1.1.5.</span> <span class="toc-text">文件共享</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.2.</span> <span class="toc-text">文件系统实现</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E7%9A%84%E7%89%A9%E7%90%86%E7%BB%93%E6%9E%84%EF%BC%88%E9%87%8D%E7%82%B9%EF%BC%89"><span class="toc-number">1.2.1.</span> <span class="toc-text">文件的物理结构（重点）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%BB%E8%BE%91%E7%BB%93%E6%9E%84-VS-%E7%89%A9%E7%90%86%E7%BB%93%E6%9E%84"><span class="toc-number">1.2.2.</span> <span class="toc-text">逻辑结构 VS 物理结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E5%AD%98%E5%82%A8%E7%A9%BA%E9%97%B4%E7%AE%A1%E7%90%86"><span class="toc-number">1.2.3.</span> <span class="toc-text">文件存储空间管理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C"><span class="toc-number">1.2.4.</span> <span class="toc-text">文件的基本操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84"><span class="toc-number">1.2.5.</span> <span class="toc-text">文件系统的层次结构</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A3%81%E7%9B%98%E7%BB%84%E7%BB%87%E4%B8%8E%E7%AE%A1%E7%90%86"><span class="toc-number">1.3.</span> <span class="toc-text">磁盘组织与管理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A3%81%E7%9B%98%E7%9A%84%E7%BB%93%E6%9E%84"><span class="toc-number">1.3.1.</span> <span class="toc-text">磁盘的结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A3%81%E7%9B%98%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95"><span class="toc-number">1.3.2.</span> <span class="toc-text">磁盘调度算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%8F%E5%B0%91%E7%A3%81%E7%9B%98%E5%BB%B6%E8%BF%9F%E6%97%B6%E9%97%B4%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-number">1.3.3.</span> <span class="toc-text">减少磁盘延迟时间的方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A3%81%E7%9B%98%E7%9A%84%E7%AE%A1%E7%90%86"><span class="toc-number">1.3.4.</span> <span class="toc-text">磁盘的管理</span></a></li></ol></li></ol></li></ol></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2021 - 2022 By NephrenCake</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">这里是浅幽丶奈芙莲的个人博客~</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><script src="/js/search/local-search.js"></script><script>var preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',preloader.endLoading())</script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><!-- hexo injector body_end start -->
  <script data-pjax src="https://cdn.jsdelivr.net/gh/Zfour/hexo-github-calendar@1.21/hexo_githubcalendar.js"></script>
  <script data-pjax>
        function GithubCalendarConfig(){
            var git_githubapiurl ="https://python-github-calendar-api.vercel.app/api?NephrenCake";
            var git_color =['#ebedf0', '#fdcdec', '#fc9bd9', '#fa6ac5', '#f838b2', '#f5089f', '#c4067e', '#92055e', '#540336', '#48022f', '#30021f'];
            var git_user ="NephrenCake";
            var parent_div_git = document.getElementById('recent-posts');
            var git_div_html = '<div class="recent-post-item" style="width:100%;height:auto;padding:10px;"><div id="github_loading" style="width:10%;height:100%;margin:0 auto;display: block"><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"  viewBox="0 0 50 50" style="enable-background:new 0 0 50 50" xml:space="preserve"><path fill="#d0d0d0" d="M25.251,6.461c-10.318,0-18.683,8.365-18.683,18.683h4.068c0-8.071,6.543-14.615,14.615-14.615V6.461z" transform="rotate(275.098 25 25)"><animateTransform attributeType="xml" attributeName="transform" type="rotate" from="0 25 25" to="360 25 25" dur="0.6s" repeatCount="indefinite"></animateTransform></path></svg></div><div id="github_container"></div></div>';
            if(parent_div_git && location.pathname =='/'){
                console.log('已挂载github calendar')
                // parent_div_git.innerHTML=git_div_html+parent_div_git.innerHTML // 无报错，但不影响使用(支持pjax跳转)
                parent_div_git.insertAdjacentHTML("afterbegin",git_div_html) // 有报错，但不影响使用(支持pjax跳转)
            };
            GithubCalendar(git_githubapiurl,git_color,git_user)
        }
        if(document.getElementById('recent-posts')){
            GithubCalendarConfig()
        }
    </script>
    <style>#github_container{min-height:280px}@media screen and (max-width:650px) {#github_container{background-image:;min-height:0px}}</style>
    <style></style><!-- hexo injector body_end end --></body></html>