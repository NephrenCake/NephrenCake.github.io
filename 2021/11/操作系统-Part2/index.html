<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>操作系统-Part2 | 浅幽丶奈芙莲的个人博客</title><meta name="author" content="NephrenCake"><meta name="copyright" content="NephrenCake"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><meta name="description" content="进程管理">
<meta property="og:type" content="article">
<meta property="og:title" content="操作系统-Part2">
<meta property="og:url" content="https://nephrencake.gitee.io/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part2/index.html">
<meta property="og:site_name" content="浅幽丶奈芙莲的个人博客">
<meta property="og:description" content="进程管理">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://nephrencake.gitee.io/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E5%AE%8C%E7%BB%93%E7%9B%AE%E5%BD%95/%E4%BA%8Ced12.jpg">
<meta property="article:published_time" content="2021-11-01T01:43:44.000Z">
<meta property="article:modified_time" content="2021-11-16T08:41:01.852Z">
<meta property="article:author" content="NephrenCake">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://nephrencake.gitee.io/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E5%AE%8C%E7%BB%93%E7%9B%AE%E5%BD%95/%E4%BA%8Ced12.jpg"><link rel="shortcut icon" href="/img/favicon.jpg"><link rel="canonical" href="https://nephrencake.gitee.io/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part2/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: {"limitDay":365,"position":"top","messagePrev":"It has been","messageNext":"days since the last update, the content of the article may be outdated."},
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
};

var saveToLocal = {
  set: function setWithExpiry(key, value, ttl) {
    const now = new Date()
    const expiryDay = ttl * 86400000
    const item = {
      value: value,
      expiry: now.getTime() + expiryDay,
    }
    localStorage.setItem(key, JSON.stringify(item))
  },

  get: function getWithExpiry(key) {
    const itemStr = localStorage.getItem(key)

    if (!itemStr) {
      return undefined
    }
    const item = JSON.parse(itemStr)
    const now = new Date()

    if (now.getTime() > item.expiry) {
      localStorage.removeItem(key)
      return undefined
    }
    return item.value
  }
}

// https://stackoverflow.com/questions/16839698/jquery-getscript-alternative-in-native-javascript
const getScript = url => new Promise((resolve, reject) => {
  const script = document.createElement('script')
  script.src = url
  script.async = true
  script.onerror = reject
  script.onload = script.onreadystatechange = function() {
    const loadState = this.readyState
    if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
    script.onload = script.onreadystatechange = null
    resolve()
  }
  document.head.appendChild(script)
})</script><script id="config_change">var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2021-11-16 16:41:01'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(function () {const asideStatus = saveToLocal.get('aside-status')
if (asideStatus !== undefined) {
   if (asideStatus === 'hide') {
     document.documentElement.classList.add('hide-aside')
   } else {
     document.documentElement.classList.remove('hide-aside')
   }
}})()</script><link rel="stylesheet" href="/css/background.css"><link rel="stylesheet" href="/css/mouse.css"><link rel="stylesheet" href="/css/scrollbar.css"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/iconfont.css"><meta name="generator" content="Hexo 5.3.0"><link rel="alternate" href="/atom.xml" title="浅幽丶奈芙莲的个人博客" type="application/atom+xml">
</head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="author-avatar"><img class="avatar-img" src="/img/avatar.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">85</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">9</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">14</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/photo/"><i class="fa-fw fas fa-heart"></i><span> 相册</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友情链接</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E5%AE%8C%E7%BB%93%E7%9B%AE%E5%BD%95/%E4%BA%8Ced12.jpg)"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">浅幽丶奈芙莲的个人博客</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/photo/"><i class="fa-fw fas fa-heart"></i><span> 相册</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友情链接</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">操作系统-Part2</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2021-11-01T01:43:44.000Z" title="发表于 2021-11-01 09:43:44">2021-11-01</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2021-11-16T08:41:01.852Z" title="更新于 2021-11-16 16:41:01">2021-11-16</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">操作系统</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">14.5k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>42分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="操作系统-Part2——进程管理"><a href="#操作系统-Part2——进程管理" class="headerlink" title="操作系统-Part2——进程管理"></a>操作系统-Part2——进程管理</h1><p>[TOC]</p>
<h2 id="进程与线程"><a href="#进程与线程" class="headerlink" title="进程与线程"></a>进程与线程</h2><h3 id="进程的概念、组成、特征"><a href="#进程的概念、组成、特征" class="headerlink" title="进程的概念、组成、特征"></a>进程的概念、组成、特征</h3><p><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part2/image-20211102143509078.png" alt="image-20211102143509078"></p>
<ul>
<li><p>概念</p>
<ul>
<li>程序：是静态的，是存放在磁盘的可执行文件。</li>
<li>进程：是动态的，是进程实体的运行过程，<strong>是能独立运行、独立获得资源、独立接受调度的基本单位</strong>。<ul>
<li>进程实体（进程映像）：是静态的，一个进程实体由 PCB、程序段、数据段组成。</li>
<li><strong>进程实体（进程映像）反应了进程某一时刻的状态</strong></li>
</ul>
</li>
<li>同一个程序多次执行会对应多个进程</li>
</ul>
</li>
<li><p>组成（严格地来说是<strong>进程实体的组成</strong>）</p>
<ul>
<li><strong>进程控制块</strong>（Process Control Block，PCB）<ul>
<li><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part2/image-20211102140823925.png" alt="image-20211102140823925"><ul>
<li>进程描述信息：用于区分各个进程</li>
<li>进程控制和管理信息：用于实现操作系统对进程的控制、调度</li>
<li>资源分配清单：用于实现对资源的管理</li>
<li>处理机相关信息：用于实现进程切换</li>
</ul>
</li>
<li>其中，进程标识符 PID 是<strong>唯一的、不重复的</strong>，即使进程已经被杀死</li>
<li>操作系统对进程进行管理工作<strong>所需的所有信息，都存在 PCB 中</strong></li>
<li><strong>PCB 是进程存在的唯一标志</strong>，当进程被创建时，操作系统为其创建 PCB，当进程结束时，会回收其 PCB。</li>
</ul>
</li>
<li><strong>程序段</strong>与<strong>数据段</strong><ul>
<li>PCB 是给<strong>操作系统</strong>用的。程序段、数据段是给<strong>进程</strong>自己用的。</li>
<li>程序段：程序的代码（指令序列）<ul>
<li>一个应用的多个进程拥有<strong>相同的程序段</strong></li>
</ul>
</li>
<li>数据段：运行过程中的各种数据（变量）<ul>
<li>一个应用的多个进程拥有<strong>不同的数据段</strong></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>特征</p>
<ul>
<li><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part2/image-20211102143009562.png" alt="image-20211102143009562"></li>
<li>动态性是进程最基本的特征</li>
<li>引入线程之后，进程不再是独立接受调度的基本单位，但仍是独立获得资源的基本单位</li>
</ul>
</li>
</ul>
<h3 id="进程的状态与转换、进程的组织"><a href="#进程的状态与转换、进程的组织" class="headerlink" title="进程的状态与转换、进程的组织"></a>进程的状态与转换、进程的组织</h3><p><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part2/image-20211102152923790.png" alt="image-20211102152923790"></p>
<p>进程的状态与转换</p>
<ul>
<li>状态转换过程<ul>
<li><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part2/image-20211102152203439.png" alt="image-20211102152203439"></li>
<li>创建态（New，新建态）：进程正在被创建。在这个阶段，操作系统会为进程分配资源、初始化 PCB</li>
<li>就绪态（Ready）：仅缺少 CPU，具备其他所有运行条件，随时可以被处理运行</li>
<li>运行态（Running）：进程正在 CPU 上运行<ul>
<li>多核 CPU 可能有多个进程处于运行态</li>
</ul>
</li>
<li>阻塞态（Waiting/Blocked，等待态）：进程<strong>主动</strong>请求等待某个事件的发生（资源分配或其他进程响应）<ul>
<li>即除 CPU 之外还缺少必要的条件，只有<strong>被动</strong>获得其余条件，才能转化成就绪态</li>
</ul>
</li>
<li>终止态（Terminated，结束态）：执行 exit 系统调用，或出现终止异常。进程下 CPU、回收内存空间等<strong>资源</strong>、回收该进程的 <strong>PCB</strong>，彻底消失。</li>
</ul>
</li>
<li>三种基本状态：运行态、就绪态、阻塞态</li>
<li><strong>不能由阻塞态直接转为运行态，也不能由就绪态直接转为阻塞态</strong>。</li>
<li>进程 PCB 中，会有一个变量 state 来表示进程的当前状态</li>
</ul>
<p>进程的组织</p>
<ul>
<li>链接方式<ul>
<li>按照进程状态将 PCB 分为多个队列</li>
<li>操作系统持有各个队列的指针</li>
</ul>
</li>
<li>索引方式<ul>
<li>根据进程状态的不同，建立索引表</li>
<li>操作系统持有各个索引表的指针</li>
</ul>
</li>
</ul>
<h3 id="进程控制"><a href="#进程控制" class="headerlink" title="进程控制"></a>进程控制</h3><ul>
<li><p>基本概念</p>
<ul>
<li>进程控制：实现进程状态转换</li>
<li>进程控制的实现方式：原语<ul>
<li>原语的执行具有<strong>原子性</strong>，运行必须一气呵成，不可中断</li>
<li>进程控制/状态转换，不可中断</li>
<li>通过<strong>关/中断指令</strong>这两个<strong>特权指令</strong>实现原子性</li>
<li>进程控制必定是内核程序，需要运行在<strong>核心态</strong></li>
</ul>
</li>
</ul>
</li>
<li><p>进程控制相关原语</p>
<ul>
<li>进程的创建<ul>
<li><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part2/image-20211102155434833.png" alt="image-20211102155434833"></li>
<li>作业调度：将位于<strong>外存</strong>后备队列中的作业调入<strong>内存</strong></li>
</ul>
</li>
<li>进程的终止<ul>
<li><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part2/image-20211102155614381.png" alt="image-20211102155614381" style="zoom:80%;"></li>
</ul>
</li>
<li>进程的阻塞、进程的唤醒<ul>
<li><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part2/image-20211102155717098.png" alt="image-20211102155717098"></li>
<li>阻塞和切换必定成对出现</li>
</ul>
</li>
<li>进程的切换<ul>
<li><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part2/image-20211102155913145.png" alt="image-20211102155913145" style="zoom: 67%;"></li>
<li>通过 PCB 恢复运行环境</li>
</ul>
</li>
</ul>
</li>
<li><p>无论哪个进程控制原语，要做的无非三类事情：</p>
<ul>
<li>更新 PCB 中的信息（修改进程状态，保存/恢复运行环境）<ul>
<li>所有的进程控制原语一定都会修改进程状态标志</li>
<li>剥夺当前运行进程的CPU使用权必然需要保存其运行环境</li>
<li>某进程开始运行前必然要恢复期运行环境</li>
</ul>
</li>
<li>将 PCB 插入合适的队列</li>
<li>分配/回收资源</li>
</ul>
</li>
</ul>
<h3 id="进程通信"><a href="#进程通信" class="headerlink" title="进程通信"></a>进程通信</h3><p><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part2/image-20211102160516149.png" alt="image-20211102160516149"></p>
<ul>
<li>基本概念<ul>
<li>进程通信（Inter-Process Communication， IPC）是指两个进程之间产生数据交互。</li>
<li>进程是分配系统资源的单位（包括内存地址空间），因此各进程拥有的<strong>内存地址空间相互独立</strong>。<ul>
<li>为了保证安全，<strong>一个进程不能直接访问另一个进程的地址空间</strong>。</li>
</ul>
</li>
</ul>
</li>
<li><strong>共享存储</strong><ul>
<li>为避免出错，各个进程对共享空间的访问应该是<strong>互斥</strong>的。</li>
<li>基于<strong>数据结构</strong>的共享：<ul>
<li>比如共享空间里只能放一个长度为 10 的数组。</li>
<li>速度慢、限制多，是一种<strong>低级通信</strong>方式</li>
</ul>
</li>
<li>基于<strong>存储区</strong>的共享：<ul>
<li>操作系统在内存中划出一块共享存储区。数据的形式、存放位置都由<strong>通信进程</strong>控制，而不是操作系统。</li>
<li>速度很快，是一种<strong>高级通信</strong>方式。</li>
<li><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part2/image-20211102190332073.png" alt="image-20211102190332073" style="zoom: 67%;"></li>
</ul>
</li>
</ul>
</li>
<li><strong>消息传递</strong><ul>
<li>进程间的数据交换以<strong>格式化的消息</strong>（Message）为单位。进程通过操作系统提供的“发送消息/接收消息”两个<strong>原语</strong>进行数据交换。</li>
<li><strong>直接通信方式</strong><ul>
<li>消息发送进程要指明接收进程的ID</li>
<li><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part2/image-20211102190853574.png" alt="image-20211102190853574" style="zoom: 67%;"></li>
</ul>
</li>
<li><strong>间接通信方式</strong><ul>
<li>通过“信箱”间接地通信。因此又称“信箱通信方式”</li>
<li><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part2/image-20211102191135092.png" alt="image-20211102191135092" style="zoom:67%;"></li>
</ul>
</li>
</ul>
</li>
<li><strong>管信通信</strong><ul>
<li>“管道”是一个特殊的共享文件，又名 pipe 文件。其实就是在内存中开辟一个<strong>大小固定的内存缓冲区</strong>（循环队列）</li>
<li>管道只能采用<strong>半双工通信</strong>，某一时间段内只能实现单向的传输。如果要实现<strong>全双工通信</strong>，则需要设置两个管道。</li>
<li>各进程要<strong>互斥</strong>地访问管道（由操作系统实现）</li>
<li>当管道<strong>写满</strong>时，<strong>写进程将阻塞</strong>，直到读进程将管道中的数据取走，即可唤醒写进程。</li>
<li>当管道<strong>读空</strong>时，<strong>读进程将阻塞</strong>，直到写进程往管道中写入数据，即可唤醒读进程。</li>
<li>管道中的数据一旦被读出，就彻底消失。因此，当多个进程读同一个管道时，可能会错乱。对此，通常有两种解决方案：<ul>
<li>一个管道允许<strong>多个写进程，一个读进程</strong>（2014年408真题高教社官方答案）；</li>
<li>允许有多个写进程，多个读进程，但系统会让各个读进程轮流从管道中读数据（Linux 的方案）。</li>
</ul>
</li>
<li>只要管道没空，读进程就可以从管道读数据；只要管道没满，写进程就可以往管道写数据。</li>
</ul>
</li>
</ul>
<h3 id="线程的概念与特点"><a href="#线程的概念与特点" class="headerlink" title="线程的概念与特点"></a>线程的概念与特点</h3><ul>
<li>线程是一个基本的 CPU 执行单元，是<strong>程序执行流的最小单位</strong>。</li>
<li>带来的变化：<ul>
<li>资源分配、调度<ul>
<li>传统进程机制中，进程是资源分配、调度的基本单位</li>
<li>引入线程之后，进程是<strong>资源分配</strong>的基本单位，线程是<strong>调度</strong>的基本单位</li>
</ul>
</li>
<li>并发性<ul>
<li>传统进程机制中，只能进程间并发</li>
<li>引入线程之后，各线程之间也能并发，提升了并发度</li>
</ul>
</li>
<li>系统开销<ul>
<li>传统的进程间并发，需要切换进程的运行环境，系统开销大</li>
<li>线程间并发，如果是<strong>同一线程内的线程切换</strong>，则不需要切换进程环境，<strong>系统开销小</strong></li>
<li>引入线程后，并发带来的系统开销减小</li>
</ul>
</li>
</ul>
</li>
<li>线程属性：<ul>
<li>线程是处理机调度单位</li>
<li>多 CPU 计算机中，各个线程可以占用不同的 CPU<ul>
<li>（一般是一个进程占一个核。因为不同逻辑核心用的缓存是不同的，若一个进程同时用多个核，则数据调用会变得困难。但是考纲表明，一个进程可以占用多个核心，核心级线程是处理机分配的最小单位）</li>
</ul>
</li>
<li>每一个线程都有<strong>线程 ID、线程控制块（TCB）</strong></li>
<li>线程也有<strong>就绪、堵塞、运行</strong>三种基本状态</li>
<li>线程几乎不拥有系统资源</li>
<li>同一进程的不同线程<strong>共享进程的资源</strong></li>
<li>由于共享内存地址空间，同一线程中的线程间通信无需系统干预</li>
<li>同一进程中的线程切换，不会引起进程切换；不同进程中的线程切换，会引起进程切换。</li>
<li>切换同进程内的线程，系统开销很小；切换进程，系统的开销较大。</li>
</ul>
</li>
</ul>
<h3 id="线程的实现方式和多线程模型"><a href="#线程的实现方式和多线程模型" class="headerlink" title="线程的实现方式和多线程模型"></a>线程的实现方式和多线程模型</h3><p><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part2/image-20211102232120706.png" alt="image-20211102232120706"></p>
<ul>
<li><p>线程的实现方式</p>
<ul>
<li><strong>用户级线程</strong>（User-Level Thread, ULT）<ul>
<li>用户级线程<strong>由应用程序通过线程库实现</strong>，所有的线程管理工作都<strong>由应用程序负责</strong>（包括线程切换）</li>
<li>用户级线程中，线程切换可以<strong>在用户态下完成</strong>，无需操作系统干预。</li>
<li>在用户看来，是有多个线程。但是在操作系统内核看来，并意识不到线程的存在。</li>
<li>优点：用户级线程的切换在用户空间即可完成，不需要切换到核心态，线程管理的<strong>开销小，效率高</strong></li>
<li>缺点：当一个用户级线程被阻塞后，整个进程都会被阻塞，<strong>并发度不高</strong>。多个线程不可在多核处理机上并行运行。</li>
<li><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part2/image-20211103135106630.png" alt="image-20211103135106630" style="zoom:80%;"></li>
</ul>
</li>
<li><strong>内核级线程</strong>（Kernel-Level Thread, KLT，又称“内核支持的线程”）<ul>
<li>内核级线程的管理工作由操作系统内核完成。</li>
<li>线程调度、切换等工作都由内核负责，因此内核级线程的切换必然需要在核心态下才能完成。</li>
<li>操作系统会为每个内核级线程建立相应的 TCB（Thread Control Block，线程控制块），通过 TCB 对线程进行管理。“内核级线程”就是“从操作系统内核视角看能看到的线程”</li>
<li>优点：当一个线程被阻塞后，别的线程还可以继续执行，并发能力强。多线程可在多核处理机上并行执行。</li>
<li>缺点：一个用户进程会占用多个内核级线程，线程切换由操作系统内核完成，需要切换到核心态，因此线程管理的成本高，开销大。</li>
<li><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part2/image-20211103134402805.png" alt="image-20211103134402805" style="zoom:80%;">
</li>
</ul>
</li>
</ul>
</li>
<li><p>多线程模型</p>
<ul>
<li>一对一模型：（内核级线程）<ul>
<li><strong>一个用户级线程映射到一个内核级线程</strong>。每个用户进程有与用户级线程同数量的内核级线程。</li>
<li>优点：当一个线程被阻塞后，别的线程还可以继续执行，<strong>并发能力强</strong>。<strong>多线程可在多核处理机上并行执行</strong>。</li>
<li>缺点：<strong>一个用户进程会占用多个内核级线程</strong>，线程切换由操作系统内核完成，需要切换到核心态，因此<strong>线程管理的成本高，开销大</strong>。</li>
</ul>
</li>
<li>多对一模型：（用户级线程）<ul>
<li><strong>多个用户级线程映射到一个内核级线程</strong>。且<strong>一个进程只被分配一个内核级线程</strong>。</li>
<li>优点：用户级线程的切换在用户空间即可完成，不需要切换到核心态，线程管理的系统开销小，效率高</li>
<li>缺点：当一个用户级线程被阻塞后，整个进程都会被阻塞，<strong>并发度不高</strong>。多个线程不可在多核处理机上并行运行，因为只有这一个进程只有一个内核级线程。</li>
</ul>
</li>
<li>多对多模型：<ul>
<li>n 用户及线程映射到 m 个内核级线程（<strong>n&gt;=m</strong>）。每个用户进程对应 m 个内核级线程。</li>
<li>克服了多对一模型并发度不高的缺点（一个阻塞全体阻塞），又克服了一对一模型中一个用户进程占用太多内核级线程，开销太大的缺点。</li>
<li><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part2/image-20211103135439234.png" alt="image-20211103135439234" style="zoom:80%;">

</li>
</ul>
</li>
</ul>
<blockquote>
<ul>
<li>用户级线程是“代码逻辑”的载体</li>
<li>内核级线程是“运行机会”的载体</li>
<li>注意：<strong>内核级线程才是处理机分配的单位</strong>。</li>
</ul>
</blockquote>
</li>
</ul>
<h2 id="处理机调度"><a href="#处理机调度" class="headerlink" title="处理机调度"></a>处理机调度</h2><h3 id="调度的概念、层次"><a href="#调度的概念、层次" class="headerlink" title="调度的概念、层次"></a>调度的概念、层次</h3><p><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part2/image-20211103143657421.png" alt="image-20211103143657421"></p>
<ul>
<li><p>基本概念：确定某种规则来决定处理任务的顺序</p>
</li>
<li><p>三个层次</p>
<ul>
<li>高级调度（作业调度）<ul>
<li>作业：指一个具体的任务</li>
<li>用户向系统提交一个作业 ≈ 用户让操作系统启动一个程序（来处理一个具体的任务）</li>
<li>按一定的原则从<strong>外存</strong>的作业后备队列中挑选一个作业调入<strong>内存</strong>，并<strong>创建进程</strong>。</li>
<li>每个作业<strong>只调入一次</strong>，<strong>调出一次</strong>。作业调入时会建立 PCB，调出时才撤销 PCB。</li>
</ul>
</li>
<li>中级调度（内存调度）<ul>
<li>内存不够时，将某些进程的数据调出外存。等内存空闲或者进程需要运行时再重新调入内存。</li>
<li>暂时调到外存等待的进程状态为<strong>挂起状态</strong>（suspend）。被挂起的进程 PCB 会被组织成<strong>挂起队列</strong></li>
<li>一个进程可能会被<strong>多次调出、调入内存</strong>，因此<strong>中级调度发生的频率要比高级调度更高</strong>。</li>
</ul>
</li>
<li>低级调度（进程调度）<ul>
<li>从<strong>内存</strong>中的<strong>就绪队列</strong>中选取一个进程，将<strong>处理机</strong>分配给它。</li>
<li><strong>进程调度是操作系统中最基本的一种调度</strong>，在一般的操作系统中都必须配置进程调度。</li>
<li>进程调度的<strong>频率很高</strong>，一般几十毫秒一次。</li>
</ul>
</li>
</ul>
</li>
<li><p>补充</p>
<ul>
<li>进程的挂起态<ul>
<li>暂时调到<strong>外存</strong>等待的进程状态为挂起状态</li>
<li>挂起态又可以进一步细分为<strong>就绪挂起</strong>、<strong>阻塞挂起</strong>两种状态</li>
</ul>
</li>
<li>七状态模型<ul>
<li>注意：挂起和阻塞，两种状态都是暂时不能获得CPU的服务，但挂起态是<strong>将进程映像调到外存</strong>去了，而<strong>阻塞态下进程映像还在内存中</strong>。</li>
<li>有的操作系统会把就绪挂起、阻塞挂起分为两个挂起队列，甚至会根据阻塞原因不同再把阻塞挂起进程进一步细分为多个队列。</li>
<li><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part2/image-20211103142132494.png" alt="image-20211103142132494"></li>
</ul>
</li>
</ul>
</li>
<li><p>三个层次的联系、对比</p>
<ul>
<li><table>
<thead>
<tr>
<th></th>
<th>内容</th>
<th>发生位置</th>
<th>发生频率</th>
<th>进程状态</th>
</tr>
</thead>
<tbody><tr>
<td>（高级）作业调度</td>
<td>从后备队列选择以创建进程</td>
<td>外存 -&gt; 内存（面向作业）</td>
<td>最低</td>
<td>无 -&gt; 创建态 -&gt; 就绪态</td>
</tr>
<tr>
<td>（中级）内存调度</td>
<td>从挂起队列选择以调回内存</td>
<td>外存 -&gt; 内存（面向进程）</td>
<td>中等</td>
<td>挂起态 -&gt; 就绪态</td>
</tr>
<tr>
<td>（低级）进程调度</td>
<td>从就绪队列选择以分配 CPU</td>
<td>内存 -&gt; CPU</td>
<td>最高</td>
<td>就绪态 -&gt; 运行态</td>
</tr>
</tbody></table>
</li>
</ul>
</li>
</ul>
<h3 id="进程调度的时机、切换与过程、方式"><a href="#进程调度的时机、切换与过程、方式" class="headerlink" title="进程调度的时机、切换与过程、方式"></a>进程调度的时机、切换与过程、方式</h3><p><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part2/image-20211103143931197.png" alt="image-20211103143931197"></p>
<ul>
<li><strong>进程调度的时机</strong><ul>
<li>进程调度（低级调度），就是按照某种算法从就绪队列中选择一个进程为其分配处理机。</li>
<li><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part2/image-20211103144051040.png" alt="image-20211103144051040"></li>
<li><strong>需要</strong>进行进程调度与切换的情况<ul>
<li>当前进程<strong>主动</strong>放弃处理机<ul>
<li>进程正常终止</li>
<li>发生异常而终止</li>
<li>进程主动请求阻塞（如 等待I/O）</li>
</ul>
</li>
<li>当前进程<strong>被动</strong>放弃处理机<ul>
<li>分给进程的时间片用完</li>
<li>有更紧急的事需要处理（如 I/O中断）</li>
<li>有更高优先级的进程进入就绪队列</li>
</ul>
</li>
</ul>
</li>
<li><strong>不能</strong>进行进程调度与切换的情况<ul>
<li>在<strong>处理中断的过程中</strong>。中断处理过程复杂，与硬件密切相关，很难做到在中断处理过程中进行进程切换。</li>
<li>进程在<strong>操作系统内核程序临界区中</strong>。但是进程在普通临界区中是可以进行调度、切换的。</li>
<li>在<strong>原子操作过程中</strong>（原语）。原子操作不可中断。（如修改 PCB 中进程状态标志，并把 PCB 放到相应队列）</li>
</ul>
</li>
<li>真题案例：<ul>
<li>进程在<strong>操作系统内核程序临界区</strong>中<strong>不能</strong>进行调度与切换。<strong>对</strong></li>
<li>（2012年联考真题）进程处于<strong>临界区</strong>时<strong>不能</strong>进行处理机调度。<strong>错</strong></li>
<li>临界资源：<strong>一个时间段内只允许一个进程使用的资源</strong>。各进程需要互斥地访问临界资源。</li>
<li>临界区：访问临界资源的那段代码。</li>
<li><strong>内核程序临界区</strong>一般是用来访问<strong>某种内核数据结构</strong>的，比如进程的就绪队列（由各就绪进程的 PCB 组成）<ul>
<li>进程还未退出临界区时，临界资源（就绪队列）则一直处于上锁状态，则其他进程调度相关的程序就会被阻塞。</li>
<li>内核程序临界区访问的临界资源如果不尽快释放，极有可能影响到操作系统内核的其他管理工作。因此<strong>在访问内核程序临界区期间不能进行调度和切换</strong>。</li>
</ul>
</li>
<li>普通临界区<ul>
<li>在打印机打印完成之前，进程一直处于临界区内，临界资源（打印机）不会解锁。但打印机是慢速设备，如果不允许进程调度则会导致 CPU 一直空闲</li>
<li>普通临界区资源（如打印机）不会影响到操作系统内核的管理工作。因此<strong>在访问普通临界区资源时可以进行调度与切换</strong>。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><strong>进程调度的方式</strong><ul>
<li><strong>非剥夺调度方式</strong>，又称<strong>非抢占方式</strong>。即，只允许进程主动放弃处理机。在运行过程中即便有更紧迫的任务到达，当前进程依然会继续使用处理机，直到该进程终止或主动要求进入阻塞态。<ul>
<li>实现简单，系统开销小但是无法及时处理紧急任务，适合于<strong>早期的批处理系统</strong></li>
</ul>
</li>
<li><strong>剥夺调度方式</strong>，又称<strong>抢占方式</strong>。当一个进程正在处理机上执行时，如果有一个更重要或更紧迫的进程需要使用处理机，则立即暂停正在执行的进程，将处理机分配给更重要紧迫的那个进程。<ul>
<li>可以优先处理更紧急的进程，也可实现让各进程按时间片轮流执行的功能（通过时钟中断）。适合于<strong>分时操作系统、实时操作系统</strong></li>
</ul>
</li>
</ul>
</li>
<li><strong>进程的切换与过程</strong><ul>
<li><strong>进程调度</strong>与<strong>进程切换</strong>的区别：<ul>
<li><strong>狭义的进程调度</strong>，指的是从就绪队列中选中一个要运行的进程。（这个进程可以是刚刚被暂停执行的进程，也可能是另一个进程，后一种情况就需要进程切换）</li>
<li><strong>进程切换</strong>，指一个进程让出处理机，由另一个进程占用处理机的过程。</li>
<li><strong>广义的进程调度</strong>，包含了选择一个进程和进程切换两个步骤</li>
</ul>
</li>
<li>进程切换的过程主要完成了：<ul>
<li>对原来运行进程各种数据的保存</li>
<li>对新的进程各种数据的恢复</li>
</ul>
</li>
<li><strong>进程切换是有代价的</strong>，因此如果过于频繁的进行进程调度、切换，必然会使整个系统的效率降低，使系统大部分时间都花在了进程切换上，而真正用于执行进程的时间减少。</li>
</ul>
</li>
</ul>
<h3 id="调度算法的评价指标"><a href="#调度算法的评价指标" class="headerlink" title="调度算法的评价指标"></a>调度算法的评价指标</h3><p><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part2/image-20211103220000158.png" alt="image-20211103220000158"></p>
<ul>
<li><strong>CPU 利用率</strong>：指 CPU 忙碌的时间占总时间的比例。</li>
<li><strong>系统吞吐量</strong>：单位时间内完成作业的数量</li>
<li>周转时间<ul>
<li><strong>周转时间</strong>，指从作业被提交给系统开始，到作业完成为止的时间。<ul>
<li>包括四个部分：作业<strong>在外存后备队列上等待作业调度（高级调度）</strong>的时间、进程<strong>在就绪队列上等待进程调度（低级调度）</strong>的时间、进程<strong>在CPU上执行的时间</strong>、进程<strong>等待 I/O 操作完成的时间</strong>。后三项在一个作业的整个处理过程中，可能发生多次。</li>
</ul>
</li>
<li><strong>带权周转时间</strong>必然 ≥ 1</li>
<li>带权周转时间与周转时间都是越小越好</li>
</ul>
</li>
<li><strong>等待时间</strong><ul>
<li>等待时间，指进程/作业<strong>处于等待处理机状态时间之和</strong>，等待时间越长，用户满意度越低。</li>
<li>对于进程来说，等待时间就是指进程建立后<strong>等待被服务的时间之和</strong>，在等待I/O完成的期间其实进程也是在被服务的，所以不计入等待时间。</li>
<li>对于作业来说，不仅要考虑<strong>建立进程后的等待时间</strong>，还要加上<strong>作业在外存后备队列中等待的时间</strong>。</li>
</ul>
</li>
<li><strong>响应时间</strong>：指从用户提交请求到首次产生响应所用的时间。</li>
</ul>
<h3 id="调度算法"><a href="#调度算法" class="headerlink" title="调度算法"></a>调度算法</h3><ul>
<li>各种调度算法的学习思路<ol>
<li>算法思想</li>
<li>算法规则</li>
<li>作业调度 or 进程调度</li>
<li>抢占式 or 非抢占式</li>
<li>优点 and 缺点</li>
<li>是否会导致饥饿/饿死</li>
</ol>
</li>
<li>FCFS、SJF/SPF、HRRN 适合用于早期的批处理系统；时间片轮转、优先级调度、多级反馈队列适合用于交互式系统</li>
</ul>
<h4 id="先来先服务"><a href="#先来先服务" class="headerlink" title="先来先服务"></a>先来先服务</h4><ul>
<li>先来先服务（FCFS, First Come First Serve）<ul>
<li>算法思想：主要从“公平”的角度考虑</li>
<li>算法规则：按照<strong>到达的先后顺序</strong>进行服务</li>
<li>调度对象：用于作业调度时，考虑的是哪个作业先到达<strong>后备队列</strong>；用于进程调度时，考虑的是哪个进程先到达<strong>就绪队列</strong></li>
<li>是否抢占：非抢占式</li>
<li>优点：公平、算法实现简单</li>
<li>缺点：<ul>
<li><strong>带权周转时间很大</strong>。</li>
<li>公平</li>
<li><strong>对长作业有利，对短作业不利</strong>。</li>
</ul>
</li>
<li>是否会导致饥饿/饿死：不会</li>
</ul>
</li>
</ul>
<p><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part2/image-20211104135659417.png" alt="image-20211104135659417"></p>
<h4 id="最短作业优先"><a href="#最短作业优先" class="headerlink" title="最短作业优先"></a>最短作业优先</h4><ul>
<li><p>短作业优先（SJF, Shortest Job First）</p>
<ul>
<li>算法思想：追求最少的<strong>平均等待时间</strong>、<strong>平均周转时间</strong>、<strong>平均带权周转时间</strong></li>
<li>算法规则：<strong>要求服务时间最短</strong>的作业/进程优先得到服务</li>
<li>调度对象：作业/进程调度皆可。用于进程调度称为，短进程优先算法（SPF, Shortest Process First）</li>
<li>是否抢占：SJF 和 SPF 是非抢占式的算法。但是也有抢占式的版本——最短剩余时间优先算法（SRTN, Shortest Remaining Time Next）<ul>
<li>SJF：仅在每次调度时选择当前<strong>已到达且运行时间最短</strong>的作业/进程。</li>
<li>SRTN：每当有进程加入<strong>就绪队列改变时就需要调度</strong>，如果新到达的进程<strong>剩余时间</strong>比当前运行的进程剩余时间<strong>更短</strong>，则由新进程<strong>抢占</strong>处理机，当前运行进程重新回到就绪队列。另外，当一个进程完成时也需要调度。</li>
</ul>
</li>
<li>优点：“最短的”平均等待时间、平均周转时间</li>
<li>缺点：<ul>
<li>不公平。</li>
<li><strong>对短作业有利，对长作业不利</strong>。</li>
<li>可能产生饥饿现象。</li>
<li>作业/进程的运行时间是由用户提供的，并不一定真实，不一定能做到真正的短作业优先</li>
</ul>
</li>
<li>是否会导致饥饿/饿死：会</li>
</ul>
</li>
<li><p>注意：</p>
<ul>
<li>如果题目中未特别说明，所提到的“短作业/进程优先算法”默认是<strong>非抢占式</strong>的</li>
<li>“SJF 调度算法的平均等待时间、平均周转时间最少”，严格来说，这个表述是错误的，不严谨的。<ul>
<li>在<strong>所有进程同时可运行</strong>时，采用 SJF 调度算法的平均等待时间、平均周转时间最少</li>
<li>在<strong>所有进程都几乎同时到达</strong>时，采用 SJF 调度算法的平均等待时间、平均周转时间最少</li>
<li><strong>抢占式的</strong>短作业/进程优先调度算法（<strong>最短剩余时间优先</strong>，SRNT算法）的平均等待时间、平均周转时间最少</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part2/image-20211104135754210.png" alt="image-20211104135754210"></p>
<p><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part2/image-20211104135848421.png" alt="image-20211104135848421"></p>
<h4 id="最高响应比优先"><a href="#最高响应比优先" class="headerlink" title="最高响应比优先"></a>最高响应比优先</h4><ul>
<li>高响应比优先（HRRN, Highest Response Ratio Next）<ul>
<li>算法思想：综合考虑作业/进程的等待时间和要求服务的时间</li>
<li>算法规则：在每次调度时先<strong>计算各个作业/进程的响应比，选择响应比最高</strong>的作业/进程为其服务<ul>
<li><strong>响应比 =（等待时间+要求服务时间）/ 要求服务时间</strong></li>
</ul>
</li>
<li>调度对象：即可用于作业调度，也可用于进程调度</li>
<li>是否抢占：非抢占式</li>
<li>优缺点：<ul>
<li>综合考虑了等待时间和运行时间（要求服务时间）</li>
<li>等待时间相同时，要求服务时间短的优先（SJF 的优点）</li>
<li>要求服务时间相同时，等待时间长的优先（FCFS 的优点）</li>
<li>对于长作业来说，随着等待时间越来越久，其响应比也会越来越大，从而避免了长作业饥饿的问题</li>
</ul>
</li>
<li>是否会导致饥饿/饿死：不会</li>
</ul>
</li>
</ul>
<p><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part2/image-20211104135933630.png" alt="image-20211104135933630"></p>
<h4 id="时间片轮转"><a href="#时间片轮转" class="headerlink" title="时间片轮转"></a>时间片轮转</h4><ul>
<li>时间片轮转（RR，Round-Robin）<ul>
<li>算法思想：公平地、轮流地为各个进程服务，让每个进程在一定时间间隔内都可以得到响应</li>
<li>算法规则：按照各进程到达就绪队列的顺序，轮流让各个进程执行一个时间片。若进程未在一个时间片内执行完，则剥夺处理机，将进程重新放到就绪队列队尾重新排队。</li>
<li>调度对象：进程调度（只有作业放入内存建立了相应的进程后，才能被分配处理机时间片）</li>
<li>是否抢占：<strong>抢占式</strong>。由时钟装置发出<strong>时钟中断</strong>来通知 CPU 时间片已到</li>
<li>优点：公平；响应快，适用于分时操作系统；</li>
<li>缺点：由于高频率的进程切换，因此有一定开销；不区分任务的紧急程度。</li>
<li>是否会导致饥饿/饿死：不会</li>
</ul>
</li>
<li>注意：<ul>
<li>当同时有进程 a <strong>下处理机</strong>、有进程 b <strong>到达</strong>，则默认新到达的进程先进入就绪队列</li>
<li>进程主动放弃处理机，则<strong>立刻调度下一个进程上处理机</strong>，并且<strong>不影响下一个进程的时间片周期</strong></li>
<li>通常，设计时间片要让切换进程的开销占比不超过 1%<ul>
<li>时间片不能太大：否则，将使得每个进程都可以在一个时间片内就完成，则时间片轮转调度算法<strong>退化为先来先服务调度算法</strong>，并且会<strong>增大进程响应时间</strong>。</li>
<li>时间片不能太小：否则会导致<strong>进程切换过于频繁</strong>，而进程调度、切换都有时间代价（保存、恢复运行环境）。</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part2/image-20211104150056927.png" alt="image-20211104150056927"></p>
<h4 id="优先级调度"><a href="#优先级调度" class="headerlink" title="优先级调度"></a>优先级调度</h4><ul>
<li>优先级调度算法<ul>
<li>算法思想：根据任务的紧急程度来决定处理顺序</li>
<li>算法规则：每个作业/进程有各自的优先级，调度时选择优先级最高的</li>
<li>调度对象：作业、进程、I/O 调度</li>
<li>是否抢占：抢占式、非抢占式都有。<ul>
<li>非抢占式只需在进程主动放弃处理机时进行调度即可</li>
<li>抢占式另外还需在就绪队列变化时，检查是否会发生抢占</li>
</ul>
</li>
<li>优点：<ul>
<li>用优先级区分紧急程度、重要程度，适用于实时操作系统。</li>
<li>可灵活地调整对各种作业/进程的偏好程度。</li>
</ul>
</li>
<li>缺点：若源源不断地有高优先级进程到来，则可能导致饥饿</li>
<li>是否会导致饥饿/饿死：会</li>
</ul>
</li>
<li>注意：<ul>
<li>优先数要按照题意判断：优先数<strong>越大（或者越小）</strong>，优先级越高</li>
<li>根据优先级是否可以动态改变，有两种分类<ul>
<li><strong>静态优先级</strong>：创建进程时确定，之后一直不变。</li>
<li><strong>动态优先级</strong>：创建进程时有一个初始值，之后会根据情况动态地调整优先级。</li>
</ul>
</li>
<li>通常：<ul>
<li>系统进程优先级<strong>高于</strong>用户进程</li>
<li>前台进程优先级<strong>高于</strong>后台进程</li>
<li>操作系统更<strong>偏好 I/O 型进程（I/O 繁忙型进程）</strong><ul>
<li>相对的是计算型进程（CPU 繁忙型进程）</li>
</ul>
</li>
</ul>
</li>
<li>动态优先级调整策略<ul>
<li>如果某进程在就绪队列中<strong>等待了很长时间</strong>，则可以适当提升其优先级</li>
<li>如果某进程<strong>占用处理机运行了很长时间</strong>，则可适当降低其优先级</li>
<li>如果发现一个进程频<strong>繁地进行 I/O 操作</strong>，则可适当提升其优先级</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part2/image-20211104150805430.png" alt="image-20211104150805430"></p>
<p><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part2/image-20211104150844950.png" alt="image-20211104150844950"></p>
<h4 id="多级反馈队列"><a href="#多级反馈队列" class="headerlink" title="多级反馈队列"></a>多级反馈队列</h4><ul>
<li><ul>
<li>算法思想：对其他调度算法的折中权衡</li>
<li>算法规则：<ul>
<li>设置多级就绪队列，<strong>各级队列优先级从高到低</strong>，<strong>时间片从小到大</strong></li>
<li>新进程到达时先进入第 1 级队列，按 FCFS 原则排队等待被分配时间片。若用完时间片进程还未结束，则进入下一级队列队尾。如果已经在最下级队列，则重新放回该级队列队尾</li>
<li>被抢占处理机的进程重新放回原队列队尾</li>
<li>只有第 k 级队列为空时，才会为 k+1 级队头的进程分配时间片。</li>
</ul>
</li>
<li>调度对象：进程调度</li>
<li>是否抢占：抢占式</li>
<li>优缺点：<ul>
<li>对各类型进程相对公平（FCFS的优点）</li>
<li>每个新到达的进程都可以很快就得到响应（RR的优点）</li>
<li>短进程只用较少的时间就可完成（SPF的优点）</li>
<li>不必实现估计进程的运行时间（避免用户作假）；</li>
<li>可灵活地调整对各类进程的偏好程度，比如 CPU 密集型进程、I/O 密集型进程（拓展：可以将因 I/O 而阻塞的进程重新放回原队列，这样 I/O 型进程就可以保持较高优先级）</li>
</ul>
</li>
<li>是否会导致饥饿/饿死：会</li>
</ul>
</li>
</ul>
<p><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part2/image-20211104151749404.png" alt="image-20211104151749404"></p>
<h2 id="进程同步"><a href="#进程同步" class="headerlink" title="进程同步"></a>进程同步</h2><h3 id="进程同步、进程互斥"><a href="#进程同步、进程互斥" class="headerlink" title="进程同步、进程互斥"></a>进程同步、进程互斥</h3><p><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part2/image-20211104162619267.png" alt="image-20211104162619267"></p>
<ul>
<li>进程同步<ul>
<li>针对问题：进程具有异步性的特征。各并发执行的进程以<strong>各自独立的、不可预知的</strong>速度向前推进。</li>
<li><strong>同步</strong>亦称<strong>直接制约关系</strong>。指为了完成某种任务而建立的多个进程，因为需要在某些位置上<strong>协调工作次序</strong>而产生的制约关系。</li>
</ul>
</li>
<li>进程互斥<ul>
<li>针对问题：<strong>一个时间段内只允许一个进程使用</strong>的资源称为临界资源。</li>
<li><strong>互斥</strong>，亦称<strong>间接制约关系</strong>。指当一个进程访问临界资源时，另一个想要访问该临界资源的进程必须等待，直到临界资源被释放</li>
<li><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part2/image-20211104162337247.png" alt="image-20211104162337247"></li>
<li>注意：<ul>
<li><strong>临界区</strong>是进程中<strong>访问临界资源</strong>的代码段。</li>
<li><strong>进入区</strong>和<strong>退出区</strong>是<strong>负责实现互斥</strong>的代码段。</li>
<li>临界区也可称为“临界段”。</li>
</ul>
</li>
<li><strong>四个原则</strong>：（为了实现对临界资源的互斥访问，同时保证系统整体性能）<ol>
<li>空闲让进。临界区空闲时，可以允许一个请求进入临界区的进程立即进入临界区；</li>
<li>忙则等待。当已有进程进入临界区时，其他试图进入临界区的进程必须等待；</li>
<li>有限等待。对请求访问的进程，应保证能在有限时间内进入临界区（保证不会饥饿）；</li>
<li>让权等待。当进程不能进入临界区时，应立即释放处理机，防止进程忙等待。</li>
</ol>
</li>
</ul>
</li>
</ul>
<h3 id="进程互斥的软件实现方法（高频）"><a href="#进程互斥的软件实现方法（高频）" class="headerlink" title="进程互斥的软件实现方法（高频）"></a>进程互斥的软件实现方法（高频）</h3><p><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part2/image-20211104165325471.png" alt="image-20211104165325471"></p>
<ul>
<li>单标志法<ul>
<li>算法思想：两个进程在<strong>访问完临界区后</strong>会把使用临界区的权限转交给另一个进程。即，<strong>每个进程进入临界区的权限只能被另一个进程赋予</strong></li>
<li>主要问题：违背“<strong>空闲让进</strong>”原则。</li>
<li><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part2/image-20211104202433915.png" alt="image-20211104202433915"></li>
</ul>
</li>
<li>双标志先检查<ul>
<li>算法思想：设置一个布尔型数组，用来<strong>标记各进程想进入临界区的意愿</strong></li>
<li>主要问题：违反“<strong>忙则等待</strong>”原则。</li>
<li>问题原因：<strong>检查</strong>与<strong>上锁</strong>之间可能发生进程切换。</li>
<li><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part2/image-20211104203017349.png" alt="image-20211104203017349"></li>
</ul>
</li>
<li>双标志后检查<ul>
<li>算法思想：先“上锁”后“检查”</li>
<li>主要问题：违背了“<strong>空闲让进</strong>”和“<strong>有限等待</strong>”原则，会产生“<strong>饥饿</strong>”现象。</li>
<li><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part2/image-20211104202926919.png" alt="image-20211104202926919"></li>
</ul>
</li>
<li>Peterson 算法<ul>
<li>算法思想：结合双标志法（争取）、单标志法（谦让）的思想。<strong>主动争取、主动谦让、检查</strong>。</li>
<li>主要问题：未遵循“<strong>让权等待</strong>”原则</li>
<li><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part2/image-20211104203638733.png" alt="image-20211104203638733"></li>
</ul>
</li>
</ul>
<h3 id="进程互斥的硬件实现方法"><a href="#进程互斥的硬件实现方法" class="headerlink" title="进程互斥的硬件实现方法"></a>进程互斥的硬件实现方法</h3><p><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part2/image-20211104204033279.png" alt="image-20211104204033279"></p>
<ul>
<li>中断屏蔽方法<ul>
<li>利用“开/关中断指令”实现</li>
<li>优点：<strong>简单、高效</strong></li>
<li>缺点：<ul>
<li><strong>不适用于多处理机</strong>。A 核执行了关中断，不影响 B 核使用相同的临界区。</li>
<li>只适用于操作系统内核进程，不适用于用户进程（<strong>开/关中断指令只能运行在内核态</strong>）</li>
</ul>
</li>
</ul>
</li>
<li>TestAndSet 指令<ul>
<li>TS 指令，也称 TestAndSetLock（TSL）指令</li>
<li>TSL 指令是用<strong>硬件实现</strong>的，执行的过程不允许被中断</li>
<li><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part2/image-20211105121953825.png" alt="image-20211105121953825"></li>
<li>优点：<ul>
<li>实现简单，无需像软件实现方法那样严格检查是否会有逻辑漏洞</li>
<li>适用于多处理机环境</li>
</ul>
</li>
<li>缺点：不满足“让权等待”原则，暂时无法进入临界区的进程会占用 CPU 并循环执行TSL指令。</li>
</ul>
</li>
<li>Swap 指令<ul>
<li>也称 Exchange（XCHG）指令</li>
<li>Swap 指令是用<strong>硬件实现</strong>的，执行的过程不允许被中断</li>
<li><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part2/image-20211105122231302.png" alt="image-20211105122231302"></li>
<li>优缺点：同 TestAndSet 指令</li>
</ul>
</li>
</ul>
<h3 id="信号量机制"><a href="#信号量机制" class="headerlink" title="信号量机制"></a>信号量机制</h3><p><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part2/image-20211105124116186.png" alt="image-20211105124116186"></p>
<ul>
<li>基本概念：<ul>
<li>用户进程可以通过使用操作系统提供的<strong>一对原语</strong>来对<strong>信号量</strong>进行操作，从而很方便的实现了进程互斥、进程同步。</li>
<li>信号量其实就是一个变量，用来<strong>表示系统中某种资源的数量</strong>。</li>
<li>原语是一种特殊的程序段，其<strong>执行只能一气呵成，不可被中断</strong>。</li>
<li>一对原语：<strong>wait(S) 原语</strong>和 <strong>signal(S) 原语</strong>，S 为信号量</li>
<li>wait、signal 原语常简称为 P、V 操作（来自荷兰语 proberen 和 verhogen），即 <strong>P(S)、V(S)</strong></li>
</ul>
</li>
<li>整型信号量<ul>
<li>用一个<strong>整数型的变量</strong>作为信号量。<ul>
<li>与普通整数变量的区别：对信号量的操作只有三种，初始化、P 操作、V 操作</li>
</ul>
</li>
<li>其实和 TS 指令差不多</li>
<li><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part2/image-20211105124727576.png" alt="image-20211105124727576" style="zoom: 75%;"></li>
<li>问题：<strong>不满足“让权等待”</strong></li>
</ul>
</li>
<li>记录型信号量<ul>
<li>用记录型数据结构表示的信号量。<ul>
<li>如果剩余资源数不足，使用 <strong>block 原语</strong>使进程<strong>从运行态进入阻塞态</strong>，并把挂到信号量 S 的等待队列（阻塞队列）中</li>
<li>释放资源后，若还有别的进程在等待这种资源，则使用 <strong>wakeup 原语</strong>唤醒等待队列中的一个进程，该进程<strong>从阻塞态变为就绪态</strong></li>
</ul>
</li>
<li><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part2/image-20211105125223262.png" alt="image-20211105125223262" style="zoom:80%;"></li>
<li>P(S)、V(S) 实现系统资源的“<strong>申请</strong>”和“<strong>释放</strong>”。</li>
<li><strong>S.value 的初值</strong>表示系统中<strong>某种资源的数目</strong>。</li>
<li>P 操作：<ul>
<li>对信号量 S 的<strong>一次 P 操作</strong>意味着进程<strong>请求一个单位的该类资源</strong>，因此需要执行 S.value–，表示资源数减 1。</li>
<li>当 S.value &lt; 0 时表示该类资源已分配完毕，因此进程应调用 block 原语进行自我阻塞（**当前运行的进程从运行态 -&gt; 阻塞态<strong>），</strong>主动放弃处理机<strong>，并</strong>插入该类资源的等待队列 S.L 中**。</li>
<li>可见，该机制<strong>遵循了“让权等待”原则</strong>，不会出现“忙等”现象。</li>
</ul>
</li>
<li>V 操作：<ul>
<li>对信号量 S 的<strong>一次 V 操作</strong>意味着进程<strong>释放一个单位的该类资源</strong>，因此需要执行 S.value++，表示资源数加 1。</li>
<li>若加 1 后仍是 S.value &lt;= 0，表示依然有进程在等待该类资源，因此应**调用 wakeup 原语**唤醒等待队列中的第一个进程（**被唤醒进程从阻塞态 -&gt; 就绪态**）。</li>
</ul>
</li>
</ul>
</li>
</ul>
<blockquote>
<p>信号量的值 = 这种资源的剩余数量</p>
<p>P( S ) —— 申请一个资源 S，如果资源不够就阻塞等待</p>
<p>V( S ) —— 释放一个资源 S，如果有进程在等待该资源，则唤醒一个进程</p>
</blockquote>
<h3 id="信号量实现进程互斥、同步、前驱关系"><a href="#信号量实现进程互斥、同步、前驱关系" class="headerlink" title="信号量实现进程互斥、同步、前驱关系"></a>信号量实现进程互斥、同步、前驱关系</h3><p><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part2/image-20211105131735276.png" alt="image-20211105131735276"></p>
<ul>
<li>实现进程互斥<ul>
<li>过程：<ul>
<li>分析并发进程的关键活动，划定临界区</li>
<li>设置互斥信号量 mutex，<strong>初值为 1</strong></li>
<li><strong>在进入区 P(mutex)——申请资源</strong></li>
<li><strong>在退出区 V(mutex)——释放资源</strong></li>
<li><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part2/image-20211105144434351.png" alt="image-20211105144434351" style="zoom:80%;"></li>
</ul>
</li>
<li>注意：<ul>
<li>对不同的临界资源需要设置不同的互斥信号量。 </li>
<li>P、V 操作必须成对出现。缺少 P(mutex) 就不能保证临界资源的互斥访问。缺少 V(mutex) 会导致资源永不被释放，等待进程永不被唤醒。</li>
</ul>
</li>
</ul>
</li>
<li>实现进程同步<ul>
<li>过程：<ul>
<li>分析什么地方需要实现“同步关系”，即必须保证“一前一后”执行的两个操作</li>
<li>设置同步信号量 S，<strong>初始为 0</strong></li>
<li><strong>在“前操作”之后执行 V(S)</strong></li>
<li><strong>在“后操作”之前执行 P(S)</strong><ul>
<li>信号量 S 代表“某种资源”，刚开始是没有这种资源的。P2 需要使用这种资源，而又只能由 P1 产生这种资源</li>
<li><strong>前 V 后 P</strong></li>
</ul>
</li>
<li><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part2/image-20211105144750166.png" alt="image-20211105144750166" style="zoom:80%;"></li>
</ul>
</li>
</ul>
</li>
<li>实现前驱关系<ul>
<li>过程<ul>
<li>为<strong>每一对前驱关系</strong>各设置一个同步信号量</li>
<li>在“前操作”之后对相应的同步信号量执行 V 操作</li>
<li>在“后操作”之前对相应的同步信号量执行 P 操作</li>
<li><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part2/image-20211105145022913.png" alt="image-20211105145022913" style="zoom:80%;"></li>
</ul>
</li>
<li>前驱关系问题，<strong>本质上就是多级同步问题</strong>。</li>
</ul>
</li>
</ul>
<h3 id="生产者-消费者问题"><a href="#生产者-消费者问题" class="headerlink" title="生产者-消费者问题"></a>生产者-消费者问题</h3><ul>
<li>问题描述：系统中有一组生产者进程和一组消费者进程，生产者进程每次生产一个产品放入缓冲区，消费者进程每次从缓冲区中取出一个产品并使用。生产者、消费者共享一个初始为空、大小为 n 的缓冲区。</li>
<li>问题分析：<ul>
<li>只有<strong>缓冲区没满</strong>时，生产者才能把产品放入缓冲区，否则必须等待。——同步</li>
<li>只有<strong>缓冲区不空</strong>时，消费者才能从中取出产品，否则必须等待。——同步</li>
<li>缓冲区是临界资源，各进程必须<strong>互斥</strong>地访问。——互斥</li>
</ul>
</li>
<li>算法实现：<ul>
<li><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part2/image-20211105173157993.png" alt="image-20211105173157993"></li>
</ul>
</li>
<li>注意：<ul>
<li><strong>实现互斥的 P 操作一定要在实现同步的 P 操作之后</strong>。</li>
<li>V 操作不会导致进程阻塞，因此<strong>两个 V 操作顺序可以交换</strong>。</li>
<li>生产产品与使用产品可以放在 P、V 中间，但是这样会使得临界区代码变长</li>
<li>有时候是<strong>消费者需要等待生产者生产</strong>，有时候是<strong>生产者要等待消费者消费</strong>，这是两个不同的“一前一后问题”。因此，题目<strong>隐含两对同步关系</strong>，也需要<strong>设置两个同步信号量</strong>。</li>
</ul>
</li>
</ul>
<h3 id="多生产者-多消费者"><a href="#多生产者-多消费者" class="headerlink" title="多生产者-多消费者"></a>多生产者-多消费者</h3><ul>
<li>问题描述：桌子上有一只盘子，每次只能向其中放入一个水果。爸爸专向盘子中放苹果，妈妈专向盘子中放橘子，儿子专等着吃盘子中的橘子，女儿专等着吃盘子中的苹果。只有盘子空时，爸爸或妈妈才可向盘子中放一个水果。仅当盘子中有自己需要的水果时，儿子或女儿可以从盘子中取出水果。</li>
<li>问题分析：<ul>
<li>对缓冲区（盘子）的访问要互斥地进行。——互斥</li>
<li>父亲将苹果放入盘子后，女儿才能取苹果。——同步</li>
<li>母亲将橘子放入盘子后，儿子才能取橘子。——同步</li>
<li>只有<strong>盘子为空</strong>时，<strong>父亲或母亲</strong>才能放入水果。——同步<ul>
<li>“盘子为空”这个事件可以由儿子或女儿触发。</li>
</ul>
</li>
</ul>
</li>
<li>算法实现<ul>
<li><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part2/image-20211105175350546.png" alt="image-20211105175350546"></li>
</ul>
</li>
<li>注意：<ul>
<li>当缓冲区容量为 1 时，则<strong>可能</strong>不设置专门的互斥变量 mutex，也不会出现多个进程同时访问盘子的现象。具体情况具体分析</li>
<li>如果来不及仔细分析，完全可以加上互斥信号量，以保证各进程一定会互斥地访问缓冲区。<strong>互斥的 P 一定要在同步 P 之后</strong>。</li>
</ul>
</li>
</ul>
<blockquote>
<p>解决“多生产者-多消费者问题”的关键在于理清复杂的同步关系。</p>
<p>在分析同步问题（一前一后问题）的时候<strong>不能从单个进程行为</strong>的角度来分析，要把“一前一后”发生的事看做是两种“<strong>事件</strong>”的前后关系。</p>
<ul>
<li>如果从单个进程行为的角度来考虑的话，我们会有以下结论：<ul>
<li>如果盘子里装有苹果，那么一定要女儿取走苹果后父亲或母亲才能再放入水果</li>
<li>如果盘子里装有橘子，那么一定要儿子取走橘子后父亲或母亲才能再放入水果</li>
<li>意味着要设置四个同步信号量分别实现这四个“一前一后”的关系？</li>
</ul>
</li>
<li>正确的分析方法应该从“事件”（面向过程）的角度来考虑，我们可以把上述四对“进程行为的前后关系”抽象为一对“事件的前后关系”<ul>
<li>盘子变空事件 -&gt; 放入水果事件。</li>
<li>“盘子变空事件”既可由儿子（进程）引发，也可由女儿（进程）引发；“放水果事件”既可能是父亲（进程）执行，也可能是母亲（进程）执行。</li>
<li>这样的话，就可以用一个同步信号量解决问题了</li>
</ul>
</li>
</ul>
</blockquote>
<h3 id="吸烟者问题"><a href="#吸烟者问题" class="headerlink" title="吸烟者问题"></a>吸烟者问题</h3><ul>
<li>问题描述：假设一个系统有<strong>三个抽烟者进程</strong>和<strong>一个供应者进程</strong>。每个抽烟者不停地卷烟并抽掉它，但是要卷起并抽掉一支烟，抽烟者需要有三种材料：烟草、纸和胶水。三个抽烟者中，<strong>第一个拥有烟草、第二个拥有纸、第三个拥有胶水</strong>。供应者进程无限地提供三种材料，供应者每次将两种材料放桌子上，<strong>拥有剩下那种材料的抽烟者卷一根烟并抽掉它，并给供应者进程一个信号告诉完成了</strong>，供应者就会放另外两种材料再桌上，这个过程一直重复（<strong>让三个抽烟者轮流地抽烟</strong>）</li>
<li>问题分析：<ul>
<li>也属于“生产者-消费者”问题，更详细的说应该是“可生产多种产品的单生产者-多消费者”。</li>
<li>缓冲区大小为 1，每个吸烟者其实需要的是<strong>一个“组合”</strong>，且<strong>可以不设置互斥信号量</strong></li>
<li><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part2/image-20211105194323459.png" alt="image-20211105194323459"></li>
</ul>
</li>
<li>算法实现：<ul>
<li><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part2/image-20211105194941823.png" alt="image-20211105194941823"></li>
</ul>
</li>
</ul>
<h3 id="读者-写者问题"><a href="#读者-写者问题" class="headerlink" title="读者-写者问题"></a>读者-写者问题</h3><ul>
<li>问题描述：<ul>
<li>有读者和写者两组并发进程，共享一个文件，当两个或两个以上的读进程同时访问共享数据时不会产生副作用，但若某个写进程和其他进程（读进程或写进程）同时访问共享数据时则可能导致数据不一致的错误。</li>
<li>因此要求：①<strong>允许多个读者可以同时对文件执行读操作</strong>；②<strong>只允许一个写者往文件中写信息</strong>；③<strong>任一写者在完成写操作之前不允许其他读者或写者工作</strong>；④<strong>写者执行写操作前，应让已有的读者和写者全部退出</strong>。</li>
</ul>
</li>
<li>问题分析：<ul>
<li>两类进程：写进程、读进程</li>
<li>互斥关系：写进程—写进程、写进程—读进程。读进程与读进程不存在互斥问题。</li>
</ul>
</li>
<li>算法实现：<ul>
<li>读进程优先：<ul>
<li><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part2/image-20211105202012898.png" alt="image-20211105202012898"></li>
<li>问题：若<strong>两个读进程并发执行</strong>，则 count=0 时两个进程也许<strong>都能满足 if 条件，都会执行 P(rw)**，从而</strong>使第二个读进程阻塞**的情况。</li>
<li>原因：在于对 count 变量的检查和赋值无法一气呵成</li>
<li>解决：设置 mutex  互斥信号量来保证各读进程对 count 变量的互斥访问</li>
<li>特点：只要有读进程还在读，写进程就要一直阻塞等待，可能“饿死”。因此，该算法为<strong>读进程优先</strong></li>
</ul>
</li>
<li>读写公平：<ul>
<li><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part2/image-20211105202325653.png" alt="image-20211105202325653"></li>
<li>精髓：在读者写者中 P(w)、V(w) 分别<strong>包住了写文件</strong>和<strong>没有包住读文件</strong>，因此可以保证写者与其他互斥，读文件可以并发</li>
</ul>
</li>
</ul>
</li>
</ul>
<blockquote>
<p>总结：</p>
<ul>
<li>互斥 -&gt; 读者写者；同步 -&gt; 生产者消费者</li>
<li>对于读者共享，要<strong>设置计数器 count 来记录当前正在访问共享文件的读进程数</strong>。<strong>只有第一个/最后一个读进程需要进行 P、V 操作</strong>。</li>
<li>对于需要一气呵成的“<strong>检查和赋值</strong>” ，自然应该想到用<strong>互斥信号量</strong>实现。 </li>
<li>解决“写进程饥饿”问题，需要<strong>通过写者来限制读者访问 count</strong>。</li>
</ul>
</blockquote>
<h3 id="哲学家进餐问题"><a href="#哲学家进餐问题" class="headerlink" title="哲学家进餐问题"></a>哲学家进餐问题</h3><ul>
<li>问题描述：一张圆桌上坐着 5 名哲学家，每两个哲学家之间的桌上摆一根筷子，桌子的中间是一碗米饭。哲学家们倾注毕生的精力用于思考和进餐，哲学家在思考时，并不影响他人。只有当哲学家饥饿时，才试图拿起左、右两根筷子（一根一根地拿起）。如果筷子已在他人手上，则需等待。饥饿的哲学家只有同时拿起两根筷子才可以开始进餐，当进餐完毕后，放下筷子继续思考。</li>
<li>问题分析：因为需要<strong>同时持有两个临界资源</strong>，所以如果多个哲学家并发则可能出现<strong>循环等待</strong>，<strong>发生死锁</strong>。</li>
<li>算法实现：<ul>
<li>保证了“<strong>各哲学家拿筷子这件事必须互斥的执行</strong>”。<ul>
<li>即使一个哲学家在拿筷子拿到一半时被阻塞，也不会有别的哲学家继续尝试拿筷子。</li>
</ul>
</li>
<li>并不能保证“<strong>仅当一个哲学家左右两支筷子都可用时才允许他抓起筷子</strong>”。</li>
<li><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part2/image-20211105215209806.png" alt="image-20211105215209806" style="zoom:80%;">

</li>
</ul>
</li>
</ul>
<h3 id="管程"><a href="#管程" class="headerlink" title="管程"></a>管程</h3><p><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part2/image-20211105215354783.png" alt="image-20211105215354783"></p>
<ul>
<li>针对问题：编写程序困难、易出错</li>
<li>改进方向：将复杂部分<strong>封装</strong>为管程，对外<strong>仅暴露接口</strong></li>
<li>组成：<ul>
<li>局部于管程的<strong>共享数据结构</strong></li>
<li>对该数据结构进行操作的<strong>过程</strong></li>
<li>对共享数据设置的<strong>初始值</strong></li>
<li>管程的名字</li>
</ul>
</li>
<li>基本特征：<ul>
<li>共享数据<strong>只能由内部的过程操作</strong></li>
<li>一个进程<strong>只有通过调用管程的过程</strong>才能访问共享数据</li>
<li><strong>每次仅允许一个进程在管程内执行某个内部过程</strong></li>
<li>其互斥特性是<strong>由编译器负责实现</strong></li>
<li>可在管程中设置<strong>条件变量</strong>及<strong>等待/唤醒操作</strong>以解决同步问题。</li>
</ul>
</li>
<li>实现：（伪代码，不考）<ul>
<li><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part2/image-20211105221421680.png" alt="image-20211105221421680"></li>
<li>JAVA 中的 synchronized 关键字</li>
</ul>
</li>
</ul>
<h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><h3 id="死锁的概念"><a href="#死锁的概念" class="headerlink" title="死锁的概念"></a>死锁的概念</h3><p><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part2/image-20211106134325023.png" alt="image-20211106134325023"></p>
<ul>
<li>死锁、饥饿、死循环<ul>
<li>死锁：各进程互相等待对方手里的资源，导致各进程都阻塞，无法向前推进的现象。</li>
<li>饥饿：由于长期得不到想要的资源，某进程无法向前推进的现象。</li>
<li>死循环：某进程执行过程中一直跳不出某个循环的现象。</li>
</ul>
</li>
<li>共同点：都是进程无法顺利向前推进的现象</li>
<li><strong>死锁、饥饿、死循环的区别</strong><ul>
<li>数量：<ul>
<li>死锁：如果有死锁现象，那<strong>至少有两个或两个以上</strong>的进程同时发生死锁。</li>
<li>饥饿：可能<strong>只有一个或多个</strong>进程发生饥饿。</li>
<li>死循环：可能<strong>只有一个或多个</strong>进程发生死循环。</li>
</ul>
</li>
<li>原因：<ul>
<li>死锁：一定是“<strong>循环等待对方手里的资源</strong>”导致的</li>
<li>饥饿：长期得不到需要的 <strong>I/O 设备</strong>或<strong>处理机</strong></li>
<li>死循环：代码<strong>逻辑的错误或者人为因素</strong></li>
</ul>
</li>
<li>进程状态：<ul>
<li>死锁：一定处于阻塞态。</li>
<li>饥饿：既可能是阻塞态，也可能是就绪态。</li>
<li>死循环：可以是运行态</li>
</ul>
</li>
<li>死锁和饥饿，是由于<strong>操作系统分配资源的策略不合理</strong>导致的，是管理者（操作系统）的问题；死循环是<strong>被管理者</strong>的问题。</li>
</ul>
</li>
<li><strong>死锁产生的必要条件</strong><ul>
<li>产生死锁<strong>必须同时满足</strong>一下四个条件，只要其中任一条件不成立，死锁就不会发生。</li>
<li><strong>互斥条件</strong>：<strong>只有对必须互斥使用的资源的争抢</strong>才会导致死锁（如哲学家的筷子、打印机设备）。像内存、扬声器这样可以同时让多个进程使用的资源是不会导致死锁的（因为进程不用阻塞等待这种资源）。</li>
<li><strong>不剥夺条件</strong>：进程所获得的资源在<strong>未使用完之前，不能由其他进程强行夺走</strong>，只能主动释放。</li>
<li><strong>请求和保持条件</strong>：进程<strong>已经保持了至少一个资源，但又提出了新的资源请求，而该资源又被其他进程占有</strong>，此时请求进程被阻塞，但又对自己已有的资源保持不放。</li>
<li><strong>循环等待条件</strong>：存在一种<strong>进程资源的循环等待链</strong>，链中的每一个进程已获得的资源同时被下一个进程所请求。</li>
</ul>
</li>
<li>注意：发生死锁时一定有循环等待，但是发生循环等待时未必死锁（循环等待是死锁的必要不充分条件）<ul>
<li>存在循环等待的同时，还存在其他可以获得资源的分支</li>
<li><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part2/image-20211106133925724.png" alt="image-20211106133925724" style="zoom:50%;"></li>
</ul>
</li>
<li>发生死锁的情况（<strong>对不可剥夺资源的不合理分配</strong>）<ul>
<li>对系统资源的竞争。各进程对<strong>不可剥夺的资源</strong>（如打印机）的竞争可能引起死锁，对可剥夺的资源（CPU）的竞争是不会引起死锁的。</li>
<li>进程推进顺序非法。请求和释放资源的顺序不当，也同样会导致死锁。例如，并发执行的进程 P1、P2 分别申请并占有了资源 R1、R2，之后进程 P1 又紧接着申请资源 R2，而进程 P2 又申请资源 R1，两者会因为申请的资源被对方占有而阻塞，从而发生死锁。</li>
<li>信号量的使用不当也会造成死锁。如生产者-消费者问题中，如果实现互斥的P操作在实现同步的 P 操作之前，就有可能导致死锁。（可以把互斥信号量、同步信号量也看做是一种抽象的系统资源）</li>
</ul>
</li>
</ul>
<h3 id="死锁的处理策略"><a href="#死锁的处理策略" class="headerlink" title="死锁的处理策略"></a>死锁的处理策略</h3><h4 id="预防死锁（静态策略）"><a href="#预防死锁（静态策略）" class="headerlink" title="预防死锁（静态策略）"></a>预防死锁（静态策略）</h4><p><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part2/image-20211106134712771.png" alt="image-20211106134712771"></p>
<ul>
<li><strong>破坏互斥条件</strong><ul>
<li>把只能互斥使用的资源改造为允许共享使用，则系统不会进入死锁状态。</li>
<li>如：SPOOLing 技术把独占设备在逻辑上改造成共享设备。<ul>
<li><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part2/image-20211106145121574.png" alt="image-20211106145121574" style="zoom:80%;"></li>
</ul>
</li>
<li>缺点：并不是所有的资源都可以改造成可共享使用的资源。并且为了系统安全，很多地方还必须保护这种互斥性。因此，<strong>很多时候都无法破坏互斥条件</strong>。</li>
</ul>
</li>
<li><strong>破坏不剥夺条件</strong><ul>
<li>方案一：当某个进程请求新的资源得不到满足时，必须立即<strong>主动释放保持的所有资源</strong>，以后需要时重新申请。</li>
<li>方案二：当某个进程需要的资源被其他进程所占有的时候，可以<strong>由操作系统协助，将想要的资源强行剥夺</strong>。<ul>
<li>这种方式一般需要考虑各进程的优先级（比如：剥夺调度方式，就是将处理机资源强行剥夺给优先级更高的进程使用）</li>
</ul>
</li>
<li>缺点：<ul>
<li>实现起来比较复杂。</li>
<li>释放已获得的资源可能造成前一阶段工作的失效。因此这种方法一般只<strong>适用于易保存和恢复状态的资源</strong>，如 CPU。</li>
<li>反复地申请和释放资源会增加系统开销，降低系统吞吐量。</li>
<li>若采用方案一，意味着只要暂时得不到某个资源，之前获得的那些资源就都需要放弃，以后再重新申请。如果<strong>一直发生放弃资源，就会导致进程饥饿</strong>。</li>
</ul>
</li>
</ul>
</li>
<li><strong>破坏请求和保持条件</strong><ul>
<li>采用<strong>静态分配方法</strong>，即进程在运行前一次申请完它所需要的全部资源，在它的资源未满足前，不让它投入运行。一旦投入运行后，这些资源就一直归它所有，该进程就不会再请求别的任何资源了。</li>
<li>缺点：<strong>有些资源可能只需要用很短的时间</strong>，因此如果进程的整个运行期间都一直保持着所有资源，就会造成严重的<strong>资源浪费</strong>，资源利用率极低。另外，该策略也有可能导致某些进程饥饿。</li>
</ul>
</li>
<li><strong>破坏循环等待条件</strong><ul>
<li>采用<strong>顺序资源分配法</strong>。首先给系统中的资源编号，规定每个进程<strong>必须按编号递增的顺序请求资源</strong>（持有 n 号资源时，不允许请求 &lt;n 号的资源），同类资源（即编号相同的资源）一次申请完。</li>
<li>缺点：<ul>
<li><strong>不方便增加新的设备</strong>，因为可能需要重新分配所有的编号；</li>
<li>进程<strong>实际使用资源的顺序</strong>可能和<strong>编号递增顺序</strong>不一致（必须先占有资源，但不使用），会导致资源浪费；</li>
<li>必须按规定次序申请资源，编程麻烦。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="避免死锁（动态策略）"><a href="#避免死锁（动态策略）" class="headerlink" title="避免死锁（动态策略）"></a>避免死锁（动态策略）</h4><ul>
<li><p><strong>安全序列</strong>，指如果系统按照这种序列分配资源，则每个进程都能顺利完成。</p>
<ul>
<li>只要能找出一个安全序列，系统就是<strong>安全状态</strong>。<strong>安全序列可能有多个</strong>。</li>
<li>如果分配了资源之后，系统中找不出任何一个安全序列，系统就进入了<strong>不安全状态</strong>。这就意味着之后<strong>可能</strong>所有进程都无法顺利的执行下去。<ul>
<li>如果有进程提前归还了一些资源，那系统也<strong>有可能重新回到安全状态</strong>，不过我们在分配资源之前总是要考虑到最坏的情况。</li>
</ul>
</li>
</ul>
</li>
<li><p>注意：</p>
<ul>
<li>如果系统处于<strong>安全状态</strong>，就<strong>一定不会发生死锁</strong>；如果系统进入<strong>不安全状态</strong>，就<strong>可能发生死锁</strong>。</li>
<li><strong>处于不安全状态未必会发生死锁，但发生死锁时一定是在不安全状态</strong></li>
</ul>
</li>
<li><p>核心思想：</p>
<ul>
<li>在进程提出资源申请时，先预判此次分配是否会导致系统进入不安全状态。如果会进入不安全状态，就暂时不答应这次请求，让该进程先阻塞等待。</li>
</ul>
</li>
<li><p>算法实现：</p>
<ul>
<li><p>假设系统中有 n 个进程，m 种资源</p>
</li>
<li><p>数据结构：</p>
<ul>
<li><p>n*m 矩阵 <strong>Max</strong> 表示各进程对资源的最大需求数</p>
</li>
<li><p>n*m 矩阵 <strong>Allocation</strong> 表示已经给各进程分配了多少资源</p>
</li>
<li><p>Max – Allocation = <strong>Need</strong> 矩阵表示各进程最多还需要多少资源</p>
</li>
<li><p>长度为 m 的一维数组 <strong>Available</strong> 表示还有多少可用资源</p>
</li>
<li><p>用长度为 m 的一位数组 <strong>Request</strong> 表示进程此次申请的各种资源数</p>
</li>
</ul>
</li>
<li><p>银行家算法步骤：</p>
<ul>
<li>Request ≤ Need[i]：检查此次申请是否超过了之前声明的最大需求数</li>
<li>Request ≤ Available：检查此时系统剩余的可用资源是否还能满足这次请求</li>
<li>Available -= Request；Allocation[i] += Request；Need[i] -= Request：试探着分配，更改各数据结构</li>
<li>用安全性算法<strong>检查此次分配是否会导致系统进入不安全状态</strong>（是否能找到安全序列）。若安全，才正式分配；否则，恢复相应数据，让进程阻塞等待。</li>
</ul>
</li>
<li><p><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part2/image-20211106153921852.png" alt="image-20211106153921852"></p>
</li>
<li><p><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part2/image-20211106154041109.png" alt="image-20211106154041109"></p>
</li>
</ul>
</li>
</ul>
<h4 id="死锁的检测与解除"><a href="#死锁的检测与解除" class="headerlink" title="死锁的检测与解除"></a>死锁的检测与解除</h4><p><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part2/image-20211106153523487.png" alt="image-20211106153523487"></p>
<p>如果系统中<strong>既不采取预防死锁的措施，也不采取避免死锁的措施</strong>，系统就很可能发生死锁。在这种情况下，系统应当提供两个算法：</p>
<ul>
<li><p>死锁检测算法：</p>
<ul>
<li>用于检测系统状态，以确定系统中是否发生了死锁。</li>
<li>算法实现：<ul>
<li>用某种<strong>数据结构</strong>来保存资源的请求和分配信息</li>
<li>提供<strong>一种算法</strong>，利用上述信息来检测系统是否已进入死锁状态</li>
<li><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part2/image-20211106160701820.png" alt="image-20211106160701820"></li>
<li>删去所有<strong>可以请求到足够资源</strong>（不阻塞）的<strong>进程节点的边</strong><ul>
<li>最终能消除所有边，就称这个图是<strong>可完全简化的</strong>。此时一定没有发生死锁（能找到一个安全序列）</li>
<li>如果最终不能消除所有边，那么此时就是发生了死锁。</li>
<li><strong>化简资源分配图后，还连着边的那些进程就是死锁进程</strong>。</li>
</ul>
</li>
</ul>
</li>
<li>死锁定理：如果某时刻系统的资源分配图是<strong>不可完全简化</strong>的，那么此时系统死锁</li>
</ul>
</li>
<li><p>死锁解除算法：</p>
<ul>
<li><p>当认定系统中已经发生了死锁，利用该算法可将系统从死锁状态中解脱出来。</p>
</li>
<li><p>解除死锁的主要方法有：</p>
<ol>
<li><p><strong>资源剥夺法</strong>。挂起（暂时放到外存上）某些死锁进程，并抢占它的资源，将这些资源分配给其他的死锁进程。但是应防止被挂起的进程长时间得不到资源而饥饿。</p>
</li>
<li><p><strong>撤销进程法</strong>（<strong>终止进程法</strong>）。强制撤销部分、甚至全部死锁进程，并剥夺这些进程的资源。这种方式的优点是实现简单，但所付出的代价可能会很大。因为有些进程可能已经运行了很长时间，已经接近结束了，一旦被终止可谓功亏一篑，以后还得从头再来。</p>
</li>
<li><p><strong>进程回退法</strong>。让一个或多个死锁进程回退到足以避免死锁的地步。这就要求系统要记录进程的历史信息，设置还原点。</p>
</li>
</ol>
</li>
<li><p>确定解除对象进程：</p>
<ol>
<li><p>进程优先级（优先级更高的进程先获得资源）</p>
</li>
<li><p>已执行时间（回退已执行时间越长的进程，代价越大）</p>
</li>
<li><p>预计完成花费时间（优先让快结束的进程获得资源）</p>
</li>
<li><p>进程已使用资源量（优先牺牲持有多资源的进程）</p>
</li>
<li><p>进程是交互式的还是批处理式的（优先牺牲批处理式进程）</p>
</li>
</ol>
</li>
</ul>
</li>
</ul>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">NephrenCake</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://nephrencake.gitee.io/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part2/">https://nephrencake.gitee.io/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part2/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://nephrencake.gitee.io" target="_blank">浅幽丶奈芙莲的个人博客</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E5%AE%8C%E7%BB%93%E7%9B%AE%E5%BD%95/%E4%BA%8Ced12.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part3/"><img class="prev-cover" src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E5%AE%8C%E7%BB%93%E7%9B%AE%E5%BD%95/%E4%BA%8Ced12.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">操作系统-Part3</div></div></a></div><div class="next-post pull-right"><a href="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part1/"><img class="next-cover" src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E5%AE%8C%E7%BB%93%E7%9B%AE%E5%BD%95/%E4%BA%8Ced12.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">操作系统-Part1</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part2%E2%80%94%E2%80%94%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86"><span class="toc-number">1.</span> <span class="toc-text">操作系统-Part2——进程管理</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B"><span class="toc-number">1.1.</span> <span class="toc-text">进程与线程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E7%9A%84%E6%A6%82%E5%BF%B5%E3%80%81%E7%BB%84%E6%88%90%E3%80%81%E7%89%B9%E5%BE%81"><span class="toc-number">1.1.1.</span> <span class="toc-text">进程的概念、组成、特征</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E7%9A%84%E7%8A%B6%E6%80%81%E4%B8%8E%E8%BD%AC%E6%8D%A2%E3%80%81%E8%BF%9B%E7%A8%8B%E7%9A%84%E7%BB%84%E7%BB%87"><span class="toc-number">1.1.2.</span> <span class="toc-text">进程的状态与转换、进程的组织</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6"><span class="toc-number">1.1.3.</span> <span class="toc-text">进程控制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1"><span class="toc-number">1.1.4.</span> <span class="toc-text">进程通信</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E7%9A%84%E6%A6%82%E5%BF%B5%E4%B8%8E%E7%89%B9%E7%82%B9"><span class="toc-number">1.1.5.</span> <span class="toc-text">线程的概念与特点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F%E5%92%8C%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B"><span class="toc-number">1.1.6.</span> <span class="toc-text">线程的实现方式和多线程模型</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%84%E7%90%86%E6%9C%BA%E8%B0%83%E5%BA%A6"><span class="toc-number">1.2.</span> <span class="toc-text">处理机调度</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B0%83%E5%BA%A6%E7%9A%84%E6%A6%82%E5%BF%B5%E3%80%81%E5%B1%82%E6%AC%A1"><span class="toc-number">1.2.1.</span> <span class="toc-text">调度的概念、层次</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6%E7%9A%84%E6%97%B6%E6%9C%BA%E3%80%81%E5%88%87%E6%8D%A2%E4%B8%8E%E8%BF%87%E7%A8%8B%E3%80%81%E6%96%B9%E5%BC%8F"><span class="toc-number">1.2.2.</span> <span class="toc-text">进程调度的时机、切换与过程、方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95%E7%9A%84%E8%AF%84%E4%BB%B7%E6%8C%87%E6%A0%87"><span class="toc-number">1.2.3.</span> <span class="toc-text">调度算法的评价指标</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95"><span class="toc-number">1.2.4.</span> <span class="toc-text">调度算法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%88%E6%9D%A5%E5%85%88%E6%9C%8D%E5%8A%A1"><span class="toc-number">1.2.4.1.</span> <span class="toc-text">先来先服务</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%80%E7%9F%AD%E4%BD%9C%E4%B8%9A%E4%BC%98%E5%85%88"><span class="toc-number">1.2.4.2.</span> <span class="toc-text">最短作业优先</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%80%E9%AB%98%E5%93%8D%E5%BA%94%E6%AF%94%E4%BC%98%E5%85%88"><span class="toc-number">1.2.4.3.</span> <span class="toc-text">最高响应比优先</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%97%B6%E9%97%B4%E7%89%87%E8%BD%AE%E8%BD%AC"><span class="toc-number">1.2.4.4.</span> <span class="toc-text">时间片轮转</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%98%E5%85%88%E7%BA%A7%E8%B0%83%E5%BA%A6"><span class="toc-number">1.2.4.5.</span> <span class="toc-text">优先级调度</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%9A%E7%BA%A7%E5%8F%8D%E9%A6%88%E9%98%9F%E5%88%97"><span class="toc-number">1.2.4.6.</span> <span class="toc-text">多级反馈队列</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A5"><span class="toc-number">1.3.</span> <span class="toc-text">进程同步</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A5%E3%80%81%E8%BF%9B%E7%A8%8B%E4%BA%92%E6%96%A5"><span class="toc-number">1.3.1.</span> <span class="toc-text">进程同步、进程互斥</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E4%BA%92%E6%96%A5%E7%9A%84%E8%BD%AF%E4%BB%B6%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%B3%95%EF%BC%88%E9%AB%98%E9%A2%91%EF%BC%89"><span class="toc-number">1.3.2.</span> <span class="toc-text">进程互斥的软件实现方法（高频）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E4%BA%92%E6%96%A5%E7%9A%84%E7%A1%AC%E4%BB%B6%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%B3%95"><span class="toc-number">1.3.3.</span> <span class="toc-text">进程互斥的硬件实现方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BF%A1%E5%8F%B7%E9%87%8F%E6%9C%BA%E5%88%B6"><span class="toc-number">1.3.4.</span> <span class="toc-text">信号量机制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BF%A1%E5%8F%B7%E9%87%8F%E5%AE%9E%E7%8E%B0%E8%BF%9B%E7%A8%8B%E4%BA%92%E6%96%A5%E3%80%81%E5%90%8C%E6%AD%A5%E3%80%81%E5%89%8D%E9%A9%B1%E5%85%B3%E7%B3%BB"><span class="toc-number">1.3.5.</span> <span class="toc-text">信号量实现进程互斥、同步、前驱关系</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%9F%E4%BA%A7%E8%80%85-%E6%B6%88%E8%B4%B9%E8%80%85%E9%97%AE%E9%A2%98"><span class="toc-number">1.3.6.</span> <span class="toc-text">生产者-消费者问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E7%94%9F%E4%BA%A7%E8%80%85-%E5%A4%9A%E6%B6%88%E8%B4%B9%E8%80%85"><span class="toc-number">1.3.7.</span> <span class="toc-text">多生产者-多消费者</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%B8%E7%83%9F%E8%80%85%E9%97%AE%E9%A2%98"><span class="toc-number">1.3.8.</span> <span class="toc-text">吸烟者问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%BB%E8%80%85-%E5%86%99%E8%80%85%E9%97%AE%E9%A2%98"><span class="toc-number">1.3.9.</span> <span class="toc-text">读者-写者问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%93%B2%E5%AD%A6%E5%AE%B6%E8%BF%9B%E9%A4%90%E9%97%AE%E9%A2%98"><span class="toc-number">1.3.10.</span> <span class="toc-text">哲学家进餐问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%A1%E7%A8%8B"><span class="toc-number">1.3.11.</span> <span class="toc-text">管程</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%AD%BB%E9%94%81"><span class="toc-number">1.4.</span> <span class="toc-text">死锁</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AD%BB%E9%94%81%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="toc-number">1.4.1.</span> <span class="toc-text">死锁的概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AD%BB%E9%94%81%E7%9A%84%E5%A4%84%E7%90%86%E7%AD%96%E7%95%A5"><span class="toc-number">1.4.2.</span> <span class="toc-text">死锁的处理策略</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A2%84%E9%98%B2%E6%AD%BB%E9%94%81%EF%BC%88%E9%9D%99%E6%80%81%E7%AD%96%E7%95%A5%EF%BC%89"><span class="toc-number">1.4.2.1.</span> <span class="toc-text">预防死锁（静态策略）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%81%BF%E5%85%8D%E6%AD%BB%E9%94%81%EF%BC%88%E5%8A%A8%E6%80%81%E7%AD%96%E7%95%A5%EF%BC%89"><span class="toc-number">1.4.2.2.</span> <span class="toc-text">避免死锁（动态策略）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%AD%BB%E9%94%81%E7%9A%84%E6%A3%80%E6%B5%8B%E4%B8%8E%E8%A7%A3%E9%99%A4"><span class="toc-number">1.4.2.3.</span> <span class="toc-text">死锁的检测与解除</span></a></li></ol></li></ol></li></ol></li></ol></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2021 By NephrenCake</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">这里是浅幽丶奈芙莲的个人博客~</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div></div><hr/><div id="local-search-results"></div><span class="search-close-button"><i class="fas fa-times"></i></span></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/search/local-search.js"></script><script>var preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',()=> {preloader.endLoading()})</script><div class="js-pjax"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><canvas class="fireworks" mobile="true"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/fireworks.min.js"></script></div></body></html>