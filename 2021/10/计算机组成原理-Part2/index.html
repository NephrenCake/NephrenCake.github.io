<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>计算机组成原理-Part2 | 浅幽丶奈芙莲的个人博客</title><meta name="author" content="NephrenCake"><meta name="copyright" content="NephrenCake"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><meta name="description" content="数据的表示和运算">
<meta property="og:type" content="article">
<meta property="og:title" content="计算机组成原理-Part2">
<meta property="og:url" content="https://nephrencake.gitee.io/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part2/index.html">
<meta property="og:site_name" content="浅幽丶奈芙莲的个人博客">
<meta property="og:description" content="数据的表示和运算">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://nephrencake.gitee.io/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E5%AE%8C%E7%BB%93%E7%9B%AE%E5%BD%95/%E4%BA%8Ced11.jpg">
<meta property="article:published_time" content="2021-10-02T02:53:03.000Z">
<meta property="article:modified_time" content="2021-12-25T08:29:16.431Z">
<meta property="article:author" content="NephrenCake">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://nephrencake.gitee.io/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E5%AE%8C%E7%BB%93%E7%9B%AE%E5%BD%95/%E4%BA%8Ced11.jpg"><link rel="shortcut icon" href="/img/favicon.jpg"><link rel="canonical" href="https://nephrencake.gitee.io/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part2/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: {"limitDay":365,"position":"top","messagePrev":"It has been","messageNext":"days since the last update, the content of the article may be outdated."},
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
};

var saveToLocal = {
  set: function setWithExpiry(key, value, ttl) {
    const now = new Date()
    const expiryDay = ttl * 86400000
    const item = {
      value: value,
      expiry: now.getTime() + expiryDay,
    }
    localStorage.setItem(key, JSON.stringify(item))
  },

  get: function getWithExpiry(key) {
    const itemStr = localStorage.getItem(key)

    if (!itemStr) {
      return undefined
    }
    const item = JSON.parse(itemStr)
    const now = new Date()

    if (now.getTime() > item.expiry) {
      localStorage.removeItem(key)
      return undefined
    }
    return item.value
  }
}

// https://stackoverflow.com/questions/16839698/jquery-getscript-alternative-in-native-javascript
const getScript = url => new Promise((resolve, reject) => {
  const script = document.createElement('script')
  script.src = url
  script.async = true
  script.onerror = reject
  script.onload = script.onreadystatechange = function() {
    const loadState = this.readyState
    if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
    script.onload = script.onreadystatechange = null
    resolve()
  }
  document.head.appendChild(script)
})</script><script id="config_change">var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2021-12-25 16:29:16'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(function () {const asideStatus = saveToLocal.get('aside-status')
if (asideStatus !== undefined) {
   if (asideStatus === 'hide') {
     document.documentElement.classList.add('hide-aside')
   } else {
     document.documentElement.classList.remove('hide-aside')
   }
}})()</script><link rel="stylesheet" href="/css/background.css"><link rel="stylesheet" href="/css/mouse.css"><link rel="stylesheet" href="/css/scrollbar.css"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/iconfont.css"><meta name="generator" content="Hexo 5.3.0"><link rel="alternate" href="/atom.xml" title="浅幽丶奈芙莲的个人博客" type="application/atom+xml">
</head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="author-avatar"><img class="avatar-img" src="/img/avatar.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">103</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">10</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">18</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/photo/"><i class="fa-fw fas fa-heart"></i><span> 相册</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友情链接</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E5%AE%8C%E7%BB%93%E7%9B%AE%E5%BD%95/%E4%BA%8Ced11.jpg)"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">浅幽丶奈芙莲的个人博客</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/photo/"><i class="fa-fw fas fa-heart"></i><span> 相册</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友情链接</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">计算机组成原理-Part2</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2021-10-02T02:53:03.000Z" title="发表于 2021-10-02 10:53:03">2021-10-02</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2021-12-25T08:29:16.431Z" title="更新于 2021-12-25 16:29:16">2021-12-25</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/">计算机组成原理</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">8.1k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>27分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="计算机组成原理-Part2——数据的表示和运算"><a href="#计算机组成原理-Part2——数据的表示和运算" class="headerlink" title="计算机组成原理-Part2——数据的表示和运算"></a>计算机组成原理-Part2——数据的表示和运算</h1><p>[TOC]</p>
<h2 id="数制与编码"><a href="#数制与编码" class="headerlink" title="数制与编码"></a>数制与编码</h2><h3 id="进位计数制及其相互转换"><a href="#进位计数制及其相互转换" class="headerlink" title="进位计数制及其相互转换"></a>进位计数制及其相互转换</h3><h4 id="r-进制计数法"><a href="#r-进制计数法" class="headerlink" title="r 进制计数法"></a>r 进制计数法</h4><ul>
<li><strong>基数</strong>：每个数码位所用到的不同符号的个数，r 进制的基数为 r</li>
<li><strong>位权</strong>：处于第 i 位的权重，值为 r^i^</li>
<li>每个位上的取值范围：0 ~ r-1</li>
</ul>
<h4 id="其他进制-gt-十进制"><a href="#其他进制-gt-十进制" class="headerlink" title="其他进制 -&gt; 十进制"></a>其他进制 -&gt; 十进制</h4><ul>
<li>r 进制数：K<del>n</del>K<del>n-1</del>……K<del>1</del>K<del>0</del>K<del>-1</del>……K<del>-m</del></li>
<li>十进制：  K<del>n</del> × r^n^ + K<del>n-1</del> × r^n-1^ + …… + K<del>1</del> × r^1^ + K<del>0</del> × r^0^ + K<del>-1</del> × r^-1^ + …… + K<del>-m</del> × r^m^ </li>
</ul>
<table>
<thead>
<tr>
<th>2^12^</th>
<th>2^11^</th>
<th>2^10^</th>
<th>2^9^</th>
<th>2^8^</th>
<th>2^7^</th>
<th>2^6^</th>
<th>2^5^</th>
<th>2^4^</th>
<th>2^3^</th>
<th>2^2^</th>
<th>2^1^</th>
<th>2^0^</th>
<th>2^-1^</th>
<th>2^-2^</th>
<th>2^-3^</th>
</tr>
</thead>
<tbody><tr>
<td>4096</td>
<td>2048</td>
<td>1024</td>
<td>512</td>
<td>256</td>
<td>128</td>
<td>64</td>
<td>32</td>
<td>16</td>
<td>8</td>
<td>4</td>
<td>2</td>
<td>1</td>
<td>0.5</td>
<td>0.25</td>
<td>0.125</td>
</tr>
</tbody></table>
<h4 id="二、八、十六进制之间相互转换"><a href="#二、八、十六进制之间相互转换" class="headerlink" title="二、八、十六进制之间相互转换"></a>二、八、十六进制之间相互转换</h4><ul>
<li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part2/image-20211003084155324.png" alt="image-20211003084155324"></li>
<li>各种进制的常见书写方式<ul>
<li>二进制（Binary）：(1010001010010)<del>2</del>    或    1010001010010B</li>
<li>八进制：(1652)<del>8</del></li>
<li>十六进制（hex）：(1652)<del>16</del>    或     1652H    或    0x1652</li>
<li>十进制（dec）：(1652)<del>10</del>    或    1652D</li>
</ul>
</li>
<li>注意需要补位：整数向前补 0，小数向后补 0。</li>
</ul>
<h4 id="十进制-gt-其他进制"><a href="#十进制-gt-其他进制" class="headerlink" title="十进制 -&gt; 其他进制"></a>十进制 -&gt; 其他进制</h4><ul>
<li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part2/image-20211003085557768.png" alt="image-20211003085557768"></li>
<li>整数部分除法：先除得的余数为低位（靠近0）</li>
<li>小数部分乘法：先进位的整数为高位（靠近0）</li>
<li>也可以使用拼凑法：枚举 r 进制数与十进制数的对应表</li>
<li>有的十进制小数无法使用二进制精确表示，如：0.3</li>
</ul>
<h4 id="真值和机器数"><a href="#真值和机器数" class="headerlink" title="真值和机器数"></a>真值和机器数</h4><ul>
<li><strong>真值</strong>：符合人类习惯的数字</li>
<li><strong>机器数</strong>：数字实际存到机器里的形式，正负号需要被“数字化”</li>
</ul>
<h3 id="BCD码（408大纲已删）"><a href="#BCD码（408大纲已删）" class="headerlink" title="BCD码（408大纲已删）"></a>BCD码（408大纲已删）</h3><ul>
<li>BCD ：Binary-Coded Decimal，用二进制编码的十进制<ul>
<li>8421 码（掌握加法）</li>
<li>余 3 码</li>
<li>2421 码</li>
</ul>
</li>
<li>针对问题：二进制方便计算机处理、十进制符合人类习惯，但是转换麻烦</li>
<li>改进方向：快速转换，一一对应</li>
<li><strong>以 4bit 二进制码表示 0~9</strong>。一共 16 种情况，6 种冗余。</li>
</ul>
<h4 id="8421-码"><a href="#8421-码" class="headerlink" title="8421 码"></a>8421 码</h4><ul>
<li>4 位二进制权值分别为：8 4 2 1</li>
<li>8421 码是有权码</li>
<li>8421 码的加法：<strong>先用十进制加法得出结果，再转 8421 码</strong></li>
<li>8421码中，1010～1111 没有定义</li>
<li>在机器的视角中，若发现结果<strong>非法定义</strong>（6+7）或<strong>出现进位</strong>（9+9），则需要继续 +6 进行修正。</li>
</ul>
<table>
<thead>
<tr>
<th>0</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
<th>6</th>
<th>7</th>
<th>8</th>
<th>9</th>
</tr>
</thead>
<tbody><tr>
<td>0000</td>
<td>0001</td>
<td>0010</td>
<td>0011</td>
<td>0100</td>
<td>0101</td>
<td>0110</td>
<td>0111</td>
<td>1000</td>
<td>1001</td>
</tr>
</tbody></table>
<h4 id="余-3-码"><a href="#余-3-码" class="headerlink" title="余 3 码"></a>余 3 码</h4><ul>
<li>余3码：8421码 + (0011)<del>2</del></li>
<li>余 3 码的每个权位不固定，所以是无权码</li>
</ul>
<table>
<thead>
<tr>
<th>0</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
<th>6</th>
<th>7</th>
<th>8</th>
<th>9</th>
</tr>
</thead>
<tbody><tr>
<td>0011</td>
<td>0100</td>
<td>0101</td>
<td>0110</td>
<td>0111</td>
<td>1000</td>
<td>1001</td>
<td>1010</td>
<td>1011</td>
<td>1100</td>
</tr>
</tbody></table>
<h4 id="2421-码"><a href="#2421-码" class="headerlink" title="2421 码"></a>2421 码</h4><ul>
<li>4 位二进制权值分别为：2 4 2 1</li>
<li>0<del>4 首位必须是 0，5</del>9 首位必须是 1</li>
</ul>
<table>
<thead>
<tr>
<th>0</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
<th>6</th>
<th>7</th>
<th>8</th>
<th>9</th>
</tr>
</thead>
<tbody><tr>
<td>0000</td>
<td>0001</td>
<td>0010</td>
<td>0011</td>
<td>0100</td>
<td>1011</td>
<td>1100</td>
<td>1101</td>
<td>1110</td>
<td>1111</td>
</tr>
</tbody></table>
<h3 id="字符与字符串"><a href="#字符与字符串" class="headerlink" title="字符与字符串"></a>字符与字符串</h3><h4 id="ASCII-码"><a href="#ASCII-码" class="headerlink" title="ASCII 码"></a>ASCII 码</h4><ul>
<li>键盘共 128 个字符，可以用 7 位二进制编码。<ul>
<li>为了存入计算机，通常在最高位补 0，凑足1B</li>
</ul>
</li>
<li>可印刷字符：32～126，其余为控制（如：127 DEL）、通信（如：6 ACK）字符</li>
<li>数字 0~9：<strong>48</strong>(0011 0000)～<strong>57</strong>(0011 1001)<ul>
<li>数字的 ASCII 码的<strong>前四位是 0011，后四位是 8421 码</strong></li>
</ul>
</li>
<li>大写字母 A~Z：<strong>65</strong>(0100 0001)～<strong>90</strong>(0101 1010)<ul>
<li>大写字母 ASCII 码<strong>前三位都是 010，后五位是 1~26</strong></li>
</ul>
</li>
<li>小写字母 a~z：<strong>97</strong>(0110 0001)～<strong>122</strong>(0111 1010)<ul>
<li>小写字母 ASCII 码<strong>前三位都是 011，后五位是 1~26</strong></li>
</ul>
</li>
<li>所有数字、大写字母、小写字母的编码都是连续的</li>
</ul>
<blockquote>
<p>求解某字符 ASCII 码时，要充分利用上述规律，避免十进制、二进制转换。</p>
</blockquote>
<h4 id="汉字的表示和编码"><a href="#汉字的表示和编码" class="headerlink" title="汉字的表示和编码"></a>汉字的表示和编码</h4><ul>
<li>GB 2312-100（19100年）：汉字+各种符号共7445个</li>
<li><strong>区位码：94 个区，每区 94 个位置</strong>。相当于把所有汉字存放在了 94*94 的方阵中，通过两个字节长度来定位汉字</li>
<li><strong>国标码：区位码 + 20H</strong>。防止信息交换时与“控制/通信字符”冲突</li>
<li><strong>汉字(机)内码：国标码 + 100H</strong>。保证高位为1，与ASCII码区分</li>
<li>输入法 -&gt; 国标码 -&gt; 汉字内码 -&gt;  (国标码 -&gt; )汉字字形码（像素方阵）</li>
</ul>
<h4 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h4><ul>
<li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part2/image-20211003101235176.png" alt="image-20211003101235176"></li>
<li><strong>按字节编址：每个地址对应 1B/1字节（存储单元大小为 1B/8b）</strong></li>
<li>很多语言中，“\0”作为字符串结尾标志</li>
<li>在所有计算机中，多字节数据都被存放在连续的字节序列中。根据数据中各字节的排列顺序不同，可能有“大端模式”、“小端模式”<ul>
<li>大端模式：将数据的<strong>最高有效字节存放在低地址单元</strong>中（低位到高位顺序读取）</li>
<li>小端模式：将数据的<strong>最高有效字节存放在高地址单元</strong>中（遇到多字节数据需要倒着读）</li>
</ul>
</li>
</ul>
<h3 id="奇偶校验码（计网要考）"><a href="#奇偶校验码（计网要考）" class="headerlink" title="奇偶校验码（计网要考）"></a>奇偶校验码（计网要考）</h3><h4 id="校验原理"><a href="#校验原理" class="headerlink" title="校验原理"></a>校验原理</h4><ul>
<li>位错误：在 bit 位上发生的突变。0 变 1，1 变 0</li>
<li><strong>码字</strong>：由若干位代码组成的一个字</li>
<li><strong>两个码字间的距离</strong>：将两个码字逐位进行对比，<strong>具有不同的位的个数</strong></li>
<li><strong>码距</strong>：一种编码方案中，合法码字之间的最小距离。<strong>最少变动多少位可以在各合法码字之间转换</strong></li>
<li>当 d=1 时，无检错能力；当 d=2 时，有检错能力；当 d≥3 时，若设计合理，可能具有检错、纠错能力</li>
</ul>
<h4 id="奇偶校验码"><a href="#奇偶校验码" class="headerlink" title="奇偶校验码"></a>奇偶校验码</h4><ul>
<li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part2/image-20211004142023267.png" alt="image-20211004142023267" style="zoom:100%;"></li>
<li><strong>奇校验码</strong>：在有效信息位之外添加一位校验位，使得整个校验码中“1”的个数为<strong>奇数</strong>。</li>
<li><strong>偶校验码</strong>：在有效信息位之外添加一位校验位，使得整个校验码中“1”的个数为<strong>偶数</strong>。</li>
<li>本质：如果出现<strong>奇数次的位错误，则可以检测出错误</strong>；如果出现<strong>偶数次位错误，则检不出错误</strong>。</li>
<li><strong>偶校验的硬件实现</strong>：取各位的信息依次进行异或（模2加）运算，得到的结果即为偶校验位。<ul>
<li>进行偶校验且结果为 0 时，则通过校验。</li>
<li>进行奇校验且结果为 1 时，则通过校验。</li>
</ul>
</li>
<li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part2/image-20211004143356036.png" alt="image-20211004143356036" style="zoom:100%;">

</li>
</ul>
<h3 id="海明校验码（计网要考）"><a href="#海明校验码（计网要考）" class="headerlink" title="海明校验码（计网要考）"></a>海明校验码（计网要考）</h3><h4 id="基本思想"><a href="#基本思想" class="headerlink" title="基本思想"></a>基本思想</h4><ul>
<li>针对问题：偶校验只能发现<strong>奇数位错误</strong>，且<strong>无法确定出错位置</strong>，想要获得正确信息则必须重新传输信息。</li>
<li>改进方向：将信息位分组进行偶校验 —&gt; 多个校验位 —&gt; 多个校验位标注出错位置<ul>
<li>1 个校验位之只能携带 2 种状态信息（对/错）</li>
<li>多个校验位能携带多种状态信息（对/错，错在哪）</li>
</ul>
</li>
<li>信息位 n 位 + 校验位 k 位 = 共 n+k 位<ul>
<li>k 位校验位代表最多能表示 2^k^ 种状态</li>
<li>校验位表示的状态应该要考虑到 n+k 的任何一位都有可能出错</li>
<li>重要公式：<strong>2^k^ ≥ n + k + 1</strong></li>
</ul>
</li>
<li>本质：分 k 组偶校验</li>
</ul>
<h4 id="海明码求解步骤（TODO）"><a href="#海明码求解步骤（TODO）" class="headerlink" title="海明码求解步骤（TODO）"></a>海明码求解步骤（TODO）</h4><p>Eg：信息位为 1010，求解海明码。</p>
<ol>
<li><p>确定海明码的位数：</p>
<ul>
<li>2^k^ ≥ n + k + 1</li>
<li>n=4 =&gt; k=3</li>
</ul>
</li>
<li><p>确定校验位的分布：</p>
<ul>
<li><p>设信息位 D<del>4</del>D<del>3</del>D<del>2</del>D<del>1</del>（1010），共4位；校验位 P<del>3</del>P<del>2</del>P<del>1</del>，共3位；对应的海明码为 H<del>7</del>H<del>6</del>H<del>5</del>H<del>4</del>H<del>3</del>H<del>2</del>H<del>1</del></p>
</li>
<li><p><strong>校验位 P<del>i</del> 放在海明位号为 2^i−1^ 的位置上</strong></p>
</li>
<li><p>校验位 P<del>i</del> 与位置序号第 i 位为 1 的信息位归为同一组，进行偶校验</p>
</li>
<li><table>
<thead>
<tr>
<th>H<del>7</del></th>
<th>H<del>6</del></th>
<th>H<del>5</del></th>
<th>H<del>4</del></th>
<th>H<del>3</del></th>
<th>H<del>2</del></th>
<th>H<del>1</del></th>
</tr>
</thead>
<tbody><tr>
<td>D<del>4</del></td>
<td>D<del>3</del></td>
<td>D<del>2</del></td>
<td>P<del>3</del></td>
<td>D<del>1</del></td>
<td>P<del>2</del></td>
<td>P<del>1</del></td>
</tr>
<tr>
<td>1</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>0</td>
</tr>
</tbody></table>
</li>
</ul>
</li>
<li><p>求校验位的值：</p>
<ul>
<li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part2/image-20211004151532962.png" alt="image-20211004151532962" style="zoom:100%;"></li>
<li>将海明码信息位的下标转二进制矩阵，一列为一组，对应 1 的信息拿出来做偶校验，结果就是海明码校验位的值。</li>
</ul>
</li>
<li><p>纠错：</p>
<ul>
<li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part2/image-20211004154938467.png" alt="image-20211004154938467" style="zoom:100%;"></li>
<li>题目的下标顺序不影响做题（TODO）</li>
</ul>
</li>
</ol>
<h4 id="海明码的检错、纠错能力"><a href="#海明码的检错、纠错能力" class="headerlink" title="海明码的检错、纠错能力"></a>海明码的检错、纠错能力</h4><ul>
<li>海明码的检错、纠错能力：<ul>
<li>纠错能力：1位（无法区分到底是 1 位错还是 2 位错）</li>
<li>检错能力：2位</li>
</ul>
</li>
<li>为了区分是 1 位错误还是 2 位错误，需加上“全校验位”，对整体进行偶校验。</li>
<li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part2/image-20211004155557262.png" alt="image-20211004155557262"></li>
</ul>
<h3 id="循环冗余校验码（计网要考）"><a href="#循环冗余校验码（计网要考）" class="headerlink" title="循环冗余校验码（计网要考）"></a>循环冗余校验码（计网要考）</h3><h4 id="基本思想-1"><a href="#基本思想-1" class="headerlink" title="基本思想"></a>基本思想</h4><ul>
<li>循环冗余校验（Cyclic Redundancy Check，CRC）</li>
<li>数据发送、接受方<strong>共同约定一个“除数”</strong></li>
<li>K个信息位+R个校验位 作为“被除数”，<strong>添加校验位以保证除法的余数为 0</strong><ul>
<li>收到数据后，进行除法检查余数是否为0</li>
<li>若余数非 0 说明出错，则进行重传或纠错</li>
</ul>
</li>
</ul>
<h4 id="构造、检错、纠错"><a href="#构造、检错、纠错" class="headerlink" title="构造、检错、纠错"></a>构造、检错、纠错</h4><ul>
<li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part2/image-20211004164514722.png" alt="image-20211004164514722" style="zoom:100%;"></li>
<li>流程：<ol>
<li>题目给出生成多项式、信息码</li>
<li>K = 信息码的长度 = 6，R = 生成多项式最高次幂 = 3 =&gt; 校验码位数 N = K + R = 9</li>
<li>信息码左移 R 位，低位补 0。利用生成多项式系数进行模2除法，得余数为校验码。</li>
<li>将接受到的码字用生成多项式进行模2除法，余数为000则代表没有出错，否则不然。</li>
</ol>
</li>
<li>循环冗余校验码的检错、纠错特性：<ul>
<li>可检测出所有奇数个错误</li>
<li>可检测出所有双比特的错误</li>
<li>可检测出所有小于等于校验位长度的连续错误</li>
<li>对于确定的生成多项式，出错位与余数是相对应的</li>
<li>当码字长度超出检错码可表示的能力时，出错位与余数的对应关系将进行循环</li>
<li>K个信息位，R个校验位，若生成多项式选择得当，且 2^R^≥K+R+1，则 CRC 码可纠正1位错</li>
</ul>
</li>
</ul>
<h2 id="定点数的表示与运算"><a href="#定点数的表示与运算" class="headerlink" title="定点数的表示与运算"></a>定点数的表示与运算</h2><blockquote>
<ul>
<li>定点数：小数点的位置固定（定点数也包含小数）<ul>
<li>常规计数</li>
<li>Eg：996.007</li>
</ul>
</li>
<li>浮点数：小数点的位置不固定<ul>
<li>科学计数法</li>
<li>Eg：9.96007*102</li>
</ul>
</li>
</ul>
</blockquote>
<h3 id="定点数的表示"><a href="#定点数的表示" class="headerlink" title="定点数的表示"></a>定点数的表示</h3><h4 id="无符号数的定点表示"><a href="#无符号数的定点表示" class="headerlink" title="无符号数的定点表示"></a>无符号数的定点表示</h4><ul>
<li>无符号数：<strong>整个机器字长的全部二进制位均为数值位</strong>，没有符号位，相当于数的绝对值。</li>
<li>通常只有无符号整数，而没有无符号小数（unsigned int/long）</li>
<li>表示范围：<strong>n 位 bit 的无符号数表示范围为：0 ～ 2n-1</strong><ul>
<li>Eg：8位二进制数： 2^8^ 种不同的状态，表示 0000 0000 ～ 1111 1111，即 0 ~ 255</li>
</ul>
</li>
</ul>
<h4 id="有符号数的定点表示"><a href="#有符号数的定点表示" class="headerlink" title="有符号数的定点表示"></a>有符号数的定点表示</h4><ul>
<li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part2/image-20211007120237263.png" alt="image-20211007120237263" style="zoom:100%;"></li>
<li>可用 <strong>原码、反码、补码</strong> 三种方式来表示定点整数和定点小数。还可用 <strong>移码</strong> 表示定点整数。</li>
<li>若真值为 x，则用 <strong>[x]原、[x]反、[x]补、[x]移</strong> 分别表示真值所对应的原码、反码、补码、移码</li>
<li>若机器字长为 n+1 位，则符号位占 1 位，尾数占 n 位</li>
<li>表示定点整数，默认小数点隐含在尾数后；表示定点小数，默认小数点隐含在符号位后尾数前。</li>
</ul>
<h5 id="原码表示定点整数和定点小数"><a href="#原码表示定点整数和定点小数" class="headerlink" title="原码表示定点整数和定点小数"></a>原码表示定点整数和定点小数</h5><ul>
<li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part2/image-20211007121910742.png" alt="image-20211007121910742" style="zoom:100%;"></li>
<li>未指明机器字长时，整数尾数前端的 0 可略去，小数尾数后端的 0 可略去。</li>
<li>要注意<strong>第一位是符号位</strong>，切不能当成数值。</li>
<li>整数原码常用 <strong>逗号</strong> 分割符号位和尾数，小数原码常用 <strong>小数点</strong> 分割符号位和尾数。</li>
<li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part2/image-20211007123125347.png" alt="image-20211007123125347" style="zoom:100%;"></li>
<li>在整数和小数的原码表示中，<strong>真值 0 有 +0 和 -0 两种形式</strong>，即两种二进制状态对应了同一种真值。<ul>
<li>因此即使机器字长为 n+1 位，理论上能够表示 2^n+1^ 种情况，但实际上值表示了 <strong>2^n+1^-1</strong> 种。</li>
</ul>
</li>
<li>原码整数表示范围：**-(2^n^-1)≤x≤2^n^-1<strong>；源码小数表示范围：</strong>-(1-2^n^)≤x≤1-2^n^**。</li>
</ul>
<h5 id="反码表示定点整数和定点小数"><a href="#反码表示定点整数和定点小数" class="headerlink" title="反码表示定点整数和定点小数"></a>反码表示定点整数和定点小数</h5><ul>
<li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part2/image-20211007124524338.png" alt="image-20211007124524338" style="zoom:100%;"></li>
<li>反码：<strong>若符号位为0，则反码与原码相同；若符号位为1，则数值位全部取反。</strong></li>
<li>表示范围和源码相同。</li>
</ul>
<blockquote>
<p>“反码”只是“原码”转变为“补码”的一个中间状态，实际中并没什么卵用——并没有解决“真值 0 有 +0 和 -0 两种形式”这个问题。</p>
</blockquote>
<h5 id="补码表示定点整数和定点小数"><a href="#补码表示定点整数和定点小数" class="headerlink" title="补码表示定点整数和定点小数"></a>补码表示定点整数和定点小数</h5><ul>
<li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part2/image-20211007131951644.png" alt="image-20211007131951644" style="zoom:100%;"></li>
<li>补码：正数的补码=原码；负数的补码=反码末位+1（要考虑进位）</li>
<li>补码的真值 0 只有一种表示形式：[+0]补= [-0]补= 00000000<ul>
<li>定点整数<ul>
<li>[-2^7^]补 = **1,**0000000</li>
<li>表示范围：−2^n^ ≤ x ≤ 2^n^−1</li>
</ul>
</li>
<li>定点小数<ul>
<li>[-1]补 = **1.**0000000 </li>
<li>表示范围：-1 ≤ x ≤ 1-2^-n^</li>
</ul>
</li>
</ul>
</li>
<li><strong>由 [x]补 快速求 [-x]补 的方法：符号位、数值位全部取反，末位+1</strong></li>
</ul>
<h5 id="移码表示定点整数"><a href="#移码表示定点整数" class="headerlink" title="移码表示定点整数"></a>移码表示定点整数</h5><ul>
<li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part2/image-20211007143059138.png" alt="image-20211007143059138" style="zoom:100%;"></li>
<li>移码：<strong>补码的基础上将符号位取反</strong>。注意：<strong>移码只能用于表示整数</strong>。</li>
<li>移码表示的整数很方便对比大小</li>
<li>在浮点数中将大量是使用源码</li>
</ul>
<h3 id="原码补码移码的作用"><a href="#原码补码移码的作用" class="headerlink" title="原码补码移码的作用"></a>原码补码移码的作用</h3><ul>
<li>无符号数：可以进行直接加减运算。</li>
<li>原码的加减运算：需要将符号位单独区分，但是这样将增加硬件成本、计算复杂度。<ul>
<li>因此需要用加法运算来代替减法运算 =&gt; 将减法操作转换成取模运算（例如：-3mod12=9）</li>
</ul>
</li>
<li>补码的本质：为了能够进行直接加运算，将系统设计成了循环。</li>
<li>反码的本质：将原码的负数部分进行了反转，是补码能够循环的铺垫。</li>
<li>移码的本质：使用偏置将补码的循环提前了半个周期。</li>
</ul>
<table>
<thead>
<tr>
<th>二进制机器数</th>
<th>二进制表示无符号数</th>
<th>二进制表示原码</th>
<th>二进制表示反码</th>
<th>二进制表示补码</th>
<th>二进制表示移码</th>
</tr>
</thead>
<tbody><tr>
<td>0000 0000</td>
<td><strong>0</strong></td>
<td><strong>+0</strong></td>
<td><strong>+0</strong></td>
<td><strong>±0</strong></td>
<td>-128</td>
</tr>
<tr>
<td>0000 0001</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>-127</td>
</tr>
<tr>
<td>……</td>
<td>……</td>
<td>……</td>
<td>……</td>
<td>……</td>
<td>……</td>
</tr>
<tr>
<td>0111 1111</td>
<td>127</td>
<td>127</td>
<td>127</td>
<td>127</td>
<td>-1</td>
</tr>
<tr>
<td>1000 0000</td>
<td>128</td>
<td><strong>-0</strong></td>
<td>-127</td>
<td>-128</td>
<td><strong>±0</strong></td>
</tr>
<tr>
<td>1000 0001</td>
<td>129</td>
<td>-1</td>
<td>-126</td>
<td>-127</td>
<td>1</td>
</tr>
<tr>
<td>……</td>
<td>……</td>
<td>……</td>
<td>……</td>
<td>……</td>
<td>……</td>
</tr>
<tr>
<td>1111 1111</td>
<td>255</td>
<td>-127</td>
<td><strong>-0</strong></td>
<td>-1</td>
<td>127</td>
</tr>
</tbody></table>
<ul>
<li>带余除法——设 x, m∈Z, m&gt;0 则存在唯一决定的整数 q 和 r，使得：x = q*m + r , 0 ≤ r &lt; m <ul>
<li>(mod 12) 把所有整数分为 12 类（余数为 0~11）</li>
<li>(mod 12) 余数相同的数，都是同一类，都是等价的</li>
<li>在 (mod m) 的条件下，若能<strong>找到负数的补数</strong>，就可以<strong>用正数的加法来等价替代减法</strong><ul>
<li>若二个数绝对值之和=模，则称这两个数互为补数</li>
</ul>
</li>
<li><strong>模 - a的绝对值 = a的补数</strong></li>
<li>↑ 这是补码的原生定义</li>
</ul>
</li>
<li>反码 + 原码 + 1 = 模</li>
<li>补码的作用： 使用补码可将减法操作转变为等价的加法，ALU 中无需集成减法器。执行加法操作时，符号位一起参与运算。</li>
</ul>
<h3 id="移位运算"><a href="#移位运算" class="headerlink" title="移位运算"></a>移位运算</h3><h4 id="算数移位"><a href="#算数移位" class="headerlink" title="算数移位"></a>算数移位</h4><ul>
<li><p>移位：通过改变各个数码位和小数点的相对位置，从而改变各数码位的位权。可用移位运算实现乘法、除法</p>
</li>
<li><p>原码的算数移位——<strong>符号位保持不变，仅对数值位进行移位</strong>。</p>
<ul>
<li>右移：高位补0，低位舍弃。若舍弃的位=0，<strong>则相当于÷2</strong>；若舍弃的位≠0，则会丢失<strong>精度</strong></li>
<li>左移：低位补0，高位舍弃。若舍弃的位=0，<strong>则相当于×2</strong>；若舍弃的位≠0，则会出现<strong>严重误差</strong></li>
</ul>
</li>
<li><p>反码的算数移位</p>
<ul>
<li>正数的反码与原码相同，因此对正数反码的移位运算也和原码相同。<ul>
<li>右移：<strong>高位补0</strong>，低位舍弃。</li>
<li>左移：<strong>低位补0</strong>，高位舍弃。</li>
</ul>
</li>
<li>负数的反码数值位与原码相反，因此负数反码的移位在补位上有所变化。<ul>
<li>右移：<strong>高位补1</strong>，低位舍弃。</li>
<li>左移：<strong>低位补1</strong>，高位舍弃。</li>
</ul>
</li>
</ul>
</li>
<li><p>补码的算数移位</p>
<ul>
<li>正数的补码与原码相同，因此对正数补码的移位运算也和原码相同。<ul>
<li>右移：<strong>高位补0</strong>，低位舍弃。</li>
<li>左移：<strong>低位补0</strong>，高位舍弃。</li>
</ul>
</li>
<li>负数补码=反码末位+1，导致反码最右边几个连续的1都因进位而变为0，直到进位碰到第一个0为止。<ul>
<li>负数补码中：最右边的1及其右边同原码；最右边的1的左边同反码负数补码。</li>
<li>右移（同反码）：<strong>高位补1</strong>，低位舍弃。</li>
<li>左移（同原码）：<strong>低位补0</strong>，高位舍弃。</li>
</ul>
</li>
</ul>
</li>
<li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part2/image-20211008121454539.png" alt="image-20211008121454539" style="zoom:100%;">
</li>
<li><p>Eg：-20×7 = -20×(2^0^+2^1^+2^2^) = (-20左移0位) + (-20左移1位) + (-20左移2位)</p>
</li>
</ul>
<h4 id="逻辑移位"><a href="#逻辑移位" class="headerlink" title="逻辑移位"></a>逻辑移位</h4><ul>
<li>逻辑右移：高位补0，低位舍弃。</li>
<li>逻辑左移：低位补0，高位舍弃。</li>
<li>可以把逻辑移位看作是对“无符号数”的算数移位</li>
<li>Eg：<img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part2/image-20211008122429002.png" alt="image-20211008122429002" style="zoom:100%;"></li>
</ul>
<h4 id="循环移位"><a href="#循环移位" class="headerlink" title="循环移位"></a>循环移位</h4><ul>
<li>不带进位位：用<strong>移出的位补上空缺</strong></li>
<li>带进位位：用<strong>进位位的值补上空缺</strong>，而<strong>移出的位放到进位位</strong></li>
<li>Eg：交换高低位字节时常用（大端存储&lt;=&gt;小端存储）</li>
</ul>
<h3 id="加减运算和溢出判断"><a href="#加减运算和溢出判断" class="headerlink" title="加减运算和溢出判断"></a>加减运算和溢出判断</h3><h4 id="原码的加减法"><a href="#原码的加减法" class="headerlink" title="原码的加减法"></a>原码的加减法</h4><ul>
<li>要考虑 2*2 种情况，并且同时实现加法器和减法器</li>
<li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part2/image-20211008124354552.png" alt="image-20211008124354552">

</li>
</ul>
<h4 id="补码的加减法"><a href="#补码的加减法" class="headerlink" title="补码的加减法"></a>补码的加减法</h4><ul>
<li><p>负数的补码转原码：</p>
<ul>
<li>数值位取反，+1</li>
<li>-1，数值位取反</li>
<li>负数补码中，最右边的1及其右边同原码，最右边的1的左边同反码</li>
</ul>
</li>
<li><p>[(负数)]补 &lt;=&gt; [(负数)]原：<strong>取负数补码最右边的一位1，其本身与其右侧不变，左侧数值位全部取反</strong>。（常用）</p>
</li>
<li><p>[x]补 =&gt; [-x]补：<strong>连同符号位一起取反加1</strong>。</p>
</li>
</ul>
<h4 id="溢出判断"><a href="#溢出判断" class="headerlink" title="溢出判断"></a>溢出判断</h4><ul>
<li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part2/image-20211008151859101.png" alt="image-20211008151859101"></li>
<li>溢出情况：<ul>
<li>只有“正数+正数 ”才会上溢 —— 正+正=负</li>
<li>只有“负数+负数 ”才会下溢 —— 负+负=正</li>
</ul>
</li>
<li>判断方法：<ul>
<li>法一：采用一位符号位设 A 的符号为 A<del>S</del>，B 的符号为 B<del>S</del>，运算结果的符号为 S<del>S</del>，则溢出逻辑表达式为：<ul>
<li>$V = A_{s}B_{s}\overline{S_{s}} + \overline{A_{s}}\overline{B_{s}}S_{s}$</li>
<li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part2/image-20211008163931615.png" alt="image-20211008163931615" style="zoom:100%;"></li>
<li>若 V=0，表示无溢出；若 V=1，表示有溢出。</li>
<li><strong>A<del>S</del> 为 1 且 B<del>S</del> 为 1 且 S<del>S</del> 为 0</strong> 或 <strong>A<del>S</del> 为 0 且 B<del>S</del> 为 0 且 S<del>S</del> 为 1</strong>。</li>
</ul>
</li>
<li>法二：采用一位符号位，根据数据位进位情况判断溢出符号位的进位 C<del>S</del>，最高数值位的进位 C<del>1</del><ul>
<li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part2/image-20211008163814192.png" alt="image-20211008163814192" style="zoom:100%;"></li>
<li>$V=C_{S}⊕ C_{1}$</li>
<li>若 V=0，表示无溢出；若 V=1，表示有溢出。</li>
<li><strong>最高数值位进位且符号位不进位</strong> 或 <strong>符号位进位而最高数值位不进位</strong>。</li>
</ul>
</li>
<li>法三：<ul>
<li>采用双符号位：正数符号为 00，负数符号为 11</li>
<li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part2/image-20211008163848872.png" alt="image-20211008163848872" style="zoom:100%;"></li>
<li>记两个符号位为 S<del>S1</del>S<del>S2</del> ，则 $V=S_{S1}\otimes S_{S2}$。若 V=0，表示无溢出；若 V=1，表示有溢出。</li>
<li><strong>第一个符号位表明应该得到的符号，第二个符号位表明实际得到的符号。</strong></li>
<li>双符号位补码又称：模 4 补码；单符号位补码又称：模 2 补码。</li>
<li>实际存储时只存储一个符号位，运算时会复制一个符号位</li>
</ul>
</li>
</ul>
</li>
<li>同+同=异  =&gt;  发生溢出</li>
</ul>
<h4 id="符号扩展"><a href="#符号扩展" class="headerlink" title="符号扩展"></a>符号扩展</h4><ul>
<li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part2/image-20211008164330993.png" alt="image-20211008164330993" style="zoom:100%;"></li>
<li>定点整数的符号扩展：在原符号位和数值位<strong>中间</strong>添加新位，正数都添0；负数<strong>原码添0，反码、补码添1</strong></li>
<li>定点小数的符号扩展：在原符号位和数值位<strong>后面</strong>添加新位，正数都添0；负数<strong>原码、补码添0，反码添1</strong></li>
</ul>
<h3 id="乘法运算"><a href="#乘法运算" class="headerlink" title="乘法运算"></a>乘法运算</h3><h4 id="乘法运算的实现思想"><a href="#乘法运算的实现思想" class="headerlink" title="乘法运算的实现思想"></a>乘法运算的实现思想</h4><ul>
<li>用移位实现乘数累加</li>
<li>Eg：0.1101×0.1011 = (1101×1×2^-8^ ) + (1101×1×2^-7^) + (1101×0×2^-6^) + (1101×1×2^-5^)</li>
</ul>
<h4 id="原码的一位乘法"><a href="#原码的一位乘法" class="headerlink" title="原码的一位乘法"></a>原码的一位乘法</h4><ul>
<li><strong>符号单独处理</strong>：符号位 = x<del>s</del>⊕y<del>s</del></li>
<li><strong>数值位取绝对值进行乘法</strong>计算</li>
<li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part2/image-20211009130101904.png" alt="image-20211009130101904" style="zoom:100%;"></li>
<li>在机器实现乘法中：<ul>
<li>ACC 存放<strong>乘积高位</strong>，MQ 存放<strong>乘数与乘积低位</strong>，X 存放<strong>被乘数</strong></li>
<li>在正式进行乘法之前，<strong>ACC 置零</strong></li>
<li>先将 X 中被乘数与 MQ 最低位的乘积结果<strong>加到 ACC 中</strong></li>
<li>再将 ACC、MQ 整体<strong>逻辑右移</strong>一位<ul>
<li>逻辑右移，高位补零</li>
<li>ACC 的低位移到 MQ 的高位</li>
<li>MQ 的低位用完之后直接丢弃</li>
<li>此时，AC、MQ 中运算得到的位上的结果称作<strong>部分积</strong></li>
</ul>
</li>
<li>数值位一共 n 位，则<strong>循环 n 次</strong><ul>
<li>乘数的符号位不用参与运算。ACC+MQ 是一个整体，而 MQ 由取绝对值，所以最多只有 4 为有效，原本的符号位不会对结果造成影响。</li>
<li>小数点隐含位置在 ACC 的第二位</li>
</ul>
</li>
<li><strong>修改 ACC 的符号位</strong>：x<del>s</del>⊕y<del>s</del>=1</li>
</ul>
</li>
<li>之所以称为“一位乘法”是因为每次都使用 MQ 的最后一位进行乘积相加，还有更快的“二位乘法”但不做要求。</li>
<li>Tips：<ul>
<li>乘数的符号位不参与运算，可以省略</li>
<li>原码一位乘可以只用单符号位，也可以用双符号位</li>
<li>答题时最终结果最好写为原码机器数</li>
</ul>
</li>
</ul>
<h4 id="补码的一位乘法（Booth算法）"><a href="#补码的一位乘法（Booth算法）" class="headerlink" title="补码的一位乘法（Booth算法）"></a>补码的一位乘法（Booth算法）</h4><ul>
<li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part2/image-20211009134039359.png" alt="image-20211009134039359" style="zoom:100%;"></li>
<li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part2/image-20211009143142389.png" alt="image-20211009143142389" style="zoom:100%;"></li>
<li>机器实现补码乘法时：<ul>
<li>MQ 相比原码乘法需要在最低位后面加一位辅助位。同时 CPU 中寄存器大小应当一致，所以<ul>
<li>ACC、X 使用<strong>双符号位</strong>，MQ 使用<strong>单符号位以及一位辅助位</strong>，部分积也是使用<strong>双符号位</strong></li>
</ul>
</li>
<li>与原码乘法不同，每次加法是：<code>ACC + [(辅助位-MQ最低位)x]补</code></li>
<li>与原码乘法不同，每次移位是：<strong>补码的算数移位</strong><ul>
<li>符号位不动，数值位右移，正数右移补0，负数右移补1（符号位是啥就补啥）</li>
</ul>
</li>
<li>加法与移位的循环分别是 n+1 和 n 次，即<strong>乘数的单符号位也会参与计算</strong></li>
<li>与原码乘法不同，最后的符号确定已在计算过程中完成，无需再次校验。</li>
</ul>
</li>
</ul>
<h3 id="除法运算"><a href="#除法运算" class="headerlink" title="除法运算"></a>除法运算</h3><h4 id="除法运算的实现思想"><a href="#除法运算的实现思想" class="headerlink" title="除法运算的实现思想"></a>除法运算的实现思想</h4><ul>
<li>被除数、余数本质相同，是我们还需要去拼凑的数</li>
<li>商是我们尽可能去接近需要拼凑的数但不能超过</li>
</ul>
<h4 id="原码的除法运算"><a href="#原码的除法运算" class="headerlink" title="原码的除法运算"></a>原码的除法运算</h4><h5 id="恢复余数法"><a href="#恢复余数法" class="headerlink" title="恢复余数法"></a>恢复余数法</h5><ul>
<li>ACC 放被除数和余数，MQ 放商，X 放除数</li>
<li><strong>符号单独处理</strong>：符号位 = x<del>s</del>⊕y<del>s</del></li>
<li><strong>数值位取绝对值进行除法</strong>计算</li>
<li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part2/image-20211011153443169.png" alt="image-20211011153443169" style="zoom:100%;"></li>
<li>在机器实现除法中：<ul>
<li>在正式进行乘法之前，<strong>MQ 置零</strong></li>
<li>首先<strong>默认商/MQ最低位为 1</strong>，将除数的相反数的补码与被除数/余数（ ACC ）相加（将 ACC 减去除数）<ul>
<li>(ACC)+ [−|y|]补 -&gt; ACC</li>
<li><strong>若相减之后余数符号位为 1</strong>（小于 0），则表明商不应该为 1，而是 0</li>
<li><strong>则将 ACC 的值再次加上除数</strong>，恢复成原样</li>
<li>并<strong>将商改成 0</strong></li>
<li>若最后一步余数是负数，则一样要进行上面的纠正</li>
</ul>
</li>
<li>ACC、MQ 整体逻辑左移<ul>
<li>MQ 低位补零</li>
<li>ACC 高位丢弃</li>
</ul>
</li>
<li>机器字长有 n+1 位，就要算 n+1 位的商，左移 n 次</li>
<li><strong>修改 MQ 的符号位</strong>：x<del>s</del>⊕y<del>s</del>=0</li>
</ul>
</li>
</ul>
<h5 id="不恢复余数法（加减交替法）"><a href="#不恢复余数法（加减交替法）" class="headerlink" title="不恢复余数法（加减交替法）"></a>不恢复余数法（加减交替法）</h5><ul>
<li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part2/image-20211011155159488.png" alt="image-20211011155159488" style="zoom:100%;"></li>
<li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part2/image-20211011154706460.png" alt="image-20211011154706460" style="zoom:100%;"></li>
<li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part2/image-20211011155635905.png" alt="image-20211011155635905" style="zoom:100%;"></li>
<li>当余数（ACC）为负时，商 0<ul>
<li>恢复余数法：+|除数（X）|，再左移，再-|除数（X）|</li>
<li>加减交替法：左移，再+|除数（X）|</li>
</ul>
</li>
<li>在加减交替法中<ul>
<li>余数（ACC）的正负性与商相同</li>
<li>符号位同样需要额外判定</li>
<li>若最后的余数（ACC）为负，需商0，并+[|y|]补得到正确余数</li>
</ul>
</li>
</ul>
<h4 id="补码的除法运算（加减交替法）"><a href="#补码的除法运算（加减交替法）" class="headerlink" title="补码的除法运算（加减交替法）"></a>补码的除法运算（加减交替法）</h4><ul>
<li>符号位参与运算</li>
<li>被除数/余数、除数采用双符号位</li>
<li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part2/image-20211014133724204.png" alt="image-20211014133724204" style="zoom:100%;"></li>
<li>第一步，比较<strong>被除数</strong>（ACC）和除数（X）符号<ul>
<li>同号，则被除数-除数</li>
<li>异号，则被除数+除数</li>
</ul>
</li>
<li>然后，比较<strong>余数</strong>（ACC）和除数（X）符号（每次循环保证两者相加符号不同，结果与被除）<ul>
<li>同号，<strong>商1</strong>，余数左移，减去除数</li>
<li>异号，<strong>商0</strong>，余数左移，加上除数</li>
</ul>
</li>
<li>重复 n 次</li>
<li>MQ 的最后一位恒置 1（精度误差不超过 2^-n^）</li>
</ul>
<h4 id="除法运算总结"><a href="#除法运算总结" class="headerlink" title="除法运算总结"></a>除法运算总结</h4><table>
<thead>
<tr>
<th>除法类型</th>
<th>符号位参与运算</th>
<th>加减次数</th>
<th>移位方向</th>
<th>移位次数</th>
<th>上商、加减原则</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>原码加减交替法</td>
<td>否</td>
<td>N+1 或 N+2</td>
<td>左</td>
<td>N</td>
<td>余数的正负</td>
<td>若最终余数为负，则恢复余数</td>
</tr>
<tr>
<td>补码加减交替法</td>
<td>是</td>
<td>N+1</td>
<td>左</td>
<td>N</td>
<td>余数和除数是否同号</td>
<td>商末位恒置 1</td>
</tr>
</tbody></table>
<h3 id="强制类型转换"><a href="#强制类型转换" class="headerlink" title="强制类型转换"></a>强制类型转换</h3><ul>
<li>C 语言中定点整数（int、long、short）是用<strong>补码</strong>存储的。</li>
<li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part2/image-20211015192650002.png" alt="image-20211015192650002" style="zoom:100%;">

</li>
</ul>
<h3 id="数据的存储和排列"><a href="#数据的存储和排列" class="headerlink" title="数据的存储和排列"></a>数据的存储和排列</h3><ul>
<li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part2/image-20211015195134394.png" alt="image-20211015195134394" style="zoom:100%;"></li>
<li>最高有效字节（<strong>MSB</strong>）最低有效字节（<strong>LSB</strong>）</li>
<li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part2/image-20211015200927531.png" alt="image-20211015200927531"></li>
<li>现代计算机<strong>通常是按字节编址</strong>，即每个字节对应1个地址<ul>
<li>通常也支持按字、按半字、按字节寻址</li>
</ul>
</li>
<li>假设存储字长为32位，则1个字=32bit，半字=16bit<ul>
<li>要将按字寻址转成按字节寻址，则将值左移2位</li>
</ul>
</li>
<li><strong>每次访存只能读/写1个字</strong></li>
<li>c语言的数据类型长度<ul>
<li>char：1字节</li>
<li>short：2字节</li>
<li>int：4字节</li>
<li>long：8字节</li>
</ul>
</li>
<li>使用<strong>边界对齐方式</strong>可以<strong>提高读取效率</strong>，而使用<strong>边界不对齐方式</strong>可以<strong>减少存储开销</strong>。</li>
</ul>
<h2 id="浮点数的表示与运算"><a href="#浮点数的表示与运算" class="headerlink" title="浮点数的表示与运算"></a>浮点数的表示与运算</h2><h3 id="浮点数的表示"><a href="#浮点数的表示" class="headerlink" title="浮点数的表示"></a>浮点数的表示</h3><h4 id="浮点数的作用和基本原理"><a href="#浮点数的作用和基本原理" class="headerlink" title="浮点数的作用和基本原理"></a>浮点数的作用和基本原理</h4><ul>
<li>针对问题：定点数可表示的数字范围有限，但我们不能无限制地增加数据的长度</li>
<li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part2/image-20211016153947660.png" alt="image-20211016153947660"></li>
<li>阶码：常用补码或移码表示的定点整数</li>
<li>尾数：常用原码或补码表示的定点小数</li>
<li>浮点数的真值：N=r^E^×M<ul>
<li>阶码的底 r，通常为 2</li>
<li>阶码 E 反映浮点数的<strong>表示范围</strong>及小数点的实际位置</li>
<li>尾数 M 的数值部分的位数 n 反映浮点数的<strong>精度</strong></li>
<li>尾数给出一个小数，阶码正负与数值指明了尾数左移/右移(小数点向后/向前移动)几位。</li>
</ul>
</li>
</ul>
<h4 id="浮点数规格化"><a href="#浮点数规格化" class="headerlink" title="浮点数规格化"></a>浮点数规格化</h4><ul>
<li>规格化浮点数：规定尾数的最高数值位必须是一个有效值 。</li>
<li>左规：当浮点数运算的结果为非规格化（尾数的最高数值位为 0）时，将尾数算数左移 1 位，阶码减 1。<ul>
<li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part2/image-20211016194214228.png" alt="image-20211016194214228"></li>
</ul>
</li>
<li>右规：当浮点数运算的结果尾数出现溢出（双符号位为01或10）时，将尾数算数右移 1 位，阶码加 1。<ul>
<li>第一位符号位是正确的符号位</li>
<li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part2/image-20211016194118837.png" alt="image-20211016194118837"></li>
</ul>
</li>
<li>规格化浮点数的特点：<ul>
<li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part2/image-20211016204436786.png" alt="image-20211016204436786"></li>
<li>规格化的原码尾数，最高数值位一定是 1</li>
<li>规格化的补码尾数，符号位与最高数值位一定相反</li>
</ul>
</li>
</ul>
<h4 id="浮点数表示范围（大纲外）"><a href="#浮点数表示范围（大纲外）" class="headerlink" title="浮点数表示范围（大纲外）"></a>浮点数表示范围（大纲外）</h4><ul>
<li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part2/image-20211016204413711.png" alt="image-20211016204413711"></li>
<li>对于下溢，只需要当做0处理</li>
<li>对于上溢，必须作为异常</li>
</ul>
<h3 id="浮点数标准IEEE75"><a href="#浮点数标准IEEE75" class="headerlink" title="浮点数标准IEEE75"></a>浮点数标准IEEE75</h3><ul>
<li><p>读音：I triple E——IEEE</p>
</li>
<li><p>移码的定义：<strong>移码 = 真值 + 偏置值</strong>（偏置值并不固定）</p>
<ul>
<li>在之前所学的移码中：偏置值为 128D=1000 0000B，即 2^n-1^</li>
<li>在 IEEE75 中，偏置值为 <strong>127D=0111 1111B</strong>，即 <strong>2^n-1^-1</strong></li>
</ul>
</li>
<li><p><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part2/image-20211018121445755.png" alt="image-20211018121445755"></p>
</li>
<li></li>
<li><p>阶码全1、全0时用作特殊用途。因此阶码的正常范围：**-126~127**</p>
<ul>
<li>规格化短浮点真值：(-1)^s^×1.M×2^E-127^</li>
<li>规格化长浮点真值：(-1)^s^×1.M×2^E-1023^</li>
<li>计算<strong>移码/阶码的真值</strong>时，不用在二进制上面计算，可以<strong>先把看见的移码当做无符号数计算值</strong>，然后<strong>减去偏置值127</strong></li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th>类型</th>
<th>数符</th>
<th>阶码</th>
<th>尾数</th>
<th>总位数</th>
<th>偏置值（十六进制）</th>
<th>偏置值（十进制）</th>
</tr>
</thead>
<tbody><tr>
<td>短浮点数(float)</td>
<td>1</td>
<td>8</td>
<td>23</td>
<td>32</td>
<td>7FH</td>
<td>127</td>
</tr>
<tr>
<td>长浮点数(double)</td>
<td>1</td>
<td>11</td>
<td>52</td>
<td>64</td>
<td>3FFH</td>
<td>1023</td>
</tr>
<tr>
<td>临时浮点数(long double)</td>
<td>1</td>
<td>15</td>
<td>64</td>
<td>80</td>
<td>3FFFH</td>
<td>16383</td>
</tr>
</tbody></table>
<ul>
<li><p><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part2/image-20211018115935229.png" alt="image-20211018115935229"></p>
</li>
<li><p>IEEE 754 单精度浮点型能表示的最小绝对值、最大绝对值</p>
<ul>
<li>最小绝对值：尾数全为0，阶码真值最小-126，对应移码机器数 0000 0001。此时整体的真值为 (1.0)<del>2</del>×2^-126^</li>
<li>最大绝对值：尾数全为1，阶码真值最大 127，对应移码机器数 1111 1110。此时整体的真值为 (1.111…11)<del>2</del>×2^127^</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th>格式</th>
<th>格式化的最小绝对值</th>
<th>格式化的最大绝对值</th>
</tr>
</thead>
<tbody><tr>
<td>单精度</td>
<td>E=1，M=0：1.0×2^1−127^=2^-126^</td>
<td>E=254，M=.11…1：1.11…1×2^254−127^=2^127^×(2−2^−23^)</td>
</tr>
<tr>
<td>双精度</td>
<td>E=1，M=0：1.0×2^1−1023^=2^-1022^</td>
<td>E=254，M=.11…1：1.11…1×2^2046−1023^=2^1023^×(2−2^−52^)</td>
</tr>
</tbody></table>
<ul>
<li><strong>只有 1≤E≤254时，真值 = (−1)^s^×1.M×2^E−127^</strong></li>
<li>当阶码E全为0<ul>
<li>尾数M不全为0时，表示非规格化小数 ±(0.xx…x)<del>2</del>×2^-126^<ul>
<li>隐含最高位变为 0</li>
<li>阶码真值固定视为 -126</li>
</ul>
</li>
<li>尾数M全为0时，表示真值 ±0</li>
</ul>
</li>
<li>当阶码E全为1<ul>
<li>尾数M不全为0时，表示非数值 “NaN” (Not a Number)<ul>
<li>如：0/0、∞-∞ 等非法运算的结果就是 NaN</li>
</ul>
</li>
<li>尾数M全为0时，表示无穷大 ±∞</li>
</ul>
</li>
</ul>
<blockquote>
<p>由浮点数确定真值（阶码不是全0、也不是全1）：</p>
<ol>
<li>根据“某浮点数”确定数符、阶码、尾数的分布</li>
<li>确定尾数 1.M（注意补充最高的隐含位1）</li>
<li>确定阶码的真值 = 移码 - 偏置值 （可将移码看作无符号数，用无符号数的值减去偏置值）</li>
<li>(−1)^s^×1.M×2^E−偏置值^</li>
</ol>
</blockquote>
<h3 id="浮点数的运算"><a href="#浮点数的运算" class="headerlink" title="浮点数的运算"></a>浮点数的运算</h3><h4 id="浮点数的加减运算"><a href="#浮点数的加减运算" class="headerlink" title="浮点数的加减运算"></a>浮点数的加减运算</h4><ul>
<li>浮点数加减运算步骤<ul>
<li>转换格式（真值D-&gt;机器数B；注意审题：用补/移码表示阶码和尾数）</li>
<li>对阶（使两个数的阶码相等，小阶向大阶看齐，尾数毎右移一位，阶码加1）</li>
<li>尾数加减</li>
<li>规格化</li>
<li>舍入（可以有不同的舍入规则）<ul>
<li>0舍1入：移去为0则舍，为1则入（可能会使尾数又溢出，此时需再做一次右规。）</li>
<li>恒置1：无论移去0还是1，都使右移后的尾数末位置1（这种方法同样有使尾数变大和变小的两种可能。）</li>
</ul>
</li>
<li>判溢出（尾数溢出未必导致整体溢出，只有阶数溢出才是真正的溢出）</li>
</ul>
</li>
<li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part2/image-20211018135039513.png" alt="image-20211018135039513"></li>
</ul>
<h4 id="强制类型转换-1"><a href="#强制类型转换-1" class="headerlink" title="强制类型转换"></a>强制类型转换</h4><table>
<thead>
<tr>
<th>类型</th>
<th>16位机器</th>
<th>32位机器</th>
<th>64位机器</th>
</tr>
</thead>
<tbody><tr>
<td>char</td>
<td>8</td>
<td>8</td>
<td>8</td>
</tr>
<tr>
<td>short</td>
<td>16</td>
<td>16</td>
<td>16</td>
</tr>
<tr>
<td>int</td>
<td>16</td>
<td>32</td>
<td>32</td>
</tr>
<tr>
<td>long</td>
<td>32</td>
<td>32</td>
<td>64</td>
</tr>
<tr>
<td>long long</td>
<td>64</td>
<td>64</td>
<td>64</td>
</tr>
<tr>
<td>float</td>
<td>16</td>
<td>32（23+1）</td>
<td>32</td>
</tr>
<tr>
<td>double</td>
<td>64</td>
<td>64（52+1）</td>
<td>64</td>
</tr>
</tbody></table>
<ul>
<li>没有特殊说明，则默认 32 位机器</li>
<li>无损转换：char -&gt; int -&gt; long -&gt; double；float -&gt; double。<ul>
<li>在 32 位中，这些转换过程没有损失</li>
<li>在 64 位中，long -&gt; double 会出现精度损失</li>
</ul>
</li>
<li>有损转换：int -&gt; float；float -&gt; int<ul>
<li>判断是否会有精度损失，要从有效数字方面考虑</li>
<li>int：表示整数，范围 -2^31^ ～ 2^31^-1 ，有效数字 <strong>32</strong> 位</li>
<li>float：表示整数及小数，范围 ±[2^-126^ ～ 2^127^×(2−2^−23^)]，有效数字 <strong>23+1=24</strong> 位</li>
<li>int -&gt; float：可能损失精度（如 2^24^~2^31^-1 中无法被 float 表示的）</li>
<li>float -&gt; int：可能溢出（范围过大）及损失精度（表示小数）</li>
</ul>
</li>
</ul>
<h2 id="算术逻辑单元（ALU）"><a href="#算术逻辑单元（ALU）" class="headerlink" title="算术逻辑单元（ALU）"></a>算术逻辑单元（ALU）</h2><h3 id="电路的基本原理、加法器设计"><a href="#电路的基本原理、加法器设计" class="headerlink" title="电路的基本原理、加法器设计"></a>电路的基本原理、加法器设计</h3><h4 id="作用与原理"><a href="#作用与原理" class="headerlink" title="作用与原理"></a>作用与原理</h4><ul>
<li>机器字长是 CPU（ALU）一次能够处理的长度，一般等于寄存器的长度。因为输入输出数据存放的寄存器也要和 CPU 处理长度一致。</li>
<li>ALU 的功能。由控制单元 CU 发出的控制信号决定<ul>
<li>算术运算：加、减、乘、除等</li>
<li>逻辑运算：与、或、非、异或等</li>
<li>辅助功能：移位、求补等</li>
</ul>
</li>
</ul>
<h4 id="电路基础知识"><a href="#电路基础知识" class="headerlink" title="电路基础知识"></a>电路基础知识</h4><p><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part2/image-20211018152119179.png" alt="image-20211018152119179"></p>
<h4 id="加法器的实现"><a href="#加法器的实现" class="headerlink" title="加法器的实现"></a>加法器的实现</h4><h5 id="一位全加器"><a href="#一位全加器" class="headerlink" title="一位全加器"></a>一位全加器</h5><p><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part2/image-20211018153352014.png" alt="image-20211018153352014">、</p>
<h5 id="串行加法器"><a href="#串行加法器" class="headerlink" title="串行加法器"></a>串行加法器</h5><p><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part2/image-20211018153857365.png" alt="image-20211018153857365"></p>
<ul>
<li>串行加法器：只有一个全加器，数据逐位串行送入加法器中进行运算。<ul>
<li>进位触发器用来寄存进位信号，以便参与下一次运算。</li>
</ul>
</li>
<li>如果操作数长 n 位，加法就要分 n 次进行，每次产生一位和，并且串行逐位地送回寄存器。</li>
</ul>
<h5 id="并行加法器"><a href="#并行加法器" class="headerlink" title="并行加法器"></a>并行加法器</h5><p><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part2/image-20211018153931233.png" alt="image-20211018153931233"></p>
<ul>
<li>串行进位的并行加法器：把 n 个全加器串接起来，就可进行两个 n 位数的相加。</li>
<li>串行进位又称为行波进位，每一级进位直接依赖于前一级的进位，即进位信号是逐级形成的。</li>
<li>其性能很大程度依赖于 <strong>FA 产生进位</strong>和<strong>传递进位</strong>的速度</li>
</ul>
<h3 id="加法器、ALU的改进"><a href="#加法器、ALU的改进" class="headerlink" title="加法器、ALU的改进"></a>加法器、ALU的改进</h3><ul>
<li>第 i 位向更高位的进位 C<del>i</del> 可根据 <strong>被加数、加数的第 1~i 位</strong>、<strong>C<del>0</del></strong> 即可确定</li>
<li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part2/image-20211018171510387.png" alt="image-20211018171510387"></li>
<li>并行进位的<strong>并行加法器</strong>：各级进位信号同时形成，又称为<strong>先行进位</strong>、<strong>同时进位</strong></li>
<li>为了避免电路过于复杂，设计为 4 个 FA 为一组，组成一个 CLA</li>
<li>G<del>i</del>：进位产生函数。（由本位确定的是否进位）</li>
<li>P<del>i</del>：进位传递函数。（本位会控制/屏蔽前一位的进位信息）</li>
<li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part2/image-20211018172125934.png" alt="image-20211018172125934"></li>
<li>完成组内并行之后，各组之间依然是串行的结构<ul>
<li><strong>单级先行进位方式</strong>，又称为<strong>组内并行、组间串行</strong>进位方式。</li>
</ul>
</li>
<li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part2/image-20211018172358547.png" alt="image-20211018172358547"></li>
<li>通过 CLA 电路，同时产生各组之间的进位信息<ul>
<li><strong>多级先行进位</strong>方式，又称为<strong>组内并行、组间并行</strong>进位方式</li>
</ul>
</li>
<li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part2/image-20211018173324132.png" alt="image-20211018173324132"></li>
</ul>
<h1 id="习题课"><a href="#习题课" class="headerlink" title="习题课"></a>习题课</h1><h2 id="todo"><a href="#todo" class="headerlink" title="todo"></a>todo</h2></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">NephrenCake</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://nephrencake.gitee.io/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part2/">https://nephrencake.gitee.io/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part2/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://nephrencake.gitee.io" target="_blank">浅幽丶奈芙莲的个人博客</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E5%AE%8C%E7%BB%93%E7%9B%AE%E5%BD%95/%E4%BA%8Ced11.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part3/"><img class="prev-cover" src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E5%AE%8C%E7%BB%93%E7%9B%AE%E5%BD%95/%E4%BA%8Ced11.jpg" onerror="onerror=null;src='/img/404.png'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">计算机组成原理-Part3</div></div></a></div><div class="next-post pull-right"><a href="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part1/"><img class="next-cover" src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E5%AE%8C%E7%BB%93%E7%9B%AE%E5%BD%95/%E4%BA%8Ced11.jpg" onerror="onerror=null;src='/img/404.png'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">计算机组成原理-Part1</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part2%E2%80%94%E2%80%94%E6%95%B0%E6%8D%AE%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%92%8C%E8%BF%90%E7%AE%97"><span class="toc-number">1.</span> <span class="toc-text">计算机组成原理-Part2——数据的表示和运算</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E5%88%B6%E4%B8%8E%E7%BC%96%E7%A0%81"><span class="toc-number">1.1.</span> <span class="toc-text">数制与编码</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E4%BD%8D%E8%AE%A1%E6%95%B0%E5%88%B6%E5%8F%8A%E5%85%B6%E7%9B%B8%E4%BA%92%E8%BD%AC%E6%8D%A2"><span class="toc-number">1.1.1.</span> <span class="toc-text">进位计数制及其相互转换</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#r-%E8%BF%9B%E5%88%B6%E8%AE%A1%E6%95%B0%E6%B3%95"><span class="toc-number">1.1.1.1.</span> <span class="toc-text">r 进制计数法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B6%E4%BB%96%E8%BF%9B%E5%88%B6-gt-%E5%8D%81%E8%BF%9B%E5%88%B6"><span class="toc-number">1.1.1.2.</span> <span class="toc-text">其他进制 -&gt; 十进制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E5%85%AB%E3%80%81%E5%8D%81%E5%85%AD%E8%BF%9B%E5%88%B6%E4%B9%8B%E9%97%B4%E7%9B%B8%E4%BA%92%E8%BD%AC%E6%8D%A2"><span class="toc-number">1.1.1.3.</span> <span class="toc-text">二、八、十六进制之间相互转换</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8D%81%E8%BF%9B%E5%88%B6-gt-%E5%85%B6%E4%BB%96%E8%BF%9B%E5%88%B6"><span class="toc-number">1.1.1.4.</span> <span class="toc-text">十进制 -&gt; 其他进制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9C%9F%E5%80%BC%E5%92%8C%E6%9C%BA%E5%99%A8%E6%95%B0"><span class="toc-number">1.1.1.5.</span> <span class="toc-text">真值和机器数</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#BCD%E7%A0%81%EF%BC%88408%E5%A4%A7%E7%BA%B2%E5%B7%B2%E5%88%A0%EF%BC%89"><span class="toc-number">1.1.2.</span> <span class="toc-text">BCD码（408大纲已删）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#8421-%E7%A0%81"><span class="toc-number">1.1.2.1.</span> <span class="toc-text">8421 码</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%99-3-%E7%A0%81"><span class="toc-number">1.1.2.2.</span> <span class="toc-text">余 3 码</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2421-%E7%A0%81"><span class="toc-number">1.1.2.3.</span> <span class="toc-text">2421 码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%8E%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">1.1.3.</span> <span class="toc-text">字符与字符串</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#ASCII-%E7%A0%81"><span class="toc-number">1.1.3.1.</span> <span class="toc-text">ASCII 码</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B1%89%E5%AD%97%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%92%8C%E7%BC%96%E7%A0%81"><span class="toc-number">1.1.3.2.</span> <span class="toc-text">汉字的表示和编码</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">1.1.3.3.</span> <span class="toc-text">字符串</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A5%87%E5%81%B6%E6%A0%A1%E9%AA%8C%E7%A0%81%EF%BC%88%E8%AE%A1%E7%BD%91%E8%A6%81%E8%80%83%EF%BC%89"><span class="toc-number">1.1.4.</span> <span class="toc-text">奇偶校验码（计网要考）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%A1%E9%AA%8C%E5%8E%9F%E7%90%86"><span class="toc-number">1.1.4.1.</span> <span class="toc-text">校验原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A5%87%E5%81%B6%E6%A0%A1%E9%AA%8C%E7%A0%81"><span class="toc-number">1.1.4.2.</span> <span class="toc-text">奇偶校验码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B5%B7%E6%98%8E%E6%A0%A1%E9%AA%8C%E7%A0%81%EF%BC%88%E8%AE%A1%E7%BD%91%E8%A6%81%E8%80%83%EF%BC%89"><span class="toc-number">1.1.5.</span> <span class="toc-text">海明校验码（计网要考）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%80%9D%E6%83%B3"><span class="toc-number">1.1.5.1.</span> <span class="toc-text">基本思想</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B5%B7%E6%98%8E%E7%A0%81%E6%B1%82%E8%A7%A3%E6%AD%A5%E9%AA%A4%EF%BC%88TODO%EF%BC%89"><span class="toc-number">1.1.5.2.</span> <span class="toc-text">海明码求解步骤（TODO）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B5%B7%E6%98%8E%E7%A0%81%E7%9A%84%E6%A3%80%E9%94%99%E3%80%81%E7%BA%A0%E9%94%99%E8%83%BD%E5%8A%9B"><span class="toc-number">1.1.5.3.</span> <span class="toc-text">海明码的检错、纠错能力</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BE%AA%E7%8E%AF%E5%86%97%E4%BD%99%E6%A0%A1%E9%AA%8C%E7%A0%81%EF%BC%88%E8%AE%A1%E7%BD%91%E8%A6%81%E8%80%83%EF%BC%89"><span class="toc-number">1.1.6.</span> <span class="toc-text">循环冗余校验码（计网要考）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%80%9D%E6%83%B3-1"><span class="toc-number">1.1.6.1.</span> <span class="toc-text">基本思想</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E3%80%81%E6%A3%80%E9%94%99%E3%80%81%E7%BA%A0%E9%94%99"><span class="toc-number">1.1.6.2.</span> <span class="toc-text">构造、检错、纠错</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9A%E7%82%B9%E6%95%B0%E7%9A%84%E8%A1%A8%E7%A4%BA%E4%B8%8E%E8%BF%90%E7%AE%97"><span class="toc-number">1.2.</span> <span class="toc-text">定点数的表示与运算</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9A%E7%82%B9%E6%95%B0%E7%9A%84%E8%A1%A8%E7%A4%BA"><span class="toc-number">1.2.1.</span> <span class="toc-text">定点数的表示</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%97%A0%E7%AC%A6%E5%8F%B7%E6%95%B0%E7%9A%84%E5%AE%9A%E7%82%B9%E8%A1%A8%E7%A4%BA"><span class="toc-number">1.2.1.1.</span> <span class="toc-text">无符号数的定点表示</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%89%E7%AC%A6%E5%8F%B7%E6%95%B0%E7%9A%84%E5%AE%9A%E7%82%B9%E8%A1%A8%E7%A4%BA"><span class="toc-number">1.2.1.2.</span> <span class="toc-text">有符号数的定点表示</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8E%9F%E7%A0%81%E8%A1%A8%E7%A4%BA%E5%AE%9A%E7%82%B9%E6%95%B4%E6%95%B0%E5%92%8C%E5%AE%9A%E7%82%B9%E5%B0%8F%E6%95%B0"><span class="toc-number">1.2.1.2.1.</span> <span class="toc-text">原码表示定点整数和定点小数</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8F%8D%E7%A0%81%E8%A1%A8%E7%A4%BA%E5%AE%9A%E7%82%B9%E6%95%B4%E6%95%B0%E5%92%8C%E5%AE%9A%E7%82%B9%E5%B0%8F%E6%95%B0"><span class="toc-number">1.2.1.2.2.</span> <span class="toc-text">反码表示定点整数和定点小数</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%A1%A5%E7%A0%81%E8%A1%A8%E7%A4%BA%E5%AE%9A%E7%82%B9%E6%95%B4%E6%95%B0%E5%92%8C%E5%AE%9A%E7%82%B9%E5%B0%8F%E6%95%B0"><span class="toc-number">1.2.1.2.3.</span> <span class="toc-text">补码表示定点整数和定点小数</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%A7%BB%E7%A0%81%E8%A1%A8%E7%A4%BA%E5%AE%9A%E7%82%B9%E6%95%B4%E6%95%B0"><span class="toc-number">1.2.1.2.4.</span> <span class="toc-text">移码表示定点整数</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8E%9F%E7%A0%81%E8%A1%A5%E7%A0%81%E7%A7%BB%E7%A0%81%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-number">1.2.2.</span> <span class="toc-text">原码补码移码的作用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A7%BB%E4%BD%8D%E8%BF%90%E7%AE%97"><span class="toc-number">1.2.3.</span> <span class="toc-text">移位运算</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%97%E6%95%B0%E7%A7%BB%E4%BD%8D"><span class="toc-number">1.2.3.1.</span> <span class="toc-text">算数移位</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%BB%E8%BE%91%E7%A7%BB%E4%BD%8D"><span class="toc-number">1.2.3.2.</span> <span class="toc-text">逻辑移位</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BE%AA%E7%8E%AF%E7%A7%BB%E4%BD%8D"><span class="toc-number">1.2.3.3.</span> <span class="toc-text">循环移位</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%A0%E5%87%8F%E8%BF%90%E7%AE%97%E5%92%8C%E6%BA%A2%E5%87%BA%E5%88%A4%E6%96%AD"><span class="toc-number">1.2.4.</span> <span class="toc-text">加减运算和溢出判断</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8E%9F%E7%A0%81%E7%9A%84%E5%8A%A0%E5%87%8F%E6%B3%95"><span class="toc-number">1.2.4.1.</span> <span class="toc-text">原码的加减法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A1%A5%E7%A0%81%E7%9A%84%E5%8A%A0%E5%87%8F%E6%B3%95"><span class="toc-number">1.2.4.2.</span> <span class="toc-text">补码的加减法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%BA%A2%E5%87%BA%E5%88%A4%E6%96%AD"><span class="toc-number">1.2.4.3.</span> <span class="toc-text">溢出判断</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AC%A6%E5%8F%B7%E6%89%A9%E5%B1%95"><span class="toc-number">1.2.4.4.</span> <span class="toc-text">符号扩展</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B9%98%E6%B3%95%E8%BF%90%E7%AE%97"><span class="toc-number">1.2.5.</span> <span class="toc-text">乘法运算</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B9%98%E6%B3%95%E8%BF%90%E7%AE%97%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%80%9D%E6%83%B3"><span class="toc-number">1.2.5.1.</span> <span class="toc-text">乘法运算的实现思想</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8E%9F%E7%A0%81%E7%9A%84%E4%B8%80%E4%BD%8D%E4%B9%98%E6%B3%95"><span class="toc-number">1.2.5.2.</span> <span class="toc-text">原码的一位乘法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A1%A5%E7%A0%81%E7%9A%84%E4%B8%80%E4%BD%8D%E4%B9%98%E6%B3%95%EF%BC%88Booth%E7%AE%97%E6%B3%95%EF%BC%89"><span class="toc-number">1.2.5.3.</span> <span class="toc-text">补码的一位乘法（Booth算法）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%99%A4%E6%B3%95%E8%BF%90%E7%AE%97"><span class="toc-number">1.2.6.</span> <span class="toc-text">除法运算</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%99%A4%E6%B3%95%E8%BF%90%E7%AE%97%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%80%9D%E6%83%B3"><span class="toc-number">1.2.6.1.</span> <span class="toc-text">除法运算的实现思想</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8E%9F%E7%A0%81%E7%9A%84%E9%99%A4%E6%B3%95%E8%BF%90%E7%AE%97"><span class="toc-number">1.2.6.2.</span> <span class="toc-text">原码的除法运算</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%81%A2%E5%A4%8D%E4%BD%99%E6%95%B0%E6%B3%95"><span class="toc-number">1.2.6.2.1.</span> <span class="toc-text">恢复余数法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%8D%E6%81%A2%E5%A4%8D%E4%BD%99%E6%95%B0%E6%B3%95%EF%BC%88%E5%8A%A0%E5%87%8F%E4%BA%A4%E6%9B%BF%E6%B3%95%EF%BC%89"><span class="toc-number">1.2.6.2.2.</span> <span class="toc-text">不恢复余数法（加减交替法）</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A1%A5%E7%A0%81%E7%9A%84%E9%99%A4%E6%B3%95%E8%BF%90%E7%AE%97%EF%BC%88%E5%8A%A0%E5%87%8F%E4%BA%A4%E6%9B%BF%E6%B3%95%EF%BC%89"><span class="toc-number">1.2.6.3.</span> <span class="toc-text">补码的除法运算（加减交替法）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%99%A4%E6%B3%95%E8%BF%90%E7%AE%97%E6%80%BB%E7%BB%93"><span class="toc-number">1.2.6.4.</span> <span class="toc-text">除法运算总结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%BA%E5%88%B6%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="toc-number">1.2.7.</span> <span class="toc-text">强制类型转换</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%9A%84%E5%AD%98%E5%82%A8%E5%92%8C%E6%8E%92%E5%88%97"><span class="toc-number">1.2.8.</span> <span class="toc-text">数据的存储和排列</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B5%AE%E7%82%B9%E6%95%B0%E7%9A%84%E8%A1%A8%E7%A4%BA%E4%B8%8E%E8%BF%90%E7%AE%97"><span class="toc-number">1.3.</span> <span class="toc-text">浮点数的表示与运算</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B5%AE%E7%82%B9%E6%95%B0%E7%9A%84%E8%A1%A8%E7%A4%BA"><span class="toc-number">1.3.1.</span> <span class="toc-text">浮点数的表示</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B5%AE%E7%82%B9%E6%95%B0%E7%9A%84%E4%BD%9C%E7%94%A8%E5%92%8C%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86"><span class="toc-number">1.3.1.1.</span> <span class="toc-text">浮点数的作用和基本原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B5%AE%E7%82%B9%E6%95%B0%E8%A7%84%E6%A0%BC%E5%8C%96"><span class="toc-number">1.3.1.2.</span> <span class="toc-text">浮点数规格化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B5%AE%E7%82%B9%E6%95%B0%E8%A1%A8%E7%A4%BA%E8%8C%83%E5%9B%B4%EF%BC%88%E5%A4%A7%E7%BA%B2%E5%A4%96%EF%BC%89"><span class="toc-number">1.3.1.3.</span> <span class="toc-text">浮点数表示范围（大纲外）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B5%AE%E7%82%B9%E6%95%B0%E6%A0%87%E5%87%86IEEE75"><span class="toc-number">1.3.2.</span> <span class="toc-text">浮点数标准IEEE75</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B5%AE%E7%82%B9%E6%95%B0%E7%9A%84%E8%BF%90%E7%AE%97"><span class="toc-number">1.3.3.</span> <span class="toc-text">浮点数的运算</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B5%AE%E7%82%B9%E6%95%B0%E7%9A%84%E5%8A%A0%E5%87%8F%E8%BF%90%E7%AE%97"><span class="toc-number">1.3.3.1.</span> <span class="toc-text">浮点数的加减运算</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%BA%E5%88%B6%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2-1"><span class="toc-number">1.3.3.2.</span> <span class="toc-text">强制类型转换</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%97%E6%9C%AF%E9%80%BB%E8%BE%91%E5%8D%95%E5%85%83%EF%BC%88ALU%EF%BC%89"><span class="toc-number">1.4.</span> <span class="toc-text">算术逻辑单元（ALU）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%B5%E8%B7%AF%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86%E3%80%81%E5%8A%A0%E6%B3%95%E5%99%A8%E8%AE%BE%E8%AE%A1"><span class="toc-number">1.4.1.</span> <span class="toc-text">电路的基本原理、加法器设计</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%9C%E7%94%A8%E4%B8%8E%E5%8E%9F%E7%90%86"><span class="toc-number">1.4.1.1.</span> <span class="toc-text">作用与原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%94%B5%E8%B7%AF%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86"><span class="toc-number">1.4.1.2.</span> <span class="toc-text">电路基础知识</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8A%A0%E6%B3%95%E5%99%A8%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.4.1.3.</span> <span class="toc-text">加法器的实现</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%80%E4%BD%8D%E5%85%A8%E5%8A%A0%E5%99%A8"><span class="toc-number">1.4.1.3.1.</span> <span class="toc-text">一位全加器</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%B2%E8%A1%8C%E5%8A%A0%E6%B3%95%E5%99%A8"><span class="toc-number">1.4.1.3.2.</span> <span class="toc-text">串行加法器</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%B9%B6%E8%A1%8C%E5%8A%A0%E6%B3%95%E5%99%A8"><span class="toc-number">1.4.1.3.3.</span> <span class="toc-text">并行加法器</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%A0%E6%B3%95%E5%99%A8%E3%80%81ALU%E7%9A%84%E6%94%B9%E8%BF%9B"><span class="toc-number">1.4.2.</span> <span class="toc-text">加法器、ALU的改进</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B9%A0%E9%A2%98%E8%AF%BE"><span class="toc-number">2.</span> <span class="toc-text">习题课</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#todo"><span class="toc-number">2.1.</span> <span class="toc-text">todo</span></a></li></ol></li></ol></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2021 - 2022 By NephrenCake</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">这里是浅幽丶奈芙莲的个人博客~</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div></div><hr/><div id="local-search-results"></div><span class="search-close-button"><i class="fas fa-times"></i></span></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/search/local-search.js"></script><script>var preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',()=> {preloader.endLoading()})</script><div class="js-pjax"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><canvas class="fireworks" mobile="true"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/fireworks.min.js"></script></div></body></html>