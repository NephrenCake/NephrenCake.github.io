<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>考研记录-Part8</title>
      <link href="/2022/8/%E8%80%83%E7%A0%94%E8%AE%B0%E5%BD%95-Part8/"/>
      <url>/2022/8/%E8%80%83%E7%A0%94%E8%AE%B0%E5%BD%95-Part8/</url>
      
        <content type="html"><![CDATA[<h1 id="考研记录-Part8——8月份考研记录"><a href="#考研记录-Part8——8月份考研记录" class="headerlink" title="考研记录-Part8——8月份考研记录"></a>考研记录-Part8——8月份考研记录</h1><h2 id="8-10"><a href="#8-10" class="headerlink" title="8.10"></a>8.10</h2><ol><li>数学<ul><li>姜150：高数 9~10 讲（积麻了）</li><li>共创 19 模拟五</li></ul></li><li>408<ul><li>数据结构 1~3 章（久违开整）</li></ul></li><li>英语<ul><li>背单词 400</li></ul></li></ol><h2 id="8-9"><a href="#8-9" class="headerlink" title="8.9"></a>8.9</h2><ol><li>数学<ul><li>姜150：高数 9~10 讲</li><li>共创 19 模拟四</li></ul></li><li>英语<ul><li>背单词 400</li></ul></li></ol><h2 id="8-8"><a href="#8-8" class="headerlink" title="8.8"></a>8.8</h2><ol><li>数学<ul><li>姜150：高数 8 讲</li><li>整理模拟错题</li><li>共创 19 模拟三</li></ul></li><li>英语<ul><li>背单词 200</li></ul></li></ol><h2 id="8-7"><a href="#8-7" class="headerlink" title="8.7"></a>8.7</h2><ol><li>数学<ul><li>姜150：高数 7 讲</li><li>共创 19 模拟二</li></ul></li><li>英语<ul><li>背单词 400</li></ul></li></ol><h2 id="8-6"><a href="#8-6" class="headerlink" title="8.6"></a>8.6</h2><ol><li>数学<ul><li>姜150：高数 6~7 讲</li><li>共创 19 模拟一</li></ul></li></ol><h2 id="8-5"><a href="#8-5" class="headerlink" title="8.5"></a>8.5</h2><ol><li>数学<ul><li>姜150：高数 5~6 讲</li><li>共创 18 模拟五</li></ul></li><li>英语<ul><li>背单词 400</li></ul></li></ol><h2 id="8-4"><a href="#8-4" class="headerlink" title="8.4"></a>8.4</h2><ol><li>数学<ul><li>姜150：高数 5 讲</li><li>共创 18 模拟四</li></ul></li></ol><h2 id="8-3"><a href="#8-3" class="headerlink" title="8.3"></a>8.3</h2><ol><li>数学<ul><li>姜150：高数 3~5 讲</li><li>共创 18 模拟三（麻了，这共创超越怎么哪哪有印错）</li></ul></li><li>英语<ul><li>背单词 400</li></ul></li></ol><h2 id="8-2"><a href="#8-2" class="headerlink" title="8.2"></a>8.2</h2><ol><li>数学<ul><li>姜150：高数 2~3 讲</li><li>共创 18 模拟二（心态崩了，分布函数算十年，-2-2-2=-8）</li></ul></li><li>英语<ul><li>背单词 400</li></ul></li></ol><h2 id="8-1"><a href="#8-1" class="headerlink" title="8.1"></a>8.1</h2><ol><li>数学<ul><li>姜150：高数 1 讲</li><li>重做 660 概率 480~575</li><li>回顾线代</li><li>共创 18 模拟一（怎么高数能出的这么难）</li></ul></li><li>英语<ul><li>背单词 400</li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> 考研记录 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>考研记录-Part7</title>
      <link href="/2022/7/%E8%80%83%E7%A0%94%E8%AE%B0%E5%BD%95-Part7/"/>
      <url>/2022/7/%E8%80%83%E7%A0%94%E8%AE%B0%E5%BD%95-Part7/</url>
      
        <content type="html"><![CDATA[<h1 id="考研记录-Part7——7月份考研记录"><a href="#考研记录-Part7——7月份考研记录" class="headerlink" title="考研记录-Part7——7月份考研记录"></a>考研记录-Part7——7月份考研记录</h1><h2 id="7-31"><a href="#7-31" class="headerlink" title="7.31"></a>7.31</h2><ol><li>数学<ul><li>姜150：概率 7~8 讲</li><li>重做 660 概率 426~479</li></ul></li><li>英语<ul><li>背单词 400</li></ul></li></ol><h2 id="7-30"><a href="#7-30" class="headerlink" title="7.30"></a>7.30</h2><ol><li>数学<ul><li>姜150：概率 6~7 讲</li></ul></li><li>英语<ul><li>背单词 400</li></ul></li></ol><h2 id="7-29"><a href="#7-29" class="headerlink" title="7.29"></a>7.29</h2><ol><li>数学<ul><li>姜150：概率 4~5 讲</li></ul></li><li>英语<ul><li>背单词 200</li></ul></li></ol><h2 id="7-28"><a href="#7-28" class="headerlink" title="7.28"></a>7.28</h2><ol><li>数学<ul><li>姜150：概率 2~4 讲</li></ul></li><li>英语<ul><li>背单词 400</li></ul></li></ol><h2 id="7-27"><a href="#7-27" class="headerlink" title="7.27"></a>7.27</h2><ol><li>数学<ul><li>姜150：线代 10 讲</li><li>姜150：概率 1~2 讲</li></ul></li><li>英语<ul><li>背单词 200</li></ul></li></ol><h2 id="7-26"><a href="#7-26" class="headerlink" title="7.26"></a>7.26</h2><ol><li>数学<ul><li>姜150：线代 8~10 讲（写了一天大题，麻麻子）</li></ul></li><li>英语<ul><li>背单词 200</li></ul></li></ol><h2 id="7-25"><a href="#7-25" class="headerlink" title="7.25"></a>7.25</h2><ol><li>数学<ul><li>回顾线代</li><li>姜150：线代 8~10 讲</li><li>重做 660 线代 276~425（探望新手村）</li></ul></li><li>英语<ul><li>背单词 300</li></ul></li></ol><h2 id="7-24"><a href="#7-24" class="headerlink" title="7.24"></a>7.24</h2><ol><li>数学<ul><li>整理复习线代 6 章</li><li>姜晓千150：线代 6~7 讲</li></ul></li><li>英语<ul><li>背单词 200</li></ul></li></ol><h2 id="7-23"><a href="#7-23" class="headerlink" title="7.23"></a>7.23</h2><ol><li>数学<ul><li>整理复习线代 5、6 章</li><li>姜晓千150：线代 6~7 讲</li></ul></li><li>英语<ul><li>背单词 200</li></ul></li></ol><h2 id="7-22"><a href="#7-22" class="headerlink" title="7.22"></a>7.22</h2><ol><li>数学<ul><li>整理复习线代 5 章</li><li>共创 17 模拟一（87/150）（我的评价是高数忘完了）</li></ul></li><li>英语<ul><li>背单词 300</li></ul></li></ol><h2 id="7-21"><a href="#7-21" class="headerlink" title="7.21"></a>7.21</h2><ol><li>数学<ul><li>姜晓千150：线代 5 讲</li></ul></li><li>英语<ul><li>背单词 200</li></ul></li></ol><h2 id="7-20"><a href="#7-20" class="headerlink" title="7.20"></a>7.20</h2><ol><li>数学<ul><li>整理复习线代 1~4 章</li><li>姜晓千150：线代 5 讲</li></ul></li><li>英语<ul><li>背单词 400</li></ul></li></ol><h2 id="7-19"><a href="#7-19" class="headerlink" title="7.19"></a>7.19</h2><ol><li>数学<ul><li>整理复习线代 1~4 章（比想象中花的时间还多，也许是太摸了</li></ul></li><li>英语<ul><li>背单词 200</li></ul></li></ol><h2 id="7-18"><a href="#7-18" class="headerlink" title="7.18"></a>7.18</h2><ol><li>数学<ul><li>整理复习线代 1~4 章</li></ul></li></ol><h2 id="7-17"><a href="#7-17" class="headerlink" title="7.17"></a>7.17</h2><ol><li>数学<ul><li>姜晓千150：线代 1~4 讲（进行中）</li><li>重做线代基础强化 1~4 章（进行中）</li></ul></li><li>英语<ul><li>背单词 320</li></ul></li></ol><h2 id="7-16"><a href="#7-16" class="headerlink" title="7.16"></a>7.16</h2><ol><li>姜晓千150：线代 1、2 讲（进行中）</li><li>重做线代基础强化 1、2 章（进行中）</li><li>数据结构强化 1 讲（进行中）</li><li>背单词 100</li></ol><h2 id="7-15"><a href="#7-15" class="headerlink" title="7.15"></a>7.15</h2><ol><li>姜晓千150：线代 1 讲（进行中）</li><li>重做线代基础强化 1、2 章（进行中）</li><li>数据结构强化 1 讲（进行中）</li><li>背单词 300</li></ol><h2 id="7-14"><a href="#7-14" class="headerlink" title="7.14"></a>7.14</h2><ol><li>660 概率 526-575</li><li>背单词 400</li></ol><h2 id="7-13"><a href="#7-13" class="headerlink" title="7.13"></a>7.13</h2><ol><li>复习编译原理，编译原理考试</li><li>背单词 300</li></ol><h2 id="7-12"><a href="#7-12" class="headerlink" title="7.12"></a>7.12</h2><ol><li>660 概率 460-525</li><li>复习编译原理</li><li>背单词 500</li></ol><h2 id="7-11"><a href="#7-11" class="headerlink" title="7.11"></a>7.11</h2><ol><li>复习计网书，计网考试</li><li>复习编译原理</li><li>背单词 520</li></ol><h2 id="7-10"><a href="#7-10" class="headerlink" title="7.10"></a>7.10</h2><ol><li>概率强化 5、6、7 章，重做基础 5、6、7 章；</li><li>660 概率 453-459</li><li>背单词 320</li></ol><h2 id="7-9"><a href="#7-9" class="headerlink" title="7.9"></a>7.9</h2><ol><li>概率强化 3、4 章，重做基础 4 章</li><li>背单词 320</li></ol><h2 id="7-8"><a href="#7-8" class="headerlink" title="7.8"></a>7.8</h2><ol><li>重做概率基础强化 1、2、3 章例题</li><li>660 概率 426-453</li><li>概率强化 3 章（20%）</li><li>背单词 320 </li></ol><h2 id="7-7"><a href="#7-7" class="headerlink" title="7.7"></a>7.7</h2><ol><li>计网书一遍收尾（ip、tcp题啃了好几天啊）</li><li>复习660空间几何、多元函数积分</li><li>复习概率基础</li></ol>]]></content>
      
      
      <categories>
          
          <category> 考研记录 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>C++-完结目录</title>
      <link href="/2022/1/C++-%E5%AE%8C%E7%BB%93%E7%9B%AE%E5%BD%95/"/>
      <url>/2022/1/C++-%E5%AE%8C%E7%BB%93%E7%9B%AE%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<h1 id="C-完结目录"><a href="#C-完结目录" class="headerlink" title="C++-完结目录"></a>C++-完结目录</h1><p>教程传送门：</p><ul><li><a href="https://www.bilibili.com/video/BV1et411b73Z">https://www.bilibili.com/video/BV1et411b73Z</a></li><li><a href="https://www.runoob.com/cplusplus/cpp-tutorial.html">https://www.runoob.com/cplusplus/cpp-tutorial.html</a></li></ul><table><thead><tr><th align="center"><a href="/2022/01/C++-Part1/">C++-Part1——入门编程</a></th></tr></thead><tbody><tr><td align="center"><strong><a href="/2022/01/C++-Part2/">C++-Part2——核心编程</a></strong></td></tr><tr><td align="center"><strong><a href="/2022/01/C++-Part3/">C++-Part3——提高编程</a></strong></td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithms </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++-Part3</title>
      <link href="/2022/1/C++-Part3/"/>
      <url>/2022/1/C++-Part3/</url>
      
        <content type="html"><![CDATA[<h1 id="C-Part3——提高编程"><a href="#C-Part3——提高编程" class="headerlink" title="C++-Part3——提高编程"></a>C++-Part3——提高编程</h1><p>[TOC]</p><h2 id="STL-概述"><a href="#STL-概述" class="headerlink" title="STL 概述"></a>STL 概述</h2><ul><li>诞生背景<ul><li>长久以来，软件界一直希望建立一种可重复利用的东西</li><li>C++ 的<strong>面向对象</strong>和<strong>泛型编程</strong>思想，目的就是<strong>复用性的提升</strong></li><li>大多情况下，数据结构和算法都未能有一套标准，导致被迫从事大量重复工作</li><li>为了建立数据结构和算法的一套标准，诞生了<strong>STL</strong></li></ul></li></ul><ul><li><p>基本概念</p><ul><li>STL（Standard Template Library，标准模板库）</li><li>STL 从广义上分为：<strong>容器（container）、算法（algorithm）、迭代器（iterator）</strong></li><li><strong>容器</strong>和<strong>算法</strong>之间通过<strong>迭代器</strong>进行无缝连接。</li><li>STL 几乎所有的代码都采用了模板类或者模板函数</li></ul></li><li><p>STL 六大组件：</p><ol><li>容器：各种数据结构，如 vector、list、deque、set、map 等，用来存放数据。</li><li>算法：各种常用的算法，如 sort、find、copy、for_each 等</li><li>迭代器：扮演了容器与算法之间的胶合剂。</li><li>仿函数：行为类似函数，可作为算法的某种策略。</li><li>适配器：一种用来修饰容器或者仿函数或迭代器接口的东西。</li><li>空间配置器：负责空间的配置与管理。</li></ol></li><li><p>STL 容器、算法、迭代器</p><ul><li><p>容器：</p><ul><li>STL<strong>容器</strong>就是将运用<strong>最广泛的一些数据结构</strong>实现出来</li><li>常用的数据结构：数组、链表、树、栈、队列、集合、映射表等</li><li>这些容器分为<strong>序列式容器</strong>和<strong>关联式容器</strong>两种:<ul><li><strong>序列式容器</strong>：强调值的排序，序列式容器中的每个元素均有固定的位置。</li><li><strong>关联式容器</strong>：二叉树结构，各元素之间没有严格的物理上的顺序关系</li></ul></li></ul></li><li><p>算法：</p><ul><li>有限的步骤，解决逻辑或数学上的问题</li><li>算法分为：<strong>质变算法</strong>和<strong>非质变算法</strong>。<ul><li>质变算法：是指运算过程中会更改区间内的元素的内容。例如拷贝、替换、删除等等</li><li>非质变算法：是指运算过程中不会更改区间内的元素内容，例如查找、计数、遍历、寻找极值等等</li></ul></li></ul></li><li><p>迭代器：</p><ul><li><p>提供一种方法，使之能够依序寻访某个容器所含的各个元素，而又无需暴露该容器的内部表示方式。</p></li><li><p><strong>每个容器都有自己专属的迭代器</strong></p></li><li><p>迭代器使用非常类似于指针</p></li><li><p>迭代器种类：</p><table><thead><tr><th>种类</th><th>功能</th><th>支持运算</th></tr></thead><tbody><tr><td>输入迭代器</td><td>对数据的只读访问</td><td>只读，支持++、==、！=</td></tr><tr><td>输出迭代器</td><td>对数据的只写访问</td><td>只写，支持++</td></tr><tr><td>前向迭代器</td><td>读写操作，并能向前推进迭代器</td><td>读写，支持++、==、！=</td></tr><tr><td>双向迭代器</td><td>读写操作，并能向前和向后操作</td><td>读写，支持++、–，</td></tr><tr><td>随机访问迭代器</td><td>读写操作，可以以跳跃的方式访问任意数据，功能最强的迭代器</td><td>读写，支持++、–、[n]、-n、&lt;、&lt;=、&gt;、&gt;=</td></tr></tbody></table></li><li><p>常用的容器中迭代器种类为双向迭代器，和随机访问迭代器</p></li></ul></li></ul></li></ul><h2 id="STL-常用容器"><a href="#STL-常用容器" class="headerlink" title="STL 常用容器"></a>STL 常用容器</h2><h3 id="string-容器"><a href="#string-容器" class="headerlink" title="string 容器"></a>string 容器</h3><h4 id="string-基本概念"><a href="#string-基本概念" class="headerlink" title="string 基本概念"></a>string 基本概念</h4><ul><li><p>本质：</p><ul><li>string 是 C++ 风格的字符串，而 string 本质上是一个类</li></ul></li><li><p>string 和 char* 区别：</p><ul><li>char* 是一个指针</li><li>string 是一个类，类内部封装了char*，管理这个字符串，是一个 char* 型的容器。</li></ul></li><li><p>特点：</p><ul><li>string 类内部封装了很多成员方法</li><li>string 管理 char* 所分配的内存，不用担心复制越界和取值越界等，由类内部进行负责</li></ul></li></ul><h4 id="string-构造函数"><a href="#string-构造函数" class="headerlink" title="string 构造函数"></a>string 构造函数</h4><ul><li><p>构造函数原型：</p><ul><li><p><code>string();</code>：创建一个空的字符串</p></li><li><p><code>string(const char* s);</code>：使用 c 风格字符串初始化</p><ul><li><blockquote><p>string 转 char*：<code>char*p=(char*)str.data();</code> 或 <code>char *p=(char*)str.c_str();</code></p></blockquote></li></ul></li><li><p><code>string(const string&amp; str);</code>：使用一个 string 对象初始化另一个 string 对象</p></li><li><p><code>string(int n, char c);</code>：使用 n 个字符 c 初始化 </p></li></ul></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// string构造</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">string</span> s1; <span class="comment">// 创建空字符串，调用无参构造函数</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;str1 = &quot;</span> &lt;&lt; s1 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *str = <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">s2</span><span class="params">(str)</span></span>; <span class="comment">// 把c_string转换成了string</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;str2 = &quot;</span> &lt;&lt; s2 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">s3</span><span class="params">(s2)</span></span>; <span class="comment">// 调用拷贝构造函数</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;str3 = &quot;</span> &lt;&lt; s3 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">s4</span><span class="params">(<span class="number">10</span>, <span class="string">&#x27;a&#x27;</span>)</span></span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;str4 = &quot;</span> &lt;&lt; s4 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    test01();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="string-赋值操作"><a href="#string-赋值操作" class="headerlink" title="string 赋值操作"></a>string 赋值操作</h4><ul><li>赋值的函数原型：<ul><li><code>string&amp; operator=(const char* s);</code>：char* 类型字符串赋值给当前的字符串</li><li><code>string&amp; operator=(const string &amp;s);</code>：把字符串 s 赋给当前的字符串</li><li><code>string&amp; operator=(char c);</code>：单字符赋值给当前的字符串</li><li><code>string&amp; assign(const char *s);</code>：把字符串 s 赋给当前的字符串</li><li><code>string&amp; assign(const char *s, int n);</code>：把字符串 s 的<strong>前 n 个字符</strong>赋给当前的字符串</li><li><code>string&amp; assign(const string &amp;s);</code>：把字符串 s 赋给当前字符串</li><li><code>string&amp; assign(int n, char c);</code>：用 n 个字符 c 赋给当前字符串</li></ul></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//赋值</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">string</span> str1;</span><br><span class="line">    str1 = <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;str1 = &quot;</span> &lt;&lt; str1 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">string</span> str2;</span><br><span class="line">    str2 = str1;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;str2 = &quot;</span> &lt;&lt; str2 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">string</span> str3;</span><br><span class="line">    str3 = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;str3 = &quot;</span> &lt;&lt; str3 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">string</span> str4;</span><br><span class="line">    str4.assign(<span class="string">&quot;hello c++&quot;</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;str4 = &quot;</span> &lt;&lt; str4 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">string</span> str5;</span><br><span class="line">    str5.assign(<span class="string">&quot;hello c++&quot;</span>, <span class="number">5</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;str5 = &quot;</span> &lt;&lt; str5 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">string</span> str6;</span><br><span class="line">    str6.assign(str5);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;str6 = &quot;</span> &lt;&lt; str6 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">string</span> str7;</span><br><span class="line">    str7.assign(<span class="number">5</span>, <span class="string">&#x27;x&#x27;</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;str7 = &quot;</span> &lt;&lt; str7 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    test01();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="string-字符串拼接"><a href="#string-字符串拼接" class="headerlink" title="string 字符串拼接"></a>string 字符串拼接</h4><ul><li>函数原型：<ul><li><code>string&amp; operator+=(const char* str);</code>：重载 += 操作符</li><li><code>string&amp; operator+=(const char c);</code>：重载 += 操作符</li><li><code>string&amp; operator+=(const string&amp; str);</code>：重载 += 操作符</li><li><code>string&amp; append(const char* s);</code>：把字符串 s 连接到当前字符串结尾</li><li><code>string&amp; append(const char* s, int n);</code>：把字符串 s 的前 n 个字符连接到当前字符串结尾</li><li><code>string&amp; append(const string&amp; s);</code>：同 operator+=(const string&amp; str)</li><li><code>string&amp; append(const string&amp; s, int pos, int n);</code>：字符串 s 中从 pos 开始的 n 个字符连接到字符串结尾</li></ul></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//字符串拼接</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">string</span> str1 = <span class="string">&quot;我&quot;</span>;</span><br><span class="line">    str1 += <span class="string">&quot;爱玩游戏&quot;</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;str1 = &quot;</span> &lt;&lt; str1 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    str1 += <span class="string">&#x27;:&#x27;</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;str1 = &quot;</span> &lt;&lt; str1 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">string</span> str2 = <span class="string">&quot;LOL DNF&quot;</span>;</span><br><span class="line">    str1 += str2;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;str1 = &quot;</span> &lt;&lt; str1 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">string</span> str3 = <span class="string">&quot;I&quot;</span>;</span><br><span class="line">    str3.append(<span class="string">&quot; love &quot;</span>);</span><br><span class="line">    str3.append(<span class="string">&quot;game abcde&quot;</span>, <span class="number">4</span>);</span><br><span class="line">    <span class="comment">//str3.append(str2);</span></span><br><span class="line">    str3.append(str2, <span class="number">4</span>, <span class="number">3</span>); <span class="comment">// 从下标4位置开始 ，截取3个字符，拼接到字符串末尾</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;str3 = &quot;</span> &lt;&lt; str3 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    test01();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="string-查找和替换"><a href="#string-查找和替换" class="headerlink" title="string 查找和替换"></a>string 查找和替换</h4><ul><li>函数原型：<ul><li><code>int find(const string&amp; str, int pos = 0) const;</code>：查找 str 第一次出现位置，从 pos 开始查找</li><li><code>int find(const char* s, int pos = 0) const;</code>：查找 s 第一次出现位置，从pos开始查找</li><li><code>int find(const char* s, int pos, int n) const;</code>：从 pos 位置查找 s 的前 n 个字符第一次位置</li><li><code>int find(const char c, int pos = 0) const;</code>：查找字符 c 第一次出现位置</li><li><code>int rfind(const string&amp; str, int pos = npos) const;</code>：从右查找 str 最后一次位置，从 pos 开始查找</li><li><code>int rfind(const char* s, int pos = npos) const;</code>：从右查找 s 最后一次出现位置，从 pos 开始查找</li><li><code>int rfind(const char* s, int pos, int n) const;</code>：从右从 pos 查找 s 的前 n 个字符最后一次位置</li><li><code>int rfind(const char c, int pos = 0) const;</code>：从右查找字符 c 最后一次出现位置</li><li><code>string&amp; replace(int pos, int n, const string&amp; str);</code>：替换从 pos 开始 n 个字符为字符串 str</li><li><code>string&amp; replace(int pos, int n, const char* s);</code>：替换从 pos 开始的 n 个字符为字符串 s</li></ul></li><li>find 找到字符串后返回查找的第一个字符位置，找不到返回 -1</li><li>replace 在替换时，要指定起始位置，替换的目标长度，替换的结果</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//查找和替换</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//查找</span></span><br><span class="line">    <span class="built_in">string</span> str1 = <span class="string">&quot;abcdefgde&quot;</span>;</span><br><span class="line">    <span class="keyword">int</span> pos = str1.find(<span class="string">&quot;de&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (pos == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;未找到&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;pos = &quot;</span> &lt;&lt; pos &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pos = str1.rfind(<span class="string">&quot;de&quot;</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;pos = &quot;</span> &lt;&lt; pos &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//替换</span></span><br><span class="line">    <span class="built_in">string</span> str1 = <span class="string">&quot;abcdefgde&quot;</span>;</span><br><span class="line">    str1.replace(<span class="number">1</span>, <span class="number">3</span>, <span class="string">&quot;1111&quot;</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;str1 = &quot;</span> &lt;&lt; str1 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    test01();</span><br><span class="line">    test02();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="string-字符串比较"><a href="#string-字符串比较" class="headerlink" title="string 字符串比较"></a>string 字符串比较</h4><ul><li>比较方式：比较字符的 ASCII 码值（意义不大）<ul><li>= 返回 0</li><li>&gt; 返回 1 </li><li>&lt; 返回 -1</li></ul></li><li>函数原型：<ul><li><code>int compare(const string&amp; s) const;</code>：与字符串 s 比较</li><li><code>int compare(const char* s) const;</code>：与字符串 s 比较</li></ul></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 字符串比较</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">string</span> s1 = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">    <span class="built_in">string</span> s2 = <span class="string">&quot;aello&quot;</span>;</span><br><span class="line">    <span class="keyword">int</span> ret = s1.compare(s2);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (ret == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;s1 等于 s2&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ret &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;s1 大于 s2&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;s1 小于 s2&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    test01();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="string-字符存取"><a href="#string-字符存取" class="headerlink" title="string 字符存取"></a>string 字符存取</h4><ul><li><p>string 中单个字符存取方式有两种</p><ul><li><code>char&amp; operator[](int n); </code>：通过 [] 方式取字符</li><li><code>char&amp; at(int n);   </code>：通过 at() 获取字符</li></ul></li><li><blockquote><p>可以直接使用增强 for 进行遍历</p></blockquote></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">string</span> str = <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">char</span> i : str) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//字符修改</span></span><br><span class="line">    str[<span class="number">0</span>] = <span class="string">&#x27;x&#x27;</span>;</span><br><span class="line">    str.at(<span class="number">1</span>) = <span class="string">&#x27;x&#x27;</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; str &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    test01();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="string-插入和删除"><a href="#string-插入和删除" class="headerlink" title="string 插入和删除"></a>string 插入和删除</h4><ul><li>函数原型：<ul><li><code>string&amp; insert(int pos, const char* s);</code>：插入字符串</li><li><code>string&amp; insert(int pos, const string&amp; str);</code>：插入字符串</li><li><code>string&amp; insert(int pos, int n, char c);</code>：在指定位置插入 n 个字符 c</li><li><code>string&amp; erase(int pos, int n = npos);</code>：删除从 Pos 开始的 n 个字符 </li></ul></li><li>注意：插入和删除的起始下标都是从 0 开始</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//字符串插入和删除</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">string</span> str = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">    </span><br><span class="line">    str.insert(<span class="number">1</span>, <span class="string">&quot;111&quot;</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; str &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">// h111ello</span></span><br><span class="line"></span><br><span class="line">    str.erase(<span class="number">1</span>, <span class="number">3</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; str &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">// h111ello</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    test01();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="string-子串"><a href="#string-子串" class="headerlink" title="string 子串"></a>string 子串</h4><ul><li>函数原型：<ul><li><code>string substr(int pos = 0, int n = npos) const;</code>：返回由 pos 开始的 n 个字符组成的字符串</li></ul></li><li>总结：灵活的运用求子串功能，可以在实际开发中获取有效的信息</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//子串</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 验证</span></span><br><span class="line">    <span class="built_in">string</span> str = <span class="string">&quot;abcdefg&quot;</span>;</span><br><span class="line">    <span class="built_in">string</span> subStr = str.substr(<span class="number">1</span>, <span class="number">3</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;subStr = &quot;</span> &lt;&lt; subStr &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">// subStr = bcd</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 应用</span></span><br><span class="line">    <span class="built_in">string</span> email = <span class="string">&quot;hello@sina.com&quot;</span>;</span><br><span class="line">    <span class="keyword">int</span> pos = email.find(<span class="string">&#x27;@&#x27;</span>);</span><br><span class="line">    <span class="built_in">string</span> username = email.substr(<span class="number">0</span>, pos);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;username: &quot;</span> &lt;&lt; username &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">// username: hello</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    test01();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="string-大小"><a href="#string-大小" class="headerlink" title="string 大小"></a>string 大小</h4><blockquote><ul><li><code>size()</code>：获得字符串的长度</li><li><code>capacity()</code>：获得该字符串的总空间大小</li></ul></blockquote><h3 id="vector-容器"><a href="#vector-容器" class="headerlink" title="vector 容器"></a>vector 容器</h3><h4 id="vector-基本概念"><a href="#vector-基本概念" class="headerlink" title="vector 基本概念"></a>vector 基本概念</h4><ul><li><p>功能：</p><ul><li>vector 数据结构和数组非常相似，也称为单端数组</li></ul></li><li><p>vector 与普通数组区别：</p><ul><li>不同之处在于数组是静态空间，而 vector 封装了动态扩展</li></ul></li><li><p>动态扩展：</p><ul><li>并不是在原空间之后续接新空间，而是找更大的内存空间，然后将原数据拷贝新空间，释放原空间</li></ul></li><li><p>vector 容器的迭代器是支持随机访问的迭代器</p></li><li><img src="/2022/1/C++-Part3/clip_image002.jpg" alt="说明: 2015-11-10_151152" style="zoom:150%;"></li></ul><h4 id="vector-构造函数"><a href="#vector-构造函数" class="headerlink" title="vector 构造函数"></a>vector 构造函数</h4><ul><li>函数原型：<ul><li><code>vector&lt;T&gt; v;</code>：采用模板实现类实现，默认构造函数</li><li><code>vector(v.begin(), v.end());</code>：将 [begin(), end()) 区间中的元素拷贝给本身。</li><li><code>vector(n, elem);</code>：构造函数将 n 个 elem 拷贝给本身。</li><li><code>vector(const vector &amp;vec);</code>：拷贝构造函数。</li></ul></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printVector</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> &amp;it : v) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v1;  <span class="comment">// 无参构造</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        v1.push_back(i);</span><br><span class="line">    &#125;</span><br><span class="line">    printVector(v1);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">v2</span><span class="params">(v1.begin(), v1.end())</span></span>;</span><br><span class="line">    printVector(v2);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">v3</span><span class="params">(<span class="number">10</span>, <span class="number">100</span>)</span></span>;</span><br><span class="line">    printVector(v3);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">v4</span><span class="params">(v3)</span></span>;</span><br><span class="line">    printVector(v4);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    test01();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="vector-赋值操作"><a href="#vector-赋值操作" class="headerlink" title="vector 赋值操作"></a>vector 赋值操作</h4><ul><li><p>函数原型：</p><ul><li><p><code>vector&amp; operator=(const vector &amp;vec);</code>：重载等号操作符</p></li><li><p><code>assign(beg, end);</code>：将[beg, end)区间中的数据拷贝赋值给本身。</p></li><li><p><code>assign(n, elem);</code>：将n个elem拷贝赋值给本身。</p></li></ul></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 赋值操作</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v1;  <span class="comment">// 无参构造</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        v1.push_back(i);</span><br><span class="line">    &#125;</span><br><span class="line">    printVector(v1);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v2;</span><br><span class="line">    v2 = v1;</span><br><span class="line">    printVector(v2);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v3;</span><br><span class="line">    v3.assign(v1.begin(), v1.end());</span><br><span class="line">    printVector(v3);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v4;</span><br><span class="line">    v4.assign(<span class="number">10</span>, <span class="number">100</span>);</span><br><span class="line">    printVector(v4);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    test01();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="vector-容量和大小"><a href="#vector-容量和大小" class="headerlink" title="vector 容量和大小"></a>vector 容量和大小</h4><ul><li>函数原型：<ul><li><code>empty();</code>：判断容器是否为空</li><li><code>capacity();</code>：返回容器的容量</li><li><code>size();</code>：返回容器中元素的个数</li><li><code>resize(int num, elem);</code>：重新指定容器的长度为 num<ul><li>若容器变长，则以 elem 填充新位置。若没有提供 elem，则填充默认值 0。</li><li>如果容器变短，则末尾超出容器长度的元素被删除。</li></ul></li></ul></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v1;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        v1.push_back(i);</span><br><span class="line">    &#125;</span><br><span class="line">    printVector(v1);</span><br><span class="line">    <span class="keyword">if</span> (v1.empty()) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;v1为空&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;v1不为空&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;v1的容量 = &quot;</span> &lt;&lt; v1.capacity() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;v1的大小 = &quot;</span> &lt;&lt; v1.size() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//resize 重新指定大小 ，若指定的更大，默认用0填充新位置，可以利用重载版本替换默认填充</span></span><br><span class="line">    v1.resize(<span class="number">15</span>, <span class="number">10</span>);</span><br><span class="line">    printVector(v1);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//resize 重新指定大小 ，若指定的更小，超出部分元素被删除</span></span><br><span class="line">    v1.resize(<span class="number">5</span>);</span><br><span class="line">    printVector(v1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    test01();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="vector-插入和删除"><a href="#vector-插入和删除" class="headerlink" title="vector 插入和删除"></a>vector 插入和删除</h4><ul><li>函数原型：<ul><li><code>push_back(ele);</code>：尾部插入元素 ele</li><li><code>pop_back();</code>：删除最后一个元素</li><li><code>insert(const_iterator pos, ele);</code>：迭代器指向位置 pos 插入元素 ele</li><li><code>insert(const_iterator pos, int count,ele);</code>：迭代器指向位置 pos 插入 count 个元素 ele</li><li><code>erase(const_iterator pos);</code>：删除迭代器指向的元素</li><li><code>erase(const_iterator start, const_iterator end);</code>：删除迭代器从 start 到 end 之间的元素</li><li><code>clear();</code>：删除容器中所有元素</li></ul></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//插入和删除</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v1;</span><br><span class="line"></span><br><span class="line">    v1.push_back(<span class="number">10</span>);</span><br><span class="line">    v1.push_back(<span class="number">20</span>);</span><br><span class="line">    v1.push_back(<span class="number">30</span>);</span><br><span class="line">    v1.push_back(<span class="number">40</span>);</span><br><span class="line">    v1.push_back(<span class="number">50</span>);  <span class="comment">// 尾插</span></span><br><span class="line">    printVector(v1);</span><br><span class="line"></span><br><span class="line">    v1.pop_back();  <span class="comment">// 尾删</span></span><br><span class="line">    printVector(v1);</span><br><span class="line"></span><br><span class="line">    v1.insert(v1.begin(), <span class="number">100</span>);  <span class="comment">// 插入</span></span><br><span class="line">    printVector(v1);</span><br><span class="line"></span><br><span class="line">    v1.insert(v1.begin(), <span class="number">2</span>, <span class="number">1000</span>);</span><br><span class="line">    printVector(v1);</span><br><span class="line"></span><br><span class="line">    v1.erase(v1.begin());  <span class="comment">// 删除</span></span><br><span class="line">    printVector(v1);</span><br><span class="line"></span><br><span class="line">    v1.erase(v1.begin(), v1.end());  <span class="comment">// 清空</span></span><br><span class="line">    v1.clear();</span><br><span class="line">    printVector(v1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    test01();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="vector-数据存取"><a href="#vector-数据存取" class="headerlink" title="vector 数据存取"></a>vector 数据存取</h4><ul><li><p>函数原型：</p><ul><li><code>at(int idx); </code>：返回索引 idx 所指的数据</li><li><code>operator[]; </code>：返回索引 idx 所指的数据</li><li><code>front(); </code>：返回容器中第一个数据元素</li><li><code>back();</code>：返回容器中最后一个数据元素</li></ul></li><li><blockquote><p>建议直接使用增强 for</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printVector</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;v)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> &amp;it : v) &#123;</span><br><span class="line">           <span class="built_in">cout</span> &lt;&lt; it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v1;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        v1.push_back(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; v1.size(); i++) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; v1[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; v1.size(); i++) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; v1.at(i) &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;v1的第一个元素为： &quot;</span> &lt;&lt; v1.front() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;v1的最后一个元素为： &quot;</span> &lt;&lt; v1.back() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    test01();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="vector-互换容器"><a href="#vector-互换容器" class="headerlink" title="vector 互换容器"></a>vector 互换容器</h4></li><li><p>函数原型：</p><ul><li><code>swap(vec);</code>：将 vec 与本身的元素互换</li></ul></li><li><p>总结：swap 可以使两个容器互换，可以达到实用的收缩内存效果（因为使用的当前容器的 size 来初始化了匿名对象）</p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v1;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        v1.push_back(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v2;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">10</span>; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">        v2.push_back(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//互换容器</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;互换前&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    printVector(v1);</span><br><span class="line">    printVector(v2);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;互换后&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    v1.swap(v2);</span><br><span class="line">    printVector(v1);</span><br><span class="line">    printVector(v2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100000</span>; i++) &#123;</span><br><span class="line">        v.push_back(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;v的大小为：&quot;</span> &lt;&lt; v.size() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;v的容量为：&quot;</span> &lt;&lt; v.capacity() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    v.resize(<span class="number">3</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;v的大小为：&quot;</span> &lt;&lt; v.size() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;v的容量为：&quot;</span> &lt;&lt; v.capacity() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//收缩内存</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(v).swap(v);  <span class="comment">// 匿名对象</span></span><br><span class="line">    v.shrink_to_fit();  <span class="comment">// 等价方法</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;v的大小为：&quot;</span> &lt;&lt; v.size() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;v的容量为：&quot;</span> &lt;&lt; v.capacity() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    test01();</span><br><span class="line">    test02();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="vector-预留空间"><a href="#vector-预留空间" class="headerlink" title="vector 预留空间"></a>vector 预留空间</h4><ul><li><p>函数原型：</p><ul><li><code>reserve(int len);</code>：容器预留 len 个元素长度，预留位置不初始化，元素不可访问。</li></ul></li><li><p>总结：如果数据量较大，可以一开始利用 reserve 预留空间，以免添加数据时不断复制扩张</p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">    <span class="comment">//预留空间</span></span><br><span class="line">    v.reserve(<span class="number">100000</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> *p = <span class="literal">nullptr</span>;  <span class="comment">// 追踪 vector 首地址</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100000</span>; i++) &#123;</span><br><span class="line">        v.push_back(i);</span><br><span class="line">        <span class="keyword">if</span> (p != &amp;v[<span class="number">0</span>]) &#123;</span><br><span class="line">            p = &amp;v[<span class="number">0</span>];</span><br><span class="line">            num++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;num:&quot;</span> &lt;&lt; num &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    test01();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="deque-容器"><a href="#deque-容器" class="headerlink" title="deque 容器"></a>deque 容器</h3><h4 id="deque-容器基本概念"><a href="#deque-容器基本概念" class="headerlink" title="deque 容器基本概念"></a>deque 容器基本概念</h4><ul><li><p>功能：</p><ul><li>双端数组，可以对头端进行插入删除操作</li></ul></li><li><p>deque 与 vector 区别：</p><ul><li>vector 对于头部的插入删除效率低，数据量越大，效率越低</li><li>deque 相对而言，对头部的插入删除速度回比 vector 快</li><li>vector 访问元素时的速度会比 deque 快</li></ul></li><li><p><img src="/2022/1/C++-Part3/clip_image002-1547547642923.jpg" alt="说明: 2015-11-19_204101"></p></li></ul><ul><li>deque 内部工作原理:<ul><li>deque 内部有个<strong>中控器</strong>，维护每段缓冲区中的内容，缓冲区中存放真实数据</li><li>中控器维护的是每个缓冲区的地址，使得使用 deque 时像一片连续的内存空间</li><li><img src="/2022/1/C++-Part3/clip_image002-1547547896341.jpg" alt="clip_image002-1547547896341"></li></ul></li></ul><ul><li>deque 容器的迭代器也是支持随机访问的</li></ul><h4 id="deque-构造函数"><a href="#deque-构造函数" class="headerlink" title="deque 构造函数"></a>deque 构造函数</h4><ul><li>函数原型：<ul><li><code>deque&lt;T&gt; deqT;</code>：默认构造形式</li><li><code>deque(beg, end);</code>：构造函数将 [beg, end) 区间中的元素拷贝给本身。</li><li><code>deque(n, elem);</code>：构造函数将 n 个 elem 拷贝给本身。</li><li><code>deque(const deque &amp;deq);</code>：拷贝构造函数</li></ul></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deque&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printDeque</span><span class="params">(<span class="keyword">const</span> <span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; &amp;d)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> it = d.begin(); it != d.end(); it++) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// deque构造</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; d1;  <span class="comment">// 无参构造函数</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        d1.push_back(i);</span><br><span class="line">    &#125;</span><br><span class="line">    printDeque(d1);</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; <span class="title">d2</span><span class="params">(d1.begin(), d1.end())</span></span>;</span><br><span class="line">    printDeque(d2);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; <span class="title">d3</span><span class="params">(<span class="number">10</span>, <span class="number">100</span>)</span></span>;</span><br><span class="line">    printDeque(d3);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; d4 = d3;</span><br><span class="line">    printDeque(d4);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    test01();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="deque-赋值操作"><a href="#deque-赋值操作" class="headerlink" title="deque 赋值操作"></a>deque 赋值操作</h4><ul><li><p>函数原型：</p><ul><li><p><code>deque&amp; operator=(const deque&amp; deq); </code>：重载等号操作符</p></li><li><p><code>assign(beg, end);</code>：将 [beg, end) 区间中的数据拷贝赋值给本身。</p></li><li><p><code>assign(n, elem);</code>：将 n 个 elem 拷贝赋值给本身。</p></li></ul></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 赋值操作</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; d1;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        d1.push_back(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; d2;</span><br><span class="line">    d2 = d1;</span><br><span class="line">    printDeque(d2);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; d3;</span><br><span class="line">    d3.assign(d1.begin(), d1.end());</span><br><span class="line">    printDeque(d3);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; d4;</span><br><span class="line">    d4.assign(<span class="number">10</span>, <span class="number">100</span>);</span><br><span class="line">    printDeque(d4);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    test01();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="deque-大小操作"><a href="#deque-大小操作" class="headerlink" title="deque 大小操作"></a>deque 大小操作</h4><ul><li><p>函数原型：</p><ul><li><p><code>deque.empty();</code>：判断容器是否为空</p></li><li><p><code>deque.size();</code>：返回容器中元素的个数</p></li><li><p><code>deque.resize(num, elem);</code>：重新指定容器的长度为 num，若容器变长，</p></li><li><p>若容器变长，则以 elem 值填充新位置。若没有提供 elem，则以默认值填充新位置。</p><ul><li>如果容器变短，则末尾超出容器长度的元素被删除。</li></ul></li></ul></li><li><p>deque 没有容量的概念</p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 大小操作</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; d1;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        d1.push_back(i);</span><br><span class="line">    &#125;</span><br><span class="line">    printDeque(d1);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断容器是否为空</span></span><br><span class="line">    <span class="keyword">if</span> (d1.empty()) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;d1为空!&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;d1不为空!&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="comment">//统计大小</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;d1的大小为：&quot;</span> &lt;&lt; d1.size() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//重新指定大小</span></span><br><span class="line">    d1.resize(<span class="number">15</span>, <span class="number">1</span>);</span><br><span class="line">    printDeque(d1);</span><br><span class="line"></span><br><span class="line">    d1.resize(<span class="number">5</span>);</span><br><span class="line">    printDeque(d1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    test01();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="deque-插入和删除"><a href="#deque-插入和删除" class="headerlink" title="deque 插入和删除"></a>deque 插入和删除</h4><ul><li><p>函数原型：</p><ul><li><p>两端插入操作：</p><ul><li><code>push_back(elem);</code>：在容器尾部添加一个数据</li><li><code>push_front(elem);</code>：在容器头部插入一个数据</li><li><code>pop_back();</code>：删除容器最后一个数据</li><li><code>pop_front();</code>：删除容器第一个数据</li></ul></li><li><p>指定位置操作：</p><ul><li><code>insert(pos, elem);</code>：在 pos 位置插入一个 elem 元素的拷贝，返回新数据的位置。</li><li><code>insert(pos, n, elem);</code>：在 pos 位置插入 n 个 elem 数据，无返回值。</li><li><code>insert(pos, beg, end);</code>：在 pos 位置插入 [beg,end) 区间的数据，无返回值。</li><li><code>clear();</code>：清空容器的所有数据</li><li><code>erase(beg, end);</code>：删除 [beg,end) 区间的数据，返回下一个数据的位置。</li><li><code>erase(pos);</code>：删除 pos 位置的数据，返回下一个数据的位置。</li></ul></li></ul></li><li><p><strong>插入和删除提供的位置是迭代器</strong></p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//两端操作</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; d;</span><br><span class="line"></span><br><span class="line">    d.push_back(<span class="number">10</span>);</span><br><span class="line">    d.push_back(<span class="number">20</span>);  <span class="comment">//尾插</span></span><br><span class="line">    d.push_front(<span class="number">100</span>);</span><br><span class="line">    d.push_front(<span class="number">200</span>);  <span class="comment">//头插</span></span><br><span class="line">    printDeque(d);  <span class="comment">// 200 100 10 20</span></span><br><span class="line"></span><br><span class="line">    d.pop_back();  <span class="comment">//尾删</span></span><br><span class="line">    d.pop_front();  <span class="comment">//头删</span></span><br><span class="line">    printDeque(d);  <span class="comment">// 100 10</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//插入</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; d;</span><br><span class="line">    d.push_back(<span class="number">10</span>);</span><br><span class="line">    d.push_back(<span class="number">20</span>);</span><br><span class="line">    d.push_front(<span class="number">100</span>);</span><br><span class="line">    d.push_front(<span class="number">200</span>);</span><br><span class="line"></span><br><span class="line">    d.insert(d.begin(), <span class="number">1000</span>);</span><br><span class="line">    printDeque(d);  <span class="comment">// 1000 200 100 10 20</span></span><br><span class="line"></span><br><span class="line">    d.insert(d.begin(), <span class="number">2</span>, <span class="number">10000</span>);</span><br><span class="line">    printDeque(d);  <span class="comment">// 10000 10000 1000 200 100 10 20</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; d2;</span><br><span class="line">    d2.push_back(<span class="number">1</span>);</span><br><span class="line">    d2.push_back(<span class="number">2</span>);</span><br><span class="line">    d2.push_back(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    d.insert(d.begin(), d2.begin(), d2.end());</span><br><span class="line">    printDeque(d);  <span class="comment">// 1 2 3 10000 10000 1000 200 100 10 20</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test03</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; d;</span><br><span class="line">    d.push_back(<span class="number">10</span>);</span><br><span class="line">    d.push_back(<span class="number">20</span>);</span><br><span class="line">    d.push_front(<span class="number">100</span>);</span><br><span class="line">    d.push_front(<span class="number">200</span>);</span><br><span class="line"></span><br><span class="line">    d.erase(d.begin());</span><br><span class="line">    printDeque(d);  <span class="comment">// 100 10 20</span></span><br><span class="line"></span><br><span class="line">    d.erase(d.begin(), d.end());</span><br><span class="line">    d.clear();</span><br><span class="line">    printDeque(d);  <span class="comment">// 空</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    test01();</span><br><span class="line">    test02();</span><br><span class="line">    test03();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="deque-数据存取"><a href="#deque-数据存取" class="headerlink" title="deque 数据存取"></a>deque 数据存取</h4><ul><li><p>函数原型：</p><ul><li><code>at(int idx); </code>：返回索引 idx 所指的数据</li><li><code>operator[]; </code>：返回索引 idx 所指的数据</li><li><code>front(); </code>：返回容器中第一个数据元素</li><li><code>back();</code>：返回容器中最后一个数据元素</li></ul></li><li><blockquote><p>可以直接使用增强 for</p></blockquote></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//数据存取</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; d;</span><br><span class="line">    d.push_back(<span class="number">10</span>);</span><br><span class="line">    d.push_back(<span class="number">20</span>);</span><br><span class="line">    d.push_front(<span class="number">100</span>);</span><br><span class="line">    d.push_front(<span class="number">200</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; d.size(); i++) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; d[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; d.size(); i++) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; d.at(i) &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;front:&quot;</span> &lt;&lt; d.front() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;back:&quot;</span> &lt;&lt; d.back() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    test01();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="deque-排序"><a href="#deque-排序" class="headerlink" title="deque 排序"></a>deque 排序</h4><ul><li>算法：<ul><li><code>sort(iterator beg, iterator end)</code>：对 beg 和 end 区间内元素进行排序</li></ul></li><li>使用时包含头文件 algorithm</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; d;</span><br><span class="line">    d.push_back(<span class="number">10</span>);</span><br><span class="line">    d.push_back(<span class="number">20</span>);</span><br><span class="line">    d.push_front(<span class="number">100</span>);</span><br><span class="line">    d.push_front(<span class="number">200</span>);</span><br><span class="line"></span><br><span class="line">    printDeque(d);</span><br><span class="line">    sort(d.begin(), d.end());</span><br><span class="line">    printDeque(d);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    test01();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="stack-容器"><a href="#stack-容器" class="headerlink" title="stack 容器"></a>stack 容器</h3><h4 id="stack-基本概念"><a href="#stack-基本概念" class="headerlink" title="stack 基本概念"></a>stack 基本概念</h4><ul><li><p>概念：stack 是一种<strong>先进后出</strong>（First In Last Out, FILO）的数据结构，它只有一个出口</p></li><li><p><img src="/2022/1/C++-Part3/clip_image002-1547604555425.jpg" alt="说明: 2015-11-15_195707"></p></li><li><p>栈中只有顶端的元素才可以被外界使用，因此栈不允许有遍历行为</p></li></ul><h4 id="stack-常用接口"><a href="#stack-常用接口" class="headerlink" title="stack 常用接口"></a>stack 常用接口</h4><ul><li><p>构造函数：</p><ul><li><code>stack&lt;T&gt; stk;</code>：stack 采用模板类实现，stack 对象的默认构造形式</li><li><code>stack(const stack &amp;stk);</code>：拷贝构造函数</li></ul></li><li><p>赋值操作：</p><ul><li><code>stack&amp; operator=(const stack &amp;stk);</code>：重载等号操作符</li></ul></li><li><p>数据存取：</p><ul><li><code>push(elem);</code>：向栈顶添加元素</li><li><code>pop();</code>：从栈顶移除第一个元素</li><li><code>top(); </code>：返回栈顶元素</li></ul></li><li><p>大小操作：</p><ul><li><code>empty();</code>：判断堆栈是否为空</li><li><code>size(); </code>：返回栈的大小</li></ul></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//栈容器常用接口</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建栈容器 栈容器必须符合先进后出</span></span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 向栈中添加元素，叫做 压栈 入栈</span></span><br><span class="line">    s.push(<span class="number">10</span>);</span><br><span class="line">    s.push(<span class="number">20</span>);</span><br><span class="line">    s.push(<span class="number">30</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!s.empty()) &#123;</span><br><span class="line">        <span class="comment">//输出栈顶元素</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;栈顶元素为： &quot;</span> &lt;&lt; s.top() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="comment">//弹出栈顶元素</span></span><br><span class="line">        s.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;栈的大小为：&quot;</span> &lt;&lt; s.size() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    test01();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="queue-容器"><a href="#queue-容器" class="headerlink" title="queue 容器"></a>queue 容器</h3><h4 id="queue-基本概念"><a href="#queue-基本概念" class="headerlink" title="queue 基本概念"></a>queue 基本概念</h4><ul><li><p>概念：Queue 是一种<strong>先进先出</strong>（First In First Out, FIFO）的数据结构，它有两个出口</p></li><li><p><img src="/2022/1/C++-Part3/clip_image002-1547606475892.jpg" alt="说明: 2015-11-15_214429"></p></li><li><p>队列容器允许从一端新增元素，从另一端移除元素</p></li><li><p>队列中只有队头和队尾才可以被外界使用，因此队列不允许有遍历行为</p></li></ul><h4 id="queue-常用接口"><a href="#queue-常用接口" class="headerlink" title="queue 常用接口"></a>queue 常用接口</h4><ul><li><p>构造函数：</p><ul><li><code>queue&lt;T&gt; que;</code>：queue 采用模板类实现，queue 对象的默认构造形式</li><li><code>queue(const queue &amp;que);</code>：拷贝构造函数</li></ul></li><li><p>赋值操作：</p><ul><li><code>queue&amp; operator=(const queue &amp;que);</code>：重载等号操作符</li></ul></li><li><p>数据存取：</p><ul><li><code>push(elem);</code>：往队尾添加元素</li><li><code>pop();</code>：从队头移除第一个元素</li><li><code>back();</code>：返回最后一个元素</li><li><code>front(); </code>：返回第一个元素</li></ul></li><li><p>大小操作：</p><ul><li><code>empty();</code>：判断堆栈是否为空</li><li><code>size(); </code>：返回栈的大小</li></ul></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">string</span> m_Name;</span><br><span class="line">    <span class="keyword">int</span> m_Age;</span><br><span class="line"></span><br><span class="line">    Person(<span class="built_in">string</span> name, <span class="keyword">int</span> age) &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;m_Name = name;</span><br><span class="line">        <span class="keyword">this</span>-&gt;m_Age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建队列</span></span><br><span class="line">    <span class="built_in">queue</span>&lt;Person&gt; q;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 向队列中添加元素  入队操作</span></span><br><span class="line">    q.push(Person(<span class="string">&quot;唐僧&quot;</span>, <span class="number">30</span>));</span><br><span class="line">    q.push(Person(<span class="string">&quot;孙悟空&quot;</span>, <span class="number">1000</span>));</span><br><span class="line">    q.push(Person(<span class="string">&quot;猪八戒&quot;</span>, <span class="number">900</span>));</span><br><span class="line">    q.push(Person(<span class="string">&quot;沙僧&quot;</span>, <span class="number">800</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 队列不提供迭代器，更不支持随机访问</span></span><br><span class="line">    <span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">        <span class="comment">//输出队头元素</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;队头元素-- 姓名： &quot;</span> &lt;&lt; q.front().m_Name</span><br><span class="line">             &lt;&lt; <span class="string">&quot; 年龄： &quot;</span> &lt;&lt; q.front().m_Age &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;队尾元素-- 姓名： &quot;</span> &lt;&lt; q.back().m_Name</span><br><span class="line">             &lt;&lt; <span class="string">&quot; 年龄： &quot;</span> &lt;&lt; q.back().m_Age &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="comment">//弹出队头元素</span></span><br><span class="line">        q.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;队列大小为：&quot;</span> &lt;&lt; q.size() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    test01();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="list容器"><a href="#list容器" class="headerlink" title="list容器"></a>list容器</h3><h4 id="list-基本概念"><a href="#list-基本概念" class="headerlink" title="list 基本概念"></a>list 基本概念</h4><ul><li><p>链表（list）是一种物理存储单元上非连续的存储结构，数据元素的逻辑顺序是通过链表中的指针链接实现的</p><ul><li>链表的组成：链表由一系列<strong>结点</strong>组成</li><li>结点的组成：一个是存储数据元素的<strong>数据域</strong>，另一个是存储下一个结点地址的<strong>指针域</strong></li></ul></li><li><p>STL 中的链表是一个双向循环链表</p><ul><li><img src="/2022/1/C++-Part3/clip_image002-1547608564071.jpg" alt="说明: 2015-11-15_225145"></li></ul></li><li><p>由于链表的存储方式并不是连续的内存空间，因此链表 list 中的迭代器只支持前移和后移，属于<strong>双向迭代器</strong></p></li><li><p>list 的优点：</p><ul><li>采用动态存储分配，不会造成内存浪费和溢出</li><li>链表执行插入和删除操作十分方便，修改指针即可，不需要移动大量元素</li></ul></li><li><p>list 的缺点：</p><ul><li>链表灵活，但是空间（指针域）和 时间（遍历）额外耗费较大</li></ul></li><li><p>List 有一个重要的性质，插入操作和删除操作都不会造成原有 list 迭代器的失效，这在 vector 是不成立的。</p></li><li><p>总结：STL 中 <strong>List 和 vector 是两个最常被使用的容器</strong>，各有优缺点</p></li></ul><h4 id="list-构造函数"><a href="#list-构造函数" class="headerlink" title="list 构造函数"></a>list 构造函数</h4><ul><li>函数原型：<ul><li><code>list&lt;T&gt; lst;</code>：list采用采用模板类实现,对象的默认构造形式：</li><li><code>list(beg,end);</code>：构造函数将[beg, end)区间中的元素拷贝给本身。</li><li><code>list(n,elem);</code>：构造函数将n个elem拷贝给本身。</li><li><code>list(const list &amp;lst);</code>：拷贝构造函数。</li></ul></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printList</span><span class="params">(<span class="keyword">const</span> <span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; &amp;L)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> it : L) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; L1;</span><br><span class="line">    L1.push_back(<span class="number">10</span>);</span><br><span class="line">    L1.push_back(<span class="number">20</span>);</span><br><span class="line">    L1.push_back(<span class="number">30</span>);</span><br><span class="line">    L1.push_back(<span class="number">40</span>);</span><br><span class="line"></span><br><span class="line">    printList(L1);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; <span class="title">L2</span><span class="params">(L1.begin(), L1.end())</span></span>;</span><br><span class="line">    printList(L2);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; <span class="title">L3</span><span class="params">(L2)</span></span>;</span><br><span class="line">    printList(L3);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; <span class="title">L4</span><span class="params">(<span class="number">10</span>, <span class="number">1000</span>)</span></span>;</span><br><span class="line">    printList(L4);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    test01();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="list-赋值和交换"><a href="#list-赋值和交换" class="headerlink" title="list 赋值和交换"></a>list 赋值和交换</h4><ul><li>函数原型：<ul><li><code>assign(beg, end);</code>：将 [beg, end) 区间中的数据拷贝赋值给本身。</li><li><code>assign(n, elem);</code>：将 n 个 elem 拷贝赋值给本身。</li><li><code>list&amp; operator=(const list &amp;lst);</code>：重载等号操作符</li><li><code>swap(lst);</code>：将lst与本身的元素互换。</li></ul></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 赋值</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; L1;</span><br><span class="line">    L1.push_back(<span class="number">10</span>);</span><br><span class="line">    L1.push_back(<span class="number">20</span>);</span><br><span class="line">    L1.push_back(<span class="number">30</span>);</span><br><span class="line">    L1.push_back(<span class="number">40</span>);</span><br><span class="line">    printList(L1);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; L2;</span><br><span class="line">    L2 = L1;</span><br><span class="line">    printList(L2);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; L3;</span><br><span class="line">    L3.assign(L2.begin(), L2.end());</span><br><span class="line">    printList(L3);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; L4;</span><br><span class="line">    L4.assign(<span class="number">10</span>, <span class="number">100</span>);</span><br><span class="line">    printList(L4);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 交换</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; L1;</span><br><span class="line">    L1.push_back(<span class="number">10</span>);</span><br><span class="line">    L1.push_back(<span class="number">20</span>);</span><br><span class="line">    L1.push_back(<span class="number">30</span>);</span><br><span class="line">    L1.push_back(<span class="number">40</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; L2;</span><br><span class="line">    L2.assign(<span class="number">10</span>, <span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;交换前： &quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    printList(L1);</span><br><span class="line">    printList(L2);</span><br><span class="line"></span><br><span class="line">    L1.swap(L2);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;交换后： &quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    printList(L1);</span><br><span class="line">    printList(L2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    test01();</span><br><span class="line">    test02();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="list-大小操作"><a href="#list-大小操作" class="headerlink" title="list 大小操作"></a>list 大小操作</h4><ul><li><p>函数原型：</p><ul><li><p><code>size(); </code>：返回容器中元素的个数</p></li><li><p><code>empty(); </code>：判断容器是否为空</p></li><li><p><code>resize(num);</code>：重新指定容器的长度为 num</p><ul><li>若容器变长，则以 elem 值填充新位置。若没有提供 elem，则以默认值填充新位置。</li><li>若容器变短，则末尾超出容器长度的元素被删除。</li></ul></li></ul></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//大小操作</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; L1;</span><br><span class="line">    L1.push_back(<span class="number">10</span>);</span><br><span class="line">    L1.push_back(<span class="number">20</span>);</span><br><span class="line">    L1.push_back(<span class="number">30</span>);</span><br><span class="line">    L1.push_back(<span class="number">40</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (L1.empty()) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;L1为空&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;L1不为空&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;L1的大小为： &quot;</span> &lt;&lt; L1.size() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//重新指定大小</span></span><br><span class="line">    L1.resize(<span class="number">10</span>);</span><br><span class="line">    printList(L1);</span><br><span class="line"></span><br><span class="line">    L1.resize(<span class="number">2</span>);</span><br><span class="line">    printList(L1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    test01();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="list-插入和删除"><a href="#list-插入和删除" class="headerlink" title="list 插入和删除"></a>list 插入和删除</h4><ul><li>函数原型：<ul><li><code>push_back(elem);</code>：在容器尾部加入一个元素</li><li><code>pop_back();</code>：删除容器中最后一个元素</li><li><code>push_front(elem);</code>：在容器开头插入一个元素</li><li><code>pop_front();</code>：从容器开头移除第一个元素</li><li><code>insert(pos, elem);</code>：在 pos 位置插 elem 元素的拷贝，返回新数据的位置。</li><li><code>insert(pos, n, elem);</code>：在 pos 位置插入 n 个 elem 数据，无返回值。</li><li><code>insert(pos, beg, end);</code>：在 pos 位置插入 [beg,end) 区间的数据，无返回值。</li><li><code>clear();</code>：移除容器的所有数据</li><li><code>erase(beg, end);</code>：删除 [beg,end) 区间的数据，返回下一个数据的位置。</li><li><code>erase(pos);</code>：删除 pos 位置的数据，返回下一个数据的位置。</li><li><code>remove(elem);</code>：删除容器中所有与 elem 值匹配的元素。</li></ul></li><li><strong>插入和删除提供的位置是迭代器</strong></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//插入和删除</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; L;</span><br><span class="line"></span><br><span class="line">    L.push_back(<span class="number">10</span>);</span><br><span class="line">    L.push_back(<span class="number">20</span>);</span><br><span class="line">    L.push_back(<span class="number">30</span>);  <span class="comment">// 尾插</span></span><br><span class="line">    L.push_front(<span class="number">100</span>);</span><br><span class="line">    L.push_front(<span class="number">200</span>);</span><br><span class="line">    L.push_front(<span class="number">300</span>);  <span class="comment">// 头插</span></span><br><span class="line">    printList(L);  <span class="comment">// 300 200 100 10 20 30</span></span><br><span class="line"></span><br><span class="line">    L.pop_back();  <span class="comment">// 尾删</span></span><br><span class="line">    printList(L);  <span class="comment">// 300 200 100 10 20</span></span><br><span class="line">    </span><br><span class="line">    L.pop_front();  <span class="comment">// 头删</span></span><br><span class="line">    printList(L);  <span class="comment">// 200 100 10 20</span></span><br><span class="line">    </span><br><span class="line">    L.insert(++L.begin(), <span class="number">1000</span>);  <span class="comment">// 插入</span></span><br><span class="line">    printList(L);  <span class="comment">// 200 1000 100 10 20</span></span><br><span class="line">    </span><br><span class="line">    L.erase(++L.begin());  <span class="comment">//删除</span></span><br><span class="line">    printList(L);  <span class="comment">// 200 100 10 20</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//移除</span></span><br><span class="line">    L.push_back(<span class="number">10000</span>);</span><br><span class="line">    L.push_back(<span class="number">10000</span>);</span><br><span class="line">    L.push_back(<span class="number">10000</span>);</span><br><span class="line">    printList(L);  <span class="comment">// 200 100 10 20 10000 10000 10000</span></span><br><span class="line">    L.remove(<span class="number">10000</span>);</span><br><span class="line">    printList(L);  <span class="comment">// 200 100 10 20</span></span><br><span class="line">    </span><br><span class="line">    L.clear();  <span class="comment">//清空</span></span><br><span class="line">    printList(L);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    test01();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="list-数据存取"><a href="#list-数据存取" class="headerlink" title="list 数据存取"></a>list 数据存取</h4><ul><li>函数原型：<ul><li><code>front();</code>：返回第一个元素。</li><li><code>back();</code>：返回最后一个元素。</li></ul></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 数据存取</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; L1;</span><br><span class="line">    L1.push_back(<span class="number">10</span>);</span><br><span class="line">    L1.push_back(<span class="number">20</span>);</span><br><span class="line">    L1.push_back(<span class="number">30</span>);</span><br><span class="line">    L1.push_back(<span class="number">40</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//cout &lt;&lt; L1.at(0) &lt;&lt; endl;  // 错误 不支持at访问数据</span></span><br><span class="line">    <span class="comment">//cout &lt;&lt; L1[0] &lt;&lt; endl;  // 错误  不支持[]方式访问数据</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;第一个元素为： &quot;</span> &lt;&lt; L1.front() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;最后一个元素为： &quot;</span> &lt;&lt; L1.back() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// list容器的迭代器是双向迭代器，不支持随机访问</span></span><br><span class="line">    <span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt;::iterator it = L1.begin();</span><br><span class="line">    <span class="comment">//it = it + 1;  // 错误，不可以跳跃访问，即使是+1</span></span><br><span class="line">    it++;  <span class="comment">// 只能不断 ++ 才能能够移动迭代器</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    test01();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="list-反转和排序"><a href="#list-反转和排序" class="headerlink" title="list 反转和排序"></a>list 反转和排序</h4><ul><li>函数原型：<ul><li><code>reverse();</code>：反转链表</li><li><code>sort();</code>：链表排序</li></ul></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">myCompare</span><span class="params">(<span class="keyword">int</span> val1, <span class="keyword">int</span> val2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> val1 &gt; val2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 反转和排序</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; L;</span><br><span class="line">    L.push_back(<span class="number">90</span>);</span><br><span class="line">    L.push_back(<span class="number">30</span>);</span><br><span class="line">    L.push_back(<span class="number">20</span>);</span><br><span class="line">    L.push_back(<span class="number">70</span>);</span><br><span class="line">    printList(L);  <span class="comment">// 90 30 20 70</span></span><br><span class="line"></span><br><span class="line">    L.reverse();  <span class="comment">// 反转容器的元素</span></span><br><span class="line">    printList(L);  <span class="comment">// 70 20 30 90</span></span><br><span class="line"></span><br><span class="line">    L.sort(); <span class="comment">// 默认的排序规则 从小到大</span></span><br><span class="line">    printList(L);  <span class="comment">// 20 30 70 90</span></span><br><span class="line"></span><br><span class="line">    L.sort(myCompare); <span class="comment">// 指定规则，从大到小</span></span><br><span class="line">    printList(L);  <span class="comment">// 90 70 30 20</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    test01();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="set-multiset-容器"><a href="#set-multiset-容器" class="headerlink" title="set/multiset 容器"></a>set/multiset 容器</h3><h4 id="set-基本概念"><a href="#set-基本概念" class="headerlink" title="set 基本概念"></a>set 基本概念</h4><ul><li><p>简介：</p><ul><li>所有元素都会在插入时自动被排序</li></ul></li><li><p>本质：</p><ul><li>set/multiset 属于<strong>关联式容器</strong>，底层结构是用<strong>二叉树</strong>实现。</li></ul></li><li><p>set 和 multiset 区别：</p><ul><li>set <strong>不允许</strong>容器中有重复的元素</li><li>multiset <strong>允许</strong>容器中有重复的元素</li></ul></li></ul><h4 id="set-构造和赋值"><a href="#set-构造和赋值" class="headerlink" title="set 构造和赋值"></a>set 构造和赋值</h4><ul><li><p>构造：</p><ul><li><code>set&lt;T&gt; st;</code>：默认构造函数：</li><li><code>set(const set &amp;st);</code>：拷贝构造函数</li></ul></li><li><p>赋值：</p><ul><li><code>set&amp; operator=(const set &amp;st);</code>：重载等号操作符</li></ul></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printSet</span><span class="params">(<span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; &amp;s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> it : s) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//构造和赋值</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; s1;</span><br><span class="line"></span><br><span class="line">    s1.insert(<span class="number">10</span>);</span><br><span class="line">    s1.insert(<span class="number">30</span>);</span><br><span class="line">    s1.insert(<span class="number">20</span>);</span><br><span class="line">    s1.insert(<span class="number">40</span>);</span><br><span class="line">    printSet(s1);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//拷贝构造</span></span><br><span class="line">    <span class="function"><span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; <span class="title">s2</span><span class="params">(s1)</span></span>;</span><br><span class="line">    printSet(s2);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//赋值</span></span><br><span class="line">    <span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; s3;</span><br><span class="line">    s3 = s2;</span><br><span class="line">    printSet(s3);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    test01();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="set-大小和交换"><a href="#set-大小和交换" class="headerlink" title="set 大小和交换"></a>set 大小和交换</h4><ul><li>函数原型：<ul><li><code>size();</code>：返回容器中元素的数目</li><li><code>empty();</code>：判断容器是否为空</li><li><code>swap(st);</code>：交换两个集合容器</li></ul></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 大小</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; s1;</span><br><span class="line"></span><br><span class="line">    s1.insert(<span class="number">10</span>);</span><br><span class="line">    s1.insert(<span class="number">30</span>);</span><br><span class="line">    s1.insert(<span class="number">20</span>);</span><br><span class="line">    s1.insert(<span class="number">40</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (s1.empty()) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;s1为空&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;s1不为空&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;s1的大小为： &quot;</span> &lt;&lt; s1.size() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 交换</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; s1;</span><br><span class="line">    s1.insert(<span class="number">10</span>);</span><br><span class="line">    s1.insert(<span class="number">30</span>);</span><br><span class="line">    s1.insert(<span class="number">20</span>);</span><br><span class="line">    s1.insert(<span class="number">40</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; s2;</span><br><span class="line">    s2.insert(<span class="number">100</span>);</span><br><span class="line">    s2.insert(<span class="number">300</span>);</span><br><span class="line">    s2.insert(<span class="number">200</span>);</span><br><span class="line">    s2.insert(<span class="number">400</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;交换前&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    printSet(s1);</span><br><span class="line">    printSet(s2);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;交换后&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    s1.swap(s2);</span><br><span class="line">    printSet(s1);</span><br><span class="line">    printSet(s2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    test01();</span><br><span class="line">    test02();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="set-插入和删除"><a href="#set-插入和删除" class="headerlink" title="set 插入和删除"></a>set 插入和删除</h4><ul><li>函数原型：<ul><li><code>insert(elem);</code>：在容器中插入元素。</li><li><code>clear();</code>：清除所有元素</li><li><code>erase(pos);</code>：删除 pos 迭代器所指的元素，返回下一个元素的迭代器。</li><li><code>erase(beg, end);</code>：删除区间 [beg,end) 的所有元素 ，返回下一个元素的迭代器。</li><li><code>erase(elem);</code>：删除容器中值为 elem 的元素。</li></ul></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 插入和删除</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; s1;</span><br><span class="line">    <span class="comment">//插入</span></span><br><span class="line">    s1.insert(<span class="number">10</span>);</span><br><span class="line">    s1.insert(<span class="number">30</span>);</span><br><span class="line">    s1.insert(<span class="number">20</span>);</span><br><span class="line">    s1.insert(<span class="number">40</span>);</span><br><span class="line">    printSet(s1);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//删除</span></span><br><span class="line">    s1.erase(s1.begin());</span><br><span class="line">    printSet(s1);</span><br><span class="line"></span><br><span class="line">    s1.erase(<span class="number">30</span>);</span><br><span class="line">    printSet(s1);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//清空</span></span><br><span class="line">    <span class="comment">//s1.erase(s1.begin(), s1.end());</span></span><br><span class="line">    s1.clear();</span><br><span class="line">    printSet(s1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    test01();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="set-查找和统计"><a href="#set-查找和统计" class="headerlink" title="set 查找和统计"></a>set 查找和统计</h4><ul><li>函数原型：<ul><li><code>find(key);</code>：查找 key 是否存在，若存在，返回该键的元素的迭代器；若不存在，返回 <code>set.end();</code>。</li><li><code>count(key);</code>：统计 key 的元素个数（对于set，结果为 0 或者 1）</li></ul></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 查找和统计</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; s1;</span><br><span class="line">    s1.insert(<span class="number">10</span>);</span><br><span class="line">    s1.insert(<span class="number">30</span>);</span><br><span class="line">    s1.insert(<span class="number">20</span>);</span><br><span class="line">    s1.insert(<span class="number">40</span>);</span><br><span class="line">  </span><br><span class="line">    <span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt;::iterator pos = s1.find(<span class="number">30</span>);  <span class="comment">// 查找</span></span><br><span class="line">    <span class="keyword">if</span> (pos != s1.end()) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;找到了元素 ： &quot;</span> &lt;&lt; *pos &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;未找到元素&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> num = s1.count(<span class="number">30</span>);  <span class="comment">// 统计</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;num = &quot;</span> &lt;&lt; num &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    test01();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="set-和-multiset-区别"><a href="#set-和-multiset-区别" class="headerlink" title="set 和 multiset 区别"></a>set 和 multiset 区别</h4><ul><li>区别：<ul><li>set 不可以插入重复数据，而 multiset 可以插入重复数据</li><li>set 插入数据会返回<strong>迭代器与结果的对组</strong> <code>pair&lt;set&lt;int&gt;::iterator, bool&gt;</code> ，取 <code>.second</code> 表示插入是否成功</li><li>multiset 插入数据时，仅返回插入结果的迭代器</li></ul></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// set和multiset区别</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line">    <span class="built_in">pair</span>&lt;<span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt;::iterator, <span class="keyword">bool</span>&gt; ret = s.insert(<span class="number">10</span>);</span><br><span class="line">    <span class="keyword">if</span> (ret.second) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;第一次插入成功!&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;第一次插入失败!&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ret = s.insert(<span class="number">10</span>);</span><br><span class="line">    <span class="keyword">if</span> (ret.second) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;第二次插入成功!&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;第二次插入失败!&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// multiset</span></span><br><span class="line">    <span class="built_in">multiset</span>&lt;<span class="keyword">int</span>&gt; ms;</span><br><span class="line">    ms.insert(<span class="number">10</span>);</span><br><span class="line">    ms.insert(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> m : ms) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; m &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    test01();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="pair-对组创建"><a href="#pair-对组创建" class="headerlink" title="pair 对组创建"></a>pair 对组创建</h4><ul><li>两种创建方式：<ul><li><code>pair&lt;type, type&gt; p ( value1, value2 );</code></li><li><code>pair&lt;type, type&gt; p = make_pair( value1, value2 );</code></li></ul></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 对组创建</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    pair&lt;string, int&gt; p(string(&quot;Tom&quot;), 20);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;姓名： &quot;</span> &lt;&lt; p.first &lt;&lt; <span class="string">&quot; 年龄： &quot;</span> &lt;&lt; p.second &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">pair</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt; p2 = <span class="built_in">make_pair</span>(<span class="string">&quot;Jerry&quot;</span>, <span class="number">10</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;姓名： &quot;</span> &lt;&lt; p2.first &lt;&lt; <span class="string">&quot; 年龄： &quot;</span> &lt;&lt; p2.second &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    test01();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="set-容器排序"><a href="#set-容器排序" class="headerlink" title="set 容器排序"></a>set 容器排序</h4><ul><li>总结：<ul><li>只能使用仿函数指定 set 容器的排序规则，不能传递普通函数</li><li>仿函数必须用 const 修饰为常函数</li><li>对于自定义数据类型，set 必须指定排序规则才可以插入数据</li></ul></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">string</span> m_Name;</span><br><span class="line">    <span class="keyword">int</span> m_Age;</span><br><span class="line"></span><br><span class="line">    Person(<span class="built_in">string</span> name, <span class="keyword">int</span> age) &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;m_Name = name;</span><br><span class="line">        <span class="keyword">this</span>-&gt;m_Age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">comparePerson</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 必须要用 const 修饰为常函数</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> Person &amp;p1, <span class="keyword">const</span> Person &amp;p2)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 按照年龄进行降序排序</span></span><br><span class="line">        <span class="keyword">return</span> p1.m_Age &gt; p2.m_Age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">set</span>&lt;Person, comparePerson&gt; s;</span><br><span class="line"></span><br><span class="line">    s.insert(Person(<span class="string">&quot;刘备&quot;</span>, <span class="number">23</span>));</span><br><span class="line">    s.insert(Person(<span class="string">&quot;关羽&quot;</span>, <span class="number">27</span>));</span><br><span class="line">    s.insert(Person(<span class="string">&quot;张飞&quot;</span>, <span class="number">25</span>));</span><br><span class="line">    s.insert(Person(<span class="string">&quot;赵云&quot;</span>, <span class="number">21</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp; it : s) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;姓名： &quot;</span> &lt;&lt; it.m_Name &lt;&lt; <span class="string">&quot; 年龄： &quot;</span> &lt;&lt; it.m_Age &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    test01();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="map-multimap-容器"><a href="#map-multimap-容器" class="headerlink" title="map/multimap 容器"></a>map/multimap 容器</h3><h4 id="map-基本概念"><a href="#map-基本概念" class="headerlink" title="map 基本概念"></a>map 基本概念</h4><ul><li><p>简介：</p><ul><li>map 中所有元素都是 pair</li><li>pair 中第一个元素为 key（键值），第二个元素为 value（实值）</li><li>所有元素都会根据元素的键值自动排序</li></ul></li><li><p>本质：</p><ul><li>map/multimap 属于<strong>关联式容器</strong>，底层结构是用二叉树实现。</li></ul></li><li><p>优点：</p><ul><li>可以根据 key 值快速找到 value 值</li></ul></li><li><p>map 和 multimap 区别：</p><ul><li>map 不允许容器中有重复 key 值元素</li><li>multimap 允许容器中有重复 key 值元素</li></ul></li></ul><h4 id="map-构造和赋值"><a href="#map-构造和赋值" class="headerlink" title="map 构造和赋值"></a>map 构造和赋值</h4><ul><li><p>函数原型：</p><ul><li><p>构造：</p><ul><li><code>map&lt;T1, T2&gt; mp;</code>：map 默认构造函数: </li><li><code>map(const map &amp;mp);</code>：拷贝构造函数</li></ul></li><li><p>赋值：</p><ul><li><code>map&amp; operator=(const map &amp;mp);</code>：重载等号操作符</li></ul></li></ul></li><li><p>总结：map 中所有元素都是成对出现，插入数据时候要使用对组</p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printMap</span><span class="params">(<span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; &amp;m)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp; it : m) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;key = &quot;</span> &lt;&lt; it.first &lt;&lt; <span class="string">&quot; value = &quot;</span> &lt;&lt; it.second &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; m;  <span class="comment">// 默认构造</span></span><br><span class="line">    m.insert(<span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;(<span class="number">1</span>, <span class="number">10</span>));</span><br><span class="line">    m.insert(<span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;(<span class="number">2</span>, <span class="number">20</span>));</span><br><span class="line">    m.insert(<span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;(<span class="number">3</span>, <span class="number">30</span>));</span><br><span class="line">    printMap(m);</span><br><span class="line"></span><br><span class="line">    map&lt;int, int&gt; m2(m);  // 拷贝构造</span><br><span class="line">    printMap(m2);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; m3;</span><br><span class="line">    m3 = m2;  <span class="comment">// 赋值</span></span><br><span class="line">    printMap(m3);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    test01();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="map-大小和交换"><a href="#map-大小和交换" class="headerlink" title="map 大小和交换"></a>map 大小和交换</h4><ul><li>函数原型：<ul><li><code>size();</code>：返回容器中元素的数目</li><li><code>empty();</code>：判断容器是否为空</li><li><code>swap(st);</code>：交换两个集合容器</li></ul></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; m;</span><br><span class="line">    m.insert(<span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;(<span class="number">1</span>, <span class="number">10</span>));</span><br><span class="line">    m.insert(<span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;(<span class="number">2</span>, <span class="number">20</span>));</span><br><span class="line">    m.insert(<span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;(<span class="number">3</span>, <span class="number">30</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (m.empty()) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;m为空&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;m不为空&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;m的大小为： &quot;</span> &lt;&lt; m.size() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 交换</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; m;</span><br><span class="line">    m.insert(<span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;(<span class="number">1</span>, <span class="number">10</span>));</span><br><span class="line">    m.insert(<span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;(<span class="number">2</span>, <span class="number">20</span>));</span><br><span class="line">    m.insert(<span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;(<span class="number">3</span>, <span class="number">30</span>));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; m2;</span><br><span class="line">    m2.insert(<span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;(<span class="number">4</span>, <span class="number">100</span>));</span><br><span class="line">    m2.insert(<span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;(<span class="number">5</span>, <span class="number">200</span>));</span><br><span class="line">    m2.insert(<span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;(<span class="number">6</span>, <span class="number">300</span>));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;交换前&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    printMap(m);</span><br><span class="line">    printMap(m2);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;交换后&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    m.swap(m2);</span><br><span class="line">    printMap(m);</span><br><span class="line">    printMap(m2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    test01();</span><br><span class="line">    test02();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="map-插入和删除"><a href="#map-插入和删除" class="headerlink" title="map 插入和删除"></a>map 插入和删除</h4><ul><li><p>函数原型：</p><ul><li><code>insert(elem);</code>：在容器中插入元素。</li><li><code>clear();</code>：清除所有元素</li><li><code>erase(pos);</code>：删除 pos 迭代器所指的元素，返回下一个元素的迭代器。</li><li><code>erase(beg, end);</code>：删除区间 [beg,end) 的所有元素 ，返回下一个元素的迭代器。</li><li><code>erase(key);</code>：删除容器中值为 key 的元素。</li></ul></li><li><p>提供的 pos 可以为迭代器或者直接为 key</p></li><li><blockquote><p>中括号重载调用，在数据不存在的情况下，会直接初始化一个 0 值，因此<strong>不推荐读取时使用</strong>。</p></blockquote></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 1. 插入</span></span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; m;</span><br><span class="line">    <span class="comment">// 第一种插入方式</span></span><br><span class="line">    m.insert(<span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;(<span class="number">1</span>, <span class="number">10</span>));</span><br><span class="line">    <span class="comment">// 第二种插入方式</span></span><br><span class="line">    m.insert(<span class="built_in">make_pair</span>(<span class="number">2</span>, <span class="number">20</span>));</span><br><span class="line">    <span class="comment">// 第三种插入方式</span></span><br><span class="line">    m.insert(<span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;::value_type(<span class="number">3</span>, <span class="number">30</span>));</span><br><span class="line">    <span class="comment">// 第四种插入方式</span></span><br><span class="line">    m[<span class="number">4</span>] = <span class="number">40</span>;</span><br><span class="line">    printMap(m);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 删除</span></span><br><span class="line">    m.erase(m.begin());</span><br><span class="line">    printMap(m);</span><br><span class="line"></span><br><span class="line">    m.erase(<span class="number">3</span>);</span><br><span class="line">    printMap(m);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 清空</span></span><br><span class="line">    m.erase(m.begin(), m.end());</span><br><span class="line">    m.clear();</span><br><span class="line">    printMap(m);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    test01();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="map-查找和统计"><a href="#map-查找和统计" class="headerlink" title="map 查找和统计"></a>map 查找和统计</h4><ul><li>函数原型：<ul><li><code>find(key);</code>：查找 key 是否存在,若存在，返回该键的元素的迭代器；若不存在，返回 <code>set.end();</code>。</li><li><code>count(key);</code>：统计 key 的元素个数（对于 map，结果为 0 或者 1）</li></ul></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 查找和统计</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; m;</span><br><span class="line">    m.insert(<span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;(<span class="number">1</span>, <span class="number">10</span>));</span><br><span class="line">    m.insert(<span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;(<span class="number">2</span>, <span class="number">20</span>));</span><br><span class="line">    m.insert(<span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;(<span class="number">3</span>, <span class="number">30</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查找</span></span><br><span class="line">    <span class="keyword">auto</span> pos = m.find(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pos != m.end()) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;找到了元素 key = &quot;</span> &lt;&lt; (*pos).first &lt;&lt; <span class="string">&quot; value = &quot;</span> &lt;&lt; (*pos).second &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;未找到元素&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//统计</span></span><br><span class="line">    <span class="keyword">int</span> num = m.count(<span class="number">3</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;num = &quot;</span> &lt;&lt; num &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    test01();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="map-容器排序"><a href="#map-容器排序" class="headerlink" title="map 容器排序"></a>map 容器排序</h4><ul><li><p>总结：</p><ul><li>只能使用仿函数指定 map 容器的排序规则，不能传递普通函数</li><li>仿函数必须用 const 修饰为常函数</li><li>对于自定义数据类型，map 必须指定排序规则才可以插入数据</li></ul></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyCompare</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> v1, <span class="keyword">int</span> v2)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> v1 &gt; v2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 默认从小到大排序</span></span><br><span class="line">    <span class="comment">// 利用仿函数实现从大到小排序</span></span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>, MyCompare&gt; m;</span><br><span class="line"></span><br><span class="line">    m.insert(<span class="built_in">make_pair</span>(<span class="number">1</span>, <span class="number">10</span>));</span><br><span class="line">    m.insert(<span class="built_in">make_pair</span>(<span class="number">2</span>, <span class="number">20</span>));</span><br><span class="line">    m.insert(<span class="built_in">make_pair</span>(<span class="number">3</span>, <span class="number">30</span>));</span><br><span class="line">    m.insert(<span class="built_in">make_pair</span>(<span class="number">4</span>, <span class="number">40</span>));</span><br><span class="line">    m.insert(<span class="built_in">make_pair</span>(<span class="number">5</span>, <span class="number">50</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp; it : m) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;key:&quot;</span> &lt;&lt; it.first &lt;&lt; <span class="string">&quot; value:&quot;</span> &lt;&lt; it.second &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    test01();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="STL-函数对象"><a href="#STL-函数对象" class="headerlink" title="STL 函数对象"></a>STL 函数对象</h2><h3 id="函数对象"><a href="#函数对象" class="headerlink" title="函数对象"></a>函数对象</h3><h4 id="函数对象概念"><a href="#函数对象概念" class="headerlink" title="函数对象概念"></a>函数对象概念</h4><ul><li><p>概念：</p><ul><li>重载<strong>函数调用操作符</strong>的类，其对象常称为<strong>函数对象</strong></li><li><strong>函数对象</strong>使用重载的 <code>()</code> 时，行为类似函数调用，也叫<strong>仿函数</strong></li></ul></li><li><p>本质：</p><ul><li>函数对象（仿函数）是一个<strong>类</strong>，不是一个函数</li></ul></li></ul><h4 id="函数对象使用"><a href="#函数对象使用" class="headerlink" title="函数对象使用"></a>函数对象使用</h4><ul><li>特点：<ul><li>函数对象在使用时，可以像普通函数那样调用，可以有参数，可以有返回值</li><li>函数对象超出普通函数的概念，函数对象可以有自己的状态</li><li>函数对象可以作为参数传递</li></ul></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 函数对象在使用时，可以像普通函数那样调用, 可以有参数，可以有返回值</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyAdd</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span> :</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> v1, <span class="keyword">int</span> v2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> v1 + v2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    MyAdd myAdd;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; myAdd(<span class="number">10</span>, <span class="number">10</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 函数对象可以有自己的状态</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyPrint</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> count;  <span class="comment">// 内部状态</span></span><br><span class="line"></span><br><span class="line">    MyPrint() &#123;</span><br><span class="line">        count = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="built_in">string</span> test)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; test &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        count++; <span class="comment">//统计使用次数</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    MyPrint myPrint;</span><br><span class="line">    myPrint(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">    myPrint(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">    myPrint(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;myPrint调用次数为： &quot;</span> &lt;&lt; myPrint.count &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 函数对象可以作为参数传递</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doPrint</span><span class="params">(MyPrint &amp;mp, <span class="built_in">string</span> test)</span> </span>&#123;</span><br><span class="line">    mp(test);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test03</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    MyPrint myPrint;</span><br><span class="line">    doPrint(myPrint, <span class="string">&quot;Hello C++&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    test01();</span><br><span class="line">    test02();</span><br><span class="line">    test03();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="谓词"><a href="#谓词" class="headerlink" title="谓词"></a>谓词</h3><h4 id="谓词概念"><a href="#谓词概念" class="headerlink" title="谓词概念"></a>谓词概念</h4><ul><li><p>概念：</p><ul><li><strong>返回 bool 类型</strong>的仿函数称为<strong>谓词</strong></li><li>一元谓词：operator() 接受一个参数</li><li>二元谓词：operator() 接受两个参数</li></ul></li><li><blockquote><p>此处与之前不同，可以传递 struct、class、普通函数。</p></blockquote></li></ul><h4 id="一元谓词"><a href="#一元谓词" class="headerlink" title="一元谓词"></a>一元谓词</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 一元谓词</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">GreaterFive</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> val &gt; <span class="number">5</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        v.push_back(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> it = find_if(v.begin(), v.end(), GreaterFive());</span><br><span class="line">    <span class="keyword">if</span> (it == v.end()) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;没找到!&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;找到: &quot;</span> &lt;&lt; *it &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    test01();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="二元谓词"><a href="#二元谓词" class="headerlink" title="二元谓词"></a>二元谓词</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printVector</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> &amp;it : v) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 二元谓词</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyCompare</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> num1, <span class="keyword">int</span> num2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> num1 &gt; num2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">myCompare</span><span class="params">(<span class="keyword">int</span> val1, <span class="keyword">int</span> val2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> val1 &gt; val2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">    v.push_back(<span class="number">10</span>);</span><br><span class="line">    v.push_back(<span class="number">40</span>);</span><br><span class="line">    v.push_back(<span class="number">20</span>);</span><br><span class="line">    v.push_back(<span class="number">30</span>);</span><br><span class="line">    v.push_back(<span class="number">50</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 默认从小到大</span></span><br><span class="line">    sort(v.begin(), v.end());</span><br><span class="line">    printVector(v);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;----------------------------&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用函数对象改变算法策略，排序从大到小</span></span><br><span class="line">    sort(v.begin(), v.end(), MyCompare());</span><br><span class="line">    <span class="comment">// sort(v.begin(), v.end(), myCompare);  // 等价</span></span><br><span class="line">    printVector(v);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    test01();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="内建函数对象"><a href="#内建函数对象" class="headerlink" title="内建函数对象"></a>内建函数对象</h3><h4 id="内建函数对象意义"><a href="#内建函数对象意义" class="headerlink" title="内建函数对象意义"></a>内建函数对象意义</h4><ul><li><p>概念：</p><ul><li>STL 内建的一些函数对象</li></ul></li><li><p>分类:</p><ul><li><p>算术仿函数</p></li><li><p>关系仿函数</p></li><li><p>逻辑仿函数</p></li></ul></li><li><p>使用内建函数对象，需要引入头文件 <code>#include&lt;functional&gt;</code></p></li></ul><h4 id="算术仿函数"><a href="#算术仿函数" class="headerlink" title="算术仿函数"></a>算术仿函数</h4><ul><li>仿函数原型：<ul><li><code>template&lt;class T&gt; T plus&lt;T&gt;</code>：加法仿函数</li><li><code>template&lt;class T&gt; T minus&lt;T&gt;</code>：减法仿函数</li><li><code>template&lt;class T&gt; T multiplies&lt;T&gt;</code>：乘法仿函数</li><li><code>template&lt;class T&gt; T divides&lt;T&gt;</code>：除法仿函数</li><li><code>template&lt;class T&gt; T modulus&lt;T&gt;</code>：取模仿函数</li><li><code>template&lt;class T&gt; T negate&lt;T&gt;</code>：取反仿函数</li></ul></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// negate</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    negate&lt;<span class="keyword">int</span>&gt; n;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; n(<span class="number">50</span>) &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">// -50</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// plus</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    plus&lt;<span class="keyword">int</span>&gt; p;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; p(<span class="number">10</span>, <span class="number">20</span>) &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">// 30</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    test01();</span><br><span class="line">    test02();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="关系仿函数"><a href="#关系仿函数" class="headerlink" title="关系仿函数"></a>关系仿函数</h4><ul><li>仿函数原型：<ul><li><code>template&lt;class T&gt; bool equal_to&lt;T&gt;</code>：等于</li><li><code>template&lt;class T&gt; bool not_equal_to&lt;T&gt;</code>：不等于</li><li><code>template&lt;class T&gt; bool greater&lt;T&gt;</code>：大于</li><li><code>template&lt;class T&gt; bool greater_equal&lt;T&gt;</code>：大于等于</li><li><code>template&lt;class T&gt; bool less&lt;T&gt;</code>：小于</li><li><code>template&lt;class T&gt; bool less_equal&lt;T&gt;</code>：小于等于</li></ul></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printVector</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> &amp;it : v) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyCompare</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> v1, <span class="keyword">int</span> v2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> v1 &gt; v2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">    v.push_back(<span class="number">10</span>);</span><br><span class="line">    v.push_back(<span class="number">30</span>);</span><br><span class="line">    v.push_back(<span class="number">50</span>);</span><br><span class="line">    v.push_back(<span class="number">40</span>);</span><br><span class="line">    v.push_back(<span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">    printVector(v);</span><br><span class="line">    <span class="comment">//sort(v.begin(), v.end(), MyCompare());  // 自己实现仿函数</span></span><br><span class="line">    sort(v.begin(), v.end(), greater&lt;<span class="keyword">int</span>&gt;());  <span class="comment">// STL 内建仿函数</span></span><br><span class="line">    printVector(v);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    test01();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="逻辑仿函数"><a href="#逻辑仿函数" class="headerlink" title="逻辑仿函数"></a>逻辑仿函数</h4><ul><li>函数原型：<ul><li><code>template&lt;class T&gt; bool logical_and&lt;T&gt;</code>：逻辑与</li><li><code>template&lt;class T&gt; bool logical_or&lt;T&gt;</code>：逻辑或</li><li><code>template&lt;class T&gt; bool logical_not&lt;T&gt;</code>：逻辑非</li></ul></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printVector</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; &amp;v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;&amp; it : v) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; v;</span><br><span class="line">    v.push_back(<span class="literal">true</span>);</span><br><span class="line">    v.push_back(<span class="literal">false</span>);</span><br><span class="line">    v.push_back(<span class="literal">true</span>);</span><br><span class="line">    v.push_back(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">    printVector(v);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 逻辑非  将v容器搬运到v2中，并执行逻辑非运算</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; v2;</span><br><span class="line">    v2.resize(v.size());</span><br><span class="line">    transform(v.begin(), v.end(), v2.begin(), logical_not&lt;<span class="keyword">bool</span>&gt;());</span><br><span class="line">    printVector(v2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    test01();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="STL-常用算法"><a href="#STL-常用算法" class="headerlink" title="STL 常用算法"></a>STL 常用算法</h2><ul><li>概述:<ul><li>算法主要是由头文件<code>&lt;algorithm&gt;</code> <code>&lt;functional&gt;</code> <code>&lt;numeric&gt;</code>组成。</li></ul></li><li><code>&lt;algorithm&gt;</code>：是所有 STL 头文件中最大的一个，范围涉及到比较、 交换、查找、遍历操作、复制、修改等</li><li><code>&lt;numeric&gt;</code>：体积很小，只包括几个在序列上面进行简单数学运算的模板函数</li><li><code>&lt;functional&gt;</code>：定义了一些模板类，用以声明函数对象。</li></ul><h3 id="常用遍历算法"><a href="#常用遍历算法" class="headerlink" title="常用遍历算法"></a>常用遍历算法</h3><ul><li>算法简介：<ul><li><code>for_each</code>：遍历容器（常用）</li><li><code>transform</code>：搬运容器到另一个容器中</li></ul></li></ul><h4 id="for-each"><a href="#for-each" class="headerlink" title="for_each"></a>for_each</h4><ul><li>函数原型：<ul><li><code>for_each(iterator beg, iterator end, _func);  </code>：遍历算法 遍历容器元素<ul><li>beg 开始迭代器</li><li>end 结束迭代器</li><li>_func 函数或者函数对象</li></ul></li></ul></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 普通函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print01</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数对象</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">print02</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// for_each 算法基本用法</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        v.push_back(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//遍历算法</span></span><br><span class="line">    for_each(v.begin(), v.end(), print01);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    for_each(v.begin(), v.end(), print02());</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    test01();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="transform"><a href="#transform" class="headerlink" title="transform"></a>transform</h4><ul><li><p>函数原型：</p><ul><li><p><code>transform(iterator beg1, iterator end1, iterator beg2, _func);</code></p><ul><li>beg1：源容器开始迭代器</li><li>end1：源容器结束迭代器</li><li>beg2：目标容器开始迭代器</li><li>_func：函数或者函数对象</li></ul></li></ul></li><li><p>注意：搬运的目标容器必须要提前开辟空间，否则无法正常搬运</p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//常用遍历算法  搬运 transform</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TransForm</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyPrint</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; val + <span class="number">1</span> &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">    v.reserve(<span class="number">10</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        v.push_back(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vTarget;  <span class="comment">// 目标容器</span></span><br><span class="line"></span><br><span class="line">    vTarget.resize(v.size());  <span class="comment">// 目标容器需要提前开辟空间</span></span><br><span class="line"></span><br><span class="line">    transform(v.begin(), v.end(), vTarget.begin(), TransForm());</span><br><span class="line"></span><br><span class="line">    for_each(vTarget.begin(), vTarget.end(), MyPrint());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    test01();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="常用查找算法"><a href="#常用查找算法" class="headerlink" title="常用查找算法"></a>常用查找算法</h3><ul><li>算法简介：<ul><li><code>find</code>：查找元素</li><li><code>find_if</code>：按条件查找元素</li><li><code>adjacent_find</code>：查找相邻重复元素</li><li><code>binary_search</code>：二分查找法</li><li><code>count</code>：统计元素个数</li><li><code>count_if</code>：按条件统计元素个数</li></ul></li></ul><h4 id="find"><a href="#find" class="headerlink" title="find"></a>find</h4><ul><li>函数原型：<ul><li><code>find(iterator beg, iterator end, value);  </code>：按值查找元素，找到返回指定位置迭代器，找不到返回结束迭代器位置<ul><li>beg：开始迭代器</li><li>end：结束迭代器</li><li>value：查找的元素</li></ul></li></ul></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">    v.reserve(<span class="number">10</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        v.push_back(i + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//查找容器中是否有 5 这个元素</span></span><br><span class="line">    <span class="keyword">auto</span> it = find(v.begin(), v.end(), <span class="number">5</span>);</span><br><span class="line">    <span class="keyword">if</span> (it == v.end()) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;没有找到!&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;找到:&quot;</span> &lt;&lt; *it &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">string</span> m_Name;</span><br><span class="line">    <span class="keyword">int</span> m_Age;</span><br><span class="line"></span><br><span class="line">    Person(<span class="built_in">string</span> name, <span class="keyword">int</span> age) &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;m_Name = name;</span><br><span class="line">        <span class="keyword">this</span>-&gt;m_Age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>==(<span class="keyword">const</span> Person &amp;p) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>-&gt;m_Name == p.m_Name &amp;&amp; <span class="keyword">this</span>-&gt;m_Age == p.m_Age) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;Person&gt; v;</span><br><span class="line">    <span class="function">Person <span class="title">p1</span><span class="params">(<span class="string">&quot;aaa&quot;</span>, <span class="number">10</span>)</span></span>;</span><br><span class="line">    <span class="function">Person <span class="title">p2</span><span class="params">(<span class="string">&quot;bbb&quot;</span>, <span class="number">20</span>)</span></span>;</span><br><span class="line">    <span class="function">Person <span class="title">p3</span><span class="params">(<span class="string">&quot;ccc&quot;</span>, <span class="number">30</span>)</span></span>;</span><br><span class="line">    <span class="function">Person <span class="title">p4</span><span class="params">(<span class="string">&quot;ddd&quot;</span>, <span class="number">40</span>)</span></span>;</span><br><span class="line">    v.push_back(p1);</span><br><span class="line">    v.push_back(p2);</span><br><span class="line">    v.push_back(p3);</span><br><span class="line">    v.push_back(p4);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> it = find(v.begin(), v.end(), p2);</span><br><span class="line">    <span class="keyword">if</span> (it == v.end()) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;没有找到!&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;找到姓名:&quot;</span> &lt;&lt; it-&gt;m_Name &lt;&lt; <span class="string">&quot; 年龄: &quot;</span> &lt;&lt; it-&gt;m_Age &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    test01();</span><br><span class="line">    test02();</span><br><span class="line">    <span class="keyword">return</span> EXIT_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="find-if"><a href="#find-if" class="headerlink" title="find_if"></a>find_if</h4><ul><li>函数原型：<ul><li><code>find_if(iterator beg, iterator end, _Pred);  </code>：按值查找元素，找到返回指定位置迭代器，找不到返回结束迭代器位置<ul><li>beg：开始迭代器</li><li>end：结束迭代器</li><li>_Pred：函数或者谓词（返回bool类型的仿函数）</li></ul></li></ul></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 内置数据类型</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GreaterFive</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> val &gt; <span class="number">5</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        v.push_back(i + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> it = find_if(v.begin(), v.end(), GreaterFive());</span><br><span class="line">    <span class="keyword">if</span> (it == v.end()) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;没有找到!&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;找到大于5的数字:&quot;</span> &lt;&lt; *it &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//自定义数据类型</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">string</span> m_Name;</span><br><span class="line">    <span class="keyword">int</span> m_Age;</span><br><span class="line">    </span><br><span class="line">    Person(<span class="built_in">string</span> name, <span class="keyword">int</span> age) &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;m_Name = name;</span><br><span class="line">        <span class="keyword">this</span>-&gt;m_Age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Greater20</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(Person &amp;p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> p.m_Age &gt; <span class="number">20</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;Person&gt; v;</span><br><span class="line">    v.emplace_back(<span class="string">&quot;aaa&quot;</span>, <span class="number">10</span>);</span><br><span class="line">    v.emplace_back(<span class="string">&quot;bbb&quot;</span>, <span class="number">20</span>);</span><br><span class="line">    v.emplace_back(<span class="string">&quot;ccc&quot;</span>, <span class="number">30</span>);</span><br><span class="line">    v.emplace_back(<span class="string">&quot;ddd&quot;</span>, <span class="number">40</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> it = find_if(v.begin(), v.end(), Greater20());</span><br><span class="line">    <span class="keyword">if</span> (it == v.end()) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;没有找到!&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;找到姓名:&quot;</span> &lt;&lt; it-&gt;m_Name &lt;&lt; <span class="string">&quot; 年龄: &quot;</span> &lt;&lt; it-&gt;m_Age &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    test01();</span><br><span class="line">    test02();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="adjacent-find"><a href="#adjacent-find" class="headerlink" title="adjacent_find"></a>adjacent_find</h4><ul><li>函数原型：<ul><li><code>adjacent_find(iterator beg, iterator end);  </code>：查找相邻重复元素,返回相邻元素的第一个位置的迭代器<ul><li>beg：开始迭代器</li><li>end：结束迭代器</li></ul></li></ul></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">    v.push_back(<span class="number">1</span>);</span><br><span class="line">    v.push_back(<span class="number">2</span>);</span><br><span class="line">    v.push_back(<span class="number">5</span>);</span><br><span class="line">    v.push_back(<span class="number">2</span>);</span><br><span class="line">    v.push_back(<span class="number">4</span>);</span><br><span class="line">    v.push_back(<span class="number">4</span>);</span><br><span class="line">    v.push_back(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查找相邻重复元素</span></span><br><span class="line">    <span class="keyword">auto</span> it = adjacent_find(v.begin(), v.end());</span><br><span class="line">    <span class="keyword">if</span> (it == v.end()) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;找不到!&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;找到相邻重复元素为:&quot;</span> &lt;&lt; *it &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    test01();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="binary-search"><a href="#binary-search" class="headerlink" title="binary_search"></a>binary_search</h4><ul><li>函数原型：<ul><li><code>bool binary_search(iterator beg, iterator end, value);  </code>：查找指定的元素，查到则返回 true，否则 false。<ul><li>beg：开始迭代器</li><li>end：结束迭代器</li><li>value：查找的元素</li></ul></li></ul></li><li>注意：在无序序列中不可用</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">    v.reserve(<span class="number">10</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        v.push_back(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 二分查找</span></span><br><span class="line">    <span class="keyword">bool</span> ret = binary_search(v.begin(), v.end(), <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">if</span> (ret) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;找到了&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;未找到&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    test01();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="count"><a href="#count" class="headerlink" title="count"></a>count</h4><ul><li>函数原型：<ul><li><code>count(iterator beg, iterator end, value);  </code>：统计元素出现次数<ul><li>beg：开始迭代器</li><li>end：结束迭代器</li><li>value：统计的元素</li></ul></li></ul></li><li>统计自定义数据类型时候，需要配合重载 <code>operator==</code>。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 内置数据类型</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">    v.push_back(<span class="number">1</span>);</span><br><span class="line">    v.push_back(<span class="number">2</span>);</span><br><span class="line">    v.push_back(<span class="number">4</span>);</span><br><span class="line">    v.push_back(<span class="number">5</span>);</span><br><span class="line">    v.push_back(<span class="number">3</span>);</span><br><span class="line">    v.push_back(<span class="number">4</span>);</span><br><span class="line">    v.push_back(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;4的个数为： &quot;</span> &lt;&lt; count(v.begin(), v.end(), <span class="number">4</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义数据类型</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">string</span> m_Name;</span><br><span class="line">    <span class="keyword">int</span> m_Age;</span><br><span class="line">    </span><br><span class="line">    Person(<span class="built_in">string</span> name, <span class="keyword">int</span> age) &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;m_Name = name;</span><br><span class="line">        <span class="keyword">this</span>-&gt;m_Age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>==(<span class="keyword">const</span> Person &amp;p) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>-&gt;m_Age == p.m_Age) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;Person&gt; v;</span><br><span class="line">    v.emplace_back(<span class="string">&quot;刘备&quot;</span>, <span class="number">35</span>);</span><br><span class="line">    v.emplace_back(<span class="string">&quot;关羽&quot;</span>, <span class="number">35</span>);</span><br><span class="line">    v.emplace_back(<span class="string">&quot;张飞&quot;</span>, <span class="number">35</span>);</span><br><span class="line">    v.emplace_back(<span class="string">&quot;赵云&quot;</span>, <span class="number">30</span>);</span><br><span class="line">    v.emplace_back(<span class="string">&quot;曹操&quot;</span>, <span class="number">25</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;num = &quot;</span> &lt;&lt; count(v.begin(), v.end(), Person(<span class="string">&quot;诸葛亮&quot;</span>, <span class="number">35</span>)) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    test01();</span><br><span class="line">    test02();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="count-if"><a href="#count-if" class="headerlink" title="count_if"></a>count_if</h4><ul><li>函数原型：<ul><li><code>count_if(iterator beg, iterator end, _Pred);  </code>：按条件统计元素出现次数<ul><li>beg：开始迭代器</li><li>end：结束迭代器</li><li>_Pred：谓词</li></ul></li></ul></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Greater4</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> val &gt;= <span class="number">4</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 置数据类型</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">    v.push_back(<span class="number">1</span>);</span><br><span class="line">    v.push_back(<span class="number">2</span>);</span><br><span class="line">    v.push_back(<span class="number">4</span>);</span><br><span class="line">    v.push_back(<span class="number">5</span>);</span><br><span class="line">    v.push_back(<span class="number">3</span>);</span><br><span class="line">    v.push_back(<span class="number">4</span>);</span><br><span class="line">    v.push_back(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;大于4的个数为： &quot;</span> &lt;&lt; count_if(v.begin(), v.end(), Greater4()) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义数据类型</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">string</span> m_Name;</span><br><span class="line">    <span class="keyword">int</span> m_Age;</span><br><span class="line">    </span><br><span class="line">    Person(<span class="built_in">string</span> name, <span class="keyword">int</span> age) &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;m_Name = name;</span><br><span class="line">        <span class="keyword">this</span>-&gt;m_Age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AgeLess35</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> Person &amp;p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> p.m_Age &lt; <span class="number">35</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;Person&gt; v;</span><br><span class="line">    v.emplace_back(<span class="string">&quot;刘备&quot;</span>, <span class="number">35</span>);</span><br><span class="line">    v.emplace_back(<span class="string">&quot;关羽&quot;</span>, <span class="number">35</span>);</span><br><span class="line">    v.emplace_back(<span class="string">&quot;张飞&quot;</span>, <span class="number">35</span>);</span><br><span class="line">    v.emplace_back(<span class="string">&quot;赵云&quot;</span>, <span class="number">30</span>);</span><br><span class="line">    v.emplace_back(<span class="string">&quot;曹操&quot;</span>, <span class="number">25</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;小于35岁的个数：&quot;</span> &lt;&lt; count_if(v.begin(), v.end(), AgeLess35()) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    test01();</span><br><span class="line">    test02();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="常用排序算法"><a href="#常用排序算法" class="headerlink" title="常用排序算法"></a>常用排序算法</h3><ul><li>算法简介：<ul><li><code>sort</code>：对容器内元素进行排序</li><li><code>random_shuffle</code>：洗牌   指定范围内的元素随机调整次序</li><li><code>merge </code>：容器元素合并，并存储到另一容器中</li><li><code>reverse</code>：反转指定范围的元素</li></ul></li></ul><h4 id="sort"><a href="#sort" class="headerlink" title="sort"></a>sort</h4><ul><li>函数原型：<ul><li><code>sort(iterator beg, iterator end, _Pred);  </code>：按值查找元素，找到返回指定位置迭代器，找不到返回结束迭代器位置<ul><li>beg：开始迭代器</li><li>end：结束迭代器</li><li>_Pred：谓词</li></ul></li></ul></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myPrint</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">    v.push_back(<span class="number">10</span>);</span><br><span class="line">    v.push_back(<span class="number">30</span>);</span><br><span class="line">    v.push_back(<span class="number">50</span>);</span><br><span class="line">    v.push_back(<span class="number">20</span>);</span><br><span class="line">    v.push_back(<span class="number">40</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// sort 默认从小到大排序</span></span><br><span class="line">    sort(v.begin(), v.end());</span><br><span class="line">    for_each(v.begin(), v.end(), myPrint);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从大到小排序</span></span><br><span class="line">    sort(v.begin(), v.end(), greater&lt;<span class="keyword">int</span>&gt;());</span><br><span class="line">    for_each(v.begin(), v.end(), myPrint);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    test01();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="random-shuffle"><a href="#random-shuffle" class="headerlink" title="random_shuffle"></a>random_shuffle</h4><ul><li>函数原型：<ul><li><code>random_shuffle(iterator beg, iterator end);  </code>：指定范围内的元素随机调整次序<ul><li>beg：开始迭代器</li><li>end：结束迭代器、</li></ul></li></ul></li><li><code>random_shuffle</code> 在 C++11 中被标记 deprecated，在 C++14 中被 removed。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctime&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">myPrint</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    srand((<span class="keyword">unsigned</span> <span class="keyword">int</span>) time(<span class="literal">nullptr</span>));</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        v.push_back(i);</span><br><span class="line">    &#125;</span><br><span class="line">    for_each(v.begin(), v.end(), myPrint());</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//打乱顺序</span></span><br><span class="line">    random_shuffle(v.begin(), v.end());</span><br><span class="line">    for_each(v.begin(), v.end(), myPrint());</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    test01();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="merge"><a href="#merge" class="headerlink" title="merge"></a>merge</h4><ul><li>函数原型：<ul><li><code>merge(iterator beg1, iterator end1, iterator beg2, iterator end2, iterator dest);  </code>：容器元素合并，并存储到另一容器中<ul><li>beg1：容器 1 开始迭代器</li><li>end1：容器 1 结束迭代器</li><li>beg2：容器 2 开始迭代器</li><li>end2：容器 2 结束迭代器</li><li>dest：目标容器开始迭代器</li></ul></li></ul></li><li>注意: 两个容器必须是<strong>有序的</strong></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">myPrint</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v1;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v2;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        v1.push_back(i);</span><br><span class="line">        v2.push_back(i + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vtarget;</span><br><span class="line">    vtarget.resize(v1.size() + v2.size());  <span class="comment">// 目标容器需要提前开辟空间</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//合并: 需要两个有序序列</span></span><br><span class="line">    merge(v1.begin(), v1.end(), v2.begin(), v2.end(), vtarget.begin());</span><br><span class="line">    for_each(vtarget.begin(), vtarget.end(), myPrint());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    test01();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="reverse"><a href="#reverse" class="headerlink" title="reverse"></a>reverse</h4><ul><li>函数原型：<ul><li><code>reverse(iterator beg, iterator end);  </code>：反转指定范围的元素<ul><li>beg：开始迭代器</li><li>end：结束迭代器</li></ul></li></ul></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">myPrint</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">    v.push_back(<span class="number">10</span>);</span><br><span class="line">    v.push_back(<span class="number">30</span>);</span><br><span class="line">    v.push_back(<span class="number">50</span>);</span><br><span class="line">    v.push_back(<span class="number">20</span>);</span><br><span class="line">    v.push_back(<span class="number">40</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;反转前： &quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    for_each(v.begin(), v.end(), myPrint());</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;反转后： &quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    reverse(v.begin(), v.end());</span><br><span class="line">    for_each(v.begin(), v.end(), myPrint());</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    test01();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="常用拷贝和替换算法"><a href="#常用拷贝和替换算法" class="headerlink" title="常用拷贝和替换算法"></a>常用拷贝和替换算法</h3><ul><li>算法简介：<ul><li><code>copy</code>：容器内指定范围的元素拷贝到另一容器中</li><li><code>replace</code>：将容器内指定范围的旧元素修改为新元素</li><li><code>replace_if </code>：容器内指定范围满足条件的元素替换为新元素</li><li><code>swap</code>：互换两个容器的元素</li></ul></li></ul><h4 id="copy"><a href="#copy" class="headerlink" title="copy"></a>copy</h4><ul><li>函数原型：<ul><li><code>copy(iterator beg, iterator end, iterator dest);  </code>：按值查找元素，找到返回指定位置迭代器，找不到返回结束迭代器位置<ul><li>beg：源开始迭代器</li><li>end：源结束迭代器</li><li>dest：目标起始迭代器</li></ul></li></ul></li><li>拷贝前需要提前开辟空间</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">myPrint</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v1;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        v1.push_back(i + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v2;</span><br><span class="line">    v2.resize(v1.size());  <span class="comment">// 提前开辟空间</span></span><br><span class="line">    copy(v1.begin(), v1.end(), v2.begin());</span><br><span class="line"></span><br><span class="line">    for_each(v2.begin(), v2.end(), myPrint());</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    test01();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="replace"><a href="#replace" class="headerlink" title="replace"></a>replace</h4><ul><li>函数原型：<ul><li><code>replace(iterator beg, iterator end, oldvalue, newvalue);  </code>：将区间内旧元素替换成新元素<ul><li>beg：开始迭代器</li><li>end：结束迭代器</li><li>oldvalue：旧元素</li><li>newvalue：新元素</li></ul></li></ul></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">myPrint</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">    v.push_back(<span class="number">20</span>);</span><br><span class="line">    v.push_back(<span class="number">30</span>);</span><br><span class="line">    v.push_back(<span class="number">20</span>);</span><br><span class="line">    v.push_back(<span class="number">40</span>);</span><br><span class="line">    v.push_back(<span class="number">50</span>);</span><br><span class="line">    v.push_back(<span class="number">10</span>);</span><br><span class="line">    v.push_back(<span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;替换前：&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    for_each(v.begin(), v.end(), myPrint());</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将容器中的 20 替换成 2000</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;替换后：&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    replace(v.begin(), v.end(), <span class="number">20</span>, <span class="number">2000</span>);</span><br><span class="line">    for_each(v.begin(), v.end(), myPrint());</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    test01();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="replace-if"><a href="#replace-if" class="headerlink" title="replace_if"></a>replace_if</h4><ul><li>函数原型：<ul><li><code>replace_if(iterator beg, iterator end, _pred, newvalue);  </code>：按条件替换元素，满足条件的替换成指定元素<ul><li>beg：开始迭代器</li><li>end：结束迭代器</li><li>_pred：谓词</li><li>newvalue：替换的新元素</li></ul></li></ul></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">myPrint</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ReplaceGreater30</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> val &gt;= <span class="number">30</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">    v.push_back(<span class="number">20</span>);</span><br><span class="line">    v.push_back(<span class="number">30</span>);</span><br><span class="line">    v.push_back(<span class="number">20</span>);</span><br><span class="line">    v.push_back(<span class="number">40</span>);</span><br><span class="line">    v.push_back(<span class="number">50</span>);</span><br><span class="line">    v.push_back(<span class="number">10</span>);</span><br><span class="line">    v.push_back(<span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;替换前：&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    for_each(v.begin(), v.end(), myPrint());</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将容器中大于等于的30 替换成 3000</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;替换后：&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    replace_if(v.begin(), v.end(), ReplaceGreater30(), <span class="number">3000</span>);</span><br><span class="line">    for_each(v.begin(), v.end(), myPrint());</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    test01();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="swap"><a href="#swap" class="headerlink" title="swap"></a>swap</h4><ul><li>函数原型：<ul><li><code>swap(container c1, container c2);  </code>：互换两个容器的元素<ul><li>c1：容器1</li><li>c2：容器2</li></ul></li></ul></li><li>swap 交换容器时，注意交换的容器要同种类型</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">myPrint</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v1;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v2;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        v1.push_back(i);</span><br><span class="line">        v2.push_back(i + <span class="number">100</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;交换前： &quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    for_each(v1.begin(), v1.end(), myPrint());</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    for_each(v2.begin(), v2.end(), myPrint());</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;交换后： &quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    swap(v1, v2);</span><br><span class="line">    for_each(v1.begin(), v1.end(), myPrint());</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    for_each(v2.begin(), v2.end(), myPrint());</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    test01();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="常用算术生成算法"><a href="#常用算术生成算法" class="headerlink" title="常用算术生成算法"></a>常用算术生成算法</h3><ul><li><p>注意：</p><ul><li>算术生成算法属于小型算法，使用时包含的头文件为 <code>#include &lt;numeric&gt;</code></li><li>通常比较实用</li></ul></li><li><p>算法简介：</p><ul><li><p><code>accumulate</code>：计算容器元素累计总和</p></li><li><p><code>fill</code>：向容器中添加元素</p></li></ul></li></ul><h4 id="accumulate"><a href="#accumulate" class="headerlink" title="accumulate"></a>accumulate</h4><ul><li>函数原型：<ul><li><code>accumulate(iterator beg, iterator end, value);  </code>：计算容器元素累计总和<ul><li>beg：开始迭代器</li><li>end：结束迭代器</li><li>value：起始值</li></ul></li></ul></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;numeric&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">100</span>; i++) &#123;</span><br><span class="line">        v.push_back(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> total = accumulate(v.begin(), v.end(), <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;total = &quot;</span> &lt;&lt; total &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    test01();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="fill"><a href="#fill" class="headerlink" title="fill"></a>fill</h4><ul><li>函数原型：<ul><li><code>fill(iterator beg, iterator end, value);  </code>：向容器中填充元素<ul><li>beg：开始迭代器</li><li>end：结束迭代器</li><li>value：填充的值</li></ul></li></ul></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;numeric&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">myPrint</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">    v.resize(<span class="number">10</span>);</span><br><span class="line">    <span class="comment">//填充</span></span><br><span class="line">    fill(v.begin(), v.end(), <span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">    for_each(v.begin(), v.end(), myPrint());</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    test01();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="常用集合算法"><a href="#常用集合算法" class="headerlink" title="常用集合算法"></a>常用集合算法</h3><ul><li><p>算法简介：</p><ul><li><p><code>set_intersection</code>：求两个容器的交集</p></li><li><p><code>set_union</code>：求两个容器的并集</p></li><li><p><code>set_difference </code>：求两个容器的差集</p></li></ul></li></ul><h4 id="set-intersection"><a href="#set-intersection" class="headerlink" title="set_intersection"></a>set_intersection</h4><ul><li><p>函数原型：</p><ul><li><code>set_intersection(iterator beg1, iterator end1, iterator beg2, iterator end2, iterator dest);  </code>：求两个集合的交集<ul><li>beg1：容器 1 开始迭代器</li><li>end1：容器 1 结束迭代器</li><li>beg2：容器 2 开始迭代器</li><li>end2：容器 2 结束迭代器</li><li>dest：目标容器开始迭代器</li></ul></li></ul></li><li><p>注意： </p><ul><li>求交集的两个集合必须是<strong>有序序列</strong>。</li><li>目标容器开辟空间需要从<strong>两个容器中取小值</strong>。</li><li>set_intersection 返回值是交集中最后一个元素的位置。</li></ul></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">myPrint</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v1;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v2;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        v1.push_back(i);</span><br><span class="line">        v2.push_back(i + <span class="number">5</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vTarget;</span><br><span class="line">    vTarget.resize(min(v1.size(), v2.size()));  <span class="comment">// 取两个里面较小的值给目标容器开辟空间</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回目标容器的最后一个元素的迭代器地址</span></span><br><span class="line">    <span class="keyword">auto</span> itEnd = set_intersection(v1.begin(), v1.end(), v2.begin(), v2.end(), vTarget.begin());</span><br><span class="line"></span><br><span class="line">    for_each(vTarget.begin(), itEnd, myPrint());</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    test01();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="set-union"><a href="#set-union" class="headerlink" title="set_union"></a>set_union</h4><ul><li>函数原型：<ul><li><code>set_union(iterator beg1, iterator end1, iterator beg2, iterator end2, iterator dest);  </code>：求两个集合的并集<ul><li>beg1：容器 1 开始迭代器</li><li>end1：容器 1 结束迭代器</li><li>beg2：容器 2 开始迭代器</li><li>end2：容器 2 结束迭代器</li><li>dest：目标容器开始迭代器</li></ul></li></ul></li><li>注意：<ul><li>求并集的两个集合必须的<strong>有序序列</strong>。</li><li>目标容器开辟空间需要<strong>两个容器相加</strong>。</li><li>set_union 返回值既是并集中最后一个元素的位置。</li></ul></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">myPrint</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v1;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v2;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        v1.push_back(i);</span><br><span class="line">        v2.push_back(i + <span class="number">5</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vTarget;</span><br><span class="line">    vTarget.resize(v1.size() + v2.size());  <span class="comment">// 取两个容器的和给目标容器开辟空间</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回目标容器的最后一个元素的迭代器地址</span></span><br><span class="line">    <span class="keyword">auto</span> itEnd = set_union(v1.begin(), v1.end(), v2.begin(), v2.end(), vTarget.begin());</span><br><span class="line"></span><br><span class="line">    for_each(vTarget.begin(), itEnd, myPrint());</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    test01();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="set-difference"><a href="#set-difference" class="headerlink" title="set_difference"></a>set_difference</h4><ul><li>函数原型：<ul><li><code>set_difference(iterator beg1, iterator end1, iterator beg2, iterator end2, iterator dest);  </code>：求两个集合的差集<ul><li>beg1：容器 1 开始迭代器</li><li>end1：容器 1 结束迭代器</li><li>beg2：容器 2 开始迭代器</li><li>end2：容器 2 结束迭代器</li><li>dest：目标容器开始迭代器</li></ul></li></ul></li><li>注意： <ul><li>v1 和 v2 的差集与 v2 和 v1 的差集是不一样的。</li><li>求差集的两个集合必须是<strong>有序序列</strong>。</li><li>目标容器开辟空间需要从<strong>两个容器取较大值</strong>。</li><li>set_difference 返回值既是差集中最后一个元素的位置。</li></ul></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">myPrint</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v1;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v2;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        v1.push_back(i);</span><br><span class="line">        v2.push_back(i + <span class="number">5</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vTarget;</span><br><span class="line"></span><br><span class="line">    vTarget.resize(max(v1.size(), v2.size()));  <span class="comment">// 取两个里面较大的值给目标容器开辟空间</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回目标容器的最后一个元素的迭代器地址</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;v1与v2的差集为： &quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">auto</span> itEnd =set_difference(v1.begin(), v1.end(), v2.begin(), v2.end(), vTarget.begin());</span><br><span class="line">    for_each(vTarget.begin(), itEnd, myPrint());</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;v2与v1的差集为： &quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    itEnd = set_difference(v2.begin(), v2.end(), v1.begin(), v1.end(), vTarget.begin());</span><br><span class="line">    for_each(vTarget.begin(), itEnd, myPrint());</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    test01();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>C++-Part2</title>
      <link href="/2022/1/C++-Part2/"/>
      <url>/2022/1/C++-Part2/</url>
      
        <content type="html"><![CDATA[<h1 id="C-Part2——核心编程"><a href="#C-Part2——核心编程" class="headerlink" title="C++-Part2——核心编程"></a>C++-Part2——核心编程</h1><p>[TOC]</p><h2 id="内存分区模型"><a href="#内存分区模型" class="headerlink" title="内存分区模型"></a>内存分区模型</h2><h3 id="内存分区概述"><a href="#内存分区概述" class="headerlink" title="内存分区概述"></a>内存分区概述</h3><ul><li><p>C++ 程序在执行时，将内存大方向划分为 4 个区域</p><ul><li>代码区：存放函数体的二进制代码，<strong>由操作系统进行管理的</strong></li><li>全局区：存放全局变量、静态变量、字符串常量、全局常量，<strong>在程序结束后由操作系统释放</strong></li><li>栈区：<strong>由编译器自动分配释放</strong>，存放函数的参数值、局部变量、局部常量等</li><li>堆区：<strong>由程序员分配和释放</strong>，若程序员不释放，则程序结束时由操作系统回收</li></ul></li><li><p>内存分区的意义：</p><ul><li>不同区域存放的数据，赋予不同的生命周期，提供更大的灵活编程</li></ul></li></ul><h3 id="程序运行前"><a href="#程序运行前" class="headerlink" title="程序运行前"></a>程序运行前</h3><ul><li>在程序编译后，生成了 exe 可执行程序，在程序运行前分为<strong>全局区</strong>和<strong>代码区</strong>。</li></ul><ul><li>代码区：<ul><li>存放 CPU 执行的机器指令</li><li>代码区是<strong>共享</strong>的，共享的目的是对于频繁被执行的程序，只需要在内存中有一份代码即可</li><li>代码区是<strong>只读</strong>的，使其只读的原因是防止程序意外地修改了它的指令</li></ul></li><li>全局区：<ul><li><strong>全局变量、静态变量</strong>存放在此.</li><li>全局区包含常量区，存放<strong>字符串常量、const 修饰的全局常量</strong>.</li><li><strong>该区域的数据仅在程序结束后由操作系统释放</strong></li></ul></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//全局变量</span></span><br><span class="line"><span class="keyword">int</span> g_a = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> g_b = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//全局常量</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> c_g_a = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> c_g_b = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//局部变量</span></span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">int</span> b = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//打印地址</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;局部变量a地址为： &quot;</span> &lt;&lt; (<span class="keyword">int</span>) &amp;a &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;局部变量b地址为： &quot;</span> &lt;&lt; (<span class="keyword">int</span>) &amp;b &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;全局变量g_a地址为： &quot;</span> &lt;&lt; (<span class="keyword">int</span>) &amp;g_a &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;全局变量g_b地址为： &quot;</span> &lt;&lt; (<span class="keyword">int</span>) &amp;g_b &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//静态变量</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> s_a = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> s_b = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;静态变量s_a地址为： &quot;</span> &lt;&lt; (<span class="keyword">int</span>) &amp;s_a &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;静态变量s_b地址为： &quot;</span> &lt;&lt; (<span class="keyword">int</span>) &amp;s_b &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;字符串常量地址为： &quot;</span> &lt;&lt; (<span class="keyword">int</span>) &amp;<span class="string">&quot;hello world&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;字符串常量地址为： &quot;</span> &lt;&lt; (<span class="keyword">int</span>) &amp;<span class="string">&quot;hello world1&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;全局常量c_g_a地址为： &quot;</span> &lt;&lt; (<span class="keyword">int</span>) &amp;c_g_a &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;全局常量c_g_b地址为： &quot;</span> &lt;&lt; (<span class="keyword">int</span>) &amp;c_g_b &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> c_l_a = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> c_l_b = <span class="number">10</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;局部常量c_l_a地址为： &quot;</span> &lt;&lt; (<span class="keyword">int</span>) &amp;c_l_a &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;局部常量c_l_b地址为： &quot;</span> &lt;&lt; (<span class="keyword">int</span>) &amp;c_l_b &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 局部变量a地址为： 14088016</span></span><br><span class="line"><span class="comment"> * 局部变量b地址为： 14088004</span></span><br><span class="line"><span class="comment"> * 全局变量g_a地址为： 15974400</span></span><br><span class="line"><span class="comment"> * 全局变量g_b地址为： 15974404</span></span><br><span class="line"><span class="comment"> * 静态变量s_a地址为： 15974412</span></span><br><span class="line"><span class="comment"> * 静态变量s_b地址为： 15974416</span></span><br><span class="line"><span class="comment"> * 字符串常量地址为： 15965632</span></span><br><span class="line"><span class="comment"> * 字符串常量地址为： 15965664</span></span><br><span class="line"><span class="comment"> * 全局常量c_g_a地址为： 15965260</span></span><br><span class="line"><span class="comment"> * 全局常量c_g_b地址为： 15965472</span></span><br><span class="line"><span class="comment"> * 局部常量c_l_a地址为： 14087992</span></span><br><span class="line"><span class="comment"> * 局部常量c_l_b地址为： 14087980</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><h3 id="程序运行后"><a href="#程序运行后" class="headerlink" title="程序运行后"></a>程序运行后</h3><ul><li>栈区：<ul><li>由编译器自动分配释放, 存放函数的参数值,局部变量等</li><li>注意事项：不要返回局部变量的地址，栈区开辟的数据由编译器自动释放</li></ul></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> *<span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">return</span> &amp;a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> *p = func();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; *p &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">// 在外部第一次调用时，编译器会对数据做一次保留</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; *p &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">// 第二次调用时彻底消失</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>堆区：<ul><li>由程序员分配释放，若程序员不释放，程序结束时由操作系统回收</li><li>在 C++ 中主要利用 new 在堆区开辟内存</li></ul></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> *<span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> *a = <span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">10</span>);</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> *p = func();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; *p &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; *p &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="new-操作符"><a href="#new-操作符" class="headerlink" title="new 操作符"></a>new 操作符</h3><ul><li><p>利用 new 操作符在堆区<strong>开辟</strong>数据</p></li><li><p>利用 delete 操作符在堆区<strong>释放</strong>数据</p></li></ul><ul><li><p>语法：</p><ul><li><code> new 数据类型</code></li><li><code>delete 变量名</code></li></ul></li><li><blockquote><p>返回的是该类型的指针/地址</p><p>删除的类型应当是指针/地址</p></blockquote></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 堆区创建int</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> *<span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> *a = <span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">10</span>);  <span class="comment">// 利用new创建的数据，会返回该数据对应的类型的指针</span></span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> *p = func();</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; *p &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 利用delete释放堆区数据</span></span><br><span class="line">    <span class="keyword">delete</span> p;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; *p &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">// 报错，释放的空间不可访问</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 堆区开辟数组</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> *arr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>]&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>,&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        arr[i] = i + <span class="number">100</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; arr[i] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//释放数组 delete 后加 []</span></span><br><span class="line">    <span class="keyword">delete</span>[] arr;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><blockquote><p>参考：<a href="https://www.zhihu.com/question/37608201/answer/1601079930">c++中，引用和指针的区别是什么？ - 编程指北的回答 - 知乎</a> </p></blockquote><h3 id="引用的基本使用"><a href="#引用的基本使用" class="headerlink" title="引用的基本使用"></a>引用的基本使用</h3><ul><li><p>作用：给变量起别名</p></li><li><p>语法：<code>数据类型 &amp;别名 = 原名</code></p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">int</span> &amp;b = a;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;b = &quot;</span> &lt;&lt; b &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    b = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;b = &quot;</span> &lt;&lt; b &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="引用注意事项"><a href="#引用注意事项" class="headerlink" title="引用注意事项"></a>引用注意事项</h3><ul><li>引用必须初始化</li><li>引用在初始化后，不可以改变</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">int</span> b = <span class="number">20</span>;</span><br><span class="line">    <span class="comment">// int &amp;c;  // 错误，引用必须初始化</span></span><br><span class="line">    <span class="keyword">int</span> &amp;c = a;  <span class="comment">// 一旦初始化后，就不可以更改</span></span><br><span class="line">    c = b;  <span class="comment">// 这是赋值操作，不是更改引用</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;b = &quot;</span> &lt;&lt; b &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;c = &quot;</span> &lt;&lt; c &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="引用做函数参数"><a href="#引用做函数参数" class="headerlink" title="引用做函数参数"></a>引用做函数参数</h3><ul><li><p>作用：函数传参时，可以利用引用的技术让形参修饰实参</p></li><li><p>优点：可以简化指针修改实参</p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1. 值传递</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mySwap01</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp = a;</span><br><span class="line">    a = b;</span><br><span class="line">    b = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2. 地址传递</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mySwap02</span><span class="params">(<span class="keyword">int</span> *a, <span class="keyword">int</span> *b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp = *a;</span><br><span class="line">    *a = *b;</span><br><span class="line">    *b = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//3. 引用传递</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mySwap03</span><span class="params">(<span class="keyword">int</span> &amp;a, <span class="keyword">int</span> &amp;b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp = a;</span><br><span class="line">    a = b;</span><br><span class="line">    b = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">int</span> b = <span class="number">20</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;a:&quot;</span> &lt;&lt; a &lt;&lt; <span class="string">&quot; b:&quot;</span> &lt;&lt; b &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">// a:10 b:20</span></span><br><span class="line"></span><br><span class="line">    mySwap01(a, b);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;a:&quot;</span> &lt;&lt; a &lt;&lt; <span class="string">&quot; b:&quot;</span> &lt;&lt; b &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">// a:10 b:20</span></span><br><span class="line"></span><br><span class="line">    mySwap02(&amp;a, &amp;b);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;a:&quot;</span> &lt;&lt; a &lt;&lt; <span class="string">&quot; b:&quot;</span> &lt;&lt; b &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">// a:20 b:10</span></span><br><span class="line"></span><br><span class="line">    mySwap03(a, b);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;a:&quot;</span> &lt;&lt; a &lt;&lt; <span class="string">&quot; b:&quot;</span> &lt;&lt; b &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">// a:10 b:20</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="引用做函数返回值"><a href="#引用做函数返回值" class="headerlink" title="引用做函数返回值"></a>引用做函数返回值</h3><ul><li><p>作用：引用是可以作为函数的返回值存在的</p></li><li><p>注意：<strong>不要返回局部变量引用</strong></p></li><li><p>用法：函数调用作为左值</p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回局部变量引用</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> &amp;<span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">10</span>;  <span class="comment">// 局部变量</span></span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回静态变量引用</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> &amp;<span class="title">test02</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> a = <span class="number">20</span>;  <span class="comment">// 静态变量，操作的是位于全局区的变量，不会新建一个对象</span></span><br><span class="line">    <span class="comment">// int &amp;a = *(new int(20));  // 堆区变量，两次调用返回两个不同的对象</span></span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 不能返回局部变量的引用</span></span><br><span class="line">    <span class="keyword">int</span> &amp;ref = test01();</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;ref = &quot;</span> &lt;&lt; ref &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">// ref = 13630156</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;ref = &quot;</span> &lt;&lt; ref &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">// ref = 13630156</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果函数做左值，那么必须返回引用</span></span><br><span class="line">    <span class="keyword">int</span> &amp;ref2 = test02();</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;ref2 = &quot;</span> &lt;&lt; ref2 &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">// ref2 = 20</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;ref2 = &quot;</span> &lt;&lt; ref2 &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">// ref2 = 20</span></span><br><span class="line"></span><br><span class="line">    test02() = <span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;ref2 = &quot;</span> &lt;&lt; ref2 &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">// ref2 = 1000</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;ref2 = &quot;</span> &lt;&lt; ref2 &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">// ref2 = 1000</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="引用的本质"><a href="#引用的本质" class="headerlink" title="引用的本质"></a>引用的本质</h3><ul><li>本质：<strong>引用的本质在 C++ 内部实现是一个指针常量</strong>。</li><li>C++ 推荐用引用技术，因为语法方便，引用本质是指针常量，但是所有的指针操作编译器都帮我们做了</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 发现是引用，转换为 int* const ref = &amp;a;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> &amp;ref)</span> </span>&#123;</span><br><span class="line">    ref = <span class="number">100</span>;  <span class="comment">// ref是引用，转换为*ref = 100</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 自动转换为 int* const ref = &amp;a; 指针常量是指针指向不可改，也说明为什么引用不可更改</span></span><br><span class="line">    <span class="keyword">int</span> &amp;ref = a;</span><br><span class="line">    ref = <span class="number">20</span>;  <span class="comment">// 内部发现ref是引用，自动帮我们转换为: *ref = 20;</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;a:&quot;</span> &lt;&lt; a &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;ref:&quot;</span> &lt;&lt; ref &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    func(a);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="常量引用"><a href="#常量引用" class="headerlink" title="常量引用"></a>常量引用</h3><ul><li>作用：常量引用主要用来修饰形参，防止误操作</li><li>在函数形参列表中，<strong>加 const 修饰形参，防止形参改变实参</strong></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 发现是引用，转换为 int* const ref = &amp;a;</span></span><br><span class="line"><span class="comment">// 引用使用的场景，通常用来修饰形参</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">showValue</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> &amp;v)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// v += 10;</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; v &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// int&amp; ref = 10;  引用本身需要一个合法的内存空间，因此这行错误</span></span><br><span class="line">    <span class="comment">// 加入const就可以了，编译器优化代码，int temp = 10; const int&amp; ref = temp;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> &amp;ref = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ref = 100;  // 加入const后不可以修改变量</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ref &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 函数中利用常量引用防止误操作修改实参</span></span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">    showValue(a);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="函数提高"><a href="#函数提高" class="headerlink" title="函数提高"></a>函数提高</h2><h3 id="函数默认参数"><a href="#函数默认参数" class="headerlink" title="函数默认参数"></a>函数默认参数</h3><ul><li><p>在 C++ 中，函数的形参列表中的形参是可以有默认值的。</p></li><li><p>语法：<code> 返回值类型 函数名 (参数= 默认值) &#123;&#125;</code></p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">func1</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b = <span class="number">10</span>, <span class="keyword">int</span> c = <span class="number">10</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b + c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. 如果某个位置参数有默认值，那么从这个位置往后，从左向右，必须都要有默认值</span></span><br><span class="line"><span class="comment">// 2. 如果函数声明/实现有默认值，则函数实现/声明的时候就不能有默认参数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">func2</span><span class="params">(<span class="keyword">int</span> a = <span class="number">10</span>, <span class="keyword">int</span> b = <span class="number">10</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">func2</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;ret = &quot;</span> &lt;&lt; func1(<span class="number">20</span>, <span class="number">20</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;ret = &quot;</span> &lt;&lt; func2(<span class="number">100</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="函数占位参数"><a href="#函数占位参数" class="headerlink" title="函数占位参数"></a>函数占位参数</h3><ul><li><p>C++ 中函数的形参列表里可以有占位参数，用来做占位，调用函数时必须填补该位置</p></li><li><p>语法： <code>返回值类型 函数名 (数据类型) &#123;&#125;</code></p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//函数占位参数 ，占位参数也可以有默认参数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> = <span class="number">10</span>)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;this is func&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    func(<span class="number">10</span>, <span class="number">10</span>); <span class="comment">//占位参数必须填补</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="函数重载"><a href="#函数重载" class="headerlink" title="函数重载"></a>函数重载</h3><h4 id="函数重载概述"><a href="#函数重载概述" class="headerlink" title="函数重载概述"></a>函数重载概述</h4><ul><li><p>作用：函数名可以相同，提高复用性</p></li><li><p>函数重载满足条件：</p><ul><li>同一个作用域下</li><li>函数名称相同</li><li>函数参数<strong>类型不同</strong>或者<strong>个数不同</strong>或者<strong>顺序不同</strong>。</li></ul></li><li><p>注意:  函数的返回值不可以作为函数重载的条件</p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//函数重载需要函数都在同一个作用域下</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;func 的调用！&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> a)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;func (int a) 的调用！&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">double</span> a)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;func (double a)的调用！&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">double</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;func (int a ,double b) 的调用！&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">double</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;func (double a ,int b)的调用！&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//函数返回值不可以作为函数重载条件</span></span><br><span class="line"><span class="comment">//int func(double a, int b)</span></span><br><span class="line"><span class="comment">//&#123;</span></span><br><span class="line"><span class="comment">//cout &lt;&lt; &quot;func (double a ,int b)的调用！&quot; &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    func();</span><br><span class="line">    func(<span class="number">10</span>);</span><br><span class="line">    func(<span class="number">3.14</span>);</span><br><span class="line">    func(<span class="number">10</span>, <span class="number">3.14</span>);</span><br><span class="line">    func(<span class="number">3.14</span>, <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="函数重载注意事项"><a href="#函数重载注意事项" class="headerlink" title="函数重载注意事项"></a>函数重载注意事项</h4><ul><li>引用作为重载条件</li><li>函数重载碰到函数默认参数</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1、引用作为重载条件</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func1</span><span class="params">(<span class="keyword">int</span> &amp;a)</span> </span>&#123;  <span class="comment">// int &amp;a = 10; 不合法</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;func (int &amp;a) 调用 &quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func1</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> &amp;a)</span> </span>&#123;  <span class="comment">// const int &amp;a = 10; 合法</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;func (const int &amp;a) 调用 &quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2、函数重载碰到函数默认参数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func2</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b = <span class="number">10</span>)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;func2(int a, int b = 10) 调用&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func2</span><span class="params">(<span class="keyword">int</span> a)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;func2(int a) 调用&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">    func1(a); <span class="comment">// 调用无const</span></span><br><span class="line">    func1(<span class="number">10</span>);<span class="comment">// 调用有const</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//func2(10); // 碰到默认参数产生歧义，需要避免</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="类和对象"><a href="#类和对象" class="headerlink" title="类和对象"></a>类和对象</h2><blockquote><p>面向对象的三大特性为：<strong>封装</strong>、<strong>继承</strong>、<strong>多态</strong>。</p><p><strong>万事万物都皆为对象</strong>，对象上有其属性和行为。</p></blockquote><h3 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h3><h4 id="封装的意义"><a href="#封装的意义" class="headerlink" title="封装的意义"></a>封装的意义</h4><ul><li><p>封装的意义：</p><ul><li>将属性和行为作为一个整体</li><li>将属性和行为加以权限控制<ul><li>公共权限（public）：类内可以访问，类外可以访问，子类可以访问</li><li>保护权限（protected）：类内可以访问，类外不可以访问，子类可以访问</li><li>私有权限（private）：类内可以访问，类外不可以访问，子类不可以访问</li></ul></li></ul></li><li><p>语法：<code>class 类名 &#123; 访问权限： 属性 / 行为 &#125;;</code></p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line">    <span class="comment">//姓名  公共权限</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">string</span> m_Name;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//汽车  保护权限</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="built_in">string</span> m_Car;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//银行卡密码  私有权限</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> m_Password;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        m_Name = <span class="string">&quot;张三&quot;</span>;</span><br><span class="line">        m_Car = <span class="string">&quot;拖拉机&quot;</span>;</span><br><span class="line">        m_Password = <span class="number">123456</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Person p;</span><br><span class="line">    p.m_Name = <span class="string">&quot;李四&quot;</span>;</span><br><span class="line">    <span class="comment">//p.m_Car = &quot;奔驰&quot;;  // 保护权限类外访问不到</span></span><br><span class="line">    <span class="comment">//p.m_Password = 123; // 私有权限类外访问不到</span></span><br><span class="line">    p.func();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="truct-和-class-区别"><a href="#truct-和-class-区别" class="headerlink" title="truct 和 class 区别"></a>truct 和 class 区别</h4><ul><li><p>在 C++ 中 struct 和 class 唯一的区别就在于默认的访问权限不同</p></li><li><p>区别：</p><ul><li>struct：默认权限为公共</li><li>class：默认权限为私有</li></ul></li></ul><h4 id="成员属性设置为私有"><a href="#成员属性设置为私有" class="headerlink" title="成员属性设置为私有"></a>成员属性设置为私有</h4><ul><li>优点<ul><li>将所有成员属性设置为私有，可以自己控制读写权限</li><li>对于写权限，我们可以检测数据的有效性</li></ul></li></ul><h3 id="对象的初始化和清理"><a href="#对象的初始化和清理" class="headerlink" title="对象的初始化和清理"></a>对象的初始化和清理</h3><h4 id="构造函数和析构函数"><a href="#构造函数和析构函数" class="headerlink" title="构造函数和析构函数"></a>构造函数和析构函数</h4><ul><li><p>对象的<strong>初始化和清理</strong>是两个非常重要的安全问题</p><ul><li>一个对象或者变量没有初始状态，对其使用后果是未知</li><li>同样的使用完一个对象或变量，没有及时清理，也会造成一定的安全问题</li></ul></li><li><p>c++利用了<strong>构造函数</strong>和<strong>析构函数</strong>解决上述问题，这两个函数将会被编译器自动调用，完成对象初始化和清理工作。</p><ul><li>对象的初始化和清理工作是编译器强制要我们做的事情，因此如果<strong>我们不提供构造和析构，编译器会提供</strong></li><li><strong>编译器提供的构造函数和析构函数是空实现。</strong></li></ul></li></ul><ul><li>构造函数 <code>类名()&#123;&#125;</code>：主要作用在于<strong>创建对象时</strong>为对象的成员属性赋值，构造函数由编译器自动调用，无须手动调用。<ol><li>构造函数，没有返回值也不写 void</li><li>函数名称与类名相同</li><li>构造函数可以有参数，因此可以发生重载</li><li>程序在调用对象时候会自动调用构造，无须手动调用，而且只会调用一次</li></ol></li><li>析构函数 <code>~类名()&#123;&#125;</code>：主要作用在于对象<strong>销毁前</strong>系统自动调用，执行一些清理工作。<ol><li>析构函数，没有返回值也不写 void</li><li>函数名称与类名相同,在名称前加上符号  ~</li><li>析构函数不可以有参数，因此不可以发生重载</li><li>程序在对象销毁前会自动调用析构，无须手动调用，而且只会调用一次</li></ol></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//构造函数</span></span><br><span class="line">    Person() &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Person的构造函数调用&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//析构函数</span></span><br><span class="line">    ~Person() &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Person的析构函数调用&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Person p;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="构造函数的分类及调用"><a href="#构造函数的分类及调用" class="headerlink" title="构造函数的分类及调用"></a>构造函数的分类及调用</h4><ul><li>两种分类方式：<ul><li>按参数分为：有参构造和无参构造<ul><li>无参又称为默认构造函数</li></ul></li><li>按类型分为：普通构造和拷贝构造</li></ul></li><li>三种调用方式：<ul><li>括号法</li><li>显示法</li><li>隐式转换法</li></ul></li><li>注意<ul><li>调用无参构造函数不能加括号，如果加了编译器认为这是一个函数声明</li><li>不能利用拷贝构造函数初始化匿名对象，否则编译器认为是对象声明（老版本）</li></ul></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1、构造函数分类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 无参(默认)构造函数</span></span><br><span class="line">    Person() &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;无参构造函数!&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 有参普通构造函数</span></span><br><span class="line">    Person(<span class="keyword">int</span> a) &#123;</span><br><span class="line">        age = a;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;有参构造函数!&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 拷贝构造函数</span></span><br><span class="line">    <span class="comment">// 可以不写，编译器提供的拷贝函数自动复制成员变量值</span></span><br><span class="line">    Person(<span class="keyword">const</span> Person &amp;p) &#123;</span><br><span class="line">        age = p.age;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;拷贝构造函数!&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 析构函数</span></span><br><span class="line">    ~Person() &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;析构函数!&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2、构造函数的调用</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 调用无参构造函数</span></span><br><span class="line">    Person p; <span class="comment">//调用无参构造函数</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用有参的构造函数</span></span><br><span class="line">    <span class="comment">// 2.1  括号法，常用</span></span><br><span class="line">    <span class="function">Person <span class="title">p1</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">    <span class="comment">//注意1：调用无参构造函数不能加括号，如果加了编译器认为这是一个函数声明</span></span><br><span class="line">    <span class="comment">//Person p2();</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.2 显式法</span></span><br><span class="line">    Person p2 = Person(<span class="number">10</span>);</span><br><span class="line">    Person p3 = Person(p2);</span><br><span class="line">    Person(<span class="number">10</span>);  <span class="comment">// 单独写就是匿名对象  当前行结束之后，马上析构</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.3 隐式转换法</span></span><br><span class="line">    Person p4 = <span class="number">10</span>; <span class="comment">// Person p4 = Person(10);</span></span><br><span class="line">    Person p5 = p4; <span class="comment">// Person p5 = Person(p4);</span></span><br><span class="line">    <span class="comment">//注意2：不能利用 拷贝构造函数 初始化匿名对象 编译器认为是对象声明</span></span><br><span class="line">    <span class="comment">//Person p6(p4);</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="拷贝构造函数调用时机"><a href="#拷贝构造函数调用时机" class="headerlink" title="拷贝构造函数调用时机"></a>拷贝构造函数调用时机</h4><ul><li>C++ 中拷贝构造函数调用时机通常有三种情况<ul><li>使用一个已经创建完毕的对象来初始化一个新对象</li><li>值传递的方式给函数参数传值</li><li>以值方式返回局部对象</li></ul></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 使用一个已经创建完毕的对象来初始化一个新对象</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">Person <span class="title">man</span><span class="params">(<span class="number">100</span>)</span></span>;  <span class="comment">// p对象已经创建完毕</span></span><br><span class="line">    <span class="function">Person <span class="title">newman</span><span class="params">(man)</span></span>;  <span class="comment">// 调用拷贝构造函数</span></span><br><span class="line">    Person newman2 = man;  <span class="comment">// 拷贝构造</span></span><br><span class="line">    Person newman3;</span><br><span class="line">    newman3 = man;  <span class="comment">// 不是调用拷贝构造函数，赋值操作</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 值传递的方式给函数参数传值</span></span><br><span class="line"><span class="comment">// 相当于 Person p1 = p;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doWork</span><span class="params">(Person p1)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Person p;  <span class="comment">// 无参构造函数</span></span><br><span class="line">    doWork(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 以值方式返回局部对象</span></span><br><span class="line"><span class="function">Person <span class="title">doWork2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Person p1;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; (<span class="keyword">int</span> *) &amp;p1 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> p1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test03</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Person p = doWork2();</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; (<span class="keyword">int</span> *) &amp;p &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    test01();</span><br><span class="line">    <span class="comment">// test02();</span></span><br><span class="line">    <span class="comment">// test03();</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="构造函数调用规则"><a href="#构造函数调用规则" class="headerlink" title="构造函数调用规则"></a>构造函数调用规则</h4><ul><li><p>默认情况下，c++ 编译器至少给一个类添加 3 个函数</p><ol><li>默认构造函数（无参，函数体为空）</li><li>默认析构函数（无参，函数体为空）</li><li>默认拷贝构造函数，对属性进行值拷贝</li></ol></li><li><p>构造函数调用规则如下：</p><ul><li><p>如果用户定义有参构造函数，C++ 不会提供默认无参构造，但是会提供默认拷贝构造</p></li><li><p>如果用户定义拷贝构造函数，C++ 不会再提供其他构造函数</p></li></ul></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">Person <span class="title">p1</span><span class="params">(<span class="number">18</span>)</span></span>;</span><br><span class="line">    <span class="function">Person <span class="title">p2</span><span class="params">(p1)</span></span>;  <span class="comment">//如果不写拷贝构造，编译器会自动添加拷贝构造，并且做浅拷贝操作</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;p2的年龄为： &quot;</span> &lt;&lt; p2.age &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 如果用户提供有参构造，编译器不会提供默认构造，但会提供拷贝构造</span></span><br><span class="line">    Person p1;  <span class="comment">// 此时如果用户自己没有提供默认构造，会出错</span></span><br><span class="line">    <span class="function">Person <span class="title">p2</span><span class="params">(<span class="number">10</span>)</span></span>;  <span class="comment">// 用户提供的有参</span></span><br><span class="line">    <span class="function">Person <span class="title">p3</span><span class="params">(p2)</span></span>;  <span class="comment">// 此时如果用户没有提供拷贝构造，编译器会提供</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果用户提供拷贝构造，编译器不会提供其他构造函数</span></span><br><span class="line">    Person p4;  <span class="comment">// 此时如果用户自己没有提供默认构造，会出错</span></span><br><span class="line">    <span class="function">Person <span class="title">p5</span><span class="params">(<span class="number">10</span>)</span></span>;  <span class="comment">// 此时如果用户自己没有提供有参，会出错</span></span><br><span class="line">    <span class="function">Person <span class="title">p6</span><span class="params">(p5)</span></span>;  <span class="comment">// 用户自己提供拷贝构造</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    test01();</span><br><span class="line">    test02();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="深拷贝与浅拷贝"><a href="#深拷贝与浅拷贝" class="headerlink" title="深拷贝与浅拷贝"></a>深拷贝与浅拷贝</h4><ul><li><p>浅拷贝：简单的赋值拷贝操作</p></li><li><p>深拷贝：在堆区重新申请空间，进行拷贝操作</p></li><li><blockquote><p>注意：如果属性有在堆区开辟的，一定要自己提供拷贝构造函数，防止浅拷贝带来的问题</p></blockquote></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> m_age&#123;&#125;;</span><br><span class="line">    <span class="keyword">int</span> *m_height&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//无参（默认）构造函数</span></span><br><span class="line">    Person() &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;无参构造函数!&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//有参构造函数</span></span><br><span class="line">    Person(<span class="keyword">int</span> age, <span class="keyword">int</span> height) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;有参构造函数!&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        m_age = age;</span><br><span class="line">        m_height = <span class="keyword">new</span> <span class="keyword">int</span>(height);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//拷贝构造函数</span></span><br><span class="line">    Person(<span class="keyword">const</span> Person &amp;p) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;拷贝构造函数!&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="comment">//如果不利用深拷贝在堆区创建新内存，有可能会导致浅拷贝带来的重复释放堆区问题</span></span><br><span class="line">        m_age = p.m_age;</span><br><span class="line">        m_height = <span class="keyword">new</span> <span class="keyword">int</span>(*p.m_height);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//析构函数</span></span><br><span class="line">    ~Person() &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;析构函数!&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">if</span> (m_height != <span class="literal">nullptr</span> &amp;&amp; *m_height != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">delete</span> m_height;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">Person <span class="title">p1</span><span class="params">(<span class="number">18</span>, <span class="number">180</span>)</span></span>;</span><br><span class="line">    <span class="function">Person <span class="title">p2</span><span class="params">(p1)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;p1的年龄： &quot;</span> &lt;&lt; p1.m_age &lt;&lt; <span class="string">&quot; 身高： &quot;</span> &lt;&lt; *p1.m_height &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;p2的年龄： &quot;</span> &lt;&lt; p2.m_age &lt;&lt; <span class="string">&quot; 身高： &quot;</span> &lt;&lt; *p2.m_height &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="初始化列表"><a href="#初始化列表" class="headerlink" title="初始化列表"></a>初始化列表</h4><ul><li>作用：C++ 提供了初始化列表语法，用来初始化属性</li><li>语法：<code>构造函数()：属性1(值1),属性2（值2）... &#123;&#125;</code></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> m_A;</span><br><span class="line">    <span class="keyword">int</span> m_B;</span><br><span class="line">    <span class="keyword">int</span> m_C;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 传统方式初始化</span></span><br><span class="line">    <span class="comment">//Person(int a, int b, int c) &#123;</span></span><br><span class="line">    <span class="comment">//m_A = a;</span></span><br><span class="line">    <span class="comment">//m_B = b;</span></span><br><span class="line">    <span class="comment">//m_C = c;</span></span><br><span class="line">    <span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//初始化列表方式初始化</span></span><br><span class="line">    Person(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c) : m_A(a), m_B(b), m_C(c) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">PrintPerson</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;mA:&quot;</span> &lt;&lt; m_A &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;mB:&quot;</span> &lt;&lt; m_B &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;mC:&quot;</span> &lt;&lt; m_C &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">Person <span class="title">p</span><span class="params">(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span></span>;</span><br><span class="line">    p.PrintPerson();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="类对象作为类成员"><a href="#类对象作为类成员" class="headerlink" title="类对象作为类成员"></a>类对象作为类成员</h4><ul><li>C++ 类中的成员可以是另一个类的对象，我们称该成员为<strong>对象成员</strong>。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> &#123;</span></span><br><span class="line">    A a；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>一个对象 A 与其对象成员 B 的构造和析构的先后顺序？<ul><li>先构造对象成员 B</li><li>先析构对象 A</li><li>析构顺序与构造相反</li></ul></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Phone</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">string</span> m_PhoneName;</span><br><span class="line"></span><br><span class="line">    Phone(<span class="built_in">string</span> name) &#123;</span><br><span class="line">        m_PhoneName = name;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Phone构造&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~Phone() &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Phone析构&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">string</span> m_Name;</span><br><span class="line">    Phone m_Phone;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//初始化列表可以告诉编译器调用哪一个构造函数</span></span><br><span class="line">    Person(<span class="built_in">string</span> name, <span class="built_in">string</span> pName) : m_Name(name), m_Phone(pName) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="keyword">this</span>-&gt;m_Name &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Person构造&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~Person() &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Person析构&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">playGame</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; m_Name &lt;&lt; <span class="string">&quot; 使用&quot;</span> &lt;&lt; m_Phone.m_PhoneName &lt;&lt; <span class="string">&quot; 牌手机! &quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">Person <span class="title">p</span><span class="params">(<span class="string">&quot;张三&quot;</span>, <span class="string">&quot;苹果X&quot;</span>)</span></span>;</span><br><span class="line">    p.playGame();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="静态成员"><a href="#静态成员" class="headerlink" title="静态成员"></a>静态成员</h4><ul><li><p>静态成员就是在成员变量和成员函数前加上关键字 static，称为静态成员</p></li><li><p>静态成员分为：</p><ul><li>静态成员变量<ul><li> 所有对象共享同一份数据</li><li> 在编译阶段分配内存</li><li> 类内声明，类外初始化</li></ul></li><li>静态成员函数<ul><li> 所有对象共享同一个函数</li><li> 静态成员函数只能访问静态成员变量</li></ul></li></ul></li><li><p>静态成员变量特点：</p><ol><li>在编译阶段分配内存</li><li>类内声明，类外初始化</li><li>所有对象共享同一份数据</li></ol></li><li><p>静态成员函数特点：</p><ol><li>程序共享一个函数</li><li>静态成员函数只能访问静态成员变量</li></ol></li><li><p>静态成员变量与函数都可以设定访问权限</p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> m_C;  <span class="comment">// 静态成员变量也是有访问权限的</span></span><br><span class="line">    <span class="keyword">int</span> m_B;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 静态成员函数也是有访问权限的</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">func2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;func2调用&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> m_A;  <span class="comment">// 静态成员变量</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;func调用&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        m_A = <span class="number">100</span>;</span><br><span class="line">        <span class="comment">//m_B = 100;  // 错误，不可以访问非静态成员变量</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> Person::m_A = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> Person::m_C = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//静态成员变量两种访问方式</span></span><br><span class="line">    <span class="comment">//1、通过对象</span></span><br><span class="line">    Person p1;</span><br><span class="line">    p1.m_A = <span class="number">100</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;p1.m_A = &quot;</span> &lt;&lt; p1.m_A &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    Person p2;</span><br><span class="line">    p2.m_A = <span class="number">200</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;p1.m_A = &quot;</span> &lt;&lt; p1.m_A &lt;&lt; <span class="built_in">endl</span>; <span class="comment">//共享同一份数据</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;p2.m_A = &quot;</span> &lt;&lt; p2.m_A &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2、通过类名</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;m_A = &quot;</span> &lt;&lt; Person::m_A &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//cout &lt;&lt; &quot;m_C = &quot; &lt;&lt; Person::m_C &lt;&lt; endl; //私有权限访问不到</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//静态成员变量两种访问方式</span></span><br><span class="line">    <span class="comment">//1、通过对象</span></span><br><span class="line">    Person p1;</span><br><span class="line">    p1.func();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2、通过类名</span></span><br><span class="line">    Person::func();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Person::func2(); // 私有权限访问不到</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    test01();</span><br><span class="line">    test02();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="C-对象模型和-this-指针"><a href="#C-对象模型和-this-指针" class="headerlink" title="C++ 对象模型和 this 指针"></a>C++ 对象模型和 this 指针</h3><h4 id="成员变量和成员函数分开存储"><a href="#成员变量和成员函数分开存储" class="headerlink" title="成员变量和成员函数分开存储"></a>成员变量和成员函数分开存储</h4><ul><li><p>在 C++ 中，类内的成员变量和成员函数分开存储</p></li><li><p>注意：只有<strong>非静态成员变量</strong>才属于类的对象上</p></li><li><blockquote><ol><li>空对象占用的是 1 字节<ul><li>C++ 为每个空对象分配一个字节的空间，为了区分空对象占内存的位置</li></ul></li><li>存在<strong>非静态成员变量</strong>时，按照非静态成员变量的大小和分配空间</li></ol></blockquote></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 非静态成员变量占对象空间</span></span><br><span class="line">    <span class="keyword">int</span> mA;</span><br><span class="line">    <span class="comment">// 静态成员变量不占对象空间</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> mB;</span><br><span class="line"></span><br><span class="line">    Person() &#123;</span><br><span class="line">        mA = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 函数也不占对象空间，所有函数共享一个函数实例</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//静态成员函数也不占对象空间</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">s_func</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="keyword">sizeof</span>(Person) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="this-指针概念"><a href="#this-指针概念" class="headerlink" title="this 指针概念"></a>this 指针概念</h4><ul><li><p><strong>每一个非静态成员函数只会诞生一份函数实例</strong>，即多个同类的对象会共用一块代码</p></li><li><p>针对问题：非静态成员函数如何区分调用自己的对象</p><ul><li><p>this 指针指向调用的成员函数的对象</p></li><li><p>this 指针是隐含在每一个非静态成员函数内的一种指针</p></li><li><p>this 指针不需要定义，直接使用即可</p></li></ul></li><li><p>this 指针的用途：</p><ul><li>当形参和成员变量同名时，可用 this 指针来区分</li><li>在类的非静态成员函数中返回对象本身，可使用 <code>return *this</code>。</li></ul></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    Person(<span class="keyword">int</span> age) &#123;</span><br><span class="line">        <span class="comment">//1、当形参和成员变量同名时，可用this指针来区分</span></span><br><span class="line">        <span class="keyword">this</span>-&gt;age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">Person &amp;<span class="title">PersonAddPerson</span><span class="params">(Person p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;age += p.age;</span><br><span class="line">        <span class="comment">//返回对象本身</span></span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">Person <span class="title">p1</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;p1.age = &quot;</span> &lt;&lt; p1.age &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">Person <span class="title">p2</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">    p2.PersonAddPerson(p1).PersonAddPerson(p1).PersonAddPerson(p1);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;p2.age = &quot;</span> &lt;&lt; p2.age &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="空指针访问成员函数"><a href="#空指针访问成员函数" class="headerlink" title="空指针访问成员函数"></a>空指针访问成员函数</h4><ul><li><p>C++ 中空指针也是可以调用非静态成员函数，但是要注意不能用到 this 指针</p></li><li><p>首先要避免空指针</p><ul><li>如果空指针对象调用的函数必须用到 this 指针，需要加以判断保证代码的健壮性</li></ul></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//空指针访问成员函数</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> mAge;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">ShowClassName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;我是Person类!&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">ShowPerson</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; mAge &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Person *p = <span class="literal">nullptr</span>;</span><br><span class="line">    p-&gt;ShowClassName();  <span class="comment">// 空指针，可以非静态调用成员函数</span></span><br><span class="line">    p-&gt;ShowPerson();  <span class="comment">// 但是如果成员函数中用到了this指针，就不可以了</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="const-修饰成员函数"><a href="#const-修饰成员函数" class="headerlink" title="const 修饰成员函数"></a>const 修饰成员函数</h4><ul><li><p>常函数：</p><ul><li>声明成员函数时在函数名后加 const ，即常函数</li><li>常函数内不可以修改非静态成员变量</li></ul></li><li><p>常对象：</p><ul><li>声明对象前加 const ，则该对象为常对象</li><li>常对象只能调用常函数</li></ul></li><li><p>用 mutable 修饰的非静态成员变量，在常函数、常变量中依然可以修改</p></li><li><blockquote><p>this 指针的本质是一个指针常量，指针的指向不可修改。</p><p>如果想让指针指向的值也不可以修改，需要声明常函数。</p></blockquote></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> m_A;</span><br><span class="line">    <span class="keyword">mutable</span> <span class="keyword">int</span> m_B;  <span class="comment">// 可修改、可变的</span></span><br><span class="line"></span><br><span class="line">    Person() &#123;</span><br><span class="line">        m_A = <span class="number">0</span>;</span><br><span class="line">        m_B = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">ShowPerson</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">        <span class="comment">// const Type* const pointer;</span></span><br><span class="line">        <span class="comment">// const 修饰成员函数，表示指针指向的内存空间的数据不能修改，除了 mutable 修饰的变量</span></span><br><span class="line">        <span class="keyword">this</span>-&gt;m_B = <span class="number">100</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">MyFunc</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">        <span class="comment">//mA = 10000;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> Person person;  <span class="comment">// 常量对象</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; person.m_A &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">//person.mA = 100;  // 常对象不能修改成员变量的值,但是可以访问</span></span><br><span class="line">    person.m_B = <span class="number">100</span>;  <span class="comment">// 但是常对象可以修改mutable修饰成员变量</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 常对象访问成员函数</span></span><br><span class="line">    person.MyFunc();  <span class="comment">// 常对象只能调用常函数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="友元"><a href="#友元" class="headerlink" title="友元"></a>友元</h3><ul><li><p>针对问题：对于有些私有属性，也想让类外特殊的函数或类访问</p></li><li><p>友元 <code>friend</code> 的目的：让一个函数或者类访问另一个类中私有成员</p></li><li><p>友元的三种实现：</p><ul><li>全局函数做友元</li><li>类做友元</li><li>成员函数做友元</li></ul></li></ul><h4 id="全局函数做友元"><a href="#全局函数做友元" class="headerlink" title="全局函数做友元"></a>全局函数做友元</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Building</span> &#123;</span></span><br><span class="line">    <span class="comment">// 告诉编译器 goodGay 全局函数 是 Building类的好朋友，可以访问类中的私有内容</span></span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="keyword">void</span> <span class="title">goodGay</span><span class="params">(Building *building)</span></span>;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">string</span> m_BedRoom; <span class="comment">//卧室</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">string</span> m_SittingRoom; <span class="comment">//客厅</span></span><br><span class="line">    </span><br><span class="line">    Building() &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;m_SittingRoom = <span class="string">&quot;客厅&quot;</span>;</span><br><span class="line">        <span class="keyword">this</span>-&gt;m_BedRoom = <span class="string">&quot;卧室&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">goodGay</span><span class="params">(Building *building)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;好基友正在访问： &quot;</span> &lt;&lt; building-&gt;m_SittingRoom &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;好基友正在访问： &quot;</span> &lt;&lt; building-&gt;m_BedRoom &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Building b;</span><br><span class="line">    goodGay(&amp;b);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="类做友元"><a href="#类做友元" class="headerlink" title="类做友元"></a>类做友元</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 先声明类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Building</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">goodGay</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Building *building;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    goodGay();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">visit</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Building</span> &#123;</span></span><br><span class="line">    <span class="comment">// 告诉编译器 goodGay 类是 Building 类的好朋友，可以访问到 Building 类中私有内容</span></span><br><span class="line">    <span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">goodGay</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">string</span> m_BedRoom;  <span class="comment">// 卧室</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">string</span> m_SittingRoom;  <span class="comment">// 客厅</span></span><br><span class="line"></span><br><span class="line">    Building();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类外实现函数</span></span><br><span class="line">Building::Building() &#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;m_SittingRoom = <span class="string">&quot;客厅&quot;</span>;</span><br><span class="line">    <span class="keyword">this</span>-&gt;m_BedRoom = <span class="string">&quot;卧室&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">goodGay::goodGay() &#123;</span><br><span class="line">    building = <span class="keyword">new</span> Building;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">goodGay::visit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;好基友正在访问&quot;</span> &lt;&lt; building-&gt;m_SittingRoom &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;好基友正在访问&quot;</span> &lt;&lt; building-&gt;m_BedRoom &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    goodGay gg;</span><br><span class="line">    gg.visit();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="成员函数做友元"><a href="#成员函数做友元" class="headerlink" title="成员函数做友元"></a>成员函数做友元</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Building</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">goodGay</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Building *building;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    goodGay();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">visit</span><span class="params">()</span></span>;  <span class="comment">// 只让 visit 函数作为 Building 的好朋友，可以发访问 Building 中私有内容</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">visit2</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Building</span> &#123;</span></span><br><span class="line">    <span class="comment">// 告诉编译器 goodGay 类中的 visit 成员函数是 Building 好朋友，可以访问私有内容</span></span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="keyword">void</span> <span class="title">goodGay::visit</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">string</span> m_BedRoom;<span class="comment">//卧室</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">string</span> m_SittingRoom; <span class="comment">//客厅</span></span><br><span class="line"></span><br><span class="line">    Building();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Building::Building() &#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;m_SittingRoom = <span class="string">&quot;客厅&quot;</span>;</span><br><span class="line">    <span class="keyword">this</span>-&gt;m_BedRoom = <span class="string">&quot;卧室&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">goodGay::goodGay() &#123;</span><br><span class="line">    building = <span class="keyword">new</span> Building;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">goodGay::visit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;好基友正在访问&quot;</span> &lt;&lt; building-&gt;m_SittingRoom &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;好基友正在访问&quot;</span> &lt;&lt; building-&gt;m_BedRoom &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">goodGay::visit2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;好基友正在访问&quot;</span> &lt;&lt; building-&gt;m_SittingRoom &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">//cout &lt;&lt; &quot;好基友正在访问&quot; &lt;&lt; building-&gt;m_BedRoom &lt;&lt; endl;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    goodGay gg;</span><br><span class="line">    gg.visit();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="运算符重载"><a href="#运算符重载" class="headerlink" title="运算符重载"></a>运算符重载</h3><h4 id="加号运算符重载"><a href="#加号运算符重载" class="headerlink" title="加号运算符重载"></a>加号运算符重载</h4><ul><li>作用：实现两个自定义数据类型相加的运算</li><li>总结<ul><li>对于内置的数据类型的表达式的的运算符是不可能改变的</li><li>不要滥用运算符重载</li></ul></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> m_A&#123;&#125;;</span><br><span class="line">    <span class="keyword">int</span> m_B&#123;&#125;;</span><br><span class="line"></span><br><span class="line">    Person() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">    Person(<span class="keyword">int</span> a, <span class="keyword">int</span> b) &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;m_A = a;</span><br><span class="line">        <span class="keyword">this</span>-&gt;m_B = b;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过成员函数实现 + 号运算符重载</span></span><br><span class="line">    Person <span class="keyword">operator</span>+(<span class="keyword">const</span> Person &amp;p) <span class="keyword">const</span> &#123;</span><br><span class="line">        Person temp;</span><br><span class="line">        temp.m_A = <span class="keyword">this</span>-&gt;m_A + p.m_A;</span><br><span class="line">        temp.m_B = <span class="keyword">this</span>-&gt;m_B + p.m_B;</span><br><span class="line">        <span class="keyword">return</span> temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过全局函数实现 + 号运算符重载</span></span><br><span class="line"><span class="comment">// 但是等价的运算符重载只能实现一次</span></span><br><span class="line"><span class="comment">//Person operator+(const Person&amp; p1, const Person&amp; p2) &#123;</span></span><br><span class="line"><span class="comment">//Person temp(0, 0);</span></span><br><span class="line"><span class="comment">//temp.m_A = p1.m_A + p2.m_A;</span></span><br><span class="line"><span class="comment">//temp.m_B = p1.m_B + p2.m_B;</span></span><br><span class="line"><span class="comment">//return temp;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//运算符重载 可以发生函数重载</span></span><br><span class="line">Person <span class="keyword">operator</span>+(<span class="keyword">const</span> Person &amp;p2, <span class="keyword">int</span> val) &#123;</span><br><span class="line">    Person temp;</span><br><span class="line">    temp.m_A = p2.m_A + val;</span><br><span class="line">    temp.m_B = p2.m_B + val;</span><br><span class="line">    <span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">Person <span class="title">p1</span><span class="params">(<span class="number">10</span>, <span class="number">10</span>)</span></span>;</span><br><span class="line">    <span class="function">Person <span class="title">p2</span><span class="params">(<span class="number">20</span>, <span class="number">20</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    Person p3 = p2 + p1;  <span class="comment">//相当于 p2.operaor+(p1)</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;mA:&quot;</span> &lt;&lt; p3.m_A &lt;&lt; <span class="string">&quot; mB:&quot;</span> &lt;&lt; p3.m_B &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    Person p4 = p3 + <span class="number">10</span>; <span class="comment">//相当于 operator+(p3,10)</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;mA:&quot;</span> &lt;&lt; p4.m_A &lt;&lt; <span class="string">&quot; mB:&quot;</span> &lt;&lt; p4.m_B &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    test();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="左移运算符重载"><a href="#左移运算符重载" class="headerlink" title="左移运算符重载"></a>左移运算符重载</h4><ul><li><p>作用：可以输出自定义数据类型</p></li><li><p>总结：</p><ul><li><strong>一般不会利用成员函数重载左移运算符</strong>，因为无法实现 cout 在左侧</li><li>重载左移运算符<strong>配合友元</strong>可以实现输出自定义数据类型</li></ul></li><li><blockquote><p>注意</p><ol><li>ostream 对象只能有一个，因此要使用引用</li><li>要返回输出流对象，再能链式地追加输出</li></ol></blockquote></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line">    <span class="keyword">friend</span> ostream &amp;<span class="keyword">operator</span>&lt;&lt;(ostream &amp;out, Person &amp;p);</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> m_A;</span><br><span class="line">    <span class="keyword">int</span> m_B;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Person(<span class="keyword">int</span> a, <span class="keyword">int</span> b) &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;m_A = a;</span><br><span class="line">        <span class="keyword">this</span>-&gt;m_B = b;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 成员函数实现的 p &lt;&lt; cout 不是我们想要的效果</span></span><br><span class="line">    <span class="comment">//void operator&lt;&lt;(Person&amp; p)&#123;</span></span><br><span class="line">    <span class="comment">//&#125;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 全局函数实现左移重载</span></span><br><span class="line">ostream &amp;<span class="keyword">operator</span>&lt;&lt;(ostream &amp;out, Person &amp;p) &#123;</span><br><span class="line">    out &lt;&lt; <span class="string">&quot;a:&quot;</span> &lt;&lt; p.m_A &lt;&lt; <span class="string">&quot; b:&quot;</span> &lt;&lt; p.m_B;</span><br><span class="line">    <span class="keyword">return</span> out;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">Person <span class="title">p1</span><span class="params">(<span class="number">10</span>, <span class="number">20</span>)</span></span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; p1 &lt;&lt; <span class="string">&quot;hello world&quot;</span> &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">// 链式编程</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="递增运算符重载"><a href="#递增运算符重载" class="headerlink" title="递增运算符重载"></a>递增运算符重载</h4><ul><li>作用：通过重载递增运算符，实现自己的整型数据</li><li>总结：前置递增返回引用，后置递增返回值</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyInteger</span> &#123;</span></span><br><span class="line">    <span class="keyword">friend</span> ostream &amp;<span class="keyword">operator</span>&lt;&lt;(ostream &amp;out, MyInteger myint);</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> m_Num;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    MyInteger() &#123;</span><br><span class="line">        m_Num = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 前置++</span></span><br><span class="line">    MyInteger &amp;<span class="keyword">operator</span>++() &#123;</span><br><span class="line">        <span class="comment">//先++</span></span><br><span class="line">        m_Num++;</span><br><span class="line">        <span class="comment">//再返回</span></span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 后置++</span></span><br><span class="line">    <span class="comment">// int 占位符可以区分前置后置</span></span><br><span class="line">    MyInteger <span class="keyword">operator</span>++(<span class="keyword">int</span>) &#123;</span><br><span class="line">        MyInteger temp = *<span class="keyword">this</span>;  <span class="comment">// 记录当前本身的值，然后让本身的值加1，但是返回的是以前的值，达到先返回后++；</span></span><br><span class="line">        m_Num++;</span><br><span class="line">        <span class="keyword">return</span> temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ostream &amp;<span class="keyword">operator</span>&lt;&lt;(ostream &amp;out, MyInteger myint) &#123;</span><br><span class="line">    out &lt;&lt; myint.m_Num;</span><br><span class="line">    <span class="keyword">return</span> out;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//前置++: 先++, 再返回</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    MyInteger myInt;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ++myInt &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; myInt &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//后置++: 先返回, 再++</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    MyInteger myInt;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; myInt++ &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; myInt &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    test01();</span><br><span class="line">    test02();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="赋值运算符重载"><a href="#赋值运算符重载" class="headerlink" title="赋值运算符重载"></a>赋值运算符重载</h4><ul><li><p>C++ 编译器至少给一个类添加4个函数</p><ol><li>默认构造函数（无参，函数体为空）</li><li>默认析构函数（无参，函数体为空）</li><li>默认拷贝构造函数，对属性进行值拷贝</li><li>赋值运算符 operator=，对属性进行值拷贝</li></ol></li><li><p>针对问题：如果类中有属性指向堆区，则编译器提供的赋值操作会出现深浅拷贝问题</p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 年龄的指针</span></span><br><span class="line">    <span class="keyword">int</span> *m_Age;</span><br><span class="line">    </span><br><span class="line">    Person(<span class="keyword">int</span> age) &#123;</span><br><span class="line">        <span class="comment">// 将年龄数据开辟到堆区</span></span><br><span class="line">        m_Age = <span class="keyword">new</span> <span class="keyword">int</span>(age);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重载赋值运算符 </span></span><br><span class="line">    Person &amp;<span class="keyword">operator</span>=(Person &amp;p) &#123;</span><br><span class="line">        <span class="keyword">if</span> (m_Age != <span class="literal">nullptr</span>) &#123;  <span class="comment">// 删除之前的数据，防止内存泄漏</span></span><br><span class="line">            <span class="keyword">delete</span> m_Age;</span><br><span class="line">            m_Age = <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 编译器提供的代码是浅拷贝</span></span><br><span class="line">        <span class="comment">//m_Age = p.m_Age;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 提供深拷贝 解决浅拷贝的问题</span></span><br><span class="line">        m_Age = <span class="keyword">new</span> <span class="keyword">int</span>(*p.m_Age);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 返回自身</span></span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ~Person() &#123;</span><br><span class="line">        <span class="keyword">if</span> (m_Age != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">delete</span> m_Age;</span><br><span class="line">            m_Age = <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">Person <span class="title">p1</span><span class="params">(<span class="number">18</span>)</span></span>;</span><br><span class="line">    <span class="function">Person <span class="title">p2</span><span class="params">(<span class="number">20</span>)</span></span>;</span><br><span class="line">    <span class="function">Person <span class="title">p3</span><span class="params">(<span class="number">30</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    p3 = p2 = p1;  <span class="comment">// 赋值操作</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;p1的年龄为：&quot;</span> &lt;&lt; *p1.m_Age &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;p2的年龄为：&quot;</span> &lt;&lt; *p2.m_Age &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;p3的年龄为：&quot;</span> &lt;&lt; *p3.m_Age &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    test01();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">int</span> b = <span class="number">20</span>;</span><br><span class="line">    <span class="keyword">int</span> c = <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line">    c = b = a;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;b = &quot;</span> &lt;&lt; b &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;c = &quot;</span> &lt;&lt; c &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="关系运算符重载"><a href="#关系运算符重载" class="headerlink" title="关系运算符重载"></a>关系运算符重载</h4><ul><li>作用：重载关系运算符，可以让两个自定义类型对象进行对比操作</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">string</span> m_Name;</span><br><span class="line">    <span class="keyword">int</span> m_Age;</span><br><span class="line">    </span><br><span class="line">    Person(<span class="built_in">string</span> name, <span class="keyword">int</span> age) &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;m_Name = name;</span><br><span class="line">        <span class="keyword">this</span>-&gt;m_Age = age;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>==(Person &amp;p) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>-&gt;m_Name == p.m_Name &amp;&amp; <span class="keyword">this</span>-&gt;m_Age == p.m_Age) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>!=(Person &amp;p) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>-&gt;m_Name == p.m_Name &amp;&amp; <span class="keyword">this</span>-&gt;m_Age == p.m_Age) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">Person <span class="title">a</span><span class="params">(<span class="string">&quot;孙悟空&quot;</span>, <span class="number">18</span>)</span></span>;</span><br><span class="line">    <span class="function">Person <span class="title">b</span><span class="params">(<span class="string">&quot;孙悟空&quot;</span>, <span class="number">18</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (a == b) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;a和b相等&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;a和b不相等&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (a != b) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;a和b不相等&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;a和b相等&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    test01();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="函数调用运算符重载"><a href="#函数调用运算符重载" class="headerlink" title="函数调用运算符重载"></a>函数调用运算符重载</h4><ul><li>函数调用运算符 ()  也可以重载</li><li>由于重载后使用的方式非常像函数的调用，因此称为仿函数</li><li>仿函数没有固定写法，非常灵活</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyPrint</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="built_in">string</span> text)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; text &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 重载的()操作符 也称为仿函数</span></span><br><span class="line">    MyPrint myFunc;</span><br><span class="line">    myFunc(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyAdd</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> v1, <span class="keyword">int</span> v2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> v1 + v2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    MyAdd add;</span><br><span class="line">    <span class="keyword">int</span> ret = add(<span class="number">10</span>, <span class="number">10</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;ret = &quot;</span> &lt;&lt; ret &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">//匿名对象调用</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;MyAdd()(100,100) = &quot;</span> &lt;&lt; MyAdd()(<span class="number">100</span>, <span class="number">100</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    test01();</span><br><span class="line">    test02();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><blockquote><p>子类是对父类的扩展。</p></blockquote><h4 id="继承的基本语法"><a href="#继承的基本语法" class="headerlink" title="继承的基本语法"></a>继承的基本语法</h4><ul><li>继承的好处：可以减少重复的代码</li><li><code>class A : public B;</code> <ul><li>A 类称为子类、派生类</li><li>B 类称为父类、基类</li></ul></li><li>派生类中的成员，包含两大部分：<ul><li>一部分是从基类继承过来的，一部分是自己增加的成员。</li><li>从基类继承过来的成员表现其共性，而新增的成员体现了其个性。</li></ul></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//公共页面</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BasePage</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">header</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;首页、公开课、登录、注册...（公共头部）&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">footer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;帮助中心、交流合作、站内地图...(公共底部)&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">left</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Java,Python,C++...(公共分类列表)&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Java页面</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Java</span> :</span> <span class="keyword">public</span> BasePage &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">content</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;JAVA学科视频&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Python页面</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Python</span> :</span> <span class="keyword">public</span> BasePage &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">content</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Python学科视频&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//C++页面</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CPP</span> :</span> <span class="keyword">public</span> BasePage &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">content</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;C++学科视频&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//Java页面</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Java下载视频页面如下： &quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    Java::header();</span><br><span class="line">    Java::footer();</span><br><span class="line">    Java::left();</span><br><span class="line">    Java::content();</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;--------------------&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Python页面</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Python下载视频页面如下： &quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    Python::header();</span><br><span class="line">    Python::footer();</span><br><span class="line">    Python::left();</span><br><span class="line">    Python::content();</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;--------------------&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//C++页面</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;C++下载视频页面如下： &quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    CPP::header();</span><br><span class="line">    CPP::footer();</span><br><span class="line">    CPP::left();</span><br><span class="line">    CPP::content();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="继承方式"><a href="#继承方式" class="headerlink" title="继承方式"></a>继承方式</h4><ul><li>继承的语法：<code>class 子类 : 继承方式  父类</code></li><li>继承方式一共有三种：<ul><li>公共继承</li><li>保护继承</li><li>私有继承</li></ul></li></ul><table><thead><tr><th></th><th>公共继承</th><th>保护继承</th><th>私有继承</th></tr></thead><tbody><tr><td>公共成员</td><td>公共成员</td><td>保护成员</td><td>私有成员</td></tr><tr><td>保护成员</td><td>保护成员</td><td>保护成员</td><td>私有成员</td></tr><tr><td>私有成员</td><td>不可访问</td><td>不可访问</td><td>不可访问</td></tr></tbody></table><h4 id="继承中的对象模型"><a href="#继承中的对象模型" class="headerlink" title="继承中的对象模型"></a>继承中的对象模型</h4><ul><li>总结：父类中私有成员也是被子类继承下去了，只是由编译器给隐藏后访问不到</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> m_A;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="keyword">int</span> m_B;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> m_C; <span class="comment">//私有成员只是被隐藏了，但是还是会继承下去</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//公共继承</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son</span> :</span> <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> m_D;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;sizeof Son = &quot;</span> &lt;&lt; <span class="keyword">sizeof</span>(Son) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">// sizeof Son = 16</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="继承中构造和析构顺序"><a href="#继承中构造和析构顺序" class="headerlink" title="继承中构造和析构顺序"></a>继承中构造和析构顺序</h4><ul><li>总结：<ul><li>子类继承父类后，当创建子类对象，也会调用父类的构造函数</li><li>继承中，先调用父类构造函数，再调用子类构造函数，析构顺序与构造相反</li></ul></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Base() &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Base构造函数!&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~Base() &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Base析构函数!&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son</span> :</span> <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Son() &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Son构造函数!&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~Son() &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Son析构函数!&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//继承中 先调用父类构造函数，再调用子类构造函数，析构顺序与构造相反</span></span><br><span class="line">    Son s;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="继承同名（非）静态成员处理方式"><a href="#继承同名（非）静态成员处理方式" class="headerlink" title="继承同名（非）静态成员处理方式"></a>继承同名（非）静态成员处理方式</h4><ul><li><p>针对问题：当子类与父类出现同名的成员，通过子类对象，访问到子类或父类中同名的成员变量。</p></li><li><p>方法：</p><ul><li>访问子类同名成员   直接访问即可</li><li>访问父类同名成员   需要加作用域</li></ul></li><li><p>总结：</p><ol><li>子类对象可以直接访问到子类中同名成员</li><li>子类对象加作用域可以访问到父类同名成员</li><li><strong>子类的成员函数会隐藏父类中所有版本的同名成员函数（包括重载函数）</strong>，只有加作用域才可以访问到父类中同名函数</li></ol></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> m_A;</span><br><span class="line"></span><br><span class="line">    Base() &#123;</span><br><span class="line">        m_A = <span class="number">100</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Base - func()调用&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> a)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Base - func(int a)调用&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son</span> :</span> <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> m_A;</span><br><span class="line"></span><br><span class="line">    Son() : m_A(<span class="number">200</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 子类会隐藏父类中所有版本的同名成员函数</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Son - func()调用&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Son s;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Son下的m_A = &quot;</span> &lt;&lt; s.m_A &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Base下的m_A = &quot;</span> &lt;&lt; s.Base::m_A &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    s.func();</span><br><span class="line">    s.Base::func();</span><br><span class="line">    s.Base::func(<span class="number">10</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> EXIT_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="多继承语法"><a href="#多继承语法" class="headerlink" title="多继承语法"></a>多继承语法</h4><ul><li><p>C++ 允许一个类继承多个类</p></li><li><p>语法：<code>class 子类: 继承方式 父类1, 继承方式 父类2...</code></p></li><li><p>总结： 多继承中如果引发父类中有同名成员出现，子类使用时候要加作用域</p><ul><li>C++ 实际开发中不建议用多继承</li></ul></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base1</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> m_A;</span><br><span class="line"></span><br><span class="line">    Base1() : m_A(<span class="number">100</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base2</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> m_A;</span><br><span class="line"></span><br><span class="line">    Base2() : m_A(<span class="number">200</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son</span> :</span> <span class="keyword">public</span> Base2, <span class="keyword">public</span> Base1 &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> m_C;</span><br><span class="line">    <span class="keyword">int</span> m_D;</span><br><span class="line"></span><br><span class="line">    Son() : m_C(<span class="number">300</span>), m_D(<span class="number">400</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//多继承容易产生成员同名的情况</span></span><br><span class="line">    <span class="comment">//通过使用类名作用域可以区分调用哪一个基类的成员</span></span><br><span class="line">    Son s;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;sizeof Son = &quot;</span> &lt;&lt; <span class="keyword">sizeof</span>(s) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;s.Base1::m_A = &quot;</span> &lt;&lt; s.Base1::m_A &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;s.Base2::m_A = &quot;</span> &lt;&lt; s.Base2::m_A &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="菱形继承"><a href="#菱形继承" class="headerlink" title="菱形继承"></a>菱形继承</h4><ul><li><p>菱形（钻石）继承概念：</p><ul><li>两个派生类继承同一个基类</li><li>又有某个类同时继承者两个派生类</li></ul></li><li><p>典型的菱形继承案例：</p></li><li><p><img src="/2022/1/C++-Part2/clip_image002.jpg" alt="IMG_256"></p></li><li><p>菱形继承问题：</p><ol><li><pre><code>羊继承了动物的数据，驼同样继承了动物的数据，当草泥马使用数据时，就会产生二义性。</code></pre></li><li><pre><code>草泥马继承自动物的数据继承了两份，其实这份数据我们只需要一份就可以，此为资源浪费。</code></pre></li></ol></li><li><p>总结：</p><ul><li>菱形继承带来的主要问题是子类继承两份相同的数据，导致资源浪费以及毫无意义</li><li>利用虚继承可以解决菱形继承问题，从虚基类继承的成员变量只会有一份内存空间。</li></ul></li><li><blockquote><ul><li>虚基类是子类以虚继承方式继承的父类的别称，并不是抽象类，其依然能够创建实例对象</li><li>虚继承的本质是将自己继承过来的成员作为一个指针（virtual base pointer，vbptr）指向父类的空间（vbtable）<ul><li>因此修改任何一个父类或者子类，实际上都是在修改同一份数据</li><li>类似于 Java 的重写</li></ul></li></ul></blockquote></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> m_Age&#123;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 继承前加virtual关键字后，变为虚继承</span></span><br><span class="line"><span class="comment">// 此时公共的父类Animal称为虚基类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sheep</span> :</span> <span class="keyword">virtual</span> <span class="keyword">public</span> Animal &#123;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tuo</span> :</span> <span class="keyword">virtual</span> <span class="keyword">public</span> Animal &#123;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SheepTuo</span> :</span> <span class="keyword">public</span> Sheep, <span class="keyword">public</span> Tuo &#123;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Animal a;</span><br><span class="line">    a.m_Age = <span class="number">15</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;s.m_Age = &quot;</span> &lt;&lt; a.m_Age &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    Sheep s;</span><br><span class="line">    s.m_Age = <span class="number">10</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;s.m_Age = &quot;</span> &lt;&lt; s.m_Age &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    Tuo t;</span><br><span class="line">    t.m_Age = <span class="number">20</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;t.m_Age = &quot;</span> &lt;&lt; t.m_Age &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    SheepTuo st;</span><br><span class="line">    st.Sheep::m_Age = <span class="number">100</span>;</span><br><span class="line">    st.Tuo::m_Age = <span class="number">200</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;st.Sheep::m_Age = &quot;</span> &lt;&lt; st.Sheep::m_Age &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;st.Tuo::m_Age = &quot;</span> &lt;&lt; st.Tuo::m_Age &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;st.m_Age = &quot;</span> &lt;&lt; st.m_Age &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><h4 id="多态的基本概念"><a href="#多态的基本概念" class="headerlink" title="多态的基本概念"></a>多态的基本概念</h4><ul><li><p>多态分为两类</p><ul><li>静态多态：<strong>函数重载</strong>和<strong>运算符重载</strong>属于静态多态（复用函数名）</li><li>动态多态：派生类和虚函数实现运行时多态</li></ul></li><li><p>静态多态和动态多态区别：</p><ul><li>静态多态的函数地址早绑定：编译阶段确定函数地址</li><li>动态多态的函数地址晚绑定：运行阶段确定函数地址</li></ul></li><li><p>总结：</p><ul><li>多态满足条件<ul><li>有继承关系</li><li>子类重写父类中的虚函数</li></ul></li><li>多态使用条件<ul><li>父类指针或引用指向子类对象</li></ul></li><li>我们希望传入什么对象，那么就调用什么对象的函数<ul><li>如果函数地址在编译阶段就能确定，那么静态联编</li><li>如果函数地址在运行阶段才能确定，就是动态联编</li></ul></li><li>重写：<code>函数返回值类型  函数名 参数列表</code> 需要完全一致才称为重写</li></ul></li><li><p>多态的优点：</p><ul><li>代码组织结构清晰</li><li>可读性强</li><li>利于前期和后期的扩展以及维护</li></ul></li><li><blockquote><p>多态的原理</p><ul><li>加上 virtual 关键字之前，Animal 类的成员函数不存储在类对象中，<strong>因此一个 Animal 实例的大小为 1 字节</strong></li><li>加上 virtual 关键字之后，Animal 类将保存一个虚函数指针（virtual function pointer，vfptr）指向自己的虚函数表（virtual function table，vftable），并存储在该类对象中，<strong>因此一个 Animal 实例（无论有多少个虚函数）的大小为 4 字节</strong><ul><li>一个类只有一个虚函数指针，虚函数表内部记录各个虚函数的地址</li><li>继承时复制一份虚函数指针和虚函数表，虚函数表不占实例空间</li></ul></li><li>当子类重写父类虚函数时，即重写/替换父类内部（继承过来）的虚函数指针指向的虚函数表中的函数，因此使用父类指针指向的子类实例调用父类函数时，实际是调用子类重写的函数内容</li></ul></blockquote></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 函数前面加上 virtual 关键字就是虚函数，编译器在编译的时候不能确定函数调用。</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">speak</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;动物在说话&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">speak2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;动物在说话&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span> :</span> <span class="keyword">public</span> Animal &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">speak</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;小猫在说话&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span> :</span> <span class="keyword">public</span> Animal &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">speak</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;小狗在说话&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DoSpeak</span><span class="params">(Animal &amp;animal)</span> </span>&#123;</span><br><span class="line">    animal.speak();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Cat cat;</span><br><span class="line">    DoSpeak(cat);</span><br><span class="line">    Dog dog;</span><br><span class="line">    DoSpeak(dog);</span><br><span class="line">    Animal animal;</span><br><span class="line">    DoSpeak(animal);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;sizeof animal = &quot;</span> &lt;&lt; <span class="keyword">sizeof</span> animal &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="纯虚函数和抽象类"><a href="#纯虚函数和抽象类" class="headerlink" title="纯虚函数和抽象类"></a>纯虚函数和抽象类</h4><ul><li><p>针对问题：在多态中，通常父类中虚函数的实现是无意义的，主要都是调用子类重写的内容</p></li><li><p>解决：因此可以将虚函数改为<strong>纯虚函数</strong>，要求子类必须重写纯虚函数</p></li><li><p>语法：<code>virtual 返回值类型 函数名 （参数列表）= 0 ;</code></p></li><li><p>只要类中有一个纯虚函数，这个类就称为抽象类</p></li><li><p>抽象类特点：</p><ul><li>无法实例化对象</li><li>子类必须重写抽象类中的纯虚函数，否则也属于抽象类</li></ul></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son</span> :</span> <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;func调用&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//Base * = new Base; // 错误，抽象类无法实例化对象</span></span><br><span class="line">    Base *base = <span class="keyword">new</span> Son;</span><br><span class="line">    base-&gt;func();</span><br><span class="line">    <span class="keyword">delete</span> base;<span class="comment">//记得销毁</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="虚析构和纯虚析构"><a href="#虚析构和纯虚析构" class="headerlink" title="虚析构和纯虚析构"></a>虚析构和纯虚析构</h4><ul><li><p>父类指针在释放时无法调用到子类的析构代码，因此如果子类中有属性开辟到堆区，那么会有内存泄漏的隐患</p></li><li><p>解决方式：将父类中的析构函数改为<strong>虚析构</strong>或者<strong>纯虚析构</strong></p></li><li><p>虚析构和纯虚析构共性：</p><ul><li>都可以解决父类指针释放子类对象</li><li><strong>虚析构和纯虚析构都需要有具体的函数实现</strong>，父类成员变量在父类的析构函数中释放</li></ul></li><li><p>虚析构和纯虚析构区别：</p><ul><li>如果是纯虚析构，该类属于抽象类，无法实例化对象</li></ul></li><li><p>虚析构语法：<code>virtual ~类名() &#123;&#125;</code></p></li></ul><ul><li><p>纯虚析构语法：</p><ul><li><pre><code class="c++">virtual ~类名() = 0;类名::~类名() &#123;&#125;<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 总结：</span><br><span class="line"></span><br><span class="line">  1. 虚析构或纯虚析构就是用来解决通过父类指针释放子类对象</span><br><span class="line"></span><br><span class="line">  2. 如果子类中没有堆区数据，可以不写为虚析构或纯虚析构</span><br><span class="line"></span><br><span class="line">  3. 拥有纯虚析构函数的类也属于抽象类</span><br><span class="line"></span><br><span class="line">&#96;&#96;&#96;C++</span><br><span class="line">class Animal &#123;</span><br><span class="line">public:</span><br><span class="line">    Animal() &#123;</span><br><span class="line">        cout &lt;&lt; &quot;Animal 构造函数调用！&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 析构函数加上virtual关键字，变成虚析构函数</span><br><span class="line">    &#x2F;&#x2F;virtual ~Animal()</span><br><span class="line">    &#x2F;&#x2F;&#123;</span><br><span class="line">    &#x2F;&#x2F;cout &lt;&lt; &quot;Animal虚析构函数调用！&quot; &lt;&lt; endl;</span><br><span class="line">    &#x2F;&#x2F;&#125;</span><br><span class="line">    virtual ~Animal() &#x3D; 0;</span><br><span class="line"></span><br><span class="line">    virtual void Speak() &#x3D; 0;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Animal::~Animal() &#123;</span><br><span class="line">    cout &lt;&lt; &quot;Animal 纯虚析构函数调用！&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Cat : public Animal &#123;</span><br><span class="line">public:</span><br><span class="line">    string *m_Name;</span><br><span class="line"></span><br><span class="line">    explicit Cat(string name) &#123;</span><br><span class="line">        cout &lt;&lt; &quot;Cat 构造函数调用！&quot; &lt;&lt; endl;</span><br><span class="line">        m_Name &#x3D; new string(std::move(name));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~Cat() override &#123;</span><br><span class="line">        cout &lt;&lt; &quot;Cat 析构函数调用!&quot; &lt;&lt; endl;</span><br><span class="line">        if (this-&gt;m_Name !&#x3D; nullptr) &#123;</span><br><span class="line">            delete m_Name;</span><br><span class="line">            m_Name &#x3D; nullptr;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void Speak() override &#123;</span><br><span class="line">        cout &lt;&lt; *m_Name &lt;&lt; &quot; 小猫在说话!&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    Animal *animal &#x3D; new Cat(&quot;Tom&quot;);</span><br><span class="line">    animal-&gt;Speak();</span><br><span class="line">    delete animal;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>## 文件操作</code></pre></li></ul></li></ul><h3 id="文件操作概述"><a href="#文件操作概述" class="headerlink" title="文件操作概述"></a>文件操作概述</h3><ul><li><p>C++ 中对文件操作需要包含头文件 <code>#include &lt;fstream&gt;</code></p></li><li><p>文件类型分为两种：</p><ol><li>文本文件：文件以文本的 ASCII 码形式存储在计算机中</li><li>二进制文件：文件以文本的二进制形式存储在计算机中，用户一般不能直接读懂它们</li></ol></li><li><p>操作文件的三大类：</p><ol><li>ofstream：写操作</li><li>ifstream：读操作</li><li>fstream：读写操作</li></ol></li><li><p>文件打开方式：</p></li></ul><table><thead><tr><th>打开方式</th><th>解释</th></tr></thead><tbody><tr><td>ios::in</td><td>为读文件而打开文件</td></tr><tr><td>ios::out</td><td>为写文件而打开文件</td></tr><tr><td>ios::ate</td><td>初始位置：文件尾</td></tr><tr><td>ios::app</td><td>追加方式写文件</td></tr><tr><td>ios::trunc</td><td>如果文件存在先删除，再创建</td></tr><tr><td>ios::binary</td><td>二进制方式</td></tr></tbody></table><ul><li>注意：文件打开方式可以配合使用，利用 <code>|</code> 操作符<ul><li>例如：用二进制方式写文件 <code>ios::binary |  ios:: out</code></li></ul></li></ul><h3 id="文本文件"><a href="#文本文件" class="headerlink" title="文本文件"></a>文本文件</h3><h4 id="写文件"><a href="#写文件" class="headerlink" title="写文件"></a>写文件</h4><ul><li><p>写文件步骤如下：</p><ol><li><p>包含头文件：<code>#include &lt;fstream&gt;</code></p></li><li><p>创建流对象：<code>ofstream ofs;</code></p></li><li><p>打开文件：<code>ofs.open(&quot;文件路径&quot;, 打开方式);</code></p></li><li><p>写数据：<code>ofs &lt;&lt; &quot;写入的数据&quot;;</code></p></li><li><p>关闭文件：<code>ofs.close();</code></p></li></ol></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fstream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ofstream ofs;</span><br><span class="line">    ofs.open(<span class="string">&quot;test.txt&quot;</span>, ios::out);</span><br><span class="line"></span><br><span class="line">    ofs &lt;&lt; <span class="string">&quot;姓名：张三&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    ofs &lt;&lt; <span class="string">&quot;性别：男&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    ofs &lt;&lt; <span class="string">&quot;年龄：18&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    ofs.close();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    test01();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="读文件"><a href="#读文件" class="headerlink" title="读文件"></a>读文件</h4><ul><li>读文件步骤如下：<ol><li>包含头文件：<code>#include &lt;fstream&gt;</code></li><li>创建流对象：<code>ifstream ofs;</code></li><li>打开文件：<code>ifs.open(&quot;文件路径&quot;,打开方式);</code></li><li>检查是否打开成功：<code>!ifs.is_open()</code></li><li>读数据，四种方式读取</li><li>关闭文件：<code>ifs.close();</code></li></ol></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ifstream ifs;</span><br><span class="line">    ifs.open(<span class="string">&quot;test.txt&quot;</span>, ios::in);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!ifs.is_open()) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;文件打开失败&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. 第一种方式</span></span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">1024</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    <span class="keyword">while</span> (ifs &gt;&gt; buf) &#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; buf &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 第二种方式</span></span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">1024</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    <span class="keyword">while</span> (ifs.getline(buf, <span class="keyword">sizeof</span>(buf))) &#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; buf &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 第三种方式</span></span><br><span class="line">    <span class="built_in">string</span> buf;</span><br><span class="line">    <span class="keyword">while</span> (getline(ifs, buf)) &#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; buf &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4. 第四种方式（不推荐）</span></span><br><span class="line">    <span class="keyword">char</span> c;</span><br><span class="line">    <span class="keyword">while</span> ((c = ifs.get()) != EOF) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; c;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ifs.close();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    test01();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="二进制文件"><a href="#二进制文件" class="headerlink" title="二进制文件"></a>二进制文件</h3><h4 id="写文件-1"><a href="#写文件-1" class="headerlink" title="写文件"></a>写文件</h4><ul><li><p>写二进制文件主要利用流对象的成员函数 <code>write()</code></p><ul><li>函数原型 ：<code>ostream&amp; write(const char * buffer, int len);</code></li><li>参数解释：<ul><li>字符指针 buffer 指向内存中一段存储空间</li><li>len 是读写的字节数</li></ul></li></ul></li><li><p>建议使用 char[] 进行二进制的写入</p></li><li><p>对象指针要强转为 <code>char *</code>，同时计算读写的大小空间。</p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">char</span> m_Name[<span class="number">64</span>];</span><br><span class="line">    <span class="keyword">int</span> m_Age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写二进制文件</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">ofstream <span class="title">ofs</span><span class="params">(<span class="string">&quot;person.txt&quot;</span>, ios::out | ios::binary)</span></span>;</span><br><span class="line"></span><br><span class="line">    Person p = &#123;<span class="string">&quot;张三&quot;</span>, <span class="number">18</span>&#125;;</span><br><span class="line">    ofs.write((<span class="keyword">const</span> <span class="keyword">char</span> *) &amp;p, <span class="keyword">sizeof</span>(p));</span><br><span class="line"></span><br><span class="line">    ofs.close();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    test01();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="读文件-1"><a href="#读文件-1" class="headerlink" title="读文件"></a>读文件</h4><ul><li>读二进制文件主要利用流对象的成员函数 <code>read()</code><ul><li>函数原型：<code>istream&amp; read(char *buffer, int len);</code></li><li>参数解释：<ul><li>字符指针 buffer 指向内存中一段存储空间</li><li>len 是读写的字节数</li></ul></li></ul></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">char</span> m_Name[<span class="number">64</span>];</span><br><span class="line">    <span class="keyword">int</span> m_Age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">ifstream <span class="title">ifs</span><span class="params">(<span class="string">&quot;person.txt&quot;</span>, ios::in | ios::binary)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (!ifs.is_open()) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;文件打开失败&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Person p;</span><br><span class="line">    ifs.read((<span class="keyword">char</span> *) &amp;p, <span class="keyword">sizeof</span>(p));</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;姓名： &quot;</span> &lt;&lt; p.m_Name &lt;&lt; <span class="string">&quot; 年龄： &quot;</span> &lt;&lt; p.m_Age &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    </span><br><span class="line">    ifs.close();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    test01();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h2><h3 id="模板的概念"><a href="#模板的概念" class="headerlink" title="模板的概念"></a>模板的概念</h3><ul><li>模板的特点：<ul><li>模板不可以直接使用，只是一个框架</li><li>模板的通用并不是万能的</li></ul></li><li>C++ 另一种编程思想称为<strong>泛型编程</strong>，主要利用的技术就是模板</li></ul><ul><li>C++ 提供两种模板机制:<strong>函数模板</strong>和<strong>类模板</strong> </li></ul><h3 id="函数模板"><a href="#函数模板" class="headerlink" title="函数模板"></a>函数模板</h3><h4 id="函数模板语法"><a href="#函数模板语法" class="headerlink" title="函数模板语法"></a>函数模板语法</h4><ul><li><p>函数模板作用：</p><ul><li>建立一个通用函数，其函数返回值类型和形参类型可以不具体制定，用一个<strong>虚拟的类型</strong>来代表。</li></ul></li><li><p>语法： </p><ul><li><pre><code class="c++">template&lt;typename/class T&gt;函数声明或定义<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 解释：</span><br><span class="line"></span><br><span class="line">  - &#96;template&#96;：声明创建模板</span><br><span class="line">  - &#96;typename&#x2F;class&#96;：表面其后面的符号是一种数据类型，可以用 class 代替</span><br><span class="line">  - &#96;T&#96;：通用的数据类型，名称可以替换，通常为大写字母</span><br><span class="line"></span><br><span class="line">- 总结：</span><br><span class="line"></span><br><span class="line">  - 使用函数模板有两种方式：自动类型推导、显式指定类型</span><br><span class="line">  - 模板的目的是将类型参数化、为了提高复用性，需要熟练掌握</span><br><span class="line"></span><br><span class="line">- 注意：</span><br><span class="line"></span><br><span class="line">  - 必须**确定出数据类型 T** 并且**同一个 T 推导结果一致**，才可以使用。</span><br><span class="line"></span><br><span class="line">&#96;&#96;&#96;C++</span><br><span class="line">&#x2F;&#x2F; 利用模板提供通用的交换函数</span><br><span class="line">template&lt;typename T&gt;  &#x2F;&#x2F; typename 可以换成 class</span><br><span class="line">void mySwap(T &amp;a, T &amp;b) &#123;</span><br><span class="line">    T temp &#x3D; a;</span><br><span class="line">    a &#x3D; b;</span><br><span class="line">    b &#x3D; temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void test01() &#123;</span><br><span class="line">    int a &#x3D; 10;</span><br><span class="line">    int b &#x3D; 20;</span><br><span class="line">    char c &#x3D; &#39;c&#39;;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 利用模板实现交换</span><br><span class="line">    &#x2F;&#x2F; 1、自动类型推导</span><br><span class="line">    mySwap(a, b);</span><br><span class="line">    &#x2F;&#x2F;mySwap(a, c);  &#x2F;&#x2F; 错误，推导不出一致的 T 类型</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 2、显式指定类型</span><br><span class="line">    mySwap&lt;int&gt;(a, b);</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; &quot;a &#x3D; &quot; &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; &quot;b &#x3D; &quot; &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template&lt;class T&gt;</span><br><span class="line">void func() &#123;</span><br><span class="line">    cout &lt;&lt; &quot;func 调用&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void test02() &#123;</span><br><span class="line">    &#x2F;&#x2F;func();  &#x2F;&#x2F; 错误，模板不能独立使用，必须确定出 T 的类型</span><br><span class="line">    func&lt;int&gt;();  &#x2F;&#x2F; 利用显示指定类型的方式，给 T 一个类型，才可以使用该模板</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    test01();</span><br><span class="line">    test02();</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>#### 普通函数与函数模板的区别</code></pre></li></ul></li><li><p>普通函数与函数模板区别：</p><ul><li>普通函数调用时可以发生自动类型转换（隐式类型转换）</li><li>函数模板调用时，如果利用自动类型推导，不会发生隐式类型转换（因为需要确保推导的 T 结果一致）</li><li>如果利用显示指定类型的方式，则可以发生隐式类型转换</li></ul></li><li><p>总结：建议使用显示指定类型的方式，调用函数模板，因为可以自己确定通用类型 T</p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 普通函数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">myAdd01</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数模板</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="function">T <span class="title">myAdd02</span><span class="params">(T a, T b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用函数模板时，如果用自动类型推导，不会发生自动类型转换,即隐式类型转换</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">int</span> b = <span class="number">20</span>;</span><br><span class="line">    <span class="keyword">char</span> c = <span class="string">&#x27;c&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; myAdd01(a, c) &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">// 正确，将char类型的&#x27;c&#x27;隐式转换为int类型  &#x27;c&#x27; 对应 ASCII码 99</span></span><br><span class="line">    <span class="comment">//myAdd02(a, c);  // 报错，使用自动类型推导时，不会发生隐式类型转换</span></span><br><span class="line">    myAdd02&lt;<span class="keyword">int</span>&gt;(a, c);  <span class="comment">// 正确，如果用显示指定类型，可以发生隐式类型转换</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    test01();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="普通函数与函数模板的调用规则"><a href="#普通函数与函数模板的调用规则" class="headerlink" title="普通函数与函数模板的调用规则"></a>普通函数与函数模板的调用规则</h4><ul><li>调用规则如下：<ol><li>如果函数模板和普通函数都可以实现，优先调用普通函数</li><li>可以通过空模板参数列表来强制调用函数模板</li><li>函数模板也可以发生重载</li><li>如果函数模板可以产生更好的匹配，优先调用函数模板</li></ol></li><li>总结：既然提供了函数模板，最好就不要提供普通函数，否则容易出现二义性</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myPrint</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;调用的普通函数&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myPrint</span><span class="params">(T a, T b)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;调用的模板&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myPrint</span><span class="params">(T a, T b, T c)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;调用重载的模板&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 1. 如果函数模板和普通函数都可以实现，优先调用普通函数</span></span><br><span class="line">    <span class="comment">// 注意 如果告诉编译器  普通函数是有的，但只是声明没有实现，或者不在当前文件内实现，就会报错找不到</span></span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">int</span> b = <span class="number">20</span>;</span><br><span class="line">    myPrint(a, b);  <span class="comment">// 调用普通函数</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 可以通过空模板参数列表来强制调用函数模板</span></span><br><span class="line">    myPrint&lt;&gt;(a, b);  <span class="comment">// 调用函数模板</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 函数模板也可以发生重载</span></span><br><span class="line">    <span class="keyword">int</span> c = <span class="number">30</span>;</span><br><span class="line">    myPrint(a, b, c);  <span class="comment">// 调用重载的函数模板</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4. 如果函数模板可以产生更好的匹配,优先调用函数模板</span></span><br><span class="line">    <span class="keyword">char</span> c1 = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">    <span class="keyword">char</span> c2 = <span class="string">&#x27;b&#x27;</span>;</span><br><span class="line">    myPrint(c1, c2);  <span class="comment">// 调用函数模板</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    test01();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="模板的局限性"><a href="#模板的局限性" class="headerlink" title="模板的局限性"></a>模板的局限性</h4><ul><li>模板函数的成功运行，要求传入的数据类型能够支持函数内部的代码<ul><li>以下情况不可能直接运行：<ul><li>数组的直接赋值</li><li>自定义数据类型的直接比较</li></ul></li></ul></li><li>解决方向：模板的重载，可以为这些<strong>特定的类型</strong>提供<strong>具体化的模板</strong></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">string</span> m_Name;</span><br><span class="line">    <span class="keyword">int</span> m_Age;</span><br><span class="line"></span><br><span class="line">    Person(<span class="built_in">string</span> name, <span class="keyword">int</span> age) &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;m_Name = name;</span><br><span class="line">        <span class="keyword">this</span>-&gt;m_Age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 普通函数模板</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">myCompare</span><span class="params">(T &amp;a, T &amp;b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (a == b) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以 template&lt;&gt; 开头，具体化特定数据类型的重载模板函数，将优先于常规模板</span></span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">myCompare</span><span class="params">(Person &amp;p1, Person &amp;p2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p1.m_Name == p2.m_Name &amp;&amp; p1.m_Age == p2.m_Age) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">int</span> b = <span class="number">20</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">bool</span> ret = myCompare(a, b);</span><br><span class="line">    <span class="keyword">if</span> (ret) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;a == b &quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;a != b &quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">Person <span class="title">p1</span><span class="params">(<span class="string">&quot;Tom&quot;</span>, <span class="number">10</span>)</span></span>;</span><br><span class="line">    <span class="function">Person <span class="title">p2</span><span class="params">(<span class="string">&quot;Tom&quot;</span>, <span class="number">10</span>)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 可以创建具体化的Person数据类型的模板，用于特殊处理这个类型</span></span><br><span class="line">    <span class="keyword">bool</span> ret = myCompare(p1, p2);</span><br><span class="line">    <span class="keyword">if</span> (ret) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;p1 == p2 &quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;p1 != p2 &quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    test01();</span><br><span class="line">    test02();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="类模板"><a href="#类模板" class="headerlink" title="类模板"></a>类模板</h3><h4 id="类模板语法"><a href="#类模板语法" class="headerlink" title="类模板语法"></a>类模板语法</h4><ul><li><p>类模板作用：</p></li><li><p>建立一个通用类，类中的成员 数据类型可以不具体制定，用一个<strong>虚拟的类型</strong>来代表。</p></li><li><p>语法： </p><ul><li><pre><code class="c++">template&lt;typename T&gt;类<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 解释：</span><br><span class="line"></span><br><span class="line">  - template：声明创建模板</span><br><span class="line">  - typename：表面其后面的符号是一种数据类型，可以用class代替</span><br><span class="line">  - T：通用的数据类型，名称可以替换，通常为大写字母</span><br><span class="line"></span><br><span class="line">&#96;&#96;&#96;C++</span><br><span class="line">&#x2F;&#x2F;类模板</span><br><span class="line">template&lt;class NameType, class AgeType&gt;</span><br><span class="line">class Person &#123;</span><br><span class="line">public:</span><br><span class="line">    NameType mName;</span><br><span class="line">    AgeType mAge;</span><br><span class="line">    </span><br><span class="line">    Person(NameType name, AgeType age) &#123;</span><br><span class="line">        this-&gt;mName &#x3D; name;</span><br><span class="line">        this-&gt;mAge &#x3D; age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void showPerson() &#123;</span><br><span class="line">        cout &lt;&lt; &quot;name: &quot; &lt;&lt; this-&gt;mName &lt;&lt; &quot; age: &quot; &lt;&lt; this-&gt;mAge &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">void test01() &#123;</span><br><span class="line">    &#x2F;&#x2F; 指定 NameType 为 string 类型，AgeType 为 int 类型</span><br><span class="line">    Person&lt;string, int&gt; P1(&quot;孙悟空&quot;, 999);</span><br><span class="line">    P1.showPerson();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    test01();</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>#### 类模板与函数模板区别</code></pre></li></ul></li><li><p>类模板与函数模板区别主要有两点：</p><ol><li>类模板没有自动类型推导的使用方式</li><li>类模板在模板参数列表中可以有默认参数</li></ol></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//类模板</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">NameType</span>, <span class="keyword">class</span> <span class="title">AgeType</span> =</span> <span class="keyword">int</span>&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    NameType mName;</span><br><span class="line">    AgeType mAge;</span><br><span class="line">    </span><br><span class="line">    Person(NameType name, AgeType age) &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;mName = name;</span><br><span class="line">        <span class="keyword">this</span>-&gt;mAge = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">showPerson</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;name: &quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;mName &lt;&lt; <span class="string">&quot; age: &quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;mAge &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. 类模板没有自动类型推导的使用方式</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Person p(&quot;孙悟空&quot;, 1000);  // 错误 类模板使用时候，不可以用自动类型推导</span></span><br><span class="line">    Person&lt;string, int&gt; p(&quot;孙悟空&quot;, 1000);  // 必须使用显示指定类型的方式，使用类模板</span><br><span class="line">    p.showPerson();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 类模板在模板参数列表中可以有默认参数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">Person&lt;<span class="built_in">string</span>&gt; <span class="title">p</span><span class="params">(<span class="string">&quot;猪八戒&quot;</span>, <span class="number">999</span>)</span></span>; <span class="comment">//类模板中的模板参数列表 可以指定默认参数</span></span><br><span class="line">    p.showPerson();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    test01();</span><br><span class="line">    test02();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="类模板中成员函数创建时机"><a href="#类模板中成员函数创建时机" class="headerlink" title="类模板中成员函数创建时机"></a>类模板中成员函数创建时机</h4><ul><li>类模板中成员函数和普通类中成员函数创建时机是有区别的：<ul><li>普通类中的成员函数一开始就可以创建</li><li>类模板中的成员函数在调用时才创建，并检查是否该数据类型能够调用函数</li></ul></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person1</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">showPerson1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Person1 show&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person2</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">showPerson2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Person2 show&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    T obj;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">fun1</span><span class="params">()</span> </span>&#123; obj.showPerson1(); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">fun2</span><span class="params">()</span> </span>&#123; obj.showPerson2(); &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    MyClass&lt;Person1&gt; m&#123;&#125;;</span><br><span class="line">    m.fun1();</span><br><span class="line">    <span class="comment">//m.fun2();  // 编译会出错，说明只有函数被调用才会去创建成员函数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    test01();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="类模板对象做函数参数"><a href="#类模板对象做函数参数" class="headerlink" title="类模板对象做函数参数"></a>类模板对象做函数参数</h4><ul><li><p>学习目标：</p></li><li><p>类模板实例化出的对象，向函数传参的方式</p></li><li><p>一共有三种传入方式：</p><ol><li>指定传入的类型：直接显示对象的数据类型</li><li>参数模板化：将对象中的参数变为模板进行传递</li><li>整个类模板化：将这个对象类型 模板化进行传递</li></ol></li><li><p>总结：</p><ul><li>通过类模板创建的对象，可以有三种方式向函数中进行传参</li><li>使用比较广泛是第一种：指定传入的类型</li></ul></li><li><blockquote><p>在 C++ 中查看一个模板类型 T 或者变量 var 的数据类型：<code>typeid(T/var).name()</code></p></blockquote></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 类模板</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">NameType</span>, <span class="keyword">class</span> <span class="title">AgeType</span> =</span> <span class="keyword">int</span>&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    NameType mName;</span><br><span class="line">    AgeType mAge;</span><br><span class="line"></span><br><span class="line">    Person(NameType name, AgeType age) &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;mName = name;</span><br><span class="line">        <span class="keyword">this</span>-&gt;mAge = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">showPerson</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;name: &quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;mName &lt;&lt; <span class="string">&quot; age: &quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;mAge &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1、指定传入的类型</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printPerson1</span><span class="params">(Person&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt; &amp;p)</span> </span>&#123;</span><br><span class="line">    p.showPerson();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Person&lt;string, int&gt; p(&quot;孙悟空&quot;, 100);</span><br><span class="line">    printPerson1(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2、类模板参数的模板化</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T1</span>, <span class="keyword">class</span> <span class="title">T2</span>&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printPerson2</span><span class="params">(Person&lt;T1, T2&gt; &amp;p)</span> </span>&#123;</span><br><span class="line">    p.showPerson();</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;T1的类型为： &quot;</span> &lt;&lt; <span class="keyword">typeid</span>(T1).name() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;T2的类型为： &quot;</span> &lt;&lt; <span class="keyword">typeid</span>(T2).name() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Person&lt;string, int&gt; p(&quot;猪八戒&quot;, 90);</span><br><span class="line">    printPerson2(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3、整个类的模板化</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printPerson3</span><span class="params">(T &amp;p)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;T的类型为： &quot;</span> &lt;&lt; <span class="keyword">typeid</span>(T).name() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    p.showPerson();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test03</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Person&lt;string, int&gt; p(&quot;唐僧&quot;, 30);</span><br><span class="line">    printPerson3(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    test01();</span><br><span class="line">    test02();</span><br><span class="line">    test03();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="类模板与继承"><a href="#类模板与继承" class="headerlink" title="类模板与继承"></a>类模板与继承</h4><ul><li>当类模板碰到继承时，需要注意一下几点：<ul><li>当子类继承的父类是一个类模板时，子类在声明的时候，要指定出父类中T的类型</li><li>如果不指定，编译器无法给子类分配内存</li><li>如果想灵活指定出父类中T的类型，子类也需变为类模板</li></ul></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> &#123;</span></span><br><span class="line">    T m;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//class Son:public Base  //错误，c++编译需要给子类分配内存，必须知道父类中T的类型才可以向下继承</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. 必须指定父类的模板类型</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son</span> :</span> <span class="keyword">public</span> Base&lt;<span class="keyword">int</span>&gt; &#123;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 用类模板继承类模板，用T2指定父类中的T类型</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T1</span>, <span class="keyword">class</span> <span class="title">T2</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son2</span> :</span> <span class="keyword">public</span> Base&lt;T2&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Son2() &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="keyword">typeid</span>(T1).name() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="keyword">typeid</span>(T2).name() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Son c;</span><br><span class="line">    Son2&lt;<span class="keyword">int</span>, <span class="keyword">char</span>&gt; child1;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="类模板成员函数类外实现"><a href="#类模板成员函数类外实现" class="headerlink" title="类模板成员函数类外实现"></a>类模板成员函数类外实现</h4><ul><li>类模板中成员函数类外实现时，需要加上模板参数列表</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T1</span>, <span class="keyword">class</span> <span class="title">T2</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    T1 m_Name;</span><br><span class="line">    T2 m_Age;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//成员函数类内声明</span></span><br><span class="line">    Person(T1 name, T2 age);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">showPerson</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//构造函数 类外实现</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T1</span>, <span class="keyword">class</span> <span class="title">T2</span>&gt;</span></span><br><span class="line">Person&lt;T1, T2&gt;::Person(T1 name, T2 age) &#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;m_Name = name;</span><br><span class="line">    <span class="keyword">this</span>-&gt;m_Age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//成员函数 类外实现</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T1</span>, <span class="keyword">class</span> <span class="title">T2</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> Person&lt;T1, T2&gt;::showPerson() &#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;姓名: &quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;m_Name &lt;&lt; <span class="string">&quot; 年龄:&quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;m_Age &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Person&lt;string, int&gt; p(&quot;Tom&quot;, 20);</span><br><span class="line">    p.showPerson();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    test01();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="类模板分文件编写"><a href="#类模板分文件编写" class="headerlink" title="类模板分文件编写"></a>类模板分文件编写</h4><ul><li><p>针对问题：类模板中成员函数创建时机是在调用阶段，导致分文件编写时链接不到</p></li><li><p>解决方向：</p><ol><li><p>直接包含 .cpp 源文件：<code>#include &quot;person.cpp&quot;</code></p></li><li><p>将声明和实现写到同一个文件中，并更改后缀名为 .hpp：<code>#include &quot;person.hpp&quot;</code>（常用方法）</p><ul><li><pre><code class="c++">#ifndef CLEARNING_PERSON_HPP#define CLEARNING_PERSON_HPP</code></pre></li></ul></li></ol></li></ul><pre><code>   #include &lt;iostream&gt;   #include &lt;string&gt;   using namespace std;   template&lt;class T1, class T2&gt;   class Person &#123;   public:       T1 m_Name;       T2 m_Age;       Person(T1 name, T2 age);       void showPerson();   &#125;;   //构造函数 类外实现   template&lt;class T1, class T2&gt;   Person&lt;T1, T2&gt;::Person(T1 name, T2 age) &#123;       this-&gt;m_Name = name;       this-&gt;m_Age = age;   &#125;   //成员函数 类外实现   template&lt;class T1, class T2&gt;   void Person&lt;T1, T2&gt;::showPerson() &#123;       cout &lt;&lt; &quot;姓名: &quot; &lt;&lt; this-&gt;m_Name &lt;&lt; &quot; 年龄:&quot; &lt;&lt; this-&gt;m_Age &lt;&lt; endl;   &#125;   #endif //CLEARNING_PERSON_HPP   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- &#96;&#96;&#96;c++</span><br><span class="line">  #include &quot;Person.hpp&quot;</span><br><span class="line">  </span><br><span class="line">  void test01() &#123;</span><br><span class="line">      Person&lt;string, int&gt; p(&quot;Tom&quot;, 10);</span><br><span class="line">      p.showPerson();</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  int main() &#123;</span><br><span class="line">      test01();</span><br><span class="line">      return 0;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></code></pre><h4 id="类模板与友元"><a href="#类模板与友元" class="headerlink" title="类模板与友元"></a>类模板与友元</h4><ul><li><p>全局函数类内实现：直接在类内声明友元即可（推荐）</p></li><li><p>全局函数类外实现：需要提前让编译器知道全局函数的存在</p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 2. 全局函数配合友元  类外实现 - 先做函数模板声明，下方在做函数模板定义，在做友元</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T1</span>, <span class="keyword">class</span> <span class="title">T2</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果声明了函数模板，可以将实现写到后面，否则需要将实现体写到类的前面让编译器提前看到</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T1</span>, <span class="keyword">class</span> <span class="title">T2</span>&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printPerson2</span><span class="params">(Person&lt;T1, T2&gt; &amp;p)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;类外实现 ---- 姓名： &quot;</span> &lt;&lt; p.m_Name &lt;&lt; <span class="string">&quot; 年龄：&quot;</span> &lt;&lt; p.m_Age &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T1</span>, <span class="keyword">class</span> <span class="title">T2</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line">    <span class="comment">// 1. 全局函数配合友元   类内实现</span></span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="keyword">void</span> <span class="title">printPerson</span><span class="params">(Person&lt;T1, T2&gt; &amp;p)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;姓名： &quot;</span> &lt;&lt; p.m_Name &lt;&lt; <span class="string">&quot; 年龄：&quot;</span> &lt;&lt; p.m_Age &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 全局函数配合友元  类外实现</span></span><br><span class="line">    <span class="comment">// 添加空模板参数 &lt;&gt; 表示为类模板的函数</span></span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">void</span> printPerson2&lt;&gt;(Person&lt;T1, T2&gt; &amp;p);</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T1 m_Name;</span><br><span class="line">    T2 m_Age;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Person(T1 name, T2 age) &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;m_Name = name;</span><br><span class="line">        <span class="keyword">this</span>-&gt;m_Age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. 全局函数在类内实现</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Person&lt;string, int&gt; p(&quot;Tom&quot;, 20);</span><br><span class="line">    printPerson(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 全局函数在类外实现</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Person&lt;string, int&gt; p(&quot;Jerry&quot;, 30);</span><br><span class="line">    printPerson2(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    test01();</span><br><span class="line">    test02();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>C++-Part1</title>
      <link href="/2022/1/C++-Part1/"/>
      <url>/2022/1/C++-Part1/</url>
      
        <content type="html"><![CDATA[<h1 id="C-Part1——入门编程"><a href="#C-Part1——入门编程" class="headerlink" title="C++-Part1——入门编程"></a>C++-Part1——入门编程</h1><p>[TOC]</p><h2 id="CLion-环境配置"><a href="#CLion-环境配置" class="headerlink" title="CLion 环境配置"></a>CLion 环境配置</h2><h3 id="无-Virtual-Studio-方案"><a href="#无-Virtual-Studio-方案" class="headerlink" title="无 Virtual Studio 方案"></a>无 Virtual Studio 方案</h3><blockquote><p>参考：</p><ul><li>Cygwin（推荐）：<a href="https://zhuanlan.zhihu.com/p/40776005">https://zhuanlan.zhihu.com/p/40776005</a></li><li>MinGW：<a href="http://c.biancheng.net/view/8077.html">http://c.biancheng.net/view/8077.html</a></li></ul></blockquote><ol><li>下载 <a href="http://www.cygwin.com/">Cygwin</a></li><li>安装 - 选择国内镜像</li><li>安装 - 选择 gcc-core、gcc-g++、make、gdb、binutils</li><li>配置工具链</li></ol><h3 id="乱码解决方案"><a href="#乱码解决方案" class="headerlink" title="乱码解决方案"></a>乱码解决方案</h3><blockquote><p>根本原因在于移植的编译环境一般只支持 UTF-8，因此要以编译环境为中心，把可能的文件都改成 UTF-8 编码。</p><p>否则编码错误会出现在各种地方，包括 Release、ssh。以后使用其他项目，也统一使用 UTF-8 编码。</p></blockquote><ol><li><p>设置搜索 UTF-8，修改文件的编码设置。</p><p><img src="/2022/1/C++-Part1/image-20220506211715471.png" alt="image-20220506211715471"></p></li><li><p>修改 ssh 终端的编码设置</p><p><img src="/2022/1/C++-Part1/image-20220506211759176.png" alt="image-20220506211759176"></p></li><li><p>项目下所有文件全部转换成 UTF-8 编码</p><p><img src="/2022/1/C++-Part1/image-20220506211843056.png" alt="image-20220506211843056"></p></li></ol><h2 id="C-初识"><a href="#C-初识" class="headerlink" title="C++ 初识"></a>C++ 初识</h2><h3 id="Hello-World"><a href="#Hello-World" class="headerlink" title="Hello, World!"></a>Hello, World!</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    std::cout &lt;&lt; &quot;Hello, World!&quot; &lt;&lt; std::endl;</span><br><span class="line">    system(&quot;pause&quot;);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h3><ol><li><p>单行注释：</p><ul><li><p><code>// 描述信息</code> </p></li><li><p>通常在一行代码的上方或者一条语句的末尾，对该行代码说明</p></li></ul></li><li><p>多行注释： </p><ul><li><code>/* 描述信息 */</code></li><li>通常在一段代码的上方，对该段代码做整体说明</li></ul></li><li><p>条件编译：</p><ul><li><p><code>#if 0 ... #endif</code></p></li><li><p>可以使用条件编译来实现注释，且可以实现嵌套</p></li><li><p>通过改变参数 0/1 来开启/屏蔽代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">if</span> 0</span></span><br><span class="line">code1</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> </span></span><br></pre></td></tr></table></figure><h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3></li></ul></li></ol><ul><li><p>作用：给一段指定的内存空间起名，方便操作这段内存</p></li><li><p>语法：<code>数据类型 变量名 = 初始值</code>;</p></li></ul><h3 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h3><ul><li>作用：用于记录程序中不可更改的数据</li></ul><ol><li>#define 宏常量： <ul><li><code>#define 常量名 常量值</code></li><li>通常在文件上方定义，表示一个常量</li></ul></li></ol><ol start="2"><li>const 修饰的变量 <ul><li><code>const 数据类型 常量名 = 常量值</code></li><li>通常在变量定义前加关键字 const，修饰该变量为常量，不可修改</li></ul></li></ol><h3 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h3><table><thead><tr><th>asm</th><th>do</th><th>if</th><th>return</th><th>typedef</th></tr></thead><tbody><tr><td>auto</td><td>double</td><td>inline</td><td>short</td><td>typeid</td></tr><tr><td>bool</td><td>dynamic_cast</td><td>int</td><td>signed</td><td>typename</td></tr><tr><td>break</td><td>else</td><td>long</td><td>sizeof</td><td>union</td></tr><tr><td>case</td><td>enum</td><td>mutable</td><td>static</td><td>unsigned</td></tr><tr><td>catch</td><td>explicit</td><td>namespace</td><td>static_cast</td><td>using</td></tr><tr><td>char</td><td>export</td><td>new</td><td>struct</td><td>virtual</td></tr><tr><td>class</td><td>extern</td><td>operator</td><td>switch</td><td>void</td></tr><tr><td>const</td><td>false</td><td>private</td><td>template</td><td>volatile</td></tr><tr><td>const_cast</td><td>float</td><td>protected</td><td>this</td><td>wchar_t</td></tr><tr><td>continue</td><td>for</td><td>public</td><td>throw</td><td>while</td></tr><tr><td>default</td><td>friend</td><td>register</td><td>true</td><td></td></tr><tr><td>delete</td><td>goto</td><td>reinterpret_cast</td><td>try</td><td></td></tr></tbody></table><h3 id="标识符命名规则"><a href="#标识符命名规则" class="headerlink" title="标识符命名规则"></a>标识符命名规则</h3><ul><li>标识符不能是关键字</li><li>标识符只能由字母、数字、下划线组成</li><li>第一个字符必须为字母或下划线</li><li>标识符中字母区分大小写</li></ul><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><h3 id="整型"><a href="#整型" class="headerlink" title="整型"></a>整型</h3><ul><li><p>作用：整型变量表示的是整数类型的数据</p></li><li><p>C++ 中能够表示整型的类型有以下几种方式，<strong>区别在于所占内存空间不同</strong>：</p></li></ul><table><thead><tr><th><strong>数据类型</strong></th><th><strong>占用空间</strong></th><th>取值范围</th></tr></thead><tbody><tr><td>short（短整型）</td><td>2 字节</td><td>-2^15 ~ 2^15-1</td></tr><tr><td>int（整型）</td><td>4 字节</td><td>-2^31 ~ 2^31-1</td></tr><tr><td>long（长整形）</td><td>Windows 为 4 字节，Linux 为 4 字节（32位）8 字节（64位）</td><td>-2^31 ~ 2^31-1</td></tr><tr><td>long long（长长整形）</td><td>8 字节</td><td>-2^63 ~ 2^63-1</td></tr></tbody></table><h3 id="sizeof-关键字"><a href="#sizeof-关键字" class="headerlink" title="sizeof 关键字"></a>sizeof 关键字</h3><ul><li>作用：利用 sizeof 关键字可以统计数据类型所占内存大小</li><li>语法： <code>sizeof( 数据类型 / 变量)</code></li><li>结论：short &lt; int &lt;= long &lt;= long long</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;short 类型所占内存空间为： &quot;</span> &lt;&lt; <span class="keyword">sizeof</span>(<span class="keyword">short</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;int 类型所占内存空间为： &quot;</span> &lt;&lt; <span class="keyword">sizeof</span>(<span class="keyword">int</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;long 类型所占内存空间为： &quot;</span> &lt;&lt; <span class="keyword">sizeof</span>(<span class="keyword">long</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;long long 类型所占内存空间为： &quot;</span> &lt;&lt; <span class="keyword">sizeof</span>(<span class="keyword">long</span> <span class="keyword">long</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * short 类型所占内存空间为： 2</span></span><br><span class="line"><span class="comment"> * int 类型所占内存空间为： 4</span></span><br><span class="line"><span class="comment"> * long 类型所占内存空间为： 4</span></span><br><span class="line"><span class="comment"> * long long 类型所占内存空间为： 8</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><h3 id="实型（浮点型）"><a href="#实型（浮点型）" class="headerlink" title="实型（浮点型）"></a>实型（浮点型）</h3><ul><li><p>作用：用于表示小数</p></li><li><p>浮点型变量分为两种：</p><ul><li>单精度 float </li><li>双精度 double</li></ul></li><li><p>有效数字指所有出现的数字个数，浮点数的精度取决于其尾数</p></li></ul><table><thead><tr><th><strong>数据类型</strong></th><th><strong>占用空间</strong></th><th><strong>有效数字范围</strong></th></tr></thead><tbody><tr><td>float</td><td>4 字节</td><td>7 位有效数字</td></tr><tr><td>double</td><td>8 字节</td><td>15～16 位有效数字</td></tr></tbody></table><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">float</span> f1 = <span class="number">3.1415926f</span>;  <span class="comment">// f 指定为 float，否则会经过 double 转型</span></span><br><span class="line">    <span class="keyword">double</span> d1 = <span class="number">3.1415926</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; f1 &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">// 默认都只能打印 6 位有效</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; d1&lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;float  sizeof = &quot;</span> &lt;&lt; <span class="keyword">sizeof</span>(f1) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;double sizeof = &quot;</span> &lt;&lt; <span class="keyword">sizeof</span>(d1) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//科学计数法</span></span><br><span class="line">    <span class="keyword">float</span> f2 = <span class="number">3e2</span>; <span class="comment">// 3 * 10 ^ 2</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;f2 = &quot;</span> &lt;&lt; f2 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">float</span> f3 = <span class="number">3e-2</span>;  <span class="comment">// 3 * 0.1 ^ 2</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;f3 = &quot;</span> &lt;&lt; f3 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 3.14159</span></span><br><span class="line"><span class="comment"> * 31.4159</span></span><br><span class="line"><span class="comment"> * float  sizeof = 4</span></span><br><span class="line"><span class="comment"> * double sizeof = 8</span></span><br><span class="line"><span class="comment"> * f2 = 300</span></span><br><span class="line"><span class="comment"> * f3 = 0.03</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><h3 id="字符型"><a href="#字符型" class="headerlink" title="字符型"></a>字符型</h3><ul><li><p>作用：字符型变量用于显示单个字符</p></li><li><p>语法：<code>char ch = &#39;a&#39;;</code></p></li><li><p>注意：</p><ul><li>在显示字符型变量时，用单引号将字符括起来，不要用双引号</li><li>单引号内只能有一个字符，不可以是字符串</li></ul></li><li><p>C 和 C++ 中字符型变量只占用 1 个字节。</p></li><li><p>字符型变量是将对应的 ASCII 编码放入到存储单元</p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> ch = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ch &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="keyword">sizeof</span>(<span class="keyword">char</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; (<span class="keyword">int</span>)ch &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">//查看字符a对应的ASCII码</span></span><br><span class="line">    ch = <span class="number">97</span>; <span class="comment">//可以直接用ASCII给字符型变量赋值</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ch &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * a</span></span><br><span class="line"><span class="comment"> * 1</span></span><br><span class="line"><span class="comment"> * 97</span></span><br><span class="line"><span class="comment"> * a</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><p>ASCII 码大致由以下两部分组成：</p><ul><li>ASCII 非打印控制字符： ASCII 表上的数字 <strong>0-31</strong> 分配给了控制字符，用于控制像打印机等一些外围设备。</li><li>ASCII 打印字符：数字 <strong>32-126</strong> 分配给了能在键盘上找到的字符，当查看或打印文档时就会出现。</li></ul><table><thead><tr><th><strong>ASCII</strong>值</th><th><strong>控制字符</strong></th><th><strong>ASCII</strong>值</th><th><strong>字符</strong></th><th><strong>ASCII</strong>值</th><th><strong>字符</strong></th><th><strong>ASCII</strong>值</th><th><strong>字符</strong></th></tr></thead><tbody><tr><td>0</td><td>NUT</td><td>32</td><td>(space)</td><td>64</td><td>@</td><td>96</td><td>、</td></tr><tr><td>1</td><td>SOH</td><td>33</td><td>!</td><td>65</td><td>A</td><td>97</td><td>a</td></tr><tr><td>2</td><td>STX</td><td>34</td><td>“</td><td>66</td><td>B</td><td>98</td><td>b</td></tr><tr><td>3</td><td>ETX</td><td>35</td><td>#</td><td>67</td><td>C</td><td>99</td><td>c</td></tr><tr><td>4</td><td>EOT</td><td>36</td><td>$</td><td>68</td><td>D</td><td>100</td><td>d</td></tr><tr><td>5</td><td>ENQ</td><td>37</td><td>%</td><td>69</td><td>E</td><td>101</td><td>e</td></tr><tr><td>6</td><td>ACK</td><td>38</td><td>&amp;</td><td>70</td><td>F</td><td>102</td><td>f</td></tr><tr><td>7</td><td>BEL</td><td>39</td><td>,</td><td>71</td><td>G</td><td>103</td><td>g</td></tr><tr><td>8</td><td>BS</td><td>40</td><td>(</td><td>72</td><td>H</td><td>104</td><td>h</td></tr><tr><td>9</td><td>HT</td><td>41</td><td>)</td><td>73</td><td>I</td><td>105</td><td>i</td></tr><tr><td>10</td><td>LF</td><td>42</td><td>*</td><td>74</td><td>J</td><td>106</td><td>j</td></tr><tr><td>11</td><td>VT</td><td>43</td><td>+</td><td>75</td><td>K</td><td>107</td><td>k</td></tr><tr><td>12</td><td>FF</td><td>44</td><td>,</td><td>76</td><td>L</td><td>108</td><td>l</td></tr><tr><td>13</td><td>CR</td><td>45</td><td>-</td><td>77</td><td>M</td><td>109</td><td>m</td></tr><tr><td>14</td><td>SO</td><td>46</td><td>.</td><td>78</td><td>N</td><td>110</td><td>n</td></tr><tr><td>15</td><td>SI</td><td>47</td><td>/</td><td>79</td><td>O</td><td>111</td><td>o</td></tr><tr><td>16</td><td>DLE</td><td>48</td><td>0</td><td>80</td><td>P</td><td>112</td><td>p</td></tr><tr><td>17</td><td>DCI</td><td>49</td><td>1</td><td>81</td><td>Q</td><td>113</td><td>q</td></tr><tr><td>18</td><td>DC2</td><td>50</td><td>2</td><td>82</td><td>R</td><td>114</td><td>r</td></tr><tr><td>19</td><td>DC3</td><td>51</td><td>3</td><td>83</td><td>S</td><td>115</td><td>s</td></tr><tr><td>20</td><td>DC4</td><td>52</td><td>4</td><td>84</td><td>T</td><td>116</td><td>t</td></tr><tr><td>21</td><td>NAK</td><td>53</td><td>5</td><td>85</td><td>U</td><td>117</td><td>u</td></tr><tr><td>22</td><td>SYN</td><td>54</td><td>6</td><td>86</td><td>V</td><td>118</td><td>v</td></tr><tr><td>23</td><td>TB</td><td>55</td><td>7</td><td>87</td><td>W</td><td>119</td><td>w</td></tr><tr><td>24</td><td>CAN</td><td>56</td><td>8</td><td>88</td><td>X</td><td>120</td><td>x</td></tr><tr><td>25</td><td>EM</td><td>57</td><td>9</td><td>89</td><td>Y</td><td>121</td><td>y</td></tr><tr><td>26</td><td>SUB</td><td>58</td><td>:</td><td>90</td><td>Z</td><td>122</td><td>z</td></tr><tr><td>27</td><td>ESC</td><td>59</td><td>;</td><td>91</td><td>[</td><td>123</td><td>{</td></tr><tr><td>28</td><td>FS</td><td>60</td><td>&lt;</td><td>92</td><td>/</td><td>124</td><td>|</td></tr><tr><td>29</td><td>GS</td><td>61</td><td>=</td><td>93</td><td>]</td><td>125</td><td>}</td></tr><tr><td>30</td><td>RS</td><td>62</td><td>&gt;</td><td>94</td><td>^</td><td>126</td><td>`</td></tr><tr><td>31</td><td>US</td><td>63</td><td>?</td><td>95</td><td>_</td><td>127</td><td>DEL</td></tr></tbody></table><h3 id="转义字符"><a href="#转义字符" class="headerlink" title="转义字符"></a>转义字符</h3><ul><li>作用：用于表示一些不能显示出来的 ASCII 字符</li></ul><table><thead><tr><th><strong>转义字符</strong></th><th><strong>含义</strong></th><th><strong>ASCII</strong>码值（十进制）</th></tr></thead><tbody><tr><td>\a</td><td>警报</td><td>007</td></tr><tr><td>\b</td><td>退格(BS) ，将当前位置移到前一列</td><td>008</td></tr><tr><td>\f</td><td>换页(FF)，将当前位置移到下页开头</td><td>012</td></tr><tr><td>\n</td><td>换行(LF) ，将当前位置移到下一行开头</td><td>010</td></tr><tr><td>\r</td><td>回车(CR) ，将当前位置移到本行开头</td><td>013</td></tr><tr><td>\t</td><td>水平制表(HT)  （跳到下一个TAB位置/8个字符位）</td><td>009</td></tr><tr><td>\v</td><td>垂直制表(VT)</td><td>011</td></tr><tr><td>\\</td><td>代表一个反斜线字符”\“</td><td>092</td></tr><tr><td>\&#39;</td><td>代表一个单引号（撇号）字符</td><td>039</td></tr><tr><td>\&quot;</td><td>代表一个双引号字符</td><td>034</td></tr><tr><td>?</td><td>代表一个问号</td><td>063</td></tr><tr><td>\0</td><td>数字0</td><td>000</td></tr><tr><td>\\ddd</td><td>8 进制转义字符，d 范围 0~7</td><td>3位8进制</td></tr><tr><td>\\xhh</td><td>16 进制转义字符，h 范围 0<del>9， a</del>f， A~F</td><td>3位16进制</td></tr></tbody></table><h3 id="字符串型"><a href="#字符串型" class="headerlink" title="字符串型"></a>字符串型</h3><ul><li>作用：用于表示一串字符</li></ul><ul><li><p>两种风格：</p><ol><li><p>C 风格字符串：<code>char 变量名[] = &quot;字符串值&quot;</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> str1[] = <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; str1 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>C++ 风格字符串：<code>string  变量名 = &quot;字符串值&quot;</code></p><ul><li>需要加入 <code>#include &lt;string&gt;</code></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">string</span> str = <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; str &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol></li><li><blockquote><p>注意：string 对象不要和 char 数组混用</p></blockquote></li></ul><h3 id="布尔类型"><a href="#布尔类型" class="headerlink" title="布尔类型"></a>布尔类型</h3><ul><li><p>作用：布尔数据类型代表真或假的值</p></li><li><p>bool 类型只有两个值：</p><ul><li>true  — 真（本质是1）</li><li>false — 假（本质是0）</li></ul></li><li><p>bool 类型占 1 个字节大小</p></li></ul><h3 id="数据的输入"><a href="#数据的输入" class="headerlink" title="数据的输入"></a>数据的输入</h3><ul><li><p>作用：用于从键盘获取数据</p></li><li><p>语法： <code>cin &gt;&gt; 变量</code></p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//整型输入</span></span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;请输入整型变量：&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; a;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; a &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//浮点型输入</span></span><br><span class="line">    <span class="keyword">double</span> d = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;请输入浮点型变量：&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; d;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; d &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//字符型输入</span></span><br><span class="line">    <span class="keyword">char</span> ch = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;请输入字符型变量：&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; ch;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ch &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//字符串型输入</span></span><br><span class="line">    <span class="built_in">string</span> str;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;请输入字符串型变量：&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; str;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; str &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//布尔类型输入</span></span><br><span class="line">    <span class="keyword">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;请输入布尔型变量：&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; flag;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; flag &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> EXIT_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h2><h3 id="算术运算符"><a href="#算术运算符" class="headerlink" title="算术运算符"></a>算术运算符</h3><ul><li>作用：用于处理四则运算 </li></ul><table><thead><tr><th><strong>运算符</strong></th><th><strong>术语</strong></th><th><strong>示例</strong></th><th><strong>结果</strong></th></tr></thead><tbody><tr><td>+</td><td>正号</td><td>+3</td><td>3</td></tr><tr><td>-</td><td>负号</td><td>-3</td><td>-3</td></tr><tr><td>+</td><td>加</td><td>10 + 5</td><td>15</td></tr><tr><td>-</td><td>减</td><td>10 - 5</td><td>5</td></tr><tr><td>*</td><td>乘</td><td>10 * 5</td><td>50</td></tr><tr><td>/</td><td>除</td><td>10 / 5</td><td>2</td></tr><tr><td>%</td><td>取模（取余）</td><td>10 % 3</td><td>1</td></tr><tr><td>++</td><td>前置递增</td><td>a=2; b=++a;</td><td>a=3; b=3;</td></tr><tr><td>++</td><td>后置递增</td><td>a=2; b=a++;</td><td>a=3; b=2;</td></tr><tr><td>–</td><td>前置递减</td><td>a=2; b=–a;</td><td>a=1; b=1;</td></tr><tr><td>–</td><td>后置递减</td><td>a=2; b=a–;</td><td>a=1; b=2;</td></tr></tbody></table><h3 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符"></a>赋值运算符</h3><ul><li>作用：用于将表达式的值赋给变量</li></ul><table><thead><tr><th><strong>运算符</strong></th><th><strong>术语</strong></th><th><strong>示例</strong></th><th><strong>结果</strong></th></tr></thead><tbody><tr><td>=</td><td>赋值</td><td>a=2; b=3;</td><td>a=2; b=3;</td></tr><tr><td>+=</td><td>加等于</td><td>a=0; a+=2;</td><td>a=2;</td></tr><tr><td>-=</td><td>减等于</td><td>a=5; a-=3;</td><td>a=2;</td></tr><tr><td>*=</td><td>乘等于</td><td>a=2; a*=2;</td><td>a=4;</td></tr><tr><td>/=</td><td>除等于</td><td>a=4; a/=2;</td><td>a=2;</td></tr><tr><td>%=</td><td>模等于</td><td>a=3; a%2;</td><td>a=1;</td></tr></tbody></table><h3 id="比较运算符"><a href="#比较运算符" class="headerlink" title="比较运算符"></a>比较运算符</h3><ul><li>作用：用于表达式的比较，并返回一个真值或假值</li></ul><table><thead><tr><th><strong>运算符</strong></th><th><strong>术语</strong></th><th><strong>示例</strong></th><th><strong>结果</strong></th></tr></thead><tbody><tr><td>==</td><td>相等于</td><td>4 == 3</td><td>0</td></tr><tr><td>!=</td><td>不等于</td><td>4 != 3</td><td>1</td></tr><tr><td>&lt;</td><td>小于</td><td>4 &lt; 3</td><td>0</td></tr><tr><td>&gt;</td><td>大于</td><td>4 &gt; 3</td><td>1</td></tr><tr><td>&lt;=</td><td>小于等于</td><td>4 &lt;= 3</td><td>0</td></tr><tr><td>&gt;=</td><td>大于等于</td><td>4 &gt;= 1</td><td>1</td></tr></tbody></table><h3 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h3><ul><li>作用：用于根据表达式的值返回真值或假值</li></ul><table><thead><tr><th><strong>运算符</strong></th><th><strong>术语</strong></th><th><strong>示例</strong></th><th><strong>结果</strong></th></tr></thead><tbody><tr><td>!</td><td>非</td><td>!a</td><td>如果a为假，则!a为真；  如果a为真，则!a为假。</td></tr><tr><td>&amp;&amp;</td><td>与</td><td>a &amp;&amp; b</td><td>如果a和b都为真，则结果为真，否则为假。</td></tr><tr><td>||</td><td>或</td><td>a || b</td><td>如果a和b有一个为真，则结果为真，二者都为假时，结果为假。</td></tr></tbody></table><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> b = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> c = <span class="number">3</span>;</span><br><span class="line">    a += b || c;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; a &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; b &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; c &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> EXIT_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="程序流程结构"><a href="#程序流程结构" class="headerlink" title="程序流程结构"></a>程序流程结构</h2><blockquote><p>C/C++支持最基本的三种程序运行结构：</p><ul><li>顺序结构：程序按顺序执行，不发生跳转</li><li>选择结构：依据条件是否满足，有选择的执行相应功能</li><li>循环结构：依据条件是否满足，循环多次执行某段代码</li></ul></blockquote><h3 id="选择结构"><a href="#选择结构" class="headerlink" title="选择结构"></a>选择结构</h3><h4 id="if-语句"><a href="#if-语句" class="headerlink" title="if 语句"></a>if 语句</h4><ul><li><p>作用：执行满足条件的语句</p></li><li><p>if 语句的三种形式</p><ul><li><p>单行格式 if 语句</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ( 条件 ) &#123; </span><br><span class="line">    条件满足执行的语句</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>多行格式 if 语句</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ( 条件 ) &#123; </span><br><span class="line">    条件满足执行的语句</span><br><span class="line">&#125; <span class="keyword">else</span> &#123; </span><br><span class="line">    条件不满足执行的语句</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>多条件的 if 语句</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ( 条件<span class="number">1</span> ) &#123; </span><br><span class="line">条件<span class="number">1</span>满足执行的语句</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> ( 条件<span class="number">2</span> ) &#123;</span><br><span class="line">    条件<span class="number">2</span>满足执行的语句</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">else</span> &#123; </span><br><span class="line">都不满足执行的语句</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="三目运算符"><a href="#三目运算符" class="headerlink" title="三目运算符"></a>三目运算符</h4></li></ul></li><li><p>作用： 通过三目运算符实现简单的判断</p></li><li><p>语法：<code>表达式1 ? 语句2 ：语句3</code></p></li><li><p>C++ 中三目运算符返回的是变量，可以继续赋值</p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">int</span> b = <span class="number">20</span>;</span><br><span class="line">    <span class="keyword">int</span> c = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    c = a &gt; b ? a : b;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;c = &quot;</span> &lt;&lt; c &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">// c = 20</span></span><br><span class="line"></span><br><span class="line">    (a &gt; b ? a : b) = <span class="number">100</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">// a = 10</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;b = &quot;</span> &lt;&lt; b &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">// b = 100</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;c = &quot;</span> &lt;&lt; c &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">// c = 20</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="switch-语句"><a href="#switch-语句" class="headerlink" title="switch 语句"></a>switch 语句</h4><ul><li><p>作用：执行多条件分支语句</p></li><li><p>注意：</p><ul><li>switch 语句中表达式类型只能是整型或者字符型</li><li>case 里如果没有 break，那么程序会一直向下执行</li><li>与 if 语句比，对于多条件判断时，switch 结构清晰，执行效率高，缺点是 switch 不可以直接判断区间</li></ul></li><li><p>语法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> ( 表达式 ) &#123;</span><br><span class="line">    <span class="keyword">case</span> 结果<span class="number">1</span>: 执行语句; <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> 结果<span class="number">2</span>: 执行语句; <span class="keyword">break</span>;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">default</span>: 执行语句; <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//请给电影评分 </span></span><br><span class="line"><span class="comment">//10 ~ 9   经典   </span></span><br><span class="line"><span class="comment">// 8 ~ 7   非常好</span></span><br><span class="line"><span class="comment">// 6 ~ 5   一般</span></span><br><span class="line"><span class="comment">// 5分以下 烂片</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> score = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;请给电影打分&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; score;</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> (score) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">10</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="number">9</span>:</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;经典&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">8</span>:</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;非常好&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">7</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="number">6</span>:</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;一般&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;烂片&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="循环结构"><a href="#循环结构" class="headerlink" title="循环结构"></a>循环结构</h3></li></ul><h4 id="while-循环语句"><a href="#while-循环语句" class="headerlink" title="while 循环语句"></a>while 循环语句</h4><ul><li><p>作用：满足循环条件，执行循环语句</p></li><li><p>语法： </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> ( 循环条件 ) &#123; </span><br><span class="line">    循环语句 </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="do…while-循环语句"><a href="#do…while-循环语句" class="headerlink" title="do…while 循环语句"></a>do…while 循环语句</h4></li><li><p>作用： 先执行一次语句，之后满足循环条件，执行循环语句</p></li><li><p>注意：</p><ul><li>while 后面要加分号</li></ul></li><li><p>语法： </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; num &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    num++;</span><br><span class="line">&#125; <span class="keyword">while</span> (num &lt; <span class="number">10</span>);</span><br></pre></td></tr></table></figure><h4 id="for-循环语句"><a href="#for-循环语句" class="headerlink" title="for 循环语句"></a>for 循环语句</h4></li><li><p>作用： 满足循环条件，执行循环语句</p></li><li><p>语法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="跳转语句"><a href="#跳转语句" class="headerlink" title="跳转语句"></a>跳转语句</h3></li></ul><h4 id="break-语句"><a href="#break-语句" class="headerlink" title="break 语句"></a>break 语句</h4><ul><li><p>作用：用于跳出选择结构或者循环结构</p></li><li><p>break 使用的时机：</p><ul><li>出现在 switch 条件语句中，作用是终止 case 并跳出 switch</li><li>出现在循环语句中，作用是跳出当前的循环语句</li><li>出现在嵌套循环中，跳出最近的内层循环语句</li></ul></li></ul><h4 id="continue-语句"><a href="#continue-语句" class="headerlink" title="continue 语句"></a>continue 语句</h4><ul><li>作用：在循环语句中，跳过本次循环中余下尚未执行的语句，继续执行下一次循环</li></ul><ul><li>注意：continue 并没有使整个循环终止，而 break 会跳出循环</li></ul><h4 id="goto-语句"><a href="#goto-语句" class="headerlink" title="goto 语句"></a>goto 语句</h4><ul><li><p>作用：可以无条件跳转语句</p></li><li><p>注意</p><ul><li>在程序中不建议使用 goto 语句，以免造成程序流程混乱</li></ul></li><li><p>语法： <code>goto 标记;</code></p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;1&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">goto</span> FLAG;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;2&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;3&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;4&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">FLAG:</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;5&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><h3 id="一维数组"><a href="#一维数组" class="headerlink" title="一维数组"></a>一维数组</h3><h4 id="一维数组定义方式"><a href="#一维数组定义方式" class="headerlink" title="一维数组定义方式"></a>一维数组定义方式</h4><ul><li>一维数组定义的三种方式：<ol><li><code>数据类型 数组名[ 数组长度 ];</code></li><li><code>数据类型 数组名[ 数组长度 ] = &#123; 值1，值2 ... &#125;;</code></li><li><code>数据类型 数组名[ ] = &#123; 值1，值2 ... &#125;;</code></li></ol></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 1. 第一种定义方式</span></span><br><span class="line">    <span class="comment">// 数据类型 数组名[元素个数];</span></span><br><span class="line">    <span class="keyword">int</span> arr1[<span class="number">10</span>];</span><br><span class="line">    arr1[<span class="number">0</span>] = <span class="number">100</span>;  <span class="comment">// 利用下标赋值</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; arr1[<span class="number">0</span>] &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">// 利用下标输出</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 第二种定义方式</span></span><br><span class="line">    <span class="comment">// 数据类型 数组名[元素个数] =  &#123;值1，值2 ，值3 ...&#125;;</span></span><br><span class="line">    <span class="comment">// 如果&#123;&#125;内不足10个数据，剩余数据用0补全</span></span><br><span class="line">    <span class="keyword">int</span> arr2[<span class="number">10</span>] = &#123;<span class="number">100</span>, <span class="number">90</span>, <span class="number">80</span>, <span class="number">70</span>, <span class="number">60</span>, <span class="number">50</span>, <span class="number">40</span>, <span class="number">30</span>, <span class="number">20</span>, <span class="number">10</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; arr2[i] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 第三种定义方式</span></span><br><span class="line">    <span class="comment">// 数据类型 数组名[] =  &#123;值1，值2 ，值3 ...&#125;;</span></span><br><span class="line">    <span class="keyword">int</span> arr3[] = &#123;<span class="number">100</span>, <span class="number">90</span>, <span class="number">80</span>, <span class="number">70</span>, <span class="number">60</span>, <span class="number">50</span>, <span class="number">40</span>, <span class="number">30</span>, <span class="number">20</span>, <span class="number">10</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i : arr3) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="一维数组数组名"><a href="#一维数组数组名" class="headerlink" title="一维数组数组名"></a>一维数组数组名</h4><ul><li><p>一维数组名称的用途：</p><ol><li>可以统计整个数组在内存中的长度：<code>sizeof(arr)</code></li><li>可以获取数组在内存中的首地址：<code>(int) &amp;arr[0]</code></li></ol></li><li><p>数组名是指针常量，不可以赋值</p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//数组名用途</span></span><br><span class="line">    <span class="comment">//1、可以获取整个数组占用内存空间大小</span></span><br><span class="line">    <span class="keyword">int</span> arr[<span class="number">10</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;整个数组所占内存空间为： &quot;</span> &lt;&lt; <span class="keyword">sizeof</span>(arr) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;每个元素所占内存空间为： &quot;</span> &lt;&lt; <span class="keyword">sizeof</span>(arr[<span class="number">0</span>]) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;数组的元素个数为： &quot;</span> &lt;&lt; <span class="keyword">sizeof</span>(arr) / <span class="keyword">sizeof</span>(arr[<span class="number">0</span>]) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2、可以通过数组名获取到数组首地址</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;数组首地址为： &quot;</span> &lt;&lt; (<span class="keyword">int</span>) arr &lt;&lt; <span class="string">&quot; - &quot;</span> &lt;&lt; arr &lt;&lt;  <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;数组中第一个元素地址为： &quot;</span> &lt;&lt; (<span class="keyword">int</span>) &amp;arr[<span class="number">0</span>] &lt;&lt; <span class="string">&quot; - &quot;</span> &lt;&lt; &amp;arr[<span class="number">0</span>] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;数组中第二个元素地址为： &quot;</span> &lt;&lt; (<span class="keyword">int</span>) &amp;arr[<span class="number">1</span>] &lt;&lt; <span class="string">&quot; - &quot;</span> &lt;&lt; &amp;arr[<span class="number">1</span>] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 整个数组所占内存空间为： 40</span></span><br><span class="line"><span class="comment"> * 每个元素所占内存空间为： 4</span></span><br><span class="line"><span class="comment"> * 数组的元素个数为： 10</span></span><br><span class="line"><span class="comment"> * 数组首地址为： 7338512 - 006FFA10</span></span><br><span class="line"><span class="comment"> * 数组中第一个元素地址为： 7338512 - 006FFA10</span></span><br><span class="line"><span class="comment"> * 数组中第二个元素地址为： 7338516 - 006FFA14</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><h3 id="二维数组"><a href="#二维数组" class="headerlink" title="二维数组"></a>二维数组</h3><h4 id="二维数组定义方式"><a href="#二维数组定义方式" class="headerlink" title="二维数组定义方式"></a>二维数组定义方式</h4><ul><li>二维数组定义的四种方式：<ol><li><code>数据类型 数组名[ 行数 ][ 列数 ];</code></li><li><code>数据类型 数组名[ 行数 ][ 列数 ] = &#123; &#123;数据1，数据2 &#125; ，&#123;数据3，数据4 &#125; &#125;;</code>（推荐）</li><li><code>数据类型 数组名[ 行数 ][ 列数 ] = &#123; 数据1，数据2，数据3，数据4&#125;;</code></li><li><code> 数据类型 数组名[  ][ 列数 ] = &#123; 数据1，数据2，数据3，数据4&#125;;</code></li></ol></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 1. 方式1</span></span><br><span class="line">    <span class="comment">// 数组类型 数组名 [行数][列数]</span></span><br><span class="line">    <span class="keyword">int</span> arr[<span class="number">2</span>][<span class="number">3</span>];</span><br><span class="line">    arr[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    arr[<span class="number">0</span>][<span class="number">1</span>] = <span class="number">2</span>;</span><br><span class="line">    arr[<span class="number">0</span>][<span class="number">2</span>] = <span class="number">3</span>;</span><br><span class="line">    arr[<span class="number">1</span>][<span class="number">0</span>] = <span class="number">4</span>;</span><br><span class="line">    arr[<span class="number">1</span>][<span class="number">1</span>] = <span class="number">5</span>;</span><br><span class="line">    arr[<span class="number">1</span>][<span class="number">2</span>] = <span class="number">6</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;i : arr) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j : i) &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; j &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 方式2</span></span><br><span class="line">    <span class="comment">// 数据类型 数组名[行数][列数] = &#123; &#123;数据1，数据2 &#125; ，&#123;数据3，数据4 &#125; &#125;;</span></span><br><span class="line">    <span class="keyword">int</span> arr2[<span class="number">2</span>][<span class="number">3</span>] = &#123;&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;,</span><br><span class="line">                      &#123;<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&#125;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 方式3</span></span><br><span class="line">    <span class="comment">// 数据类型 数组名[行数][列数] = &#123; 数据1，数据2 ,数据3，数据4  &#125;;</span></span><br><span class="line">    <span class="keyword">int</span> arr3[<span class="number">2</span>][<span class="number">3</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4. 方式4</span></span><br><span class="line">    <span class="comment">// 数据类型 数组名[][列数] = &#123; 数据1，数据2 ,数据3，数据4  &#125;;</span></span><br><span class="line">    <span class="keyword">int</span> arr4[][<span class="number">3</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="二维数组数组名"><a href="#二维数组数组名" class="headerlink" title="二维数组数组名"></a>二维数组数组名</h4><ul><li>用途<ul><li>查看二维数组所占内存空间：<code>sizeof(arr)</code></li><li>获取二维数组首地址：<code>&amp;arr[0][0]</code></li></ul></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> arr[<span class="number">2</span>][<span class="number">3</span>] = &#123;&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;,</span><br><span class="line">                     &#123;<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&#125;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 大小</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;二维数组大小：&quot;</span> &lt;&lt; <span class="keyword">sizeof</span>(arr) &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">// 二维数组大小：24</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;二维数组一行大小：&quot;</span> &lt;&lt; <span class="keyword">sizeof</span>(arr[<span class="number">0</span>]) &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">// 二维数组一行大小：12</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;二维数组元素大小：&quot;</span> &lt;&lt; <span class="keyword">sizeof</span>(arr[<span class="number">0</span>][<span class="number">0</span>]) &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">// 二维数组元素大小：4</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;二维数组行数：&quot;</span> &lt;&lt; <span class="keyword">sizeof</span>(arr) / <span class="keyword">sizeof</span>(arr[<span class="number">0</span>]) &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">// 二维数组行数：2</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;二维数组列数：&quot;</span> &lt;&lt; <span class="keyword">sizeof</span>(arr[<span class="number">0</span>]) / <span class="keyword">sizeof</span>(arr[<span class="number">0</span>][<span class="number">0</span>]) &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">// 二维数组列数：3</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 地址</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;二维数组首地址：&quot;</span> &lt;&lt; arr &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">// 二维数组首地址：009AFC94</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;二维数组第一行地址：&quot;</span> &lt;&lt; arr[<span class="number">0</span>] &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">// 二维数组第一行地址：009AFC94</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;二维数组第二行地址：&quot;</span> &lt;&lt; arr[<span class="number">1</span>] &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">// 二维数组第二行地址：009AFCA0</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;二维数组第一个元素地址：&quot;</span> &lt;&lt; &amp;arr[<span class="number">0</span>][<span class="number">0</span>] &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">// 二维数组第一个元素地址：009AFC94</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;二维数组第二个元素地址：&quot;</span> &lt;&lt; &amp;arr[<span class="number">0</span>][<span class="number">1</span>] &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">// 二维数组第二个元素地址：009AFC98</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><h3 id="函数的定义"><a href="#函数的定义" class="headerlink" title="函数的定义"></a>函数的定义</h3><ul><li><p>函数的定义的 5 个要素：</p><ul><li>返回值类型 ：一个函数可以返回一个值</li><li>函数名：给函数起个名称</li><li>参数列表：使用该函数时，传入的数据</li><li>函数体语句：花括号内的代码，函数内需要执行的语句</li><li>return 表达式： 和返回值类型挂钩，函数执行完后，返回相应的数据</li></ul></li><li><p>函数定义里小括号内称为<strong>形参</strong>，函数调用时传入的参数称为<strong>实参</strong></p></li><li><p>语法： </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">返回值类型 函数名(形参<span class="number">1</span>类型 形参<span class="number">1</span>名[, ...]) &#123;</span><br><span class="line">函数体</span><br><span class="line">[<span class="keyword">return</span> 表达式;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="函数的调用"><a href="#函数的调用" class="headerlink" title="函数的调用"></a>函数的调用</h3></li><li><p>功能：使用定义好的函数</p></li><li><p>语法：<code>函数名(参数)</code></p></li></ul><h3 id="值传递"><a href="#值传递" class="headerlink" title="值传递"></a>值传递</h3><ul><li>值传递，指函数调用时，<strong>实参将数值传入给形参（赋值传递）</strong></li><li>值传递时，局部变量的改变，不会影响到外部变量</li></ul><h3 id="函数的常见样式"><a href="#函数的常见样式" class="headerlink" title="函数的常见样式"></a>函数的常见样式</h3><ul><li>常见的函数样式有4种<ol><li>无参无返</li><li>有参无返</li><li>无参有返</li><li>有参有返</li></ol></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1. 无参无返</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;this is test01&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2. 有参无返</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">(<span class="keyword">int</span> a)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;this is test02&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//3. 无参有返</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">test03</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;this is test03 &quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//4. 有参有返</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">test04</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;this is test04 &quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">int</span> sum = a + b;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="函数的声明"><a href="#函数的声明" class="headerlink" title="函数的声明"></a>函数的声明</h3><ul><li>作用： 告诉编译器函数名称及如何调用函数。</li><li>函数的实际主体可以单独定义。</li><li>函数的<strong>声明可以多次</strong>，但是函数的<strong>定义只能有一次</strong></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//声明</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">max</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">max</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">max</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a &gt; b ? a : b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">int</span> b = <span class="number">200</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; max(a, b) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="函数的分文件编写"><a href="#函数的分文件编写" class="headerlink" title="函数的分文件编写"></a>函数的分文件编写</h3><ul><li><p>作用：让代码结构更加清晰</p></li><li><p>函数分文件编写一般有 4 个步骤</p><ol><li>创建后缀名为 .h 的头文件  </li><li>创建后缀名为 .cpp 的源文件</li><li>在头文件中写函数的声明</li><li>在源文件中写函数的定义</li></ol></li><li><blockquote><p>使用 CMakeLists.txt 时，需要编辑：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">cmake_minimum_required(VERSION <span class="number">3.19</span>)</span><br><span class="line">project(CLearning)</span><br><span class="line"></span><br><span class="line"><span class="built_in">set</span>(CMAKE_CXX_STANDARD <span class="number">20</span>)</span><br><span class="line"></span><br><span class="line">add_executable(CLearning main.cpp swap.cpp swap.h)</span><br></pre></td></tr></table></figure></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// -&gt; swap.h文件</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> CLEARNING_SWAP_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CLEARNING_SWAP_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现两个数字交换的函数声明</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">//CLEARNING_SWAP_H</span></span></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// -&gt; swap.cpp文件</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;swap.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp = a;</span><br><span class="line">    a = b;</span><br><span class="line">    b = temp;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;b = &quot;</span> &lt;&lt; b &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// -&gt; main函数文件</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;swap.h&quot;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> a = <span class="number">100</span>;</span><br><span class="line"><span class="keyword">int</span> b = <span class="number">200</span>;</span><br><span class="line">swap(a, b);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h2></li></ul><h3 id="指针变量的定义和使用"><a href="#指针变量的定义和使用" class="headerlink" title="指针变量的定义和使用"></a>指针变量的定义和使用</h3><ul><li><blockquote><p>指针也是一种数据类型，可以使用 <code>(int *)</code> 强转</p></blockquote></li><li><p>指针变量定义语法： <code>数据类型 * 变量名；</code></p></li><li><p>指针变量和普通变量的区别</p><ul><li>普通变量存放的是数据,指针变量存放的是地址</li><li>指针变量可以通过解引用操作符 <code>*</code>，操作指针变量指向的内存空间</li></ul></li><li><p>总结</p><ul><li>我们可以通过 <code>&amp;</code> 符号获取变量的地址</li><li>利用指针可以记录地址</li><li>对指针变量解引用，可以操作指针指向的内存</li></ul></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 1. 指针的定义</span></span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">10</span>; <span class="comment">//定义整型变量a</span></span><br><span class="line">    <span class="comment">// 指针定义语法： 数据类型 * 变量名 ;</span></span><br><span class="line">    <span class="keyword">int</span> *p;</span><br><span class="line">    <span class="comment">// 指针变量赋值</span></span><br><span class="line">    p = &amp;a; <span class="comment">// 指针指向变量a的地址</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; &amp;a &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 打印数据a的地址</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; p &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">// 打印指针变量p</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 指针的使用</span></span><br><span class="line">    <span class="comment">// 通过*解引用符操作指针变量指向的内存</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;*p = &quot;</span> &lt;&lt; *p &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="指针所占内存空间"><a href="#指针所占内存空间" class="headerlink" title="指针所占内存空间"></a>指针所占内存空间</h3><ul><li>所有指针类型在 32 位操作系统下是 4 个字节</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> * p;</span><br><span class="line">p = &amp;a; <span class="comment">// 指针指向数据a的地址</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; *p &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// * 解引用</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="keyword">sizeof</span>(p) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="keyword">sizeof</span>(<span class="keyword">char</span> *) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="keyword">sizeof</span>(<span class="keyword">float</span> *) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="keyword">sizeof</span>(<span class="keyword">double</span> *) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="空指针和野指针"><a href="#空指针和野指针" class="headerlink" title="空指针和野指针"></a>空指针和野指针</h3><ul><li>空指针：指针变量指向内存中编号为 0 的空间</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// 指针变量p指向内存地址编号为0的空间</span></span><br><span class="line"><span class="keyword">int</span> * p = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 访问空指针报错 </span></span><br><span class="line"><span class="comment">// 内存编号 0 ~255 为系统占用内存，不允许用户访问</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; *p &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>野指针：指针变量指向非法的内存空间</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// 指针变量p指向内存地址编号为0x1100的空间</span></span><br><span class="line"><span class="keyword">int</span> * p = (<span class="keyword">int</span> *)<span class="number">0x1100</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 访问野指针报错 </span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; *p &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="const-修饰指针"><a href="#const-修饰指针" class="headerlink" title="const 修饰指针"></a>const 修饰指针</h3><ul><li><p>const 修饰指针的三种情况</p><ol><li>常量指针：const 修饰指针</li><li>指针常量：const 修饰常量</li><li>const 即修饰指针，又修饰常量</li></ol></li><li><blockquote><p>技巧：看 const 右侧紧跟着的是指针还是常量，是指针就是常量指针，是常量就是指针常量</p></blockquote></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">int</span> b = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 常量指针：const修饰的是指针，指针的值可以改，指针指向的值不可以更改</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> *p1 = &amp;a;</span><br><span class="line">    p1 = &amp;b;  <span class="comment">// 正确</span></span><br><span class="line">    <span class="comment">// *p1 = 100;  // 报错</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 指针常量：const修饰的是常量，指针的值不可以改，指针指向的值可以更改</span></span><br><span class="line">    <span class="keyword">int</span> *<span class="keyword">const</span> p2 = &amp;a;</span><br><span class="line">    <span class="comment">// p2 = &amp;b;  // 错误</span></span><br><span class="line">    *p2 = <span class="number">100</span>;  <span class="comment">// 正确</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// const既修饰指针又修饰常量</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> *<span class="keyword">const</span> p3 = &amp;a;</span><br><span class="line">    <span class="comment">// p3 = &amp;b;  // 错误</span></span><br><span class="line">    <span class="comment">// *p3 = 100;  // 错误</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="指针和数组"><a href="#指针和数组" class="headerlink" title="指针和数组"></a>指针和数组</h3><ul><li><p>作用：利用指针访问数组中元素</p></li><li><blockquote><p>指向数组的指针，进行 +1 操作，其到底移动多少在于指针的类型（若是 int，则为 4 字节）</p></blockquote></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> arr[] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> *p = arr;  <span class="comment">//指向数组的指针</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;第一个元素： &quot;</span> &lt;&lt; arr[<span class="number">0</span>] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;指针访问第一个元素： &quot;</span> &lt;&lt; *p &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; *p &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        p++;  <span class="comment">// 此处往后移 4 个字节</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="指针和函数"><a href="#指针和函数" class="headerlink" title="指针和函数"></a>指针和函数</h3><ul><li><p>作用：利用指针作函数参数，可以修改实参的值</p></li><li><blockquote><p>如果不想修改实参，就用值传递；如果想修改实参，就用地址传递。</p></blockquote></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//值传递</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap1</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp = a;</span><br><span class="line">    a = b;</span><br><span class="line">    b = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//地址传递</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap2</span><span class="params">(<span class="keyword">int</span> *p1, <span class="keyword">int</span> *p2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp = *p1;</span><br><span class="line">    *p1 = *p2;</span><br><span class="line">    *p2 = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">int</span> b = <span class="number">20</span>;</span><br><span class="line">    </span><br><span class="line">    swap1(a, b); <span class="comment">// 值传递不会改变实参</span></span><br><span class="line">    swap2(&amp;a, &amp;b); <span class="comment">//地址传递会改变实参</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;b = &quot;</span> &lt;&lt; b &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="指针、数组、函数"><a href="#指针、数组、函数" class="headerlink" title="指针、数组、函数"></a>指针、数组、函数</h3><ul><li><p>案例描述：封装一个函数，利用冒泡排序，实现对整型数组的升序排序</p></li><li><blockquote><p>总结：当数组名传入到函数作为参数时，被退化为指向首元素的指针</p></blockquote></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//冒泡排序函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bubbleSort</span><span class="params">(<span class="keyword">int</span> *arr, <span class="keyword">int</span> len)</span> </span>&#123;  <span class="comment">//int * arr 也可以写为int arr[]</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; len - <span class="number">1</span> - i; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[j] &gt; arr[j + <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="keyword">int</span> temp = arr[j];</span><br><span class="line">                arr[j] = arr[j + <span class="number">1</span>];</span><br><span class="line">                arr[j + <span class="number">1</span>] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//打印数组函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printArray</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; arr[i] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> arr[<span class="number">10</span>] = &#123;<span class="number">4</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">9</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">10</span>, <span class="number">8</span>, <span class="number">7</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> len = <span class="keyword">sizeof</span>(arr) / <span class="keyword">sizeof</span>(<span class="keyword">int</span>);</span><br><span class="line"></span><br><span class="line">    bubbleSort(arr, len);</span><br><span class="line">    printArray(arr, len);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h2><h3 id="结构体定义和使用"><a href="#结构体定义和使用" class="headerlink" title="结构体定义和使用"></a>结构体定义和使用</h3><ul><li>语法：<code>struct 结构体名 &#123; 结构体成员列表 &#125;；</code></li><li>通过结构体创建变量的方式有三种：（建议使用前两种）<ol><li>[struct] 结构体名 变量名</li><li>[struct] 结构体名 变量名 = { 成员1值 , … }</li><li>定义结构体时顺便创建变量</li></ol></li><li>利用 <code>.</code> 访问结构体属性</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 结构体定义</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">student</span> &#123;</span></span><br><span class="line">    <span class="built_in">string</span> name;  <span class="comment">// 姓名</span></span><br><span class="line">    <span class="keyword">int</span> age&#123;&#125;;    <span class="comment">// 年龄</span></span><br><span class="line">    <span class="keyword">int</span> score&#123;&#125;;  <span class="comment">// 分数</span></span><br><span class="line">&#125; stu3;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 结构体变量创建方式1</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">student</span> <span class="title">stu1</span>;</span>  <span class="comment">// struct 关键字可以省略</span></span><br><span class="line">    stu1.name = <span class="string">&quot;张三&quot;</span>;</span><br><span class="line">    stu1.age = <span class="number">18</span>;</span><br><span class="line">    stu1.score = <span class="number">100</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;姓名：&quot;</span> &lt;&lt; stu1.name &lt;&lt; <span class="string">&quot; 年龄：&quot;</span> &lt;&lt; stu1.age &lt;&lt; <span class="string">&quot; 分数：&quot;</span> &lt;&lt; stu1.score &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 结构体变量创建方式2</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">student</span> <span class="title">stu2</span> =</span> &#123;<span class="string">&quot;李四&quot;</span>, <span class="number">19</span>, <span class="number">60</span>&#125;;  <span class="comment">// struct 关键字可以省略</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;姓名：&quot;</span> &lt;&lt; stu2.name &lt;&lt; <span class="string">&quot; 年龄：&quot;</span> &lt;&lt; stu2.age &lt;&lt; <span class="string">&quot; 分数：&quot;</span> &lt;&lt; stu2.score &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 结构体变量创建方式3</span></span><br><span class="line">    stu3.name = <span class="string">&quot;王五&quot;</span>;</span><br><span class="line">    stu3.age = <span class="number">18</span>;</span><br><span class="line">    stu3.score = <span class="number">80</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;姓名：&quot;</span> &lt;&lt; stu3.name &lt;&lt; <span class="string">&quot; 年龄：&quot;</span> &lt;&lt; stu3.age &lt;&lt; <span class="string">&quot; 分数：&quot;</span> &lt;&lt; stu3.score &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="结构体数组"><a href="#结构体数组" class="headerlink" title="结构体数组"></a>结构体数组</h3><ul><li><p>作用：将自定义的结构体放入到数组中方便维护</p></li><li><p>语法：<code> struct  结构体名 数组名[元素个数] = &#123;  &#123;&#125; , &#123;&#125; , ... &#123;&#125; &#125;</code></p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 结构体定义</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">student</span> &#123;</span> </span><br><span class="line">    <span class="built_in">string</span> name;  <span class="comment">// 姓名</span></span><br><span class="line">    <span class="keyword">int</span> age&#123;&#125;;    <span class="comment">// 年龄</span></span><br><span class="line">    <span class="keyword">int</span> score&#123;&#125;;  <span class="comment">// 分数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 结构体数组</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">student</span> <span class="title">arr</span>[3] =</span> &#123;&#123;<span class="string">&quot;张三&quot;</span>, <span class="number">18</span>, <span class="number">80</span>&#125;,</span><br><span class="line">                             &#123;<span class="string">&quot;李四&quot;</span>, <span class="number">19</span>, <span class="number">60</span>&#125;,</span><br><span class="line">                             &#123;<span class="string">&quot;王五&quot;</span>, <span class="number">20</span>, <span class="number">70</span>&#125;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp; i : arr) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;姓名：&quot;</span> &lt;&lt; i.name &lt;&lt; <span class="string">&quot; 年龄：&quot;</span> &lt;&lt; i.age &lt;&lt; <span class="string">&quot; 分数：&quot;</span> &lt;&lt; i.score &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="结构体指针"><a href="#结构体指针" class="headerlink" title="结构体指针"></a>结构体指针</h3><ul><li>作用：通过指针访问结构体中的成员</li></ul><ul><li>利用 <code>-&gt; </code> 可以通过结构体指针访问结构体属性</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 结构体定义</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">student</span> &#123;</span> </span><br><span class="line">    <span class="built_in">string</span> name;  <span class="comment">// 姓名</span></span><br><span class="line">    <span class="keyword">int</span> age&#123;&#125;;    <span class="comment">// 年龄</span></span><br><span class="line">    <span class="keyword">int</span> score&#123;&#125;;  <span class="comment">// 分数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">student</span> <span class="title">stu</span> =</span> &#123;<span class="string">&quot;张三&quot;</span>, <span class="number">18</span>, <span class="number">100</span>,&#125;;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">student</span> *<span class="title">p</span> =</span> &amp;stu;</span><br><span class="line"></span><br><span class="line">    p-&gt;name = <span class="string">&quot;张三&quot;</span>; <span class="comment">// 指针通过 -&gt; 操作符可以访问成员</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;姓名：&quot;</span> &lt;&lt; p-&gt;name &lt;&lt; <span class="string">&quot; 年龄：&quot;</span> &lt;&lt; p-&gt;age &lt;&lt; <span class="string">&quot; 分数：&quot;</span> &lt;&lt; p-&gt;score &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="结构体嵌套结构体"><a href="#结构体嵌套结构体" class="headerlink" title="结构体嵌套结构体"></a>结构体嵌套结构体</h3><ul><li>作用： 结构体中的成员可以包含另一个结构体，用来解决实际问题</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 学生结构体定义</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">student</span> &#123;</span></span><br><span class="line">    <span class="built_in">string</span> name;  <span class="comment">// 姓名</span></span><br><span class="line">    <span class="keyword">int</span> age&#123;&#125;;    <span class="comment">// 年龄</span></span><br><span class="line">    <span class="keyword">int</span> score&#123;&#125;;  <span class="comment">// 分数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 教师结构体定义</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">teacher</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> id&#123;&#125;;     <span class="comment">// 职工编号</span></span><br><span class="line">    <span class="built_in">string</span> name;  <span class="comment">// 教师姓名</span></span><br><span class="line">    <span class="keyword">int</span> age&#123;&#125;;    <span class="comment">// 教师年龄</span></span><br><span class="line">    student stu;  <span class="comment">// 子结构体 学生</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    teacher t1;</span><br><span class="line">    t1.id = <span class="number">10000</span>;</span><br><span class="line">    t1.name = <span class="string">&quot;老王&quot;</span>;</span><br><span class="line">    t1.age = <span class="number">40</span>;</span><br><span class="line"></span><br><span class="line">    t1.stu.name = <span class="string">&quot;张三&quot;</span>;</span><br><span class="line">    t1.stu.age = <span class="number">18</span>;</span><br><span class="line">    t1.stu.score = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;教师 职工编号： &quot;</span> &lt;&lt; t1.id &lt;&lt; <span class="string">&quot; 姓名： &quot;</span> &lt;&lt; t1.name &lt;&lt; <span class="string">&quot; 年龄： &quot;</span> &lt;&lt; t1.age &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;辅导学员 姓名： &quot;</span> &lt;&lt; t1.stu.name &lt;&lt; <span class="string">&quot; 年龄：&quot;</span> &lt;&lt; t1.stu.age &lt;&lt; <span class="string">&quot; 考试分数： &quot;</span> &lt;&lt; t1.stu.score &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="结构体做函数参数"><a href="#结构体做函数参数" class="headerlink" title="结构体做函数参数"></a>结构体做函数参数</h3><ul><li><p>作用：将结构体作为参数向函数中传递</p></li><li><p>传递方式有两种：</p><ul><li>值传递</li><li>地址传递</li></ul></li><li><p>如果不想修改主函数中的数据，用值传递，反之用地址传递</p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 学生结构体定义</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">student</span> &#123;</span></span><br><span class="line">    <span class="built_in">string</span> name;    <span class="comment">// 姓名</span></span><br><span class="line">    <span class="keyword">int</span> age&#123;&#125;;      <span class="comment">// 年龄</span></span><br><span class="line">    <span class="keyword">int</span> score&#123;&#125;;    <span class="comment">// 分数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 值传递</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printStudent</span><span class="params">(student stu)</span> </span>&#123;</span><br><span class="line">    stu.age = <span class="number">28</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;子函数中 姓名：&quot;</span> &lt;&lt; stu.name &lt;&lt; <span class="string">&quot; 年龄： &quot;</span> &lt;&lt; stu.age &lt;&lt; <span class="string">&quot; 分数：&quot;</span> &lt;&lt; stu.score &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 地址传递</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printStudent2</span><span class="params">(student *stu)</span> </span>&#123;</span><br><span class="line">    stu-&gt;age = <span class="number">28</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;子函数中 姓名：&quot;</span> &lt;&lt; stu-&gt;name &lt;&lt; <span class="string">&quot; 年龄： &quot;</span> &lt;&lt; stu-&gt;age &lt;&lt; <span class="string">&quot; 分数：&quot;</span> &lt;&lt; stu-&gt;score &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    student stu = &#123;<span class="string">&quot;张三&quot;</span>, <span class="number">18</span>, <span class="number">100</span>&#125;;</span><br><span class="line">    <span class="comment">// 值传递</span></span><br><span class="line">    printStudent(stu);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;主函数中 姓名：&quot;</span> &lt;&lt; stu.name &lt;&lt; <span class="string">&quot; 年龄： &quot;</span> &lt;&lt; stu.age &lt;&lt; <span class="string">&quot; 分数：&quot;</span> &lt;&lt; stu.score &lt;&lt; <span class="built_in">endl</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 地址传递</span></span><br><span class="line">    printStudent2(&amp;stu);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;主函数中 姓名：&quot;</span> &lt;&lt; stu.name &lt;&lt; <span class="string">&quot; 年龄： &quot;</span> &lt;&lt; stu.age &lt;&lt; <span class="string">&quot; 分数：&quot;</span> &lt;&lt; stu.score &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="结构体中使用-const"><a href="#结构体中使用-const" class="headerlink" title="结构体中使用 const"></a>结构体中使用 const</h3><ul><li>作用：用 const 来防止误操作</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 学生结构体定义</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">student</span> &#123;</span></span><br><span class="line">    <span class="built_in">string</span> name;  <span class="comment">// 姓名</span></span><br><span class="line">    <span class="keyword">int</span> age;      <span class="comment">// 年龄</span></span><br><span class="line">    <span class="keyword">int</span> score;    <span class="comment">// 分数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// const使用场景</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printStudent</span><span class="params">(<span class="keyword">const</span> student *stu)</span> </span>&#123;  <span class="comment">// 加const防止函数体中的误操作</span></span><br><span class="line">    <span class="comment">// stu-&gt;age = 100;  // 操作失败，因为加了const修饰</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;姓名：&quot;</span> &lt;&lt; stu-&gt;name &lt;&lt; <span class="string">&quot; 年龄：&quot;</span> &lt;&lt; stu-&gt;age &lt;&lt; <span class="string">&quot; 分数：&quot;</span> &lt;&lt; stu-&gt;score &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    student stu = &#123;<span class="string">&quot;张三&quot;</span>, <span class="number">18</span>, <span class="number">100</span>&#125;;</span><br><span class="line">    printStudent(&amp;stu);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络-完结目录</title>
      <link href="/2021/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E5%AE%8C%E7%BB%93%E7%9B%AE%E5%BD%95/"/>
      <url>/2021/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E5%AE%8C%E7%BB%93%E7%9B%AE%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<h1 id="计算机网络-完结目录"><a href="#计算机网络-完结目录" class="headerlink" title="计算机网络-完结目录"></a>计算机网络-完结目录</h1><p>推荐资源：</p><ol><li>王道配套书</li></ol><p>感觉王道小姐姐讲的并不是很好，建议多看书。</p><table><thead><tr><th align="center"><a href="/2021/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-Part1/">计算机网络-Part1——计算机网络体系结构</a></th></tr></thead><tbody><tr><td align="center"><strong><a href="/2021/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-Part2/">计算机网络-Part2——物理层</a></strong></td></tr><tr><td align="center"><strong><a href="/2021/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-Part3/">计算机网络-Part3——数据链路层</a></strong></td></tr><tr><td align="center"><strong><a href="/2021/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-Part4/">计算机网络-Part4——网络层</a></strong></td></tr><tr><td align="center"><strong><a href="/2021/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-Part5/">计算机网络-Part5——传输层</a></strong></td></tr><tr><td align="center"><strong><a href="/2021/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-Part6/">计算机网络-Part6——应用层</a></strong></td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 408 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络-Part6</title>
      <link href="/2021/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-Part6/"/>
      <url>/2021/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-Part6/</url>
      
        <content type="html"><![CDATA[<h1 id="计算机网络-Part6——应用层"><a href="#计算机网络-Part6——应用层" class="headerlink" title="计算机网络-Part6——应用层"></a>计算机网络-Part6——应用层</h1><p>[TOC]</p><p><img src="/2021/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-Part6/image-20211206204714816.png" alt="image-20211206204714816"></p><h2 id="网络应用模型"><a href="#网络应用模型" class="headerlink" title="网络应用模型"></a>网络应用模型</h2><ul><li>应用层概述<ul><li>应用层对应用程序的通信提供服务。</li></ul></li><li>应用层协议<strong>定义</strong>：<ul><li>应用进程交换的报文类型，请求 or 响应</li><li>各种报文类型的语法，如报文中的各个字段及其详细描述。</li><li>字段的语义，即包含在字段中的信息的含义。</li><li>进程何时、如何发送报文，以及对报文进行响应的规则。</li></ul></li><li>应用层的<strong>功能</strong>：<ul><li>文件传输、访问和管理</li><li>电子邮件</li><li>虚拟终端</li><li>查询服务和远程作业登录</li></ul></li><li>应用层的<strong>重要协议</strong>：<ul><li>FTP</li><li>SMTP、POP3</li><li>HTTP</li><li>DNS</li></ul></li><li>客户/服务器（Client/Server）模型<ul><li>服务器：<strong>提供计算服务</strong>的设备<ul><li>永久提供服务</li><li>永久性访问地址/域名</li></ul></li><li>客户机：<strong>请求计算服务</strong>的主机<ul><li>与服务器通信，使用服务器提供的服务</li><li>间歇性接入网络</li><li>可使用动态 IP 地址</li><li>不与其他客户机直接通信</li></ul></li><li>应用：Web，文件传输 FTP，远程登录，电子邮件</li></ul></li><li>P2P （Peer-to-Peer）模型<ul><li>不存在永远在线的服务器</li><li>每个主机既可以<strong>提供服务</strong>，也可以<strong>请求服务</strong></li><li>任意端系统/节点之间可以<strong>直接通讯</strong></li><li>节点间歇性接入网络</li><li>节点可能改变IP地址</li><li>可扩展性好</li><li>网络健壮性强</li></ul></li></ul><h2 id="DNS-系统"><a href="#DNS-系统" class="headerlink" title="DNS 系统"></a>DNS 系统</h2><ul><li>DNS 服务的作用：将域名解析成 IP 地址。</li><li>域名级别<ul><li>完整写法：<a href="http://www.cskaoyan.com.(最后一个点表示为根,根之前为顶/...%E7%BA%A7%E5%9F%9F%E5%90%8D%EF%BC%89">www.cskaoyan.com.（最后一个点表示为根，根之前为顶/...级域名）</a></li><li>顶级域名<ul><li>国家顶级域名：cn、us、uk</li><li>通用顶级域名：com、net、org、gov、int、aero、museum、travel</li><li>基础结构域名/反向域名：arpa</li></ul></li><li>二级域名<ul><li>类别域名：ac、com、edu、gov、mil、net、org</li><li>行政区域名：bj、js</li></ul></li><li>三级域名</li><li>四级域名</li><li><img src="/2021/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-Part6/image-20211206210944573.png" alt="image-20211206210944573" style="zoom:80%;"></li></ul></li><li>域名服务器<ul><li><img src="/2021/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-Part6/image-20211207090429846.png" alt="image-20211207090429846"></li></ul></li><li>域名解析过程<ul><li>本地域名服务器中设有高速缓存，能够暂存各个服务器及域名的解析 ip。</li><li><img src="/2021/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-Part6/image-20211207091244405.png" alt="image-20211207091244405"></li></ul></li></ul><h2 id="文件传输协议-FTP"><a href="#文件传输协议-FTP" class="headerlink" title="文件传输协议 FTP"></a>文件传输协议 FTP</h2><ul><li>文件传送协议 FTP（File Transfer Protocol）<ul><li>提供不同种类主机系统（硬、软件体系等都可以不同）之间的文件传输能力。</li><li>简单文件传送协议 TFTP（Trivial File Transfer Protocol）</li></ul></li><li>FTP 是基于客户/服务器（C/S）的协议<ul><li>依照 FTP 协议提供服务，进行文件传送的计算机就是 <strong>FTP 服务器</strong>。</li><li>连接 FTP 服务器，遵循 FTP 协议与服务器传送文件的电脑就是 <strong>FTP 客户端</strong>。</li></ul></li><li>工作原理<ul><li>FTP 使用 TCP 实现可靠传输。<ul><li><strong>控制</strong>连接始终保持（会话期间打开）</li><li><strong>数据</strong>连接不会始终保持（文件传输期间打开）</li></ul></li><li>是否使用 TCP 20 端口建立数据连接与传输模式有关<ul><li>主动方式使用 TCP 20 端口 （含端口的 Port 命令）</li><li>被动方式由服务器和客户端自行协商决定，服务器的端口 &gt;1024（Pasvt 命令）</li></ul></li><li><img src="/2021/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-Part6/image-20211207092821036.png" alt="image-20211207092821036" style="zoom:80%;"></li></ul></li><li>传输模式：<ul><li>文本模式：ASCII 模式，以文本序列传输数据；</li><li>二进制模式：Binary 模式，以二进制序列传输数据。</li></ul></li></ul><h2 id="电子邮件"><a href="#电子邮件" class="headerlink" title="电子邮件"></a>电子邮件</h2><p><img src="/2021/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-Part6/image-20211207124939809.png" alt="image-20211207124939809"></p><ul><li><img src="/2021/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-Part6/image-20211207094450303.png" alt="image-20211207094450303"><ul><li>用户代理（Foxmail、Outlook）：1. 撰写；2. 显示；3. 处理；4. 通信</li><li>邮件服务器：1. 发送&amp;接收邮件；2. 向发件人报告邮件传送结果</li></ul></li><li><strong>SMTP</strong>（简单邮件传送协议）<ul><li>SMTP 规定了在两个相互通信的 <strong>SMTP 进程</strong>之间应如何交换信息。<ul><li>负责发送邮件的 SMTP 进程就是 <strong>SMTP 客户</strong>，负责接收邮件的进程就是 <strong>SMTP 服务器</strong>。</li></ul></li><li>TCP 连接、端口号 25、C/S</li><li>SMTP 规定了 14 条命令（几个字母）和 21 种应答信息（三位数字代码+简单文字说明）。（考研不会考察具体细节）<ul><li><img src="/2021/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-Part6/image-20211207122248575.png" alt="image-20211207122248575"></li></ul></li><li>SMTP 的缺点：<ul><li>SMTP 不能传送可执行文件或者其他二进制对象。</li><li>SMTP 仅限于传送 7 位 ASCII 码，不能传送其他非英语国家的文字。</li><li>SMTP 服务器会拒绝超过一定长度的邮件。</li></ul></li></ul></li><li><strong>MIME</strong>（通用因特网邮件扩充）<ul><li>是 SMTP、POP3 的扩充。使传输内容支持声音、图像、视频、多国家语言。</li><li><img src="/2021/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-Part6/image-20211207124117062.png" alt="image-20211207124117062"></li></ul></li><li><strong>POP3</strong>（邮局协议）<ul><li>只存在于查阅邮件的环节</li><li>TCP 连接、端口号 100、C/S</li><li>POP3 对于用户查阅邮件之后的操作<ul><li>下载并保留（在服务器）</li><li>下载并删除</li></ul></li></ul></li><li><strong>IMAP</strong>（网际报文存取协议）<ul><li>IMAP 协议比 POP 协议复杂。</li><li>IMAP 协议与 POP 协议一样处于查阅邮件的部分。</li><li>IMAP 允许只读取邮件中的某一个部分（先看标题正文，有 WiFi 的时候再下载附件）。</li></ul></li><li><strong>基于万维网的电子邮件</strong><ul><li>用户与服务器的交互都转为 HTTP，服务器之间还是 SMTP。</li><li>特点：更方便</li><li><img src="/2021/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-Part6/image-20211207125727764.png" alt="image-20211207125727764"></li></ul></li></ul><h2 id="万维网和-HTTP-协议"><a href="#万维网和-HTTP-协议" class="headerlink" title="万维网和 HTTP 协议"></a>万维网和 HTTP 协议</h2><ul><li><p>万维网概述</p><ul><li>万维网WWW（World Wide Web）是一个大规模的、联机式的信息储藏所/资料空间，是无数个网络站点和网页的集合。</li><li>统一资源定位符 URL 唯一标识资源（文字、视频、音频…）</li><li>URL 一般形式：&lt;协议&gt;://&lt;主机&gt;:&lt;端口&gt;/&lt;路径&gt;</li><li>万维网以客户/服务器方式工作，用户使用的浏览器就是万维网客户程序，万维网文档所驻留的主机运行服务器程序。</li></ul></li><li><p>HTTP 具体过程：</p><ol><li><p>浏览器分析 URL</p></li><li><p>浏览器向 DNS 请求解析 IP 地址</p></li><li><p>DNS 解析出 IP 地址</p></li><li><p>浏览器与服务器建立 TCP 连接</p></li><li><p>浏览器发出取文件命令</p></li><li><p>服务器响应</p></li><li><p>释放 TCP 连接</p></li><li><p>浏览器显示</p></li></ol><ul><li><img src="/2021/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-Part6/image-20211207130752214.png" alt="image-20211207130752214" style="zoom: 50%;"></li></ul></li><li><p>HTTP 协议的特点：</p><ul><li>HTTP 协议是<strong>无状态</strong>的。</li><li>Cookie 是存储在用户主机中的<strong>文本文件</strong>。</li><li>HTTP 采用 <strong>TCP</strong> 作为运输层协议，但 HTTP 协议本身是<strong>无连接</strong>的（通信双方在交换 HTTP 报文之前不需要先建立 HTTP 连接）。</li><li><img src="/2021/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-Part6/image-20211207131011431.png" alt="image-20211207131011431" style="zoom:80%;"></li><li><img src="/2021/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-Part6/image-20211207131105541.png" alt="image-20211207131105541"></li></ul></li><li><p>超文本传输协议 HTTP 报文结构</p><ul><li>HTTP 请求/响应报文是<strong>面向文本</strong>的，因此在报文中的每一个字段都是一些 ASCII 码串。</li><li><img src="/2021/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-Part6/image-20211207140137732.png" alt="image-20211207140137732"></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络-Part5</title>
      <link href="/2021/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-Part5/"/>
      <url>/2021/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-Part5/</url>
      
        <content type="html"><![CDATA[<h1 id="计算机网络-Part5——传输层"><a href="#计算机网络-Part5——传输层" class="headerlink" title="计算机网络-Part5——传输层"></a>计算机网络-Part5——传输层</h1><p>[TOC]</p><h2 id="传输层概述"><a href="#传输层概述" class="headerlink" title="传输层概述"></a>传输层概述</h2><ul><li>只有主机才有的层次</li><li>传输层的功能：<ul><li>传输层提供进程和进程之间的逻辑通信</li><li>复用和分用<ul><li>复用：应用层所有的应用进程都可以通过传输层再传输到网络层。</li><li>分用：传输层从网络层收到数据后交付指明的应用进程。</li></ul></li><li>传输层对收到的报文进行差错检测</li><li>传输层的两种协议</li></ul></li><li>传输层的两个协议：<ul><li>面向连接的传输控制协议 TCP<ul><li>传送数据之前必须建立连接，数据传送结束后要释放连接。</li><li>不提供广播或多播服务。</li><li>由于 TCP 要提供可靠的面向连接的传输服务，因此不可避免增加了许多开销：确认、流量控制、计时器及连接管理等。</li><li>特点：<strong>可靠，面向连接，时延大，适用于大文件</strong>。</li></ul></li><li>无连接的用户数据报协议 UDP<ul><li>传送数据之前不需要建立连接，收到 UDP 报文后也不需要给出任何确认。</li><li>特点：<strong>不可靠，无连接，时延小，适用于小文件</strong>。</li></ul></li></ul></li><li>传输层的寻址与端口<ul><li>端口号<ul><li>端口（逻辑端口/软件端口，区别于硬件端口）是传输层的SAP，标识主机中的应用进程。</li><li>端口号只有本地意义，在因特网中不同计算机的相同端口是没有联系的。</li><li>端口号长度为 16bit，能表示 65536 个不同的端口号。</li><li><img src="/2021/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-Part5/image-20211220143918200.png" alt="image-20211220143918200"></li></ul></li><li>寻址：<ul><li><img src="/2021/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-Part5/image-20211220144448803.png" alt="image-20211220144448803"></li><li>在网络中采用发送方和接收方的套接字组合来识别端点，<strong>套接字</strong>唯一标识了网络中的一个主机和它上面的一个进程。</li><li>套接字 Socket =（主机地址，端口号）</li></ul></li></ul></li></ul><h2 id="UDP-协议"><a href="#UDP-协议" class="headerlink" title="UDP 协议"></a>UDP 协议</h2><ul><li>UDP 只在 IP 数据报服务之上增加了很少功能，即复用分用和差错检测功能。</li><li>UDP的主要特点：<ul><li><strong>无连接</strong>，减少开销和发送数据之前的时延</li><li><strong>不保证可靠交付</strong>，使用最大努力交付</li><li><strong>面向报文</strong>，适合一次性传输少量数据的网络应用</li><li>无拥塞控制，适合很多实时应用</li><li>首部开销小，大小为 8B，TCP 是 20B</li></ul></li><li>应用层给 UDP 多长的报文，UDP 就照样发送，即一次发一个完整报文。<ul><li>使用 UDP 需要选择合适的报文长度。<ul><li>过长会被网络层分片（链路层有 MTU 要求）；</li><li>过短会使 IP 首部相对过大，降低网络层效率（希望尽可能减少负压信息、尽可能多的数据信息）。</li></ul></li><li><img src="/2021/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-Part5/image-20211220144949185.png" alt="image-20211220144949185" style="zoom:80%;"></li></ul></li><li>UDP 首部格式<ul><li>分用时，找不到对应的目的端口号，就丢弃报文，并给发送方发送ICMP“端口不可达”差错报告报文。</li><li><img src="/2021/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-Part5/image-20211220150455794.png" alt="image-20211220150455794" style="zoom:80%;"></li></ul></li><li>UDP 校验<ul><li><img src="/2021/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-Part5/image-20211220150544166.png" alt="image-20211220150544166" style="zoom:80%;"></li><li>使用伪首部检验 UDP 用户数据报<ul><li>伪首部只有在计算检验和时才出现，不向下传送也不向上递交。</li><li>17：<strong>封装 UDP 报文的 IP 数据报首部协议字段是 17</strong>。</li><li>UDP 长度：UDP 首部 8B+ 数据部分长度（不包括伪首部）。</li></ul></li><li>在发送端：<ul><li>填上伪首部</li><li>全 0 填充检验和字段</li><li>全 0 填充数据部分（UDP 数据报要看成许多 4B 的字串接起来）</li><li>伪首部+首部+数据部分采用二进制反码求和</li><li>把和求反码填入检验和字段</li><li>去掉伪首部，发送</li></ul></li><li>在接收端：<ul><li>填上伪首部</li><li>伪首部+首部+数据部分采用二进制反码求和</li><li>结果全为 1 则无差错，否则丢弃数据报/交给应用层附上出差错的警告。</li></ul></li><li><img src="/2021/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-Part5/image-20211220150955461.png" alt="image-20211220150955461" style="zoom:80%;"></li></ul></li></ul><h2 id="TCP-协议"><a href="#TCP-协议" class="headerlink" title="TCP 协议"></a>TCP 协议</h2><h3 id="TCP-协议特点和报文段格式"><a href="#TCP-协议特点和报文段格式" class="headerlink" title="TCP 协议特点和报文段格式"></a>TCP 协议特点和报文段格式</h3><ul><li>特点：<ul><li><strong>面向连接</strong>（虚连接）</li><li><strong>点对点</strong>：每一条 TCP 连接只能有两个端点</li><li><strong>可靠有序，不丢不重</strong>：TCP 提供可靠交付的服务，无差错、不丢失、不重复、按序到达</li><li>提供<strong>全双工通信</strong>：<ul><li>发送缓存：准备发送的数据 &amp; 已发送但尚未收到确认的数据</li><li>接收缓存：按序到达但尚未被接受应用程序读取的数据 &amp; 不按序到达的数据</li></ul></li><li><strong>面向字节流</strong>：把应用程序交下来的数据看成仅仅是一连串的<strong>无结构的字节流</strong></li></ul></li><li><strong>TCP 报文段首部格式</strong>（重点）<ul><li><strong>序号</strong>：在一个 TCP 连接中传送的字节流中的每一个<strong>字节</strong>都按顺序编号，本字段表示本报文段所发送数据的<strong>第一个字节的序号</strong>。</li><li><strong>确认号</strong>：<strong>期望</strong>收到对方下一个报文段的第一个数据字节的序号。若确认号为 N， 则证明到序号 N-1 为止的所有数据都已正确收到。</li><li><strong>数据偏移</strong>（<strong>首部长度</strong>）：TCP 报文段的数据起始处距离 TCP 报文段的起始处有多远，以 4B 位单位，即 1 个数值是 4B。</li><li>控制位：<ul><li><strong>紧急位 URG</strong>：URG=1 时，标明此报文段中有紧急数据，是高优先级的数据，应尽快传送，不用在缓存里排队，配合紧急指针字段使用。</li><li><strong>确认位 ACK</strong>：ACK=1 时，确认号有效，在连接建立后所有传送的报文段都必须把 ACK 置为 1。</li><li>推送位 PSH：PSH=1时，接收方尽快交付接收应用进程，不再等到缓存填满再向上交付。</li><li>复位 RST：RST=1时，表明 TCP 连接中出现严重差错，必须释放连接，然后再重新建立传输链接。</li><li><strong>同步位 SYN</strong>：SYN=1时，表明是一个连接请求/连接接受报文。</li><li><strong>终止位 FIN</strong>：FIN=1时，表明此报文段发送方数据已发完，要求释放连接。</li></ul></li><li><strong>窗口：</strong>指的是发送本报文段的一方的接收窗口大小，即现在允许对方发送的数据量。</li><li><strong>检验和：</strong>检验首部+数据，检验时要加上 12B 伪首部，第四个字段为 6（UDP 是 17）。</li><li><strong>紧急指针：</strong>URG=1 时才有意义，指出本报文段中紧急数据的字节数。</li><li><strong>选项：</strong>最大报文段长度 MSS、窗口扩大、时间戳、选择确认…</li><li><img src="/2021/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-Part5/image-20211220165457244.png" alt="image-20211220165457244" style="zoom:80%;"></li></ul></li></ul><h3 id="TCP-连接管理"><a href="#TCP-连接管理" class="headerlink" title="TCP 连接管理"></a>TCP 连接管理</h3><ul><li>TCP 连接传输三个阶段：连接建立、数据传送、连接释放</li><li>TCP 连接的建立采用<strong>客户服务器方式</strong>，主动发起连接建立的应用进程叫做客户，而被动等待连接建立的应用进程叫服务器。</li><li>过程：（三次握手）<ul><li>客户端发送<strong>连接请求报文段</strong>，无应用层数据。</li><li>服务器端为该 TCP 连接<strong>分配缓存和变量</strong>，并向客户端返回<strong>确认报文段</strong>，允许连接，无应用层数据。</li><li>客户端为该TCP连接<strong>分配缓存和变量</strong>，并向服务器端返回确认的确认，<strong>可以携带数据</strong>。</li><li><img src="/2021/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-Part5/image-20211220172255417.png" alt="image-20211220172255417"></li></ul></li><li>SYN 洪泛攻击：<ul><li>SYN 洪泛攻击，发生在 OSI 第四层，利用 TCP 协议的特性（三次握手）。</li><li>攻击者发送 TCP SYN，SYN 是 TCP 三次握手中的<strong>第一个数据包</strong>，而当服务器返回 ACK 后，该攻击者不对其进行再确认，导致这个 TCP 连接就处于挂起状态，即所谓的半连接状态。</li><li>同时服务器收不到再确认，还会重复发送 ACK 给攻击者，进一步浪费服务器的资源。</li><li>攻击者就对服务器发送非常大量的这种 TCP 连接，由于每一个都没法完成三次握手，所以服务器上，这些TCP连接会因为挂起状态而消耗CPU和内存，最后服务器可能死机，就无法为正常用户提供服务了。</li></ul></li><li>TCP 的连接释放：（四次挥手）<ul><li>客户端发送<strong>连接释放报文段</strong>，停止发送数据，主动关闭 TCP 连接。</li><li>服务器端回送一个确认报文段，客户到服务器这个方向的连接就释放了——半关闭状态。</li><li>服务器端发完数据，就发出连接释放报文段，主动关闭 TCP 连接。</li><li>客户端回送一个确认报文段，再等到时间等待计时器设置的 2MSL（最长报文段寿命）后，连接彻底关闭。</li><li><img src="/2021/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-Part5/image-20211220181742363.png" alt="image-20211220181742363"></li></ul></li></ul><h3 id="TCP-可靠传输（非重点）"><a href="#TCP-可靠传输（非重点）" class="headerlink" title="TCP 可靠传输（非重点）"></a>TCP 可靠传输（非重点）</h3><ul><li>网络层，提供尽最大努力交付、不可靠传输；传输层，使用 TCP 实现可靠传输。<ul><li>可靠：保证接收方进程从缓存区读出的字节流与发送方发出的字节流是完全一样的。</li></ul></li><li>TCP 实现可靠传输的机制<ul><li>校验（与UDP校验一样，<strong>增加伪首部</strong>）</li><li>序号（<strong>序号字段</strong>指的是一个报文段第一个字节的序号，保证传输有序）</li><li>确认（TCP 默认使用累计确认）</li><li>重传（发送方在<strong>重传时间</strong>内<strong>没有收到确认</strong>就要重传已发送的报文段）<ul><li>超时：TCP 采用自适应算法，动态改变重传时间 RTTs（加权平均往返时间）</li><li>冗余 ACK（冗余确认）：每当比期望序号大的失序报文段到达时，发送一个冗余 ACK，指明下一个期待字节的序号。<ul><li>例如，发送方收到 3 个对于报文段 1 的冗余 ACK，则认为 2 报文段丢失并只重传 2 号报文段（<strong>快速重传</strong>）</li></ul></li></ul></li></ul></li></ul><h3 id="TCP-流量控制（重点）"><a href="#TCP-流量控制（重点）" class="headerlink" title="TCP 流量控制（重点）"></a>TCP 流量控制（重点）</h3><ul><li>流量控制：让<strong>发送方慢点</strong>，要让接收方来得及接收。<ul><li>TCP 利用<strong>滑动窗口</strong>机制实现流量控制。</li></ul></li><li>在通信过程中，接收方根据自己<strong>接收缓存的大小</strong>，设置确认报文段的窗口字段，动态通知并调整发送方的发送窗口大小。<ul><li>发送方的发送窗口 = Min { 接收窗口 rwnd，拥塞窗口 cwnd }。</li></ul></li><li>TCP 为每一个连接设有一个持续计时器，只要 TCP 连接的一方收到对方的零窗口通知，就启动持续计时器。<ul><li>若持续计时器设置的时间到期，就发送一个零窗口<strong>探测报文段</strong>。接收方收到探测报文段时给出现在的窗口值。</li><li>若窗口仍然是 0，那么发送方就重新设置持续计时器。</li></ul></li><li><img src="/2021/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-Part5/image-20211220190918520.png" alt="image-20211220190918520"></li></ul><h3 id="TCP-拥塞控制（重点）"><a href="#TCP-拥塞控制（重点）" class="headerlink" title="TCP 拥塞控制（重点）"></a>TCP 拥塞控制（重点）</h3><ul><li>出现拥塞的条件：<ul><li>对资源需求的总和 &gt; 可用资源</li><li>网络中有许多资源同时呈现供应不足 -&gt; 网络性能变坏 -&gt; 网络吞吐量将随输入负荷增大而下降</li></ul></li><li>拥塞控制：<ul><li>防止过多的数据注入到网络中。</li></ul></li><li>拥塞控制与流量控制的区别：<ul><li>流量控制是点对点的控制，拥塞控制是全局性问题</li><li>流量控制是发送过快，拥塞控制是迟迟接收不到</li></ul></li><li>假定：<ul><li>数据单方向传送，而另一个方向只传送确认</li><li>接收方总是有足够大的缓存空间，因而发送窗口大小取决于拥塞程度</li><li>发送窗口 = Min { 接收窗口 rwnd，拥塞窗口 cwnd }<ul><li>接收窗口：<strong>接收方</strong>根据接受缓存设置的值，并告知给发送方，反映接收方容量。</li><li>拥塞窗口：<strong>发送方</strong>根据自己估算的网络拥塞程度而设置的窗口值，反映网络当前容量。</li></ul></li><li>一个<strong>传输轮次</strong>：一个往返时延<strong>RTT</strong>。发送并收到确认。</li></ul></li><li>拥塞控制两种算法<ul><li><strong>慢开始和拥塞避免</strong><ul><li>一收到确认，就提高拥塞窗口数量</li><li>新的门限值 = 网络拥塞时的拥塞窗口 ÷ 2</li><li><img src="/2021/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-Part5/image-20211220194719790.png" alt="image-20211220194719790"></li></ul></li><li><strong>快重传和快恢复</strong><ul><li><strong>收到 3 个重复确认</strong>时，不重新开始，而是降为当前窗口的一半。</li><li><img src="/2021/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-Part5/image-20211220194814988.png" alt="image-20211220194814988"></li></ul></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络-Part4</title>
      <link href="/2021/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-Part4/"/>
      <url>/2021/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-Part4/</url>
      
        <content type="html"><![CDATA[<h1 id="计算机网络-Part4——网络层"><a href="#计算机网络-Part4——网络层" class="headerlink" title="计算机网络-Part4——网络层"></a>计算机网络-Part4——网络层</h1><p>[TOC]</p><h2 id="网络层功能概述"><a href="#网络层功能概述" class="headerlink" title="网络层功能概述"></a>网络层功能概述</h2><h3 id="网络层功能"><a href="#网络层功能" class="headerlink" title="网络层功能"></a>网络层功能</h3><p><img src="/2021/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-Part4/image-20211221134208504.png" alt="image-20211221134208504"></p><ul><li>主要任务是把<strong>分组</strong>从源端传到目的端，为分组交换网上的不同主机提供通信服务。<ul><li>网络层传输单位是<strong>数据报</strong>。</li></ul></li><li>功能：<ul><li>路由选择与分组转发（寻找最佳路径）</li><li>异构网络互联</li><li>拥塞控制<ul><li>开环控制（静态）</li><li>闭环控制（动态）</li></ul></li></ul></li></ul><h3 id="IP-数据报格式"><a href="#IP-数据报格式" class="headerlink" title="IP 数据报格式"></a>IP 数据报格式</h3><ul><li>TCP/IP 协议栈<ul><li><img src="/2021/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-Part4/image-20211221135135704.png" alt="image-20211221135135704" style="zoom: 67%;"></li></ul></li><li>IP 数据报格式<ul><li>版本：IPv4 / IPv6</li><li>首部长度：单位是 <strong>4B</strong>，最小为 5.</li><li>区分服务：指示期望获得哪种类型的服务。</li><li>总长度：首部+数据，单位是<strong>1B</strong>。2^16^-1=65525B</li><li>生存时间（TTL）：IP 分组的保质期。经过一个路由器 -1，变成 0 则丢弃。</li><li>协议：数据部分的协议。TCP=6，UDP=17。</li><li>检验首部和：只检验首部</li><li>源地址和目的地址：32 位。</li><li>可选字段：0~40B，用来支持排错、测量以及安全等措施。</li><li>填充：全 0，把首部补成 4B 的整数倍。</li><li><img src="/2021/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-Part4/image-20211221140112405.png" alt="image-20211221140112405"></li></ul></li></ul><h3 id="IP-数据报分片"><a href="#IP-数据报分片" class="headerlink" title="IP 数据报分片"></a>IP 数据报分片</h3><ul><li>最大传送单元 MTU<ul><li>链路层数据帧可封装数据的上限，超过则在 IP 分组中进行分片，否则无法往下传递。</li><li>以太网的 MTU 是 1500 字节。</li><li><img src="/2021/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-Part4/image-20211221141348483.png" alt="image-20211221141348483" style="zoom:80%;"></li></ul></li><li>IP 数据报格式<ul><li>标识：同一数据报的分片使用同一标识。</li><li>标志：只有2位有意义<ul><li>中间位DF（Don’t Fragment）：<ul><li>DF=1，禁止分片</li><li>DF=0，允许分片</li></ul></li><li>最低位MF （More Fragment） ：<ul><li>MF=1，后面“还有分片”</li><li>MF=0，代表最后一片/没分片</li></ul></li></ul></li><li>片偏移：指出较长分组分片后，某片在原分组中的相对位置。以 <strong>8B</strong> 为单位（所以片偏移的长度是 13bit）。<ul><li>除了最后一个分片，每个分片长度一定是 <strong>8B</strong> 的整数倍。</li></ul></li><li><img src="/2021/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-Part4/image-20211221140112405.png" alt="image-20211221140112405" style="zoom: 67%;"></li></ul></li><li>IP 数据报分片例题<ul><li><img src="/2021/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-Part4/image-20211221142919264.png" alt="image-20211221142919264"></li></ul></li><li>注意单位<ul><li>总长度单位是 1B</li><li>片偏移单位是 8B</li><li>首部长度单位是 4B</li><li>口诀：一种八片首饰（1总8片首4）</li></ul></li></ul><h2 id="IPv4（重要）"><a href="#IPv4（重要）" class="headerlink" title="IPv4（重要）"></a>IPv4（重要）</h2><h3 id="IPv4-地址"><a href="#IPv4-地址" class="headerlink" title="IPv4 地址"></a>IPv4 地址</h3><ul><li><p>IP 编址的历史阶段</p><ul><li>分类的 IP 地址</li><li>子网的划分</li><li>构成超网（无分类编址方案）</li></ul></li><li><p>IP地址：全世界唯一的 <strong>32位/4字节</strong> 标识符，标识路由器主机的接口。</p><ul><li>IP地址::={&lt;网络号&gt;,&lt;主机号&gt;}</li><li>点分十进制</li></ul></li><li><p>互联网中的 IP 地址</p><ul><li>同一个网络中，网络号相同</li><li><img src="/2021/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-Part4/image-20211221144310762.png" alt="image-20211221144310762" style="zoom:80%;"></li></ul></li><li><p>IP 地址分类</p><ul><li>主要熟悉 A、B、C 类</li><li><img src="/2021/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-Part4/image-20211221144405995.png" alt="image-20211221144405995"></li><li><img src="/2021/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-Part4/image-20211221150228337.png" alt="image-20211221150228337"></li></ul></li><li><p>特殊 IP 地址</p><ul><li><img src="/2021/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-Part4/image-20211221145029209.png" alt="image-20211221145029209"></li></ul></li><li><p>私有 IP 地址</p><ul><li>路由器对目的地址是私有IP地址的数据报一律不进行转发。</li><li><img src="/2021/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-Part4/image-20211221145144605.png" alt="image-20211221145144605"></li></ul></li></ul><h3 id="网络地址转换-NAT"><a href="#网络地址转换-NAT" class="headerlink" title="网络地址转换 NAT"></a>网络地址转换 NAT</h3><ul><li>网络地址转换 NAT（Network Address Translation）：<ul><li>在<strong>专用网</strong>连接到<strong>因特网</strong>的路由器上安装 NAT 软件（安装了 NAT 软件的路由器叫 NAT 路由器）</li><li>它至少有一个有效的<strong>外部全球 IP 地址</strong>。</li></ul></li><li><img src="/2021/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-Part4/image-20211221151054767.png" alt="image-20211221151054767"></li></ul><h3 id="子网划分和子网掩码"><a href="#子网划分和子网掩码" class="headerlink" title="子网划分和子网掩码"></a>子网划分和子网掩码</h3><ul><li>针对问题：（分类的 IP 地址）<ul><li>IP 地址空间的利用率有时很低。</li><li>两级 IP 地址不够灵活。</li></ul></li><li>子网划分<ul><li>子网号能否全 0 全 1 要看情况<ul><li>最初不可以</li><li>后续 CIDR 广泛应用就可以了</li></ul></li><li>主机号不能全 0 全 1（0：本机；1：广播）</li><li>某单位划分子网后，对外仍<strong>表现为一个网络</strong>，即本单位外的网络看不见本单位内子网的划分。</li><li><img src="/2021/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-Part4/image-20211221151749123.png" alt="image-20211221151749123"></li><li><img src="/2021/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-Part4/image-20211221154628241.png" alt="image-20211221154628241" style="zoom:80%;"></li></ul></li><li>子网掩码<ul><li><img src="/2021/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-Part4/image-20211221154854041.png" alt="image-20211221154854041" style="zoom:80%;"></li><li>熟记常用的二进制转换，会提高效率<ul><li><img src="/2021/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-Part4/image-20211221155236311.png" alt="image-20211221155236311" style="zoom: 67%;"></li></ul></li></ul></li><li>路由表中：<ul><li>目的网络地址</li><li>目的网络子网掩码</li><li>下一跳地址</li></ul></li><li>路由器转发分组的算法：<ol><li>提取目的 IP 地址</li><li>是否直接交付（目的地址和子网掩码相与，查看是否有对应的子网，否则为间接交付给下一个路由）</li><li>特定主机路由（路由表中特殊指定的 IP 地址）</li><li>检测路由表中有无路径（和路由表中所有的子网掩码相与，类似于第二条？）</li><li>默认路由 0.0.0.0</li><li>丢弃，报告转发分组出错</li></ol></li></ul><h3 id="无分类编址-CIDR（常考）"><a href="#无分类编址-CIDR（常考）" class="headerlink" title="无分类编址 CIDR（常考）"></a>无分类编址 CIDR（常考）</h3><ul><li>针对问题：<ul><li>B 类地址很快将分配完毕</li><li>路由表中的项目急剧增长</li></ul></li><li><strong>无分类域间路由选择 CIDR（Classless Inter-Domain Routing）</strong>：<ul><li>消除了传统的 A、B、C 类地址以及划分子网的概念。<ul><li>将网络号和子网号合并成了网络前缀</li><li>CIDR 记法：IP 地址后加上“/”，并写上网络前缀的位数。</li><li><img src="/2021/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-Part4/image-20211221161620670.png" alt="image-20211221161620670" style="zoom: 67%;"></li></ul></li><li>融合子网地址与子网掩码，方便子网划分。<ul><li>CIDR把<strong>网络前缀都相同</strong>的连续的IP地址组成一个“CIDR 地址块”。</li><li><img src="/2021/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-Part4/image-20211221161800913.png" alt="image-20211221161800913" style="zoom:67%;"></li></ul></li></ul></li><li>构成超网（路由聚合）<ul><li>构成超网：将多个子网聚合成一个较大的子网。</li><li>方法：将网络前缀缩短（所有网络地址取交集）。</li><li>划分子网是少 -&gt; 多 </li><li>构成超网是多 -&gt; 少</li></ul></li><li>最长前缀匹配<ul><li>使用 CIDR 时，查找路由表可能得到几个匹配结果（<strong>跟网络掩码按位相与</strong>），应选择具有最长网络前缀的路由。</li><li><strong>前缀越长，地址块越小，路由越具体</strong>。</li></ul></li></ul><h3 id="ARP-协议"><a href="#ARP-协议" class="headerlink" title="ARP 协议"></a>ARP 协议</h3><ul><li><p>ARP 高速缓存：IP 地址与 MAC 地址的映射</p></li><li><p><strong>发送数据的过程</strong></p><ul><li><img src="/2021/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-Part4/image-20211223135416993.png" alt="image-20211223135416993"></li><li>网关具备 MAC 地址，但交换机不具备。</li><li>网关将解封装到网络层<ul><li>在不进行 NAT 的情况下，将更换数据的源 MAC 和目标 MAC。</li><li>在进行 NAT 的情况下，还将更换数据的源 IP。</li></ul></li><li>主机与主机、主机与网关、网关与网关之间，通过带 IP 的广播，请求目标设备带 IP-MAC 映射的响应，以获得数据链路层所需要的封装信息（目标的物理 MAC 地址）。</li></ul></li><li><p><strong>ARP（Address Resolution Protocol）协议</strong></p></li><li><p>针对问题：在实际网络的链路上传送数据帧时，最终必须使用 MAC 地址。</p></li><li><p>ARP 协议：完成主机或路由器 IP 地址到 MAC 地址的映射。（解决下一跳走哪的问题）</p></li><li><p>使用过程：</p><ul><li><strong>检查 ARP 高速缓存</strong>，有对应表项则写入 MAC 帧。<ul><li>没有则用目的 MAC 地址为 FF-FF-FF-FF-FF-FF 的帧封装并<strong>广播 ARP 请求分组</strong>，同一局域网中所有主机都能收到该请求。</li><li>目的主机收到请求后就会向源主机<strong>单播 ARP 响应分组</strong>，源主机收到后将此映射<strong>写入 ARP 缓存</strong>（10-20min 更新一次）。</li></ul></li></ul></li><li><p>ARP 协议 4 种典型情况：</p><ul><li><p>主机 A 发给<strong>本网络</strong>上的主机 B：用 ARP 找到主机B的硬件地址；</p></li><li><p>主机 A 发给<strong>另一网络</strong>上的主机 B：用 ARP 找到本网络上一个路由器（网关）的硬件地址；</p></li><li><p>路由器发给<strong>本网络</strong>的主机 A：用 ARP 找到主机 A 的硬件地址；</p></li><li><p>路由器发给<strong>另一网络</strong>的主机 B：用 ARP 找到本网络上的一个路由器的硬件地址。</p></li></ul></li><li><p>ARP 协议自动进行。</p></li></ul><h3 id="DHCP-协议"><a href="#DHCP-协议" class="headerlink" title="DHCP 协议"></a>DHCP 协议</h3><ul><li>获得 IP 地址<ul><li>静态配置</li><li>动态配置</li></ul></li><li>DHCP（Dynamic Host Configuration Protocol）协议<ul><li>动态主机配置协议 DHCP 是<strong>应用层协议</strong>，使用<strong>客户/服务器</strong>方式，客户端和服务端通过<strong>广播</strong>方式进行交互，基于 <strong>UDP</strong>。</li><li>DHCP 功能<ul><li>提供<strong>即插即用</strong>联网的机制；</li><li>主机可以从服务器动态获取 IP 地址、子网掩码、默认网关、DNS 服务器名称与 IP 地址；</li><li>允许<strong>地址重用</strong>（IP 地址池）；</li><li>支持<strong>移动用户加入网络</strong>；</li><li>支持<strong>在用地址续租</strong>（IP 地址租用期）。</li></ul></li><li>过程<ul><li>主机广播 DHCP <strong>发现</strong>报文（试图找到网络中的服务器，服务器获得一个IP地址）</li><li>DHCP 服务器广播 DHCP <strong>提供</strong>报文（服务器拟分配给主机一个 IP 地址及相关配置）</li><li>主机广播 DHCP <strong>请求</strong>报文（主机向服务器请求提供 IP 地址）</li><li>DHCP 服务器广播 DHCP <strong>确认</strong>报文（正式将 IP 地址分配给主机）</li></ul></li></ul></li></ul><h3 id="ICMP-协议"><a href="#ICMP-协议" class="headerlink" title="ICMP 协议"></a>ICMP 协议</h3><ul><li>网际控制报文协议 ICMP（Internet Control Message Protocol）是<strong>网络层协议</strong>。<ul><li>差错（或异常）报告：ICMP 查错报文</li><li>网络探询：ICMP 询问报文</li></ul></li><li>ICMP 差错报告报文<ul><li><strong>终点不可达</strong>：当路由器或主机<strong>不能交付数据报时</strong>就向源点发送终点不可达报文。</li><li><del><strong>源点抑制</strong>：当路由器或主机由于<strong>拥塞而丢弃数据报时</strong>，就向源点发送源点抑制报文，使源点知道应当把数据报的发送速率放慢。（不再使用）</del></li><li><strong>时间超过</strong>：<ul><li>当路由器<strong>收到生存时间 TTL=0 的数据报时</strong>，除丢弃该数据报外，还要向源点发送时间超过报文。</li><li>当终点在预先规定的时间内<strong>不能收到一个数据报的全部数据报片时</strong>，就把已收到的数据报片都丢弃，并向源点发送时间超过报文。</li></ul></li><li><strong>参数问题</strong>：当路由器或目的主机收到的<strong>数据报的首部中有的字段的值不正确时</strong>，就丢弃该数据报，并向源点发送参数问题报文。</li><li><strong>改变路由（重定向）</strong>：<strong>路由器把改变路由报文发送给主机</strong>，让主机知道下次应将数据报发送给另外的路由器（可通过更好的路由）。</li><li><img src="/2021/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-Part4/image-20211223150014117.png" alt="image-20211223150014117"></li></ul></li><li>不应发送 ICMP 差错报文的情况<ul><li>对 <strong>ICMP 差错报告报文</strong>不再发送 ICMP 差错报告报文。（IP 数据报不会检查数据部分，即 ICMP 差错报文有无出错）</li><li>对第一个分片的数据报片的所有<strong>后续数据报片</strong>都不发送 ICMP 差错报告报文。</li><li>对具有<strong>组播地址</strong>（一对指定多，区别于广播为一对所有多）的数据报都不发送 ICMP 差错报告报文。</li><li>对具有<strong>特殊地址</strong>（如 127.0.0.0 或 0.0.0.0）的数据报不发送 ICMP 差错报告报文。</li></ul></li><li>ICMP 询问报文<ul><li>回送请求和回答报文<ul><li>主机或路由器向特定目的主机发出的询问，收到此报文的主机必须给源主机或路由器发送 ICMP 回送回答报文。<strong>测试目的站是否可达以及了解其相关状态</strong>。</li></ul></li><li>时间戳请求和回答报文<ul><li>请某个主机或路由器回答当前的日期和时间。<strong>用来进行时钟同步和测量时间</strong>。</li></ul></li><li><del>掩码地址请求和回答报文（不再使用）</del></li><li><del>路由器询问和通告报文（不再使用）</del></li></ul></li><li>ICMP 的应用<ul><li>PING：测试两个主机之间的连通性，使用了 <strong>ICMP 回送请求和回答报文</strong>。</li><li>Traceroute：跟踪一个分组从源点到终点的路径，使用了 <strong>ICMP 时间超过差错报告报文</strong>。</li></ul></li></ul><h2 id="IPv6"><a href="#IPv6" class="headerlink" title="IPv6"></a>IPv6</h2><p><img src="/2021/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-Part4/image-20211223154240704.png" alt="image-20211223154240704"></p><ul><li>针对问题：<ul><li>32 位 IPv4 地址空间已分配殆尽</li><li>CIDR、NAT 只能延缓</li></ul></li><li>改进方向：<ul><li>IPv6 改进首部格式 -&gt; 快速处理/转发数据报、支持 QoS</li></ul></li><li>数据报格式：<ul><li>版本：6</li><li>优先级：区分数据报的类别和<strong>优先级</strong>。</li><li>流标签：互联网络上<strong>从特定源点到特定终点的一系列数据报</strong>。所有属于同一个流的数据报都具有同样的流标签。（区别于 IPv4 的标识位是标识同一组分片的数据报）</li><li>有效载荷长度：标识<strong>有效载荷 [扩展首部+数据] 的长度</strong>（区别于 IPv4 的首部长度 [首部+扩展首部] +总长度 [首部+扩展首部+数据] ）</li><li>下一个首部：标识<strong>下一个扩展首部</strong>（扩展首部可能有多个，每一个扩展首部都会有该字段来标识下一个首部）或<strong>上层协议首部</strong>（即数据部分）。</li><li>跳数限制：相当于 IPv4 的 TTL。</li><li><img src="/2021/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-Part4/image-20211223152037845.png" alt="image-20211223152037845" style="zoom: 80%;"></li></ul></li><li><strong>IPv6 和 IPv4 的区别</strong><ul><li>IPv6 将地址从 32 位（4B）扩大到 <strong>128 位（16B）</strong>，更大的地址空间。</li><li>IPv6 将 IPv4 的<strong>校验和字段彻底移除</strong>，以减少每跳的处理时间。</li><li>IPv6 将 IPv4 的可选字段移出首部，变成了<strong>扩展首部</strong>，成为灵活的首部格式，路由器通常不对扩展首部进行检查，大大提高了路由器的处理效率。</li><li>IPv6 支持<strong>即插即用</strong>（即自动配置），不需要 DHCP 协议。</li><li>IPv6 首部长度必须是 <strong>8B 的整数倍</strong>，IPv4 首部是 4B 的整数倍。</li><li>IPv6 <strong>只能在主机处分片</strong>，IPv4 可以在路由器和主机处分片。</li><li>ICMPv6：附加报文类型“分组过大”。</li><li>IPv6 支持资源的预分配， 支持实时视像等要求，保证一定的带宽和时延的应用。</li><li>IPv6 取消了协议字段，改成下一个首部字段。</li><li>IPv6 取消了总长度字段，改用有效载荷长度字段。</li><li>IPv6 取消了服务类型字段。</li></ul></li><li><strong>IPv6 地址表示形式</strong><ul><li>一般形式：<ul><li>冒号十六进制记法：<ul><li>4BF5:AA12:0216:FEBC:BA5F:039A:BE9A:2170</li></ul></li></ul></li><li>压缩形式：<ul><li>连续的 0 压缩成一个 0：<ul><li>4BF5:0000:0000:0000:BA 5F:039A:000A:2176 -&gt; 4BF5:0:0:0:BA5F:39A:A:2176</li></ul></li><li>零压缩：一连串连续的 0 可以被一对冒号取代（<strong>在一个地址中仅可出现一次</strong>）<ul><li>FF05:0:0:0:0:0:0:B3 -&gt; FF05::B3</li></ul></li></ul></li></ul></li><li>IPv6 基本地址类型<ul><li>单播：一对一通信，可做源地址+目的地址</li><li>多播：一对多通信，可做目的地址</li><li>任播：一对多中的一个通信，可做目的地址</li></ul></li><li>IPv6 向 IPv4 过渡的策略<ul><li>双栈协议<ul><li>指在一台路由器或主机上<strong>同时启用 lPv4 和 IPv6 协议栈</strong>，则既能和 IPv4 网络通信，又能和 IPv6 网络通信。</li></ul></li><li>隧道技术<ul><li>通过使用互联网络的基础设施在网络之间传递数据的方式。使用隧道传递的数据（或负载）可以是不同协议的数据帧或包。</li><li>隧道协议将其它协议（IPv6）的数据帧或包<strong>重新封装</strong>（成 IPv4）然后通过隧道发送。</li></ul></li></ul></li></ul><h2 id="路由算法与路由协议"><a href="#路由算法与路由协议" class="headerlink" title="路由算法与路由协议"></a>路由算法与路由协议</h2><h3 id="路由算法与路由协议概述"><a href="#路由算法与路由协议概述" class="headerlink" title="路由算法与路由协议概述"></a>路由算法与路由协议概述</h3><ul><li>最佳路由：“最佳”只能是相对于某一种特定要求下得出的较为合理的选择而已。</li><li>路由表表项：<ul><li>目的网络 IP 地址 </li><li>子网掩码 </li><li>下一跳 IP 地址 </li><li>接口</li></ul></li><li>路由算法分类<ul><li><strong>静态路由算法</strong>（非自适应路由算法）：管理员手工配置路由信息。<ul><li>优点：简便、可靠，在负荷稳定、拓扑变化不大的网络中运行效果很好，广泛用于高度安全性的军事网络和较小的商业网络。</li><li>缺点：路由更新慢，不适用大型网络。</li></ul></li><li><strong>动态路由算法</strong>（自适应路由算法）：路由器间彼此交换信息，按照路由算法优化出路由表项。<ul><li>优点：路由更新快，适用大型网络，及时响应链路费用或网络拓扑变化。</li><li>缺点：算法复杂，增加网络负担。</li></ul></li></ul></li><li>动态路由算法<ul><li><strong>全局性</strong>：链路状态路由算法（OSPF）<ul><li>所有路由器掌握完整的网络拓扑和链路费用信息。</li></ul></li><li><strong>分散性</strong>：距离向量路由算法（RIP）<ul><li>路由器只掌握物理相连的邻居及链路费用。</li></ul></li></ul></li><li>分层次的路由选择协议<ul><li>针对原因：1. 因特网规模很大，会导致路由表过于庞大；2. 许多单位不想让外界知道自己的路由选择协议，但还想连入因特网。</li><li>自治系统AS：<ul><li>在单一的技术管理下的一组路由器，而这些路由器使用一种AS内部的路由选择协议和共同的度量以确定分组在该AS内的路由，同时还使用一种AS之间的路由协议以确定在AS之间的路由。</li><li>一个AS内的所有网络都属于一个行政单位来管辖，一个自治系统的所有路由器在本自治系统内都必须连通。</li></ul></li><li>路由选择协议：<ul><li>内部网关协议 IGP：一个 AS 内使用（如 RIP、OSPF）</li><li>外部网关协议 EGP：AS 之间使用（如 BGP）</li></ul></li><li><img src="/2021/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-Part4/image-20211223162824830.png" alt="image-20211223162824830"></li></ul></li></ul><h3 id="RIP-协议与距离向量算法"><a href="#RIP-协议与距离向量算法" class="headerlink" title="RIP 协议与距离向量算法"></a>RIP 协议与距离向量算法</h3><p><img src="/2021/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-Part4/image-20211223170633629.png" alt="image-20211223170633629"></p><ul><li><p>RIP（Routing Information Protocol）是一种分布式的基于<strong>距离向量</strong>的路由选择协议，是因特网的协议标准，最大优点是<strong>简单</strong>。</p><ul><li>RIP 协议只适用于<strong>小互联网</strong>。</li></ul></li><li><p>RIP 协议要求网络中每一个路由器都维护<strong>从它自己到其他每一个目的网络的唯一最佳距离记录</strong>（即一组距离）。</p><ul><li>距离：通常为“跳数”，即从源端口到目的端口所经过的路由器个数，经过一个路由器跳数+1。</li><li>特别的，从一路由器到直接连接的网络距离为 1。</li><li>RIP 允许一条路由最多只能包含 15 个路由器，因此距离为 16 表示网络不可达。</li></ul></li><li><p>RIP 特点</p><ul><li>RIP 协议和谁交换？<ul><li>仅和<strong>相邻路由器</strong>交换信息。</li></ul></li><li>多久交换一次？<ul><li>每 <strong>30秒</strong> 交换一次路由信息，然后路由器根据新信息更新路由表。若超过 180s 没收到邻居路由器的通告，则判定邻居没了，并更新自己路由表。</li></ul></li><li>交换什么？<ul><li>路由器交换的信息是<strong>自己的路由表</strong>。</li></ul></li><li>路由器刚开始工作时，只知道直接连接的网络的距离（距离为1），接着每一个路由器也只和数目非常有限的相邻路由器交换并更新路由信息。</li><li>经过若干次更新后，所有路由器最终都会知道到达本自治系统任何一个网络的最短距离和下一跳路由器的地址，即“<strong>收敛</strong>”。</li></ul></li><li><p>RIP 更新</p><ol><li><p>修改相邻路由器发来的RIP报文中<strong>所有表项</strong>：</p><ul><li><p><strong>下一跳字段改为 X</strong>，并且<strong>距离字段 +1</strong>。</p></li><li><p><img src="/2021/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-Part4/image-20211223164554692.png" alt="image-20211223164554692"></p></li></ul></li><li><p>对修改后的 RIP 报文中的每一个项目，进行以下步骤：</p><ul><li>R1 路由表中若没有 Net3，则把该项目填入 R1 路由表</li><li>R1 路由表中若有 Net3，则查看下一跳路由器地址：<ul><li>若下一跳是 X，则用收到的项目替换源路由表中的项目（即更新距离）；</li><li>若下一跳不是 X， 原记录距离比新记录距离远则更新，否则不作处理。</li></ul></li></ul></li><li><p>若 <strong>180s</strong> 还没收到相邻路由器X的更新路由表，则把 X 记为不可达的路由器，即把距离设置为 16。</p></li></ol></li><li><p>RIP 协议的报文格式（了解）</p><ul><li><img src="/2021/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-Part4/image-20211223170035763.png" alt="image-20211223170035763"></li></ul></li><li><p>RIP 协议好消息传得快，坏消息传得慢</p><ul><li><strong>真正的无法到达的消息总会被虚假的可达到消息覆盖</strong>，只有在双方一次次相互传递消息之后才缓慢收敛成无法到达。</li><li><img src="/2021/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-Part4/image-20211223170432089.png" alt="image-20211223170432089"></li></ul></li></ul><h3 id="OSPF-协议与链路状态算法"><a href="#OSPF-协议与链路状态算法" class="headerlink" title="OSPF 协议与链路状态算法"></a>OSPF 协议与链路状态算法</h3><ul><li>OSPF（Open Shortest Path First）开放式最短路径优先<ul><li>“开放”标明 OSPF 协议不是受某一家厂商控制，而是公开发表的；“最短路径优先”是因为使用了 Dijkstra 提出的最短路径算法 SPF。</li><li>OSPF 最主要的特征就是<strong>使用分布式的链路状态协议</strong>。</li></ul></li><li>OSPF 的特点：<ul><li>和谁交换：<ul><li>使用<strong>洪泛法</strong>向自治系统内<strong>所有路由器</strong>发送信息，即路由器向所有相邻的路由器发送信息（广播），而每一个相邻路由器又再次将此信息发往其所有的相邻路由器。</li><li>最终整个区域内所有路由器都得到了这个信息的一个副本。</li></ul></li><li>交换什么：<ul><li>发送的信息就是与本路由器<strong>相邻的所有路由器的链路状态</strong>（与本路由器相邻的路由器，以及对应链路的度量/代价——费用、距离、时延、带宽等）。</li></ul></li><li>多久交换：<ul><li>只有当<strong>链路状态发生变化时</strong>，路由器才向所有路由器洪泛发送此信息。</li></ul></li><li>最后，所有路由器都能建立一个<strong>链路状态数据库</strong>，即<strong>全网拓扑图</strong>。</li></ul></li><li>链路状态路由算法<ul><li>构造网络拓扑<ol><li>每个路由器发现它的邻居结点【问候分组】，并了解邻居节点的网络地址。</li><li>设置到它的每个邻居的成本度量 metric。</li><li>构造【DD 数据库描述分组】，向邻站给出自己的链路状态数据库中的所有链路状态项目的摘要信息。</li><li>如果 DD 分组中的摘要自己都有，则邻站不做处理；如果有没有的或者是更新的，则发送【LSR 链路状态请求分组】 请求自己没有的和比自己更新的信息。</li><li>收到邻站的 LSR 分组后，发送【LSU 链路状态更新分组】进行更新。</li><li>更新完毕后，邻站返回一个【LSAck 链路状态确认分组】进行确认。</li></ol></li><li>若一个路由器的链路状态发生变化：<ol start="5"><li>向邻居泛洪发送【LSU 链路状态更新分组】进行更新。</li><li>更新完毕后，其他站返回一个【LSAck 链路状态确认分组】进行确认。</li><li>使用 Dijkstra 根据自己的链路状态数据库构造到其他节点间的最短路径。</li></ol></li></ul></li><li>OSPF 的区域（了解）<ul><li>为了使 OSPF 能够用于规模很大的网络，OSPF 将一个自治系统再划分为若干个更小的范围，叫做<strong>区域</strong>。</li><li>每一个区域都有一个 32 位的区域标识符（用点分十进制表示）。</li><li>区域也不能太大，在一个区域内的路由器最好不超过 200 个。</li><li><img src="/2021/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-Part4/image-20211224104028583.png" alt="image-20211224104028583"></li></ul></li><li>OSPF 分组<ul><li>OSPF 直接用 IP 数据报传送。（<strong>网络层协议</strong>）</li><li><img src="/2021/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-Part4/image-20211224104144658.png" alt="image-20211224104144658" style="zoom:80%;"></li></ul></li><li>OSPF 其他特点<ul><li>每隔 <strong>30min</strong>，要刷新一次数据库中的链路状态。</li><li>由于一个路由器的链路状态只涉及到与相邻路由器的连通状态，因而与网络的规模并无直接关系。因此当<strong>互联网规模很大</strong>时，OSPF 协议要比距离向量协议 RIP 好得多。</li><li>OSPF 不存在坏消息传的慢的问题，<strong>收敛速度很快</strong>。</li></ul></li></ul><h3 id="BGP-协议"><a href="#BGP-协议" class="headerlink" title="BGP 协议"></a>BGP 协议</h3><ul><li>BGP（Border Gateway Protocol）边界网关协议<ul><li>每个自治系统至少选择一位发言人，通常为边界路由器。</li><li>两个 BGP 发言人通过一个网络连接在一起。</li><li>自治系统连通图是一个树形结构</li><li><img src="/2021/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-Part4/image-20211224104947913.png" alt="image-20211224104947913"></li></ul></li><li>特点：<ul><li>和谁交换<ul><li>与其他 AS 的邻站 BGP 发言人交换信息。</li></ul></li><li>交换什么<ul><li>交换的网络可达性的信息，即要<strong>到达某个网络所要经过的一系列 AS</strong>（<strong>路径向量</strong>）。</li></ul></li><li>多久交换<ul><li>发生变化时更新有变化的部分。</li></ul></li></ul></li><li>BGP 协议报文格式<ul><li>一个 BGP 发言人与其他自治系统中的 BGP 发言人要交换路由信息<ul><li><strong>先建立 TCP 连接</strong>；</li><li>然后在此连接上<strong>交换 BGP 报文以建立 BGP 会话（session）</strong>；</li><li>利用 BGP 会话交换路由信息。</li></ul></li><li>BGP是<strong>应用层</strong>协议，借助<strong>TCP</strong>传送。</li><li><img src="/2021/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-Part4/image-20211224105743360.png" alt="image-20211224105743360"></li></ul></li><li>BGP 协议特点<ul><li>BGP 支持 <strong>CIDR</strong>，因此 BGP 的路由表也就应当包括<strong>目的网络前缀</strong>、<strong>下一跳路由器</strong>，以及<strong>到达该目的网络所要经过的各个自治系统序列</strong>。 </li><li>BGP 启动时，邻站交换整个 BGP 路由表。但以后只需要在<strong>发生变化时更新有变化的部分</strong>。<ul><li>由此，节省网络带宽、减少路由器的处理开销。</li></ul></li></ul></li><li>BGP-4 的四种报文<ul><li><strong>OPEN（打开）报文</strong>：用来与相邻的另一个 BGP 发言人建立关系，并认证发送方。</li><li><strong>UPDATE（更新）报文</strong>：通告新路径或撤销原路径。</li><li><strong>KEEPALIVE（保活）报文</strong>：在无 UPDATE 时，周期性证实邻站的连通性；也作为 OPEN 的确认。</li><li><strong>NOTIFICATION（通知）报文</strong>：报告先前报文的差错；也被用于关闭连接。</li></ul></li><li><strong>三种路由协议比较</strong><ul><li>RIP 是一种分布式的基于距离向量的内部网关路由选择协议，通过广播 UDP 报文来交换路由信息。</li><li>OSPF 是一个内部网关协议，要交换的信息量较大，应使报文的长度尽量短，所以<strong>不使用传输层协议（如 UDP 或 TCP），而是直接采用 IP</strong>。</li><li>BGP 是一个外部网关协议，在不同的自治系统之间交换路由信息，由于网络环境复杂，需要保证可靠传输，所以采用 TCP。</li><li><img src="/2021/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-Part4/image-20211224110705488.png" alt="image-20211224110705488"></li></ul></li></ul><h2 id="IP-组播"><a href="#IP-组播" class="headerlink" title="IP 组播"></a>IP 组播</h2><p><img src="/2021/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-Part4/image-20211224130048760.png" alt="image-20211224130048760"></p><ul><li>IP 数据报的三种传输方式<ul><li>单播：单播用于发送数据包到单个目的地，且每发送一份单播报文都使用一个单播IP地址作为目的地址。是一种<strong>点对点</strong>传输方式。</li><li>广播：广播是指发送数据包到同一广播域或子网内的所有设备的一种数据传输方式，是一种<strong>点对多点</strong>传输方式。</li><li>组播（多播）：当网络中的某些用户需要特定数据时，组播数据发送者仅发送一次数据，借助组播路由协议为组播数据包建立组播分发树，<strong>被传递的数据到达距离用户端尽可能近的节点后才开始复制和分发</strong>，是一种<strong>点对多点</strong>传输方式。</li></ul></li><li>组播地址<ul><li>IP 组播地址让源设备能够将分组发送给一组设备。属于多播组的设备将被分配一个<strong>组播组 IP 地址</strong>（一群共同需求主机的相同标识）。</li><li>组播地址范围为 224.0.0.0～239.255.255.255（D 类地址），一个 D 类地址表示一个组播组。<strong>只能用作分组的目标地址，源地址总是为单播地址</strong>。</li><li>组播数据报也是“尽最大努力交付”，不提供可靠交付，应用于 UDP。</li><li>对组播数据报不产生 ICMP 差错报文。</li><li>并非所有 D 类地址都可以作为组播地址。</li><li><img src="/2021/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-Part4/image-20211224132506030.png" alt="image-20211224132506030"></li></ul></li><li><strong>硬件组播</strong><ul><li>同单播地址一样，组播 IP 地址也需要相应的组播 MAC 地址在本地网络中实际传送帧。</li><li>组播 MAC 地址以十六进制值 01-00-5E 开头，余下的 6 个十六进制位是根据 IP 组播组地址的最后 23 位转换得到。</li><li>TCP/IP 协议使用的以太网多播地址的范围是: <ul><li>从 <strong>01-00-5E-00-00-00</strong> 到 <strong>01-00-5E-7F-FF-FF</strong></li></ul></li><li>收到多播数据报的主机，还要在 IP 层利用软件进行过滤，把不是本主机要接收的数据报丢弃。</li><li><img src="/2021/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-Part4/image-20211224132654866.png" alt="image-20211224132654866"></li></ul></li><li>IGMP 协议与组播路由选择协议<ul><li>网际组管理协议 IGMP<ul><li>IGMP 协议让路由器知道本局域网上<strong>是否有主机（的进程）参加或退出了某个组播组</strong>。</li><li>ICMP 和 IGMP 都使用 <strong>IP 数据报传递报文</strong>。</li><li><img src="/2021/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-Part4/image-20211224133147877.png" alt="image-20211224133147877"></li><li>IGMP 工作的两个阶段<ul><li>某主机要加入组播组时，该主机向组播组的组播地址发送一个 IGMP 报文，声明自己要称为该组的成员。本地组播路由器收到 IGMP 报文后，要利用组播路由选择协议把这组成员关系发给因特网上的其他组播路由器。</li><li>本地组播路由器周期性探询本地局域网上的主机，以便知道这些主机是否还是组播组的成员。只要有一个主机对某个组响应，那么组播路由器就认为这个组是活跃的；如果经过几次探询后没有一个主机响应，组播路由器就认为本网络上的没有此组播组的主机，因此就不再把这组的成员关系发给其他的组播路由器。</li><li>组播路由器知道的成员关系只是所连接的局域网中有无组播组的成员。</li></ul></li></ul></li><li>组播路由选择协议<ul><li>组播路由选择协议目的是找出以源主机为根节点的<strong>组播转发树</strong>。</li><li>对不同的多播组对应于不同的多播转发树；同一个多播组，对不同的源点也会有不同的多播转发树。</li><li>组播路由选择协议常使用的三种算法：<ul><li>基于链路状态的路由选择</li><li>基于距离-向量的路由选择</li><li>协议无关的组播（稀疏/密集）</li></ul></li></ul></li></ul></li></ul><h2 id="移动-IP（不常考）"><a href="#移动-IP（不常考）" class="headerlink" title="移动 IP（不常考）"></a>移动 IP（不常考）</h2><ul><li><p>移动 IP 相关概念</p><ul><li>移动 IP 技术是移动结点（计算机/服务器等）以<strong>固定的网络 IP 地址</strong>，实现跨越不同网段的漫游功能，并保证了基于网络 IP 的网络权限在漫游过程中不发生任何改变。</li><li>移动结点：<ul><li>具有永久IP地址的移动设备。</li></ul></li><li>归属代理（本地代理）：<ul><li>一个移动结点的永久“居所”称为<strong>归属网络</strong>，在归属网络中代表移动节点执行移动管理功能的实体叫做归属代理。（路由器也可以作为归属代理）</li></ul></li><li>永久地址（归属地址/主地址）：<ul><li>移动站点在归属网络中的原始地址。</li></ul></li><li>外部代理（外地代理）：<ul><li>在<strong>外部网络</strong>中帮助移动节点完成移动管理功能的实体称为外部代理。（一个外部网络的路由器）</li></ul></li><li>转交地址（辅地址）：<ul><li>可以是外部代理的地址或动态配置的一个地址</li></ul></li></ul></li><li><p>工作流程：</p><ul><li><p>A 刚进入外部网络：</p><ol><li>获得外部代理的转交地址（外部代理广播报文）。<ul><li>主动获得：主机发布报文以获得转交地址</li><li>被动获得：路由器广播转交地址</li></ul></li><li>移动节点<strong>通过外部代理发送注册报文给归属代理</strong>（包含永久地址 &amp; 转交地址）。</li><li>归属代理接收请求，并<strong>将移动节点的永久地址和转交地址绑定</strong>（以后到达该归属代理的数据报且要发往移动节点的数据报将被封装并以隧道方式发给转交地址），并返回一注册响应报文。</li><li>外部代理接收注册 <strong>A</strong> 响应，并转发给移动节点。</li></ol></li><li><p>A 移动到了下一个网络：</p><ol><li><p>在新外部代理登记注册一个转交地址。</p></li><li><p>新外部代理给本地代理发送新的转交地址（覆盖旧的）。</p></li></ol></li><li><p>A 回到了归属网络：</p><ol><li><p>A 向本地代理注销转交地址。</p></li><li><p>按原始方式通信。</p></li></ol></li></ul></li></ul><h2 id="网络层设备"><a href="#网络层设备" class="headerlink" title="网络层设备"></a>网络层设备</h2><ul><li>路由器<ul><li>路由器，是一种具有多个输入端口和多个输出端口的专用计算机，其任务是<strong>转发分组</strong>。</li><li><img src="/2021/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-Part4/image-20211224113104910.png" alt="image-20211224113104910"></li></ul></li><li>路由选择：<ul><li>根据所选定的路由选择协议<strong>构造出路由表</strong>，同时经常或定期地和相邻路由器交换路由信息而不断地<strong>更新和维护路由表</strong>。</li></ul></li><li>分组转发：<ul><li>交换结构：根据<strong>转发表（路由表得来）</strong>对分组进行<strong>转发</strong>。</li><li>若收到 RIP/OSPF 分组等，则把分组送往路由选择处理机；若收到数据分组，则查找转发表并输出。</li></ul></li><li>输入端口对线路上收到的分组的处理，将交换结构传送来的分组发送到线路<ul><li>输入端口中的查找和转发功能在路由器的交换功能中是最重要的。</li><li>若路由器处理分组的速率赶不上分组进入队列的速率，则队列的存储空间最终必定减少到零，这就使后面再进入队列的分组由于没有存储空间而只能被丢弃。<ul><li><strong>路由器中的输入或输出队列产生溢出是造成分组丢失的重要原因。</strong></li></ul></li><li><img src="/2021/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-Part4/image-20211224113631995.png" alt="image-20211224113631995"></li></ul></li><li><strong>三层设备的区别</strong><ul><li>网络层设备（路由器）：可以互联两个不同网络层协议的网段。</li><li>链路层设备（网桥、交换机）：可以互联两个物理层和链路层不同的网段。</li><li>物理层设备（中继器、集线器）：不能互联两个物理层不同的网段。</li></ul></li><li><strong>路由表与路由转发</strong><ul><li>路由表<ul><li>路由表根据<strong>路由选择算法</strong>得出的，主要用途是路由选择，总用软件来实现。</li></ul></li><li>转发表<ul><li>由<strong>路由表</strong>得来，可以用软件实现，也可以用特殊的硬件来实现。</li><li>转发表必须包含完成转发功能所必需的信息，即从要到达的目的网络到输出端口和某些 MAC 地址信息的映射。</li></ul></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络-Part3</title>
      <link href="/2021/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-Part3/"/>
      <url>/2021/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-Part3/</url>
      
        <content type="html"><![CDATA[<h1 id="计算机网络-Part3——数据链路层"><a href="#计算机网络-Part3——数据链路层" class="headerlink" title="计算机网络-Part3——数据链路层"></a>计算机网络-Part3——数据链路层</h1><p>[TOC]</p><p><img src="/2021/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-Part3/image-20211206141619999.png" alt="image-20211206141619999"></p><h2 id="数据链路层功能概述"><a href="#数据链路层功能概述" class="headerlink" title="数据链路层功能概述"></a>数据链路层功能概述</h2><ul><li>研究思想：只关心同级的数据链路层如何封装与解封装</li><li>基本概念<ul><li>结点：主机、路由器</li><li>链路：网络中两个结点之间的<strong>物理通道</strong>，链路的传输介质主要有双绞线、光纤和微波。分为有线链路、无线链路。</li><li>数据链路：网络中两个结点之间的<strong>逻辑通道</strong>，把实现控制数据传输<strong>协议</strong>的硬件和软件加到链路上就构成数据链路。</li><li>帧：链路层的协议数据单元，封装网络层数据报。</li><li><strong>数据链路层</strong>负责通过一条链路从一个结点向另一个物理链路直接相连的相邻结点传送数据报。</li></ul></li><li>功能概述<ul><li>数据链路层在物理层提供服务的基础上<strong>向网络层提供服务</strong>，其最基本的服务是将源自网络层来的数据可靠地传输到相邻节点的目标机网络层。</li><li>主要作用是<strong>加强物理层传输原始比特流的功能</strong>，将物理层提供的可能出错的物理连接改造成为逻辑上无差错的数据链路，使之对网络层表现为一条无差错的链路。</li><li>功能<ul><li>为网络层提供服务。无确认无连接服务，有确认无连接服务，有确认面向连接服务</li><li>链路管理，即连接的建立、维持、释放（用于面向连接的服务）</li><li>组帧</li><li>流量控制</li><li>差错控制（帧错/位错）</li></ul></li></ul></li></ul><h2 id="封装成帧和透明传输"><a href="#封装成帧和透明传输" class="headerlink" title="封装成帧和透明传输"></a>封装成帧和透明传输</h2><ul><li><strong>封装成帧</strong>是在一段数据上添加首部和尾部，构成一个帧。接收端在收到物理层上的比特流后，就能根据首部和尾部的标记，来识别帧的开始和结束。<ul><li>首部和尾部包含许多的控制信息，只有帧定界符才是实现了<strong>帧定界</strong>。</li><li><strong>帧同步</strong>：<strong>接收方</strong>应当能从接收到的二进制比特流中区分出帧的起始和终止。</li><li><strong>组帧的四种方法</strong>：1. 字符计数法；2. 字符（节）填充法；3. 零比特填充法；4. 违规编码法。</li><li><img src="/2021/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-Part3/image-20211206193517041.png" alt="image-20211206193517041"></li></ul></li><li><strong>透明传输</strong>是指不管所传数据是什么样的比特组合，都应当能够在链路上传送。因此，链路层就“看不见”有什么妨碍数据传输的东西。<ul><li>当所传<strong>数据中的比特组合</strong>恰巧与<strong>某一个控制信息</strong>完全一样时，就必须采取适当的措施，使收方不会将这样的数据误认为是某种控制信息。这样才能保证数据链路层的传输是透明的。</li><li>字符计数法<ul><li>帧首部使用一个计数字段（第一个<strong>字节</strong>，八位）来标明帧内字符数。</li><li>缺点：当首部出错时，后面会跟着出错</li><li><img src="/2021/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-Part3/image-20211206194718116.png" alt="image-20211206194718116" style="zoom:80%;"></li></ul></li><li>字符填充法<ul><li>在控制字符之前增添转义，表示按照数据读取。<ul><li>SOH：Start of header</li><li>EOT：End of transmission</li></ul></li><li><img src="/2021/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-Part3/image-20211206195050505.png" alt="image-20211206195050505" style="zoom:80%;"></li></ul></li><li>零比特填充法<ul><li>流程（5110）<ul><li>在发送端，扫描整个信息字段，只要连续 5 个 1，就立即填入 1 个 0。</li><li>在接收端收到一个帧时，先找到标志字段确定边界，再用硬件对比特流进行扫描。发现连续 5 个 1 时，就把后面的 0 删除。</li></ul></li><li>实现了：在传送的比特流中可以传送任意比特组合，而不会引起对帧边界的判断错误。</li><li><img src="/2021/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-Part3/image-20211206195623869.png" alt="image-20211206195623869" style="zoom:80%;"></li></ul></li><li>违规编码法<ul><li>使用不会用到的编码方式，“高-高”、“低-低”来定界帧的起始和终止。</li><li><img src="/2021/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-Part3/image-20211206195924114.png" alt="image-20211206195924114" style="zoom:80%;"></li></ul></li><li>总结：<ul><li>字节计数法中 Count 字段很脆弱</li><li>字符填充实现上复杂且不兼容</li><li>普遍使用的帧同步法是<strong>比特填充</strong>和<strong>违规编码法</strong>。</li></ul></li></ul></li></ul><h2 id="差错控制"><a href="#差错控制" class="headerlink" title="差错控制"></a>差错控制</h2><ul><li><p>差错的来源（传输中的差错都是由于噪声引起的）</p><ul><li>全局性<ul><li>由于线路本身电气特性所产生的<strong>随机热噪声</strong>，是信道固有的，随机存在的。</li><li>解决办法：提高信噪比来减少或避免干扰。（对传感器下手）</li></ul></li><li>局部性<ul><li>外界特定的短暂原因所造成的<strong>冲击噪声</strong>，是产生差错的主要原因。</li><li>解决办法：通常利用编码技术来解决。</li></ul></li></ul></li><li><p>差错的种类</p><ul><li>位错<ul><li>比特位出错，1 变成 0，0 变成 1。</li></ul></li><li>帧错<ul><li>丢失：收到[#1]-[#3] </li><li>重复：收到[#1]-[#2]-[#2]-[#3]</li><li>失序：收到[#1]-[#3]-[#2]</li></ul></li></ul></li><li><p>分不同的链路选择不同的连接方式</p><ul><li><img src="/2021/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-Part3/image-20211206200547917.png" alt="image-20211206200547917" style="zoom:80%;"></li></ul></li><li><p>数据链路层与物理层的编码意义</p><ul><li>物理层编码针对的是<strong>单个比特</strong>，解决传输过程中<strong>比特的同步</strong>等问题，如曼彻斯特编码。</li><li>数据链路层的编码针对的是<strong>一组比特</strong>，通过冗余码的技术实现对<strong>二进制比特流的跳变问题</strong>。</li></ul></li><li><p>冗余编码</p><ul><li><strong>附加</strong>一定的冗余位，以实现检错、纠错。</li></ul></li></ul><h3 id="检错编码"><a href="#检错编码" class="headerlink" title="检错编码"></a>检错编码</h3><ul><li>奇偶校验码<ul><li>特点：只能检查出<strong>奇数个比特</strong>错误，检错能力为50%。</li><li><img src="/2021/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-Part3/image-20211206201829051.png" alt="image-20211206201829051"></li></ul></li><li>CRC 循环冗余码<ul><li>除数为 r+1 位，生成多项式为 r 阶，FCS 为 r 位。</li><li>在数据链路层 CRC，只能做到对帧的无差错接收，即“凡是接收端数据链路层接受的帧，我们都能以非常接近于 1 的概率认为这些帧在传输过程中没有产生差错”。<ul><li><strong>可靠传输</strong>：数据链路层发送端发送什么，接收端就收到什么。</li><li>CRC，能够实现无比特差错的传输，但这不属于可靠传输。因为，接收端会<strong>丢弃</strong>曾收到但因为有差错被丢弃的帧。</li></ul></li><li><img src="/2021/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-Part3/image-20211206202346800.png" alt="image-20211206202346800"></li><li><img src="/2021/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-Part3/image-20211206204015149.png" alt="image-20211206204015149"></li></ul></li></ul><h3 id="纠错编码"><a href="#纠错编码" class="headerlink" title="纠错编码"></a>纠错编码</h3><ul><li>海明距离<ul><li>两个码字的海明距离（码距）：两个合法编码（码字）的对应比特取值不同的比特数。</li><li>一个编码集的海明距离（码距）：一个有效编码集中，任意两个合法编码（码字）海明距离的最小值。</li><li>将两个字符串异或（同 0 异 1）：码距 = 1 的个数</li></ul></li><li>公式：<ul><li>检测 d 位错，需要 d+1 位码距</li><li>纠正 d 位错，需要 2d+1 位码距</li></ul></li><li>海明校验码算法流程<ul><li>确定校验码位数 r（数据/信息有 m 位，冗余码/校验码有 r 位）<ul><li>校验码一共有 2^r^ 种取值</li><li><strong>2^r^ ≥ m+r+1</strong>（海明不等式）</li><li>凑出合适的 r</li></ul></li><li>确定校验码和数据的位置<ul><li>校验码放在序号为 2^n^ 的位置，数据按序填上</li><li>从右到左，由低到高</li></ul></li><li>求出校验码的值<ul><li><img src="/2021/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-Part3/image-20211207203531042.png" alt="image-20211207203531042" style="zoom: 67%;"></li></ul></li><li>检错并纠错<ul><li>法一：找交并集<ul><li><img src="/2021/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-Part3/image-20211207204157940.png" alt="image-20211207204157940" style="zoom:67%;"></li></ul></li><li>法二：普适法<ul><li><img src="/2021/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-Part3/image-20211207204453806.png" alt="image-20211207204453806" style="zoom:80%;"></li></ul></li></ul></li></ul></li></ul><h2 id="流量控制与可靠传输机制（重要）"><a href="#流量控制与可靠传输机制（重要）" class="headerlink" title="流量控制与可靠传输机制（重要）"></a>流量控制与可靠传输机制（重要）</h2><h3 id="流量控制、可靠传输与滑动窗口机制"><a href="#流量控制、可靠传输与滑动窗口机制" class="headerlink" title="流量控制、可靠传输与滑动窗口机制"></a>流量控制、可靠传输与滑动窗口机制</h3><p><img src="/2021/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-Part3/image-20211207211509126.png" alt="image-20211207211509126"></p><ul><li>针对问题：<strong>较高的发送速度</strong>和<strong>较低的接收能力</strong>的不匹配，会造成<strong>传输出错、资源浪费</strong>，因此流量控制也是数据链路层的一项重要工作。<ul><li>数据链路层的流量控制是点对点的，而传输层的流量控制是端到端的。</li><li><strong>数据链路层</strong>流量控制手段：接收方收不下就不回复确认（不包含数据的确认帧）。</li><li><strong>传输层</strong>流量控制手段：接收端给发送端一个窗口公告（提示可承受的缓冲区容量）。</li></ul></li><li>滑动窗口机制：同时发送和接收窗口的数据，确认后移动窗口<ul><li>停止-等待协议：发送窗口大小=1，接收窗口大小=1；</li><li>后退 N 帧协议：发送窗口大小&gt;1，接收窗口大小=1；</li><li>选择重传协议：发送窗口大小&gt;1，接收窗口大小&gt;1；</li><li>数据链路层的这三种滑动窗口大小在发送过程中是固定值</li><li>传输层的窗口可能不固定</li></ul></li><li>滑动窗口解决<strong>流量控制</strong>（收不下就不给确认，想发也发不了）、<strong>可靠传输</strong>（发送方自动重传）<ul><li>可靠传输：发送端发啥，接收端收啥。</li><li>流量控制：控制发送速率，使接收方有足够的缓冲空间来接收每一个帧。</li></ul></li></ul><h3 id="单帧滑动窗口与停止-等待协议"><a href="#单帧滑动窗口与停止-等待协议" class="headerlink" title="单帧滑动窗口与停止-等待协议"></a>单帧滑动窗口与停止-等待协议</h3><p><img src="/2021/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-Part3/image-20211211134349640.png" alt="image-20211211134349640"></p><ul><li>三个协议在哪一层<ul><li>在以往通信质量不好的时候，数据链路层要承担可靠传输的职责，因此会使用这三种协议</li><li>如今差错不如之前那么大，因此可靠传输的职责可以交由传输层负责，数据链路层主要负责差错控制</li><li>不需要过度在意，属于不同层只是称呼对象不同，传输层为分组、链路层为帧，本质都是传输的数据</li></ul></li><li>为什么要有停止-等待协议<ul><li>为了实现流量控制、解决丢包问题。</li></ul></li><li>研究停等协议的前提<ul><li>虽然现在常用全双工通信方式，但为了讨论问题方便，仅考虑一方发送数据（发送方），一方接收数据（接收方）</li><li>因为是在讨论可靠传输的原理，所以并不考虑数据是在哪一个层次上传送的。</li></ul></li><li>停等协议的无差错情况&amp;有差错情况<ul><li>无差错情况<ul><li>每发送 1 个数据帧就停止并等待，因此用 1bit 来编号足够。</li><li><img src="/2021/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-Part3/image-20211207213049809.png" alt="image-20211207213049809" style="zoom: 50%;"></li></ul></li><li>有差错情况——数据帧丢失或检测到帧出错<ul><li>超时计时器：每次发送一个帧就启动一个计时器。</li><li>超时计时器设置的重传时间应当比帧传输的平均 RTT 更长一些。</li><li>发完一个帧后，必须保留它的副本。（发送方以备重传）</li><li>数据帧和确认帧必须编号。（接受方响应重传）</li><li><img src="/2021/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-Part3/image-20211207213606881.png" alt="image-20211207213606881" style="zoom: 50%;"></li></ul></li><li>有差错情况——有差错情况<ul><li><img src="/2021/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-Part3/image-20211207213642669.png" alt="image-20211207213642669" style="zoom:50%;"></li></ul></li><li>有差错情况——ACK 迟到<ul><li><img src="/2021/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-Part3/image-20211207213733189.png" alt="image-20211207213733189" style="zoom:50%;"></li></ul></li></ul></li><li>停等协议的性能分析<ul><li>简单；信道利用率低</li><li><img src="/2021/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-Part3/image-20211207214234621.png" alt="image-20211207214234621" style="zoom:80%;"></li><li><strong>信道利用率</strong>：<strong>发送方</strong>在一个发送周期内，<strong>有效地发送数据所需要的时间</strong>占整个发送周期的比率。<ul><li><img src="/2021/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-Part3/image-20211207214357171.png" alt="image-20211207214357171" style="zoom: 67%;"></li></ul></li><li>*<em>信道吞吐率 = 信道利用率 * 发送方的发送速率*</em></li><li><img src="/2021/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-Part3/image-20211211134308548.png" alt="image-20211211134308548" style="zoom:80%;"></li></ul></li></ul><h3 id="多帧滑动窗口与后退-N-帧协议（GBN）"><a href="#多帧滑动窗口与后退-N-帧协议（GBN）" class="headerlink" title="多帧滑动窗口与后退 N 帧协议（GBN）"></a>多帧滑动窗口与后退 N 帧协议（GBN）</h3><p><img src="/2021/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-Part3/image-20211211150917861.png" alt="image-20211211150917861"></p><ul><li>针对问题：停等利用率低</li><li>改进方向：流水线技术<ul><li>发送窗口 ：发送方维持一组连续的允许发送的帧的序号。</li><li>接收窗口 ：接收方维持一组连续的允许接收帧的序号。</li></ul></li><li>改进注意：<ul><li>必须增加序号的范围</li><li>发送方需要缓存多个分组</li></ul></li><li>GBN 发送方必须响应的三件事<ul><li>上层（网络层）的调用（要发送数据时）：<ul><li>先检查发送窗口是否已满，如果未满，则产生一个帧并将其发送；</li><li>如果窗口已满，则不接收数据并使上层等待。实际实现中，可以缓存上层的数据，在窗口有空时再发送帧。</li></ul></li><li>收到 ACK：GBN 协议中，对 n 号帧的确认采用<strong>累积确认</strong>的方式，表明接收方已经收到 n 号帧和它之前的全部帧。</li><li>超时事件：协议名为后退/回退 N 帧，来源于出现<strong>丢失和时延过长帧</strong>时发送方的行为：发送方重传<strong>所有一连串已发送但未被确认</strong>的帧。</li></ul></li><li>GBN 接收方要做的事<ul><li>如果<strong>正确且按序</strong>收到 n 号帧，那么接收方为 n 帧发送<strong>一个 ACK</strong>，并将该帧中的数据<strong>交付给上层</strong>。</li><li>若接收的帧不是按序，则<strong>丢弃该帧</strong>并为<strong>最近按序接收的帧发送 ACK</strong>。接收方无需缓存任何失序帧，只需要维护一个信息：ExpectedSeqNum（下一个按序的帧序号）</li></ul></li><li><img src="/2021/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-Part3/image-20211211143229117.png" alt="image-20211211143229117" style="zoom:80%;"></li><li>滑动窗口长度<ul><li>若采用 n 个比特对帧编号，那么发送窗口的尺寸 W<del>T</del> 应满足：1≤ W<del>T</del> ≤ 2^n^-1。</li><li>因为发送窗口尺寸过大，就会使得接收方无法区别新帧（下一个循环）和旧帧（当前循环）。</li></ul></li><li>重点总结：<ul><li>累积确认（偶尔会有接收方发送数据给发送方，此时会在数据中<strong>捎带确认</strong>）</li><li>接收方只按顺序接收帧，不按序则丢弃</li><li>确认序列号最大且按序到达的帧</li><li>发送窗口最大为 2^n^-1，接收窗口大小为 1</li></ul></li><li>GBN 协议性能分析<ul><li>优点：因连续发送数据帧而提高了信道利用率</li><li>缺点：在重传时必须把原来已经正确传送的数据帧重传，是传送效率降低。</li></ul></li></ul><h3 id="多帧滑动窗口与选择重传协议（SR）"><a href="#多帧滑动窗口与选择重传协议（SR）" class="headerlink" title="多帧滑动窗口与选择重传协议（SR）"></a>多帧滑动窗口与选择重传协议（SR）</h3><p><img src="/2021/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-Part3/image-20211211154027330.png" alt="image-20211211154027330"></p><ul><li>针对问题：GBN 累积确认是一个优点，但是出现差错时代价较大。</li><li>改进方向：选择重传协议（Selective Repeat，SR）设置为单个确认，扩大接收窗口，设置接收缓存，缓存乱序到达的帧。<ul><li><img src="/2021/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-Part3/image-20211211151735241.png" alt="image-20211211151735241" style="zoom:80%;"></li></ul></li><li>SR 发送方必须响应的三件事<ul><li>上层的调用：从上层收到数据后，SR 发送方检查下一个可用于该帧的序号，如果序号位于发送窗口内，则发送数据帧；否则，将数据缓存，或者拒绝接收数据并使上层等待。</li><li>收到一个 ACK：<ul><li>如果收到 ACK，加入该帧序号在窗口内，则 SR 发送方将那个被确认的帧标记为已接收。</li><li>如果该帧序号是窗口的下界，则窗口向前移动到具有最小序号的未确认帧处；如果窗口移动并且有序号帧在窗口内未发送，则发送这些帧。</li></ul></li><li>超时事件：每个帧都有自己的定时器，一个超时事件发生后<strong>只重传一个帧</strong>。</li></ul></li><li>SR 接收方要做的事<ul><li>SR 接收方将<strong>确认一个正确接收的帧</strong>而不管其是否按序。失序的帧将被<strong>缓存</strong>，并返回发送方一个该帧的确认帧（<strong>收谁确认谁</strong>）。</li><li>直到序号更小的帧皆被接收为止，才可以将一批帧按序交付给上层，然后<strong>向前移动滑动窗口</strong>。</li><li>如果收到小于窗口下界的帧，就返回一个 ACK</li><li>其他情况，就忽略该帧</li></ul></li><li><img src="/2021/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-Part3/image-20211211152901928.png" alt="image-20211211152901928"></li><li>滑动窗口长度<ul><li>发送窗口最好等于接收窗口。（大了会溢出，小了没意义）、</li><li>W<del>Tmax</del> = W<del>Rmax</del> = 2^n−1^</li><li><img src="/2021/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-Part3/image-20211211153858924.png" alt="image-20211211153858924" style="zoom:67%;"></li></ul></li><li>SR 协议重点总结<ul><li>对数据帧逐一确认。收一个确认一个</li><li>只重传出错帧</li><li>接收方有缓存</li><li>W<del>Tmax</del> = W<del>Rmax</del> = 2^n−1^</li></ul></li></ul><h2 id="介质访问控制（重要）"><a href="#介质访问控制（重要）" class="headerlink" title="介质访问控制（重要）"></a>介质访问控制（重要）</h2><h3 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h3><ul><li>介质访问控制：采取一定的措施，使得两对节点之间的通信不会发生互相干扰的情况。<ul><li><img src="/2021/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-Part3/image-20211212104228185.png" alt="image-20211212104228185"></li></ul></li><li>信道划分介质访问控制（Multiple Access Control，MAC）协议：<ul><li>基于<strong>多路复用</strong>技术划分资源。</li><li>网络负载重：共享信道效率高，且公平</li><li>网络负载轻：共享信道效率低</li></ul></li><li>随机访问MAC协议：（只有这个会产生冲突）<ul><li>用户根据意愿<strong>随机</strong>发送信息，发送信息时可独占信道带宽。</li><li>网络负载重：产生冲突开销</li><li>网络负载轻：共享信道效率高，单个结点可利用信道全部带宽</li></ul></li><li>轮询访问MAC协议/轮流协议/轮转访问MAC协议：<ul><li>既要<strong>不产生冲突</strong>，又要发送时<strong>占全部带宽</strong>。<ul><li>轮询协议</li><li>令牌传递协议</li></ul></li></ul></li></ul><h3 id="信道划分介质访问控制"><a href="#信道划分介质访问控制" class="headerlink" title="信道划分介质访问控制"></a>信道划分介质访问控制</h3><ul><li>传输数据使用的两种链路<ul><li>点对点链路：两个相邻节点通过一个链路相连，没有第三者。应用：PPP 协议，常用于<strong>广域网</strong>。</li><li>广播式链路：所有主机共享通信介质。应用：早期的总线以太网、无线局域网，常用于<strong>局域网</strong>。</li></ul></li><li>信道划分介质访问控制：将使用介质的每个设备与来自同一信道上的其他设备的通信隔离开，把时域和频域资源合理地分配给网络上的设备。<ul><li>多路复用技术：<ul><li>把多个信号组合在一条物理信道上进行传输，使得多个计算机或终端设备共享信道资源,提高信道利用率。</li><li>把一条广播信道，逻辑上分成几条用于两个节点之间通信的互不干扰的子信道，实际就是把广播信道转变为点对点信道。</li><li><img src="/2021/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-Part3/image-20211211155217508.png" alt="image-20211211155217508" style="zoom:67%;"></li></ul></li><li><strong>频分复用技术 FDM</strong>：<ul><li>用户在分配到一定的频带后，在通信过程中自始至终都占用这个频带。频分复用的所有用户在同样的时间占用不同的带宽（频率带宽）资源。</li><li>优点：充分利用传输介质带宽，系统效率较高;由于技术比较成熟，实现也比较容易。</li><li><img src="/2021/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-Part3/image-20211211155523995.png" alt="image-20211211155523995" style="zoom:50%;"></li></ul></li><li><strong>时分多路复用 TDM</strong>：<ul><li>将时间划分为一段段等长的时分复用帧（TDM帧）。每一个时分复用的用户在每一个TDM帧中占用固定序号的时隙，所有用户轮流占用信道。</li><li>TDM 帧是在物理层传送的比特流所划分的帧，标志一个周期。</li><li><img src="/2021/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-Part3/image-20211211155553965.png" alt="image-20211211155553965" style="zoom:50%;"></li><li>改进的时分复用——统计时分复用 STDM：<ul><li>每一个STDM帧中的时隙数小于连接在集中器上的用户数。各用户有了数据就随时发往集中器的输入缓存，然后集中器按顺序依次扫描输入缓存，把缓存中的输入数据放入STDM帧中，一个STDM帧满了就发出。STDM帧不是固定分配时隙，而是按需动态分配时隙。</li><li><img src="/2021/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-Part3/image-20211211160122515.png" alt="image-20211211160122515" style="zoom: 67%;"></li></ul></li></ul></li><li><strong>波分多路复用 WDM</strong>：<ul><li>波分多路复用就是光的频分多路复用，在一根光纤中传输多种不同波长（频率）的光信号，由于波长（频率)不同，所以各路光信号互不干扰，最后再用波长分解复用器将各路波长分解出来。</li><li><img src="/2021/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-Part3/image-20211211160309680.png" alt="image-20211211160309680" style="zoom:50%;"></li></ul></li><li><strong>码分多路复用 CDM</strong>：<ul><li>码分多址（CDMA）是码分复用的一种方式。<ul><li>发送 1bit 的时间称为 <strong>1bit 的时隙时间</strong>。把 1bit 的时间<strong>分割为 n 位的芯片序列</strong>（可以看做是向量），即 <strong>n 个微时隙</strong>，每一个站点被指定一个唯一的 n 位的芯片序列。</li><li>站点在，发送 1 时即<strong>直接发送芯片序列</strong>（通常把 0 写成 -1），发送 0 时即<strong>发送芯片序列的反码</strong>。</li></ul></li><li>流程：<ul><li>多个站点同时发送数据的时候，要求各个站点<strong>芯片序列相互正交</strong>，<strong>规格化内积为 0</strong>。<ul><li><img src="/2021/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-Part3/image-20211212103543665.png" alt="image-20211212103543665" style="zoom:67%;"></li></ul></li><li>两个向量到了公共信道上，线性相加。<ul><li><img src="/2021/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-Part3/image-20211212103701770.png" alt="image-20211212103701770" style="zoom:67%;"></li></ul></li><li>数据分离：合并的数据和源站规格化内积。<ul><li><img src="/2021/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-Part3/image-20211212103732713.png" alt="image-20211212103732713" style="zoom:67%;"></li></ul></li></ul></li></ul></li></ul></li></ul><h3 id="随机访问介质访问控制"><a href="#随机访问介质访问控制" class="headerlink" title="随机访问介质访问控制"></a>随机访问介质访问控制</h3><h4 id="ALOHA-协议"><a href="#ALOHA-协议" class="headerlink" title="ALOHA 协议"></a>ALOHA 协议</h4><ul><li>纯 ALOHA 协议<ul><li>思想：不监听信道，不按时间槽发送，随机重发。</li><li>检测冲突：如果发生冲突，接收方在就会检测出差错，然后不予确认，发送方在一定时间内收不到就判断发生冲突。</li><li>解决冲突：超时后等一随机时间再重传。</li><li><img src="/2021/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-Part3/image-20211212104905851.png" alt="image-20211212104905851" style="zoom:67%;"></li></ul></li><li>时隙 ALOHA 协议<ul><li>思想：把时间分成若干个相同的时间片，所有用户在时间片开始时刻同步接入网络信道，若发生冲突，则必须等到下一个时间片开始时刻再发送。</li><li><img src="/2021/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-Part3/image-20211212104934017.png" alt="image-20211212104934017" style="zoom:67%;"></li></ul></li><li>区别：（不是很重点）<ul><li>纯 ALOHA 比时隙 ALOHA <strong>吞吐量更低，效率更低</strong>。</li><li>纯 ALOHA <strong>想发就发</strong>，时隙 ALOHA <strong>只有在时间片段开始时才能发</strong>。</li></ul></li></ul><h4 id="CSMA-协议"><a href="#CSMA-协议" class="headerlink" title="CSMA 协议"></a>CSMA 协议</h4><ul><li><p>载波监听多路访问协议 CSMA（carrier sense multiple access）</p><ul><li><strong>CS</strong>：载波侦听/监听，每一个站在发送数据之前要检测一下总线上是否有其他计算机在发送数据。</li><li><strong>MA</strong>：多点接入，表示许多计算机以多点接入的方式连接在一根总线上。</li><li><strong>协议思想：</strong>发送帧之前，<strong>监听</strong>信道。</li><li>监听结果：<ul><li>信道空闲 ：发送完整帧</li><li>信道忙 ：推迟发送</li></ul></li><li>行为分类：<ul><li>1-坚持CSMA</li><li>非坚持CSMA</li><li>p-坚持CSMA</li></ul></li></ul></li><li><p>1-坚持CSMA</p><ul><li>坚持指的是对于监听信道<strong>忙</strong>之后的坚持。</li><li>思想：如果一个主机要发送消息，那么它先监听信道。<ul><li><strong>空闲则直接传输，不必等待。</strong></li><li><strong>忙则一直监听，直到空闲马上传输。</strong></li><li>如果有冲突（一段时间内未收到肯定回复），则等待一个随机长的时间再监听，重复上述过程。</li></ul></li><li>优点：只要媒体空闲，站点就马上发送，避免了媒体利用率的损失。 </li><li>缺点：假如有两个或两个以上的站点有数据要发送，冲突就不可避免。</li></ul></li><li><p>非坚持CSMA</p><ul><li><p>非坚持指的是对于监听信道<strong>忙</strong>之后就不继续监听。</p></li><li><p>思想：如果一个主机要发送消息，那么它先监听信道。</p><ul><li><p><strong>空闲则直接传输，不必等待。</strong></p></li><li><p><strong>忙则等待一个随机的时间之后再进行监听。</strong></p></li></ul></li><li><p>优点：采用随机的重发延迟时间可以减少冲突发生的可能性。</p></li><li><p>缺点：可能存在大家都在延迟等待过程中，使得媒体仍可能处于空闲状态，媒体使用率降低。</p></li></ul></li><li><p>p-坚持CSMA</p><ul><li>p-坚持指的是对于监听信道<strong>空闲</strong>的处理。 </li><li>思想：如果一个主机要发送消息，那么它先监听信道。<ul><li><strong>空闲则以 p 概率直接传输，不必等待；概率 1-p 等待到下一个时间槽再传输。</strong></li><li><strong>忙则持续监听直到信道空闲再以 p 概率发送。</strong></li><li>若冲突则等到下一个时间槽开始再监听并重复上述过程。</li></ul></li><li>优点：既能像非坚持算法那样减少冲突，又能像1-坚持算法那样减少媒体空闲时间的这种方案。</li></ul></li><li><p>三者共同缺点：发生冲突后还是要坚持把数据帧发送完，造成了浪费。</p></li><li><p><img src="/2021/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-Part3/image-20211212110506181.png" alt="image-20211212110506181"></p></li></ul><h4 id="CSMA-CD-协议（非常重点）"><a href="#CSMA-CD-协议（非常重点）" class="headerlink" title="CSMA/CD 协议（非常重点）"></a>CSMA/CD 协议（非常重点）</h4><p><img src="/2021/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-Part3/image-20211215185127687.png" alt="image-20211215185127687"></p><ul><li>载波监听多点接入/碰撞检测，CSMA/CD（carrier sense multiple access with collision detection）<ul><li><strong>CS</strong>：载波侦听/监听，每一个站在<strong>发送数据之前</strong>以及<strong>发送数据时</strong>都要检测一下总线上是否有其他计算机在发送数据。</li><li><strong>MA</strong>：多点接入，表示许多计算机以多点接入的方式连接在一根总线上。</li><li><strong>CD</strong>：碰撞/冲突检测，“<strong>边发送边监听</strong>”，适配器边发送数据边检测信道上信号电压的变化情况，以便判断自己在发送数据时其他站是否也在发送数据。</li></ul></li><li><strong>传播时延对载波监听的影响</strong><ul><li>检测碰撞的时间：0~1τ</li><li><img src="/2021/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-Part3/image-20211212111810053.png" alt="image-20211212111810053" style="zoom:80%;"></li></ul></li><li><strong>确定碰撞后的重传时机</strong>(截断二进制指数规避算法)<ol><li>确定基本退避（推迟）时间为争用期 2τ。</li><li>定义参数 k，使得 **k=min[重传次数，10]**。</li><li>从离散的整数集合 <strong>[0, 1, … , 2k-1]</strong> 中随机取出一个数 r，重传所需要退避的时间就是 r 倍的基本退避时间，即 <strong>2r*τ</strong> 。</li><li>当重传达 <strong>16</strong> 次仍不能成功时，说明网络太拥挤，认为此帧永远无法正确发出，抛弃此帧并向高层报告出错。</li></ol></li><li><strong>最小帧长问题</strong><ul><li><strong>帧的传输时延至少要两倍于信号在总线中的传播时延</strong>。</li><li><img src="/2021/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-Part3/image-20211215184828238.png" alt="image-20211215184828238" style="zoom:80%;"></li><li>以太网规定最短帧长为 64B，凡是长度小于 64B 的都是由于冲突而异常终止的无效帧。</li></ul></li></ul><h4 id="CSMA-CA-协议（非重点）"><a href="#CSMA-CA-协议（非重点）" class="headerlink" title="CSMA/CA 协议（非重点）"></a>CSMA/CA 协议（非重点）</h4><ul><li>载波监听多点接入/碰撞避免，CSMA/CA（carrier sense multiple access with collision avoidance）</li><li>针对问题：CSMA/CD 无法应用于无线局域网<ul><li>无法做到 360° 全面检测碰撞</li><li>隐蔽站：当 A 和 C 都检测不到信号，认为信道空闲，从而导致同时向终端B发送数据帧，导致冲突</li></ul></li><li>工作原理<ol><li>发送数据前，先检测信道是否空闲。</li><li>空闲则发出 <strong>RTS（request to send）</strong>，包括发射端的地址、接收端的地址、下一份数据将持续发送的时间等信息；信道忙则等待。（可选步骤）</li><li>接收端收到 RTS 后，将响应 <strong>CTS（clear to send）</strong>。（可选步骤）</li><li>发送端收到 CTS 后，才开始发送数据帧（同时<strong>预约信道</strong>：发送方告知其他站点自己要传多久数据）。</li><li>接收端收到数据帧后，将用 CRC 来检验数据是否正确，正确则<strong>响应 ACK 帧</strong>。</li><li>发送方收到 ACK 就可以进行下一个数据帧的发送，若没有则一直重传至规定重发次数为止（采用<strong>二进制指数退避算法</strong>来确定随机的推迟时间）。</li></ol></li><li>CSMA/CD 与 CSMA/CA<ul><li><strong>相同点：</strong><ul><li>都从属于 CSMA 的思路，其核心是<strong>先听再说</strong>。</li><li>二者出现冲突后都会进行有上限的重传。</li></ul></li><li><strong>不同点：</strong><ul><li><strong>传输介质/应用场景不同</strong>：CSMA/CD 用于总线式以太网（有线网络），CSMA/CA 用于无线局域网（无线网络）。 </li><li>因传输介质不同，而<strong>载波检测方式不同</strong>：CSMA/CD 通过电缆中电压的变化来检测；CSMA/CA 采用能量检测（ED）、载波检测（CS）和能量载波混合检测。</li><li>核心目的：CSMA/CD 检测冲突，CSMA/CA 避免冲突。</li></ul></li></ul></li></ul><h3 id="轮询访问介质访问控制（存在重点）"><a href="#轮询访问介质访问控制（存在重点）" class="headerlink" title="轮询访问介质访问控制（存在重点）"></a>轮询访问介质访问控制（存在重点）</h3><ul><li><p>轮询协议</p><ul><li>主结点轮流询问从属结点发送数据。<ul><li><img src="/2021/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-Part3/image-20211215192553168.png" alt="image-20211215192553168" style="zoom:50%;"></li></ul></li><li>存在问题：1. 轮询开销；2.等待延迟；3.单点（主机）故障。</li></ul></li><li><p>令牌传递协议（重点）</p><ul><li>令牌：一个特殊格式的MAC控制帧，不含任何信息。<ul><li>控制信道的使用，确保同一时刻只有一个结点独占信道。</li><li>每个结点都可以在一定的时间内（令牌持有时间）获得发送数据的权利，并不是无限制地持有令牌。</li><li><img src="/2021/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-Part3/image-20211215192850642.png" alt="image-20211215192850642" style="zoom:67%;"></li><li>逻辑上为环形，物理上为星型</li></ul></li><li>问题：<ul><li>与轮询协议相同：1. 令牌开销；2. 等待延迟；3. 单点故障。</li><li>应用于令牌环网（物理星型拓扑，逻辑环形拓扑）。</li><li>采用令牌传送方式的网络常用于<strong>负载较重、通信量较大</strong>的网络中。</li></ul></li></ul></li></ul><h2 id="局域网"><a href="#局域网" class="headerlink" title="局域网"></a>局域网</h2><h3 id="局域网基本概念和体系结构"><a href="#局域网基本概念和体系结构" class="headerlink" title="局域网基本概念和体系结构"></a>局域网基本概念和体系结构</h3><p><img src="/2021/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-Part3/image-20211218213256062.png" alt="image-20211218213256062"></p><ul><li>局域网（Local Area Network）：简称 LAN，是指在<strong>某一区域内</strong>由多台计算机互联成的计算机组，使用<strong>广播信道</strong>（而不是点对点信道）。</li><li>特点：<ul><li>覆盖的地理范围较小，只在一个相对独立的局部范围内联，如一座或集中的建筑群内。</li><li>使用专门铺设的传输介质（双绞线、同轴电缆）进行联网，数据传输速率高（10Mb/s～10Gb/s）。</li><li>通信延迟时间短，误码率低，可靠性较高。</li><li>各站为平等关系，共享传输信道。</li><li>多采用分布式控制和广播式通信，能进行广播和组播。</li></ul></li><li>决定局域网的主要要素为：网络拓扑，传输介质与介质访问控制方法。</li><li><strong>局域网拓扑结构</strong><ul><li><img src="/2021/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-Part3/image-20211215194700897.png" alt="image-20211215194700897"></li></ul></li><li><strong>局域网传输介质</strong><ul><li>有线局域网：双绞线、同轴电缆、光纤</li><li>无线局域网：电磁波</li></ul></li><li><strong>局域网介质访问控制方法</strong><ul><li>CSMA/CD：常用于<strong>总线型局域网</strong>，也用于树型网络（基本不会考树形）</li><li>令牌总线：常用于<strong>总线型局域网</strong>，也用于树型网络</li><li>令牌环 ：用于<strong>环形局域网</strong>，如令牌环网</li></ul></li><li><strong>局域网的分类</strong><ul><li>以太网：以太网是应用最为广泛的局域网，包括标准以太网（10Mbps）、快速以太网（100Mbps）、千兆以太网（1000 Mbps）和10G以太网，它们都符合 IEEE802.3 系列标准规范。逻辑拓扑总线型，物理拓扑是星型或拓展星型。使用 CSMA/CD。</li><li>令牌环网：物理上采用了星形拓扑结构，逻辑上是环形拓扑结构。已弃用。</li><li>FDDI 网（Fiber Distributed Data Interface）：物理上采用了双环拓扑结构，逻辑上是环形拓扑结构。 （不需要记）</li><li>ATM 网（Asynchronous Transfer Mode）：较新型的单元交换技术，使用 53 字节固定长度的单元进行交换。</li><li>无限局域网（Wireless Local Area Network，WLAN）：采用 IEEE 802.11 标准。</li></ul></li><li>IEEE 802 标准<ul><li>IEEE 802 系列标准是 IEEE 802 LAN/MAN 标准委员会制定的局域网、城域网技术标准（1980年2月成立）。</li><li>其中最广泛使用的有以太网（802.3）、令牌环（802.5）、无线局域网（802.11）、光纤 FDDI（802.8）等。</li></ul></li><li>MAC 子层和 LLC 子层<ul><li>IEEE 802标准所描述的局域网参考模型只对应 OSI 参考模型的数据链路层与物理层，它将数据链路层划分为逻辑链路层 LLC 子层和介质访问控制 MAC 子层。</li><li>LLC 子层：<ul><li>LLC 负责识别网络层协议，然后对它们进行封装。</li><li>LLC 报头告诉数据链路层一旦帧被接收到时，应当对数据包做何处理。</li><li>为网络层提供服务：<strong>无确认无连接、面向连接、带确认无连接、高速传送</strong>。</li></ul></li><li>MAC 子层：<ul><li>MAC子层的主要功能包括数据<strong>帧的封装/卸装、帧的寻址和识别、帧的接收与发送、链路的管理、帧的差错控制</strong>等。</li><li>MAC子层的存在屏蔽了不同物理链路种类的差异性。</li></ul></li><li><img src="/2021/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-Part3/image-20211218212652373.png" alt="image-20211218212652373"></li></ul></li></ul><h3 id="以太网"><a href="#以太网" class="headerlink" title="以太网"></a>以太网</h3><p><img src="/2021/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-Part3/image-20211219173818591.png" alt="image-20211219173818591"></p><ul><li>以太网概述<ul><li>以太网（Ethernet）是由 Xerox 公司创建并由 Xerox、Intel、DEC 公司联合开发的<strong>基带总线局域网规范</strong>，是当今现有局域网采用的最通用的通信协议标准。</li><li>以太网络使用 <strong>CSMA/CD</strong>（载波监听多路访问及冲突检测）技术。</li></ul></li><li>以太网在局域网各种技术中占<strong>统治性</strong>地位：<ul><li>造价低廉（以太网网卡不到100块）；</li><li>是应用最广泛的局域网技术；</li><li>比令牌环网、ATM 网便宜，简单；</li><li>满足网络速率要求：10Mb/s~10Gb/s.</li></ul></li><li>以太网两个标准<ul><li>DIX Ethernet V2（以太网）：第一个局域网产品规约。</li><li>IEEE 802.3（802.3 局域网）：IEEE 802 委员会 802.3 工作组制定的第一个 IEEE 的以太网标准。（帧格式有细小的改动）</li></ul></li><li>以太网提供无连接、不可靠的服务<ul><li>无连接：发送方和接收方之间无“握手过程”。</li><li>不可靠：不对发送方的数据帧<strong>编号</strong>，接收方不向发送方进行<strong>确认</strong>，差错帧直接丢弃，差错纠正由高层负责。</li><li><strong>以太网只实现无差错接收，不实现可靠传输</strong>。</li></ul></li><li>以太网传输介质与拓扑结构的发展<ul><li>介质：粗同轴电缆 -&gt; 细同轴电缆 -&gt; 双绞线+集线器</li><li>物理拓扑：总线型 -&gt; 总线型 -&gt; 星型</li><li>逻辑上总线型，物理上星型。使用的还是 CSMA/CD 协议。</li></ul></li><li><strong>10BASE-T 以太网</strong>（常考！）<ul><li>10BASE-T 是传送<strong>基带信号</strong>的双绞线以太网，T 表示采用双绞线，现 10BASE-T 采用的是<strong>无屏蔽双绞线</strong>（UTP），传输速率是 <strong>10Mb/s</strong>。</li><li><strong>物理上星型拓扑，逻辑上总线型</strong>，每段双绞线最长为 <strong>100m</strong>。 </li><li>采用<strong>曼彻斯特编码</strong>。</li><li>采用 <strong>CSMA/CD 介质访问控制</strong>。 </li></ul></li><li>适配器与 MAC 地址<ul><li>计算机与外界有局域网的连接是通过<strong>通信适配器</strong>的。<ul><li>网络接口卡：NIC（Network Interface Card）</li><li>适配器上装有处理器和存储器（包括RAM和ROM）。</li><li>ROM上有计算机硬件地址 <strong>MAC</strong> 地址。</li></ul></li><li>在局域网中，硬件地址又称为物理地址，或 MAC 地址。</li><li>MAC 地址：每个适配器有一个全球唯一的 48 位二进制地址，前 24 位代表厂家（由 IEEE 规定），后 24 位厂家自己指定。常用 6 个十六进制数表示，如 02-60-8c-e4-b1-21。</li></ul></li><li>以太网 MAC 帧<ul><li><img src="/2021/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-Part3/image-20211219171554968.png" alt="image-20211219171554968" style="zoom:80%;"></li></ul></li><li>高速以太网<ul><li>速率 ≥100Mb/s 的以太网称为高速以太网。</li><li>100BASE-T以太网<ul><li>在双绞线上传送 100Mb/s 基带信号的星型拓扑以太网，仍使用 IEEE802.3 的 CSMA/CD 协议。</li><li>支持全双工和半双工，可在全双工方式下工作而无冲突（交换机隔离冲突域）。</li></ul></li><li>吉比特以太网<ul><li>在光纤或双绞线上传送 1Gb/s 信号。</li><li>支持全双工和半双工，可在全双工方式下工作而无冲突。</li></ul></li><li>10 吉比特<ul><li>10 吉比特以太网在光纤上传送 10Gb/s 信号。</li><li>只支持全双工，无争用问题。</li></ul></li></ul></li></ul><h3 id="无线局域网"><a href="#无线局域网" class="headerlink" title="无线局域网"></a>无线局域网</h3><ul><li><strong>IEEE 802.11</strong>：<ul><li>是<strong>无线局域网</strong>通用的标准，它是由 IEEE 所定义的无线网络通信的标准。</li><li>WIFI 属于无线局域网（IEEE 802.11 b、IEEE 802.11 g），但无线局域网的范围一般更大</li></ul></li><li>802.11 的 MAC 帧头格式：<ul><li><img src="/2021/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-Part3/image-20211219174356857.png" alt="image-20211219174356857" style="zoom:80%;"></li><li>假设 A 手机在基站 AP<del>1</del> 登记，B 手机在基站 AP<del>2</del> 登记，则<ul><li>接收端：mac(AP<del>2</del>)</li><li>发送端：mac(AP<del>1</del>)</li><li>目的地址：mac(B)</li><li>源地址：mac(A)</li></ul></li><li><img src="/2021/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-Part3/image-20211219175425414.png" alt="image-20211219175425414" style="zoom:80%;"></li></ul></li><li><strong>无线局域网的分类</strong>：<ul><li>有固定的基础设施无线局域网<ul><li><img src="/2021/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-Part3/image-20211219175650693.png" alt="image-20211219175650693" style="zoom:67%;"></li></ul></li><li>无固定基础设施无线局域网的自组织网络（基本不考）<ul><li><img src="/2021/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-Part3/image-20211219175727315.png" alt="image-20211219175727315" style="zoom:80%;"></li></ul></li></ul></li></ul><h2 id="广域网"><a href="#广域网" class="headerlink" title="广域网"></a>广域网</h2><p><img src="/2021/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-Part3/image-20211219214621576.png" alt="image-20211219214621576"></p><h3 id="概览-1"><a href="#概览-1" class="headerlink" title="概览"></a>概览</h3><ul><li>广域网（WAN，Wide Area Network），通常跨接很大的物理范围，所覆盖的范围从几十公里到几千公里，能连接多个城市或国家、横跨几个洲并能提供远距离通信，形成国际性的远程网络。</li><li>广域网的通信子网主要使用<strong>分组交换</strong>技术。可以利用公用分组交换网、卫星通信网和无线分组交换网，将分布在不同地区的<strong>局域网或计算机系统</strong>互连起来，达到<strong>资源共享</strong>的目的。</li><li>因特网（Internet）是世界范围内最大的广域网。</li><li><img src="/2021/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-Part3/image-20211219180702012.png" alt="image-20211219180702012" style="zoom:80%;"></li></ul><h3 id="PPP-协议和-HDLC-协议"><a href="#PPP-协议和-HDLC-协议" class="headerlink" title="PPP 协议和 HDLC 协议"></a>PPP 协议和 HDLC 协议</h3><ul><li>PPP 协议<ul><li>点对点协议PPP（Point-to-Point Protocol）是目前使用最广泛的数据链路层协议，用户使用拨号电话接入因特网时一般都使用 PPP 协议。</li><li>特点：只支持全双工链路。</li><li>需要满足的要求：<ul><li>简单：对于链路层的帧，无需纠错，无需序号，无需流量控制</li><li>封装成帧：帧定界符</li><li>透明传输：与帧定界符一样比特组合的数据应该如何处理：异步线路用字节填充，同步线路用比特填充</li><li>多种网络层协议：封装的 IP 数据报可以采用多种协议</li><li>多种类型链路：串行/并行，同步/异步，电/光……</li><li>差错检测：CRC，错就丢弃</li><li>检测连接状态 ：链路是否正常工作</li><li>最大传送单元：数据部分最大长度 MTU</li><li>网络层地址协商：知道通信双方的网络层地址</li><li>数据压缩协商</li></ul></li><li>无需满足的要求：（为了更快的传输速率）<ul><li>纠错</li><li>流量控制</li><li>序号</li><li>不支持多点线路</li></ul></li><li>三个组成部分<ul><li>一个将 IP 数据报封装到串行链路（同步串行/异步串行）的方法</li><li>链路控制协议 LCP：建立并维护数据链路连接（身份验证）</li><li>网络控制协议 NCP：PPP 可支持多种网络层协议，每个不同的网络层协议都要一个相应的 NCP 来配置，为网络层协议建立和配置逻辑连接</li></ul></li><li>状态图<ul><li><img src="/2021/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-Part3/image-20211219181135816.png" alt="image-20211219181135816" style="zoom: 67%;"></li></ul></li><li>帧格式<ul><li><img src="/2021/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-Part3/image-20211219181314070.png" alt="image-20211219181314070" style="zoom:67%;"></li></ul></li></ul></li><li>HDLC 协议：<ul><li>高级数据链路控制（High-Level Data Link Control或简称HDLC），是一个在同步网上传输数据、<strong>面向比特</strong>的数据链路层协议，它是由国际标准化组织(<strong>ISO</strong>)根据IBM公司的 SDLC(SynchronousData Link Control)协议扩展开发而成的.<ul><li>数据报文可透明传输，用于实现透明传输的“0比特插入法”易于硬件实现 </li><li>采用全双工通信</li><li>所有帧采用 CRC 检验，对信息帧进行顺序编号，可防止漏收或重份，传输可靠性高。</li></ul></li><li>主站、从站、复合站<ul><li>主站的主要功能是发送命令（包括数据信息）帧、接收响应帧，并负责对整个链路的控制系统的初启、流程的控制、差错检测或恢复等。</li><li>从站的主要功能是接收由主站发来的命令帧，向主站发送响应帧，并且配合主站参与差错恢复等链路控制。</li><li>复合站的主要功能是既能发送，又能接收命令帧和响应帧，并且负责整个链路的控制。</li></ul></li><li>三种数据操作方式：<ul><li>正常响应方式</li><li>异步平衡方式</li><li>异步响应方式</li></ul></li><li>帧格式<ul><li><img src="/2021/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-Part3/image-20211219182554499.png" alt="image-20211219182554499" style="zoom:80%;"></li><li>控制C（记住三种类型即可“无奸细”）<ul><li>信息帧：开头为 0，⽤来传输数据信息，或使⽤捎带技术对数据进⾏确认</li><li>监督帧：开头为 10，⽤于流量控制和差错控制，执⾏对信息帧的确认、请求重发和请求暂停发送等功能</li><li>⽆编号帧：开头为 11，⽤于提供对链路的建⽴、拆除等多种控制功能。</li></ul></li></ul></li></ul></li><li>PPP协议＆HDLC协议<ul><li>HDLC、PPP 都只支持<strong>全双工</strong>链路。</li><li>都可以实现透明传输。（PPP 协议既可以比特填充，也可以字节填充；HDLC 只能比特填充“5110”）</li><li>都可以实现差错检测，但不纠正差错。</li><li>PPP 协议：<ul><li>面向字节</li><li>2B 协议字段</li><li>无序号和确认机制</li><li>不可靠</li></ul></li><li>HDLC 协议：<ul><li>面向比特</li><li>没有协议字段</li><li>有编号和确认机制</li><li>可靠</li></ul></li></ul></li></ul><h2 id="链路层设备"><a href="#链路层设备" class="headerlink" title="链路层设备"></a>链路层设备</h2><p><img src="/2021/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-Part3/image-20211220135420209.png" alt="image-20211220135420209"></p><ul><li><strong>物理层扩展以太网</strong><ul><li><img src="/2021/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-Part3/image-20211220131953915.png" alt="image-20211220131953915" style="zoom:80%;"></li></ul></li><li><strong>链路层扩展以太网</strong><ul><li>网桥&amp;交换机，根据 <strong>MAC 帧的目的地址</strong>对帧进行<strong>转发和过滤</strong>。<ul><li>当网桥收到一个帧时，并不像集线器那样向所有接口转发此帧，而是先检查此帧的目的 MAC 地址，然后再确定将该帧转发到哪一个接口，或者是把它丢弃（即过滤）。</li></ul></li><li>网桥优点：<ul><li>过滤通信量，增大吞吐量。</li><li>扩大了物理范围。</li><li>提高了可靠性。</li><li>可互连不同物理层、不同 MAC 子层和不同速率的以太网。</li></ul></li><li>网段：一般指一个计算机网络中使用同一物理层设备（传输介质，中继器，集线器等）能够直接通讯的那一部分。<ul><li>一个冲突域就是一个网段</li><li><img src="/2021/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-Part3/image-20211220132426109.png" alt="image-20211220132426109"></li></ul></li><li>网桥分类<ul><li><strong>透明网桥：</strong>“透明”指以太网上的站点并不知道所发送的帧将经过哪几个网桥，是一种即插即用设备——自学习。<ul><li>每次在网桥的转发表中，只记录源地址的方向，过滤目的地址。</li><li>只要连接网桥上的每一个主机都作为源地址发送一次信息，那么网桥就可以理解以太网的拓扑结构了。</li><li>会经常清空转发表重新学习，以获取最新的网络拓扑。</li><li><img src="/2021/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-Part3/image-20211220134014812.png" alt="image-20211220134014812" style="zoom:80%;"></li></ul></li><li><strong>源路由网桥：</strong>在发送帧时，把详细的最佳路由信息（路由最少/时间最短）放在帧的首部中。<ul><li><strong>方法：</strong>源站以广播方式向欲通信的目的站发送一个<strong>发现帧</strong>。</li><li>到达终点时原路返回起点，以获得最短路径。</li></ul></li></ul></li></ul></li><li>多接口网桥——以太网交换机：<ul><li>可以独占传输媒体带宽</li><li><img src="/2021/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-Part3/image-20211220134640767.png" alt="image-20211220134640767" style="zoom:80%;"></li></ul></li><li>以太网交换机的两种交换方式<ul><li>直通式交换机：<ul><li>只检查目的地址（<strong>6B</strong>）就立刻转发。</li><li>延迟小，可靠性低，无法支持具有不同速率的端口的交换。</li></ul></li><li>存储转发式交换机：<ul><li>将帧放入高速缓存，并检查否正确，正确则转发，错误则丢弃。</li><li>延迟大，可靠性高，可以支持具有不同速率的端口的交换。</li></ul></li></ul></li><li>冲突域和广播域<ul><li><strong>冲突域</strong>：在同一个冲突域中的每一个节点都能收到所有被发送的帧。简单的说就是同一时间内只能有一台设备发送信息的范围。 </li><li><strong>广播域</strong>：网络中能接收任一设备发出的广播帧的所有设备的集合。简单的说如果站点发出一个广播信号，所有能接收到这个信号的设备范围称为一个广播域。</li></ul></li></ul><table><thead><tr><th></th><th><strong>能否隔离冲突域</strong></th><th><strong>能否隔离广播域</strong></th></tr></thead><tbody><tr><td>物理层设备（中继器、集线器）</td><td>不行</td><td>不行</td></tr><tr><td>链路层设备（网桥、交换机）</td><td>可以</td><td>不行</td></tr><tr><td>网络层设备（路由器）</td><td>可以</td><td>可以</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络-Part2</title>
      <link href="/2021/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-Part2/"/>
      <url>/2021/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-Part2/</url>
      
        <content type="html"><![CDATA[<h1 id="计算机网络-Part2——物理层"><a href="#计算机网络-Part2——物理层" class="headerlink" title="计算机网络-Part2——物理层"></a>计算机网络-Part2——物理层</h1><p>[TOC]</p><p><img src="/2021/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-Part2/image-20211205133036029.png" alt="image-20211205133036029"></p><h2 id="通信基础"><a href="#通信基础" class="headerlink" title="通信基础"></a>通信基础</h2><h3 id="物理层基本概念"><a href="#物理层基本概念" class="headerlink" title="物理层基本概念"></a>物理层基本概念</h3><ul><li>物理层解决如何在连接各种计算机的传输媒体上<strong>传输数据比特流</strong>，而不是指具体的传输媒体（传输介质不包括于物理层）。</li><li>物理层主要任务：确定与传输媒体<strong>接口</strong>有关的一些特性（定义标准）</li><li>物理层接口特性<ul><li>机械特性：定义物理连接的特性，规定物理连接时所采用的规格、接口形状、<strong>引线数目</strong>、<strong>引脚数量</strong>和排列情况。</li><li>电气特性：规定传输二进制位时，线路上信号的<strong>电压范围</strong>、阻抗匹配、传输<strong>速率</strong>和<strong>距离</strong>限制等。<ul><li>某网络在物理层规定，信号的电平用+10V～+15V表示二进制0，用−10V～−15V表示二进制1，电线长度限于15m以内</li></ul></li><li>功能特性：指明某条线上出现的某一<strong>电平表示何种意义</strong>，接口部件的信号线的用途。<ul><li>描述一个物理层接口引脚处于高电平时的含义时（一般不会出现数字）</li></ul></li><li>规程特性（过程特性）：定义各条物理线路的工作<strong>规程和时序</strong>关系。</li></ul></li></ul><h3 id="数据通信基础知识"><a href="#数据通信基础知识" class="headerlink" title="数据通信基础知识"></a>数据通信基础知识</h3><p><img src="/2021/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-Part2/image-20211206121555060.png" alt="image-20211206121555060"></p><ul><li>典型的数据通信模型<ul><li><img src="/2021/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-Part2/image-20211205133834588.png" alt="image-20211205133834588"></li></ul></li><li>数据通信相关术语<ul><li>数据通信<ul><li>指在不同计算机之间传输表示信息的二进制数 0、1 序列的过程。</li><li>目的，是传送消息（消息：语音、文字、图像、视频等）。</li></ul></li><li>数据：传送信息的实体，通常是有意义的符号序列。</li><li>信号：数据的电气/电磁的表现，是数据在传输过程中的<strong>存在形式</strong>。<ul><li><img src="/2021/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-Part2/image-20211205133944619.png" alt="image-20211205133944619" style="zoom:80%;"></li></ul></li><li>信源：产生和发送数据的源头。</li><li>信宿：接收数据的终点 。</li><li>信道：信号的传输媒介。一般用来表示向某一个方向传送信息的介质，因此一条通信线路往往包含一 条发送信道和一条接收信道。<ul><li><img src="/2021/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-Part2/image-20211205134022389.png" alt="image-20211205134022389" style="zoom:80%;"></li></ul></li></ul></li><li>三种数据通信方式<ul><li>单工通信<ul><li>只有一个方向的通信而没有反方向的交互，仅需要<strong>一条</strong>信道。</li></ul></li><li>半双工通信/双向交替通信<ul><li>通信的双方都可以发送或接收信息，但任何一方都不能同时发送和接收，</li><li>需要<strong>两条</strong>信道（信道类似于矢量）。</li></ul></li><li>全双工通信/双向同时通信<ul><li>通信双方可以同时发送和接受信息，也需要<strong>两条</strong>信道。</li></ul></li></ul></li><li>两种传输方式<ul><li>串行传输<ul><li>将表示一个字符的8位二进制数按由低位到高位的顺序依次发送。</li><li>速度<strong>慢</strong>，费用<strong>低</strong>，适合<strong>远</strong>距离</li></ul></li><li>并行传输<ul><li>将表示一个字符的8位二进制数同时通过8条信道发送。</li><li>速度<strong>快</strong>，费用<strong>高</strong>，适合<strong>近</strong>距离</li></ul></li></ul></li><li>实现同步的传输/通信方式<ul><li>同步传输：在同步传输的模式下，数据的传送是以一个<strong>数据区块</strong>为单位，因此同步传输又称为区块传输。在传送数据时，需先送出1个或多个同步字符，再送出整批的数据。</li><li>异步传输：异步传输将比特分成小组进行传送，小组可以是8位的1个字符或更长。发送方可以在任何时刻发送这些比特组，而接收方不知道它们会在什么时候到达。传送数据时，加一个字符起始位和一个字符终止位。</li></ul></li><li>码元<ul><li>指用一个<strong>固定时长的信号波形</strong>（数字脉冲）代表不同离散数值的基本波形，是数字通信中数字信号的计量单位，这个时长内的信号称为 <strong>k 进制码元</strong>，而该时长称为<strong>码元宽度</strong>。</li><li>当码元的离散状态有 M 个时（M ＞ 2），此时码元为 M 进制码元。</li><li><strong>1 码元可以携带多个比特的信息量</strong>。<ul><li>在使用二进制编码时，只有两种不同的码元，一种代表 0 状态，另一种代表 1 状态。</li><li>在使用四进制编码时，有四种不同的码元，分别为 00/0110/11。</li></ul></li></ul></li><li>速率<ul><li>速率也叫数据率，是指<strong>数据的传输速率</strong>，表示单位时间内传输的数据量。可以用<strong>码元传输速率</strong>和<strong>信息传输速率</strong>表示。<ul><li><strong>码元传输速率</strong>：别名码元速率、波形速率、调制速率、符号速率等，它表示<strong>单位时间内数字通信系统所传输的码元个数</strong>（也可称为<strong>脉冲个数</strong>或<strong>信号变化的次数</strong>），单位是<strong>波特</strong>（Baud）。1 波特表示数字通信系统每秒传输一个码元。<ul><li><strong>码元速率与进制数无关</strong>，只与<strong>码元长度T</strong>有关。</li><li>$$R_{B} = \frac{1}{T} (B)$$</li></ul></li><li><strong>信息传输速率</strong>：别名信息速率、比特率等，表示单位时间内数字通信系统传输的二进制码元个数（即比特数），单位是比特/秒（b/s）。</li><li>关系：若一个码元携带 n bit 的信息量，则 M Baud 的码元传输速率所对应的信息传输速率为 M×n bit/s。</li><li><img src="/2021/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-Part2/image-20211205184138618.png" alt="image-20211205184138618" style="zoom: 80%;"></li></ul></li></ul></li><li>带宽（Bandwidth）<ul><li><strong>模拟信号系统中</strong>：最高频率和最低频率间的差值就代表了系统的通频带宽，单位为**赫兹(Hz)**。（了解）</li><li><strong>数字设备中</strong>：表示在单位时间内能通过的<strong>最高数据率</strong>（单位时间内通过链路的数量），常用来表示网络的通信线路所能传输数据的能力。 单位是**比特每秒(bps)**。</li></ul></li></ul><h3 id="奈氏准则和香农定理（重要）"><a href="#奈氏准则和香农定理（重要）" class="headerlink" title="奈氏准则和香农定理（重要）"></a>奈氏准则和香农定理（重要）</h3><ul><li>影响失真程度的因素：1. 码元传输速率；2. 信号传输距离；3. 噪声干扰；4. 传输媒体质量</li><li>码间串扰：<strong>接收端</strong>收到的信号波形失去了码元之间清晰界限的<strong>现象</strong>。</li><li>奈氏准则（奈奎斯特定理）<ul><li>在理想低通（无噪声，带宽受限）条件下，为了避免码间串扰，极限码元传输速率为 2*W Baud，W 是信道带宽，单位是 Hz。<ul><li><img src="/2021/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-Part2/image-20211205185635334.png" alt="image-20211205185635334" style="zoom:67%;"></li></ul></li><li>推论<ul><li>在任何信道中，码元传输的速率是有<strong>上限</strong>的。若传输速率超过此上限，就会出现严重的码间串扰问题，使接收端对码元无法正确识别。</li><li>信道的<strong>频带越宽</strong>（即能通过的信号高频分量越多），就可以用更高的速率进行码元的有效传输。</li><li>奈氏准则给出了码元传输速率的限制，但并没有对信息传输速率给出限制。</li><li>由于码元的传输速率受奈氏准则的制约，所以要提高数据的传输速率，就必须设法使每个码元能携带更多个比特的信息量，这就需要采用多元制的调制方法。</li></ul></li></ul></li><li>香农定理<ul><li><strong>噪声</strong>存在于所有的电子设备和通信信道中。由于噪声随机产生，它的瞬时值有时会很大，因此噪声会使接收端对码元的判决产生错误。但是噪声的影响是相对的，若信号较强，那么噪声影响相对较小。<ul><li>因此，信噪比就很重要。信噪比=<strong>信号</strong>的平均功率/<strong>噪声</strong>的平均功率，常记为S/N，并用分贝（dB）作为度量单位，即：</li><li><img src="/2021/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-Part2/image-20211205190151682.png" alt="image-20211205190151682" style="zoom:80%;"></li></ul></li><li>香农定理：在带宽受限且有噪声的信道中，为了不产生误差，信息的数据传输速率有上限值。<ul><li><img src="/2021/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-Part2/image-20211205185848058.png" alt="image-20211205185848058" style="zoom: 67%;"></li></ul></li><li>推论<ul><li>信道的<strong>带宽</strong>或信道中的<strong>信噪比</strong>越大，则信息的极限传输速率就<strong>越高</strong>。</li><li>对一定的传输带宽和一定的信噪比，信息传输速率的上限就确定了。 </li><li>只要信息的传输速率低于信道的极限传输速率，就一定能找到某种方法来实现<strong>无差错的传输</strong>。</li><li>香农定理得出的为极限信息传输速率，实际信道能达到的传输速率要比它低不少。 </li><li>从香农定理可以看出，若信道带宽W或信噪比S/N没有上限（不可能），那么信道的极限信息传输速率也就没有上限。</li></ul></li></ul></li><li><img src="/2021/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-Part2/image-20211205191024013.png" alt="image-20211205191024013"><ul><li>当两个方法都是用时，都计算，并选择其较小的一个结果</li></ul></li></ul><h3 id="编码与调制（重要）"><a href="#编码与调制（重要）" class="headerlink" title="编码与调制（重要）"></a>编码与调制（重要）</h3><p><img src="/2021/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-Part2/image-20211206121502139.png" alt="image-20211206121502139"></p><ul><li><strong>信道</strong>：信号的传输媒介。一般用来表示向某一个方向传送信息的介质，因此一条通信线路往往包含一条发送信道和一条接收信道。<ul><li>按传输信号分：1. 模拟信道（传送模拟信号）；2. 数字信道（传送数字信号）。</li><li>按传输介质分：1. 无线信道；2. 有线信道</li></ul></li><li>信道上传送的信号<ul><li>基带信号：将数字信号1和0直接用两种不同的电压表示，再送到<strong>数字信道</strong>上去传输（<strong>基带传输</strong>）。<ul><li>基带信号，是<strong>来自信源</strong>的信号，是发出的<strong>直接表达了要传输的信息的信号</strong>，计算机输出的数据信号、我们说话的声波都是基带信号。</li></ul></li><li>宽带信号：将基带信号进行调制后形成的频分复用模拟信号，再传送到模拟信道上去传输（<strong>宽带传输</strong>）。<ul><li>把基带信号经过<strong>载波调制</strong>后，把信号的<strong>频率范围搬移</strong>到<strong>较高的频段</strong>以便在信道中传输（即仅在一段频率范围内能够通过信道）。</li></ul></li><li>应用场景：<ul><li>在传输距离较近时，计算机网络采用<strong>基带传输</strong>方式（近距离衰减小，从而信号内容不易发生变化）</li><li>在传输距离较远时，计算机网络采用<strong>宽带传输</strong>方式（远距离衰减大，即使信号变化大也能最后过滤出来基带信号）</li></ul></li></ul></li><li>编码与调制<ul><li><img src="/2021/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-Part2/image-20211205193430091.png" alt="image-20211205193430091" style="zoom:80%;"></li><li>编码：把数据转为数字信号的过程</li><li>调制：把数字信号转为模拟信号的过程</li></ul></li><li>数字数据编码为数字信号<ul><li><img src="/2021/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-Part2/image-20211205194356706.png" alt="image-20211205194356706" style="zoom:80%;"></li><li>非归零编码（NRZ）：编码容易实现；但没有检错功能、无法判断一个码元的开始和结束、收发双方<strong>难以保持同步</strong>。</li><li>归零编码（RZ）：信号电平在一个码元之内都要恢复到零的这种编码成编码方式。</li><li>反向不归零编码（NRZI）：信号电平翻转表示 0，信号电平不变表示 1。</li><li>曼彻斯特编码：前低后高为 1、前高后低为 0，相反亦可。<ul><li>特点：每个码元中间<strong>都有电平跳变</strong>，既作时钟信号（可用于同步），又作数据信号；但所占的频带宽度是原始的两倍、数据传输速率<strong>只有调制速率的 1/2</strong>。</li></ul></li><li>差分曼彻斯特编码：同 1 异 0<ul><li>若码元为 1，则前半个码元的电平与上一个码元的后半个码元的电平相同，若为0，则相反。</li><li>特点：每个码元中间<strong>都有电平跳变</strong>，且抗干扰性<strong>强</strong>于曼彻斯特编码。</li></ul></li><li>4B/5B 编码<ul><li>用第 5 个比特位来包装 4 个比特位的数据（帧的开始和结束，线路的状态信息等）。编码效率为 80%。</li></ul></li></ul></li><li>数字数据调制为模拟信号<ul><li>数字数据调制技术在发送端将数字信号转换为模拟信号，而在接收端将模拟信号还原为数字信号，分别对应于调制解调器的调制和解调过程。</li><li><img src="/2021/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-Part2/image-20211205200743328.png" alt="image-20211205200743328" style="zoom:80%;"></li><li>调幅+调相（QAM）：<strong>做题时遇到 n 个相位 m 种振幅，则可知有 n*m 种码元（n*m 进制码元），需要机器用 log<del>2</del>(n*m) 个 bit 来表示</strong>。</li></ul></li><li>模拟数据编码为数字信号<ul><li>计算机内部处理的是二进制数据，处理的都是<strong>数字音频</strong>，所以需要将模拟音频通过采样、量化转换成有限个数字表示的离散序列（即实现<strong>音频数字化</strong>）。</li><li>例如，对音频信号进行编码的脉码调制（<strong>PCM</strong>），能够达到<strong>最高保真水平</strong>。</li><li>过程<ul><li>抽样：对模拟信号周期性扫描，把时间上<strong>连续的信号变成离散的信号</strong>。<ul><li>为了使所得的离散信号能无失真地代表被抽样的模拟数据，要使用采样定理进行采样：</li><li>f<del>采样频率</del> ≥ 2 * f<del>信号最高频率</del></li></ul></li><li>量化：把抽样取得的电平幅值按照分级标度转化为对应的<strong>整数值</strong>，即把连续的电平幅值转换为离散的数字量。</li><li>编码：把量化的结果转换为与之对应的二进制编码。</li></ul></li></ul></li><li>模拟数据调制为模拟信号<ul><li>为了实现传输的有效性，可能需要较高的频率。这种调制方式可以使用<strong>频分复用技术</strong>，充分利用带宽资源。模拟的声音数据是加载到模拟的载波信号中传输的。</li><li>例如：在电话机和本地交换机所传输的信号</li></ul></li></ul><h3 id="数据交换方式（重要）"><a href="#数据交换方式（重要）" class="headerlink" title="数据交换方式（重要）"></a>数据交换方式（重要）</h3><ul><li><p><strong>电路（线路）交换</strong></p><ul><li>原理：在数据传输期间，源结点与目的结点之间有一条由中间结点构成的<strong>专用物理连接线路</strong>，在数据传输结束之前，这条线路一直保持。</li><li>特点：<ul><li><strong>独占资源</strong>，用户始终占用端到端的固定传输带宽。</li><li>适用于远程批处理信息传输或系统间<strong>实时性要求高</strong>、<strong>大量数据传输</strong>的情况。</li></ul></li><li><img src="/2021/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-Part2/image-20211206122433869.png" alt="image-20211206122433869" style="zoom:80%;"></li><li><img src="/2021/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-Part2/image-20211206122457184.png" alt="image-20211206122457184"></li></ul></li><li><p><strong>报文交换</strong>(Message Exchanging)</p><ul><li>报文，是网络中交换与传输的数据单元，即站点<strong>一次性要发送的数据块</strong>。报文包含了将要发送的完整的数据信息，其长短很不一致，长度不限且可变。</li><li>原理：无需在两个站点之间建立一条专用通路，其数据传输的单位是报文。采用<strong>存储转发</strong>方式。</li><li><img src="/2021/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-Part2/image-20211206123015772.png" alt="image-20211206123015772"></li><li><img src="/2021/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-Part2/image-20211206122844463.png" alt="image-20211206122844463"></li></ul></li><li><p><strong>分组交换</strong>(Packet Exchanging)</p><ul><li><p>分组：大多数计算机网络都不能连续地传送任意长的数据，所以实际上网络系统把数据分割成小块，然后逐块地发送，这种小块就称作分组（packet）。</p></li><li><p>原理：</p><ul><li>分组交换与报文交换的工作方式基本相同，<strong>都采用存储转发方式</strong>，形式上的主要差别在于，分组交换网中要<strong>限制所传输的数据单位的长度</strong>，一般选 128B。</li><li><strong>发送节点</strong>首先对从终端设备送来的数据报文进行接收、存储，而后将报文划分成一定长度的分组，并以分组为单位进行传输和交换。<strong>接收结点</strong>将收到的分组组装成信息或报文。</li></ul></li><li><p><img src="/2021/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-Part2/image-20211206123615739.png" alt="image-20211206123615739"></p></li><li><p><img src="/2021/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-Part2/image-20211206123652425.png" alt="image-20211206123652425"></p></li><li><p>数据交换方式的选择</p><ul><li><img src="/2021/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-Part2/image-20211206124243420.png" alt="image-20211206124243420"></li></ul></li><li><p><strong>数据报方式</strong></p><ul><li>流程<ul><li>源主机（A）<strong>将报文分成多个分组</strong>，依次发送到直接相连的结点（A）。</li><li>结点A收到分组后，对每个分组<strong>差错检测</strong>和<strong>路由选择</strong>，不同分组的下一跳结点可能不同。</li><li>结点 C 收到分组 P1 后，对分组 P1 进行<strong>差错检测</strong>，若正确则向 A 发送<strong>确认信息</strong>，A 收到 C 确认后则丢弃分组 P1 副本。</li><li>所有分组到达目标主机（B）</li></ul></li><li>特点<ul><li><strong>数据报方式</strong>为网络层提供<strong>无连接服务</strong>。即，发送方可随时发送分组，网络中的结点可随时接收分组。</li><li>同一报文的不同分组达到目的结点时可能发生<strong>乱序、重复与丢失</strong>。</li><li>每个分组在传输过程中都必须携带<strong>源地址、目的地址、分组号</strong>。</li><li>导致时延的情况：1. 分组在交换结点存储转发时，需要排队等候处理；2. 通过交换结点的通信量较大或网络发生拥塞，此时交换结点还可根据情况丢弃部分分组。</li><li>网络具有冗余路径，当某一交换结点或一段链路出现故障时，可相应地更新转发表，寻找另一条路径转发分组。对故障的适应能力强，适用于突发性通信，不适于长报文、会话式通信。</li></ul></li><li><img src="/2021/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-Part2/image-20211206130257240.png" alt="image-20211206130257240"></li></ul></li><li><p><strong>虚电路方式</strong></p><ul><li>虚电路：<ul><li>结合数据报方式和电路交换方式，发挥两者优点。</li><li>一条源主机到目的主机类似于电路的路径（<strong>逻辑连接</strong>），路径上所有结点都要维持这条虚电路的建立，都维持一张虚电路表，每一项记录了一个打开的虚电路的信息。</li></ul></li><li>流程<ul><li><img src="/2021/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-Part2/image-20211206131854783.png" alt="image-20211206131854783" style="zoom:80%;"></li></ul></li><li>特点<ul><li><strong>虚电路方式</strong>为网络层提供<strong>连接服务</strong>。源节点与目的结点之间建立一条逻辑连接，而非实际物理连接。</li><li>一次通信的所有分组都通过虚电路顺序传送，分组不需携带源地址、目的地址等信息，只包含<strong>虚电路号</strong>，相对数据报方式开销小，同一报文的不同分组到达目的结点时不会乱序、重复或丢失。</li><li>分组通过虚电路上的每个节点时，节点只进行差错检测，不需进行路由选择。</li><li>每个节点可能与多个节点之间建立<strong>多条虚电路</strong>（不独占），每条虚电路支持特定的两个端系统之间的数据传输，可以在两个数据端点之间进行<strong>流量控制</strong>，两个端系统之间也可以有多条虚电路为<strong>不同的进程</strong>服务。</li><li>致命弱点：当网络中的某个结点或某条链路出故障而彻底失效时，则所有经过该结点或该链路的虚电路将遭到破坏</li></ul></li></ul></li><li><p><img src="/2021/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-Part2/image-20211206132026937.png" alt="image-20211206132026937"></p></li></ul></li></ul><h2 id="物理层传输介质"><a href="#物理层传输介质" class="headerlink" title="物理层传输介质"></a>物理层传输介质</h2><p><img src="/2021/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-Part2/image-20211206121626839.png" alt="image-20211206121626839"></p><ul><li><strong>传输介质</strong>，也称<strong>传输媒体/传输媒介</strong>，它就是数据传输系统中在发送设备和接收设备之间的<strong>物理通路</strong>。<ul><li><strong>传输媒体并不是物理层</strong>。</li></ul></li><li>导向传输介质<ul><li>双绞线<ul><li>双绞线，是古老、又最常用的传输介质，由<strong>两根</strong>采用一定规则并排<strong>绞合</strong>的、相互绝缘的<strong>铜导线</strong>组成。<ul><li><strong>绞合可以减少对相邻导线的电磁干扰</strong>。</li><li>为了进一步提高抗电磁干扰能力，可在双绞线的外面再加上一个由<strong>金属丝</strong>编织成的屏蔽层，即<strong>屏蔽双绞线</strong>（STP），无屏蔽层的则称为<strong>非屏蔽双绞线</strong>（UTP）。</li></ul></li><li>特点：<ul><li>价格<strong>便宜</strong>，是最常用的传输介质之一，在局域网和传统电话网中普遍使用。</li><li>模拟传输和数字传输都可以使用双绞线，其通信距离一般为几公里到数十公里。</li><li>距离太远时，对于<strong>模拟传输</strong>，要用<strong>放大器</strong>放大衰减的信号；对于<strong>数字传输</strong>，要用<strong>中继器</strong>将失真的信号整形。</li></ul></li><li><img src="/2021/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-Part2/image-20211206133115815.png" alt="image-20211206133115815" style="zoom:80%;"></li></ul></li><li>同轴电缆<ul><li>同轴电缆由<strong>导体铜质芯线</strong>、<strong>绝缘层</strong>、<strong>网状编织屏蔽层</strong>和<strong>塑料外层</strong>构成。</li><li>按特性阻抗数值的不同，通常将同轴电缆分为两类：<ul><li>50Ω同轴电缆主要用于传送基带数字信号，又称为<strong>基带同轴电缆</strong>，在<strong>局域网</strong>中得到广泛应用；</li><li>75Ω同轴电缆主要用于传送宽带信号，又称为<strong>宽带同轴电缆</strong>，主要用于<strong>有线电视系统</strong>。</li></ul></li><li>由于外导体屏蔽层的作用，同轴电缆<strong>抗干扰特性</strong>比双绞线好，被广泛用于传输较高速率的数据，其<strong>传输距离</strong>更远，但<strong>价格</strong>较双绞线贵。</li><li><img src="/2021/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-Part2/image-20211206133400309.png" alt="image-20211206133400309" style="zoom:80%;"></li></ul></li><li>光纤<ul><li>光纤通信，利用光导纤维（光纤）传递光脉冲进行通信。有光脉冲表示1，无光脉冲表示0。<ul><li>可见光的频率大约是 108MHz，因此光纤通信系统的<strong>带宽远远大于</strong>目前其他各种传输媒体。</li><li>光纤主要由纤芯（实心的）和包层（低折射率）构成，入射角足够大，就会出现全反射，从而传输下去</li><li><img src="/2021/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-Part2/image-20211206134627537.png" alt="image-20211206134627537" style="zoom:80%;"></li></ul></li><li>特点：<ul><li>传输<strong>损耗小</strong>，中继距离长，对远距离传输特别经济。</li><li><strong>抗雷电和电磁干扰性能好</strong>。</li><li>无串音干扰，保密性好，也<strong>不易被窃听或截取数据</strong>。</li><li><strong>体积小，重量轻</strong>。</li></ul></li><li><img src="/2021/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-Part2/image-20211206133438500.png" alt="image-20211206133438500" style="zoom:80%;"></li></ul></li></ul></li><li>非导向传输介质<ul><li>无线电波（信号向所有方向传播）<ul><li>较强<strong>穿透能力</strong>，可传远距离，广泛用于通信领域（如手机通信）。</li></ul></li><li>微波（信号固定方向传播）<ul><li>微波通信频率较高、频段范 围宽，因此数据率很高。</li><li>可用于<ul><li>地面微波接力通信</li><li>卫星通信<ul><li>优点：<ul><li>通信容量大</li><li>距离远</li><li>覆盖广</li><li>广播通信和多址通信</li></ul></li><li>缺点：<ul><li>传播时延长（250-270ms）</li><li>受气候影响大（eg：强风、太阳黑子爆发、日凌）</li><li>误码率较高</li><li>成本高（指卫星）</li></ul></li></ul></li></ul></li></ul></li><li>红外线、激光（信号固定方向传播）<ul><li>把要传输的信号分别<strong>转换为各自的信号格式</strong>（相比微波的区别），即红外光信号和激光信号，再在空间中传播。</li></ul></li></ul></li></ul><h2 id="物理层设备"><a href="#物理层设备" class="headerlink" title="物理层设备"></a>物理层设备</h2><ul><li>中继器<ul><li><strong>诞生原因</strong>：由于存在损耗，在线路上传输的信号功率会逐渐衰减，衰减到一定程度时将造成信号失真，因此会导致接收错误。</li><li><strong>中继器的功能</strong>： 对<strong>数字信号</strong>进行<strong>再生和还原</strong>，对衰减的信号进行放大，保持与原数据相同，以增加信号传输的距离，延长网络的长度。</li><li><strong>中继器的两端</strong>：两端的网络部分是网段，而不是子网，适用于完全相同的<strong>两类</strong>网络的互连，且两个网段速率要相同。<ul><li>中继器只将任何电缆段上的数据发送到另一段电缆上，它仅作用于信号的电气部分，并不管数据中是否有错误数据或不适于网段的数据（<strong>不会校验</strong>）。</li><li>两端可连相同媒体，也可连不同媒体。 </li><li>中继器两端的网段一定要是同一个协议。（<strong>不会存储转发</strong>）</li></ul></li><li><strong>5-4-3规则：</strong>网络标准中都对信号的延迟范围作了具体的规定，因而中继器只能在规定的范围内进行，否则会网络故障。<ul><li>最多只能由 5 个网段（一个中继器连两个网段）、4 个物理设备（中继器或集线器）、只有三个段可以连接计算机</li><li><img src="/2021/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-Part2/image-20211206140813646.png" alt="image-20211206140813646"></li></ul></li></ul></li><li>集线器（多口中继器）<ul><li><strong>集线器的功能</strong>： 对信号进行再生<strong>放大转发</strong>，对衰减的信号进行放大，接着转发到其他所有（除输入端口外）处于工作状态的端口上，以增加信号传输的距离，延长网络的长度。</li><li>不具备信号的定向传送能力，是一个共享式设备（广播）。</li><li><img src="/2021/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-Part2/image-20211206141116263.png" alt="image-20211206141116263" style="zoom:80%;"></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络-Part1</title>
      <link href="/2021/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-Part1/"/>
      <url>/2021/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-Part1/</url>
      
        <content type="html"><![CDATA[<h1 id="计算机网络-Part1——计算机网络体系结构"><a href="#计算机网络-Part1——计算机网络体系结构" class="headerlink" title="计算机网络-Part1——计算机网络体系结构"></a>计算机网络-Part1——计算机网络体系结构</h1><p>[TOC]</p><p><img src="/2021/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-Part1/image-20211205131631404.png" alt="image-20211205131631404"></p><h2 id="408计算机网络大纲【考查目标】"><a href="#408计算机网络大纲【考查目标】" class="headerlink" title="408计算机网络大纲【考查目标】"></a>408计算机网络大纲【考查目标】</h2><ol><li><p>掌握计算机网络的<strong>基本概念、基本原理和基本方法</strong>。 </p></li><li><p>掌握计算机网络的<strong>体系结构</strong>和典型<strong>网络协议</strong>，了解典型<strong>网络设备</strong>的组成和特点，理解典型网络设备的工作原理。</p></li><li><p>能够运用计算机网络的基本概念、基本原理和基本方法进行<strong>网络系统的分析、设计和应用</strong>。</p></li></ol><h2 id="计算机网络概述"><a href="#计算机网络概述" class="headerlink" title="计算机网络概述"></a>计算机网络概述</h2><h3 id="概念及功能"><a href="#概念及功能" class="headerlink" title="概念及功能"></a>概念及功能</h3><img src="/2021/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-Part1/image-20211204141800509.png" alt="image-20211204141800509" style="zoom:80%;"><ul><li><p>计算机网络：是一个将分散的、具有独立功能的<strong>计算机系统</strong>，通过<strong>通信设备与线路</strong>连接起来，由功能<strong>完善的软件</strong>实现<strong>资源共享</strong>和<strong>信息传递</strong>的系统。</p></li><li><p>计算机网络是<strong>互连的、自治的</strong>计算机集合。</p><ul><li>互连：通过通信链路互联互通</li><li>自治：无主从关系</li></ul></li><li><p>功能：</p><ul><li>数据通信<ul><li>通信指的是<strong>两台主机各自的一个进程之间</strong>的通信</li></ul></li><li>资源共享（网络打印机）</li><li>分布式处理（Hadoop）<ul><li>提高可靠性</li><li>负载均衡</li></ul></li></ul></li><li><p>发展：</p><ul><li>第一阶段：<ul><li>ARPAnet 阿帕网（无线分组交换网&amp;卫星通信网）</li><li>internet(interconnected network) 互联网（希望实现不同网络互联）</li><li>Internet 因特网（1983年阿帕网接受 TCP/IP 选定 Internet 为主要的计算机通信系统）<ul><li>因特网是世界上最大的互联网。</li></ul></li></ul></li><li>第二阶段（三级结构）：<ul><li>国家科学基金网 NSFNET。</li></ul></li><li>第三阶段（多层次 ISP 结构）：<ul><li><strong>ISP</strong>：因特网服务提供者/因特网服务提供商，是一个向广大用户综合提供互联网接入业务、信息业务、和增值业务的公司，如中国电信、中国联动、中国移动等。分为主干 ISP、地区 ISP 和本地 ISP。</li><li><img src="/2021/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-Part1/image-20211204141621780.png" alt="image-20211204141621780" style="zoom: 67%;"></li></ul></li></ul></li></ul><h3 id="组成与分类"><a href="#组成与分类" class="headerlink" title="组成与分类"></a>组成与分类</h3><p><img src="/2021/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-Part1/image-20211204143531048.png" alt="image-20211204143531048"></p><p>组成</p><ul><li>组成部分：硬件、软件、协议（一系列规则和约定的集合）</li><li>工作方式：<ul><li>边缘部分：用户直接使用<ul><li>C/S（client-server）方式：专门的的提供和被服务对象</li><li>P2P（peer-to-peer）方式：人人为我，我为人人</li></ul></li><li>核心部分：为边缘部分服务</li></ul></li><li>功能组成：<ul><li>通信子网：实现数据通信</li><li>资源子网：实现资源共享 /数据处理</li><li><img src="/2021/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-Part1/image-20211204143007160.png" alt="image-20211204143007160" style="zoom:67%;"></li></ul></li></ul><p>分类</p><ul><li>按分布范围：广域网WAN（交换技术）、城域网MAN、局域网LAN（广播技术）、个人区域网PAN<ul><li>优先按传输技术来区分广域网、局域网</li></ul></li><li>按使用者：公用网、专用网</li><li>按交换技术：<strong>电路交换</strong>（独享占线，结束释放资源）、<strong>报文交换</strong>（存储转发，整体）、<strong>分组交换</strong>（存储转发，切分）</li><li>按拓扑结构：<img src="/2021/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-Part1/image-20211204143437137.png" alt="image-20211204143437137"><ul><li>网状型常用于广域网</li></ul></li><li>按传输技术：<strong>广播式网络</strong>（共享公共通信信道，总线型）、<strong>点对点网络</strong>（使用<strong>分组存储转发</strong>和<strong>路由选择</strong>机制，网状型）</li></ul><h3 id="标准化工作及相关组织（大纲已删）"><a href="#标准化工作及相关组织（大纲已删）" class="headerlink" title="标准化工作及相关组织（大纲已删）"></a>标准化工作及相关组织（大纲已删）</h3><ul><li>标准分类：<ul><li>法定标准：由权威机构指定的正式、合法的标准（如，OSI）</li><li>事实标准：公司产品在竞争中占据了主流（如，TCP/IP、NanoSIM卡）</li></ul></li><li>RCP（Request For Comments）上升为因特网正式标准的四个阶段<ol><li>因特网草案（Internet Draft）这个阶段还不是 RFC 文档。</li><li>建议标准（Proposed Standard）从这个阶段开始成为 RFC 文档。</li><li>草案标准（Draft Standard）现在已经无了</li><li>因特网标准（Internet Standard）</li></ol></li><li>标准化工作的相关组织<ul><li>国际标准化组织 ISO：OSI 模型、HDLC 协议</li><li>国际电信联盟 ITU：制定通信规则</li><li>电气和电子工程师协会 IEEE：学术机构、IEEE802 系列标准、5G</li><li>lnternet 工程任务组 ETF：负责因特网相关标准的制定 RFC XXXX</li></ul></li></ul><h3 id="性能指标（重要）"><a href="#性能指标（重要）" class="headerlink" title="性能指标（重要）"></a>性能指标（重要）</h3><ul><li>速率<ul><li>速率（即数据率、数据传输率、比特率）。</li><li>连接在计算机网络上的<strong>主机</strong>在数字信道上传送数据<strong>位数的速率</strong>。</li><li><img src="/2021/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-Part1/image-20211204145448528.png" alt="image-20211204145448528" style="zoom:80%;"></li></ul></li><li>带宽<ul><li>带宽，表示网络的通信线路传送数据的能力，指单位时间内从网络中的某一点到另一点所能通过的<strong>最高数据率</strong>。单位是“比特每秒”，b/s，kb/s，Mb/s，Gb/s。</li></ul></li><li>吞吐量（严格受速率、带宽影响）<ul><li>吞吐量，表示在单位时间内通过某个网络（或信道、接口）的数据量。单位 b/s</li><li>吞吐量受网络的带宽或网络的额定速率的限制。</li><li><img src="/2021/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-Part1/image-20211204161447674.png" alt="image-20211204161447674" style="zoom:80%;"></li></ul></li><li>时延<ul><li>指数据（报文/分组/比特流）从网络（或链路）的一端传送到另一端所需的时间。也叫延迟或迟延。单位是s。<ul><li>发送时延是在主机上发生的，是打包数据的一个过程</li></ul></li><li><img src="/2021/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-Part1/image-20211204162252397.png" alt="image-20211204162252397" style="zoom:80%;"></li></ul></li><li>时延带宽积<ul><li>时延带宽积又称为以<strong>比特为单位的链路长度</strong>。即“某段链路现在有多少比特”。</li><li><strong>时延带宽积（bit）=传播时延（s） X 带宽（b/s）</strong></li><li><img src="/2021/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-Part1/image-20211204162602897.png" alt="image-20211204162602897" style="zoom:80%;"></li></ul></li><li>往返时间 RTT<ul><li>从发送方发送数据开始，到发送方收到接收方的确认（接收方收到数据后立即发送确认），总共经历的时延。<ul><li>RTT 越大，在收到确认之前，可以发送的数据越多。</li></ul></li><li>RTT 包括：往返传播时延 = 传播时延 * 2 + 末端处理时间</li></ul></li><li>利用率<ul><li><img src="/2021/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-Part1/image-20211204162734961.png" alt="image-20211204162734961" style="zoom:80%;"></li></ul></li></ul><h2 id="计算机网络体系结构与参考模型"><a href="#计算机网络体系结构与参考模型" class="headerlink" title="计算机网络体系结构与参考模型"></a>计算机网络体系结构与参考模型</h2><h3 id="分层结构、协议、接口、服务"><a href="#分层结构、协议、接口、服务" class="headerlink" title="分层结构、协议、接口、服务"></a>分层结构、协议、接口、服务</h3><ul><li>分层的基本原则：<ol><li>各层之间相互<strong>独立</strong>，每层只实现一种相对独立的功能。</li><li>每层之间<strong>界面自然清晰</strong>，易于理解，相互交流尽可能少。</li><li>结构上可分割开。每层都采用<strong>最合适的技术</strong>来实现。</li><li>保持<strong>下层对上层的独立性</strong>，<strong>上层单向使用下层提供的服务</strong>。</li><li>整个分层结构应该能促进标准化工作。</li></ol></li><li>分层结构：<ul><li>实体：第 n 层中的活动元素称为 <strong>n 层实体</strong>。同一层的实体叫<strong>对等实体</strong>。</li><li>协议：为进行网络中的<strong>对等实体</strong>数据交换而建立的规则、标准或约定称为网络协议。（水平）<ul><li>语法：规定传输数据的格式</li><li>语义：规定所要完成的功能</li><li>同步：规定各种操作的顺序</li></ul></li><li>接口（访问服务点 SAP）：上层使用下层服务的入口。</li><li>服务：下层为相邻上层提供的功能调用。（垂直）</li><li><img src="/2021/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-Part1/image-20211204164510627.png" alt="image-20211204164510627"></li><li>SDU 服务数据单元：为完成用户所要求的功能而应传送的数据。</li><li>PCI 协议控制信息：控制协议操作的信息。</li><li>PDU 协议数据单元：对等层次之间传送的数据单位。</li></ul></li><li>概念总结：<ul><li>网络体系结构是从<strong>功能</strong>上描述计算机网络结构。</li><li>计算机网络体系结构，简称网络体系结构，是<strong>分层结构</strong>。</li><li>每层遵循某个/些<strong>网络协议</strong>以完成本层功能。</li><li><strong>计算机网络体系结构</strong>是计算机网络的<strong>各层及其协议</strong>的集合。</li><li>第 n 层在向 n+1 层提供服务时，此服务不仅包含第 n 层本身的功能，还包含由下层服务提供的功能。</li><li>仅仅在<strong>相邻层间有接口</strong>，且所提供服务的具体实现细节对上一层完全屏蔽。</li><li>体系结构是<strong>抽象</strong>的，而实现是指能运行的一些软件和硬件。</li></ul></li></ul><h3 id="ISO-OSI-参考模型（重要）"><a href="#ISO-OSI-参考模型（重要）" class="headerlink" title="ISO/OSI 参考模型（重要）"></a>ISO/OSI 参考模型（重要）</h3><ul><li>目的：支持异构网络系统的互联互通。<ul><li>国际标准化组织（ISO）于1984年提出开放系统互连（OSI）参考模型。理论成功，市场失败。</li></ul></li><li>记忆技巧：<ul><li><img src="/2021/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-Part1/image-20211204165949730.png" alt="image-20211204165949730" style="zoom:67%;"></li></ul></li><li>ISO/OSI 参考模型解释通信过程<ul><li><img src="/2021/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-Part1/image-20211204170249416.png" alt="image-20211204170249416"></li><li>记忆：由于数据链路层是5个字，比其他的多2个字，因此不仅头部要加，尾部也要加。</li><li><img src="/2021/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-Part1/image-20211204170440095.png" alt="image-20211204170440095"></li></ul></li><li>应用层<ul><li>所有能和用户交互产生网络流量的程序</li><li>典型应用层服务：<ul><li>文件传输（FTP）</li><li>电子邮件（SMTP）</li><li>万维网（HTTP）</li></ul></li></ul></li><li>表示层<ul><li>功能<ul><li>数据格式变换</li><li>数据加密解密</li><li>数据压缩和恢复</li></ul></li><li>主要协议：JPEG、ASCII</li></ul></li><li>会话层<ul><li>向表示层实体/用户进程提供<strong>建立连接</strong>并在连接上<strong>有序</strong>地<strong>传输</strong>数据。适用于传输大文件。</li><li>这是会话，也是<strong>建立同步</strong>（SYN）</li><li>功能<ul><li>建立、管理、终止会话</li><li>使用校验点可使会话在通信失效时从<strong>校验点/同步点</strong>继续恢复通信，实现<strong>数据同步</strong>。</li></ul></li><li>主要协议：ADSP、ASP</li></ul></li><li>传输层<ul><li>负责主机中<strong>两个进程</strong>的通信，即<strong>端到端的通信</strong>。</li><li>传输单位是<strong>报文段</strong>或<strong>用户数据报</strong>。</li><li>功能<ul><li><strong>可</strong>靠传输、不可靠传输<ul><li>可靠：必须收到确认才发送下一段数据</li><li>不可靠：直接尽可能快地发送</li></ul></li><li><strong>差</strong>错控制</li><li><strong>流</strong>量控制</li><li>复<strong>用</strong>分用<ul><li>复用：多个应用层进程可同时使用下面运输层的服务。</li><li>分用：运输层把收到的信息分别交付给上面应用层中相应的进程。</li></ul></li></ul></li></ul></li><li>网络层（重要）<ul><li>主要任务是把<strong>分组</strong>从源端传到目的端，为分组交换网上的不同主机提供通信服务。</li><li>网络层传输单位是<strong>数据报</strong>。（将数据报切割成分组）</li><li>功能<ul><li>路由选择</li><li>流量控制</li><li>差错控制</li><li>拥塞控制<ul><li>若所有结点都来不及接受分组，而要丢弃大量分组的话，网络就处于<strong>拥塞</strong>状态。因此要采取一定措施，缓解这种拥塞。</li></ul></li></ul></li><li>主要协议：IP、IPX、ICMP、IGMP、ARP、RARP、OSPF</li></ul></li><li>数据链路层<ul><li>主要任务是把网络层传下来的数据报<strong>组装成帧</strong>。</li><li>数据链路层/链路层的传输单位是<strong>帧</strong>。</li><li>功能<ul><li>成帧（定义帧的开始和结束）</li><li>差错控制（帧错+位错）</li><li>流量控制</li><li>访问/接入控制（控制对信道的访问）</li></ul></li><li>主要协议：SDLC、HDLC、PPP、STP</li></ul></li><li>物理层<ul><li>主要任务是在<strong>物理媒体</strong>上实现比特流的<strong>透明传输</strong>。<ul><li>透明传输：指不管所传数据是什么样的比特组合,都应当能够在链路上传送。</li></ul></li><li>物理层传输单位是<strong>比特</strong>。</li><li>功能<ul><li>定义接口特性</li><li>定义传输模式（单工、半双工、双工）</li><li>定义传输速率</li><li>比特同步</li><li>比特编码</li></ul></li><li>主要协议：Rj45、802.3</li></ul></li></ul><h3 id="TCP-IP-参考模型（重要）"><a href="#TCP-IP-参考模型（重要）" class="headerlink" title="TCP/IP 参考模型（重要）"></a>TCP/IP 参考模型（重要）</h3><ul><li><img src="/2021/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-Part1/image-20211205130054831.png" alt="image-20211205130054831"></li><li>相同点：<ul><li>都分层</li><li>基于独立的协议栈的概念</li><li>可以实现异构网络互联</li></ul></li><li>不同点：<ul><li>OSI 定义三点：服务、协议、接口 </li><li>OSI 先出现，参考模型先于协议发明，不偏向特定协议</li><li>TCP/IP 设计之初就考虑到异构网互联问题，将 IP 作为重要层次</li><li><img src="/2021/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-Part1/image-20211205130712299.png" alt="image-20211205130712299"><ul><li>面向连接分为三个阶段：1. 建立连接，发出一个建立连接的请求；2. 只有在连接成功建立之后，才能开始数据传输；3. 数据传输完毕时，必须释放连接。</li><li>面向无连接：直接进行数据传输。</li></ul></li></ul></li><li><strong>5层参考模型</strong><ul><li><img src="/2021/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-Part1/image-20211205130931484.png" alt="image-20211205130931484"></li><li><img src="/2021/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-Part1/image-20211205130951873.png" alt="image-20211205130951873"></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Python后端部署-Part5</title>
      <link href="/2021/11/Python%E5%90%8E%E7%AB%AF%E9%83%A8%E7%BD%B2-Part5/"/>
      <url>/2021/11/Python%E5%90%8E%E7%AB%AF%E9%83%A8%E7%BD%B2-Part5/</url>
      
        <content type="html"><![CDATA[<h1 id="Python后端部署-Part5——MySQL数据库容器"><a href="#Python后端部署-Part5——MySQL数据库容器" class="headerlink" title="Python后端部署-Part5——MySQL数据库容器"></a>Python后端部署-Part5——MySQL数据库容器</h1><p>[TOC]</p><h2 id="服务器-Mysql-容器配置"><a href="#服务器-Mysql-容器配置" class="headerlink" title="服务器 Mysql 容器配置"></a>服务器 Mysql 容器配置</h2><blockquote><p>参考：<a href="https://www.cnblogs.com/sablier/p/11605606.html#%E4%B8%80%E3%80%81%E5%AE%89%E8%A3%85docker">https://www.cnblogs.com/sablier/p/11605606.html#%E4%B8%80%E3%80%81%E5%AE%89%E8%A3%85docker</a></p></blockquote><h3 id="创建-MySQL-的-Docker-容器"><a href="#创建-MySQL-的-Docker-容器" class="headerlink" title="创建 MySQL 的 Docker 容器"></a>创建 MySQL 的 Docker 容器</h3><ol><li><p>拉取官方镜像（暂时选择5.7）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker pull mysql:5.7   <span class="comment"># 拉取 mysql 5.7</span></span><br></pre></td></tr></table></figure></li><li><p>检查是否拉取成功</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker images</span><br></pre></td></tr></table></figure></li><li><p>创建容器，暂时不建立目录映射</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -p 9050:3306 --name WebService_mysql -e MYSQL_ROOT_PASSWORD=password1 -d mysql:5.7</span><br></pre></td></tr></table></figure><ul><li>–name：容器名，此处命名为 <code>mysql</code></li><li>-e：配置 mysql 的 root 用户的登陆密码</li><li>-p：映射主机9050端口到容器的3306端口</li><li>-d：后台运行容器，保证在退出终端后容器继续运行</li></ul></li><li><p>如果要建立目录映射</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -p 9050:3306 --name WebService_mysql \</span><br><span class="line">    -v /usr/<span class="built_in">local</span>/docker/mysql/conf:/etc/mysql \</span><br><span class="line">    -v /usr/<span class="built_in">local</span>/docker/mysql/logs:/var/<span class="built_in">log</span>/mysql \</span><br><span class="line">    -v /usr/<span class="built_in">local</span>/docker/mysql/data:/var/lib/mysql \</span><br><span class="line">    -e MYSQL_ROOT_PASSWORD=password1 \</span><br><span class="line">    -d mysql:5.7</span><br></pre></td></tr></table></figure><ul><li>-v：主机和容器的目录映射关系，”:”前为主机目录，之后为容器目录</li></ul></li><li><p>检查容器是否正确运行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker ps</span><br></pre></td></tr></table></figure><h3 id="连接-MySql"><a href="#连接-MySql" class="headerlink" title="连接 MySql"></a>连接 MySql</h3></li><li><p>需要进入 docker 本地客户端设置远程访问账号（否则只能在容器内连接数据库）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker <span class="built_in">exec</span> -it mysql bash</span><br><span class="line">$ mysql -uroot -ppassword1</span><br><span class="line">mysql&gt; grant all privileges on *.* to root@<span class="string">&#x27;%&#x27;</span> identified by <span class="string">&quot;password2&quot;</span>;</span><br></pre></td></tr></table></figure></li><li><p>使用远程连接软件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">host: 127.0.0.1</span><br><span class="line">port: 9050</span><br><span class="line">user: root</span><br><span class="line">password: password2</span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      <categories>
          
          <category> Python后端部署 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Python后端部署-Part4</title>
      <link href="/2021/11/Python%E5%90%8E%E7%AB%AF%E9%83%A8%E7%BD%B2-Part4/"/>
      <url>/2021/11/Python%E5%90%8E%E7%AB%AF%E9%83%A8%E7%BD%B2-Part4/</url>
      
        <content type="html"><![CDATA[<h1 id="Python后端部署-Part4——uWSGI与Nginx部署"><a href="#Python后端部署-Part4——uWSGI与Nginx部署" class="headerlink" title="Python后端部署-Part4——uWSGI与Nginx部署"></a>Python后端部署-Part4——uWSGI与Nginx部署</h1><p>[TOC]</p><h2 id="uWSGI"><a href="#uWSGI" class="headerlink" title="uWSGI"></a>uWSGI</h2><h3 id="WSGI-与-uWSGI"><a href="#WSGI-与-uWSGI" class="headerlink" title="WSGI 与 uWSGI"></a>WSGI 与 uWSGI</h3><ul><li>WSGI：<ul><li>WSGI（Web Server Gateway Interface 或者 Python Web Server Gateway Interface），是为 Python 语言定义的 Web 服务器和 Web 应用或框架之间的一种简单而通用的接口。</li><li>WSGI，是网关（Gateway）。网关的作用就是在协议之间进行转换。</li><li>很多框架都自带了 WSGI server，如 Flask、Django 等。但性能都不好，自带的 WebServer 更多的是测试用途，发布时则使用生产环境的 WSGI server。</li></ul></li><li>uWSGI：<ul><li>是一个Web服务器，实现了 WSGI、uwsgi、http 等协议。<ul><li>uwsgi 协议是 uWSGI 服务器自有的协议，用于定义传输信息的类型。</li><li>每一个 uwsgi packet 前 4byte 为传输信息类型描述，uwsgi 与 WSGI 相比是两样东西。</li></ul></li><li>Nginx 中 HttpUwsgiModule 的作用是与 uWSGI 服务器进行交换。</li></ul></li><li>WSGI / uwsgi / uWSGI 区分：<ul><li>WSGI 是一种通信协议。</li><li>uwsgi 同 WSGI 一样是一种通信协议。</li><li>uWSGI 是实现了 uwsgi 和 WSGI 两种协议的 Web 服务器。</li></ul></li><li>为什么有了 uWSGI 为什么还需要 nginx？<ul><li>因为 nginx 具备优秀的静态内容处理能力，然后将动态内容转发给 uWSGI 服务器，这样可以达到很好的客户端响应。 </li></ul></li></ul><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pip install uwsgi<span class="comment"># 安装</span></span><br><span class="line">uwsgi --version    <span class="comment"># 查看 uwsgi 版本</span></span><br></pre></td></tr></table></figure><h3 id="自定义配置文件（常用）"><a href="#自定义配置文件（常用）" class="headerlink" title="自定义配置文件（常用）"></a>自定义配置文件（常用）</h3><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[uwsgi]</span></span><br><span class="line"><span class="comment"># 项目所在的根目录</span></span><br><span class="line"><span class="attr">chdir</span> = /data/WebService/backend</span><br><span class="line"><span class="comment"># 指定项目的application,启动程序文件</span></span><br><span class="line"><span class="comment"># wsgi-file = WebService/wsgi.py</span></span><br><span class="line"><span class="attr">module</span> = WebService.wsgi</span><br><span class="line"><span class="comment"># 指定sock的文件路径，这个sock文件会在nginx的uwsgi_pass配置，用来nginx与uwsgi通信       </span></span><br><span class="line"><span class="comment"># 支持 ip+port 模式以及 socket file 模式</span></span><br><span class="line"><span class="comment"># socket = %(chdir)/uwsgi_conf/uwsgi.sock</span></span><br><span class="line"><span class="attr">socket</span> = <span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">8000</span></span><br><span class="line"><span class="comment"># 指定IP端口，web访问入口</span></span><br><span class="line"><span class="attr">http</span> = <span class="number">0.0</span>.<span class="number">0.0</span>:<span class="number">8000</span></span><br><span class="line"><span class="comment"># 进程个数、线程数</span></span><br><span class="line"><span class="attr">processes</span> = <span class="number">2</span></span><br><span class="line"><span class="attr">threads</span> = <span class="number">4</span></span><br><span class="line"><span class="comment"># 每个进程worker数</span></span><br><span class="line"><span class="attr">workers</span> = <span class="number">5</span></span><br><span class="line"><span class="comment"># uwsgi的进程名称前缀</span></span><br><span class="line"><span class="attr">procname-prefix-spaced</span> = WebService</span><br><span class="line"><span class="comment"># py文件修改，自动加载</span></span><br><span class="line"><span class="attr">py-autoreload</span> = <span class="number">1</span></span><br><span class="line"><span class="comment"># 指定多个静态文件：static目录和media目录,也可以不用指定该静态文件，在nginx中配置静态文件目录</span></span><br><span class="line"><span class="comment"># uwsgi有自己的配置语法，详细可参考官网，无需写绝对路径，可以用循环、判断等高级配置语法</span></span><br><span class="line"><span class="attr">for</span> = static media</span><br><span class="line"><span class="attr">static-map</span> = /static=%(chdir)/static</span><br><span class="line"><span class="comment"># 启动uwsgi的用户名和用户组</span></span><br><span class="line"><span class="attr">uid</span> = root</span><br><span class="line"><span class="attr">gid</span> = root</span><br><span class="line"><span class="comment"># 启动主进程，来管理其他进程，其它的uwsgi进程都是这个master进程的子进程，如果kill这个master进程，相当于重启所有的uwsgi进程。</span></span><br><span class="line"><span class="attr">master</span> = <span class="literal">true</span></span><br><span class="line"><span class="comment"># 当服务停止的时候自动移除unix Socket和pid文件</span></span><br><span class="line"><span class="attr">vacuum</span> = <span class="literal">true</span></span><br><span class="line"><span class="comment"># 序列化接受的内容，如果可能的话</span></span><br><span class="line"><span class="attr">thunder-lock</span> = <span class="literal">true</span></span><br><span class="line"><span class="comment"># 启用线程</span></span><br><span class="line"><span class="attr">enable-threads</span> = <span class="literal">true</span></span><br><span class="line"><span class="comment"># 设置一个超时，用于中断那些超过服务器请求上限的额外请求</span></span><br><span class="line"><span class="attr">harakiri</span>=<span class="number">30</span></span><br><span class="line"><span class="attr">http-timeout</span> = <span class="number">180</span></span><br><span class="line"><span class="attr">socket-timeout</span> = <span class="number">180</span></span><br><span class="line"><span class="comment"># 设置缓冲</span></span><br><span class="line"><span class="attr">post-buffering</span>=<span class="number">4096</span></span><br><span class="line"><span class="attr">buffer-size</span> = <span class="number">65536</span></span><br><span class="line"><span class="comment"># 设置日志目录</span></span><br><span class="line"><span class="attr">daemonize</span>=%(chdir)/uwsgi_conf/uwsgi.log</span><br><span class="line"><span class="comment"># uWSGI进程号存放</span></span><br><span class="line"><span class="attr">pidfile</span>=%(chdir)/uwsgi_conf/uwsgi.pid</span><br><span class="line"><span class="comment"># monitor uwsgi status  通过该端口可以监控 uwsgi 的负载情况</span></span><br><span class="line"><span class="comment"># 支持 ip+port 模式以及 socket file 模式</span></span><br><span class="line"><span class="comment"># stats=%(chdir)/uwsgi_conf/uwsgi.status </span></span><br><span class="line"><span class="attr">stats</span> = <span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">9001</span></span><br><span class="line"><span class="attr">max-requests</span> = <span class="number">1000</span>   </span><br></pre></td></tr></table></figure><h3 id="指令（常用）"><a href="#指令（常用）" class="headerlink" title="指令（常用）"></a>指令（常用）</h3><ul><li>启动 uWSGI：<code>uwsgi --ini uwsgi.ini</code></li><li>关闭 uWSGI：<code>uwsgi --stop uwsgi.pid</code></li></ul><h3 id="管理静态文件"><a href="#管理静态文件" class="headerlink" title="管理静态文件"></a>管理静态文件</h3><blockquote><p>参考：<a href="https://note.qidong.name/2017/07/uwsgi-serve-django-static/">https://note.qidong.name/2017/07/uwsgi-serve-django-static/</a></p></blockquote><p>现象：</p><ul><li>在 uWSGI 下无法访问静态资源，而在 runserver 下则没有问题。</li></ul><p>原因：</p><ul><li>一个 Django 应用，一般有两类静态文件。 一是<strong>应用内的静态文件</strong>，二是 <strong>Django 本身以及第三方库的静态文件</strong>。<ul><li>应用内的静态文件：在与 settings.py 设定的 STATICFILES_DIRS 目录列表中。</li><li>Django 本身以及第三方库的静态文件：INSTALLED_APPS 中配置的 django.contrib.admin、rest_framework 等。<ul><li>例，admin 的静态文件在：/usr/local/lib/python3.6/site-packages/django/contrib/admin/static/admin/。</li></ul></li></ul></li><li>因此 STATICFILES_DIRS 不仅包含了自己存放的应用内的静态文件，还隐含了 Django 本身以及第三方库的静态文件</li><li>而 uWSGI 根本不知道静态文件在什么位置，只有 Django 自己知道。</li></ul><p>解决：</p><ul><li><p>在 Django 的 <code>setting.py</code> 中配置：</p><ul><li>```python<br>STATIC_ROOT = ‘./collectedstatic’  # /data/WebService/backend/collectedstatic<br>STATIC_URL = ‘/static/‘<br>STATICFILES_DIRS = (  # 不能与 STATIC_ROOT 重名<pre><code>os.path.join(BASE_DIR, &#39;static&#39;),</code></pre>)<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 运行 Django 命令：&#96;python3 manage.py collectstatic&#96;</span><br><span class="line"></span><br><span class="line">  - 把所有 STATICFILES_DIRS 目录下的文件，都复制到 STATIC_ROOT 中。 </span><br><span class="line"></span><br><span class="line">- 在配置文件中添加：</span><br><span class="line"></span><br><span class="line">  - &#96;&#96;&#96;ini</span><br><span class="line">    static-map &#x3D; &#x2F;static&#x3D;&#x2F;data&#x2F;WebService&#x2F;backend&#x2F;collectedstatic</span><br></pre></td></tr></table></figure></li><li>通常使用绝对路径，但也支持相对路径。</li></ul></li><li><p>启动 uWSGI ：<code>uwsgi --ini uwsgi.ini</code></p></li></ul><h2 id="Nginx"><a href="#Nginx" class="headerlink" title="Nginx"></a>Nginx</h2><h3 id="安装-1"><a href="#安装-1" class="headerlink" title="安装"></a>安装</h3><ol><li><p>apt</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">   apt-get install nginx</span><br><span class="line"></span><br><span class="line">2. wget</span><br><span class="line"></span><br><span class="line">   ```bash</span><br><span class="line">   wget http://nginx.org/download/nginx-1.5.6.tar.gz</span><br><span class="line">   tar xf nginx-1.5.6.tar.gz</span><br><span class="line">   <span class="built_in">cd</span> nginx-1.5.6</span><br><span class="line">   ./configure --prefix=/usr/<span class="built_in">local</span>/nginx-1.5.6 \</span><br><span class="line">   --with-http_stub_status_module \</span><br><span class="line">   --with-http_gzip_static_module</span><br><span class="line">   make &amp;&amp; make install</span><br></pre></td></tr></table></figure></li><li><p>检查 nginx 是否安装、启动成功</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ /etc/init.d/nginx start</span><br><span class="line">[ ok ] Starting nginx (via systemctl): nginx.service.</span><br><span class="line">$ ps -ef |grep -i nginx</span><br><span class="line">root       6961      1  0 03:56 ?        00:00:00 nginx: master process /usr/sbin/nginx -g daemon on; master_process on;</span><br><span class="line">www-data   6962   6961  0 03:56 ?        00:00:00 nginx: worker process</span><br><span class="line">pala       6985   2090  0 03:57 pts/0    00:00:00 grep --color=auto -i nginx</span><br></pre></td></tr></table></figure></li><li><p>打开浏览器，访问 ip 地址，可以看见 Welcome to nginx!</p></li></ol><h3 id="常用命令（常用）"><a href="#常用命令（常用）" class="headerlink" title="常用命令（常用）"></a>常用命令（常用）</h3><ul><li>启动：<code>/etc/init.d/nginx start</code></li><li>关闭：<code>/etc/init.d/nginx stop</code></li><li>重启：<code>/etc/init.d/nginx restart</code></li></ul><h3 id="自定义配置文件（常用）-1"><a href="#自定义配置文件（常用）-1" class="headerlink" title="自定义配置文件（常用）"></a>自定义配置文件（常用）</h3><ol><li><p>Nginx 的配置目录为 /etc/nginx/conf.d/ 或 /etc/nginx/sites-enabled/</p></li><li><p>创建配置文件：<code>$ vim /etc/nginx/conf.d/xxx.conf</code></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">server&#123;</span><br><span class="line">    <span class="comment"># 需要监听的端口</span></span><br><span class="line">    listen 80;</span><br><span class="line">    <span class="comment"># 如果有域名就是买的域名</span></span><br><span class="line">    server_name 0.0.0.0;</span><br><span class="line">    <span class="comment"># 日志配置</span></span><br><span class="line">    access_log  /var/log/nginx/access.log  main;  </span><br><span class="line">    <span class="comment"># 编码</span></span><br><span class="line">    charset utf-8;</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 启用压缩,这个的作用就是给用户一个网页,比如3M压缩后1M这样传输速度就会提高很多</span></span><br><span class="line">    gzip on;  </span><br><span class="line">    <span class="comment"># 支持压缩的类型</span></span><br><span class="line">    gzip_types text/plain application/x-javascript text/css text/javascript application/x-httpd-php application/json text/json image/jpeg image/gif image/png application/octet-stream;  </span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 错误页面</span></span><br><span class="line">    error_page  404           /404.html;  </span><br><span class="line">    error_page   500 502 503 504  /50x.html;  </span><br><span class="line"></span><br><span class="line">    <span class="comment"># todo 加载静态文件的路径</span></span><br><span class="line">    location /media  &#123;</span><br><span class="line">        alias /data/WebService/backend/media;  # your Django project&#x27;s media files - amend as required</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    location /static &#123;</span><br><span class="line">        alias /data/WebService/backend/static;  # your Django project&#x27;s static files - amend as required</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    location /&#123;</span><br><span class="line">        <span class="comment"># 在nginx里面的文件uwsgi_params</span></span><br><span class="line">        include uwsgi_params;</span><br><span class="line">        <span class="comment"># 跟uwsgi通信的端口</span></span><br><span class="line">        uwsgi_pass 127.0.0.1:8000;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>若还未移动到目录下，则：<code>cp /data/WebService/backend/nginx.conf /etc/nginx/sites-enabled/nginx.conf</code></p></li><li><p>重启 Nginx：<code>$ /etc/init.d/nginx restart</code>  </p></li></ol>]]></content>
      
      
      <categories>
          
          <category> Python后端部署 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Python后端部署-Part3</title>
      <link href="/2021/11/Python%E5%90%8E%E7%AB%AF%E9%83%A8%E7%BD%B2-Part3/"/>
      <url>/2021/11/Python%E5%90%8E%E7%AB%AF%E9%83%A8%E7%BD%B2-Part3/</url>
      
        <content type="html"><![CDATA[<h1 id="Python后端部署-Part3——Supervisor进程管理"><a href="#Python后端部署-Part3——Supervisor进程管理" class="headerlink" title="Python后端部署-Part3——Supervisor进程管理"></a>Python后端部署-Part3——Supervisor进程管理</h1><p>[TOC]</p><h2 id="nohup"><a href="#nohup" class="headerlink" title="nohup"></a>nohup</h2><ul><li><p>用途：不挂断地运行命令。</p></li><li><p>语法：<code>nohup Command [ Arg … ] [　&amp; ]</code></p><ul><li>Command：要执行的命令。</li><li>Arg：一些参数，可以指定输出文件。</li><li>&amp;：让命令在后台执行，终端退出后命令仍旧执行。</li></ul></li><li><p>启动进程：</p><ul><li><pre><code class="bash">nohup python3 /data/WebService/backend/manage.py runserver 0.0.0.0:8000 &gt;&gt;/data/WebService/backend/log/output.log 2&gt;&amp;1 &amp;<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  - 2&gt;&amp;1：将标准错误 2 重定向到标准输出 &amp;1 ，标准输出 &amp;1 再被重定向输入到 runoob.log 文件中。</span><br><span class="line"></span><br><span class="line">    - 0 – stdin（standard input，标准输入）</span><br><span class="line">    - 1 – stdout（standard output，标准输出）</span><br><span class="line">    - 2 – stderr（standard error，标准错误输出）</span><br><span class="line"></span><br><span class="line">- 终止进程：</span><br><span class="line"></span><br><span class="line">  - &#96;&#96;&#96;bash</span><br><span class="line">    ps -aux | grep manage.py</span><br><span class="line">    ps -aux | grep manage.py | grep -v grep | awk &#39;&#123;print $2&#125;&#39;</span><br></pre></td></tr></table></figure></code></pre></li><li><p>参数说明：</p><ul><li>a : 显示所有程序</li><li>u : 以用户为主的格式来显示</li><li>x : 显示所有程序，不区分终端机</li></ul></li><li><p>```bash<br>kill -9  进程号PID</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">## Supervisor</span><br><span class="line"></span><br><span class="line">### 简介</span><br><span class="line"></span><br><span class="line">- Supervisor 是用 Python 开发的一套通用的进程管理程序，能将一个普通的命令行进程变为后台 daemon，并监控进程状态，异常退出时能自动重启。</span><br><span class="line">- 它是通过 fork&#x2F;exec 的方式把这些被管理的进程当作 supervisor 的子进程来启动，这样只要在 supervisor 的配置文件中，把要管理的进程的可执行文件的路径写进去即可。也实现当子进程挂掉的时候，父进程可以准确获取子进程挂掉的信息的，可以选择是否自己启动和报警。</span><br><span class="line">- Supervisor 还提供了一个功能，可以为 supervisord 或者每个子进程，设置一个非 root 的 user，这个 user 就可以管理它对应的进程。</span><br><span class="line"></span><br><span class="line">### 安装</span><br><span class="line"></span><br><span class="line">1. 配置好 yum 源后，可以直接安装</span><br><span class="line"></span><br><span class="line">   &#96;&#96;&#96;bash</span><br><span class="line">   yum install supervisor</span><br></pre></td></tr></table></figure></li></ul></li></ul><ol start="2"><li><p>Debian/Ubuntu 可通过 apt 安装</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt-get install supervisor</span><br></pre></td></tr></table></figure></li><li><p>pip 安装</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install supervisor</span><br></pre></td></tr></table></figure><h3 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h3></li></ol><h4 id="默认配置文件"><a href="#默认配置文件" class="headerlink" title="默认配置文件"></a>默认配置文件</h4><ul><li>默认配置文件：<code>/etc/supervisor/supervisord.conf</code>（可能会在不同的地方）</li><li>默认配置文件一般不需要改动，直接定义自己的配置文件即可</li></ul><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[unix_http_server]</span></span><br><span class="line"><span class="attr">file</span>=/tmp/supervisor.sock   <span class="comment">;UNIX socket 文件，supervisorctl 会使用</span></span><br><span class="line"><span class="comment">;chmod=0700                 ;socket文件的mode，默认是0700</span></span><br><span class="line"><span class="comment">;chown=nobody:nogroup       ;socket文件的owner，格式：uid:gid</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">;[inet_http_server]         ;HTTP服务器，提供web管理界面</span></span><br><span class="line"><span class="comment">;port=127.0.0.1:9001        ;Web管理后台运行的IP和端口，如果开放到公网，需要注意安全性</span></span><br><span class="line"><span class="comment">;username=user              ;登录管理后台的用户名</span></span><br><span class="line"><span class="comment">;password=123               ;登录管理后台的密码</span></span><br><span class="line"> </span><br><span class="line"><span class="section">[supervisord]</span></span><br><span class="line"><span class="attr">logfile</span>=/tmp/supervisord.log <span class="comment">;日志文件，默认是 $CWD/supervisord.log</span></span><br><span class="line"><span class="attr">logfile_maxbytes</span>=<span class="number">50</span>MB        <span class="comment">;日志文件大小，超出会rotate，默认 50MB，如果设成0，表示不限制大小</span></span><br><span class="line"><span class="attr">logfile_backups</span>=<span class="number">10</span>           <span class="comment">;日志文件保留备份数量默认10，设为0表示不备份</span></span><br><span class="line"><span class="attr">loglevel</span>=info                <span class="comment">;日志级别，默认info，其它: debug,warn,trace</span></span><br><span class="line"><span class="attr">pidfile</span>=/tmp/supervisord.pid <span class="comment">;pid 文件</span></span><br><span class="line"><span class="attr">nodaemon</span>=<span class="literal">false</span>               <span class="comment">;是否在前台启动，默认是false，即以 daemon 的方式启动</span></span><br><span class="line"><span class="attr">minfds</span>=<span class="number">1024</span>                  <span class="comment">;可以打开的文件描述符的最小值，默认 1024</span></span><br><span class="line"><span class="attr">minprocs</span>=<span class="number">200</span>                 <span class="comment">;可以打开的进程数的最小值，默认 200</span></span><br><span class="line"> </span><br><span class="line"><span class="section">[supervisorctl]</span></span><br><span class="line"><span class="attr">serverurl</span>=unix:///tmp/supervisor.sock <span class="comment">;通过UNIX socket连接supervisord，路径与unix_http_server部分的file一致</span></span><br><span class="line"><span class="comment">;serverurl=http://127.0.0.1:9001 ; 通过HTTP的方式连接supervisord</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">; [program:xx]是被管理的进程配置参数，xx是进程的名称</span></span><br><span class="line"><span class="section">[program:xx]</span></span><br><span class="line"><span class="attr">command</span>=/opt/apache-tomcat-<span class="number">8.0</span>.<span class="number">35</span>/bin/catalina.sh run  <span class="comment">; 程序启动命令</span></span><br><span class="line"><span class="attr">autostart</span>=<span class="literal">true</span>       <span class="comment">; 在supervisord启动的时候也自动启动</span></span><br><span class="line"><span class="attr">startsecs</span>=<span class="number">10</span>         <span class="comment">; 启动10秒后没有异常退出，就表示进程正常启动了，默认为1秒</span></span><br><span class="line"><span class="attr">autorestart</span>=<span class="literal">true</span>     <span class="comment">; 程序退出后自动重启,可选值：[unexpected,true,false]，默认为unexpected，表示进程意外杀死后才重启</span></span><br><span class="line"><span class="attr">startretries</span>=<span class="number">3</span>       <span class="comment">; 启动失败自动重试次数，默认是3</span></span><br><span class="line"><span class="attr">user</span>=tomcat          <span class="comment">; 用哪个用户启动进程，默认是root</span></span><br><span class="line"><span class="attr">priority</span>=<span class="number">999</span>         <span class="comment">; 进程启动优先级，默认999，值小的优先启动</span></span><br><span class="line"><span class="attr">redirect_stderr</span>=<span class="literal">true</span> <span class="comment">; 把stderr重定向到stdout，默认false</span></span><br><span class="line"><span class="attr">stdout_logfile_maxbytes</span>=<span class="number">20</span>MB  <span class="comment">; stdout 日志文件大小，默认50MB</span></span><br><span class="line"><span class="attr">stdout_logfile_backups</span> = <span class="number">20</span>   <span class="comment">; stdout 日志文件备份数，默认是10</span></span><br><span class="line"><span class="comment">; stdout 日志文件，需要注意当指定目录不存在时无法正常启动，所以需要手动创建目录（supervisord 会自动创建日志文件）</span></span><br><span class="line"><span class="attr">stdout_logfile</span>=/opt/apache-tomcat-<span class="number">8.0</span>.<span class="number">35</span>/logs/catalina.out</span><br><span class="line"><span class="attr">stopasgroup</span>=<span class="literal">false</span>     <span class="comment">;默认为false,进程被杀死时，是否向这个进程组发送stop信号，包括子进程</span></span><br><span class="line"><span class="attr">killasgroup</span>=<span class="literal">false</span>     <span class="comment">;默认为false，向进程组发送kill信号，包括子进程</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">;包含其它配置文件</span></span><br><span class="line"><span class="section">[include]</span></span><br><span class="line"><span class="attr">files</span> = relative/directory/*.ini    <span class="comment">;可以指定一个或多个以.ini结束的配置文件</span></span><br></pre></td></tr></table></figure><h4 id="自定义子进程配置文件（常用）"><a href="#自定义子进程配置文件（常用）" class="headerlink" title="自定义子进程配置文件（常用）"></a>自定义子进程配置文件（常用）</h4><ul><li>自定义的子进程配置文件路径：<code>/etc/supervisor/conf.d/</code></li></ul><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 项目名</span></span><br><span class="line"><span class="section">[program:WebService]</span></span><br><span class="line"><span class="comment"># 脚本目录</span></span><br><span class="line"><span class="attr">directory</span>=/data/WebService/backend</span><br><span class="line"><span class="comment"># 脚本执行命令</span></span><br><span class="line"><span class="attr">command</span>=python3 /data/WebService/backend/manage.py runserver <span class="number">0.0</span>.<span class="number">0.0</span>:<span class="number">8000</span></span><br><span class="line"><span class="comment">; command=uwsgi --ini /data/WebService/backend/start.ini</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#supervisor启动的时候是否随着同时启动，默认True</span></span><br><span class="line"><span class="attr">autostart</span>=<span class="literal">true</span></span><br><span class="line"><span class="comment"># 当程序exit的时候，这个program不会自动重启,默认unexpected，设置子进程挂掉后自动重启的情况，</span></span><br><span class="line"><span class="comment"># 有三个选项，false,unexpected和true。</span></span><br><span class="line"><span class="comment"># 如果为false的时候，无论什么情况下，都不会被重新启动，</span></span><br><span class="line"><span class="comment"># 如果为unexpected，只有当进程的退出码不在下面的exitcodes里面定义的</span></span><br><span class="line"><span class="attr">autorestart</span>=unexpected</span><br><span class="line"><span class="comment"># 这个选项是子进程启动多少秒之后，此时状态如果是running，则我们认为启动成功了。默认值为1</span></span><br><span class="line"><span class="attr">startsecs</span>=<span class="number">1</span></span><br><span class="line"><span class="comment"># 脚本运行的用户身份</span></span><br><span class="line"><span class="attr">user</span> = test</span><br><span class="line"><span class="comment"># 日志输出</span></span><br><span class="line"><span class="attr">stderr_logfile</span>=/data/WebService/backend/log/web_err.log</span><br><span class="line"><span class="attr">stdout_logfile</span>=/data/WebService/backend/log/web_out.log</span><br><span class="line"><span class="comment"># 把stderr重定向到stdout，默认 false</span></span><br><span class="line"><span class="attr">redirect_stderr</span> = <span class="literal">true</span></span><br><span class="line"><span class="comment"># stdout日志文件大小，默认 50MB</span></span><br><span class="line"><span class="attr">stdout_logfile_maxbytes</span> = <span class="number">50</span>MB</span><br><span class="line"><span class="comment"># stdout日志文件备份数</span></span><br><span class="line"><span class="attr">stdout_logfile_backups</span> = <span class="number">20</span></span><br></pre></td></tr></table></figure><blockquote><p>注意：supervisor 不能监控后台进程，因此 command 不能为后台运行命令</p></blockquote><h3 id="启动服务"><a href="#启动服务" class="headerlink" title="启动服务"></a>启动服务</h3><h4 id="supervisord-直接启动"><a href="#supervisord-直接启动" class="headerlink" title="supervisord 直接启动"></a>supervisord 直接启动</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">supervisord -c /etc/supervisor/supervisord.conf</span><br></pre></td></tr></table></figure><h4 id="systemctl-命令启动"><a href="#systemctl-命令启动" class="headerlink" title="systemctl 命令启动"></a>systemctl 命令启动</h4><ul><li>编辑配置文件</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /usr/lib/systemd/system/supervisord.service</span><br></pre></td></tr></table></figure><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[Unit]</span></span><br><span class="line"><span class="attr">Description</span>=Supervisor daemon</span><br><span class="line"></span><br><span class="line"><span class="section">[Service]</span></span><br><span class="line"><span class="attr">Type</span>=forking</span><br><span class="line"><span class="attr">PIDFile</span>=/home/supervisor/supervisord.pid</span><br><span class="line"><span class="attr">ExecStart</span>=/usr/local/python3/bin/supervisord -c /etc/supervisord.conf</span><br><span class="line"><span class="attr">ExecStop</span>=/usr/local/python3/bin/supervisorctl shutdown</span><br><span class="line"><span class="attr">ExecReload</span>=/usr/local/python3/bin/supervisorctl reload</span><br><span class="line"><span class="attr">KillMode</span>=process</span><br><span class="line"><span class="attr">Restart</span>=<span class="literal">on</span>-failure</span><br><span class="line"><span class="attr">RestartSec</span>=<span class="number">42</span>s</span><br><span class="line"></span><br><span class="line"><span class="section">[Install]</span></span><br><span class="line"><span class="attr">WantedBy</span>=multi-user.target</span><br></pre></td></tr></table></figure><ul><li>常用命令</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">systemctl stop supervisord</span><br><span class="line">systemctl start supervisord</span><br><span class="line">systemctl status supervisord</span><br><span class="line">systemctl reload supervisord</span><br><span class="line">systemctl restart supervisord</span><br></pre></td></tr></table></figure><h3 id="常用命令（常用）"><a href="#常用命令（常用）" class="headerlink" title="常用命令（常用）"></a>常用命令（常用）</h3><ol><li><p><code>supervisorctl status all</code>：查看所有进程的状态</p></li><li><p><code>supervisorctl stop [program]</code>：停止 program</p><ul><li>program 换成 all 可以管理配置中的所有进程</li></ul></li><li><p><code>supervisorctl start [program]</code>：启动 program</p></li><li><p><code>supervisorctl restart [program]</code>：重启 program</p></li><li><p><code>supervisorctl update</code>：配置文件修改后可以使用该命令加载新的配置</p><ul><li><pre><code class="bash">$ cp /data/WebService/backend/supervisor.conf /etc/supervisor/conf.d/supervisor.conf$ supervisorctl updateWebService: added process group  # 其实这个时候已经开始运行后台了<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">6. &#96;supervisorctl reload&#96;：重新启动 supervisor</span><br><span class="line"></span><br><span class="line">   - &#96;&#96;&#96;bash</span><br><span class="line">     $ supervisorctl reload</span><br><span class="line">     Restarted supervisord</span><br></pre></td></tr></table></figure>### 常见问题</code></pre></li></ul></li><li><p>unix:///var/run/supervisor/supervisor.sock no such file</p><ul><li>没有开启服务。<code>supervisord -c /etc/supervisor/supervisord.conf</code> </li></ul></li><li><p>启动了多个 supervisord 服务，导致无法正常关闭服务</p><ul><li>使用 <code>ps -fe | grep supervisord</code> 查看所有启动过的 supervisord 服务，kill 相关的进程 <code>kill -9 进程号</code>。</li></ul></li><li><p>启动 uwsgi 时要注释 uwsgi 里的如下配置，否则 supervisorctl 启动时会报错</p><ul><li><pre><code class="ini">; daemonize = /home/apps/logManage/logs/uwsgi.log; pidfile = /home/apps/logManage/conf/uwsgi.pid; 可以增加 logto配置logto = /home/apps/logManage/logs/uwsgi.log  </code></pre></li></ul></li><li><p>bind(): Address already in use [core/socket.c line 769]</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> Python后端部署 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Python后端部署-Part2</title>
      <link href="/2021/11/Python%E5%90%8E%E7%AB%AF%E9%83%A8%E7%BD%B2-Part2/"/>
      <url>/2021/11/Python%E5%90%8E%E7%AB%AF%E9%83%A8%E7%BD%B2-Part2/</url>
      
        <content type="html"><![CDATA[<h1 id="Python后端部署-Part2——Django登录验证"><a href="#Python后端部署-Part2——Django登录验证" class="headerlink" title="Python后端部署-Part2——Django登录验证"></a>Python后端部署-Part2——Django登录验证</h1><p>[TOC]</p><h2 id="登录验证的实现思路"><a href="#登录验证的实现思路" class="headerlink" title="登录验证的实现思路"></a>登录验证的实现思路</h2><blockquote><p>参考：</p><ul><li><a href="https://blog.csdn.net/weixin_41861301/article/details/119519785">https://blog.csdn.net/weixin_41861301/article/details/119519785</a></li><li><a href="https://www.jianshu.com/p/902b18a6bd78">https://www.jianshu.com/p/902b18a6bd78</a></li></ul></blockquote><ul><li>采用 token 认证方式，使用 rest_framework_simplejwt 库配置权限认证。</li><li>Simple JWT 为 Django REST Framework 框架提供了一个 JSON Web 令牌认证后端。</li><li>注意：使用 rest_framework_simplejwt 进行身份认证时并不需要去对数据库进行查询校验，所以并不会将 token 保存在数据库中。</li></ul><h2 id="安装使用-rest-framework"><a href="#安装使用-rest-framework" class="headerlink" title="安装使用 rest_framework"></a>安装使用 rest_framework</h2><ol><li><p>安装</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install djangorestframework</span><br></pre></td></tr></table></figure></li><li><p>添加 <code>rest_framework</code> 到 <code>INSTALLED_APPS</code> 设置中</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -&gt; backend/WebService/settings.py</span></span><br><span class="line"></span><br><span class="line">INSTALLED_APPS = [</span><br><span class="line">    ...</span><br><span class="line">    <span class="string">&#x27;rest_framework&#x27;</span>,  <span class="comment"># DRF</span></span><br><span class="line">]</span><br></pre></td></tr></table></figure></li><li><p>若使用 DRF 的可浏览 API，则修改路由 <code>urls.py</code>（在生产环境中是不需要的）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -&gt; backend/WebService/urls.py</span></span><br><span class="line"></span><br><span class="line">urlpatterns = [</span><br><span class="line">    ...</span><br><span class="line">    path(<span class="string">&#x27;api-auth/&#x27;</span>, include(<span class="string">&#x27;rest_framework.urls&#x27;</span>)),</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h2 id="安装使用-rest-framework-simplejwt"><a href="#安装使用-rest-framework-simplejwt" class="headerlink" title="安装使用 rest_framework_simplejwt"></a>安装使用 rest_framework_simplejwt</h2></li><li><p>安装</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install djangorestframework_simplejwt</span><br></pre></td></tr></table></figure></li><li><p>添加 <code>rest_framework_simplejwt</code> 到 <code>INSTALLED_APPS</code> 设置中</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -&gt; backend/WebService/settings.py</span></span><br><span class="line"></span><br><span class="line">INSTALLED_APPS = [</span><br><span class="line">    ...</span><br><span class="line">    <span class="string">&#x27;rest_framework.authtoken&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;rest_framework_simplejwt&#x27;</span>,  <span class="comment"># jwt</span></span><br><span class="line">]</span><br></pre></td></tr></table></figure></li><li><p>将 Simple JWT 的 JSON Web 令牌认证添加到身份验证类列表中</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -&gt; backend/WebService/settings.py</span></span><br><span class="line"></span><br><span class="line">REST_FRAMEWORK = &#123;</span><br><span class="line">    <span class="comment"># 全局的权限认证，只有通过认证后才赋予用户权限</span></span><br><span class="line">    <span class="string">&#x27;DEFAULT_PERMISSION_CLASSES&#x27;</span>: (</span><br><span class="line">        <span class="string">&#x27;rest_framework.permissions.IsAuthenticated&#x27;</span>,</span><br><span class="line">    ),</span><br><span class="line">    <span class="comment"># 身份验证类列表，可以设定多个身份验证</span></span><br><span class="line">    <span class="string">&#x27;DEFAULT_AUTHENTICATION_CLASSES&#x27;</span>: (</span><br><span class="line">        <span class="string">&#x27;rest_framework_simplejwt.authentication.JWTAuthentication&#x27;</span>,</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>配置 JWT 相关参数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -&gt; backend/WebService/settings.py</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> timedelta</span><br><span class="line"></span><br><span class="line">SIMPLE_JWT = &#123;</span><br><span class="line">    <span class="string">&#x27;ACCESS_TOKEN_LIFETIME&#x27;</span>: timedelta(minutes=<span class="number">1</span>),  <span class="comment"># token 的过期时间</span></span><br><span class="line">    <span class="string">&#x27;REFRESH_TOKEN_LIFETIME&#x27;</span>: timedelta(days=<span class="number">15</span>),  <span class="comment"># 刷新 token 的过期时间</span></span><br><span class="line">    <span class="comment"># &#x27;AUTH_HEADER_TYPES&#x27;: (&#x27;Bearer&#x27;, &#x27;JWT&#x27;),  # token 的请求头类型</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在任意的路由配置中添加 Simple JWT 提供的视图（这里将登录验证模块集成到 login 应用下）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -&gt; backend/login/urls.py</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> django.urls <span class="keyword">import</span> path</span><br><span class="line"><span class="keyword">from</span> rest_framework_simplejwt.views <span class="keyword">import</span> TokenObtainPairView, TokenRefreshView, TokenVerifyView</span><br><span class="line"></span><br><span class="line">urlpatterns = [</span><br><span class="line">    path(<span class="string">&#x27;token/&#x27;</span>, TokenObtainPairView.as_view(), name=<span class="string">&#x27;token_obtain_pair&#x27;</span>),  <span class="comment"># POST 登录接口</span></span><br><span class="line">    path(<span class="string">&#x27;token/refresh/&#x27;</span>, TokenRefreshView.as_view(), name=<span class="string">&#x27;token_refresh&#x27;</span>),  <span class="comment"># POST 刷新token接口</span></span><br><span class="line">    path(<span class="string">&#x27;token/verify/&#x27;</span>, TokenVerifyView.as_view(), name=<span class="string">&#x27;token_verify&#x27;</span>),  <span class="comment"># POST 验证token接口 用于vue前端写路由守卫</span></span><br><span class="line">...</span><br><span class="line">]</span><br></pre></td></tr></table></figure></li><li><p>如果自定义用户表</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -&gt; backend/WebService/settings.py</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># AUTH_USER_MODEL 配置默认的校验用户表</span></span><br><span class="line">AUTH_USER_MODEL = <span class="string">&#x27;login.UserInfo&#x27;</span> </span><br></pre></td></tr></table></figure><h2 id="安装使用-django-simple-captcha"><a href="#安装使用-django-simple-captcha" class="headerlink" title="安装使用 django-simple-captcha"></a>安装使用 django-simple-captcha</h2></li><li><p>安装</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install django-simple-captcha</span><br></pre></td></tr></table></figure></li><li><p>添加 <code>captcha</code> 到 <code>INSTALLED_APPS</code> 中</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -&gt; backend/WebService/settings.py</span></span><br><span class="line"></span><br><span class="line">INSTALLED_APPS = [</span><br><span class="line">    ...</span><br><span class="line">    <span class="string">&#x27;captcha&#x27;</span>,  <span class="comment"># 生成验证码</span></span><br><span class="line">]</span><br></pre></td></tr></table></figure></li><li><p>需要更新数据库</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">python manage.py makemigrations</span><br><span class="line">python manage.py migrate</span><br></pre></td></tr></table></figure><h2 id="无验证码的登录验证"><a href="#无验证码的登录验证" class="headerlink" title="无验证码的登录验证"></a>无验证码的登录验证</h2></li><li><p>其实配置完 simplejwt 时，即可直接使用登录验证。</p><ul><li><p>创建超级用户，命令行输入：<code>python3 manage.py createsuperuser</code></p></li><li><p>使用 post 请求获取 token 令牌</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">headers：Content-Type:application/json</span><br><span class="line">body：&#123;&quot;username&quot;: &quot;admin&quot;, &quot;password&quot;: &quot;admin&quot;&#125;</span><br></pre></td></tr></table></figure></li><li><p>携带 token 令牌请求访问后端</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">body: &#123;&quot;token&quot;: &quot;token&quot;&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>之后编写的其他视图函数，都要继承 <code>from rest_framework.views import APIView </code>，否则将无法进行身份验证。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -&gt; backend/login/views.py</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> rest_framework.views <span class="keyword">import</span> APIView</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">test</span>(<span class="params">APIView</span>):</span>  <span class="comment"># 使用 token 之后，应当继承 APIView 类</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span>(<span class="params">self, request</span>):</span></span><br><span class="line">        <span class="keyword">return</span> JsonResponse(&#123;<span class="string">&quot;msg&quot;</span>: <span class="string">&quot;ok&quot;</span>&#125;, json_dumps_params=&#123;<span class="string">&quot;ensure_ascii&quot;</span>: <span class="literal">False</span>&#125;)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">test_no_login</span>(<span class="params">APIView</span>):</span>  <span class="comment"># 不需要进行登录验证的逻辑则添加 permission_classes = []</span></span><br><span class="line">    permission_classes = []</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span>(<span class="params">self, request</span>):</span></span><br><span class="line">        <span class="keyword">return</span> JsonResponse(&#123;<span class="string">&quot;msg&quot;</span>: <span class="string">&quot;ok&quot;</span>&#125;, json_dumps_params=&#123;<span class="string">&quot;ensure_ascii&quot;</span>: <span class="literal">False</span>&#125;)</span><br></pre></td></tr></table></figure><h2 id="带验证码的登录验证"><a href="#带验证码的登录验证" class="headerlink" title="带验证码的登录验证"></a>带验证码的登录验证</h2></li></ol><h3 id="构造返回验证码的视图"><a href="#构造返回验证码的视图" class="headerlink" title="构造返回验证码的视图"></a>构造返回验证码的视图</h3><ol><li><p>返回验证码的视图接口</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -&gt; backend/login/views.py</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">from</span> django.http <span class="keyword">import</span> HttpResponse</span><br><span class="line"><span class="keyword">from</span> captcha.views <span class="keyword">import</span> CaptchaStore, captcha_image</span><br><span class="line"><span class="keyword">from</span> django.views <span class="keyword">import</span> View</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CaptchaAPIView</span>(<span class="params">View</span>):</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span>(<span class="params">self, request</span>):</span></span><br><span class="line">        hash_key = CaptchaStore.generate_key()</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="comment"># 获取图片id</span></span><br><span class="line">            id_ = CaptchaStore.objects.<span class="built_in">filter</span>(hashkey=hash_key).first().<span class="built_in">id</span></span><br><span class="line">            image = captcha_image(request, hash_key)</span><br><span class="line">            <span class="comment"># 将图片转换为base64</span></span><br><span class="line">            image_base = <span class="string">&#x27;data:image/png;base64,%s&#x27;</span> % base64.b64encode(image.content).decode(<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">            json_data = json.dumps(&#123;<span class="string">&quot;id&quot;</span>: id_, <span class="string">&quot;image_base&quot;</span>: image_base&#125;)</span><br><span class="line">            <span class="comment"># 批量删除过期验证码</span></span><br><span class="line">            CaptchaStore.remove_expired()</span><br><span class="line">        <span class="keyword">except</span>:</span><br><span class="line">            json_data = <span class="literal">None</span></span><br><span class="line">        <span class="keyword">return</span> HttpResponse(json_data, content_type=<span class="string">&quot;application/json&quot;</span>)</span><br></pre></td></tr></table></figure></li><li><p>添加验证码视图的接口路由</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -&gt; backend/login/urls.py</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> django.urls <span class="keyword">import</span> path</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> login.views <span class="keyword">import</span> CaptchaAPIView</span><br><span class="line"></span><br><span class="line">urlpatterns = [</span><br><span class="line">    ...</span><br><span class="line">    path(<span class="string">&#x27;captcha/&#x27;</span>, CaptchaAPIView.as_view(), name=<span class="string">&#x27;captcha_api&#x27;</span>),  <span class="comment"># GET 返回验证码接口</span></span><br><span class="line">]</span><br></pre></td></tr></table></figure><h3 id="重写带验证码的登录视图"><a href="#重写带验证码的登录视图" class="headerlink" title="重写带验证码的登录视图"></a>重写带验证码的登录视图</h3></li><li><p>构造一个手动返回令牌的方法</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -&gt; backend/login/utils/get_token.py</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> rest_framework_simplejwt.tokens <span class="keyword">import</span> RefreshToken</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_tokens_for_user</span>(<span class="params">user</span>):</span></span><br><span class="line">    <span class="comment"># 手动返回令牌</span></span><br><span class="line">    refresh = RefreshToken.for_user(user)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="string">&#x27;refresh&#x27;</span>: <span class="built_in">str</span>(refresh),</span><br><span class="line">        <span class="string">&#x27;access&#x27;</span>: <span class="built_in">str</span>(refresh.access_token),</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li><li><p>在扩展 <code>TokenObtainPairView</code> 视图前先扩展该序列化类 <code>TokenObtainPairSerializer</code> </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -&gt; backend/login/serializer.py</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> django.utils <span class="keyword">import</span> timezone</span><br><span class="line"><span class="keyword">from</span> rest_framework <span class="keyword">import</span> serializers</span><br><span class="line"><span class="keyword">from</span> rest_framework_simplejwt.serializers <span class="keyword">import</span> TokenObtainPairSerializer</span><br><span class="line"><span class="keyword">from</span> django.contrib.auth <span class="keyword">import</span> authenticate</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> captcha.fields <span class="keyword">import</span> CaptchaStore</span><br><span class="line"><span class="keyword">from</span> login.utils.get_token <span class="keyword">import</span> get_tokens_for_user</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DmallTokenObtainPairSerializer</span>(<span class="params">TokenObtainPairSerializer</span>):</span></span><br><span class="line">    captcha = serializers.CharField(max_length=<span class="number">4</span>, required=<span class="literal">True</span>,</span><br><span class="line">                                    trim_whitespace=<span class="literal">True</span>, min_length=<span class="number">4</span>,</span><br><span class="line">                                    error_messages=&#123;</span><br><span class="line">                                        <span class="string">&quot;max_length&quot;</span>: <span class="string">&quot;图片验证码仅允许4位&quot;</span>,</span><br><span class="line">                                        <span class="string">&quot;min_length&quot;</span>: <span class="string">&quot;图片验证码仅允许4位&quot;</span>,</span><br><span class="line">                                        <span class="string">&quot;required&quot;</span>: <span class="string">&quot;请输入图片验证码&quot;</span></span><br><span class="line">                                    &#125;, help_text=<span class="string">&quot;图片验证码&quot;</span>)</span><br><span class="line">    imgcode_id = serializers.CharField(required=<span class="literal">True</span>, write_only=<span class="literal">True</span>,</span><br><span class="line">                                       help_text=<span class="string">&quot;图片验证码id&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_token</span>(<span class="params">cls, user</span>):</span></span><br><span class="line">        token = <span class="built_in">super</span>().get_token(user)</span><br><span class="line">        token[<span class="string">&#x27;captcha&#x27;</span>] = user.captcha</span><br><span class="line">        token[<span class="string">&#x27;imgcode_id&#x27;</span>] = user.imgcode_id</span><br><span class="line">        <span class="keyword">return</span> token</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">validate_captcha</span>(<span class="params">self, captcha</span>):</span></span><br><span class="line">        <span class="comment"># 验证码验证</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            captcha = captcha.lower()</span><br><span class="line">        <span class="keyword">except</span>:</span><br><span class="line">            <span class="keyword">raise</span> serializers.ValidationError(<span class="string">&quot;验证码错误&quot;</span>)</span><br><span class="line">        img_code = CaptchaStore.objects.<span class="built_in">filter</span>(</span><br><span class="line">            <span class="built_in">id</span>=<span class="built_in">int</span>(self.initial_data[<span class="string">&#x27;imgcode_id&#x27;</span>])</span><br><span class="line">        ).first()</span><br><span class="line">        <span class="keyword">if</span> img_code <span class="keyword">and</span> timezone.now() &gt; img_code.expiration:</span><br><span class="line">            <span class="keyword">raise</span> serializers.ValidationError(<span class="string">&quot;图片验证码过期&quot;</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">if</span> img_code <span class="keyword">and</span> img_code.response == captcha:</span><br><span class="line">                <span class="keyword">pass</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">raise</span> serializers.ValidationError(<span class="string">&quot;验证码错误&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">validate</span>(<span class="params">self, attrs</span>):</span></span><br><span class="line">        <span class="comment"># 删除验证码</span></span><br><span class="line">        <span class="keyword">del</span> attrs[<span class="string">&#x27;captcha&#x27;</span>]</span><br><span class="line">        <span class="keyword">del</span> attrs[<span class="string">&#x27;imgcode_id&#x27;</span>]</span><br><span class="line">        authenticate_kwargs = &#123;</span><br><span class="line">            <span class="string">&#x27;username&#x27;</span>: attrs[<span class="string">&#x27;username&#x27;</span>],</span><br><span class="line">            <span class="string">&#x27;password&#x27;</span>: attrs[<span class="string">&#x27;password&#x27;</span>],</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment"># 验证当前登录用户</span></span><br><span class="line">        self.user = authenticate(**authenticate_kwargs)</span><br><span class="line">        <span class="keyword">if</span> self.user <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">raise</span> serializers.ValidationError(<span class="string">&#x27;账号或密码不正确&#x27;</span>)</span><br><span class="line">        <span class="comment"># 登录成功返回token信息</span></span><br><span class="line">        token = get_tokens_for_user(self.user)</span><br><span class="line">        <span class="keyword">return</span> token</span><br></pre></td></tr></table></figure></li><li><p>重写 <code>TokenObtainPairView</code> 视图函数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -&gt; backend/login/views.py</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> rest_framework_simplejwt.views <span class="keyword">import</span> TokenObtainPairView</span><br><span class="line"><span class="keyword">from</span> login.serializer <span class="keyword">import</span> DmallTokenObtainPairSerializer</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DmallTokenObtainPairView</span>(<span class="params">TokenObtainPairView</span>):</span></span><br><span class="line">    <span class="comment"># 登录成功返回token</span></span><br><span class="line">    serializer_class = DmallTokenObtainPairSerializer</span><br></pre></td></tr></table></figure></li><li><p>添加登录视图的接口路由</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -&gt; backend/login/urls.py</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> django.urls <span class="keyword">import</span> path</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> login.views <span class="keyword">import</span> DmallTokenObtainPairView</span><br><span class="line"></span><br><span class="line">urlpatterns = [</span><br><span class="line">    ...</span><br><span class="line">    path(<span class="string">&#x27;captcha/token/&#x27;</span>, DmallTokenObtainPairView.as_view(), name=<span class="string">&#x27;mytoken&#x27;</span>),</span><br><span class="line">]</span><br></pre></td></tr></table></figure></li><li><p>测试</p><img src="/2021/11/Python%E5%90%8E%E7%AB%AF%E9%83%A8%E7%BD%B2-Part2/image-20211126124446649.png" alt="image-20211126124446649" style="zoom:150%;"></li></ol>]]></content>
      
      
      <categories>
          
          <category> Python后端部署 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Python后端部署-Part1</title>
      <link href="/2021/11/Python%E5%90%8E%E7%AB%AF%E9%83%A8%E7%BD%B2-Part1/"/>
      <url>/2021/11/Python%E5%90%8E%E7%AB%AF%E9%83%A8%E7%BD%B2-Part1/</url>
      
        <content type="html"><![CDATA[<h1 id="Python后端部署-Part1——Web项目总览"><a href="#Python后端部署-Part1——Web项目总览" class="headerlink" title="Python后端部署-Part1——Web项目总览"></a>Python后端部署-Part1——Web项目总览</h1><p>[TOC]</p><h2 id="快速使用"><a href="#快速使用" class="headerlink" title="快速使用"></a>快速使用</h2><p>施工中……</p><h2 id="手动部署全流程"><a href="#手动部署全流程" class="headerlink" title="手动部署全流程"></a>手动部署全流程</h2><h2 id="服务器-Nginx-uwsgi-Django-配置"><a href="#服务器-Nginx-uwsgi-Django-配置" class="headerlink" title="服务器 Nginx+uwsgi+Django 配置"></a>服务器 Nginx+uwsgi+Django 配置</h2><h3 id="创建项目的-Docker-容器"><a href="#创建项目的-Docker-容器" class="headerlink" title="创建项目的 Docker 容器"></a>创建项目的 Docker 容器</h3><ol><li><p>拉取 ubuntu 镜像</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker pull django/ubuntu:20.04</span><br></pre></td></tr></table></figure></li><li><p>创建容器</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -it --name WebService -p 9045:22 -p 9046:80 -p 9048:8000 -p 9049:8080 -v /data/WebService:/data/WebService -d ubuntu:20.04 /bin/bash</span><br></pre></td></tr></table></figure><ul><li>-p 9045:22 用于 ssh 连接</li><li>-p 9046:80 用于 Nginx 代理</li><li>-p 9048:8000 用于 Django 测试</li><li>-p 9049:8080 用于 Vue 测试</li><li>-v /data/WebService:/data/WebService 将宿主机与容器内的项目根目录进行挂载</li></ul></li><li><p>进入容器（后续操作都在容器中进行）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker <span class="built_in">exec</span> -it WebService bash</span><br></pre></td></tr></table></figure></li><li><p>保持运行并退出容器</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ctrl + p + q</span><br></pre></td></tr></table></figure><h3 id="ssh-连接（可选）"><a href="#ssh-连接（可选）" class="headerlink" title="ssh 连接（可选）"></a>ssh 连接（可选）</h3></li></ol><h4 id="服务端搭建-ssh-服务"><a href="#服务端搭建-ssh-服务" class="headerlink" title="服务端搭建 ssh 服务"></a>服务端搭建 ssh 服务</h4><blockquote><p>参考：<a href="https://www.cnblogs.com/linuxAndMcu/p/10766589.html">https://www.cnblogs.com/linuxAndMcu/p/10766589.html</a></p></blockquote><ol><li><p>安装服务器</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ apt-get update</span><br><span class="line">$ apt-get install openssh-server</span><br></pre></td></tr></table></figure></li><li><p>生成秘钥</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">$ ssh-keygen -t rsa</span><br><span class="line">Generating public/private rsa key pair.</span><br><span class="line">Enter file <span class="keyword">in</span> <span class="built_in">which</span> to save the key (/root/.ssh/id_rsa): <span class="comment"># 这里回车</span></span><br><span class="line">Created directory <span class="string">&#x27;/root/.ssh&#x27;</span>.</span><br><span class="line">Enter passphrase (empty <span class="keyword">for</span> no passphrase): <span class="comment"># 这里回车</span></span><br><span class="line">Enter same passphrase again: <span class="comment"># 这里回车</span></span><br><span class="line">Your identification has been saved <span class="keyword">in</span> /root/.ssh/id_rsa</span><br><span class="line">Your public key has been saved <span class="keyword">in</span> /root/.ssh/id_rsa.pub</span><br><span class="line">The key fingerprint is:</span><br><span class="line">SHA256:7JmFyqQScZ5pTgQPro31HbSRQ0WhOXfaj36OlVW6rTY root@ac5b1c2f2ed8</span><br><span class="line">The key<span class="string">&#x27;s randomart image is:</span></span><br><span class="line"><span class="string">+---[RSA 3072]----+</span></span><br><span class="line"><span class="string">|  o  .+++.       |</span></span><br><span class="line"><span class="string">| . + .o=         |</span></span><br><span class="line"><span class="string">|  + + *.. .     .|</span></span><br><span class="line"><span class="string">| = * + = =     o |</span></span><br><span class="line"><span class="string">|o o B o S o   o  |</span></span><br><span class="line"><span class="string">|   = + o + o o o |</span></span><br><span class="line"><span class="string">|  . o o + . + . .|</span></span><br><span class="line"><span class="string">|   .     . o. E. |</span></span><br><span class="line"><span class="string">|          oo.... |</span></span><br><span class="line"><span class="string">+----[SHA256]-----+</span></span><br></pre></td></tr></table></figure></li><li><p>开放通过密码登录（如果没有开放的话）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ apt-get -y install vim  <span class="comment"># 如果没有 vim 的话</span></span><br><span class="line">$ vim /etc/ssh/sshd_config  <span class="comment"># 编辑</span></span><br><span class="line"></span><br><span class="line">输入/Permi，回车，找到</span><br><span class="line"><span class="comment">#PermitRootLogin prohibit-password</span></span><br><span class="line">取消注释, 修改成</span><br><span class="line">PermitRootLogin yes</span><br><span class="line"></span><br><span class="line">esc+:wq!退出</span><br></pre></td></tr></table></figure></li><li><p>设置密码</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ passwd</span><br><span class="line">New password: </span><br><span class="line">Retype new password: </span><br><span class="line">passwd: password updated successfully</span><br></pre></td></tr></table></figure></li><li><p>重启 ssh 服务</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ service ssh restart</span><br><span class="line"> * Restarting OpenBSD Secure Shell server sshd</span><br></pre></td></tr></table></figure><h4 id="使用-Pycharm-连接服务器"><a href="#使用-Pycharm-连接服务器" class="headerlink" title="使用 Pycharm 连接服务器"></a>使用 Pycharm 连接服务器</h4></li></ol><ul><li><p>pycharm 中找到远程主机</p><ul><li><img src="/2021/11/Python%E5%90%8E%E7%AB%AF%E9%83%A8%E7%BD%B2-Part1/image-20211113151601673.png" alt="image-20211113151601673"></li></ul></li><li><p>选择 SFTP</p><ul><li><img src="/2021/11/Python%E5%90%8E%E7%AB%AF%E9%83%A8%E7%BD%B2-Part1/image-20211113151849146.png" alt="image-20211113151849146"></li></ul></li><li><p>通信使用 utf-8</p><ul><li><img src="/2021/11/Python%E5%90%8E%E7%AB%AF%E9%83%A8%E7%BD%B2-Part1/image-20211113152019895.png" alt="image-20211113152019895"></li></ul></li><li><p>编辑 SSH 配置。由于 docker 容器的端口映射，这里的 9045 会连到容器的 22 端口。</p><ul><li><img src="/2021/11/Python%E5%90%8E%E7%AB%AF%E9%83%A8%E7%BD%B2-Part1/image-20211113152227627.png" alt="image-20211113152227627"></li></ul></li><li><p>设置映射</p><ul><li><img src="/2021/11/Python%E5%90%8E%E7%AB%AF%E9%83%A8%E7%BD%B2-Part1/image-20211113152505113.png" alt="image-20211113152505113"></li></ul></li><li><p>最终结果</p><ul><li><img src="/2021/11/Python%E5%90%8E%E7%AB%AF%E9%83%A8%E7%BD%B2-Part1/image-20211113152740086.png" alt="image-20211113152740086"></li></ul></li><li><p>同时，你可以通过 <code>ssh -p 9045 root@120.27.135.145</code> 在控制台登录</p><ul><li><img src="/2021/11/Python%E5%90%8E%E7%AB%AF%E9%83%A8%E7%BD%B2-Part1/image-20211113153636630.png" alt="image-20211113153636630"></li></ul></li><li><p>启动服务端的服务建议使用本地控制台连接服务器，后面会有启动命令</p></li></ul><blockquote><p>之后，你有两种方法来部署项目代码</p><ol><li>使用 ssh 连接服务器，在服务器上 git pull（当然，在此之前，你需要把代码 push 到 git 仓库）</li><li>使用 pycharm 直接部署代码（但是同样要记得 push 代码到仓库，否则在服务器上很难察觉版本迭代）</li></ol><p>同时，对于服务器上的文件修改，不需要再使用命令行，可以直接在 IDE 中编辑并上传。</p></blockquote><h3 id="容器内环境配置与测试"><a href="#容器内环境配置与测试" class="headerlink" title="容器内环境配置与测试"></a>容器内环境配置与测试</h3><blockquote><p>参考：</p><ul><li><a href="https://blog.csdn.net/yilovexing/article/details/82969103">https://blog.csdn.net/yilovexing/article/details/82969103</a></li><li><a href="https://blog.csdn.net/weixin_42292991/article/details/95937600">https://blog.csdn.net/weixin_42292991/article/details/95937600</a></li><li><a href="https://hub.docker.com/r/dockerfiles/django-uwsgi-nginx">https://hub.docker.com/r/dockerfiles/django-uwsgi-nginx</a></li><li><a href="https://www.cnblogs.com/Skyda/p/10030121.html">https://www.cnblogs.com/Skyda/p/10030121.html</a></li></ul></blockquote><ol><li><p>更新源，准备必要环境：git、py3、nginx、uwsgi</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">apt-get update &amp;&amp; \</span><br><span class="line">apt-get upgrade -y &amp;&amp; \ </span><br><span class="line">apt-get install -y \</span><br><span class="line">git \</span><br><span class="line">python3 \</span><br><span class="line">python3-dev \</span><br><span class="line">python3-setuptools \</span><br><span class="line">python3-pip \</span><br><span class="line">nginx \</span><br><span class="line">supervisor &amp;&amp; \</span><br><span class="line">pip3 install -U pip setuptools &amp;&amp; \</span><br><span class="line">pip3 install uwsgi &amp;&amp; \</span><br><span class="line">rm -rf /var/lib/apt/lists/*</span><br></pre></td></tr></table></figure></li><li><p>检查 python3</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ python3</span><br><span class="line">Python <span class="number">3.8</span><span class="number">.10</span> (default, Sep <span class="number">28</span> <span class="number">2021</span>, <span class="number">16</span>:<span class="number">10</span>:<span class="number">42</span>) </span><br><span class="line">[GCC <span class="number">9.3</span><span class="number">.0</span>] on linux</span><br><span class="line">Type <span class="string">&quot;help&quot;</span>, <span class="string">&quot;copyright&quot;</span>, <span class="string">&quot;credits&quot;</span> <span class="keyword">or</span> <span class="string">&quot;license&quot;</span> <span class="keyword">for</span> more information.</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span></span><br></pre></td></tr></table></figure></li><li><p>拉取仓库</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /data</span><br><span class="line">git <span class="built_in">clone</span> https://gitee.com/NephrenCake/WebService.git</span><br></pre></td></tr></table></figure><p>之后更新本地仓库</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /data/WebService</span><br><span class="line">git pull</span><br></pre></td></tr></table></figure></li><li><p>安装 pip 依赖</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd /data/WebService</span><br><span class="line">pip3 install -r backend/requirements.txt</span><br></pre></td></tr></table></figure></li><li><p>使用 Django 测试服务器启动服务</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python3 /data/WebService/backend/manage.py runserver <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span>:<span class="number">8000</span></span><br></pre></td></tr></table></figure><ul><li>浏览器打开 <a href="http://120.27.135.145:9048/">http://120.27.135.145:9048/</a></li></ul></li><li><p>使用 uwsgi 服务器启动服务</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">uwsgi --ini /data/WebService/backend/start.ini</span><br></pre></td></tr></table></figure><ul><li>浏览器打开 <a href="http://120.27.135.145:9048/%EF%BC%88%E5%9C%A8%E4%BD%BF%E7%94%A8">http://120.27.135.145:9048/（在使用</a> Django 或 uwsgi 服务器时，需要确保互相不同时使用，否则会有端口占用冲突）</li></ul></li><li><p>使用 Nginx 启动服务</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ cp /data/WebService/backend/nginx.conf /etc/nginx/sites-enabled/nginx.conf</span><br><span class="line">$ /etc/init.d/nginx restart</span><br><span class="line">$ nginx -s reload</span><br></pre></td></tr></table></figure><ul><li>浏览器打开 <a href="http://120.27.135.145:9046/%EF%BC%88%E5%90%8E%E9%9D%A2%E5%AE%9E%E9%99%85%E9%83%A8%E7%BD%B2%E4%BC%9A%E4%BD%BF%E7%94%A8%E8%AF%A5%E5%9C%B0%E5%9D%80%EF%BC%89">http://120.27.135.145:9046/（后面实际部署会使用该地址）</a></li></ul></li><li><p>使用 nohup 后台运行</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">nohup python3 /data/WebService/backend/manage.py runserver <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span>:<span class="number">8000</span> &gt;&gt;/data/WebService/backend/log/output.log <span class="number">2</span>&gt;&amp;<span class="number">1</span> &amp;</span><br><span class="line">ps -aux|grep manage.py| grep -v grep | awk <span class="string">&#x27;&#123;print $2&#125;&#x27;</span></span><br><span class="line">kill -<span class="number">9</span>  <span class="number">2619</span></span><br></pre></td></tr></table></figure></li><li><p>使用 Supervisor 运行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ supervisord -c /etc/supervisord.conf</span><br><span class="line">$ cp /data/WebService/backend/supervisor.conf /etc/supervisor/conf.d/supervisor.conf</span><br><span class="line">$ supervisorctl update</span><br><span class="line">WebService: added process group  <span class="comment"># 其实这个时候已经开始运行后台了</span></span><br><span class="line">$ supervisorctl restart WebService</span><br></pre></td></tr></table></figure><blockquote><p>注意：单独使用 uwsgi 和使用 Nginx+uwsgi 组合，使用的是同一个配置文件，即 start.ini，切换时需要修改对应项。当直接使用 Django 时不需要修改该配置文件。</p><ul><li><img src="/2021/11/Python%E5%90%8E%E7%AB%AF%E9%83%A8%E7%BD%B2-Part1/image-20211113171103506.png" alt="image-20211113171103506"></li></ul></blockquote></li></ol>]]></content>
      
      
      <categories>
          
          <category> Python后端部署 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Python后端部署-完结目录</title>
      <link href="/2021/11/Python%E5%90%8E%E7%AB%AF%E9%83%A8%E7%BD%B2-%E5%AE%8C%E7%BB%93%E7%9B%AE%E5%BD%95/"/>
      <url>/2021/11/Python%E5%90%8E%E7%AB%AF%E9%83%A8%E7%BD%B2-%E5%AE%8C%E7%BB%93%E7%9B%AE%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<h1 id="Python后端部署-完结目录"><a href="#Python后端部署-完结目录" class="headerlink" title="Python后端部署-完结目录"></a>Python后端部署-完结目录</h1><table><thead><tr><th align="center"><a href="/2021/11/Python%E5%90%8E%E7%AB%AF%E9%83%A8%E7%BD%B2-Part1/">Python后端部署-Part1——Web项目总览</a></th></tr></thead><tbody><tr><td align="center"><strong><a href="/2021/11/Python%E5%90%8E%E7%AB%AF%E9%83%A8%E7%BD%B2-Part2/">Python后端部署-Part2——Django登录验证</a></strong></td></tr><tr><td align="center"><strong><a href="/2021/11/Python%E5%90%8E%E7%AB%AF%E9%83%A8%E7%BD%B2-Part3/">Python后端部署-Part3——Supervisor进程管理</a></strong></td></tr><tr><td align="center"><strong><a href="Python%E5%90%8E%E7%AB%AF%E9%83%A8%E7%BD%B2-Part4/">Python后端部署-Part4——uWSGI与Nginx部署</a></strong></td></tr><tr><td align="center"><strong><a href="/2021/11/Python%E5%90%8E%E7%AB%AF%E9%83%A8%E7%BD%B2-Part5/">Python后端部署-Part5——MySQL数据库容器</a></strong></td></tr></tbody></table><p>在本系列中，主要采取以下技术栈：（以后可能会不定期更新）</p><ol><li>容器工具：Docker</li><li>后端框架：Django+DjangoRestfulFramwork</li><li>进程管理：Supervisor</li><li>Web服务器：uWSGI</li><li>反向代理：Nginx</li><li>数据库：MySQL</li></ol>]]></content>
      
      
      <categories>
          
          <category> Python后端部署 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Web </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作系统-完结目录</title>
      <link href="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E5%AE%8C%E7%BB%93%E7%9B%AE%E5%BD%95/"/>
      <url>/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E5%AE%8C%E7%BB%93%E7%9B%AE%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<h1 id="操作系统-完结目录"><a href="#操作系统-完结目录" class="headerlink" title="操作系统-完结目录"></a>操作系统-完结目录</h1><p>教程视频传送门：</p><ol><li><a href="https://www.bilibili.com/video/BV1YE411D7nH">王道计算机考研 操作系统</a></li></ol><p>推荐资源：</p><ol><li>王道配套书</li></ol><p>不多说，==做题==！</p><table><thead><tr><th align="center"><a href="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part1/">操作系统-Part1——计算机系统概述</a></th></tr></thead><tbody><tr><td align="center"><strong><a href="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part2/">操作系统-Part2——进程管理</a></strong></td></tr><tr><td align="center"><strong><a href="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part3/">操作系统-Part3——内存管理</a></strong></td></tr><tr><td align="center"><strong><a href="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part4/">操作系统-Part4——文件管理</a></strong></td></tr><tr><td align="center"><strong><a href="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part5/">操作系统-Part5——I/O 管理</a></strong></td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 408 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作系统-Part5</title>
      <link href="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part5/"/>
      <url>/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part5/</url>
      
        <content type="html"><![CDATA[<h1 id="操作系统-Part5——I-O-管理"><a href="#操作系统-Part5——I-O-管理" class="headerlink" title="操作系统-Part5——I/O 管理"></a>操作系统-Part5——I/O 管理</h1><p>[TOC]</p><h2 id="I-O-管理概述"><a href="#I-O-管理概述" class="headerlink" title="I/O 管理概述"></a>I/O 管理概述</h2><h3 id="I-O-设备的基本概念和分类"><a href="#I-O-设备的基本概念和分类" class="headerlink" title="I/O 设备的基本概念和分类"></a>I/O 设备的基本概念和分类</h3><p><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part5/image-20211115162634513.png" alt="image-20211115162634513"></p><ul><li>UNIX 系统将外部设备抽象为一种特殊的文件，用户可以使用与文件操作相同的方式对外部设备进行操作。<ul><li>Write 操作：向外部设备写出数据</li><li>Read 操作：从外部设备读入数据</li></ul></li><li>I/O 设备的分类<ul><li>按使用特性<ul><li>人机交互类外设</li><li>存储设备</li><li>网络通信设备</li></ul></li><li>按传输速率分类<ul><li>低速设备（鼠标、键盘）</li><li>中速设备（激光打印机）</li><li>高速设备（磁盘）</li></ul></li><li>按信息交换的单位分类<ul><li>块设备（磁盘）<ul><li>传输速率较高，可寻址</li></ul></li><li>字符设备（鼠标、键盘）<ul><li>传输速率较慢，不可寻址</li><li>常采用中断驱动方式</li></ul></li></ul></li></ul></li></ul><h3 id="I-O-控制器"><a href="#I-O-控制器" class="headerlink" title="I/O 控制器"></a>I/O 控制器</h3><p><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part5/image-20211115171623799.png" alt="image-20211115171623799"></p><ul><li>I/O 设备的组成<ul><li>机械部件<ul><li>主要用来执行具体 I/O 操作。</li></ul></li><li>电子部件<ul><li>通常是一块插入主板扩充槽的印刷电路板。</li><li>包括 I/O 控制器（设备控制器）</li></ul></li></ul></li><li>I/O 控制器的功能：<ul><li>接受和识别 CPU 的命令<ul><li>CPU发来的 read/write 命令，I/O 控制器中会有相应的<strong>控制寄存器</strong>来存放命令和参数。</li></ul></li><li>想 CPU 报告设备的状态<ul><li>I/O 控制器中会有相应的状态寄存器，用于记录 I/O 设备的当前状态。</li></ul></li><li>数据交换<ul><li>I/O 控制器中设置相应的数据寄存器。用于暂存输入输出时的数据。</li></ul></li><li>地址识别<ul><li>为了区分设备控制器中的各个寄存器，也需要给各个寄存器设置特定的地址</li></ul></li></ul></li><li>I/O 控制器的组成<ul><li><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part5/image-20211115171448414.png" alt="image-20211115171448414"></li><li>一个 I/O 控制器可能会对应多个设备；</li><li>数据寄存器、控制寄存器、状态寄存器可能有多个（<strong>每个控制/状态寄存器对应一个具体的设备</strong>），且这些寄存器都要有相应的地址，才能方便CPU操作。<ul><li>有的计算机会让这些寄存器占用内存地址的一部分，称为<strong>内存映像 I/O</strong>；另一些计算机则采用 I/O 专用地址，即<strong>寄存器独立编址</strong>。</li></ul></li></ul></li><li>内存映像 I/O v.s. 寄存器独立编址<ul><li><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part5/image-20211115171837978.png" alt="image-20211115171837978"></li></ul></li></ul><h3 id="I-O-控制方式"><a href="#I-O-控制方式" class="headerlink" title="I/O 控制方式"></a>I/O 控制方式</h3><p><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part5/image-20211115201702719.png" alt="image-20211115201702719"></p><ul><li>程序直接控制方式<ul><li>完成一次读/写操作的流程<ul><li><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part5/image-20211115194455982.png" alt="image-20211115194455982" style="zoom:50%;"></li></ul></li><li>CPU 干预的频率<ul><li>很频繁，I/O 操作<strong>开始之前</strong>、<strong>完成之后</strong>需要 CPU 介入，并且在<strong>等待 I/O 完成的过程中</strong> CPU 需要不断地轮询检查。</li></ul></li><li>数据传送的单位<ul><li>每次读/写<strong>一个字</strong></li></ul></li><li>数据的流向<ul><li>读操作（数据输入）：I/O 设备 -&gt; CPU -&gt; 内存</li><li>写操作（数据输出）：内存 -&gt; CPU -&gt; I/O 设备</li><li>每个字的读/写都需要 CPU 的帮助</li></ul></li><li>主要缺点和主要优点<ul><li>优点：实现简单。</li><li>缺点：CPU 和 I/O 设备<strong>只能串行工作</strong>，CPU 需要一直轮询检查，长期处于<strong>忙等</strong>状态 ，CPU <strong>利用率低</strong>。</li></ul></li></ul></li><li>中断驱动方式<ul><li>完成一次读/写操作的流程<ul><li><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part5/image-20211115195236013.png" alt="image-20211115195236013" style="zoom:50%;"></li><li>引入<strong>中断机制</strong>。将<strong>等待 I/O 的进程阻塞</strong>，<strong>在每个指令周期的末尾检查中断</strong>；</li></ul></li><li>CPU 干预的频率<ul><li>每次 I/O 操作<strong>开始之前</strong>、<strong>完成之后</strong>需要 CPU 介入。</li><li>而等待 I/O 完成的过程中 CPU 可以切换到别的进程执行。</li></ul></li><li>数据传送的单位<ul><li>每次读/写一个字</li></ul></li><li>数据的流向<ul><li>读操作（数据输入）：I/O 设备 -&gt; CPU -&gt; 内存</li><li>写操作（数据输出）：内存 -&gt; CPU -&gt; I/O 设备</li></ul></li><li>主要缺点和主要优点<ul><li>优点：通过 I/O 控制器<strong>主动发出中断信号</strong>报告 I/O 已完成，CPU 不再需要不停地轮询。CPU 和 I/O 设备并行工作，CPU 利用率明显提升。</li><li>缺点：每个字<strong>在 I/O 设备与内存之间的传输，都需要经过 CPU</strong>。而<strong>频繁的中断处理会消耗较多的 CPU 时间</strong>。</li></ul></li></ul></li><li>DMA（ Direct Memory Access，直接存储器存取）方式<ul><li>DMA 控制器<ul><li><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part5/image-20211115200414017.png" alt="image-20211115200414017" style="zoom:80%;"></li><li>DR（Data Register，数据寄存器）：暂存从设备到内存，或从内存到设备的数据。</li><li>MAR（Memory Address Register，内存地址寄存器）：在输入时，MAR 表示数据应放到内存中的什么位置；输出时 MAR 表示要输出的数据放在内存中的什么位置。</li><li>DC（Data Counter，数据计数器）：表示剩余要读/写的字节数。</li><li>CR（Command Register，命令/状态寄存器）：用于存放 CPU 发来的 I/O 命令，或设备的状态信息。</li></ul></li><li>完成一次读/写操作的流程<ul><li><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part5/image-20211115195617190.png" alt="image-20211115195617190" style="zoom:50%;"></li><li>DMA 读写完之后，向 CPU 发出中断信号</li></ul></li><li>CPU 干预的频率<ul><li>仅在传送一个或多个数据块的<strong>开始</strong>和<strong>结束</strong>时，才需要 CPU 干预。</li></ul></li><li>数据传送的单位<ul><li>每次读/写<strong>一个或多个块</strong></li><li>注意：<strong>每次读写的只能是连续的多个块，且这些块读入内存后在内存中也必须是连续的</strong>。</li></ul></li><li>数据的流向（不再需要经过CPU）<ul><li>读操作（数据输入）：I/O 设备 -&gt; 内存</li><li>写操作（数据输出）：内存 -&gt; I/O 设备</li></ul></li><li>主要缺点和主要优点<ul><li>优点：<ul><li><strong>数据传输单位为“块”</strong>，而不是“字”。</li><li>数据在 I/O 与内存之间的传输不需要经过 CPU，<strong>CPU 介入频率降低</strong>，<strong>数据传输效率增加</strong>。</li><li><strong>CPU 和 I/O 设备的并行性得到提升</strong>。</li></ul></li><li>缺点：<ul><li>CPU 每发出一条 I/O 指令，<strong>只能读/写一个或多个连续（而不能离散）的数据块</strong>。</li><li>如果<strong>要读/写多个离散存储的数据块，或者要将数据分别写到不同的内存区域</strong>时，CPU 要<strong>分别发出多条 I/O 指令，进行多次中断处理</strong>才能完成。</li></ul></li></ul></li></ul></li><li>通道控制方式<ul><li>通道（弱化 CPU）可以识别并执行一系列通道指令<ul><li><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part5/image-20211115201531964.png" alt="image-20211115201531964" style="zoom:80%;"></li><li>CPU 向通道发出 I/O 指令。指明<strong>通道程序在内存中的位置</strong>，并指明要<strong>操作的是哪个 I/O 设备</strong>。</li><li>通道执行内存中的通道程序（其中指明了要<strong>读入/写出多少数据</strong>，读/写的数据应<strong>放在内存的位置</strong>等信息，<strong>相当于任务清单</strong>）</li><li>通道执行完规定的任务后，向 CPU 发出中断信号</li></ul></li><li>完成一次读/写操作的流程<ul><li><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part5/image-20211115200740547.png" alt="image-20211115200740547" style="zoom:50%;"></li></ul></li><li>CPU 干预的频率<ul><li>极低，通道会根据 CPU 的指示执行相应的通道程序，只有完成一组数据块的读/写后才需要发出中断信号，请求 CPU 干预。</li></ul></li><li>数据传送的单位<ul><li>每次读/写<strong>一组数据块</strong></li></ul></li><li>数据的流向（在通道的控制下进行）<ul><li>读操作（数据输入）：I/O 设备 -&gt; 内存</li><li>写操作（数据输出）：内存 -&gt; I/O 设备</li></ul></li><li>主要缺点和主要优点<ul><li>缺点：实现复杂，需要专门的通道硬件支持</li><li>优点：<strong>CPU、通道、I/O 设备可并行工作，资源利用率很高</strong>。</li></ul></li></ul></li></ul><h3 id="I-O-软件层次结构"><a href="#I-O-软件层次结构" class="headerlink" title="I/O 软件层次结构"></a>I/O 软件层次结构</h3><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part5/image-20211115202052358.png" alt="image-20211115202052358" style="zoom:80%;"><ul><li><p>用户层软件</p><ul><li>用户层软件<strong>实现了与用户交互的接口</strong>，用户可直接<strong>使用该层提供的、与 I/O 操作相关的库函数</strong>对设备进行操作</li><li>用户层软件将用户请求翻译成格式化的 I/O 请求，并通过<strong>系统调用</strong>请求操作系统内核的服务</li></ul></li><li><p>设备独立性软件</p><ul><li>设备独立性软件，又称设备无关性软件。与设备的硬件特性无关的功能几乎都在这一层实现。</li><li>主要实现的功能：<ul><li><strong>向上层提供统一的调用接口</strong>（如 read/write 系统调用）</li><li><strong>设备的保护</strong>（访问权限）</li><li><strong>差错处理</strong></li><li><strong>设备的分配与回收</strong>（临界资源）</li><li><strong>数据缓冲区管理</strong>（屏蔽设备之间数据交换单位大小和传输速度的差异）</li><li><strong>建立逻辑设备表</strong>（LUT，Logical UnitTable），包含逻辑设备名到物理设备名的<strong>映射关系</strong>、根据设备类型选择<strong>调用相应的驱动程序</strong>。<ul><li><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part5/image-20211115203148579.png" alt="image-20211115203148579" style="zoom: 67%;"></li><li>操作系统系统可以采用两种方式管理逻辑设备表（LUT）： <ol><li><strong>整个系统</strong>设置一张 LUT，意味着所有用户不能使用相同的逻辑设备名，因此只适用于单用户操作系统。</li><li><strong>每个用户</strong>设置一张 LUT，各个用户使用的逻辑设备名可以重复，适用于多用户操作系统。系统在用户登录时为其建立一个用户管理进程，而 LUT 就存放在用户管理进程的 PCB 中。</li></ol></li></ul></li></ul></li></ul></li><li><p>设备驱动程序</p><ul><li>负责对硬件设备的具体控制，将上层发出的一系列命令转化成特定（不同厂家）设备的命令。</li><li>包括<strong>设置设备寄存器</strong>、<strong>检查设备状态</strong>等</li><li>驱动程序一般会以一个独立进程的方式存在。</li></ul></li><li><p>中断处理程序</p><ul><li><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part5/image-20211115205824849.png" alt="image-20211115205824849" style="zoom:80%;"></li><li>当 I/O 任务完成时，I/O 控制器会发送一个中断信号，系统会根据中断信号类型找到相应的中断处理程序并执行。</li></ul></li><li><p>最常考的是设备<strong>独立性软件、设备驱动程序</strong>这两层。</p><ul><li>直接涉及到硬件具体细节、且与中断无关的操作肯定是在<strong>设备驱动程序层</strong>完成的</li><li>没有涉及硬件的、对各种设备都需要进行的管理工作都是在<strong>设备独立性软件层</strong>完成的</li><li><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part5/image-20211115210124001.png" alt="image-20211115210124001"></li></ul></li></ul><h2 id="I-O-核心子系统"><a href="#I-O-核心子系统" class="headerlink" title="I/O 核心子系统"></a>I/O 核心子系统</h2><h3 id="I-O-子系统概述"><a href="#I-O-子系统概述" class="headerlink" title="I/O 子系统概述"></a>I/O 子系统概述</h3><ul><li><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part5/image-20211115210745581.png" alt="image-20211115210745581" style="zoom:80%;"></li><li>考研中，需要重点理解和掌握的功能是：<ul><li><strong>I/O 调度</strong><ul><li>类比磁盘调度</li><li>先来先服务算法、优先级算法、短作业优先等</li></ul></li><li><strong>设备保护</strong><ul><li>类比文件保护功能</li><li>设备被看做是一种特殊的文件，每个设备也会有对应的 FCB。</li><li>当用户请求访问某个设备时，系统根据 FCB 中记录的信息来判断该用户是否有相应的访问权限，以此实现“设备保护”的功能。</li></ul></li><li><strong>假脱机技术</strong>（SPOOLing技术）</li><li><strong>设备分配与回收</strong></li><li><strong>缓冲区管理</strong>（即缓冲与高速缓存）</li></ul></li></ul><h3 id="假脱机技术"><a href="#假脱机技术" class="headerlink" title="假脱机技术"></a>假脱机技术</h3><p><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part5/image-20211115210955966.png" alt="image-20211115210955966"></p><ul><li>脱机技术 —— 脱离主机的控制进行的输入/输出操作。<ul><li><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part5/image-20211115214348914.png" alt="image-20211115214348914" style="zoom: 67%;"></li><li>缓解 CPU 与慢速 I/O 设备的速度矛盾。</li><li>实现 I/O 设备与 CPU 的并行。</li></ul></li><li>假脱机技术（SPOOLing 技术）<ul><li><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part5/image-20211115213754105.png" alt="image-20211115213754105" style="zoom:67%;"></li><li>输入井：模拟脱机<strong>输入时的磁带</strong>，用于收容 I/O 设备输入的数据</li><li>输出井：模拟脱机<strong>输出时的磁带</strong>，用于收容用户进程输出的数据</li><li>在<strong>磁盘上</strong>开辟出两个存储区域 —— 输入井和输出井。</li><li>输入进程：模拟脱机<strong>输入时的外围控制机</strong></li><li>输出进程：模拟脱机<strong>输出时的外围控制机</strong></li><li>要实现 SPOOLing 技术，<strong>必须要有多道程序技术的支持</strong>。系统会建立输入进程和输出进程。</li><li>输入缓冲区：用于暂存从输入设备输入的数据，之后再转存到输入井中</li><li>输出缓冲区：用于暂存从输出井送来的数据，之后再传送到输出设备上</li><li>输入缓冲区和输出缓冲区是<strong>在内存中</strong>的缓冲区</li></ul></li><li>共享打印机<ul><li>SPOOLing 技术可以把一台物理设备<strong>虚拟</strong>成逻辑上的多台设备，可以<strong>将独占式设备改造成共享设备</strong>。<ol><li><strong>在磁盘输出井中</strong>为进程申请一个空闲缓冲区（这个缓冲区是在磁盘上的），并将要打印的数据送入其中；</li><li>为用户进程申请一张空白的打印请求表，并将用户的打印请求填入表中（用来说明用户的打印数据存放位置等信息），再将该表挂到假脱机文件队列上。</li><li>当打印机空闲时，<strong>输出进程会从文件队列的队头取出一张打印请求表</strong>，并根据表中的要求将要打印的数据<strong>从输出井传送到输出缓冲区</strong>，再输出到打印机进行打印。</li></ol></li><li><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part5/image-20211116140746931.png" alt="image-20211116140746931"></li></ul></li></ul><h3 id="设备的分配与回收"><a href="#设备的分配与回收" class="headerlink" title="设备的分配与回收"></a>设备的分配与回收</h3><p><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part5/image-20211116141015539.png" alt="image-20211116141015539"></p><ul><li><p><strong>设备分配时应考虑的因素</strong></p><ul><li>设备的固有属性<ul><li><strong>独占设备</strong>：一个时段只能分配给一个进程，只允许各个进程串行使用（如打印机）</li><li><strong>共享设备</strong>：可同时分配给多个进程使用（如磁盘），各进程往往是宏观上同时共享使用设备，而微观上交替使用。</li><li><strong>虚拟设备</strong>：采用 SPOOLing 技术将独占设备改造成虚拟的共享设备，可同时分配给多个进程使用（如采用 SPOOLing 技术实现的共享打印机）</li></ul></li><li>设备分配算法<ul><li><strong>先来先服务</strong></li><li><strong>优先级高者优先</strong></li><li><strong>短任务优先</strong></li><li>……</li></ul></li><li>设备分配中的安全性<ul><li><strong>安全分配方式</strong>：为进程分配一个 I/O 设备后就将进程阻塞，本次 I/O 完成后才将进程唤醒。<ul><li><strong>一个时段内每个进程只能使用一个设备</strong></li><li>优点：破坏了“请求和保持”条件，<strong>不会死锁</strong></li><li>缺点：对于一个进程来说，CPU 和 I/O 设备只能<strong>串行</strong>工作</li></ul></li><li><strong>不安全分配方式</strong>：进程发出 I/O 请求后，系统为其分配 I/O 设备，并且进程可继续执行，之后还可以发出新的 I/O 请求。只有某个 I/O 请求得不到满足时才将进程阻塞。<ul><li><strong>一个进程可以同时使用多个设备</strong></li><li>优点：进程的计算任务和 I/O 任务可以<strong>并行</strong>处理</li><li>缺点：<strong>有可能发生死锁</strong>（死锁避免、死锁的检测和解除）</li></ul></li></ul></li></ul></li><li><p><strong>静态分配与动态分配</strong></p><ul><li>静态分配：进程<strong>运行前为其分配全部所需资源</strong>，运行结束后归还资源<ul><li>破坏了“请求和保持”条件，不会发生死锁</li></ul></li><li>动态分配：进程<strong>运行过程中动态申请</strong>设备资源</li></ul></li><li><p><strong>设备分配管理中的数据结构</strong></p><ul><li><strong>设备、控制器、通道</strong>之间的关系：<ul><li>一个通道控制多个控制器，一个控制器控制多个设备</li><li><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part5/image-20211116142938193.png" alt="image-20211116142938193" style="zoom: 67%;"></li></ul></li><li><strong>设备控制表（DCT）</strong>：系统为每个设备配置一张 DCT，用于记录设备情况<ul><li>系统会根据阻塞原因不同，将进程 PCB 挂到不同的阻塞队列中</li><li><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part5/image-20211116143032613.png" alt="image-20211116143032613" style="zoom: 80%;"></li></ul></li><li><strong>控制器控制表（COCT）</strong>：每个设备控制器都会对应一张 COCT。操作系统根据 COCT 的信息对控制器进行操作和管理。<ul><li><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part5/image-20211116143127155.png" alt="image-20211116143127155" style="zoom:80%;"></li></ul></li><li><strong>通道控制表（CHCT）</strong>：每个通道都会对应一张 CHCT。操作系统根据 CHCT 的信息对通道进行操作和管理。<ul><li><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part5/image-20211116143209860.png" alt="image-20211116143209860" style="zoom:80%;"></li></ul></li><li><strong>系统设备表（SDT）</strong>：记录了<strong>系统中全部设备</strong>的情况，每个设备对应一个表目。<ul><li><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part5/image-20211116143256935.png" alt="image-20211116143256935" style="zoom:80%;"></li></ul></li></ul></li><li><p><strong>设备分配的步骤</strong></p><ul><li><p>步骤：</p><ol><li>根据进程请求的<strong>物理设备名</strong>查找 SDT（注：物理设备名是进程请求分配设备时提供的参数）</li><li>根据 SDT 找到 DCT，若<strong>设备</strong>忙碌则将进程 PCB 挂到<strong>设备等待队列</strong>中，不忙碌则将<strong>设备</strong>分配给进程。</li><li>根据 DCT 找到 COCT，若<strong>控制器</strong>忙碌则将进程 PCB 挂到<strong>控制器等待队列</strong>中，不忙碌则将<strong>控制器</strong>分配给进程。</li><li>根据 COCT 找到 CHCT，若<strong>通道</strong>忙碌则将进程 PCB 挂到<strong>通道等待队列</strong>中，不忙碌则将<strong>通道</strong>分配给进程。</li></ol></li><li><p>注意：<strong>只有设备、控制器、通道三者都分配成功时，这次设备分配才算成功，之后便可启动 I/O 设备进行数据传送</strong>。</p></li><li><p>缺点：</p><ul><li>用户编程时必须使用<strong>物理设备名</strong>，底层细节对用户不透明，不方便编程 </li><li>若换了一个<strong>物理设备</strong>，则程序无法运行</li><li>若进程<strong>请求的物理设备</strong>正在忙碌，则即使系统中还有<strong>同类型的设备</strong>，进程也必须阻塞等待</li></ul></li></ul></li><li><p><strong>设备分配步骤的改进方法</strong></p><ul><li>改进方法：建立逻辑设备名与物理设备名的映射机制，用户编程时只需提供<strong>逻辑设备名</strong>。<ul><li><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part5/image-20211116144907464.png" alt="image-20211116144907464"></li></ul></li><li>分配步骤<ol><li>根据进程请求的<strong>逻辑设备名</strong>查找 SDT（注：用户编程时提供的逻辑设备名其实就是“设备类型”）</li><li>查找 SDT，找到用户进程<strong>指定类型的且空闲</strong>的设备，将其及其 DCT 分配给该进程。<ul><li>操作系统<strong>在逻辑设备表（LUT）中新增一个表项</strong>，<strong>记录该次调用的逻辑设备名和物理设备名的映射关系</strong>，</li><li>在这一步，操作系统动态分配物理设备，并返回相应 DCT。</li><li>之后用户进程再次通过相同的逻辑设备名，操作系统通过 LUT 表的记录也可以找到对应的物理设备。</li></ul></li><li>根据 DCT 找到 COCT，若控制器忙碌则将进程 PCB 挂到控制器等待队列中，不忙碌则将控制器分配给进程。</li><li>根据 COCT 找到 CHCT，若通道忙碌则将进程 PCB 挂到通道等待队列中，不忙碌则将通道分配给进程。</li></ol></li><li>逻辑设备表的设置问题： <ul><li>整个系统只有一张 LUT：各用户所用的<strong>逻辑设备名不允许重复</strong>，适用于单用户操作系统</li><li>每个用户一张 LUT：<strong>不同用户的逻辑设备名可重复</strong>，适用于多用户操作系统</li></ul></li></ul></li></ul><h3 id="缓冲区管理"><a href="#缓冲区管理" class="headerlink" title="缓冲区管理"></a>缓冲区管理</h3><p><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part5/image-20211116150127920.png" alt="image-20211116150127920"></p><ul><li>缓冲区的定义<ul><li>缓冲区是一个<strong>存储区域</strong>，可以<strong>由专门的硬件寄存器</strong>组成，也可利用<strong>内存</strong>作为缓冲区。<ul><li>使用硬件作为缓冲区的成本较高，容量也较小，一般仅用在对速度要求非常高的场合（如，存储器管理中所用的联想寄存器，快表）</li><li>一般情况下，更多的是利用内存作为缓冲区，“设备独立性软件”的缓冲区管理就是要组织管理好内存中的缓冲区</li></ul></li></ul></li><li>缓冲区的作用<ul><li>缓和 CPU 与 I/O 设备之间速度不匹配的矛盾</li><li>减少对 CPU 的中断频率，放宽对 CPU 中断响应时间的限制<ul><li>字符型设备，每输出完一个字符就要向 CPU 发送一次中断信号</li></ul></li><li>解决数据粒度不匹配的问题<ul><li>输出进程每次可以生成一块数据，但 I/O 设备每次只能输出一个字符</li></ul></li><li>提高 CPU 和 I/O 设备之间的并行性</li></ul></li><li>单缓冲<ul><li>单缓冲策略，操作系统会在<strong>主存中为其分配一个缓冲区</strong>。</li><li>注意：<ul><li><strong>当缓冲区数据非空时，不能往缓冲区冲入数据，只能从缓冲区把数据传出</strong>；</li><li><strong>当缓冲区为空时，可以往缓冲区冲入数据，但必须把缓冲区充满以后，才能从缓冲区把数据传出</strong>。</li><li>一般来说，一个缓冲区的大小就是一个块，用户进程的工作区大小与缓冲区相同</li></ul></li><li><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part5/image-20211116154946154.png" alt="image-20211116154946154" style="zoom:67%;"></li><li><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part5/image-20211116154847194.png" alt="image-20211116154847194"></li><li>技巧：假定一个初始状态，分析下次到达相同状态需要多少时间，这就是处理<strong>一块数据平均所需时间</strong>。<ul><li><strong>采用单缓冲策略，处理一块数据平均耗时 Max(C, T)+M</strong>。</li></ul></li></ul></li><li>双缓冲<ul><li>双缓冲策略，操作系统会在主存中为其分配两个缓冲区</li><li><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part5/image-20211116155441445.png" alt="image-20211116155441445" style="zoom:67%;"></li><li><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part5/image-20211116155706436.png" alt="image-20211116155706436"></li><li>当 M+C&gt;T，则<strong>很难有回到初始状态</strong>，但是通过图中观察可发现，周期为 M+C。<ul><li>**采用双缓冲策略，处理一个数据块的平均耗时为 Max (T, C+M)**。</li></ul></li></ul></li><li>使用单/双缓冲在通信时的区别<ul><li>两台机器之间<strong>通信</strong>时，可以配置缓冲区用于数据的发送和接受。<ul><li>若两个相互通信的机器只设置<strong>单缓冲区</strong>，在任一时刻只能实现<strong>数据的单向传输</strong>。</li><li>若两个相互通信的机器设置<strong>双缓冲区</strong>，则同一时刻可以实现<strong>双向的数据传输</strong>。</li><li>管道通信中的“管道”其实就是缓冲区。要实现数据的双向传输，必须设置两个管道</li><li>==这里与part2说法冲突todo==</li></ul></li></ul></li><li>循环缓冲<ul><li>将多个大小相等的缓冲区链接成一个循环队列。</li><li><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part5/image-20211116162507957.png" alt="image-20211116162507957" style="zoom:80%;"></li></ul></li><li>缓冲池<ul><li>缓冲池由系统中共用的缓冲区组成。这些缓冲区按使用状况可以分为：空缓冲队列、装满输入数据的缓冲队列（输入队列）、装满输出数据的缓冲队列（输出队列）。</li><li>另外，根据一个缓冲区在实际运算中扮演的功能不同，又设置了四种工作缓冲区：用于收容输入数据的工作缓冲区（hin）、用于提取输入数据的工作缓冲区（sin）、用于收容输出数据的工作缓冲区（hout）、用于提取输出数据的工作缓冲区（sout）</li><li><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part5/image-20211116163116910.png" alt="image-20211116163116910" style="zoom:80%;"></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>操作系统-Part4</title>
      <link href="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part4/"/>
      <url>/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part4/</url>
      
        <content type="html"><![CDATA[<h1 id="操作系统-Part4——文件管理"><a href="#操作系统-Part4——文件管理" class="headerlink" title="操作系统-Part4——文件管理"></a>操作系统-Part4——文件管理</h1><p>[TOC]</p><h2 id="文件系统基础"><a href="#文件系统基础" class="headerlink" title="文件系统基础"></a>文件系统基础</h2><h3 id="初识文件管理"><a href="#初识文件管理" class="headerlink" title="初识文件管理"></a>初识文件管理</h3><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part4/image-20211111183657165.png" alt="image-20211111183657165"><ul><li>文件属性<ul><li><strong>文件名</strong>：由创建文件的用户决定文件名，主要是为了方便用户找到文件，<strong>同一目录下不允许有重名文件</strong>。</li><li><strong>标识符</strong>：一个系统内的各文件标识符唯一，对用户来说毫无可读性，因此标识符只是操作系统用于区分各个文件的一种内部名称。</li><li><strong>类型</strong>：指明文件的类型</li><li><strong>位置</strong>：文件存放的路径（让用户使用）、在外存中的地址（操作系统使用，对用户不可见）</li><li><strong>大小</strong>：指明文件大小</li><li><strong>创建时间、上次修改时间</strong></li><li><strong>文件所有者信息</strong></li><li><strong>保护信息</strong>：对文件进行保护的访问控制信息</li></ul></li><li>文件内部的数据组织<ul><li>无结构文件（如文本文件），由一些二进制或字符流组成，又称“流式文件”</li><li>有结构文件（如数据库表），由一组相似的记录组成，又称“记录式文件”<ul><li>记录是一组相关数据项的集合</li><li>数据项是文件系统中<strong>最基本的数据单位</strong></li><li><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part4/image-20211111182113600.png" alt="image-20211111182113600" style="zoom:67%;"></li></ul></li></ul></li><li>文件之间的组织<ul><li>目录（文件夹）其实也是一种特殊的有结构文件</li><li><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part4/image-20211111182238302.png" alt="image-20211111182238302" style="zoom:67%;"></li></ul></li><li>操作系统向上提供的功能<ul><li><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part4/image-20211111182641475.png" alt="image-20211111182641475" style="zoom: 50%;"></li><li>图形化交互操作的本质也是<strong>调用操作系统提供的接口</strong></li><li>可用几个基本操作完成更复杂的操作，比如：“复制文件”：先创建一个新的空文件，再把源文件读入内存，再将内存中的数据写到新文件中</li><li>读/写文件之前，需要“打开文件”</li><li>读/写文件结束之后，需要“关闭文件”</li></ul></li><li>文件在外存的存放<ul><li>外存也是由一个个存储单元组成的，每个存储单元可以存储一定量的数据（如 1B）。<ul><li>每个存储单元对应一个物理地址</li></ul></li><li>类似于内存分为一个个“内存块”，外存会分为一个个“块/磁盘块/物理块”。每个磁盘块的大小是相等的，每块一般包含 2 的整数幂个地址<ul><li>文件的逻辑地址也可以分为（逻辑块号，块内地址），操作系统同样需要将逻辑地址转 换为外存的物理地址（物理块号，块内地址）的形式。</li><li>块内地址的位数取决于磁盘块的大小</li></ul></li><li>操作系统<strong>以块为单位为文件分配存储空间、读入内存</strong><ul><li>即使一个文件大小只有 10B，但它依然需要占用 1KB 的磁盘块</li></ul></li></ul></li><li>其他需要由操作系统实现的文件管理功能<ul><li>文件共享：使多个用户可以共享使用一个文件</li><li>文件保护：如何保证不同的用户对文件有不同的操作权限</li></ul></li></ul><h3 id="文件的逻辑结构"><a href="#文件的逻辑结构" class="headerlink" title="文件的逻辑结构"></a>文件的逻辑结构</h3><p><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part4/image-20211111224112533.png" alt="image-20211111224112533"></p><ul><li>逻辑结构，指在用户看来，文件内部的数据应该是如何组织起来的。物理结构，指在操作系统看来，文件的数据是如何存放在外存中的。</li><li>按文件是否有结构分类，可以分为无结构文件、有结构文件两种。<ul><li><strong>无结构文件</strong>：文件内部的数据就是一系列二进制流或字符流组成。又称“<strong>流式文件</strong>”。</li><li><strong>有结构文件</strong>：由一组相似的记录组成，又称“<strong>记录式文件</strong>”。每条记录又若干个数据项组成。一般来说，每条记录有一个数据项可作为<strong>关键字</strong>（作为识别不同记录的ID）<ul><li>根据各条记录的长度（占用的存储空间）是否相等，又可分为<strong>定长记录</strong>和<strong>可变长记录</strong>两种。</li></ul></li></ul></li><li>有结构文件的逻辑结构<ul><li>顺序文件：文件中的记录一个接一个地顺序排列（逻辑上），记录可以是<strong>定长</strong>的或<strong>可变长</strong>的。各个记录在物理上可以<strong>顺序存储</strong>或<strong>链式存储</strong>。<ul><li><strong>串结构</strong>：记录之间的顺序与关键字无关</li><li><strong>顺序结构</strong>：记录之间的顺序按关键字顺序排序</li><li>一般来说，考试题目中所说的“顺序文件”指的是<strong>物理上顺序存储的顺序文件</strong>。<ul><li>顺序文件的缺点是增加/删除一个记录比较困难</li></ul></li><li><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part4/image-20211111223019417.png" alt="image-20211111223019417"></li></ul></li><li>索引文件：<ul><li>索引表本身是定长记录的顺序文件。</li><li>主要用于对信息处理的及时性要求比较高的场合。</li><li>可以用不同的数据项（属性）建立多个索引表。</li><li><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part4/image-20211111223256012.png" alt="image-20211111223256012" style="zoom: 67%;"></li></ul></li><li>索引顺序文件：<ul><li>是索引文件和顺序文件思想的结合。区别在于，不是每个记录对应一个索引表项，而是<strong>一组记录对应一个索引表项</strong>。</li><li><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part4/image-20211111223511426.png" alt="image-20211111223511426" style="zoom:67%;"></li></ul></li><li>多级索引顺序文件<ul><li><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part4/image-20211111223713847.png" alt="image-20211111223713847" style="zoom:67%;"></li></ul></li></ul></li></ul><h3 id="文件目录"><a href="#文件目录" class="headerlink" title="文件目录"></a>文件目录</h3><p><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part4/image-20211111230036761.png" alt="image-20211111230036761"></p><ul><li><strong>文件控制块</strong>（File Control Block，FCB）<ul><li>目录本身就是一种有结构文件，由一条条记录组成。每条记录对应一个在该放在该目录下的文件</li><li><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part4/image-20211111230640935.png" alt="image-20211111230640935"></li><li>对目录进行的操作<ul><li>搜索：当用户要使用一个文件时，系统要根据文件名搜索目录，找到该文件对应的目录项</li><li>创建文件：创建一个新文件时，需要在其所属的目录中增加一个目录项</li><li>删除文件：当删除一个文件时，需要在目录中删除相应的目录项</li><li>显示目录：用户可以请求显示目录的内容，如显示该目录中的所有文件及相应属性</li><li>修改目录：某些文件属性保存在目录中，因此这些属性变化时需要修改相应的目录项（如：文件重命名）</li></ul></li></ul></li><li><strong>目录结构</strong><ul><li><strong>单级目录结构</strong><ul><li>早期操作系统并不支持多级目录，整个系统中只建立一张目录表，每个文件占一个目录项。</li><li>特点：单级目录实现了“按名存取”，但是不允许文件重名。</li><li>缺点：不适用于多用户操作系统。</li></ul></li><li><strong>两级目录结构</strong><ul><li>早期的多用户操作系统，采用两级目录结构。分为<strong>主文件目录</strong>（MFD，Master File Directory）和<strong>用户文件目录</strong>（UFD，User Flie Directory）。</li><li>特点：1. 允许不同用户的文件重名；2. 可以在目录上实现实现访问限制</li><li>缺点：依然缺乏灵活性，用户不能对自己的文件进行分类</li></ul></li><li><strong>多级目录结构</strong>（树形目录结构）<ul><li><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part4/image-20211111231141027.png" alt="image-20211111231141027" style="zoom:80%;"></li><li>系统根据<strong>绝对路径</strong>一层一层地找到下一级目录。刚开始从外存读入根目录的目录表；找到“照片”目录的存放位置后，从外存读入对应的目录表；再找到“2015-08”目录的存放位置，再从外存读入对应目录表；最后才找到文件“自拍.jpg”的存放位置。<strong>整个过程需要 3 次读磁盘 I/O 操作</strong>。</li><li>引入<strong>当前目录</strong>和<strong>相对路径</strong>后，磁盘 I/O 的次数减少，提升了访问文件的效率。</li><li>特点：可以很方便地对文件进行分类，层次结构清晰，也能够更有效地进行文件的管理和保护。</li><li>缺点：<strong>不便于实现文件的共享</strong>。</li></ul></li><li><strong>无环图目录结构</strong><ul><li><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part4/image-20211111231431422.png" alt="image-20211111231431422" style="zoom:80%;"></li><li>可以用不同的文件名指向同一个文件或目录</li><li>实现：<strong>为每个共享结点设置一个共享计数器</strong>，用于记录此时有多少个地方在共享该结点。用户提出删除结点的请求时，只是<strong>删除该用户的 FCB、并使共享计数器减 1</strong>，并不会直接删除共享结点。<strong>只有共享计数器减为 0 时，才删除结点</strong>。</li><li>共享文件不同于复制文件。在共享文件中，由于各用户指向的是同一个文件，因此只要其中一个用户修改了文件数据，那么所有用户都可以看到文件数据的变化。</li></ul></li></ul></li><li>索引结点（FCB的改进）<ul><li>使用索引结点机制，磁盘块可容纳的 FCB 增多，对于拥有较多目录项的目录来说，减少了 I/O 次数，大大提升文件检索速度。</li><li>存放<strong>在外存中</strong>的索引结点称为“<strong>磁盘索引结点</strong>”；当索引结点<strong>放入内存后</strong>称为“<strong>内存索引结点</strong>”。</li><li>相比之下<strong>内存索引结点中需要增加一些信息</strong>，比如：文件是否被修改、此时有几个进程正在访问该文件等</li><li><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part4/image-20211111231941136.png" alt="image-20211111231941136" style="zoom: 67%;"></li></ul></li></ul><h3 id="文件保护"><a href="#文件保护" class="headerlink" title="文件保护"></a>文件保护</h3><p><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part4/image-20211112110535854.png" alt="image-20211112110535854"></p><ul><li><strong>口令保护</strong><ul><li>用户<strong>请求访问该文件时必须提供口令</strong>。<ul><li>口令一般存放在文件对应的 <strong>FCB</strong> 或<strong>索引结点</strong>中。</li></ul></li><li>优点：保存口令的空间开销不多，验证口令的时间开销也很小。</li><li>缺点：正确的口令存放在系统内部，<strong>不够安全</strong>。</li></ul></li><li><strong>加密保护</strong><ul><li>使用密码对文件进行加密保存，在访问文件时需要提供正确的密码才能对文件进行解密。</li><li>优点：保密性强，不需要在系统中存储“密码”</li><li>缺点：编码/译码，或者说加密/解密要花费一定时间。</li><li><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part4/image-20211112111542108.png" alt="image-20211112111542108" style="zoom: 80%;"></li></ul></li><li><strong>访问控制</strong><ul><li><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part4/image-20211112112011037.png" alt="image-20211112112011037"></li><li>在每个文件的 FCB（或索引结点）中增加一个<strong>访问控制列表</strong>（Access-Control List，ACL），该表中记录了各个用户可以对该文件执行哪些操作。</li><li><strong>精简的访问列表</strong>：<strong>以组为单位</strong>，标记各组用户可以对文件执行哪些操作。</li><li>如果对<strong>某个目录</strong>进行了访问权限的控制，那也要对<strong>目录下的所有文件</strong>进行相同的访问权限控制</li></ul></li></ul><h3 id="文件共享"><a href="#文件共享" class="headerlink" title="文件共享"></a>文件共享</h3><p><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part4/image-20211112112227710.png" alt="image-20211112112227710"></p><ul><li>注意：<ul><li>多个用户<strong>共享</strong>同一个文件，意味着系统中只有<strong>一份</strong>文件数据。用户对该文件的修改，在用户之间是共享的、可见的。</li><li>多个用户<strong>复制</strong>同一个文件，意味着系统中会有<strong>多份</strong>文件数据。用户对自己文件的修改，对其他用户的文件数据并没有影响。</li></ul></li><li><strong>基于索引结点的共享方式（硬链接）</strong><ul><li><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part4/image-20211112113309277.png" alt="image-20211112113309277"></li><li>索引结点中设置一个链接计数变量 count，用于表示链接到本索引结点上的用户目录项数。</li><li>若 count&gt;1，说明此时<strong>有多个用户目录项链接到该索引结点上</strong>，或者说<strong>有多个用户在共享此文件</strong>。</li><li>若某个用户删除该文件，则只是<strong>把目录中与该文件对应的目录项删除</strong>，且<strong>索引结点的 count 值减 1</strong>。 </li><li>若 count&gt;0，说明还有别的用户要使用该文件，暂时不能把文件数据删除，否则会导致指针悬空。</li><li>当 count=0 时系统负责删除文件。</li></ul></li><li><strong>基于符号链的共享方式（软链接）</strong><ul><li><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part4/image-20211112113608981.png" alt="image-20211112113608981" style="zoom:80%;"></li><li>当 Link 型文件被删除时，Link 指向的文件依然存在</li><li>当 Link 指向的文件被删除时，该 Link 型文件失效</li></ul></li></ul><h2 id="文件系统实现"><a href="#文件系统实现" class="headerlink" title="文件系统实现"></a>文件系统实现</h2><h3 id="文件的物理结构（重点）"><a href="#文件的物理结构（重点）" class="headerlink" title="文件的物理结构（重点）"></a>文件的物理结构（重点）</h3><p><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part4/image-20211112114305513.png" alt="image-20211112114305513"></p><ul><li><p>文件块、磁盘块</p><ul><li>文件的逻辑地址空间也被分为了一个个<strong>文件块</strong>，也可以表示为<strong>（逻辑块号，块内地址）</strong>的形式。</li><li>通常，<strong>磁盘块的大小与内存块、页面的大小相同</strong></li><li>内存与磁盘之间的数据交换（即读/写操作、磁盘 I/O）都是以块为单位进行的。</li></ul></li><li><p>连续分配</p><ul><li><p>连续分配方式要求<strong>每个文件在磁盘上占有一组连续的块</strong>。</p></li><li><p>逻辑地址到物理地址的映射</p><ul><li>（逻辑块号，块内地址）-&gt;（物理块号，块内地址）。只需转换块号就行，块内地址保持不变</li><li>物理块号 = 起始块号 + 逻辑块号</li><li>同时，还要检查逻辑块号是否合法（逻辑块号 ≤ 长度）</li></ul></li><li><p>优点</p><ul><li><strong>连续分配支持顺序访问和直接访问</strong>（随机访问）</li><li><strong>连续分配的文件在顺序读/写时速度最快</strong></li></ul></li><li><p>缺点</p><ul><li><strong>文件不方便拓展</strong>。</li><li><strong>存储空间利用率低</strong>，<strong>会产生难以利用的磁盘碎片</strong>（可以用<strong>紧凑</strong>来处理碎片，但是需要耗费很大的时间代价）</li></ul></li><li><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part4/image-20211112210113773.png" alt="image-20211112210113773" style="zoom: 67%;"></li></ul></li></ul><ul><li>链接分配<ul><li>隐式链接<ul><li>除文件的最后一个盘块之外，每个盘块中都存有<strong>指向下一个盘块的指针</strong>。文件目录包括文件<strong>第一块</strong>的指针和<strong>最后一块</strong>的指针。</li><li>优点：<ul><li>很方便文件拓展</li><li>不会有碎片问题，外存利用率高。</li></ul></li><li>缺点：<ul><li>只支持顺序访问，查找效率低</li><li>指向下一个盘块的指针也需要耗费少量的存储空间</li></ul></li><li><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part4/image-20211112211102158.png" alt="image-20211112211102158" style="zoom:67%;"></li></ul></li><li>显式链接<ul><li>把用于链接文件各物理块的指针显式地存放在一张表中。即，<strong>文件分配表</strong>（<strong>FAT</strong>，File Allocation Table）</li><li>注意：<strong>一个磁盘仅设置一张FAT。开机时，将FAT读入内存，并常驻内存</strong>。<ul><li><strong>逻辑块号转换成物理块号的过程不需要读磁盘操作</strong>。</li></ul></li><li>优点：<ul><li>支持顺序访问，也<strong>支持随机访问</strong></li><li><strong>块号转换的过程不需要访问磁盘，文件的访问效率更高</strong></li><li><strong>不会产生外部碎片</strong>，也可以很方便地对文件进行拓展</li></ul></li><li>缺点：<ul><li>文件分配表的需要占用一定的存储空间。</li></ul></li><li><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part4/image-20211112211434277.png" alt="image-20211112211434277" style="zoom:67%;"></li></ul></li></ul></li><li>索引分配<ul><li>系统<strong>为每个文件建立一张索引表</strong>，索引表中<strong>记录了文件的各个逻辑块对应的物理块</strong>（内存管理中的页表：建立<strong>逻辑页面</strong>到<strong>物理页</strong>之间的映射关系）。</li><li>索引表存放的磁盘块称为<strong>索引块</strong>。文件数据存放的磁盘块称为<strong>数据块</strong>。</li><li>注意：<ul><li><strong>显式链接</strong>方式中，文件分配表 FAT 是<strong>一个磁盘对应一张</strong>。</li><li><strong>索引分配</strong>方式中，索引表是<strong>一个文件对应一张</strong>。</li></ul></li><li>优点：<ul><li>可以支持随机访问。</li><li>文件拓展也很容易实现</li></ul></li><li>缺点<ul><li>索引表需要占用一定的存储空间</li></ul></li><li><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part4/image-20211112212647379.png" alt="image-20211112212647379" style="zoom:67%;"></li><li><strong>链接方案</strong>：<ul><li>如果索引表太大，一个索引块装不下，那么可以将多个索引块链接起来存放。</li><li>缺点：若文件很大，索引表很长，就需要将很多个索引块链接起来。<strong>查找效率低下</strong>。</li><li><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part4/image-20211112213257207.png" alt="image-20211112213257207" style="zoom:67%;"></li></ul></li><li><strong>多层索引</strong>：<ul><li>建立多层索引（原理类似于多级页表）。</li><li>结论：<ul><li>采用 <strong>k</strong> 层索引结构时，且<strong>顶级索引表未调入内存</strong>，则访问一个数据块只需要 <strong>K+1</strong> 次磁盘操作</li></ul></li><li>缺点：<ul><li>即使是小文件，访问一个数据块依然需要 K+1 次读磁盘。</li></ul></li><li><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part4/image-20211112213345728.png" alt="image-20211112213345728" style="zoom:67%;"></li></ul></li><li><strong>混合索引</strong>：<ul><li>多种索引分配方式的结合。</li><li>优点：<ul><li><strong>对于小文件来说，访问一个数据块所需的读磁盘次数更少</strong>。</li></ul></li><li><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part4/image-20211112214310115.png" alt="image-20211112214310115" style="zoom:80%;"></li></ul></li><li><strong>超级超级超级重要考点</strong>：<ul><li>要会根据多层索引、混合索引的结构计算出文件的最大长度（Key：<strong>各级索引表最大不能超过一个块</strong>）；</li><li>要能自己分析访问某个数据块所需要的读磁盘次数Key：FCB 中会存有<strong>指向顶级索引块</strong>的指针，因此可以根据 FCB 读入顶级索引块。每次读入下一级的索引块都需要一次读磁盘操作。另外，要注意题目条件：<strong>顶级索引块是否已调入内存</strong>）</li></ul></li></ul></li></ul><h3 id="逻辑结构-VS-物理结构"><a href="#逻辑结构-VS-物理结构" class="headerlink" title="逻辑结构 VS 物理结构"></a>逻辑结构 VS 物理结构</h3><p><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part4/image-20211112215804531.png" alt="image-20211112215804531"><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part4/image-20211112215911132.png" alt="image-20211112215911132" style="zoom: 50%;"></p><ul><li>个人理解：<ul><li>逻辑结构，是用户针对<strong>文件中价值内容</strong>的组织，追求对内容的查询效率</li><li>物理结构，是操作系统针对<strong>空间利用率</strong>、<strong>物理查询速度</strong>的优化，对内容是无关的</li></ul></li></ul><h3 id="文件存储空间管理"><a href="#文件存储空间管理" class="headerlink" title="文件存储空间管理"></a>文件存储空间管理</h3><p><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part4/image-20211112221825169.png" alt="image-20211112221825169"></p><ul><li><p>存储空间的划分与初始化</p><ul><li><p>存储空间的划分：将物理磁盘划分为一个个<strong>文件卷</strong>（<strong>逻辑卷、逻辑盘</strong>）</p><ul><li>同时，也有系统可以支持<strong>由多个物理磁盘组成一个文件卷</strong></li></ul></li><li><p>存储空间的初始化：<strong>将各个文件卷划分为目录区、文件区</strong>。</p><ul><li><strong>目录区</strong>，主要存放文件目录信息（FCB）、用于磁盘存储空间管理的信息</li><li><strong>文件区</strong>，用于存放文件数据</li></ul></li><li><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part4/image-20211113222439483.png" alt="image-20211113222439483" style="zoom:67%;"></li></ul></li><li><p>从三个方面进行理解：</p><ol><li><p>用什么方式记录、组织空闲块？</p></li><li><p>如何分配磁盘块</p></li><li><p>如何回收磁盘块</p></li></ol></li><li><p>存储空间管理</p><ul><li><p>空闲表法</p><ul><li><p>特点：</p><ul><li>适用于“连续分配方式”</li></ul></li><li><p>如何分配磁盘块：</p><ul><li>与<strong>内存管理中的动态分区分配</strong>很类似，为一个文件<strong>分配连续的存储空间</strong>。</li><li>可采用<strong>首次适应、最佳适应、最坏适应等算法</strong>来决定要为文件分配哪个区间。</li></ul></li><li><p>如何回收磁盘块：</p><ul><li><p>与<strong>内存管理中的动态分区分配</strong>很类似，当回收某个存储区时需要有四种情况</p><ul><li>回收区的前后都没有相邻空闲区</li><li>回收区的前后都是空闲区</li><li>回收区前面是空闲区</li><li>回收区后面是空闲区。</li></ul></li><li><p>总之，回收时需要注意表项的合并问题。</p></li></ul></li><li><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part4/image-20211113223018472.png" alt="image-20211113223018472" style="zoom:80%;"></li></ul></li><li><p>空闲链表法</p><ul><li><p><strong>操作系统保存着链头、链尾指针</strong>。</p></li><li><p>空闲盘块链：</p><ul><li>如何分配：若某文件申请 K 个盘块，则<strong>从链头开始依次摘下 K 个盘块分配</strong>，并修改空闲链的链头指针。</li><li>如何回收：<strong>回收的盘块依次挂到链尾</strong>，并修改空闲链的链尾指针。</li></ul></li><li><p>空闲盘区链：</p><ul><li>如何分配：若某文件申请 K 个盘块，则可以<strong>采用首次适应、最佳适应等算法</strong>，从链头开始检索，按照算法规则找到一个大小符合要求的空闲盘区，分配给文件。若没有合适的连续空闲块，也可以将不同盘区的盘块同时分配给一个文件，注意分配后可能要修改相应的链指针、盘区大小等数据。</li><li>如何回收：若回收区和某个空闲盘区相邻，则需要将回收区<strong>合并</strong>到空闲盘区中。若回收区没有和任何空闲区相邻，将回收区作为单独的一个空闲盘区<strong>挂到链尾</strong>。</li></ul></li><li><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part4/image-20211113223526372.png" alt="image-20211113223526372" style="zoom:80%;"></li></ul></li><li><p>位示图法（常考）</p><ul><li>每个二进制位对应一个盘块。<ul><li>位示图一般用连续的“字”来表示，如本例中一个字的字长是 16 位，<strong>字中的每一位对应一个盘块</strong>。</li><li>可以用（<strong>字号，位号</strong>）对应一个盘块号。当然有的题目中也描述为（<strong>行号，列号</strong>）</li></ul></li><li>重要：要能自己推出盘块号与（字号，位号）相互转换的公式。<ul><li>注意题目条件，盘块号、字号、位号到底是从 0 开始还是从 1 开始</li><li>（字号，位号）=（i，j）的二进制位对应的*<em>盘块号 b = n * i + j*</em></li><li>b 号盘块对应的<strong>字号 i = b / n，位号 j = b % n</strong>。</li></ul></li><li>如何分配：若文件需要 K 个块<ul><li>顺序扫描位示图，找到 K 个相邻或不相邻的“0”</li><li>根据字号、位号算出对应的盘块号，将相应盘块分配给文件</li><li>将相应位设置为“1”。</li></ul></li><li>如何回收：<ul><li>根据回收的盘块号计算出对应的字号、位号</li><li>将相应二进制位设为“0” </li></ul></li><li><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part4/image-20211114190154046.png" alt="image-20211114190154046" style="zoom:80%;"></li></ul></li><li><p>成组链接法</p><ul><li>针对问题：<strong>空闲表法、空闲链表法不适用于大型文件系统</strong>，因为空闲表或空闲链表可能过大。</li><li>改进方向：UNIX 系统中采用了成组链接法对磁盘空闲块进行管理。</li><li>文件卷的<strong>目录区中专门用一个磁盘块作为“超级块”</strong>，当系统<strong>启动时需要将超级块读入内存</strong>。并且要<strong>保证内存与外存中的“超级块”数据一致</strong>。</li><li>下一组（指第二列）空闲盘块数为 100；（第一列）有 99 个指针指向真正空闲的盘区，第一个指针指向的盘块记录下下组（第三列）的空闲盘块信息。</li><li>如何分配：<ul><li>先从下一组（第二列）中取，同时删去第一列对应的指针，减少下一组空闲盘块数</li><li>若下一组（第二列）分配完，则超级块更新内容（复制第一个空闲块的信息），指向第三组的信息，同时第二列第一块空闲被分配。</li><li><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part4/image-20211114192427463.png" alt="image-20211114192427463"></li></ul></li><li>如何回收：<ul><li>需要将超级块中的数据复制到新回收的块中，并修改超级块的内容，让新回收的块成为第一个分组。</li><li><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part4/image-20211114193521443.png" alt="image-20211114193521443"></li></ul></li></ul></li></ul></li></ul><h3 id="文件的基本操作"><a href="#文件的基本操作" class="headerlink" title="文件的基本操作"></a>文件的基本操作</h3><p><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part4/image-20211114203102662.png" alt="image-20211114203102662"></p><ul><li><p>创建文件</p><ul><li><p>需要提供的参数：</p><ul><li>所需的外存空间大小（如，一个盘块，即 1KB）</li><li>文件存放路径（如，“D:/Demo”）</li><li>文件名（如，“新建文本文档.txt”）</li></ul></li><li><p>操作系统处理 Create 系统调用：</p><ul><li><strong>在外存中找到文件所需的空间</strong>（<strong>分配空闲的磁盘空间</strong>）</li><li>根据文件存放路径的信息找到<strong>该目录对应的目录文件</strong>，在目录中<strong>创建该文件对应的目录项</strong>。目录项中包含了文件名、文件在外存中的存放位置等信息。</li></ul></li></ul></li><li><p>删除文件</p><ul><li><p>需要提供的参数：</p><ul><li>文件存放路径（如，“D:/Demo”）</li><li>文件名（如，“test.txt”）</li></ul></li><li><p>操作系统处理 Delete 系统调用：</p><ul><li>根据文件存放路径找到相应的目录文件，从目录中<strong>找到文件名对应的目录项</strong>。</li><li>根据该目录项记录的文件在外存的存放位置、文件大小等信息，<strong>回收文件占用的磁盘块</strong>。（<strong>回收空闲的磁盘空间</strong>）</li><li>从目录表中<strong>删除文件对应的目录项</strong>。</li></ul></li></ul></li><li><p>打开文件</p><ul><li><p>需要提供的参数：</p><ul><li>文件存放路径（如，“D:/Demo”）</li><li>文件名（如，“test.txt”）</li><li>要对文件的操作类型（如，r 只读、rw 读写等）</li></ul></li><li><p>操作系统处理 open 系统调用：</p><ul><li>根据文件存放路径找到相应的目录文件，从目录中<strong>找到文件名对应的的目录项</strong>，并<strong>检查该用户是否有指定的操作权限</strong>。</li><li><strong>将目录项复制到内存中的“打开文件表”中</strong>。并将对应表目的编号返回给用户。之后<strong>用户使用打开文件表的编号来指明要操作的文件</strong>。</li></ul></li><li><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part4/image-20211114195520247.png" alt="image-20211114195520247" style="zoom: 67%;"></li><li><p>进程的打开文件表和系统的打开文件表</p><ul><li><p>进程的打开文件表记录</p><ul><li>读写指针：记录了该进程对文件的读/写操作进行到的位置。每个进程都有不同的指针指向不同位置。</li><li>访问模式：如果打开文件时声明的是“只读”，则该进程不能对文件进行写操作</li></ul></li><li><p>系统的打开文件表记录（系统唯一）</p><ul><li>打开计数器：记录此时有多少个进程打开了此文件。若多个进程占用，则不允许删除。</li></ul></li><li><p><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part4/image-20211114200250821.png" alt="image-20211114200250821"></p></li></ul></li></ul></li><li><p>关闭文件</p><ul><li>操作系统处理 Close 系统调用：<ul><li>将进程的打开文件表响应的表项删除</li><li>回收分配给该文件的内存空间等资源</li><li>系统打开文件表的打开计数器 -1，若 count=0，则删除对应表项</li></ul></li></ul></li><li><p>读文件</p><ul><li>需要提供的参数：<ul><li>指明哪个文件（<strong>在读文件之前已经打开文件了，所以只需要指明文件在进程的打开文件表中的索引号即可</strong>）</li><li>指明读入多少数据</li><li>指明<strong>从外存读入</strong>的数据要放在内存中的位置</li></ul></li><li>操作系统处理 Read 系统调用：<ul><li>从<strong>读指针指向的外存</strong>中，将用户指定大小的数据读入用户指定的内存区域中。</li></ul></li></ul></li><li><p>写文件</p><ul><li>需要提供的参数：<ul><li>指明哪个文件（<strong>指明文件在进程的打开文件表中的索引号</strong>）</li><li>指明写出多少数据</li><li>指明<strong>写回外存</strong>的数据放在内存中的位置</li></ul></li><li>操作系统处理 Write 系统调用：<ul><li>从用户指定的内存区域中，将指定大小的数据写回<strong>写指针指向的外存</strong>。</li></ul></li></ul></li></ul><h3 id="文件系统的层次结构"><a href="#文件系统的层次结构" class="headerlink" title="文件系统的层次结构"></a>文件系统的层次结构</h3><p><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part4/image-20211114203949942.png" alt="image-20211114203949942"></p><p>辅助记忆：假设某用户请求删除文件 “D:/工作目录/学生信息.xlsx” 的最后100条记录。</p><ol><li><p>用户需要通过操作系统提供的接口发出请求——<strong>用户接口</strong></p></li><li><p>由于提供的是文件的存放路径，因此需要操作系统一层一层地查找目录，找到对应的目录项——<strong>文件目录系统</strong></p></li><li><p>不同的用户对文件有不同的操作权限，因此为了保证安全，需要检查用户是否有访问权限——<strong>存取控制模块（存取控制验证层）</strong></p></li><li><p>验证了用户的访问权限之后，需要把用户提供的“记录号”转变为对应的逻辑地址——<strong>逻辑文件系统与文件信息缓冲区</strong></p></li><li><p>知道了目标记录对应的逻辑地址后，还需要转换成实际的物理地址——<strong>物理文件系统</strong></p></li><li><p>要删除这条记录，必定要对磁盘设备发出请求——<strong>设备管理程序模块</strong></p></li><li><p>删除这些记录后，会有一些盘块空闲，因此要将这些空闲盘块回收——<strong>辅助分配模块</strong></p></li></ol><h2 id="磁盘组织与管理"><a href="#磁盘组织与管理" class="headerlink" title="磁盘组织与管理"></a>磁盘组织与管理</h2><h3 id="磁盘的结构"><a href="#磁盘的结构" class="headerlink" title="磁盘的结构"></a>磁盘的结构</h3><p><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part4/image-20211115125801360.png" alt="image-20211115125801360"></p><ul><li>磁盘：磁盘的<strong>表面由一些磁性物质组成</strong>，可以用这些磁性物质来<strong>记录二进制数据</strong>。</li><li>磁道：磁盘的盘面被划分成一个个磁道，一个“圈”就是一个磁道</li><li>扇区：一个磁道被划分成多个扇区，<strong>每个扇区</strong>就是一个“<strong>磁盘块</strong>”。各个扇区存放的数据量相同（如1KB）<ul><li>最内侧磁道上的扇区面积最小，因此数据密度最大</li><li>重要：<strong>每个扇区</strong>就是一个“<strong>磁盘块</strong>”！</li></ul></li><li>盘面：一个盘片可能会有两个盘面</li><li>磁头：每个盘面对应一个磁头。<strong>所有的磁头只能共进退</strong>。</li><li><strong>磁盘的物理地址</strong><ul><li><strong>可用（柱面号，盘面号，扇区号）来定位任意一个“磁盘块”</strong>。外存中的块号就可以转换成（柱面号，盘面号，扇区号）的地址形式。</li><li>读取一个“块”的流程<ul><li>根据“柱面号”移动磁臂，让磁头指向<strong>指定柱面</strong>；</li><li><strong>激活指定盘面对应的磁头</strong>；</li><li>磁盘旋转的过程中，指定的扇区从磁头下面划过，完成对指定扇区的读/写。</li></ul></li></ul></li><li>磁盘的分类<ul><li>根据磁头分类：<ul><li>磁头可以移动的称为<strong>活动头磁盘</strong>。磁臂可以来回伸缩来带动磁头定位磁道</li><li>磁头不可移动的称为<strong>固定头磁盘</strong>。这种磁盘中每个磁道有一个磁头</li></ul></li><li>根据是否可以更换分类：<ul><li>盘片可以更换的称为<strong>可换盘磁盘</strong>。</li><li>盘片不可更换的称为<strong>固定盘磁盘</strong>。</li></ul></li></ul></li><li><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part4/image-20211115125719713.png" alt="image-20211115125719713"></li></ul><h3 id="磁盘调度算法"><a href="#磁盘调度算法" class="headerlink" title="磁盘调度算法"></a>磁盘调度算法</h3><p><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part4/image-20211115125939512.png" alt="image-20211115125939512"></p><ul><li><p>一次磁盘读/写操作需要的时间</p><ul><li>**寻找时间（寻道时间）T<del>S</del>**：在读/写数据前，将磁头移动到指定磁道所花的时间。<ul><li><strong>启动磁头臂</strong>是需要时间的。假设耗时为 s；</li><li><strong>移动磁头</strong>也是需要时间的。假设磁头匀速移动，每跨越一个磁道耗时为 m，总共需要跨越 n 条磁道；</li><li>寻道时间 *<em>T<del>S</del> = s + m * n*</em> </li></ul></li><li>**延迟时间 T<del>R</del>**：通过旋转磁盘，使磁头定位到目标扇区所需要的时间。<ul><li>设磁盘转速为 r （单位：转/秒，或 转/分）<ul><li>硬盘的典型转速为 5400 转/分，或 7200 转/分</li></ul></li><li>平均所需的延迟时间 *<em>T<del>R</del> = (1/2)</em>(1/r) = 1/2r**<ul><li>找到目标扇区平均需要转半圈，因此再乘以 1/2</li></ul></li></ul></li><li>**传输时间 T<del>t</del>**：从磁盘读出或向磁盘写入数据所经历的时间<ul><li>假设磁盘转速为 r，此次读/写的字节数为 b，每个磁道上的字节数为 N</li><li>传输时间 *<em>T<del>t</del> = (1/r) * (b/N) = b/(rN)*</em></li></ul></li><li>延迟时间、传输时间都<strong>与磁盘转速为线性相关</strong>。而转速是硬件的固有属性，因此<strong>操作系统无法优化延迟时间和传输时间</strong></li><li><strong>移动磁头</strong>所花费的时间，是磁盘调度算法影响的指标</li></ul></li><li><p>磁盘调度算法</p><ul><li><p>先来先服务算法（FCFS）</p><ul><li>算法思想：根据进程请求访问磁盘的先后顺序进行调度。<ul><li><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part4/image-20211115131917033.png" alt="image-20211115131917033" style="zoom: 80%;"></li></ul></li><li>优点：公平；如果请求访问的磁道比较集中，则算法性能还行</li><li>缺点：如果有大量进程竞争使用磁盘，请求访问的磁道很分散，则 FCFS 在性能上很差，寻道时间长。</li></ul></li><li><p>最短寻找时间优先（SSTF）</p><ul><li>算法思想：SSTF 算法会优先处理的磁道是与当前磁头最近的磁道。<ul><li><strong>可以保证每次的寻道时间最短，但是并不能保证总的寻道时间最短</strong>。</li><li><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part4/image-20211115132033429.png" alt="image-20211115132033429" style="zoom:80%;"></li></ul></li><li>优点：性能较好，平均寻道时间短</li><li>缺点：<strong>可能产生“饥饿”现象</strong></li></ul></li><li><p>扫描算法（SCAN）</p><ul><li>针对问题：SSTF 算法会产生饥饿</li><li>问题原因：磁头有可能<strong>在一个小区域内来回移动</strong>。</li><li>算法思想：<strong>扫描算法（电梯算法）规定，只有磁头移动到最外侧磁道的时候才能往内移动，移动到最内侧磁道的时候才能往外移动</strong>。<ul><li><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part4/image-20211115132330637.png" alt="image-20211115132330637" style="zoom:80%;"></li></ul></li><li>优点：性能较好，平均寻道时间较短，不会产生饥饿现象</li><li>缺点：<ul><li>只有到达最边上的磁道才能改变磁头移动方向。</li><li><strong>对于各个位置磁道的响应频率不平均</strong></li></ul></li></ul></li><li><p>LOOK 调度算法</p><ul><li>针对问题：扫描算法只有到达最边上的磁道才能改变磁头移动方向。</li><li>算法思想：<strong>如果在磁头移动方向上已经没有别的请求，就可以立即改变磁头移动方向</strong>。（边移动边观察，因此叫 LOOK）<ul><li><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part4/image-20211115132956097.png" alt="image-20211115132956097" style="zoom:80%;"></li></ul></li><li>优点：比起 SCAN 算法，<strong>使寻道时间进一步缩短</strong>。</li></ul></li><li><p>循环扫描算法（C-SCAN）</p><ul><li>针对问题：扫描算法对于各个位置磁道的响应频率不平均。</li><li>算法思想：规定<strong>只有磁头朝某个特定方向移动时才处理磁道访问请求</strong>，而<strong>返回时直接快速移动至起始端而不处理任何请求</strong>。<ul><li><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part4/image-20211115133606481.png" alt="image-20211115133606481" style="zoom:80%;"></li></ul></li><li>优点：比起 SCAN，对于各个位置磁道的响应频率很平均。</li><li>缺点：<ul><li>只有到达最边上的磁道时才能改变磁头移动方向</li><li>磁头返回时其实只需要返回到 18 号磁道即可，不需要返回到最边缘的磁道。</li><li>比起 SCAN 算法，平均寻道时间更长。</li></ul></li></ul></li><li><p>C-LOOK 调度算法</p><ul><li>算法思想：如果磁头移动的方向上已经没有磁道访问请求了，就可以立即让磁头返回，并且磁头只需要返回到有磁道访问请求的位置即可。<ul><li>也就是 C-SCAN + LOOK</li><li><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part4/image-20211115133949701.png" alt="image-20211115133949701" style="zoom:80%;"></li></ul></li><li>优点：比起 C-SCAN 算法，不需要每次都移动到最外侧或最内侧才改变磁头方向，<strong>使寻道时间进一步缩短</strong></li></ul></li><li><blockquote><p>若题目中无特别说明， 则 SCAN 就是 LOOK， C-SCAN 就是 C-LOOK</p></blockquote></li></ul></li></ul><h3 id="减少磁盘延迟时间的方法"><a href="#减少磁盘延迟时间的方法" class="headerlink" title="减少磁盘延迟时间的方法"></a>减少磁盘延迟时间的方法</h3><p><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part4/image-20211115150136330.png" alt="image-20211115150136330"></p><ul><li>针对问题：磁头读入一个扇区数据后需要一小段时间处理，如果<strong>逻辑上相邻的扇区在物理上也相邻，则将花费很长的延迟时间</strong></li><li>减少延迟时间的方法：<strong>交替编号</strong><ul><li>采用交替编号的策略，即让逻辑上相邻的扇区在物理上有一定的间隔，可以使读取连续的逻辑扇区所需要的延迟时间更小。</li><li><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part4/image-20211115145219763.png" alt="image-20211115145219763" style="zoom: 67%;"></li></ul></li><li><strong>磁盘地址结构的设计</strong><ul><li><strong>磁盘的物理地址是（柱面号，盘面号，扇区号）</strong>而不是（盘面号，柱面号，扇区号）</li><li>原因：读取地址连续的磁盘块时，采用（柱面号，盘面号，扇区号）的地址结构<strong>可以减少磁头移动消耗的时间</strong>，<strong>仅需激活不同盘面上的磁头</strong>。</li></ul></li><li>减少延迟时间的方法：<strong>错位命名</strong><ul><li>为了在读取地址连续的磁盘块、切换盘面激活磁头时，需要空出间隔保证磁头启动。</li><li><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part4/image-20211115145913456.png" alt="image-20211115145913456" style="zoom:67%;"></li></ul></li></ul><h3 id="磁盘的管理"><a href="#磁盘的管理" class="headerlink" title="磁盘的管理"></a>磁盘的管理</h3><p><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part4/image-20211115150211019.png" alt="image-20211115150211019"></p><ul><li>磁盘初始化：<ol><li>进行<strong>低级格式化（物理格式化）</strong>，将磁盘的各个磁道划分为扇区。一个扇区通常可分为<strong>头</strong>、<strong>数据区域</strong>（如 512B 大小）、<strong>尾</strong>三个部分组成。<ul><li>管理扇区所需要的各种数据结构一般存放在<strong>头、尾</strong>两个部分，包括扇区校验码（如奇偶校验、CRC 循环冗余校验码等）</li></ul></li><li>将磁盘分区，每个分区由若干柱面组成（即分为我们熟悉的 C盘、D盘、E盘）<ul><li><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part4/image-20211115151139969.png" alt="image-20211115151139969" style="zoom:50%;"></li></ul></li><li>进行<strong>逻辑格式化</strong>，<strong>创建文件系统</strong>。包括创建文件系统的根目录、初始化存储空间管理所用的数据结构（如 位示图、空闲分区表）</li></ol></li><li>引导块：<ul><li>计算机开机时需要进行初始化，这些初始化工作是通过执行<strong>初始化程序（自举程序）</strong>完成的<ul><li>出厂时在主板上将集成一块<strong>不可修改的 ROM</strong>（只读存储器），其中只存放很小的“<strong>自举装入程序</strong>”</li><li>完整的自举程序放在磁盘的启动块（即<strong>引导块/启动分区</strong>）上，<strong>启动块位于磁盘的固定位置</strong>。</li><li>开机时计算机先运行“自举装入程序”，通过执行该程序就可找到引导块，并将完整的“自举程序”读入内存，完成初始化</li></ul></li><li>拥有启动分区的磁盘称为<strong>启动磁盘</strong>或<strong>系统磁盘</strong>。</li></ul></li><li>坏块的管理<ul><li>对于简单的磁盘，可以在<strong>逻辑格式化</strong>时对整个磁盘进行坏块检查，标明哪些扇区是坏扇区，比如：在文件分配表（FAT）上标明。<ul><li>在这种方式中，<strong>坏块对操作系统不透明</strong>。</li></ul></li><li>对于复杂的磁盘，磁盘控制器（磁盘设备内部的一个硬件部件）会维护一个坏块链表。<ul><li>在磁盘出厂前进行低级格式化（物理格式化）时就将坏块链进行初始化。</li><li>会保留一些<strong>备用扇区</strong>，用于替换坏块。这种方案称为<strong>扇区备用</strong>。</li><li>这种处理方式中，<strong>坏块对操作系统透明</strong>。 </li></ul></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>操作系统-Part3</title>
      <link href="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part3/"/>
      <url>/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part3/</url>
      
        <content type="html"><![CDATA[<h1 id="操作系统-Part3——内存管理"><a href="#操作系统-Part3——内存管理" class="headerlink" title="操作系统-Part3——内存管理"></a>操作系统-Part3——内存管理</h1><p>[TOC]</p><h2 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h2><h3 id="内存的基础知识"><a href="#内存的基础知识" class="headerlink" title="内存的基础知识"></a>内存的基础知识</h3><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part3/image-20211106201311424.png" alt="image-20211106201311424" style="zoom:100%;"><ul><li>编译：由编译程序将用户<strong>源代码</strong>编译成若干个<strong>目标模块</strong>（编译就是把高级语言翻译为机器语言）</li><li>链接：由链接程序将编译后形成的一组目标模块，以及所需库函数链接在一起，形成一个完整的<strong>装入模块</strong></li><li>装入（装载）：由装入程序<strong>将装入模块装入内存</strong>运行</li><li><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part3/image-20211106201147384.png" alt="image-20211106201147384"></li></ul><h4 id="装入的三种方式"><a href="#装入的三种方式" class="headerlink" title="装入的三种方式"></a>装入的三种方式</h4><ul><li><strong>绝对装入</strong>：<ul><li>编译后，在可执行文件中<strong>直接指出程序装入内存后的绝对地址</strong>。</li><li><strong>由编译器完成</strong>，因为此时还未出现操作系统。</li><li><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part3/image-20211106184745104.png" alt="image-20211106184745104" style="zoom:67%;"></li><li>缺点：<ul><li>只适用于一台机器</li><li>只适用于单道程序环境</li></ul></li><li>程序中使用的绝对地址，可在编译或汇编时给出，也可由程序员直接赋予。通常情况下都是编译或汇编时再转换为绝对地址。</li></ul></li><li><strong>静态重定位</strong>（可重定位装入）：<ul><li>编译后，装入模块的地址都是从 0 开始的，指令中使用的地址、数据存放的地址都是相对于起始地址而言的<strong>逻辑地址</strong>。</li><li>根据内存的情况，将装入模块装入到内存的适当位置。装入时对地址进行“重定位”，将逻辑地址变换为物理地址（<strong>地址变换是在装入时一次完成的</strong>）。</li><li><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part3/image-20211106184445773.png" alt="image-20211106184445773" style="zoom: 67%;"></li><li>特点：<ul><li>在一个作业装入内存时，<strong>必须分配其要求的全部内存空间</strong>，如果没有足够的内存，就不能装入该作业。</li><li>作业一旦进入内存后，<strong>在运行期间就不能再移动</strong>，也不能再申请内存空间。</li></ul></li></ul></li><li><strong>动态重定位</strong>（动态运行时装入）：<ul><li>编译后，装入模块的地址都是从 0 开始的，指令中使用的地址、数据存放的地址都是相对于起始地址而言的<strong>逻辑地址</strong>。（同静态重定位）</li><li>装入程序把装入模块装入内存后，<strong>并不会把逻辑地址转换为物理地址</strong>，而是<strong>把地址转换推迟到程序真正执行时进行</strong>。因此装入内存后所有的地址依然是<strong>逻辑地址</strong>。这种方式需要一个<strong>重定位寄存器</strong>的支持，用于<strong>存放装入模块的起始位置</strong>。</li><li><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part3/image-20211106200839645.png" alt="image-20211106200839645" style="zoom:67%;"></li><li>特点：<ul><li><strong>可将程序分配到不连续的存储区中</strong></li><li>程序<strong>只需装入部分代码</strong>即可运行，并根据需要<strong>动态申请分配内存</strong></li><li>便于程序段的共享，可以向用户提供一个比存储空间大得多的地址空间</li><li>采用动态重定位时<strong>允许程序在内存中发生移动</strong></li></ul></li></ul></li></ul><h4 id="链接的三种方式"><a href="#链接的三种方式" class="headerlink" title="链接的三种方式"></a>链接的三种方式</h4><ul><li><strong>静态链接</strong>：<ul><li>在程序运行之前，先将各目标模块及它们所需的库函数连接成一个完整的可执行文件（装入模块），之后不再拆开。</li><li><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part3/image-20211106201450752.png" alt="image-20211106201450752" style="zoom: 67%;"></li></ul></li><li><strong>装入时动态链接</strong>：<ul><li>将各目标模块装入内存时，边装入边链接的链接方式。</li><li><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part3/image-20211106201530718.png" alt="image-20211106201530718" style="zoom:67%;"></li></ul></li><li><strong>运行时动态链接</strong>：<ul><li>在程序执行中需要该目标模块时，才对它进行链接。其优点是便 于修改和更新，便于实现对目标模块的共享。</li><li>优点：灵活性更高，提高对内存的利用率</li><li><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part3/image-20211106201608804.png" alt="image-20211106201608804" style="zoom:67%;"></li></ul></li></ul><h3 id="内存管理的概念"><a href="#内存管理的概念" class="headerlink" title="内存管理的概念"></a>内存管理的概念</h3><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part3/image-20211106203022788.png" alt="image-20211106203022788" style="zoom:100%;"><p>操作系统对内存管理需要实现的四个功能</p><ul><li>操作系统需要负责<strong>内存空间的分配与回收</strong></li><li>操作系统需要提供某种技术从逻辑上<strong>对内存空间进行扩充</strong></li><li>操作系统需要提供<strong>地址转换功能</strong>，负责程序的逻辑地址与物理地址的转换<ul><li>即装入的三种方式：绝对装入、可重定位装入（静态重定位）、动态运行时装入（动态重定位）</li></ul></li><li>操作系统需要提供<strong>内存保护</strong>功能。保证各进程在各自存储空间内运行，互不干扰<ul><li>方法一：在 CPU 中设置<strong>一对上、下限寄存器</strong>，存放进程的上、下限地址。进程的指令要访问某个地址时，CPU 检查是否越界。</li><li>方法二：采用<strong>重定位寄存器（基址寄存器）</strong>和<strong>界地址寄存器（限长寄存器）</strong>进行越界检查。分别存放进程的<strong>起始物理地址</strong>和<strong>最大逻辑地址</strong>。</li></ul></li></ul><h3 id="覆盖与交换"><a href="#覆盖与交换" class="headerlink" title="覆盖与交换"></a>覆盖与交换</h3><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part3/image-20211106204129149.png" alt="image-20211106204129149" style="zoom:100%;"><ul><li><strong>覆盖技术</strong><ul><li>思想：将程序分为多个段（多个模块）。常用的段常驻内存，不常用的段在需要时调入内存。</li><li>内存中分为一个“<strong>固定区</strong>”和若干个“<strong>覆盖区</strong>”。<ul><li>需要常驻内存的段放在“固定区”中，<strong>调入后就不再调出</strong>（除非运行结束）</li><li>不常用的段放在“覆盖区”，<strong>需要用到时调入内存，用不到时调出内存</strong><ul><li>按照自身逻辑结构，让那些<strong>不可能同时被访问</strong>的程序段共享同一个覆盖区，覆盖区大小以最大的程序段为准</li><li><strong>必须由程序员声明覆盖结构</strong>，操作系统完成自动覆盖。</li></ul></li></ul></li><li><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part3/image-20211106204512297.png" alt="image-20211106204512297" style="zoom:80%;"></li><li>缺点：对用户不透明，<strong>增加了编程负担</strong>。因此，只用于早期的操作系统中，现在已成为历史。</li></ul></li><li><strong>交换技术</strong><ul><li>思想：内存空间紧张时，系统将内存中某些进程暂时<strong>换出</strong>外存，把外存中某些已具备运行条件的进程<strong>换入</strong>内存（进程在内存与磁盘间动态调度）<ul><li>中级调度（内存调度），决定将哪个处于挂起状态的进程重新调入内存。</li><li>挂起队列中的 <strong>PCB 要负责记录挂起进程在磁盘中的位置</strong>。因此，<strong>PCB 会常驻内存</strong>，不会被换出外存</li><li>暂时换出外存等待的进程状态为<strong>挂起状态</strong>（suspend），进一步细分为<strong>就绪挂起</strong>、<strong>阻塞挂起</strong>两种状态</li></ul></li><li><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part3/image-20211107092841147.png" alt="image-20211107092841147" style="zoom:67%;"></li><li>交换的进程在外存中保存的位置<ul><li>具有对换功能的操作系统中，通常把磁盘空间分为<strong>文件区</strong>和<strong>对换区</strong>两部分。</li><li>文件区主要用于存放文件，主要追求<strong>存储空间的利用率</strong>，因此对文件区空间的管理采用<strong>离散分配方式</strong></li><li>对换区空间只占磁盘空间的小部分，用于存放被换出的进程数据，主要追求<strong>换入换出速度</strong>以提升系统的整体速度，因此通常对换区采用<strong>连续分配方式</strong>。</li><li>总之，对换区的 I/O 速度比文件区的更快。</li></ul></li><li>交换的时机<ul><li>交换通常在许多进程运行且内存吃紧（经常发生缺页）时进行，而系统负荷降低（缺页率明显下降）就暂停。</li></ul></li><li>交换的对象进程<ul><li>可优先换出<strong>阻塞进程</strong></li><li>可换出<strong>优先级低的进程</strong></li><li>为了防止优先级低的进程在频繁调入调出内存，有的系统还会考虑<strong>进程在内存的驻留时间</strong></li></ul></li></ul></li></ul><h3 id="连续分配管理方式"><a href="#连续分配管理方式" class="headerlink" title="连续分配管理方式"></a>连续分配管理方式</h3><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part3/image-20211107094033664.png" alt="image-20211107094033664" style="zoom:100%;"><ul><li><strong>连续分配</strong>：为用户进程分配的必须是一个<strong>连续的内存空间</strong>。</li><li><strong>非连续分配</strong>：为用户进程分配的可以是一些<strong>分散的内存空间</strong>。</li></ul><p>三种连续分配方式：</p><ul><li><strong>单一连续分配</strong><ul><li>在单一连续分配方式中，内存被分为<strong>系统区</strong>和<strong>用户区</strong>。<ul><li>系统区通常位于<strong>内存的低地址部分</strong>，用于存放操作系统相关数据；用户区用于存放用户进程相关数据。</li><li>内存中只能有一道用户程序，用户程序<strong>独占</strong>整个用户区空间。</li><li><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part3/image-20211107095633275.png" alt="image-20211107095633275" style="zoom:50%;"></li></ul></li><li>优点：<ul><li>实现简单</li><li><strong>无外部碎片</strong></li><li>可以采用覆盖技术扩充内存</li><li><strong>不一定</strong>需要采取内存保护（eg：早期的 PC 操作系统 MS-DOS）。</li></ul></li><li>缺点：<ul><li>只能用于<strong>单用户、单任务</strong>的操作系统中</li><li><strong>有内部碎片</strong>（分配给某进程的内存区域中，没有使用的部分）</li><li><strong>存储器利用率极低</strong>。</li></ul></li></ul></li><li><strong>固定分区分配</strong><ul><li>将整个<strong>用户空间</strong>划分为<strong>若干个固定大小的分区</strong>，在<strong>每个分区中只装入一道作业</strong>。是最早的、最简单的一种可运行多道程序、不会相互干扰的内存管理方式。<ul><li><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part3/image-20211107095934415.png" alt="image-20211107095934415" style="zoom: 50%;"></li></ul></li><li>特点：<ul><li><strong>分区大小相等</strong>：缺乏灵活性，但是很适合用于用一台计算机控制多个相同对象的场合<ul><li>比如：钢铁厂有 n 个相同的炼钢炉，就可把内存分为 n 个大小相等的区域存放 n 个炼钢炉控制程序</li></ul></li><li><strong>分区大小不等</strong>：增加了灵活性，可以满足不同大小的进程需求。根据常在系统中运行的作业大小情况进行划分<ul><li>比如：划分多个小分区、适量中等分区、少量大分区</li></ul></li></ul></li><li><strong>分区说明表</strong><ul><li>实现各个分区的分配与回收。每个表项对应一个分区，通常按分区大小排列。每个表项包括对应分区的<strong>大小</strong>、<strong>起始地址</strong>、<strong>状态</strong>（是否已分配）。</li><li><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part3/image-20211107100114456.png" alt="image-20211107100114456" style="zoom:67%;"></li><li>优点：实现简单，<strong>无外部碎片</strong>。</li><li>缺点：<ul><li>当用户程序太大时，可能所有的分区都不能满足需求，此时不得不采用覆盖技术来解决，但这又会降低性能</li><li>会产生内部碎片，内存利用率低。</li></ul></li></ul></li></ul></li><li><strong>动态分区分配</strong><ul><li>动态分区分配（可变分区分配），<strong>不会预先划分内存分区</strong>，而是在进程装入内存时，<strong>根据进程的大小动态地建立分区</strong>，并使分区的大小正好适合进程的需要。<ul><li>因此系统分区的大小和数目是可变的。</li></ul></li><li>记录内存使用情况的数据结构<ul><li>两种常用的数据结构：<strong>空闲分区表</strong>、<strong>空闲分区链</strong></li><li><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part3/image-20211107101014557.png" alt="image-20211107101014557"></li></ul></li><li>多个空闲分区的分配选择<ul><li>四种<strong>动态分区分配算法</strong></li></ul></li><li>分区的分配与回收<ul><li>回收内存分区时，相邻分区需要合并<ul><li>回收区的后面有一个相邻的空闲分区（修改分区大小和起始地址）</li><li>回收区的前面有一个相邻的空闲分区（修改分区大小）</li><li>回收区的前、后各有一个相邻的空闲分区（合并分区表项，修改分区大小）</li><li>回收区的前、后都没有相邻的空闲分区（新建分区表项）</li></ul></li><li>注：各表项的顺序不一定按照地址递增顺序排列，需要依据动态分区分配算法来确定。</li></ul></li><li>动态分区分配<strong>没有内部碎片</strong>，但是<strong>有外部碎片</strong>。<ul><li>内部碎片，内存中<strong>进程所属的分区中</strong>没有利用的部分</li><li>外部碎片，内存中<strong>非进程所属分区中</strong>没有利用的部分</li><li>可以通过<strong>紧凑</strong>（拼凑，Compaction）技术来解决外部碎片。<ul><li>移动进程分区首地址以腾出连续空间</li><li>适用于<strong>动态重定位</strong></li><li>紧凑之后需要修改 CPB 中的起始地址信息</li></ul></li></ul></li></ul></li></ul><h3 id="动态分区分配算法"><a href="#动态分区分配算法" class="headerlink" title="动态分区分配算法"></a>动态分区分配算法</h3><ul><li>首次适应算法（First Fit）<ul><li>算法思想：从低地址开始找到第一个适合的分区</li><li>分区排列顺序：空闲分区以<strong>地址递增</strong>次序排列</li><li>优点：<ul><li><strong>综合看性能最好</strong>。<strong>算法开销小</strong>（回收分区后不需要对空闲分区队列重新排序）</li><li>每次都需要检索低地址的小分区。有可能把高地址部分的大分区保留下来（最佳适应算法的优点）</li></ul></li></ul></li><li>最佳适应算法（Best Fit）<ul><li>算法思想：优先使用更小的分区，以保留更多大分区</li><li>分区排列顺序：空闲分区以<strong>容量递增</strong>次序排列</li><li>优点：会有更多的大分区被保留下来，更能满足大进程需求</li><li>缺点：会产生越来越多太小的、难以利用的碎片；<strong>算法开销大</strong>（回收分区后可能需要对空闲分区队列重新排序）</li></ul></li><li>最坏适用算法（Worst Fit）<ul><li>算法思想：优先使用更大的分区，以防止产生太小的不可用的碎片</li><li>分区排列顺序：空闲分区以<strong>容量递减</strong>次序排列</li><li>优点：可以减少难以利用的小碎片</li><li>缺点：大分区容易被用完，不利于后续的大进程；<strong>算法开销大</strong></li></ul></li><li>临近适应算法（Next Fit）<ul><li>算法思想：由首次适应演变而来，每次从上次查找结束位置开始查找</li><li>分区排列顺序：空闲分区以<strong>地址递增</strong>次序排列（可排列成循环链表）</li><li>优点：不用每次都从低地址的小分区开始检索。<strong>算法开销小</strong></li><li>缺点：可能会使高地址的大分区也被用完</li></ul></li></ul><h3 id="基本分页存储管理的基本概念（重点）"><a href="#基本分页存储管理的基本概念（重点）" class="headerlink" title="基本分页存储管理的基本概念（重点）"></a>基本分页存储管理的基本概念（重点）</h3><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part3/image-20211108133534598.png" alt="image-20211108133534598" style="zoom:100%;"><ul><li><p>分页存储：</p><ul><li>将内存空间分为一个个<strong>大小相等的分区</strong>，每个分区就是一个<strong>页框</strong>（<strong>页框=页帧=内存块=物理块=物理页面</strong>）。<ul><li>每个页框有一个<strong>页框号</strong>（<strong>页框号=页帧号=内存块号=物理块号=物理页号</strong>），页框号从 0 开始。</li></ul></li><li>将<strong>进程的逻辑地址空间</strong>也分为<strong>与页框大小相等</strong>的一个个部分，每个部分称为一个<strong>页</strong>（<strong>页=页面</strong>） 。<ul><li>每个页面有一个“页号”，页号从 0 开始。</li></ul></li><li>注意区别：页、页面 vs 页框、页帧、物理页</li><li>操作系统<strong>以页框为单位</strong>为各个进程分配内存空间。进程的每个页面分别放入一个页框中。进程的页面与内存的页框有一一对应的关系。<ul><li>各个页面不必连续存放，可以放到不相邻的各个页框中。</li></ul></li><li>注：进程的最后一个页面可能没有一个页框那么大。即，<strong>分页存储有可能产生内部碎片</strong>。因此页框不能太大，否则可能产生过大的内部碎片造成浪费</li></ul></li><li><p>页表：</p><ul><li>一个进程对应一张页表</li><li>进程的每个页面对应一个页表项</li><li>每个<strong>页表项</strong>由“页号”和“块号”组成</li><li>页表记录<strong>进程页面</strong>和<strong>实际存放的内存块</strong>之间的映射关系</li><li>每个页表项的长度是相同的</li><li><strong>指向页表的指针存在于 PCB（进程控制块）中</strong></li><li><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part3/image-20211108115320995.png" alt="image-20211108115320995"></li></ul></li><li><p>每个页表项的长度计算</p><ul><li>Eg：假设某系统物理内存大小为 4GB，页面大小为 4KB，则每个页表项至少应该为多少字节？</li><li><strong>内存块大小</strong>=<strong>页面大小</strong>=4KB= 2^12^B <ul><li>4GB 的内存总共会被分为 2^32^ / 2^12^ = 2^20^ 个内存块</li><li>内存块号的范围应该是 0 ~ 2^20^-1 </li><li>内存块号至少要用 20bit 来表示</li><li>至少要用 3B 来表示块号（3*8=24bit）<ul><li>重要考点：计算机中<strong>内存块的数量</strong> -&gt; 页表项中<strong>块号至少占多少字节</strong></li></ul></li><li>页表中的<strong>页号是隐含的</strong>，即<strong>页号不占用存储空间</strong></li></ul></li><li>每个页表项占 3B，存储整个页表至少需要 (n+1)*3B</li><li>注意：页表记录的只是内存块号，而不是内存块的起始地址。*<em>J 号内存块的起始地址 = J * 内存块大小*</em></li></ul></li><li><p>实现地址的转换（重点）</p><ul><li><blockquote><p>逻辑地址A对应的物理地址 = P号页面在内存中的起始地址 + 页内偏移量W</p></blockquote><ul><li><strong>页号 = 逻辑地址 / 页面长度</strong></li><li><strong>页内偏移量 = 逻辑地址 % 页面长度</strong></li><li>*<em>起始地址 = 页表[页号] * 内存块大小*</em></li></ul></li><li><p>如果页面大小为 2^K^B，逻辑地址可以快速拆分为页号、页内偏移量</p><ul><li>在逻辑地址中，<strong>末尾 K 位为页内偏移量</strong>，其余前半部分为页号</li><li>在物理地址中，末尾 K 位为页内偏移量，<strong>其余前半部分为页表[页号]</strong></li><li><blockquote><p>即，对于页面大小为 2^K^B 的情况来说，直接将逻辑地址的<strong>页号</strong>部分替换成<strong>页框号</strong></p></blockquote></li></ul></li></ul></li><li><p>逻辑地址结构</p><ul><li><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part3/image-20211108133314602.png" alt="image-20211108133314602" style="zoom:80%;"></li><li>地址长度为 32 位；其中 0<del>11位 为“<strong>页内偏移量</strong>”（<strong>页内地址</strong>）；12</del>31 位为“<strong>页号</strong>”。</li><li><strong>如果有 K 位表示“页内偏移量”，则说明该系统中一个页面的大小是 2^K^ 个内存单元</strong></li><li><strong>如果有 M 位表示“页号”，则说明在该系统中一个进程最多允许有 2^M^ 个页面</strong></li></ul></li></ul><h3 id="基本地址变换机构（重点）"><a href="#基本地址变换机构（重点）" class="headerlink" title="基本地址变换机构（重点）"></a>基本地址变换机构（重点）</h3><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part3/image-20211108133940207.png" alt="image-20211108133940207" style="zoom:100%;"><ul><li>基本地址变换机构可以借助进程的页表将逻辑地址转换为物理地址：（重点）<ul><li><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part3/image-20211108134704399.png" alt="image-20211108134704399" style="zoom: 80%;"></li><li>进程未执行时，<strong>页表的始址</strong>和<strong>页表长度</strong>放在<strong>进程控制块</strong>（PCB）中；当进程被调度时，操作系统内核会把它们放到页表寄存器中。</li><li>设页面大小为 L、起始地址 F、页表长度 M、逻辑地址 A 到物理地址 E 的变换过程：<ol><li>计算页号 P 和页内偏移量 W<ul><li>P=A/L，W=A%L</li></ul></li><li>比较页号 P 和页表长度 M，<strong>若 P≥M</strong>，则产生越界中断</li><li>页表中页号 P 对应的*<em>页表项地址 = 页表起始地址 F + 页号 P * 页表项长度*</em>。取出该页表项内容 b，即为内存块号。<ul><li>注意：区分<strong>页表项长度</strong>、<strong>页表长度</strong>、<strong>页面大小</strong>。</li><li>页表长度，指这个页表中总共有几个页表项，即总共有几个页</li><li>页表项长度，指的是每个页表项占多大的存储空间</li><li>页面大小，指的是一个页面占多大的存储空间</li></ul></li><li>计算 E = b * L + W，用得到的物理地址 E 去访存。<ul><li>如果内存块号、页面偏移量是用二进制表示的，则直接把二者拼接即物理地址</li></ul></li></ol></li><li>在分页存储管理（页式管理）的系统中：<ul><li><strong>页面的大小和逻辑地址结构是互相确定的</strong>：页面大小 L 为 1K 字节 == 某系统<strong>按字节寻址</strong>，逻辑地址结构中，<strong>页内偏移量占 10 位</strong></li><li><strong>页式管理中地址是一维的</strong>（只需要一个参数）：只要给出一个逻辑地址，就可以直接求得页号、页内偏移量</li></ul></li></ul></li><li>对页表项大小的进一步探讨<ul><li><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part3/image-20211110103417636.png" alt="image-20211110103417636"></li><li>一般不会考察，当问最小的页表长度时，按 3B 回答</li></ul></li></ul><h3 id="具有快表的地址变换机构"><a href="#具有快表的地址变换机构" class="headerlink" title="具有快表的地址变换机构"></a>具有快表的地址变换机构</h3><ul><li><strong>快表，联想寄存器</strong>（<strong>TLB</strong>， translation lookaside buffer）<ul><li><strong>TLB 不是内存，是 cache</strong></li><li>用来存放最近访问的页表项的<strong>副本</strong></li><li>与此对应，内存中的页表常称为<strong>慢表</strong>。</li></ul></li><li>引入快表之后的地址变换过程<ul><li><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part3/image-20211110181512724.png" alt="image-20211110181512724"></li><li>CPU 给出逻辑地址，由硬件算得页号、页内偏移量，将页号与<strong>快表中的所有页号</strong>进行比较。</li><li>若命中，则直接从 TLB 取出目标的内存块号，与页内偏移量拼接形成物理地址，访问对应的内存单元。<ul><li>因此，若<strong>快表命中</strong>，则访问某个逻辑地址<strong>仅需一次访存</strong>即可。</li></ul></li><li>若没有命中，则需要访问内存中的页表，通过页表始址和页号定位对应页表项，得到目标的内存块号，再将内存块号与页内偏移量拼接形成物理地址，访问该对应的内存单元。<ul><li>因此，若<strong>快表未命中</strong>，则访问某个逻辑地址<strong>需要两次访存</strong></li><li>在找到页表项后，应同时将其存入快表，以便后面可能的再次访问。</li><li>若快表已满，则必须按照一定的算法对旧的页表项进行替换</li><li><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part3/image-20211110182850496.png" alt="image-20211110182850496" style="zoom:80%;"></li></ul></li></ul></li><li>局部性原理<ul><li>时间局部性：如果执行了程序中的某条指令，那么不久后这条指令很有可能再次执行；如果某个数据被访问过，不久之后该数据很可能再次被访问。<ul><li>因为程序中存在大量的循环</li></ul></li><li>空间局部性：一旦程序访问了某个存储单元，在不久之后，其附近的存储单元也很有可能被访问。<ul><li>因为很多数据在内存中都是连续存放的</li></ul></li></ul></li></ul><p>总结</p><ul><li><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part3/image-20211110183624691.png" alt="image-20211110183624691"></li></ul><h3 id="两级页表"><a href="#两级页表" class="headerlink" title="两级页表"></a>两级页表</h3><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part3/image-20211110192048406.png" alt="image-20211110192048406" style="zoom:100%;"><ul><li>针对问题：<ul><li>单级页表必须连续存放，因此<strong>当页表很大时，需要占用很多个连续的页框</strong>，与离散分配存储管理相悖。</li><li>没有必要让整个页表常驻内存，因为根据局部性原理，<strong>进程在一段时间内可能只需要访问某几个特定的页面</strong>。</li></ul></li><li>改进方向：<ul><li>把页表再分页并离散存储，建立一张页表记录页表各个部分的存放位置</li><li>该页表称为<strong>页目录表/外层页表/顶层页表</strong></li></ul></li><li>二级页表的结构<ul><li><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part3/image-20211110190608035.png" alt="image-20211110190608035"></li><li>与单级页表的结构意义是相同的，前半部分来找到<strong>内存块号</strong>，后半部分为<strong>页内偏移量</strong></li><li>页目录表的 item 记录<strong>二级页表在内存中的内存块号</strong>，二级页表的 item 记录<strong>数据在内存中的内存块号</strong></li><li>页目录表、二级页表的每个页表项都增加一个标志位，用于<strong>表示该页面是否已经调入内存</strong>，否则产生<strong>缺页中断</strong>（内中断/异常）</li></ul></li><li>注意：<ul><li>若分为两级页表后，页表依然很长，则可以采用更多级页表，<strong>各级页表的大小不能超过一个页面</strong><ul><li><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part3/image-20211110191953863.png" alt="image-20211110191953863"></li></ul></li><li>两级页表的访存次数分析（假设没有快表机构）<ul><li>第一次访存：访问内存中的页目录表</li><li>第二次访存：访问内存中的二级页表</li><li>第三次访存：访问目标内存单元</li></ul></li></ul></li></ul><h3 id="基本分段存储管理方式"><a href="#基本分段存储管理方式" class="headerlink" title="基本分段存储管理方式"></a>基本分段存储管理方式</h3><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part3/image-20211111112309332.png" alt="image-20211111112309332" style="zoom:100%;"><ul><li><p>进程的地址空间：按照程序<strong>自身的逻辑</strong>关系<strong>划分为若干个段</strong>，每个段都有一个段名，<strong>每段从 0 开始编址</strong>。</p></li><li><p>内存分配规则：以段为单位进行分配，<strong>每个段在内存中占据连续空间</strong>，但<strong>各段之间可以不相邻</strong>。</p></li><li><p>分段存储管理方式的优点：按逻辑功能模块划分，<strong>编程更方便</strong>，<strong>程序的可读性更高</strong>。</p></li><li><p>分段系统的逻辑地址结构：</p><ul><li><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part3/image-20211110193605564.png" alt="image-20211110193605564" style="zoom:80%;"></li><li><strong>段号的位数决定了每个进程最多可以分几个段</strong></li><li><strong>段内地址位数决定了每个段的最大长度是多少</strong></li></ul></li><li><p>段表</p><ul><li><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part3/image-20211110194243704.png" alt="image-20211110194243704"></li><li>每个段对应一个段表项，其中记录了该段在内存中的<strong>基址</strong>和<strong>长度</strong>。</li><li><strong>各个段表项的长度是相同的</strong>。因此，<strong>段号也是隐含的</strong>。<ul><li>例如：某系统按字节寻址，采用分段存储管理，逻辑地址结构为（段号 16 位, 段内地址 16 位），因此用 16 位即可表示最大段长。物理内存大小为4GB（可用 32 位表示整个物理内存地址空间）。因此，可以让每个段表项占 16+32 = 48位，即 6B。</li></ul></li></ul></li><li><p>地址变换过程</p><ul><li><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part3/image-20211110194425962.png" alt="image-20211110194425962"></li></ul></li><li><p>信息的共享和保护</p><ul><li><p>不可修改的代码（纯代码/可重入代码）是可以共享的。可修改的代码是不能共享的。</p><ul><li>不可修改的代码<strong>不属于临界资源</strong>。</li><li>可修改的代码（代码段）可能包含很多变量，各进程并发访问可能造成数据不一致</li></ul></li><li><p>只需让各进程的<strong>段表项指向同一个段</strong>即可实现共享</p></li><li><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part3/image-20211111111620647.png" alt="image-20211111111620647" style="zoom:80%;"></li></ul></li></ul><blockquote><p><strong>分段、分页管理的对比</strong></p><ul><li>目的<ul><li><strong>页</strong>是<strong>信息的物理单位</strong>。分页的主要目的是为了实现离散分配，提高内存利用率。分页仅仅是系统管理上的需要，完全是系统行为，<strong>对用户是不可见的</strong>。 </li><li><strong>段</strong>是<strong>信息的逻辑单位</strong>。分段的主要目的是更好地满足用户需求。一个段通常包含着一组属于一个逻辑模块的信息。<strong>分段对用户是可见的</strong>，用户编程时需要显式地给出段名。</li></ul></li><li>长度<ul><li>页的大小固定且由系统决定。段的长度却不固定，决定于用户编写的程序。</li></ul></li><li>维度<ul><li><strong>分页</strong>的用户进程地址空间是<strong>一维</strong>的，只需给出<strong>一个记忆符</strong>即可表示一个地址。</li><li><strong>分段</strong>的用户进程地址空间是<strong>二维</strong>的，在标识一个地址时，既要给出<strong>段名</strong>，也要给出<strong>段内地址</strong>。</li></ul></li><li>共享与保护<ul><li>分段比分页<strong>更容易实现信息的共享和保护</strong>。不可修改的代码（纯代码/可重入代码）是可以共享的。可修改的代码是不能共享的。</li></ul></li><li>访存次数<ul><li>分页（单级页表）：查内存中的页表（第一次访存）+ 访问目标内存单元（第二次访存）。总共两次访存</li><li>分段：查内存中的段表（第一次访存）+ 访问目标内存单元（第二次访存）。总共两次访存。<ul><li>分段系统中也可以引入<strong>快表</strong>机构，将近期访问过的段表项放到快表中，这样可以少一次访问，加快地址变换速度。</li></ul></li></ul></li></ul></blockquote><h3 id="段页式管理方式"><a href="#段页式管理方式" class="headerlink" title="段页式管理方式"></a>段页式管理方式</h3><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part3/image-20211111112409226.png" alt="image-20211111112409226" style="zoom:100%;"><ul><li>针对问题：<ul><li>分页管理<ul><li><strong>优点</strong>：内存空间利用率高，<strong>不会产生外部碎片</strong>，只会有少量的页内碎片</li><li><strong>缺点</strong>：不方便按照逻辑模块实现信息的共享和保护</li></ul></li><li>分段管理<ul><li><strong>优点</strong>：很方便按照逻辑模块实现信息的共享和保护</li><li><strong>缺点</strong>：1. 当段长过大时，分配很大的连续空间会很不方便。2. <strong>会产生外部碎片</strong>（可以用“紧凑”来解决，只是需要付出较大的时间代价）</li></ul></li></ul></li><li>段页式管理的实现<ul><li><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part3/image-20211111113416029.png" alt="image-20211111113416029" style="zoom:80%;"></li><li>理论：将进程按逻辑<strong>先按模块分段</strong>，<strong>再将各段分页</strong></li><li>段页式系统的逻辑地址结构：<ul><li>由段号、页号、页内地址（页内偏移量）组成。</li><li><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part3/image-20211111114030310.png" alt="image-20211111114030310" style="zoom:80%;"></li><li><strong>段号的位数</strong>决定了<strong>每个进程最大段数</strong><ul><li>段号占 16 位，每个进程最多有 2^16^=64K 个段</li></ul></li><li><strong>页号位数</strong>决定了<strong>每个段最大页数</strong><ul><li>页号占 4 位，每个段最多有 2^4^=16 页</li></ul></li><li><strong>页内偏移量</strong>决定了<strong>页面/内存块大小</strong><ul><li>页内偏移量占 12 位，每个页面\每个内存块大小为 2^12^=4096=4KB</li></ul></li></ul></li><li>分段对用户是可见的，编程时需要<strong>显式地给出段号、段内地址</strong>。而将各段分页对用户是不可见的，系统会根据段内地址<strong>自动划分页号和页内偏移量</strong>。<ul><li><strong>段页式管理的地址结构是二维的</strong>。</li></ul></li><li><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part3/image-20211111114731857.png" alt="image-20211111114731857"><ul><li>每个段对应一个段表项，每个段表项由<strong>段号、页表长度、页表存放块号（页表起始地址）</strong>组成。每个段表项长度相等，段号是隐含的。</li><li>每个页面对应一个页表项，每个页表项由<strong>页号、页面存放的内存块号</strong>组成。每个页表项长度相等，页号是隐含的。</li></ul></li><li>地址转换过程<ul><li><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part3/image-20211111115141951.png" alt="image-20211111115141951"></li><li>得到段号、页号、页内偏移量</li><li>检查段号越界</li><li>根据段号找到段表项，取页表起始块号、长度</li><li>检查页号越界</li><li>根据页号找到页表项，取目标数据的内存块号</li><li>访问目标内存单元</li></ul></li></ul></li></ul><h2 id="虚拟内存管理"><a href="#虚拟内存管理" class="headerlink" title="虚拟内存管理"></a>虚拟内存管理</h2><h3 id="虚拟内存的基本概念"><a href="#虚拟内存的基本概念" class="headerlink" title="虚拟内存的基本概念"></a>虚拟内存的基本概念</h3><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part3/image-20211111120739916.png" alt="image-20211111120739916" style="zoom:100%;"><ul><li>传统存储管理方式的特征、缺点<ul><li>一次性：作业<strong>必须一次性全部装入</strong>内存后才能开始运行。这会造成两个问题：<ul><li>作业很大时，不能全部装入内存，导致大作业无法运行</li><li>当大量作业要求运行时，由于内存无法容纳所有作业，因此只有少量作业能运行，导致多道程序并发度下降。</li></ul></li><li>驻留性：一旦作业被装入内存，就会<strong>一直驻留在内存中</strong>，直至作业运行结束。<ul><li>事实上，在一个时间段内，只需要访问作业的一小部分数据即可正常运行，这就导致了内存中会驻留大量暂时用不到的数据，浪费了宝贵的内存资源。</li></ul></li></ul></li><li>虚拟内存的定义：<ul><li>基于局部性原理，在程序装入时，可以将程序中<strong>很快会用到的部分装入内存，暂时用不到的部分留在外存</strong>，就可以让程序开始执行。</li><li>在程序执行过程中，当所访问的<strong>信息不在内存时，由操作系统负责将所需信息从外存调入内存</strong>，然后继续执行程序。<ul><li>操作系统要提供<strong>请求调页（请求调段）</strong>功能</li></ul></li><li>若内存空间不够，由<strong>操作系统负责将内存中暂时用不到的信息换出到外存</strong>。<ul><li>操作系统要提供<strong>页面置换（段置换）</strong>的功能</li></ul></li><li>在操作系统的管理下，在用户角度看虚拟内存比实际内存大得多</li></ul></li><li>易混知识点：<ul><li>虚拟内存的<strong>最大容量</strong>是由计算机的地址结构（CPU寻址范围）确定的</li><li>虚拟内存的<strong>实际容量</strong> = min（内存和外存容量之和，CPU寻址范围）</li></ul></li><li>虚拟内存的三个主要特征：<ul><li>多次性：无需将作业一次性全部装入内存，而是<strong>允许分多次调入内存</strong>。</li><li>对换性：在作业运行时无需一直常驻内存，而是<strong>允许将作业换入、换出</strong>。</li><li>虚拟性：<strong>从逻辑上扩充了内存的容量</strong>，使用户看到的内存容量，远大于实际的容量。</li></ul></li><li>实现虚拟内存技术：<ul><li>传统的非连续分配存储管理：基本分页存储管理，基本分段存储管理，基本段页式存储管理</li><li>虚拟内存实现：请求分页存储管理，请求分段存储管理，请求段页式存储管理</li></ul></li></ul><h3 id="请求分页管理方式"><a href="#请求分页管理方式" class="headerlink" title="请求分页管理方式"></a>请求分页管理方式</h3><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part3/image-20211111133427802.png" alt="image-20211111133427802" style="zoom:100%;"><ul><li>页表机制<ul><li><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part3/image-20211111134046407.png" alt="image-20211111134046407"></li></ul></li><li>缺页中断机构<ul><li>在请求分页系统中，每当要访问的<strong>页面不在内存时</strong>，便产生一个<strong>缺页中断</strong>，然后<strong>由操作系统的缺页中断处理程序处理中断</strong>。</li><li>此时<strong>缺页的进程阻塞</strong>，放入阻塞队列，调页<strong>完成后再将其唤醒</strong>，放回就绪队列。</li><li>如果内存中<strong>有空闲块</strong>，则为进程<strong>分配一个空闲块</strong>，将所缺页面装入该块，并修改页表中相应的页表项。</li><li>如果内存中<strong>没有空闲块</strong>，则<strong>由页面置换算法选择一个页面淘汰</strong>，若该页面在内存期间<strong>被修改过</strong>，则要将其<strong>写回外存</strong>。未修改过的页面不用写回外存。</li><li><strong>缺页中断</strong>是因为当前执行的指令想要访问的目标页面未调入内存而产生的，因此属于内中断、故障（fault）</li><li><strong>一条指令</strong>在执行期间，<strong>可能产生多次缺页中断</strong>。</li></ul></li><li>地址变换机构<ul><li>新增步骤<ul><li>请求调页（查到页表项时根据状态位判断）</li><li>页面置换（需要调入页面，但没有空闲内存块时进行）</li><li>需要修改请求页表中新增的表项</li></ul></li><li><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part3/image-20211111135241839.png" alt="image-20211111135241839"><ul><li>查快表（未命中）—— 查慢表（发现未调入内存）—— 调页（调入的页面对应的表项会直接加入快表）—— 查快表（命中）—— 访问目标内存单元</li></ul></li><li>注意<ul><li><strong>快表中的页面一定是在内存中的</strong>。若某个页面被换出外存，则<strong>快表中的相应表项也要删除</strong>，否则可能访问错误的页面</li><li><strong>只有写指令才需要修改修改位</strong>。并且，一般只需修改快表中的数据，只有<strong>当将快表项删除时才需要写回内存中的慢表</strong>。这样可以减少访存次数。</li><li>和普通的中断处理一样，缺页中断处理依然需要保留 CPU 现场。</li><li>换入/换出页面都需要启动慢速的 I/O 操作，如果<strong>换入/换出太频繁，会有很大的开销</strong>。</li><li>页面调入内存后，需要同时修改慢表、快表。</li></ul></li></ul></li></ul><h3 id="页面置换算法"><a href="#页面置换算法" class="headerlink" title="页面置换算法"></a>页面置换算法</h3><p><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part3/image-20211111100054045.png" alt="image-20211111100054045"></p><ul><li><p>最佳置换算法（OPT，Optimal）：</p><ul><li>每次选择淘汰的页面都是<strong>以后永不使用</strong>，或者<strong>在最长时间内不再被访问</strong>的页面。<ul><li><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part3/image-20211111140714145.png" alt="image-20211111140714145" style="zoom:80%;"></li></ul></li><li>最佳置换算法<strong>可以保证最低的缺页率</strong>，但实际上，操作系统无法提前预判页面访问序列。因此，<strong>最佳置换算法是无法实现的</strong>。</li></ul></li><li><p>先进先出置换算法（FIFO）</p><ul><li>每次选择淘汰的页面是<strong>最早进入内存</strong>的页面<ul><li><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part3/image-20211111140930234.png" alt="image-20211111140930234" style="zoom:80%;"></li><li><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part3/image-20211111141136485.png" alt="image-20211111141136485"></li></ul></li><li><strong>Belady 异常</strong>：当为进程分配的物理块数增大时，缺页次数不减反增的异常现象。<ul><li><strong>只有 FIFO 算法会产生 Belady 异常</strong>。</li></ul></li><li>FIFO 算法虽然实现简单，但是该算法与进程实际运行时的规律不适应，因为先进入的页面也有可能最经常被访问。因此，<strong>算法性能差</strong>。</li></ul></li><li><p>最近最久未使用置换算法（LRU）</p><ul><li>每次淘汰的页面是最近最久未使用的页面</li><li>实现方法：<ul><li>赋予每个页面对应的页表项中，用访问字段记录该页面自上次被访问以来所经历的时间 t。</li><li>当需要淘汰一个页面时，选择现有页面中 t 值最大的，即最近最久未使用的页面。</li><li><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part3/image-20211111141926199.png" alt="image-20211111141926199" style="zoom:80%;"></li><li>虽然性能好，但是实现困难、开销大。</li></ul></li><li>做题时，仅需逆向扫描过程中最后出现的页号，即要淘汰的页面。</li></ul></li><li><p>时钟置换算法（CLOCK）</p><ul><li><p>时钟置换算法（CLOCK 算法/最近未用算法（NRU，Not Recently Used）），是一种性能和开销较均衡的算法。</p></li><li><p><strong>简单的 CLOCK 算法实现方法</strong>：</p><ul><li><p>为每个页面设置一个访问位，再将内存中的页面都通过链接指针链接成一个循环队列。</p></li><li><p>算法规则：</p><ul><li>当某页被访问时，其访问位置为 1。</li><li>当需要淘汰一个页面时，只需检查页的访问位：如果是 0，就选择该页换出；如果是 1，则将它置为 0，暂不换出</li><li>若第一轮扫描中所有页面都是 1，则将这些页面的访问位依次置为 0 后，再进行第二轮扫描</li></ul></li><li><p><strong>简单的 CLOCK 算法选择一个淘汰页面最多会经过两轮扫描</strong></p></li></ul></li><li><p><strong>改进型的时钟置换算法</strong>：</p><ul><li><p>针对问题：<strong>只有被淘汰的页面被修改过时，才需要写回外存</strong>。</p></li><li><p>改进方向：在其他条件都相同时，应优先淘汰没有修改过的页面，避免 I/O 操作。</p></li><li><p>修改位=0，表示页面没有被修改过；修改位=1，表示页面被修改过。用（访问位，修改位）的形式表示各页面状态。</p></li><li><p>算法规则：</p><ul><li><p>第一轮：从当前位置开始扫描到第一个（0, 0）的帧用于替换。本轮扫描不修改任何标志位</p><ul><li>第一优先级：<strong>最近没访问，且没修改的页面</strong></li></ul></li><li><p>第二轮：若第一轮扫描失败，则重新扫描，查找第一个（0, 1）的帧用于替换。本轮将所有扫描过的帧访问位设为 0 </p><ul><li>第二优先级：<strong>最近没访问，但修改过的页面</strong></li></ul></li><li><p>第三轮：若第二轮扫描失败，则重新扫描，查找第一个（0, 0）的帧用于替换。本轮扫描不修改任何标志位</p><ul><li>第三优先级：<strong>最近访问过，但没修改的页面</strong></li></ul></li><li><p>第四轮：若第三轮扫描失败，则重新扫描，查找第一个（0, 1）的帧用于替换。</p><ul><li>第四优先级：<strong>最近访问过，且修改过的页面</strong></li></ul></li></ul></li><li><p><strong>改进型 CLOCK 置换算法选择一个淘汰页面最多会进行四轮扫描</strong></p></li></ul></li><li><blockquote><p>NRU 相比 LRU：</p><ul><li>记录谁<strong>最早</strong>被使用很难，那么换一种思路，把时间分成一个个周期，<strong>如果最近一个周期都没有被使用，那就干脆当做一直没有被使用</strong>。</li><li><strong>不一定要最早被使用的被淘汰，只要不是最近被使用的被淘汰就好了</strong>。</li></ul></blockquote></li></ul></li></ul><h3 id="页面分配策略"><a href="#页面分配策略" class="headerlink" title="页面分配策略"></a>页面分配策略</h3><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part3/image-20211111100203514.png" alt="image-20211111100203514" style="zoom:100%;"><ul><li>驻留集：<ul><li>指<strong>请求分页存储管理中给进程分配的物理块的集合</strong>。</li><li>在采用了虚拟存储技术的系统中，<strong>驻留集大小一般小于进程的总大小</strong>。</li><li>选择一个合适的驻留集大小<ul><li>若驻留集太小，会导致缺页频繁，系统要花大量的时间来处理缺页，实际用于进程推进的时间很少；</li><li>若驻留集太大，会导致多道程序并发度下降，资源利用率降低。</li></ul></li></ul></li><li>页面分配：<ul><li><strong>固定分配</strong>：操作系统为每个进程分配一组固定数目的物理块，在进程运行期间不再改变。即，<strong>驻留集大小不变</strong></li><li><strong>可变分配</strong>：先为每个进程分配一定数目的物理块，在进程运行期间，可根据情况做适当的增加或减少。即，<strong>驻留集大小可变</strong></li><li><strong>局部置换</strong>：发生缺页时<strong>只能选进程自己的物理块进行置换</strong>。</li><li><strong>全局置换</strong>：可以将内存中<strong>任意的物理块分配给缺页进程</strong>（包括操作系统保持的空闲物理块、争夺别的进程持有的物理块）</li></ul></li><li>置换策略：<ul><li><strong>固定分配局部置换</strong>：<ul><li>系统为每个进程分配一定数量的物理块，在整个运行期间都不改变。若进程在运行中发生缺页，则只能从该进程在内存中的页面中选出一页换出，然后再调入需要的页面。</li><li>缺点：<strong>很难在最初为每个进程确定分配合理的物理块数量</strong>。（采用这种策略的系统可以根据进程大小、优先级、或是根据程序员给出的参数来确定为一个进程分配的内存块数）</li></ul></li><li><strong>可变分配全局置换</strong>：<ul><li>刚开始会为每个进程分配一定数量的物理块。操作系统会<strong>保持一个空闲物理块队列</strong>。当某进程发生缺页时，从空闲物理块中取出一块分配给该进程；若已无空闲物理块，则可选择一个<strong>未锁定</strong>的页面换出外存，再将该物理块分配给缺页的进程。</li><li>特点：<strong>只要缺页就给分配新物理块</strong>。</li><li>缺点：当空闲物理块用完时，系统可以选择任意一个进程中未锁定的页面调出，因此这个<strong>被选中的进程拥有的物理块减少，缺页率增加</strong>。</li></ul></li><li><strong>可变分配局部置换</strong>：<ul><li>刚开始会为每个进程分配一定数量的物理块。当某进程发生缺页时，只允许从该进程自己的物理块中选出一个进行换出外存。如果进程在运行中频繁地缺页，系统会为该进程多分配几个物理块，直至该进程缺页率趋势适当程度；反之，如果进程在运行中缺页率特别低，则可适当减少分配给该进程的物理块。</li><li>特点：<strong>要根据发生缺页的频率来动态地增加或减少进程的物理块</strong></li></ul></li></ul></li><li>何时调入页面<ul><li>预调页策略：<ul><li>根据局部性原理，一次调入若干个相邻的页面可能比一次调入一个页面更高效。但如果提前调入的页面中大多数都没被访问过，则又是低效的。因此可以预测不久之后可能访问到的页面，将它们预先调入内存，但目前预测成功率只有 50% 左右。</li><li>故这种策略<strong>主要用于进程的首次调入</strong>（<strong>运行前调入</strong>），由程序员指出应该先调入哪些部分。<ul><li>主要指空间局部性，即：如果当前访问了某个内存单元，在之后很有可能会接着访问与其相邻的</li></ul></li></ul></li><li>请求调页策略：<ul><li>进程<strong>在运行期间发现缺页时才将所缺页面调入内存</strong>（<strong>运行时调入</strong>）。</li><li>由这种策略调入的页面一定会被访问到，但由于每次只能调入一页，而每次调页都要磁盘 I/O 操作，因此 I/O 开销较大。</li></ul></li></ul></li><li>从何处调入页<ul><li>系统拥有足够的对换区空间：<ul><li>页面的调入、调出都是在内存与对换区之间进行，这样可以<strong>保证页面的调入、调出速度很快</strong>。在进程运行前，需将进程相关的数据从文件区复制到对换区。</li><li><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part3/image-20211111153622301.png" alt="image-20211111153622301" style="zoom: 67%;"></li></ul></li><li>系统缺少足够的对换区空间：<ul><li>凡是不会被修改的数据都直接从文件区调入，由于这些页面不会被修改，因此<strong>换出时不必写回磁盘，下次需要时再从文件区调入即可</strong>。对于可能被修改的部分，<strong>换出时需写回磁盘对换区，下次需要时再从对换区调入</strong>。</li><li><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part3/image-20211111153712918.png" alt="image-20211111153712918" style="zoom: 67%;"></li></ul></li><li>UNIX 方式：<ul><li>运行之前进程有关的数据全部放在文件区，故未使用过的页面，都可从文件区调入。若被使用过的页面需要换出，则写回对换 区，下次需要时从对换区调入。</li><li><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part3/image-20211111153811349.png" alt="image-20211111153811349" style="zoom: 67%;"></li></ul></li></ul></li><li>抖动（颠簸）现象<ul><li><strong>刚刚换出的页面马上又要换入内存，刚刚换入的页面马上又要换出外存</strong>。<ul><li>产生原因：进程频繁访问的页面数目高于可用的物理块数（<strong>分配给进程的物理块不够</strong>）</li></ul></li><li>为进程分配的物理块太少，会使进程发生抖动现象。为进程分配的物理块太多，又会降低系统整体的并发度，降低某些资源的利用率</li><li>为了研究为应该为每个进程分配多少个物理块，Denning 提出了进程“工作集”的概念<ul><li>驻留集：指请求分页存储管理中给进程分配的内存块的集合。</li><li>工作集：指在某段时间间隔里，进程实际访问页面的集合。</li><li><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part3/image-20211111153945600.png" alt="image-20211111153945600" style="zoom:80%;"></li><li>工作集大小可能小于窗口尺寸，实际应用中，操作系统可以统计进程的工作集大小，根据工作集大小给进程分配若干内存块。</li><li>一般来说，<strong>驻留集大小不能小于工作集大小，否则进程运行过程中将频繁缺页</strong>。</li><li>拓展：可以根据进程近期访问的页面集合（工作集）来设计一种页面置换算法——选择一个不在工作集中的页面进行淘汰。</li></ul></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>操作系统-Part2</title>
      <link href="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part2/"/>
      <url>/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part2/</url>
      
        <content type="html"><![CDATA[<h1 id="操作系统-Part2——进程管理"><a href="#操作系统-Part2——进程管理" class="headerlink" title="操作系统-Part2——进程管理"></a>操作系统-Part2——进程管理</h1><p>[TOC]</p><h2 id="进程与线程"><a href="#进程与线程" class="headerlink" title="进程与线程"></a>进程与线程</h2><h3 id="进程的概念、组成、特征"><a href="#进程的概念、组成、特征" class="headerlink" title="进程的概念、组成、特征"></a>进程的概念、组成、特征</h3><p><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part2/image-20211102143509078.png" alt="image-20211102143509078"></p><ul><li><p>概念</p><ul><li>程序：是静态的，是存放在磁盘的可执行文件。</li><li>进程：是动态的，是进程实体的运行过程，<strong>是能独立运行、独立获得资源、独立接受调度的基本单位</strong>。<ul><li>进程实体（进程映像）：是静态的，一个进程实体由 PCB、程序段、数据段组成。</li><li><strong>进程实体（进程映像）反应了进程某一时刻的状态</strong></li></ul></li><li>同一个程序多次执行会对应多个进程</li></ul></li><li><p>组成（严格地来说是<strong>进程实体的组成</strong>）</p><ul><li><strong>进程控制块</strong>（Process Control Block，PCB）<ul><li><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part2/image-20211102140823925.png" alt="image-20211102140823925"><ul><li>进程描述信息：用于区分各个进程</li><li>进程控制和管理信息：用于实现操作系统对进程的控制、调度</li><li>资源分配清单：用于实现对资源的管理</li><li>处理机相关信息：用于实现进程切换</li></ul></li><li>其中，进程标识符 PID 是<strong>唯一的、不重复的</strong>，即使进程已经被杀死</li><li>操作系统对进程进行管理工作<strong>所需的所有信息，都存在 PCB 中</strong></li><li><strong>PCB 是进程存在的唯一标志</strong>，当进程被创建时，操作系统为其创建 PCB，当进程结束时，会回收其 PCB。</li></ul></li><li><strong>程序段</strong>与<strong>数据段</strong><ul><li>PCB 是给<strong>操作系统</strong>用的。程序段、数据段是给<strong>进程</strong>自己用的。</li><li>程序段：程序的代码（指令序列）<ul><li>一个应用的多个进程拥有<strong>相同的程序段</strong></li></ul></li><li>数据段：运行过程中的各种数据（变量）<ul><li>一个应用的多个进程拥有<strong>不同的数据段</strong></li></ul></li></ul></li></ul></li><li><p>特征</p><ul><li><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part2/image-20211102143009562.png" alt="image-20211102143009562"></li><li>动态性是进程最基本的特征</li><li>引入线程之后，进程不再是独立接受调度的基本单位，但仍是独立获得资源的基本单位</li></ul></li></ul><h3 id="进程的状态与转换、进程的组织"><a href="#进程的状态与转换、进程的组织" class="headerlink" title="进程的状态与转换、进程的组织"></a>进程的状态与转换、进程的组织</h3><p><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part2/image-20211102152923790.png" alt="image-20211102152923790"></p><p>进程的状态与转换</p><ul><li>状态转换过程<ul><li><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part2/image-20211102152203439.png" alt="image-20211102152203439"></li><li>创建态（New，新建态）：进程正在被创建。在这个阶段，操作系统会为进程分配资源、初始化 PCB</li><li>就绪态（Ready）：仅缺少 CPU，具备其他所有运行条件，随时可以被处理运行</li><li>运行态（Running）：进程正在 CPU 上运行<ul><li>多核 CPU 可能有多个进程处于运行态</li></ul></li><li>阻塞态（Waiting/Blocked，等待态）：进程<strong>主动</strong>请求等待某个事件的发生（资源分配或其他进程响应）<ul><li>即除 CPU 之外还缺少必要的条件，只有<strong>被动</strong>获得其余条件，才能转化成就绪态</li></ul></li><li>终止态（Terminated，结束态）：执行 exit 系统调用，或出现终止异常。进程下 CPU、回收内存空间等<strong>资源</strong>、回收该进程的 <strong>PCB</strong>，彻底消失。</li></ul></li><li>三种基本状态：运行态、就绪态、阻塞态</li><li><strong>不能由阻塞态直接转为运行态，也不能由就绪态直接转为阻塞态</strong>。</li><li>进程 PCB 中，会有一个变量 state 来表示进程的当前状态</li></ul><p>进程的组织</p><ul><li>链接方式<ul><li>按照进程状态将 PCB 分为多个队列</li><li>操作系统持有各个队列的指针</li></ul></li><li>索引方式<ul><li>根据进程状态的不同，建立索引表</li><li>操作系统持有各个索引表的指针</li></ul></li></ul><h3 id="进程控制"><a href="#进程控制" class="headerlink" title="进程控制"></a>进程控制</h3><ul><li><p>基本概念</p><ul><li>进程控制：实现进程状态转换</li><li>进程控制的实现方式：原语<ul><li>原语的执行具有<strong>原子性</strong>，运行必须一气呵成，不可中断</li><li>进程控制/状态转换，不可中断</li><li>通过<strong>关/中断指令</strong>这两个<strong>特权指令</strong>实现原子性</li><li>进程控制必定是内核程序，需要运行在<strong>核心态</strong></li></ul></li></ul></li><li><p>进程控制相关原语</p><ul><li>进程的创建<ul><li><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part2/image-20211102155434833.png" alt="image-20211102155434833"></li><li>作业调度：将位于<strong>外存</strong>后备队列中的作业调入<strong>内存</strong></li></ul></li><li>进程的终止<ul><li><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part2/image-20211102155614381.png" alt="image-20211102155614381" style="zoom:80%;"></li></ul></li><li>进程的阻塞、进程的唤醒<ul><li><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part2/image-20211102155717098.png" alt="image-20211102155717098"></li><li>阻塞和切换必定成对出现</li></ul></li><li>进程的切换<ul><li><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part2/image-20211102155913145.png" alt="image-20211102155913145" style="zoom: 67%;"></li><li>通过 PCB 恢复运行环境</li></ul></li></ul></li><li><p>无论哪个进程控制原语，要做的无非三类事情：</p><ul><li>更新 PCB 中的信息（修改进程状态，保存/恢复运行环境）<ul><li>所有的进程控制原语一定都会修改进程状态标志</li><li>剥夺当前运行进程的CPU使用权必然需要保存其运行环境</li><li>某进程开始运行前必然要恢复期运行环境</li></ul></li><li>将 PCB 插入合适的队列</li><li>分配/回收资源</li></ul></li></ul><h3 id="进程通信"><a href="#进程通信" class="headerlink" title="进程通信"></a>进程通信</h3><p><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part2/image-20211102160516149.png" alt="image-20211102160516149"></p><ul><li>基本概念<ul><li>进程通信（Inter-Process Communication， IPC）是指两个进程之间产生数据交互。</li><li>进程是分配系统资源的单位（包括内存地址空间），因此各进程拥有的<strong>内存地址空间相互独立</strong>。<ul><li>为了保证安全，<strong>一个进程不能直接访问另一个进程的地址空间</strong>。</li></ul></li></ul></li><li><strong>共享存储</strong><ul><li>为避免出错，各个进程对共享空间的访问应该是<strong>互斥</strong>的。</li><li>基于<strong>数据结构</strong>的共享：<ul><li>比如共享空间里只能放一个长度为 10 的数组。</li><li>速度慢、限制多，是一种<strong>低级通信</strong>方式</li></ul></li><li>基于<strong>存储区</strong>的共享：<ul><li>操作系统在内存中划出一块共享存储区。数据的形式、存放位置都由<strong>通信进程</strong>控制，而不是操作系统。</li><li>速度很快，是一种<strong>高级通信</strong>方式。</li><li><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part2/image-20211102190332073.png" alt="image-20211102190332073" style="zoom: 67%;"></li></ul></li></ul></li><li><strong>消息传递</strong><ul><li>进程间的数据交换以<strong>格式化的消息</strong>（Message）为单位。进程通过操作系统提供的“发送消息/接收消息”两个<strong>原语</strong>进行数据交换。</li><li><strong>直接通信方式</strong><ul><li>消息发送进程要指明接收进程的ID</li><li><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part2/image-20211102190853574.png" alt="image-20211102190853574" style="zoom: 67%;"></li></ul></li><li><strong>间接通信方式</strong><ul><li>通过“信箱”间接地通信。因此又称“信箱通信方式”</li><li><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part2/image-20211102191135092.png" alt="image-20211102191135092" style="zoom:67%;"></li></ul></li></ul></li><li><strong>管信通信</strong><ul><li>“管道”是一个特殊的共享文件，又名 pipe 文件。其实就是在内存中开辟一个<strong>大小固定的内存缓冲区</strong>（循环队列）</li><li>管道只能采用<strong>半双工通信</strong>，某一时间段内只能实现单向的传输。如果要实现<strong>全双工通信</strong>，则需要设置两个管道。</li><li>各进程要<strong>互斥</strong>地访问管道（由操作系统实现）</li><li>当管道<strong>写满</strong>时，<strong>写进程将阻塞</strong>，直到读进程将管道中的数据取走，即可唤醒写进程。</li><li>当管道<strong>读空</strong>时，<strong>读进程将阻塞</strong>，直到写进程往管道中写入数据，即可唤醒读进程。</li><li>管道中的数据一旦被读出，就彻底消失。因此，当多个进程读同一个管道时，可能会错乱。对此，通常有两种解决方案：<ul><li>一个管道允许<strong>多个写进程，一个读进程</strong>（2014年408真题高教社官方答案）；</li><li>允许有多个写进程，多个读进程，但系统会让各个读进程轮流从管道中读数据（Linux 的方案）。</li></ul></li><li>只要管道没空，读进程就可以从管道读数据；只要管道没满，写进程就可以往管道写数据。</li></ul></li></ul><h3 id="线程的概念与特点"><a href="#线程的概念与特点" class="headerlink" title="线程的概念与特点"></a>线程的概念与特点</h3><ul><li>线程是一个基本的 CPU 执行单元，是<strong>程序执行流的最小单位</strong>。</li><li>带来的变化：<ul><li>资源分配、调度<ul><li>传统进程机制中，进程是资源分配、调度的基本单位</li><li>引入线程之后，进程是<strong>资源分配</strong>的基本单位，线程是<strong>调度</strong>的基本单位</li></ul></li><li>并发性<ul><li>传统进程机制中，只能进程间并发</li><li>引入线程之后，各线程之间也能并发，提升了并发度</li></ul></li><li>系统开销<ul><li>传统的进程间并发，需要切换进程的运行环境，系统开销大</li><li>线程间并发，如果是<strong>同一线程内的线程切换</strong>，则不需要切换进程环境，<strong>系统开销小</strong></li><li>引入线程后，并发带来的系统开销减小</li></ul></li></ul></li><li>线程属性：<ul><li>线程是处理机调度单位</li><li>多 CPU 计算机中，各个线程可以占用不同的 CPU<ul><li>（一般是一个进程占一个核。因为不同逻辑核心用的缓存是不同的，若一个进程同时用多个核，则数据调用会变得困难。但是考纲表明，一个进程可以占用多个核心，核心级线程是处理机分配的最小单位）</li></ul></li><li>每一个线程都有<strong>线程 ID、线程控制块（TCB）</strong></li><li>线程也有<strong>就绪、堵塞、运行</strong>三种基本状态</li><li>线程几乎不拥有系统资源</li><li>同一进程的不同线程<strong>共享进程的资源</strong></li><li>由于共享内存地址空间，同一线程中的线程间通信无需系统干预</li><li>同一进程中的线程切换，不会引起进程切换；不同进程中的线程切换，会引起进程切换。</li><li>切换同进程内的线程，系统开销很小；切换进程，系统的开销较大。</li></ul></li></ul><h3 id="线程的实现方式和多线程模型"><a href="#线程的实现方式和多线程模型" class="headerlink" title="线程的实现方式和多线程模型"></a>线程的实现方式和多线程模型</h3><p><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part2/image-20211102232120706.png" alt="image-20211102232120706"></p><ul><li><p>线程的实现方式</p><ul><li><strong>用户级线程</strong>（User-Level Thread, ULT）<ul><li>用户级线程<strong>由应用程序通过线程库实现</strong>，所有的线程管理工作都<strong>由应用程序负责</strong>（包括线程切换）</li><li>用户级线程中，线程切换可以<strong>在用户态下完成</strong>，无需操作系统干预。</li><li>在用户看来，是有多个线程。但是在操作系统内核看来，并意识不到线程的存在。</li><li>优点：用户级线程的切换在用户空间即可完成，不需要切换到核心态，线程管理的<strong>开销小，效率高</strong></li><li>缺点：当一个用户级线程被阻塞后，整个进程都会被阻塞，<strong>并发度不高</strong>。多个线程不可在多核处理机上并行运行。</li><li><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part2/image-20211103135106630.png" alt="image-20211103135106630" style="zoom:80%;"></li></ul></li><li><strong>内核级线程</strong>（Kernel-Level Thread, KLT，又称“内核支持的线程”）<ul><li>内核级线程的管理工作由操作系统内核完成。</li><li>线程调度、切换等工作都由内核负责，因此内核级线程的切换必然需要在核心态下才能完成。</li><li>操作系统会为每个内核级线程建立相应的 TCB（Thread Control Block，线程控制块），通过 TCB 对线程进行管理。“内核级线程”就是“从操作系统内核视角看能看到的线程”</li><li>优点：当一个线程被阻塞后，别的线程还可以继续执行，并发能力强。多线程可在多核处理机上并行执行。</li><li>缺点：一个用户进程会占用多个内核级线程，线程切换由操作系统内核完成，需要切换到核心态，因此线程管理的成本高，开销大。</li><li><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part2/image-20211103134402805.png" alt="image-20211103134402805" style="zoom:80%;"></li></ul></li></ul></li><li><p>多线程模型</p><ul><li>一对一模型：（内核级线程）<ul><li><strong>一个用户级线程映射到一个内核级线程</strong>。每个用户进程有与用户级线程同数量的内核级线程。</li><li>优点：当一个线程被阻塞后，别的线程还可以继续执行，<strong>并发能力强</strong>。<strong>多线程可在多核处理机上并行执行</strong>。</li><li>缺点：<strong>一个用户进程会占用多个内核级线程</strong>，线程切换由操作系统内核完成，需要切换到核心态，因此<strong>线程管理的成本高，开销大</strong>。</li></ul></li><li>多对一模型：（用户级线程）<ul><li><strong>多个用户级线程映射到一个内核级线程</strong>。且<strong>一个进程只被分配一个内核级线程</strong>。</li><li>优点：用户级线程的切换在用户空间即可完成，不需要切换到核心态，线程管理的系统开销小，效率高</li><li>缺点：当一个用户级线程被阻塞后，整个进程都会被阻塞，<strong>并发度不高</strong>。多个线程不可在多核处理机上并行运行，因为只有这一个进程只有一个内核级线程。</li></ul></li><li>多对多模型：<ul><li>n 用户及线程映射到 m 个内核级线程（<strong>n&gt;=m</strong>）。每个用户进程对应 m 个内核级线程。</li><li>克服了多对一模型并发度不高的缺点（一个阻塞全体阻塞），又克服了一对一模型中一个用户进程占用太多内核级线程，开销太大的缺点。</li><li><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part2/image-20211103135439234.png" alt="image-20211103135439234" style="zoom:80%;"></li></ul></li></ul><blockquote><ul><li>用户级线程是“代码逻辑”的载体</li><li>内核级线程是“运行机会”的载体</li><li>注意：<strong>内核级线程才是处理机分配的单位</strong>。</li></ul></blockquote></li></ul><h2 id="处理机调度"><a href="#处理机调度" class="headerlink" title="处理机调度"></a>处理机调度</h2><h3 id="调度的概念、层次"><a href="#调度的概念、层次" class="headerlink" title="调度的概念、层次"></a>调度的概念、层次</h3><p><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part2/image-20211103143657421.png" alt="image-20211103143657421"></p><ul><li><p>基本概念：确定某种规则来决定处理任务的顺序</p></li><li><p>三个层次</p><ul><li>高级调度（作业调度）<ul><li>作业：指一个具体的任务</li><li>用户向系统提交一个作业 ≈ 用户让操作系统启动一个程序（来处理一个具体的任务）</li><li>按一定的原则从<strong>外存</strong>的作业后备队列中挑选一个作业调入<strong>内存</strong>，并<strong>创建进程</strong>。</li><li>每个作业<strong>只调入一次</strong>，<strong>调出一次</strong>。作业调入时会建立 PCB，调出时才撤销 PCB。</li></ul></li><li>中级调度（内存调度）<ul><li>内存不够时，将某些进程的数据调出外存。等内存空闲或者进程需要运行时再重新调入内存。</li><li>暂时调到外存等待的进程状态为<strong>挂起状态</strong>（suspend）。被挂起的进程 PCB 会被组织成<strong>挂起队列</strong></li><li>一个进程可能会被<strong>多次调出、调入内存</strong>，因此<strong>中级调度发生的频率要比高级调度更高</strong>。</li></ul></li><li>低级调度（进程调度）<ul><li>从<strong>内存</strong>中的<strong>就绪队列</strong>中选取一个进程，将<strong>处理机</strong>分配给它。</li><li><strong>进程调度是操作系统中最基本的一种调度</strong>，在一般的操作系统中都必须配置进程调度。</li><li>进程调度的<strong>频率很高</strong>，一般几十毫秒一次。</li></ul></li></ul></li><li><p>补充</p><ul><li>进程的挂起态<ul><li>暂时调到<strong>外存</strong>等待的进程状态为挂起状态</li><li>挂起态又可以进一步细分为<strong>就绪挂起</strong>、<strong>阻塞挂起</strong>两种状态</li></ul></li><li>七状态模型<ul><li>注意：挂起和阻塞，两种状态都是暂时不能获得CPU的服务，但挂起态是<strong>将进程映像调到外存</strong>去了，而<strong>阻塞态下进程映像还在内存中</strong>。</li><li>有的操作系统会把就绪挂起、阻塞挂起分为两个挂起队列，甚至会根据阻塞原因不同再把阻塞挂起进程进一步细分为多个队列。</li><li><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part2/image-20211103142132494.png" alt="image-20211103142132494"></li></ul></li></ul></li><li><p>三个层次的联系、对比</p><ul><li><table><thead><tr><th></th><th>内容</th><th>发生位置</th><th>发生频率</th><th>进程状态</th></tr></thead><tbody><tr><td>（高级）作业调度</td><td>从后备队列选择以创建进程</td><td>外存 -&gt; 内存（面向作业）</td><td>最低</td><td>无 -&gt; 创建态 -&gt; 就绪态</td></tr><tr><td>（中级）内存调度</td><td>从挂起队列选择以调回内存</td><td>外存 -&gt; 内存（面向进程）</td><td>中等</td><td>挂起态 -&gt; 就绪态</td></tr><tr><td>（低级）进程调度</td><td>从就绪队列选择以分配 CPU</td><td>内存 -&gt; CPU</td><td>最高</td><td>就绪态 -&gt; 运行态</td></tr></tbody></table></li></ul></li></ul><h3 id="进程调度的时机、切换与过程、方式"><a href="#进程调度的时机、切换与过程、方式" class="headerlink" title="进程调度的时机、切换与过程、方式"></a>进程调度的时机、切换与过程、方式</h3><p><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part2/image-20211103143931197.png" alt="image-20211103143931197"></p><ul><li><strong>进程调度的时机</strong><ul><li>进程调度（低级调度），就是按照某种算法从就绪队列中选择一个进程为其分配处理机。</li><li><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part2/image-20211103144051040.png" alt="image-20211103144051040"></li><li><strong>需要</strong>进行进程调度与切换的情况<ul><li>当前进程<strong>主动</strong>放弃处理机<ul><li>进程正常终止</li><li>发生异常而终止</li><li>进程主动请求阻塞（如 等待I/O）</li></ul></li><li>当前进程<strong>被动</strong>放弃处理机<ul><li>分给进程的时间片用完</li><li>有更紧急的事需要处理（如 I/O中断）</li><li>有更高优先级的进程进入就绪队列</li></ul></li></ul></li><li><strong>不能</strong>进行进程调度与切换的情况<ul><li>在<strong>处理中断的过程中</strong>。中断处理过程复杂，与硬件密切相关，很难做到在中断处理过程中进行进程切换。</li><li>进程在<strong>操作系统内核程序临界区中</strong>。但是进程在普通临界区中是可以进行调度、切换的。</li><li>在<strong>原子操作过程中</strong>（原语）。原子操作不可中断。（如修改 PCB 中进程状态标志，并把 PCB 放到相应队列）</li></ul></li><li>真题案例：<ul><li>进程在<strong>操作系统内核程序临界区</strong>中<strong>不能</strong>进行调度与切换。<strong>对</strong></li><li>（2012年联考真题）进程处于<strong>临界区</strong>时<strong>不能</strong>进行处理机调度。<strong>错</strong></li><li>临界资源：<strong>一个时间段内只允许一个进程使用的资源</strong>。各进程需要互斥地访问临界资源。</li><li>临界区：访问临界资源的那段代码。</li><li><strong>内核程序临界区</strong>一般是用来访问<strong>某种内核数据结构</strong>的，比如进程的就绪队列（由各就绪进程的 PCB 组成）<ul><li>进程还未退出临界区时，临界资源（就绪队列）则一直处于上锁状态，则其他进程调度相关的程序就会被阻塞。</li><li>内核程序临界区访问的临界资源如果不尽快释放，极有可能影响到操作系统内核的其他管理工作。因此<strong>在访问内核程序临界区期间不能进行调度和切换</strong>。</li></ul></li><li>普通临界区<ul><li>在打印机打印完成之前，进程一直处于临界区内，临界资源（打印机）不会解锁。但打印机是慢速设备，如果不允许进程调度则会导致 CPU 一直空闲</li><li>普通临界区资源（如打印机）不会影响到操作系统内核的管理工作。因此<strong>在访问普通临界区资源时可以进行调度与切换</strong>。</li></ul></li></ul></li></ul></li><li><strong>进程调度的方式</strong><ul><li><strong>非剥夺调度方式</strong>，又称<strong>非抢占方式</strong>。即，只允许进程主动放弃处理机。在运行过程中即便有更紧迫的任务到达，当前进程依然会继续使用处理机，直到该进程终止或主动要求进入阻塞态。<ul><li>实现简单，系统开销小但是无法及时处理紧急任务，适合于<strong>早期的批处理系统</strong></li></ul></li><li><strong>剥夺调度方式</strong>，又称<strong>抢占方式</strong>。当一个进程正在处理机上执行时，如果有一个更重要或更紧迫的进程需要使用处理机，则立即暂停正在执行的进程，将处理机分配给更重要紧迫的那个进程。<ul><li>可以优先处理更紧急的进程，也可实现让各进程按时间片轮流执行的功能（通过时钟中断）。适合于<strong>分时操作系统、实时操作系统</strong></li></ul></li></ul></li><li><strong>进程的切换与过程</strong><ul><li><strong>进程调度</strong>与<strong>进程切换</strong>的区别：<ul><li><strong>狭义的进程调度</strong>，指的是从就绪队列中选中一个要运行的进程。（这个进程可以是刚刚被暂停执行的进程，也可能是另一个进程，后一种情况就需要进程切换）</li><li><strong>进程切换</strong>，指一个进程让出处理机，由另一个进程占用处理机的过程。</li><li><strong>广义的进程调度</strong>，包含了选择一个进程和进程切换两个步骤</li></ul></li><li>进程切换的过程主要完成了：<ul><li>对原来运行进程各种数据的保存</li><li>对新的进程各种数据的恢复</li></ul></li><li><strong>进程切换是有代价的</strong>，因此如果过于频繁的进行进程调度、切换，必然会使整个系统的效率降低，使系统大部分时间都花在了进程切换上，而真正用于执行进程的时间减少。</li></ul></li></ul><h3 id="调度算法的评价指标"><a href="#调度算法的评价指标" class="headerlink" title="调度算法的评价指标"></a>调度算法的评价指标</h3><p><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part2/image-20211103220000158.png" alt="image-20211103220000158"></p><ul><li><strong>CPU 利用率</strong>：指 CPU 忙碌的时间占总时间的比例。</li><li><strong>系统吞吐量</strong>：单位时间内完成作业的数量</li><li>周转时间<ul><li><strong>周转时间</strong>，指从作业被提交给系统开始，到作业完成为止的时间。<ul><li>包括四个部分：作业<strong>在外存后备队列上等待作业调度（高级调度）</strong>的时间、进程<strong>在就绪队列上等待进程调度（低级调度）</strong>的时间、进程<strong>在CPU上执行的时间</strong>、进程<strong>等待 I/O 操作完成的时间</strong>。后三项在一个作业的整个处理过程中，可能发生多次。</li></ul></li><li><strong>带权周转时间</strong>必然 ≥ 1</li><li>带权周转时间与周转时间都是越小越好</li></ul></li><li><strong>等待时间</strong><ul><li>等待时间，指进程/作业<strong>处于等待处理机状态时间之和</strong>，等待时间越长，用户满意度越低。</li><li>对于进程来说，等待时间就是指进程建立后<strong>等待被服务的时间之和</strong>，在等待I/O完成的期间其实进程也是在被服务的，所以不计入等待时间。</li><li>对于作业来说，不仅要考虑<strong>建立进程后的等待时间</strong>，还要加上<strong>作业在外存后备队列中等待的时间</strong>。</li></ul></li><li><strong>响应时间</strong>：指从用户提交请求到首次产生响应所用的时间。</li></ul><h3 id="调度算法"><a href="#调度算法" class="headerlink" title="调度算法"></a>调度算法</h3><ul><li>各种调度算法的学习思路<ol><li>算法思想</li><li>算法规则</li><li>作业调度 or 进程调度</li><li>抢占式 or 非抢占式</li><li>优点 and 缺点</li><li>是否会导致饥饿/饿死</li></ol></li><li>FCFS、SJF/SPF、HRRN 适合用于早期的批处理系统；时间片轮转、优先级调度、多级反馈队列适合用于交互式系统</li></ul><h4 id="先来先服务"><a href="#先来先服务" class="headerlink" title="先来先服务"></a>先来先服务</h4><ul><li>先来先服务（FCFS, First Come First Serve）<ul><li>算法思想：主要从“公平”的角度考虑</li><li>算法规则：按照<strong>到达的先后顺序</strong>进行服务</li><li>调度对象：用于作业调度时，考虑的是哪个作业先到达<strong>后备队列</strong>；用于进程调度时，考虑的是哪个进程先到达<strong>就绪队列</strong></li><li>是否抢占：非抢占式</li><li>优点：公平、算法实现简单</li><li>缺点：<ul><li><strong>带权周转时间很大</strong>。</li><li>公平</li><li><strong>对长作业有利，对短作业不利</strong>。</li></ul></li><li>是否会导致饥饿/饿死：不会</li></ul></li></ul><p><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part2/image-20211104135659417.png" alt="image-20211104135659417"></p><h4 id="最短作业优先"><a href="#最短作业优先" class="headerlink" title="最短作业优先"></a>最短作业优先</h4><ul><li><p>短作业优先（SJF, Shortest Job First）</p><ul><li>算法思想：追求最少的<strong>平均等待时间</strong>、<strong>平均周转时间</strong>、<strong>平均带权周转时间</strong></li><li>算法规则：<strong>要求服务时间最短</strong>的作业/进程优先得到服务</li><li>调度对象：作业/进程调度皆可。用于进程调度称为，短进程优先算法（SPF, Shortest Process First）</li><li>是否抢占：SJF 和 SPF 是非抢占式的算法。但是也有抢占式的版本——最短剩余时间优先算法（SRTN, Shortest Remaining Time Next）<ul><li>SJF：仅在每次调度时选择当前<strong>已到达且运行时间最短</strong>的作业/进程。</li><li>SRTN：每当有进程加入<strong>就绪队列改变时就需要调度</strong>，如果新到达的进程<strong>剩余时间</strong>比当前运行的进程剩余时间<strong>更短</strong>，则由新进程<strong>抢占</strong>处理机，当前运行进程重新回到就绪队列。另外，当一个进程完成时也需要调度。</li></ul></li><li>优点：“最短的”平均等待时间、平均周转时间</li><li>缺点：<ul><li>不公平。</li><li><strong>对短作业有利，对长作业不利</strong>。</li><li>可能产生饥饿现象。</li><li>作业/进程的运行时间是由用户提供的，并不一定真实，不一定能做到真正的短作业优先</li></ul></li><li>是否会导致饥饿/饿死：会</li></ul></li><li><p>注意：</p><ul><li>如果题目中未特别说明，所提到的“短作业/进程优先算法”默认是<strong>非抢占式</strong>的</li><li>“SJF 调度算法的平均等待时间、平均周转时间最少”，严格来说，这个表述是错误的，不严谨的。<ul><li>在<strong>所有进程同时可运行</strong>时，采用 SJF 调度算法的平均等待时间、平均周转时间最少</li><li>在<strong>所有进程都几乎同时到达</strong>时，采用 SJF 调度算法的平均等待时间、平均周转时间最少</li><li><strong>抢占式的</strong>短作业/进程优先调度算法（<strong>最短剩余时间优先</strong>，SRNT算法）的平均等待时间、平均周转时间最少</li></ul></li></ul></li></ul><p><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part2/image-20211104135754210.png" alt="image-20211104135754210"></p><p><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part2/image-20211104135848421.png" alt="image-20211104135848421"></p><h4 id="最高响应比优先"><a href="#最高响应比优先" class="headerlink" title="最高响应比优先"></a>最高响应比优先</h4><ul><li>高响应比优先（HRRN, Highest Response Ratio Next）<ul><li>算法思想：综合考虑作业/进程的等待时间和要求服务的时间</li><li>算法规则：在每次调度时先<strong>计算各个作业/进程的响应比，选择响应比最高</strong>的作业/进程为其服务<ul><li><strong>响应比 =（等待时间+要求服务时间）/ 要求服务时间</strong></li></ul></li><li>调度对象：即可用于作业调度，也可用于进程调度</li><li>是否抢占：非抢占式</li><li>优缺点：<ul><li>综合考虑了等待时间和运行时间（要求服务时间）</li><li>等待时间相同时，要求服务时间短的优先（SJF 的优点）</li><li>要求服务时间相同时，等待时间长的优先（FCFS 的优点）</li><li>对于长作业来说，随着等待时间越来越久，其响应比也会越来越大，从而避免了长作业饥饿的问题</li></ul></li><li>是否会导致饥饿/饿死：不会</li></ul></li></ul><p><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part2/image-20211104135933630.png" alt="image-20211104135933630"></p><h4 id="时间片轮转"><a href="#时间片轮转" class="headerlink" title="时间片轮转"></a>时间片轮转</h4><ul><li>时间片轮转（RR，Round-Robin）<ul><li>算法思想：公平地、轮流地为各个进程服务，让每个进程在一定时间间隔内都可以得到响应</li><li>算法规则：按照各进程到达就绪队列的顺序，轮流让各个进程执行一个时间片。若进程未在一个时间片内执行完，则剥夺处理机，将进程重新放到就绪队列队尾重新排队。</li><li>调度对象：进程调度（只有作业放入内存建立了相应的进程后，才能被分配处理机时间片）</li><li>是否抢占：<strong>抢占式</strong>。由时钟装置发出<strong>时钟中断</strong>来通知 CPU 时间片已到</li><li>优点：公平；响应快，适用于分时操作系统；</li><li>缺点：由于高频率的进程切换，因此有一定开销；不区分任务的紧急程度。</li><li>是否会导致饥饿/饿死：不会</li></ul></li><li>注意：<ul><li>当同时有进程 a <strong>下处理机</strong>、有进程 b <strong>到达</strong>，则默认新到达的进程先进入就绪队列</li><li>进程主动放弃处理机，则<strong>立刻调度下一个进程上处理机</strong>，并且<strong>不影响下一个进程的时间片周期</strong></li><li>通常，设计时间片要让切换进程的开销占比不超过 1%<ul><li>时间片不能太大：否则，将使得每个进程都可以在一个时间片内就完成，则时间片轮转调度算法<strong>退化为先来先服务调度算法</strong>，并且会<strong>增大进程响应时间</strong>。</li><li>时间片不能太小：否则会导致<strong>进程切换过于频繁</strong>，而进程调度、切换都有时间代价（保存、恢复运行环境）。</li></ul></li></ul></li></ul><p><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part2/image-20211104150056927.png" alt="image-20211104150056927"></p><h4 id="优先级调度"><a href="#优先级调度" class="headerlink" title="优先级调度"></a>优先级调度</h4><ul><li>优先级调度算法<ul><li>算法思想：根据任务的紧急程度来决定处理顺序</li><li>算法规则：每个作业/进程有各自的优先级，调度时选择优先级最高的</li><li>调度对象：作业、进程、I/O 调度</li><li>是否抢占：抢占式、非抢占式都有。<ul><li>非抢占式只需在进程主动放弃处理机时进行调度即可</li><li>抢占式另外还需在就绪队列变化时，检查是否会发生抢占</li></ul></li><li>优点：<ul><li>用优先级区分紧急程度、重要程度，适用于实时操作系统。</li><li>可灵活地调整对各种作业/进程的偏好程度。</li></ul></li><li>缺点：若源源不断地有高优先级进程到来，则可能导致饥饿</li><li>是否会导致饥饿/饿死：会</li></ul></li><li>注意：<ul><li>优先数要按照题意判断：优先数<strong>越大（或者越小）</strong>，优先级越高</li><li>根据优先级是否可以动态改变，有两种分类<ul><li><strong>静态优先级</strong>：创建进程时确定，之后一直不变。</li><li><strong>动态优先级</strong>：创建进程时有一个初始值，之后会根据情况动态地调整优先级。</li></ul></li><li>通常：<ul><li>系统进程优先级<strong>高于</strong>用户进程</li><li>前台进程优先级<strong>高于</strong>后台进程</li><li>操作系统更<strong>偏好 I/O 型进程（I/O 繁忙型进程）</strong><ul><li>相对的是计算型进程（CPU 繁忙型进程）</li></ul></li></ul></li><li>动态优先级调整策略<ul><li>如果某进程在就绪队列中<strong>等待了很长时间</strong>，则可以适当提升其优先级</li><li>如果某进程<strong>占用处理机运行了很长时间</strong>，则可适当降低其优先级</li><li>如果发现一个进程频<strong>繁地进行 I/O 操作</strong>，则可适当提升其优先级</li></ul></li></ul></li></ul><p><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part2/image-20211104150805430.png" alt="image-20211104150805430"></p><p><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part2/image-20211104150844950.png" alt="image-20211104150844950"></p><h4 id="多级反馈队列"><a href="#多级反馈队列" class="headerlink" title="多级反馈队列"></a>多级反馈队列</h4><ul><li><p>多级反馈队列</p><ul><li>算法思想：对其他调度算法的折中权衡</li><li>算法规则：<ul><li>设置多级就绪队列，<strong>各级队列优先级从高到低</strong>，<strong>时间片从小到大</strong></li><li>新进程到达时先进入第 1 级队列，按 FCFS 原则排队等待被分配时间片。若用完时间片进程还未结束，则进入下一级队列队尾。如果已经在最下级队列，则重新放回该级队列队尾</li><li>被抢占处理机的进程重新放回原队列队尾</li><li>只有第 k 级队列为空时，才会为 k+1 级队头的进程分配时间片。</li></ul></li><li>调度对象：进程调度</li><li>是否抢占：抢占式</li><li>优缺点：<ul><li>对各类型进程相对公平（FCFS的优点）</li><li>每个新到达的进程都可以很快就得到响应（RR的优点）</li><li>短进程只用较少的时间就可完成（SPF的优点）</li><li>不必实现估计进程的运行时间（避免用户作假）；</li><li>可灵活地调整对各类进程的偏好程度，比如 CPU 密集型进程、I/O 密集型进程（拓展：可以将因 I/O 而阻塞的进程重新放回原队列，这样 I/O 型进程就可以保持较高优先级）</li></ul></li><li>是否会导致饥饿/饿死：会</li></ul></li></ul><p><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part2/image-20211104151749404.png" alt="image-20211104151749404"></p><h2 id="进程同步"><a href="#进程同步" class="headerlink" title="进程同步"></a>进程同步</h2><h3 id="进程同步、进程互斥"><a href="#进程同步、进程互斥" class="headerlink" title="进程同步、进程互斥"></a>进程同步、进程互斥</h3><p><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part2/image-20211104162619267.png" alt="image-20211104162619267"></p><ul><li>进程同步<ul><li>针对问题：进程具有异步性的特征。各并发执行的进程以<strong>各自独立的、不可预知的</strong>速度向前推进。</li><li><strong>同步</strong>亦称<strong>直接制约关系</strong>。指为了完成某种任务而建立的多个进程，因为需要在某些位置上<strong>协调工作次序</strong>而产生的制约关系。</li></ul></li><li>进程互斥<ul><li>针对问题：<strong>一个时间段内只允许一个进程使用</strong>的资源称为临界资源。</li><li><strong>互斥</strong>，亦称<strong>间接制约关系</strong>。指当一个进程访问临界资源时，另一个想要访问该临界资源的进程必须等待，直到临界资源被释放</li><li><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part2/image-20211104162337247.png" alt="image-20211104162337247"></li><li>注意：<ul><li><strong>临界区</strong>是进程中<strong>访问临界资源</strong>的代码段。</li><li><strong>进入区</strong>和<strong>退出区</strong>是<strong>负责实现互斥</strong>的代码段。</li><li>临界区也可称为“临界段”。</li></ul></li><li><strong>四个原则</strong>：（为了实现对临界资源的互斥访问，同时保证系统整体性能）<ol><li>空闲让进。临界区空闲时，可以允许一个请求进入临界区的进程立即进入临界区；</li><li>忙则等待。当已有进程进入临界区时，其他试图进入临界区的进程必须等待；</li><li>有限等待。对请求访问的进程，应保证能在有限时间内进入临界区（保证不会饥饿）；</li><li>让权等待。当进程不能进入临界区时，应立即释放处理机，防止进程忙等待。</li></ol></li></ul></li></ul><h3 id="进程互斥的软件实现方法（高频）"><a href="#进程互斥的软件实现方法（高频）" class="headerlink" title="进程互斥的软件实现方法（高频）"></a>进程互斥的软件实现方法（高频）</h3><p><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part2/image-20211104165325471.png" alt="image-20211104165325471"></p><ul><li>单标志法<ul><li>算法思想：两个进程在<strong>访问完临界区后</strong>会把使用临界区的权限转交给另一个进程。即，<strong>每个进程进入临界区的权限只能被另一个进程赋予</strong></li><li>主要问题：违背“<strong>空闲让进</strong>”原则。</li><li><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part2/image-20211104202433915.png" alt="image-20211104202433915"></li></ul></li><li>双标志先检查<ul><li>算法思想：设置一个布尔型数组，用来<strong>标记各进程想进入临界区的意愿</strong></li><li>主要问题：违反“<strong>忙则等待</strong>”原则。</li><li>问题原因：<strong>检查</strong>与<strong>上锁</strong>之间可能发生进程切换。</li><li><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part2/image-20211104203017349.png" alt="image-20211104203017349"></li></ul></li><li>双标志后检查<ul><li>算法思想：先“上锁”后“检查”</li><li>主要问题：违背了“<strong>空闲让进</strong>”和“<strong>有限等待</strong>”原则，会产生“<strong>饥饿</strong>”现象。</li><li><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part2/image-20211104202926919.png" alt="image-20211104202926919"></li></ul></li><li>Peterson 算法<ul><li>算法思想：结合双标志法（争取）、单标志法（谦让）的思想。<strong>主动争取、主动谦让、检查</strong>。</li><li>主要问题：未遵循“<strong>让权等待</strong>”原则</li><li><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part2/image-20211104203638733.png" alt="image-20211104203638733"></li></ul></li></ul><h3 id="进程互斥的硬件实现方法"><a href="#进程互斥的硬件实现方法" class="headerlink" title="进程互斥的硬件实现方法"></a>进程互斥的硬件实现方法</h3><p><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part2/image-20211104204033279.png" alt="image-20211104204033279"></p><ul><li>中断屏蔽方法<ul><li>利用“开/关中断指令”实现</li><li>优点：<strong>简单、高效</strong></li><li>缺点：<ul><li><strong>不适用于多处理机</strong>。A 核执行了关中断，不影响 B 核使用相同的临界区。</li><li>只适用于操作系统内核进程，不适用于用户进程（<strong>开/关中断指令只能运行在内核态</strong>）</li></ul></li></ul></li><li>TestAndSet 指令<ul><li>TS 指令，也称 TestAndSetLock（TSL）指令</li><li>TSL 指令是用<strong>硬件实现</strong>的，执行的过程不允许被中断</li><li><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part2/image-20211105121953825.png" alt="image-20211105121953825"></li><li>优点：<ul><li>实现简单，无需像软件实现方法那样严格检查是否会有逻辑漏洞</li><li>适用于多处理机环境</li></ul></li><li>缺点：不满足“让权等待”原则，暂时无法进入临界区的进程会占用 CPU 并循环执行TSL指令。</li></ul></li><li>Swap 指令<ul><li>也称 Exchange（XCHG）指令</li><li>Swap 指令是用<strong>硬件实现</strong>的，执行的过程不允许被中断</li><li><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part2/image-20211105122231302.png" alt="image-20211105122231302"></li><li>优缺点：同 TestAndSet 指令</li></ul></li></ul><h3 id="信号量机制"><a href="#信号量机制" class="headerlink" title="信号量机制"></a>信号量机制</h3><p><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part2/image-20211105124116186.png" alt="image-20211105124116186"></p><ul><li>基本概念：<ul><li>用户进程可以通过使用操作系统提供的<strong>一对原语</strong>来对<strong>信号量</strong>进行操作，从而很方便的实现了进程互斥、进程同步。</li><li>信号量其实就是一个变量，用来<strong>表示系统中某种资源的数量</strong>。</li><li>原语是一种特殊的程序段，其<strong>执行只能一气呵成，不可被中断</strong>。</li><li>一对原语：<strong>wait(S) 原语</strong>和 <strong>signal(S) 原语</strong>，S 为信号量</li><li>wait、signal 原语常简称为 P、V 操作（来自荷兰语 proberen 和 verhogen），即 <strong>P(S)、V(S)</strong></li></ul></li><li>整型信号量<ul><li>用一个<strong>整数型的变量</strong>作为信号量。<ul><li>与普通整数变量的区别：对信号量的操作只有三种，初始化、P 操作、V 操作</li></ul></li><li>其实和 TS 指令差不多</li><li><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part2/image-20211105124727576.png" alt="image-20211105124727576" style="zoom: 75%;"></li><li>问题：<strong>不满足“让权等待”</strong></li></ul></li><li>记录型信号量<ul><li>用记录型数据结构表示的信号量。<ul><li>如果剩余资源数不足，使用 <strong>block 原语</strong>使进程<strong>从运行态进入阻塞态</strong>，并把挂到信号量 S 的等待队列（阻塞队列）中</li><li>释放资源后，若还有别的进程在等待这种资源，则使用 <strong>wakeup 原语</strong>唤醒等待队列中的一个进程，该进程<strong>从阻塞态变为就绪态</strong></li></ul></li><li><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part2/image-20211105125223262.png" alt="image-20211105125223262" style="zoom:80%;"></li><li>P(S)、V(S) 实现系统资源的“<strong>申请</strong>”和“<strong>释放</strong>”。</li><li><strong>S.value 的初值</strong>表示系统中<strong>某种资源的数目</strong>。</li><li>P 操作：<ul><li>对信号量 S 的<strong>一次 P 操作</strong>意味着进程<strong>请求一个单位的该类资源</strong>，因此需要执行 S.value–，表示资源数减 1。</li><li>当 S.value &lt; 0 时表示该类资源已分配完毕，因此进程应调用 block 原语进行自我阻塞（**当前运行的进程从运行态 -&gt; 阻塞态<strong>），</strong>主动放弃处理机<strong>，并</strong>插入该类资源的等待队列 S.L 中**。</li><li>可见，该机制<strong>遵循了“让权等待”原则</strong>，不会出现“忙等”现象。</li></ul></li><li>V 操作：<ul><li>对信号量 S 的<strong>一次 V 操作</strong>意味着进程<strong>释放一个单位的该类资源</strong>，因此需要执行 S.value++，表示资源数加 1。</li><li>若加 1 后仍是 S.value &lt;= 0，表示依然有进程在等待该类资源，因此应**调用 wakeup 原语**唤醒等待队列中的第一个进程（**被唤醒进程从阻塞态 -&gt; 就绪态**）。</li></ul></li></ul></li></ul><blockquote><p>信号量的值 = 这种资源的剩余数量</p><p>P( S ) —— 申请一个资源 S，如果资源不够就阻塞等待</p><p>V( S ) —— 释放一个资源 S，如果有进程在等待该资源，则唤醒一个进程</p></blockquote><h3 id="信号量实现进程互斥、同步、前驱关系"><a href="#信号量实现进程互斥、同步、前驱关系" class="headerlink" title="信号量实现进程互斥、同步、前驱关系"></a>信号量实现进程互斥、同步、前驱关系</h3><p><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part2/image-20211105131735276.png" alt="image-20211105131735276"></p><ul><li>实现进程互斥<ul><li>过程：<ul><li>分析并发进程的关键活动，划定临界区</li><li>设置互斥信号量 mutex，<strong>初值为 1</strong></li><li><strong>在进入区 P(mutex)——申请资源</strong></li><li><strong>在退出区 V(mutex)——释放资源</strong></li><li><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part2/image-20211105144434351.png" alt="image-20211105144434351" style="zoom:80%;"></li></ul></li><li>注意：<ul><li>对不同的临界资源需要设置不同的互斥信号量。 </li><li>P、V 操作必须成对出现。缺少 P(mutex) 就不能保证临界资源的互斥访问。缺少 V(mutex) 会导致资源永不被释放，等待进程永不被唤醒。</li></ul></li></ul></li><li>实现进程同步<ul><li>过程：<ul><li>分析什么地方需要实现“同步关系”，即必须保证“一前一后”执行的两个操作</li><li>设置同步信号量 S，<strong>初始为 0</strong></li><li><strong>在“前操作”之后执行 V(S)</strong></li><li><strong>在“后操作”之前执行 P(S)</strong><ul><li>信号量 S 代表“某种资源”，刚开始是没有这种资源的。P2 需要使用这种资源，而又只能由 P1 产生这种资源</li><li><strong>前 V 后 P</strong></li></ul></li><li><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part2/image-20211105144750166.png" alt="image-20211105144750166" style="zoom:80%;"></li></ul></li></ul></li><li>实现前驱关系<ul><li>过程<ul><li>为<strong>每一对前驱关系</strong>各设置一个同步信号量</li><li>在“前操作”之后对相应的同步信号量执行 V 操作</li><li>在“后操作”之前对相应的同步信号量执行 P 操作</li><li><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part2/image-20211105145022913.png" alt="image-20211105145022913" style="zoom:80%;"></li></ul></li><li>前驱关系问题，<strong>本质上就是多级同步问题</strong>。</li></ul></li></ul><h3 id="生产者-消费者问题"><a href="#生产者-消费者问题" class="headerlink" title="生产者-消费者问题"></a>生产者-消费者问题</h3><ul><li>问题描述：系统中有一组生产者进程和一组消费者进程，生产者进程每次生产一个产品放入缓冲区，消费者进程每次从缓冲区中取出一个产品并使用。生产者、消费者共享一个初始为空、大小为 n 的缓冲区。</li><li>问题分析：<ul><li>只有<strong>缓冲区没满</strong>时，生产者才能把产品放入缓冲区，否则必须等待。——同步</li><li>只有<strong>缓冲区不空</strong>时，消费者才能从中取出产品，否则必须等待。——同步</li><li>缓冲区是临界资源，各进程必须<strong>互斥</strong>地访问。——互斥</li></ul></li><li>算法实现：<ul><li><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part2/image-20211105173157993.png" alt="image-20211105173157993"></li></ul></li><li>注意：<ul><li><strong>实现互斥的 P 操作一定要在实现同步的 P 操作之后</strong>。</li><li>V 操作不会导致进程阻塞，因此<strong>两个 V 操作顺序可以交换</strong>。</li><li>生产产品与使用产品可以放在 P、V 中间，但是这样会使得临界区代码变长</li><li>有时候是<strong>消费者需要等待生产者生产</strong>，有时候是<strong>生产者要等待消费者消费</strong>，这是两个不同的“一前一后问题”。因此，题目<strong>隐含两对同步关系</strong>，也需要<strong>设置两个同步信号量</strong>。</li></ul></li></ul><h3 id="多生产者-多消费者"><a href="#多生产者-多消费者" class="headerlink" title="多生产者-多消费者"></a>多生产者-多消费者</h3><ul><li>问题描述：桌子上有一只盘子，每次只能向其中放入一个水果。爸爸专向盘子中放苹果，妈妈专向盘子中放橘子，儿子专等着吃盘子中的橘子，女儿专等着吃盘子中的苹果。只有盘子空时，爸爸或妈妈才可向盘子中放一个水果。仅当盘子中有自己需要的水果时，儿子或女儿可以从盘子中取出水果。</li><li>问题分析：<ul><li>对缓冲区（盘子）的访问要互斥地进行。——互斥</li><li>父亲将苹果放入盘子后，女儿才能取苹果。——同步</li><li>母亲将橘子放入盘子后，儿子才能取橘子。——同步</li><li>只有<strong>盘子为空</strong>时，<strong>父亲或母亲</strong>才能放入水果。——同步<ul><li>“盘子为空”这个事件可以由儿子或女儿触发。</li></ul></li></ul></li><li>算法实现<ul><li><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part2/image-20211105175350546.png" alt="image-20211105175350546"></li></ul></li><li>注意：<ul><li>当缓冲区容量为 1 时，则<strong>可能</strong>不设置专门的互斥变量 mutex，也不会出现多个进程同时访问盘子的现象。具体情况具体分析</li><li>如果来不及仔细分析，完全可以加上互斥信号量，以保证各进程一定会互斥地访问缓冲区。<strong>互斥的 P 一定要在同步 P 之后</strong>。</li></ul></li></ul><blockquote><p>解决“多生产者-多消费者问题”的关键在于理清复杂的同步关系。</p><p>在分析同步问题（一前一后问题）的时候<strong>不能从单个进程行为</strong>的角度来分析，要把“一前一后”发生的事看做是两种“<strong>事件</strong>”的前后关系。</p><ul><li>如果从单个进程行为的角度来考虑的话，我们会有以下结论：<ul><li>如果盘子里装有苹果，那么一定要女儿取走苹果后父亲或母亲才能再放入水果</li><li>如果盘子里装有橘子，那么一定要儿子取走橘子后父亲或母亲才能再放入水果</li><li>意味着要设置四个同步信号量分别实现这四个“一前一后”的关系？</li></ul></li><li>正确的分析方法应该从“事件”（面向过程）的角度来考虑，我们可以把上述四对“进程行为的前后关系”抽象为一对“事件的前后关系”<ul><li>盘子变空事件 -&gt; 放入水果事件。</li><li>“盘子变空事件”既可由儿子（进程）引发，也可由女儿（进程）引发；“放水果事件”既可能是父亲（进程）执行，也可能是母亲（进程）执行。</li><li>这样的话，就可以用一个同步信号量解决问题了</li></ul></li></ul></blockquote><h3 id="吸烟者问题"><a href="#吸烟者问题" class="headerlink" title="吸烟者问题"></a>吸烟者问题</h3><ul><li>问题描述：假设一个系统有<strong>三个抽烟者进程</strong>和<strong>一个供应者进程</strong>。每个抽烟者不停地卷烟并抽掉它，但是要卷起并抽掉一支烟，抽烟者需要有三种材料：烟草、纸和胶水。三个抽烟者中，<strong>第一个拥有烟草、第二个拥有纸、第三个拥有胶水</strong>。供应者进程无限地提供三种材料，供应者每次将两种材料放桌子上，<strong>拥有剩下那种材料的抽烟者卷一根烟并抽掉它，并给供应者进程一个信号告诉完成了</strong>，供应者就会放另外两种材料再桌上，这个过程一直重复（<strong>让三个抽烟者轮流地抽烟</strong>）</li><li>问题分析：<ul><li>也属于“生产者-消费者”问题，更详细的说应该是“可生产多种产品的单生产者-多消费者”。</li><li>缓冲区大小为 1，每个吸烟者其实需要的是<strong>一个“组合”</strong>，且<strong>可以不设置互斥信号量</strong></li><li><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part2/image-20211105194323459.png" alt="image-20211105194323459"></li></ul></li><li>算法实现：<ul><li><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part2/image-20211105194941823.png" alt="image-20211105194941823"></li></ul></li></ul><h3 id="读者-写者问题"><a href="#读者-写者问题" class="headerlink" title="读者-写者问题"></a>读者-写者问题</h3><ul><li>问题描述：<ul><li>有读者和写者两组并发进程，共享一个文件，当两个或两个以上的读进程同时访问共享数据时不会产生副作用，但若某个写进程和其他进程（读进程或写进程）同时访问共享数据时则可能导致数据不一致的错误。</li><li>因此要求：①<strong>允许多个读者可以同时对文件执行读操作</strong>；②<strong>只允许一个写者往文件中写信息</strong>；③<strong>任一写者在完成写操作之前不允许其他读者或写者工作</strong>；④<strong>写者执行写操作前，应让已有的读者和写者全部退出</strong>。</li></ul></li><li>问题分析：<ul><li>两类进程：写进程、读进程</li><li>互斥关系：写进程—写进程、写进程—读进程。读进程与读进程不存在互斥问题。</li></ul></li><li>算法实现：<ul><li>读进程优先：<ul><li><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part2/image-20211105202012898.png" alt="image-20211105202012898"></li><li>问题：若<strong>两个读进程并发执行</strong>，则 count=0 时两个进程也许<strong>都能满足 if 条件，都会执行 P(rw)**，从而</strong>使第二个读进程阻塞**的情况。</li><li>原因：在于对 count 变量的检查和赋值无法一气呵成</li><li>解决：设置 mutex  互斥信号量来保证各读进程对 count 变量的互斥访问</li><li>特点：只要有读进程还在读，写进程就要一直阻塞等待，可能“饿死”。因此，该算法为<strong>读进程优先</strong></li></ul></li><li>读写公平：<ul><li><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part2/image-20211105202325653.png" alt="image-20211105202325653"></li><li>精髓：在读者写者中 P(w)、V(w) 分别<strong>包住了写文件</strong>和<strong>没有包住读文件</strong>，因此可以保证写者与其他互斥，读文件可以并发</li></ul></li></ul></li></ul><blockquote><p>总结：</p><ul><li>互斥 -&gt; 读者写者；同步 -&gt; 生产者消费者</li><li>对于读者共享，要<strong>设置计数器 count 来记录当前正在访问共享文件的读进程数</strong>。<strong>只有第一个/最后一个读进程需要进行 P、V 操作</strong>。</li><li>对于需要一气呵成的“<strong>检查和赋值</strong>” ，自然应该想到用<strong>互斥信号量</strong>实现。 </li><li>解决“写进程饥饿”问题，需要<strong>通过写者来限制读者访问 count</strong>。</li></ul></blockquote><h3 id="哲学家进餐问题"><a href="#哲学家进餐问题" class="headerlink" title="哲学家进餐问题"></a>哲学家进餐问题</h3><ul><li>问题描述：一张圆桌上坐着 5 名哲学家，每两个哲学家之间的桌上摆一根筷子，桌子的中间是一碗米饭。哲学家们倾注毕生的精力用于思考和进餐，哲学家在思考时，并不影响他人。只有当哲学家饥饿时，才试图拿起左、右两根筷子（一根一根地拿起）。如果筷子已在他人手上，则需等待。饥饿的哲学家只有同时拿起两根筷子才可以开始进餐，当进餐完毕后，放下筷子继续思考。</li><li>问题分析：因为需要<strong>同时持有两个临界资源</strong>，所以如果多个哲学家并发则可能出现<strong>循环等待</strong>，<strong>发生死锁</strong>。</li><li>算法实现：<ul><li>保证了“<strong>各哲学家拿筷子这件事必须互斥的执行</strong>”。<ul><li>即使一个哲学家在拿筷子拿到一半时被阻塞，也不会有别的哲学家继续尝试拿筷子。</li></ul></li><li>并不能保证“<strong>仅当一个哲学家左右两支筷子都可用时才允许他抓起筷子</strong>”。</li><li><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part2/image-20211105215209806.png" alt="image-20211105215209806" style="zoom:80%;"></li></ul></li></ul><h3 id="管程"><a href="#管程" class="headerlink" title="管程"></a>管程</h3><p><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part2/image-20211105215354783.png" alt="image-20211105215354783"></p><ul><li>针对问题：编写程序困难、易出错</li><li>改进方向：将复杂部分<strong>封装</strong>为管程，对外<strong>仅暴露接口</strong></li><li>组成：<ul><li>局部于管程的<strong>共享数据结构</strong></li><li>对该数据结构进行操作的<strong>过程</strong></li><li>对共享数据设置的<strong>初始值</strong></li><li>管程的名字</li></ul></li><li>基本特征：<ul><li>共享数据<strong>只能由内部的过程操作</strong></li><li>一个进程<strong>只有通过调用管程的过程</strong>才能访问共享数据</li><li><strong>每次仅允许一个进程在管程内执行某个内部过程</strong></li><li>其互斥特性是<strong>由编译器负责实现</strong></li><li>可在管程中设置<strong>条件变量</strong>及<strong>等待/唤醒操作</strong>以解决同步问题。</li></ul></li><li>实现：（伪代码，不考）<ul><li><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part2/image-20211105221421680.png" alt="image-20211105221421680"></li><li>JAVA 中的 synchronized 关键字</li></ul></li></ul><h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><h3 id="死锁的概念"><a href="#死锁的概念" class="headerlink" title="死锁的概念"></a>死锁的概念</h3><p><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part2/image-20211106134325023.png" alt="image-20211106134325023"></p><ul><li>死锁、饥饿、死循环<ul><li>死锁：各进程互相等待对方手里的资源，导致各进程都阻塞，无法向前推进的现象。</li><li>饥饿：由于长期得不到想要的资源，某进程无法向前推进的现象。</li><li>死循环：某进程执行过程中一直跳不出某个循环的现象。</li></ul></li><li>共同点：都是进程无法顺利向前推进的现象</li><li><strong>死锁、饥饿、死循环的区别</strong><ul><li>数量：<ul><li>死锁：如果有死锁现象，那<strong>至少有两个或两个以上</strong>的进程同时发生死锁。</li><li>饥饿：可能<strong>只有一个或多个</strong>进程发生饥饿。</li><li>死循环：可能<strong>只有一个或多个</strong>进程发生死循环。</li></ul></li><li>原因：<ul><li>死锁：一定是“<strong>循环等待对方手里的资源</strong>”导致的</li><li>饥饿：长期得不到需要的 <strong>I/O 设备</strong>或<strong>处理机</strong></li><li>死循环：代码<strong>逻辑的错误或者人为因素</strong></li></ul></li><li>进程状态：<ul><li>死锁：一定处于阻塞态。</li><li>饥饿：既可能是阻塞态，也可能是就绪态。</li><li>死循环：可以是运行态</li></ul></li><li>死锁和饥饿，是由于<strong>操作系统分配资源的策略不合理</strong>导致的，是管理者（操作系统）的问题；死循环是<strong>被管理者</strong>的问题。</li></ul></li><li><strong>死锁产生的必要条件</strong><ul><li>产生死锁<strong>必须同时满足</strong>一下四个条件，只要其中任一条件不成立，死锁就不会发生。</li><li><strong>互斥条件</strong>：<strong>只有对必须互斥使用的资源的争抢</strong>才会导致死锁（如哲学家的筷子、打印机设备）。像内存、扬声器这样可以同时让多个进程使用的资源是不会导致死锁的（因为进程不用阻塞等待这种资源）。</li><li><strong>不剥夺条件</strong>：进程所获得的资源在<strong>未使用完之前，不能由其他进程强行夺走</strong>，只能主动释放。</li><li><strong>请求和保持条件</strong>：进程<strong>已经保持了至少一个资源，但又提出了新的资源请求，而该资源又被其他进程占有</strong>，此时请求进程被阻塞，但又对自己已有的资源保持不放。</li><li><strong>循环等待条件</strong>：存在一种<strong>进程资源的循环等待链</strong>，链中的每一个进程已获得的资源同时被下一个进程所请求。</li></ul></li><li>注意：发生死锁时一定有循环等待，但是发生循环等待时未必死锁（循环等待是死锁的必要不充分条件）<ul><li>存在循环等待的同时，还存在其他可以获得资源的分支</li><li><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part2/image-20211106133925724.png" alt="image-20211106133925724" style="zoom:50%;"></li></ul></li><li>发生死锁的情况（<strong>对不可剥夺资源的不合理分配</strong>）<ul><li>对系统资源的竞争。各进程对<strong>不可剥夺的资源</strong>（如打印机）的竞争可能引起死锁，对可剥夺的资源（CPU）的竞争是不会引起死锁的。</li><li>进程推进顺序非法。请求和释放资源的顺序不当，也同样会导致死锁。例如，并发执行的进程 P1、P2 分别申请并占有了资源 R1、R2，之后进程 P1 又紧接着申请资源 R2，而进程 P2 又申请资源 R1，两者会因为申请的资源被对方占有而阻塞，从而发生死锁。</li><li>信号量的使用不当也会造成死锁。如生产者-消费者问题中，如果实现互斥的P操作在实现同步的 P 操作之前，就有可能导致死锁。（可以把互斥信号量、同步信号量也看做是一种抽象的系统资源）</li></ul></li></ul><h3 id="死锁的处理策略"><a href="#死锁的处理策略" class="headerlink" title="死锁的处理策略"></a>死锁的处理策略</h3><h4 id="预防死锁（静态策略）"><a href="#预防死锁（静态策略）" class="headerlink" title="预防死锁（静态策略）"></a>预防死锁（静态策略）</h4><p><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part2/image-20211106134712771.png" alt="image-20211106134712771"></p><ul><li><strong>破坏互斥条件</strong><ul><li>把只能互斥使用的资源改造为允许共享使用，则系统不会进入死锁状态。</li><li>如：SPOOLing 技术把独占设备在逻辑上改造成共享设备。<ul><li><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part2/image-20211106145121574.png" alt="image-20211106145121574" style="zoom:80%;"></li></ul></li><li>缺点：并不是所有的资源都可以改造成可共享使用的资源。并且为了系统安全，很多地方还必须保护这种互斥性。因此，<strong>很多时候都无法破坏互斥条件</strong>。</li></ul></li><li><strong>破坏不剥夺条件</strong><ul><li>方案一：当某个进程请求新的资源得不到满足时，必须立即<strong>主动释放保持的所有资源</strong>，以后需要时重新申请。</li><li>方案二：当某个进程需要的资源被其他进程所占有的时候，可以<strong>由操作系统协助，将想要的资源强行剥夺</strong>。<ul><li>这种方式一般需要考虑各进程的优先级（比如：剥夺调度方式，就是将处理机资源强行剥夺给优先级更高的进程使用）</li></ul></li><li>缺点：<ul><li>实现起来比较复杂。</li><li>释放已获得的资源可能造成前一阶段工作的失效。因此这种方法一般只<strong>适用于易保存和恢复状态的资源</strong>，如 CPU。</li><li>反复地申请和释放资源会增加系统开销，降低系统吞吐量。</li><li>若采用方案一，意味着只要暂时得不到某个资源，之前获得的那些资源就都需要放弃，以后再重新申请。如果<strong>一直发生放弃资源，就会导致进程饥饿</strong>。</li></ul></li></ul></li><li><strong>破坏请求和保持条件</strong><ul><li>采用<strong>静态分配方法</strong>，即进程在运行前一次申请完它所需要的全部资源，在它的资源未满足前，不让它投入运行。一旦投入运行后，这些资源就一直归它所有，该进程就不会再请求别的任何资源了。</li><li>缺点：<strong>有些资源可能只需要用很短的时间</strong>，因此如果进程的整个运行期间都一直保持着所有资源，就会造成严重的<strong>资源浪费</strong>，资源利用率极低。另外，该策略也有可能导致某些进程饥饿。</li></ul></li><li><strong>破坏循环等待条件</strong><ul><li>采用<strong>顺序资源分配法</strong>。首先给系统中的资源编号，规定每个进程<strong>必须按编号递增的顺序请求资源</strong>（持有 n 号资源时，不允许请求 &lt;n 号的资源），同类资源（即编号相同的资源）一次申请完。</li><li>缺点：<ul><li><strong>不方便增加新的设备</strong>，因为可能需要重新分配所有的编号；</li><li>进程<strong>实际使用资源的顺序</strong>可能和<strong>编号递增顺序</strong>不一致（必须先占有资源，但不使用），会导致资源浪费；</li><li>必须按规定次序申请资源，编程麻烦。</li></ul></li></ul></li></ul><h4 id="避免死锁（动态策略）"><a href="#避免死锁（动态策略）" class="headerlink" title="避免死锁（动态策略）"></a>避免死锁（动态策略）</h4><ul><li><p><strong>安全序列</strong>，指如果系统按照这种序列分配资源，则每个进程都能顺利完成。</p><ul><li>只要能找出一个安全序列，系统就是<strong>安全状态</strong>。<strong>安全序列可能有多个</strong>。</li><li>如果分配了资源之后，系统中找不出任何一个安全序列，系统就进入了<strong>不安全状态</strong>。这就意味着之后<strong>可能</strong>所有进程都无法顺利的执行下去。<ul><li>如果有进程提前归还了一些资源，那系统也<strong>有可能重新回到安全状态</strong>，不过我们在分配资源之前总是要考虑到最坏的情况。</li></ul></li></ul></li><li><p>注意：</p><ul><li>如果系统处于<strong>安全状态</strong>，就<strong>一定不会发生死锁</strong>；如果系统进入<strong>不安全状态</strong>，就<strong>可能发生死锁</strong>。</li><li><strong>处于不安全状态未必会发生死锁，但发生死锁时一定是在不安全状态</strong></li></ul></li><li><p>核心思想：</p><ul><li>在进程提出资源申请时，先预判此次分配是否会导致系统进入不安全状态。如果会进入不安全状态，就暂时不答应这次请求，让该进程先阻塞等待。</li></ul></li><li><p>算法实现：</p><ul><li><p>假设系统中有 n 个进程，m 种资源</p></li><li><p>数据结构：</p><ul><li><p>n*m 矩阵 <strong>Max</strong> 表示各进程对资源的最大需求数</p></li><li><p>n*m 矩阵 <strong>Allocation</strong> 表示已经给各进程分配了多少资源</p></li><li><p>Max – Allocation = <strong>Need</strong> 矩阵表示各进程最多还需要多少资源</p></li><li><p>长度为 m 的一维数组 <strong>Available</strong> 表示还有多少可用资源</p></li><li><p>用长度为 m 的一位数组 <strong>Request</strong> 表示进程此次申请的各种资源数</p></li></ul></li><li><p>银行家算法步骤：</p><ul><li>Request ≤ Need[i]：检查此次申请是否超过了之前声明的最大需求数</li><li>Request ≤ Available：检查此时系统剩余的可用资源是否还能满足这次请求</li><li>Available -= Request；Allocation[i] += Request；Need[i] -= Request：试探着分配，更改各数据结构</li><li>用安全性算法<strong>检查此次分配是否会导致系统进入不安全状态</strong>（是否能找到安全序列）。若安全，才正式分配；否则，恢复相应数据，让进程阻塞等待。</li></ul></li><li><p><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part2/image-20211106153921852.png" alt="image-20211106153921852"></p></li><li><p><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part2/image-20211106154041109.png" alt="image-20211106154041109"></p></li></ul></li></ul><h4 id="死锁的检测与解除"><a href="#死锁的检测与解除" class="headerlink" title="死锁的检测与解除"></a>死锁的检测与解除</h4><p><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part2/image-20211106153523487.png" alt="image-20211106153523487"></p><p>如果系统中<strong>既不采取预防死锁的措施，也不采取避免死锁的措施</strong>，系统就很可能发生死锁。在这种情况下，系统应当提供两个算法：</p><ul><li><p>死锁检测算法：</p><ul><li>用于检测系统状态，以确定系统中是否发生了死锁。</li><li>算法实现：<ul><li>用某种<strong>数据结构</strong>来保存资源的请求和分配信息</li><li>提供<strong>一种算法</strong>，利用上述信息来检测系统是否已进入死锁状态</li><li><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part2/image-20211106160701820.png" alt="image-20211106160701820"></li><li>删去所有<strong>可以请求到足够资源</strong>（不阻塞）的<strong>进程节点的边</strong><ul><li>最终能消除所有边，就称这个图是<strong>可完全简化的</strong>。此时一定没有发生死锁（能找到一个安全序列）</li><li>如果最终不能消除所有边，那么此时就是发生了死锁。</li><li><strong>化简资源分配图后，还连着边的那些进程就是死锁进程</strong>。</li></ul></li></ul></li><li>死锁定理：如果某时刻系统的资源分配图是<strong>不可完全简化</strong>的，那么此时系统死锁</li></ul></li><li><p>死锁解除算法：</p><ul><li><p>当认定系统中已经发生了死锁，利用该算法可将系统从死锁状态中解脱出来。</p></li><li><p>解除死锁的主要方法有：</p><ol><li><p><strong>资源剥夺法</strong>。挂起（暂时放到外存上）某些死锁进程，并抢占它的资源，将这些资源分配给其他的死锁进程。但是应防止被挂起的进程长时间得不到资源而饥饿。</p></li><li><p><strong>撤销进程法</strong>（<strong>终止进程法</strong>）。强制撤销部分、甚至全部死锁进程，并剥夺这些进程的资源。这种方式的优点是实现简单，但所付出的代价可能会很大。因为有些进程可能已经运行了很长时间，已经接近结束了，一旦被终止可谓功亏一篑，以后还得从头再来。</p></li><li><p><strong>进程回退法</strong>。让一个或多个死锁进程回退到足以避免死锁的地步。这就要求系统要记录进程的历史信息，设置还原点。</p></li></ol></li><li><p>确定解除对象进程：</p><ol><li><p>进程优先级（优先级更高的进程先获得资源）</p></li><li><p>已执行时间（回退已执行时间越长的进程，代价越大）</p></li><li><p>预计完成花费时间（优先让快结束的进程获得资源）</p></li><li><p>进程已使用资源量（优先牺牲持有多资源的进程）</p></li><li><p>进程是交互式的还是批处理式的（优先牺牲批处理式进程）</p></li></ol></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>操作系统-Part1</title>
      <link href="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part1/"/>
      <url>/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part1/</url>
      
        <content type="html"><![CDATA[<h1 id="操作系统-Part1——计算机系统概述"><a href="#操作系统-Part1——计算机系统概述" class="headerlink" title="操作系统-Part1——计算机系统概述"></a>操作系统-Part1——计算机系统概述</h1><p>[TOC]</p><h2 id="操作系统的概念、功能"><a href="#操作系统的概念、功能" class="headerlink" title="操作系统的概念、功能"></a>操作系统的概念、功能</h2><p><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part1/image-20211101105704370.png" alt="image-20211101105704370"></p><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><ul><li><strong>操作系统</strong>（Operating System， OS）是指控制和<strong>管理</strong>整个计算机系统的<strong>硬件和软件资源</strong>，并合理地组织调度计算机的工作和资源的分配；以<strong>提供给用户和其他软件方便的接口和环境</strong>；它是计算机系统中最基本的<strong>系统软件</strong>。 <ul><li>操作系统是系统资源的管理者</li><li>向上层提供方便易用的服务</li><li>是最接近硬件的一层软件</li></ul></li></ul><h3 id="功能和目标"><a href="#功能和目标" class="headerlink" title="功能和目标"></a>功能和目标</h3><ul><li>作为系统资源的管理者<ul><li>功能：<ul><li>处理机管理</li><li>存储器管理</li><li>文件管理</li><li>设备管理</li></ul></li><li>目标：<ul><li>安全、高效</li></ul></li></ul></li><li>向上层提供方便易用的服务<ul><li>封装：操作系统把丑陋的硬件功能封装成简单易用的服务，使用户能更方便地使用计算机</li><li>实例：<ul><li>直接给用户使用<ul><li><strong>GUI</strong>（Graphical User Interface）：图形化用户接口</li><li>命令接口<ul><li><strong>联机命令接口</strong>（交互式命令接口）</li><li><strong>脱机命令接口</strong>（批处理命令接口）</li></ul></li></ul></li><li>给软件/程序员使用<ul><li><strong>程序接口</strong>：系统调用（广义指令）是应用程序请求操作系统服务的唯一方式</li></ul></li></ul></li><li>其中，命令接口与程序接口，统称为<strong>用户接口</strong>（狭义的用户接口不包括 GUI）</li></ul></li><li>作为最接近硬件的层次<ul><li>目标：实现<strong>对硬件机器的拓展</strong><ul><li>使单纯的硬件组合起来以获得更强的功能</li></ul></li><li>通常把覆盖了软件的机器成为扩充机器，又称之为虚拟机</li></ul></li></ul><h2 id="操作系统的特征"><a href="#操作系统的特征" class="headerlink" title="操作系统的特征"></a>操作系统的特征</h2><p><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part1/image-20211101105417671.png" alt="image-20211101105417671"></p><p>考点：</p><ul><li>并发和并行的区别</li><li>并发和共享<strong>互为存在条件</strong></li><li>并发和共享<strong>是操作系统的两个最基本的特征</strong>（没有并发和共享，就谈不上虚拟和异步）</li></ul><h3 id="基本特征"><a href="#基本特征" class="headerlink" title="基本特征"></a>基本特征</h3><ul><li>操作系统的特征<ul><li>并发</li><li>共享</li><li>虚拟</li><li>异步</li></ul></li><li>其中，并发和共享<strong>是两个最基本的特征，二者互为条件</strong>（重点）。</li></ul><h3 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h3><ul><li><p>并发：指两个或多个事件在同一时间间隔内发生。这些事件<strong>宏观上是同时发生的</strong>，但<strong>微观上是交替发生的</strong>。</p><ul><li>常考易混概念——<strong>并行</strong>：指两个或多个事件在<strong>同一时刻同时发生</strong>。</li></ul></li><li><p><strong>操作系统的并发性</strong>：指计算机系统中<strong>同时运行着多个程序</strong>，这些程序宏观上看是同时运行着的，而微观上看是交替运行的。</p><ul><li>操作系统就是伴随着“多道程序技术”而出现的，<strong>操作系统和程序并发是一起诞生的</strong>。</li></ul></li><li><p>注意（重要考点）：</p><ul><li>单核 CPU 同一时刻只能执行一个程序，各个程序<strong>只能并发</strong>地执行。</li><li>多核 CPU 同一时刻可以同时执行多个程序，多个程序<strong>可以并行</strong>地执行。</li></ul></li><li><p>只要有超过可并行数量的程序需要同时运行，那么并发性就是必不可少的。所以，<strong>并发性是操作系统一个最基本的特性</strong>。</p></li></ul><h3 id="共享"><a href="#共享" class="headerlink" title="共享"></a>共享</h3><ul><li><strong>共享</strong>：即资源共享，是指系统中的资源可供内存中多个并发执行的进程共同使用。</li><li>两种资源共享方式<ul><li>互斥共享方式：系统中的某些资源，虽然可以提供给多个进程使用，但<strong>一个时间段内只允许一个进程访问该资源</strong></li><li>同时共享方式：系统中的某些资源，<strong>允许一个时间段内由多个进程“同时”对它们进行访问</strong></li></ul></li><li>所谓的“同时”往往是宏观上的，而在微观上，<strong>这些进程可能是交替地对该资源进行访问的</strong>（分时共享）<ul><li>微观上交替，例：多个进程交替访问硬盘</li><li>也有可能是宏观上也为同时，例：多个进程同时使用扬声器</li></ul></li></ul><blockquote><p>并发和共享的关系：</p><ul><li>两个进程正在并发执行（并发性）<ul><li>如果失去并发性，则系统中只有一个程序正在运行，则共享性失去存在的意义</li></ul></li><li>需要共享地访问硬盘资源（共享性）<ul><li>如果失去共享性，则 QQ 和微信不能同时访问硬盘资源，就无法实现同时发送文件，也就无法并发</li></ul></li></ul></blockquote><h3 id="虚拟"><a href="#虚拟" class="headerlink" title="虚拟"></a>虚拟</h3><ul><li>虚拟：指把一个物理上的实体变为若干个逻辑上的对应物。物理实体（前者）是实际存在的，而逻辑上对应物（后者）是用户感受到的。</li><li>虚拟技术：<ul><li>空分复用技术<ul><li>如虚拟存储器技术：运行程序的大小远超实际内存</li></ul></li><li>时分复用技术：微观上处理机在各个微小的时间段内交替着为各个进程服务<ul><li>如虚拟处理器技术：实际只有单核，但是用户看来有多核 CPU 在工作</li></ul></li></ul></li></ul><blockquote><p>如果失去了并发性，就失去了实现虚拟性的意义了。因此，<strong>没有并发性，就谈不上虚拟性</strong>。</p></blockquote><h3 id="异步"><a href="#异步" class="headerlink" title="异步"></a>异步</h3><ul><li>进程的异步性：在多道程序环境下，允许多个程序并发执行，但由于资源有限，进程的执行只能以不可预知的速度向前推进。</li><li>并发运行的程序会争抢使用系统资源，而系统中的资源有限，因此进程的执行不是一贯到底的，而是走走停停的，向前推进的速度是不可预知的</li></ul><blockquote><p>如果失去了并发性，即系统只能串行地运行各个程序，那么每个程序的执行会一贯到底。<strong>只有系统拥有并发性，才有可能导致异步性</strong>。</p></blockquote><h2 id="操作系统的发展与分类"><a href="#操作系统的发展与分类" class="headerlink" title="操作系统的发展与分类"></a>操作系统的发展与分类</h2><p><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part1/image-20211101105849759.png" alt="image-20211101105849759"></p><h3 id="发展阶段"><a href="#发展阶段" class="headerlink" title="发展阶段"></a>发展阶段</h3><ul><li><p>手工操作阶段</p><ul><li>主要缺点：用户独占全机、人机速度矛盾导致资源利用率极低</li></ul></li><li><p>批处理阶段——单道批处理系统</p><ul><li>引入<strong>脱机输入/输出技术</strong>（用外围机+磁带完成），并由<strong>监督程序</strong>负责控制作业的输入、输出<ul><li>通过外围机把程序（纸带）提前存到磁带里，主机则读写磁带信息</li><li>监督程序是操作系统的雏形</li></ul></li><li>主要优点：缓解了一定程度的人机速度矛盾，资源利用率有所提升。</li><li>主要缺点：<ul><li>内存中仅能有一道程序运行，只有该程序运行结束之后才能调入下一道程序。</li><li>CPU 有大量的时间是在空闲等待 I/O 完成。资源利用率依然很低。</li></ul></li></ul></li><li><p>批处理阶段——多道批处理系统</p><ul><li>每次往内存中读入多道程序</li><li>操作系统正式诞生，用于支持多道程序并发运行</li><li>主要优点：多道程序并发执行，共享计算机资源。资源利用率大幅提升，CPU 和其他资源更能保持“忙碌”状态，系统吞吐量增大。</li><li>主要缺点：用户响应时间长，没有人机交互功能（用户提交自己的作业之后就只能等待计算机处理完成，中间不能控制自己的作业执行）</li></ul></li><li><p>分时操作系统</p><ul><li>计算机以<strong>时间片</strong>为单位<strong>轮流为各个用户/作业服务</strong>，各个用户可通过终端与计算机进行交互。</li><li>主要优点：用户请求可以被即时响应，<strong>解决了人机交互问题</strong>。允许多个用户同时使用一台计算机，并且用户对计算机的操作相互独立，感受不到别人的存在。</li><li>主要缺点：<strong>不能优先处理一些紧急任务</strong>。操作系统对各个用户/作业都是完全公平的，循环地为每个用户/作业服务一个时间片，不区分任务的紧急性。</li></ul></li><li><p>实时操作系统</p><ul><li>主要优点：能够优先响应一些紧急任务，某些紧急任务不需时间片排队。</li><li>在实时操作系统的控制下，计算机系统接收到外部信号后及时进行处理，并且<strong>要在严格的时限内处理完事件</strong>。实时操作系统的主要特点是<strong>及时性和可靠性</strong>。</li><li>分类：<ul><li>硬实时系统：必须在绝对严格的时间内完成处理（如：导弹控制系统、自动驾驶系统）</li><li>软实时系统：能接受偶尔违反时间规定（如：12306火车订票系统）</li></ul></li></ul></li><li><p>其他几种操作系统</p><ul><li>网络操作系统：是伴随着计算机网络的发展而诞生的，能把网络中各个计算机有机地结合起来，实现数据传送等功能，<strong>实现网络中各种资源的共享和各台计算机之间的通信</strong>。（如：Windows NT 就是一种典型的网络操作系统，网站服务器就可以使用）</li><li>分布式操作系统：主要特点是<strong>分布性和并行性</strong>。系统中的各台计算机地位相同，<strong>任何工作都可以分布在这些计算机上，由它们并行、协同完成这个任务</strong>。</li><li>个人计算机操作系统：如 Windows XP、MacOS，方便个人使用。</li></ul></li></ul><h2 id="操作系统的运行机制（考点）"><a href="#操作系统的运行机制（考点）" class="headerlink" title="操作系统的运行机制（考点）"></a>操作系统的运行机制（考点）</h2><p><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part1/image-20211101132816322.png" alt="image-20211101132816322"></p><h3 id="内核程序-v-s-应用程序"><a href="#内核程序-v-s-应用程序" class="headerlink" title="内核程序 v.s. 应用程序"></a>内核程序 v.s. 应用程序</h3><ul><li>普通程序员写的程序是“应用程序”</li><li>操作系统程序员写的是“内核程序”<ul><li>由多个<strong>内核程序</strong>组成了“操作系统内核”，或简称“内核（Kernel）”</li><li><strong>内核</strong>是操作系统最重要最核心的部分，也是<strong>最接近硬件的部分</strong></li><li>其实，一个操作系统只要有内核就够了（eg：Docker -&gt; 仅需 Linux 内核）</li><li>操作系统的功能未必都在内核中，如图形化用户界面 GUI</li></ul></li></ul><h3 id="特权指令-v-s-非特权指令"><a href="#特权指令-v-s-非特权指令" class="headerlink" title="特权指令 v.s. 非特权指令"></a>特权指令 v.s. 非特权指令</h3><ul><li><p>应用程序：只能使用“非特权指令”，如：加法、减法指令等</p></li><li><p>内核程序：作为 “管理者”有时会让CPU执行一些“特权指令”，如：内存清零指令。</p></li><li><p><strong>在 CPU 设计和生产的时候就划分了特权指令和非特权指令</strong>，因此 CPU 执行一条指令前就能判断出其类型</p></li></ul><h3 id="内核态-v-s-用户态"><a href="#内核态-v-s-用户态" class="headerlink" title="内核态 v.s. 用户态"></a>内核态 v.s. 用户态</h3><ul><li>CPU 有两种状态，“<strong>内核态</strong>”和“<strong>用户态</strong>”<ul><li>处于内核态时，说明此时正在运行的是<strong>内核程序</strong>，此时<strong>可以执行特权指令</strong></li><li>处于用户态时，说明此时正在运行的是<strong>应用程序</strong>，此时<strong>只能执行非特权指令</strong></li><li>内核态=核心态=<strong>管态</strong>；用户态=<strong>目态</strong></li><li>这两种状态由 PSW 中的一个二进制位表示</li></ul></li><li>内核态、用户态的切换<ul><li><strong>内核态 -&gt; 用户态</strong>：执行一条<strong>特权指令</strong>——<strong>修改 PSW</strong> 的标志位为“用户态”，这个动作意味着操作系统将主动让出 CPU 使用权</li><li><strong>用户态 -&gt; 内核态</strong>：由“<strong>中断</strong>”引发，<strong>由硬件完成变态过程</strong>，触发中断信号意味着操作系统将强行夺回 CPU 的使用权<ul><li>除非法使用特权指令外，还有很多事件需要让操作系统夺回 CPU 使用权。它们的共性是，<strong>但凡需要操作系统介入的地方，都会触发中断信号</strong></li></ul></li></ul></li></ul><h2 id="中断和异常（考点）"><a href="#中断和异常（考点）" class="headerlink" title="中断和异常（考点）"></a>中断和异常（考点）</h2><p><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part1/image-20211101140101072.png" alt="image-20211101140101072"></p><h3 id="中断的作用"><a href="#中断的作用" class="headerlink" title="中断的作用"></a>中断的作用</h3><ul><li>中断是<strong>让操作系统内核夺回 CPU 使用权的唯一途径</strong></li><li>没有中断机制，就<strong>不可能实现操作系统</strong>，<strong>不可能实现程序并发</strong></li></ul><h3 id="中断的类型"><a href="#中断的类型" class="headerlink" title="中断的类型"></a>中断的类型</h3><ul><li>内中断（异常）<ul><li>与当前执行的指令<strong>有关</strong>，中断信号来源于 CPU <strong>内部</strong></li><li><strong>特权指令</strong>：试图在用户态下执行特权指令</li><li><strong>非法指令</strong>：如，除零运算</li><li><strong>陷入指令</strong>：应用程序主动将控制权交给操作系统，常用于请求操作系统的服务（系统调用），该指令将引发一个内部中断信号<ul><li>陷入指令 = trap 指令 = <strong>访管指令</strong></li></ul></li></ul></li><li>外中断<ul><li>与当前执行的指令<strong>无关</strong>，中断信号来源于 CPU <strong>外部</strong></li><li><strong>每一条指令执行结束时</strong>，CPU 都会例行检查是否有外中断信号</li><li><strong>时钟中断</strong>：由时钟部件发来的中断信号。用于实现多道程序并发运行</li><li><strong>I/O 中断</strong>：由输入/输出设备发来的中断信号</li></ul></li><li>中断的分类<ul><li><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part1/image-20211101135845317.png" alt="image-20211101135845317"></li><li>大多数的教材、试卷中，“中断”特指狭义的中断，即外中断。而内中断一般称为“异常”</li></ul></li></ul><h3 id="中断机制的基本原理"><a href="#中断机制的基本原理" class="headerlink" title="中断机制的基本原理"></a>中断机制的基本原理</h3><ul><li>不同的中断信号，需要用不同的中断处理程序来处理。<ul><li>当 CPU 检测到中断信号后，会根据中断信号的类型去<strong>查询中断向量表</strong>，以此来找到相应的中断处理程序在内存中的存放位置。</li></ul></li><li>中断处理程序<strong>一定是内核程序</strong>，需要运行在“内核态”</li></ul><h2 id="系统调用（考点）"><a href="#系统调用（考点）" class="headerlink" title="系统调用（考点）"></a>系统调用（考点）</h2><p><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part1/image-20211101142240743.png" alt="image-20211101142240743"></p><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><ul><li>操作系统作向上提供的服务中，主要包括<strong>命令接口</strong>和<strong>程序接口</strong>。其中，<strong>程序接口由一组系统调用组成</strong>。</li><li><strong>系统调用</strong>，是操作系统提供给应用程序（程序员）使用的接口，应用程序可以通过系统调用来请求获得操作系统内核的服务</li></ul><h3 id="系统调用-v-s-库函数"><a href="#系统调用-v-s-库函数" class="headerlink" title="系统调用 v.s. 库函数"></a>系统调用 v.s. 库函数</h3><ul><li><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part1/image-20211101140936662.png" alt="image-20211101140936662" style="zoom:80%;"></li><li>不涉及系统调用的库函数：如“取绝对值”</li><li>涉及系统调用的库函数：如“创建一个新文件”</li></ul><h3 id="系统调用的必需性"><a href="#系统调用的必需性" class="headerlink" title="系统调用的必需性"></a>系统调用的必需性</h3><ul><li>针对问题：对于互斥共享的资源，各个程序不能同时使用</li><li>解决方案：由操作系统内核对共享资源进行统一的管理，并向上提供系统调用。<ul><li>用户进程想要使用打印机这种共享资源，只能通过系统调用向操作系统内核发出请求。内核会对各个请求进行协调处理。</li></ul></li></ul><h3 id="什么功能需要系统调用"><a href="#什么功能需要系统调用" class="headerlink" title="什么功能需要系统调用"></a>什么功能需要系统调用</h3><ul><li><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part1/image-20211101141628507.png" alt="image-20211101141628507"></li><li><strong>凡是与共享资源有关的操作</strong>（如存储分配、I/O操作、文件管理等），<strong>都必须通过系统调用的方式向操作系统内核提出服务请求</strong>，由操作系统内核代为完成。</li><li>这样可以<strong>保证系统的稳定性和安全性</strong>，防止用户进行非法操作。</li></ul><h3 id="系统调用的过程"><a href="#系统调用的过程" class="headerlink" title="系统调用的过程"></a>系统调用的过程</h3><ul><li><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part1/image-20211101142044385.png" alt="image-20211101142044385"></li><li>过程：<ul><li>传递系统调用参数</li><li>执行陷入指令（用户态）</li><li>执行相应的内请求核程序处理系统调用（核心态）</li><li>返回应用程序</li></ul></li><li>注意：<ul><li><strong>陷入指令是在用户态执行的</strong>，执行陷入指令之后立即引发一个<strong>内中断</strong>，使 CPU 进入<strong>核心态</strong></li><li><strong>发出系统调用请求是在用户态</strong>，而<strong>对系统调用的相应处理在核心态下进行</strong></li></ul></li></ul><h2 id="操作系统的体系结构"><a href="#操作系统的体系结构" class="headerlink" title="操作系统的体系结构"></a>操作系统的体系结构</h2><p><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part1/image-20211101143353619.png" alt="image-20211101143353619"></p><h3 id="操作系统内核"><a href="#操作系统内核" class="headerlink" title="操作系统内核"></a>操作系统内核</h3><ul><li><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part1/image-20211101133719590.png" alt="image-20211101133719590" style="zoom:80%;"></li><li><strong>内核</strong>是计算机上配置的<strong>底层软件</strong>，是操作系统最基本、最核心的部分。</li><li>实现操作系统内核功能的那些程序就是<strong>内核程序</strong>。</li><li><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part1/image-20211101134031062.png" alt="image-20211101134031062"></li></ul><h3 id="大内核与微内核"><a href="#大内核与微内核" class="headerlink" title="大内核与微内核"></a>大内核与微内核</h3><ul><li><p>通过对内核功能的划分（是否包含对系统资源的管理），可以分为<strong>大内核/单内核/宏内核</strong>和<strong>微内核</strong></p><ul><li>典型的 大内核/宏内核/单内核 操作系统： Linux、UNIX</li><li>典型的 微内核 操作系统： Windows NT</li></ul></li><li><p>注意：</p><ul><li><p>操作系统<strong>内核功能运行在内核态</strong></p></li><li><p>操作系统<strong>非内核功能运行在用户态</strong></p></li><li><p>变态的过程是有成本的，要消耗不少时间，频繁地变态会降低系统性能</p></li></ul></li><li><p><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part1/image-20211101143313918.png" alt="image-20211101143313918"></p></li></ul><h1 id="习题课"><a href="#习题课" class="headerlink" title="习题课"></a>习题课</h1><h2 id="1-1-4"><a href="#1-1-4" class="headerlink" title="1.1.4"></a>1.1.4</h2><ol><li><p>软件分类</p><ul><li>按软件的用户群体分类<ul><li><strong>通用软件</strong>：普通大众都会使用的（如Office、迅雷）</li><li><strong>专用软件</strong>：某些领域的专业人士使用的（如AutoCAD Logic Pro）</li></ul></li><li>按照软件在计算机内的角色分类<ul><li><strong>系统软件</strong>：操作系统、数据库管理程序（DBMS）、语言处理程序（编译、汇编）、服务性程序（装入程序）、标准库程序（printf）</li><li><strong>应用软件</strong>：微信、Office</li></ul></li></ul></li><li><p>操作系统既管理软件，也管理硬件（可以从任务管理器看出）</p><ul><li>软件 vs 应用程序：<strong>软件 = 程序 + 其他相关文件</strong></li><li>eg：一个游戏软件包括程序（.exe）和其它图片（.bmp等）、音效（.wav等）等附件，那么这个程序（.exe）称作<strong>应用程序</strong>，而它与其他文件（图片、音效等）在一起合称<strong>软件</strong></li><li>操作系统管理<strong>计算机资源</strong><ul><li>软件、硬件、文件都属于计算机资源</li><li>若只给出软件、硬件，则依然不如计算机资源更全面，不正确</li></ul></li></ul></li><li><p>源代码属于文件。但是操作系统关心的是文件的结构与组织，而不是文件内容。</p></li><li><p>界面 = 接口 = Interface</p><ul><li>操作系统提供给用户程序使用的接口：系统调用</li><li>操作系统提供给用户直接使用的接口：命令接口、GUl</li></ul></li><li><p>发展历程：</p><ul><li>1950 年代早期第一个操作系统诞生（批处理操作系统）<ul><li>定义：操作系统是指控制和管理整个计算机系统的硬件和软件资源，并合理地组织调度计算机的工作和资源的分配；以提供给用户和其他软件方便的接口和环境；它是计算机系统中最基本的系统软件。 </li><li><strong>管理和控制计算机资源</strong>，更加基本</li><li>其他三个选项可以说是应用程序提供的功能</li></ul></li><li>后来才支持用户交互</li><li>1970 年代早期，第一个 GUI 诞生</li><li>1983 年互联网诞生</li></ul></li><li><p>并发和共享<strong>互为存在条件</strong>；并发和共享<strong>是操作系统的两个最基本的特征</strong>。</p></li><li><p>并发：宏观上同时，微观上交替发生。并行：微观上同时发生。</p><ul><li>并发不没有严格规定要在同一时间间隔内发生，彼此发生间隔不同也是可以的</li><li>但是其他选项更不对</li></ul></li><li><p>单处理机 = 单核 CPU。不可能并发执行多个程序</p></li><li><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part1/image-20211123205819442.png" alt="image-20211123205819442" style="zoom:80%;"></li><li><p>系统调用是操作系统为应用程序使用内核功能所提供的的接口。</p></li><li><p>请求系统服务：更为概括的描述</p><p>中止系统服务：如 Linux 中的 exit 系统调用请求中止进程</p><p>申请系统资源：如 open 系统调用，可请求打开一个文件或 IO 设备</p><p>释放系统资源：如 close 系统调用，可请求关闭一个文件或 IO 设备</p></li><li><p>系统调用，文件 I/O 需要在内核态运行。</p></li><li><p>Shell：即 Unix、Linux 的命令接口</p><p>命令解释器：解释用户在“小黑框”输入的命令，如：cd、ls 等</p><p>广义指令：即系统调用</p><p>缓存管理：对用户不可见，由操作系统负责</p></li><li><p>制约性：程序的执行因为共享资源而相互制约</p><p>间断性：一个程序的执行是走走停停的</p><p>顺序性：各个程序按顺序依次执行</p><ul><li>顺序性是单道程序设计的基本特征</li><li>自从引入多道程序设计之后，程序的执行就失去了封闭性和顺序性</li></ul><p>共享性：多道程序共享资源</p></li><li><p>OS 管理资源：后序章节会有体会</p><p>OS 管理用户程序执行：第二章，处理机管理</p><p>OS 使系统资源提高效率：各种调度算法</p><p>用来编程的程序：eclipse、IntelliJ IDEA、VS …</p></li><li><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part1/image-20211123212445393.png" alt="image-20211123212445393" style="zoom: 50%;"></li></ol><h2 id="1-2-7"><a href="#1-2-7" class="headerlink" title="1.2.7"></a>1.2.7</h2><ol><li><p>手工操作时期，纸带机是要<strong>在主机的控制之下</strong>才能读写数据，因此是<strong>用户独占全机</strong>。</p><ul><li>因此，脱机技术主要<strong>解决的独占设备问题</strong></li></ul><p>多道程序技术，则是让多个程序<strong>共享主机的资源</strong>，因此相比单道程序设计<strong>提高了单机资源利用率</strong>。</p><ul><li>因此，多道程序技术主要<strong>提高单机资源利用率</strong></li></ul><p>复习：</p><ol><li>脱机技术――脱离主机的控制，提前将作业数据输入/输出到磁带，用于缓和I/O设备与主机之间的速度矛盾。</li><li>假脱机技术――将独占设备改造为共享设备。</li><li>虚拟技术――如虚拟内存技术，可增加并发度。</li><li>交换技术――增加并发度。将在第三章学习</li></ol></li><li><p>手工 -&gt; 批处理 -&gt; 分时 -&gt; 实时 -&gt; PC</p></li><li><p>同 1.1.4 的 14 题</p></li><li><p>解析：</p><ul><li><p>手工阶段不存在操作系统，直到<strong>批处理的多道程序设计</strong>引入中断技术，操作系统才诞生。</p></li><li><p><strong>分时操作系统</strong>开始才支持人机交互。</p></li><li><p>军工领域对实时的要求很高，才产生了<strong>实时操作系统</strong>。</p></li><li><p>PC 操作系统更多在强调应用场景，而不是分时/实时。</p></li><li><p>如果需要与时俱进，则再加上分布式操作系统</p></li></ul></li><li><img src="/2021/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Part1/image-20211127125218962.png" alt="image-20211127125218962" style="zoom: 80%;"></li><li><p>单道程序系统：<strong>内存中最多只有一道作业</strong>，作业之间是串行执行的。若当前作业等待 I/O，则 CPU 闲置等待。</p><p>多道程序系统：<strong>内存中有多道作业</strong>，作业之间并发执行。若当前作业等待 I/O，则 CPU 转而处理另一道作业。</p></li><li><p>被控对象规定时间</p></li><li><p>先来先服务：早期的单道批处理系统</p><p>时间片轮转：分时操作系统</p><p>抢占式的优先级高者优先：实时操作系统</p><p>高响应比优先：常用于多道程序系统中的作业调度</p></li><li><p>实时操作系统的主要特点：<strong>及时性、可靠性</strong>。</p><p><strong>资源利用率高</strong>是实时操作系统需要避免的。</p></li><li><p>要求实时：交易、机床硬件、军工</p></li><li></li></ol>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>计算机组成原理-完结目录</title>
      <link href="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E5%AE%8C%E7%BB%93%E7%9B%AE%E5%BD%95/"/>
      <url>/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E5%AE%8C%E7%BB%93%E7%9B%AE%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<h1 id="计算机组成原理-完结目录"><a href="#计算机组成原理-完结目录" class="headerlink" title="计算机组成原理-完结目录"></a>计算机组成原理-完结目录</h1><p>教程视频传送门：</p><ol><li><a href="https://www.bilibili.com/video/BV1BE411D7ii">王道计算机考研 计算机组成原理</a></li></ol><p>推荐资源：</p><ol><li>王道配套书</li></ol><p>不能只看视频，==要过一遍书，做一遍题==！</p><table><thead><tr><th align="center"><a href="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part1/">计算机组成原理-Part1——计算机系统概述</a></th></tr></thead><tbody><tr><td align="center"><strong><a href="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part2/">计算机组成原理-Part2——数据的表示和运算</a></strong></td></tr><tr><td align="center"><strong><a href="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part3/">计算机组成原理-Part3——存储系统</a></strong></td></tr><tr><td align="center"><strong><a href="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part4/">计算机组成原理-Part4——指令系统</a></strong></td></tr><tr><td align="center"><strong><a href="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part5/">计算机组成原理-Part5——中央处理器</a></strong></td></tr><tr><td align="center"><strong><a href="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part6/">计算机组成原理-Part6——总线</a></strong></td></tr><tr><td align="center"><strong><a href="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part7/">计算机组成原理-Part7——I/O 系统</a></strong></td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 计算机组成原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 408 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机组成原理-Part7</title>
      <link href="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part7/"/>
      <url>/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part7/</url>
      
        <content type="html"><![CDATA[<h1 id="计算机组成原理-Part7——I-O-系统"><a href="#计算机组成原理-Part7——I-O-系统" class="headerlink" title="计算机组成原理-Part7——I/O 系统"></a>计算机组成原理-Part7——I/O 系统</h1><p>[TOC]</p><h2 id="I-O-系统基本概念"><a href="#I-O-系统基本概念" class="headerlink" title="I/O 系统基本概念"></a>I/O 系统基本概念</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><ul><li>I/O 设备：可以将数据输入到计算机，或者可以接收计算机输出数据的外部设备，包括<strong>输入设备、输出设备、外存设备</strong>。</li><li>I/O 接口：又称 I/O 控制器（I/O Controller）、设备控制器，负责协调主机与外部设备之间的数据传输<ul><li>I/O 控制器就是一块芯片，常被集成在主板上</li><li>现在的 I/O 接口（芯片）也会被集成在南桥芯片内部</li></ul></li><li>数据流：键盘 -&gt; I/O 接口的数据寄存器 -&gt; 数据总线 -&gt; CPU某寄存器 -&gt; 主存（变量 i 的对应位置）</li></ul><h3 id="控制方式"><a href="#控制方式" class="headerlink" title="控制方式"></a>控制方式</h3><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part7/image-20211028202903178.png" alt="image-20211028202903178" style="zoom:80%;"><ul><li><strong>程序查询方式</strong>：CPU 不断轮询检查 I/O 控制器中的“状态寄存器”，<strong>直到检测到状态为“已完成”之后</strong>，才从数据寄存器取出输入数据（如程序中的输入等待）</li><li><strong>程序中断方式</strong>：等待键盘 I/O 时 CPU 可以先去执行其他程序，<strong>键盘 I/O 完成后 I/O 控制器向 CPU 发出中断请求，CPU 响应中断请求</strong>，并取走输入数据</li><li><strong>DMA 控制方式</strong>：主存与高速 I/O 设备之间有一条直接数据通路（DMA总线）。CPU 向 DMA 接口发出“读/写”命令，并指明主存地址、磁盘地址、读写数据量等参数。<ul><li>DMA 控制器自动控制磁盘与主存的数据读写，<strong>DMA 控制器与主存每次传送1个字</strong>，<strong>每当完成一整块数据读写</strong>（如 1KB 为一整块） ，才向 CPU 发出一次中断请求。</li><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part7/image-20211027224155076.png" alt="image-20211027224155076" style="zoom:80%;"></li></ul></li><li><strong>通道控制方式</strong>：相比 DMA 控制方式，不仅不与高速外设进行直接相连，包括低速外设都交由通道来管理，且通道程序保存在内存中。<ul><li>针对场景：I/O 密集型场景</li><li>通道：可以理解为是“弱鸡版的 CPU”。通道可以识别并执行一系列通道指令，通道指令种类、功能通常比较单一</li><li>步骤：<ol><li>CPU 向通道发出 I/O 指令。指明通道程序在内存中的位置，并指明要操作的是哪个 I/O 设备。CPU 就可以去做其他事情</li><li>通道执行内存中的通道程序，控制 I/O 设备完成一系列任务</li><li>通道执行完规定的任务后，向 CPU 发出中断请求，之后 CPU 对中断进行处理</li></ol></li><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part7/image-20211027224229248.png" alt="image-20211027224229248" style="zoom:80%;"></li></ul></li></ul><h3 id="系统基本组成"><a href="#系统基本组成" class="headerlink" title="系统基本组成"></a>系统基本组成</h3><ul><li>一般来说，I/O 系统由 I/O 软件和 I/O 硬件两部分构成。</li><li>I/O 硬件：包括外部<strong>设备、I/O 接口 、I/O 总线</strong>等。</li><li>I/O 软件：包括<strong>驱动程序、用户程序、管理程序、升级补丁</strong>等。通常采用 <strong>I/O 指令</strong>和<strong>通道指令</strong>实现信息交换。<ul><li>I/O 指令：CPU 指令的一部分<ul><li>操作码（CPU 对 IO 接口做什么）+ 命令码（IO 接口对设备做什么）+ 设备码（对哪个设备进行操作）</li></ul></li><li>通道指令：通道能识别的指令（提前编制好放在主存中）<ul><li>在含有通道的计算机中，CPU 执行 I/O 指令对通道发出命令，由通道执行一系列通道指令，代替 CPU 对 I/O 设备进行管理</li></ul></li></ul></li></ul><h2 id="外部设备"><a href="#外部设备" class="headerlink" title="外部设备"></a>外部设备</h2><h3 id="总览"><a href="#总览" class="headerlink" title="总览"></a>总览</h3><ul><li>外部设备<ul><li>输入设备<ul><li>用于向计算机系统输入命令和文本、数据等信息的部件。</li><li>键盘、鼠标</li></ul></li><li>输出设备<ul><li>用于将计算机系统中的信息输出到计算机外部进行显示、交换等的部件。</li><li>显示器、打印机</li></ul></li><li>外存储器（考点：磁盘存取时间的计算）<ul><li>指除计算机内存及CPU缓存等以外的存储器。</li><li>磁盘存储器、磁盘阵列、光盘存储器、SSD</li></ul></li></ul></li></ul><h3 id="显示器"><a href="#显示器" class="headerlink" title="显示器"></a>显示器</h3><h4 id="性能标准（考点：显存的计算）"><a href="#性能标准（考点：显存的计算）" class="headerlink" title="性能标准（考点：显存的计算）"></a>性能标准（考点：显存的计算）</h4><ul><li>屏幕大小：以对角线长度表示，常用的有 12～29 英寸等。</li><li>分辨率：所能表示的像素个数，<strong>宽、高的像素的乘积</strong>，如1920×1280。</li><li>灰度级：显示的像素点的亮暗差别，典型的有 8 位（256级）、16 位等。<strong>n 位可以表示 2^n^ 种不同的亮度或颜色</strong>。</li><li>刷新：单位时间内扫描整个屏幕内容的次数，通常显示器刷新频率在 60～120 Hz。</li><li>显示存储器（VRAM）：<ul><li>也称刷新存储器，<strong>显存</strong>。由图像分辨率和灰度级决定，分辨率越高，灰度级越多，刷新存储器容量越大。</li><li>显存除了作为当前显示帧的缓存，还会用于保存用于渲染的图像数据，如 3D 模型。</li><li>集成显卡计算机中，通常分配一片内存作为显存</li><li><strong>VRAM 容量 = 分辨率 × 灰度级位数</strong><ul><li>例：1440 × 900 × 3 B ≈ 3.7MB（最低工作要求，能够存储一帧图像的信息）</li></ul></li><li><strong>VRAM 带宽 = 分辨率 × 灰度级位数 × 帧频</strong><ul><li>例：3.7 × 60 Hz = 222MB/s</li></ul></li></ul></li><li>显示器分类<ul><li>阴极射线管（CRT）显示器</li><li>液晶（LCD）显示器</li><li>发光二极管（LED）显示器</li></ul></li></ul><h4 id="阴极射线管显示器（考点：字符点阵的存储）"><a href="#阴极射线管显示器（考点：字符点阵的存储）" class="headerlink" title="阴极射线管显示器（考点：字符点阵的存储）"></a>阴极射线管显示器（考点：字符点阵的存储）</h4><p>按显示信息内容不同可分为</p><ul><li><strong>字符显示器</strong>（计算器）</li><li>图形显示器（特别用途设备）<ul><li>优点：分辨率高且显示的曲线平滑。</li><li>缺点：当显示复杂图形时，会有闪烁感。</li></ul></li><li>图像显示器（用户友好界面）</li></ul><p>字符显示器：</p><ul><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part7/image-20211028115857070.png" alt="image-20211028115857070"></li><li>显示字符的方法以点阵为基础。<ul><li><strong>点阵是指由 m×n 个点组成的阵列</strong>。</li><li>点阵的多少取决于显示<strong>字符的质量</strong>和<strong>字符窗口</strong>的大小。<ul><li><strong>字符窗口是指每个字符在屏幕上所占的点数</strong>，包括字符显示点阵和字符间隔。</li></ul></li></ul></li><li>对应于每个字符窗口，所需显示<strong>字符的 ASCII 代码被存放在视频存储器 VRAM</strong> 中，以备刷新。</li><li>将<strong>点阵存入由 ROM 构成的字符发生器</strong>中，在 CRT 进行光栅扫描的过程中，从字符发生器中依次读出某个字符的点阵，按照点阵中 0 和 1 代码不同控制扫描电子束的开或关，从而在屏幕上显示出字符。<ul><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part7/image-20211028115930559.png" alt="image-20211028115930559" style="zoom:80%;"></li><li>按扫描方式不同可分为<ul><li>光栅扫描显示器</li><li>随机扫描显示器</li></ul></li></ul></li></ul><h3 id="打印机"><a href="#打印机" class="headerlink" title="打印机"></a>打印机</h3><ul><li>按印字原理不同可分为<ul><li><strong>击打式打印机</strong>：利用机械动作使印字机构与色带和纸相撞而打印字符<ul><li>优：设备成本低 、印字质量好、防伪性好</li><li>缺：噪声大、速度慢</li></ul></li><li><strong>非击打式打印机</strong>：采用电、磁、光、喷墨等物理、化学方法来印刷字符<ul><li>优：速度快、噪声小</li><li>缺：成本高</li></ul></li></ul></li><li>按打印机工作方式不同可分为<ul><li><strong>串行打印机</strong>：逐字打印、速度慢</li><li><strong>行式打印机</strong>：逐行打印、速度快</li></ul></li><li>按工作方式可分为<ul><li><strong>针式打印机</strong>：<ul><li>原理：在联机状态下，主机发出打印命令，经接口、检测和控制电路，间歇驱动纵向送纸和打印头横向移动，同时驱动打印机间歇冲击色带，在纸上打印出所需内容。</li><li>特点：擅长多层复写打印，实现各种票据或蜡纸等的打印。工作原理简单，造价低廉，耗材（色带）便宜，但打印分辨率和打印速度不够高。</li></ul></li><li><strong>喷墨式打印机</strong>：<ul><li>原理：带电的喷墨雾点经过电极偏转后，直接在纸上形成所需字形。彩色喷墨打印机基于三基色原理，即分别喷射 3 种颜色墨滴，按一定的比例混合出所要求的颜色。</li><li>特点：打印噪声小，可实现高质量彩色打印；通常打印速度比针式打印机快；但防水性差，高质量打印需要专用打印纸。</li></ul></li><li><strong>激光打印机</strong>：<ul><li>原理：计算机输出的二进制信息，经过调制后的激光束扫描，在感光鼓上形成潜像，再经过显影、转印和定影，便在纸上得到所需的字符或图像。</li><li>特点：打印质量高、速度快、噪声小、处理能力强；但耗材多、价格较贵、不能复写打印多份，且对纸张的要求高。感光鼓（也称为硒鼓）是激光打印机的核心部件。</li></ul></li></ul></li></ul><h3 id="外部存储器"><a href="#外部存储器" class="headerlink" title="外部存储器"></a>外部存储器</h3><h4 id="磁表面存储器简介"><a href="#磁表面存储器简介" class="headerlink" title="磁表面存储器简介"></a>磁表面存储器简介</h4><ul><li>磁表面存储器，是指把<strong>磁性材料</strong>薄薄地涂在金属铝或塑料表面上作为载磁体来存储信息。磁盘存储器、磁带存储器和磁鼓存储器均属于磁表面存储器。</li><li>磁表面存储器的优点：<ul><li>存储容量大，位价格低； </li><li>记录介质可以重复使用；</li><li>记录信息可以长期保存而不丢失，甚至可以脱机存档； </li><li>非破坏性读出，读出时不需要再生。</li></ul></li><li>磁表面存储器的缺点：<ul><li>存取速度慢；</li><li>机械结构复杂；</li><li>对工作环境要求较高。</li></ul></li><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part7/image-20211028122201199.png" alt="image-20211028122201199"></li><li>原理：当磁头和磁性记录介质有相对运动时，通过电磁转换（/切割磁感线）完成读/写操作。</li><li>编码方法：按某种方案，把一串二进制信息变换成存储介质磁层中一个磁化翻转状态的序列。</li><li>磁记录方式：通常采用调频制（FM）和改进型调频制（MFM）的记录方式。</li></ul><h4 id="磁盘设备"><a href="#磁盘设备" class="headerlink" title="磁盘设备"></a>磁盘设备</h4><h5 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h5><ul><li>硬盘存储器<ul><li>硬盘存储器由磁盘驱动器、磁盘控制器和盘片组成。</li><li>磁盘驱动器：核心部件是磁头组件（磁头移动臂）和盘片组件（驱动轴盘片），温彻斯特盘是一种可移动头固定盘片的硬盘存储器。</li><li>磁盘控制器：是硬盘存储器和主机的接口，主流的标准有 IDE、SCSI、SATA 等。</li></ul></li><li>存储区域：<ul><li><strong>一块硬盘</strong>含有<strong>若干个盘片</strong>；（即有好几个盘）</li><li><strong>每个盘片</strong>可以有 1 或 2 面<strong>盘面</strong>；（即磁盘的正反面都可以利用，每个盘面对应 1 个磁头）</li><li><strong>每个记录面</strong>划分为<strong>若干条磁道</strong>；（<strong>所有记录面上的同一条磁道组成一个柱面</strong>）</li><li>而<strong>每条磁道</strong>又划分为<strong>若干个扇区</strong>；（切蛋糕）</li><li><strong>扇区（也称块）是磁盘读写的最小单位</strong>，也就是说磁盘<strong>按块存取</strong>。</li><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part7/image-20211028124407864.png" alt="image-20211028124407864"></li></ul></li><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part7/image-20211028124733827.png" alt="image-20211028124733827"></li></ul><h5 id="性能指标"><a href="#性能指标" class="headerlink" title="性能指标"></a>性能指标</h5><ul><li>磁盘的容量：一个磁盘所能存储的字节总数称为磁盘容量。磁盘容量有非格式化容量和格式化容量之分。<ul><li>非格式化容量：指磁记录表面理论氪用的磁化单元总数。</li><li>格式化容量：指按照某种特定的记录格式后所能利用、存储的信息总量。</li></ul></li><li>记录密度：记录密度是指盘片单位面积上记录的二进制的信息量，通常以道密度、位密度和面密度表示。<ul><li>道密度：沿磁盘半径方向单位长度上的磁道数；</li><li>位密度：一条磁道单位长度上能记录的二进制代码位数；</li><li>面密度：位密度和道密度的乘积。</li><li>注意：磁盘所有磁道记录的信息量一定是相等的，并不是圆越大信息越多，故<strong>越内侧的磁道位密度越大</strong>。</li></ul></li><li>平均存取时间：<ul><li><code>平均存取时间 = 磁盘控制器延迟（可能会有）+ 寻道时间（磁头移动到目的磁道）+ 旋转延迟时间（磁头定位到所在扇区）+ 传输时间（传输数据所花费的时间）</code></li><li>一般寻道时间会在题中给出，旋转延迟时间可以按数学期望（即转半圈）来计算，同时通过转速也可以确定转一个扇区的时间</li><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part7/image-20211028130946542.png" alt="image-20211028130946542" style="zoom:80%;"></li></ul></li><li>数据传输率：磁盘存储器在单位时间内向主机传送数据的字节数，称为数据传输率。<ul><li>假设磁盘转数为 r（转/秒），每条磁道容量为 N 个字节，则数据传输率为 D<del>r</del>=r×N</li></ul></li></ul><h5 id="磁盘地址"><a href="#磁盘地址" class="headerlink" title="磁盘地址"></a>磁盘地址</h5><ul><li>主机向磁盘控制器发送寻址信息，包括<ul><li>驱动器号：一台电脑可能有多个硬盘</li><li>柱面（磁道）号：移动磁头臂（寻道）</li><li>盘面号：激活某个磁头</li><li>扇区号：通过旋转将特定扇区划过磁头下方</li></ul></li><li>例：若系统中有 4 个驱动器，每个驱动器带一个磁盘，每个磁盘 256 个磁道、16 个盘面，每个盘面划分为 16个扇区，则每个扇区地址要 18 位二进制代码<ul><li>驱动器号（2bit）+ 柱面（磁道）号（8bit）+ 盘面号（4bit）+ 扇区号（4bit） </li></ul></li></ul><h5 id="硬盘的工作过程"><a href="#硬盘的工作过程" class="headerlink" title="硬盘的工作过程"></a>硬盘的工作过程</h5><ul><li>硬盘的主要操作是<strong>寻址、读盘、写盘</strong>。每个操作都对应一个控制字，硬盘工作时，第一步是取控制字，第二步是执行控制字。</li><li>硬盘属于机械式部件，其读写操作是串行的，不可能在同一时刻既读又写，也不可能在同一时刻读两组数据或写两组数据。</li><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part7/image-20211028150614567.png" alt="image-20211028150614567" style="zoom:80%;"></li></ul><h4 id="磁盘阵列"><a href="#磁盘阵列" class="headerlink" title="磁盘阵列"></a>磁盘阵列</h4><ul><li>RAID（ Redundant Array of Inexpensive Disks，廉价冗余磁盘阵列）是将多个独立的物理磁盘组成一个独立的逻辑盘，数据在多个物理盘上分割交叉存储、并行访问，具有更好的存储性能、可靠性和安全性。</li><li>RAID 有 RAID1～RAID5 的几种方案，无论何时有磁盘损坏，都可以随时拔出受损的磁盘再插入好的磁盘，而数据不会损坏。（raid 数越高，冗余越少、越稳定）<ul><li>RAID0：无冗余和无校验的磁盘阵列。（条带化，提高存取速度，没有容错能力）</li><li>RAID1：镜像磁盘阵列。（镜像磁盘互为备份，容量减少一半）</li><li>RAID2：采用纠错的海明码的磁盘阵列。（开始通过数据校验提高容错能力）</li><li>RAID3：位交叉奇偶校验的磁盘阵列。</li><li>RAID4：块交叉奇偶校验的磁盘阵列。</li><li>RAID5：无独立校验的奇偶校验磁盘阵列。</li></ul></li><li>RAID 通过同时使用多个磁盘，提高传输率；通过在多个磁盘上并行存取来大幅提高存储系统的数据吞吐量；通过镜像功能，提高安全可靠性；通过数据校验，提供容错能力。</li></ul><h4 id="光盘存储器"><a href="#光盘存储器" class="headerlink" title="光盘存储器"></a>光盘存储器</h4><ul><li>利用光学原理读/写信息的存储装置，采用聚焦激光束对盘式介质以非接触的方式记录信息。</li><li>光盘的类型：<ul><li>CD-ROM：只读型光盘，只能读出其中内容，不能写入或修改。</li><li>CD-R：只可写入一次信息，之后不可修改。</li><li>CD-RW：可读可写光盘，可以重复读写。</li><li>DVD-ROM：高容量的 CD-ROM，DVD 表示通用数字化多功能光盘。</li></ul></li></ul><h4 id="固态硬盘"><a href="#固态硬盘" class="headerlink" title="固态硬盘"></a>固态硬盘</h4><ul><li>由 Flash Memory 组成，以及其他硬件和软件的支持。</li><li>闪存（Flash Memory）是在 E2PROM 的基础上发展起来的，<strong>本质上是只读存储器</strong>。</li></ul><h2 id="I-O-接口"><a href="#I-O-接口" class="headerlink" title="I/O 接口"></a>I/O 接口</h2><h3 id="主要功能"><a href="#主要功能" class="headerlink" title="主要功能"></a>主要功能</h3><ul><li><strong>数据缓冲</strong>：通过<strong>数据缓冲寄存器</strong>（DBR）达到主机和外设工作速度的匹配</li><li><strong>错误或状态监测</strong>：通过<strong>状态寄存器</strong>反馈设备的各种错误、状态信息，供 CPU 查用</li><li><strong>控制和定时</strong>：接收从控制总线发来的控制信号、时钟信号</li><li><strong>数据格式转换</strong>：“串-并”、“并-串”等格式转换</li><li><strong>与主机和设备通信</strong>：实现“主机—I/O接口—I/O设备”之间的通信</li></ul><h3 id="结构与原理"><a href="#结构与原理" class="headerlink" title="结构与原理"></a>结构与原理</h3><ul><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part7/image-20211028162350702.png" alt="image-20211028162350702" style="zoom: 67%;"><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part7/image-20211028202711609.png" alt="image-20211028202711609" style="zoom:67%;"></li><li><strong>内部接口</strong>：内部接口与系统总线相连，实质上是与内存、CPU 相连。</li><li><strong>外部接口</strong>：外部接口通过接口电缆与外设相连。外部接口的数据传输可能是串行方式，因此 I/O 接口需具有串/并转换功能。</li><li><strong>工作原理</strong>：<ul><li>发命令：发送<strong>命令字</strong>到 I/O 控制寄存器，向设备发送命令（需要驱动程序的协助）</li><li>读状态：从状态寄存器读取<strong>状态字</strong>，获得设备或 I/O 控制器的状态信息</li><li>读/写数据：从数据缓冲寄存器发送或读取数据，完成主机与外设的数据交换</li></ul></li><li>控制寄存器、状态寄存器在<strong>使用时间上错开</strong>，因此有的 I/O 接口中可将二者合二为一</li><li><strong>IO 控制器中的一个个寄存器也称为一个个 I/O 端口</strong></li></ul><h3 id="I-O-端口"><a href="#I-O-端口" class="headerlink" title="I/O 端口"></a>I/O 端口</h3><ul><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part7/image-20211028164339128.png" alt="image-20211028164339128" style="zoom: 67%;"><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part7/image-20211028163713330.png" alt="image-20211028163713330" style="zoom:80%;"></li><li><strong>统一编址</strong>：靠不同的<strong>地址码</strong>区分内存和 I/O 设备。<strong>访存类的指令都</strong>可以访问 I/O 端口。又称<strong>存储器映射方式</strong>。<ul><li>优点：1. 不需要专门的输入/输出指令，所有访存指令可直接访问端口，程序设计灵活性高；2. 端口有较大的编址空间；3. 读写控制逻辑电路简单</li><li>缺点：1. 端口占用了主存地址空间，使主存地址空间变小；2. 外设寻址时间长（地址位数多，地址译码速度慢）</li></ul></li><li><strong>独立编址</strong>：靠不同的<strong>指令</strong>区分内存和 I/O 设备。<strong>只能用专门的 I/O 指令</strong>可以访问 I/O 端口。<ul><li>优点：1. 使用专用 I/O 指令，程序编制清晰；2. I/O 端口地址位数少，<strong>地址译码速度快</strong>；3. I/O 端口的地址不占用主存地址空间</li><li>缺点：1. I/O 指令类型少，一般只能对端口进行传送操作；2. <strong>程序设计灵活性差</strong>；3. 需要 CPU 提供存储器读/写、I/O 设备读/写两组控制信号，增加了控制逻辑电路的复杂性</li></ul></li></ul><h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><ul><li>按数据传送方式可分为<ul><li><strong>并行接口</strong>：一个字节或一个字所有位同时传送。</li><li><strong>串行接口</strong>：一位一位地传送。</li><li>这里指的是<strong>外设和接口一侧</strong>的传送方式，为了传输到主机和接口一侧，接口要完成数据格式转换。</li></ul></li><li>按主机访问I/O设备的控制方式可分为<ul><li>程序查询接口</li><li>中断接口</li><li>DMA 接口</li></ul></li><li>按功能选择的灵活性可分为<ul><li>可编程接口</li><li>不可编程接口</li></ul></li></ul><h2 id="I-O-方式"><a href="#I-O-方式" class="headerlink" title="I/O 方式"></a>I/O 方式</h2><h3 id="程序查询方式"><a href="#程序查询方式" class="headerlink" title="程序查询方式"></a>程序查询方式</h3><ul><li>优点：接口<strong>设计简单</strong>、设备量少。</li><li>缺点：CPU 在信息传送过程中要<strong>花费很多时间用于查询和等待</strong>，而且在一段时间内只能和一台外设交换信息，效率大大降低。</li><li>例题<ul><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part7/image-20211028211418243.png" alt="image-20211028211418243"></li></ul></li><li><strong>独占查询</strong>：CPU 100%的时间都在查询I/O状态，完全串行</li><li><strong>定时查询</strong>：在保证数据不丢失的情况下，每隔一段时间 CPU 就查询一次 I/O 状态。查询的间隔内 CPU 可以执行其他程序</li></ul><h3 id="中断系统"><a href="#中断系统" class="headerlink" title="中断系统"></a>中断系统</h3><h4 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h4><ol><li>中断请求</li></ol><ul><li>中断源向 CPU 发送中断请求信号。</li></ul><ol start="2"><li>中断响应</li></ol><ul><li><strong>中断请求标记</strong>：<ul><li>为了区分不同的中断源，中断系统需对每个中断源设置<strong>中断请求标记触发器 INTR</strong>，当其状态为“1”时，表示中断源有请求。</li><li>这些触发器可组成<strong>中断请求标记寄存器</strong>，该寄存器可集中在CPU中，也可分散在各个中断源中。</li><li>对于<strong>外中断</strong>，CPU <strong>响应中断的时间</strong>是在每条<strong>指令执行阶段的结束前</strong>。</li><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part7/image-20211029131814925.png" alt="image-20211029131814925" style="zoom:80%;"></li></ul></li><li><strong>响应中断的条件</strong>：<ol><li>中断源有中断请求。</li><li>一条指令执行完毕，且没有更紧迫的任务。</li><li>允许中断：当前 PSW 的 IF（Interrupt Flag）为真<ul><li>IF=1 表示开中断（允许中断）；IF=0 表示关中断（不允许中断）</li><li>关中断的作用：实现<strong>原子操作</strong>（必须一次性做完的操作）</li><li>除非是不得不响应的非屏蔽中断（如掉电）</li></ul></li></ol></li><li><strong>中断判优</strong>：多个中断源同时提出请求时通过中断判优逻辑响应一个中断源。<ul><li>中断判优既可以用硬件实现，也可用软件实现：<ul><li>硬件实现是通过<strong>硬件排队器</strong>实现的，它既可以设置在 CPU 中，也可以分散在各个中断源中；</li><li>软件实现是通过<strong>查询程序</strong>实现的。（相比硬件更慢，通常使用硬件排队器）</li></ul></li><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part7/image-20211029132629325.png" alt="image-20211029132629325"></li><li><strong>优先级设置</strong>：<ol><li>硬件故障中断属于最高级，其次是软件中断；</li><li>非屏蔽中断优于可屏蔽中断；</li><li>DMA 请求优于 I/O 设备传送的中断请求</li><li>高速设备优于低速设备；</li><li>输入设备优于输出设备；</li><li>实时设备优于普通设备。</li></ol></li></ul></li></ul><ol start="3"><li>中断处理</li></ol><ul><li><strong>中断隐指令</strong>：CPU 在检测到中断请求时自动完成的一系列动作<ul><li><strong>关中断</strong>。为了在保护现场期间不被新的中断打断，必须关中断，从而保证被中断的程序在中断服务程序执行完毕之后能接着正确地执行下去。</li><li><strong>保存断点</strong>。为了保证在中断服务程序执行完毕后能正确地返回到原来的程序，必须将原来程序的断点（即程序计数器（PC）的内容）保存起来。可以存入堆栈或指定单元。</li><li><strong>引出中断服务程序</strong>。引出中断服务程序的实质就是取出中断服务程序的入口地址并传送给程序计数器（PC）。<ul><li>软件向量法</li><li>硬件向量法<ul><li>由<strong>硬件</strong>产生指向<strong>中断向量</strong>的<strong>向量地址</strong></li><li><strong>中断向量</strong>指向<strong>中断服务程序</strong>的<strong>入口地址</strong></li><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part7/image-20211029204003689.png" alt="image-20211029204003689" style="zoom:80%;"></li></ul></li></ul></li><li>以及其他任务……</li></ul></li><li><strong>中断服务程序</strong>。<ul><li><strong>保护现场</strong>：保存通用寄存器和状态寄存器的内容（eg：保存ACC寄存器的值），以便返回原程序后可以恢复 CPU 环境。可使用堆栈，也可以使用特定存储单元。</li><li><strong>中断服务</strong>（设备服务）：主体部分，如通过程序控制需打印的字符代码送入打印机的缓冲存储器中（eg：中断服务的过程中有可能修改 ACC 寄存器的值）</li><li><strong>恢复现场</strong>：通过出栈指令或取数指令把之前保存的信息送回寄存器中（eg：把原程序算到一般的 ACC 值恢复原样）</li><li><strong>中断返回</strong>：通过中断返回指令回到原程序断点处。</li></ul></li></ul><h4 id="多重中断"><a href="#多重中断" class="headerlink" title="多重中断"></a>多重中断</h4><ul><li><p><strong>单重中断</strong>：执行中断服务程序时不响应新的中断请求。</p><ul><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part7/image-20211029205105146.png" alt="image-20211029205105146" style="zoom: 67%;"></li></ul></li><li><p><strong>多重中断</strong>：又称<strong>中断嵌套</strong>，执行中断服务程序时可响应新的中断请求。</p><ul><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part7/image-20211029210138245.png" alt="image-20211029210138245" style="zoom:67%;"><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part7/image-20211029205642997.png" alt="image-20211029205642997"></li></ul></li><li><p>中断屏蔽技术：</p><ul><li><p>CPU 要具备多重中断的功能，须满足下列条件（主要用于多重中断）</p><ul><li>在中断服务程序中提前设置开中断指令。</li><li>优先级别高的中断源有权中断优先级别低的中断源。</li></ul></li><li><p>屏蔽字设置的规律：</p><ol><li><p>一般用“1”表示屏蔽，“0”表示正常申请。</p></li><li><p>每个中断源对应一个屏蔽字（在处理该中断源的中断服务程序时，屏蔽寄存器中的内容为该中断源对应的屏蔽字）。</p></li><li><p>屏蔽字中“1”越多，优先级越高。每个屏蔽字中至少有一个“1”（至少要能屏蔽自身的中断）。</p></li></ol></li><li><p>例题：</p><ul><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part7/image-20211029221003756.png" alt="image-20211029221003756"></li></ul></li></ul></li></ul><h3 id="程序中断方式"><a href="#程序中断方式" class="headerlink" title="程序中断方式"></a>程序中断方式</h3><ul><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part7/image-20211029220829035.png" alt="image-20211029220829035"></li><li>例题：<ul><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part7/image-20211029221803157.png" alt="image-20211029221803157"></li></ul></li></ul><h3 id="DMA-方式"><a href="#DMA-方式" class="headerlink" title="DMA 方式"></a>DMA 方式</h3><h4 id="DMA-传送过程"><a href="#DMA-传送过程" class="headerlink" title="DMA 传送过程"></a>DMA 传送过程</h4><ul><li><p><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part7/image-20211029232153701.png" alt="image-20211029232153701"></p></li><li><p>DMA 控制器工作流程：</p><ul><li>CPU 向 DMA 控制器指明要<strong>输入还是输出</strong>；要传送<strong>多少数据</strong>；数据在<strong>主存、外设中的地址</strong>。</li><li>接受外设发出的 DMA 请求（外设传送一个字的请求），并向 CPU 发出<strong>总线请求</strong>。</li><li>CPU 响应此总线请求，发出总线响应信号，接管总线控制权，进入 DMA 操作周期。</li><li>确定传送数据的<strong>主存单元地址及长度</strong>，并能自动修改<strong>主存地址计数</strong>和<strong>传送长度计数</strong>。</li><li>规定数据在主存和外设间的<strong>传送方向</strong>，发出读写等控制信号，执行数据传送操作。</li><li>向 CPU 报告 DMA 操作的结束。</li></ul></li><li><p>DMA 组成：</p><ul><li>主存地址计数器：简称 AR，存放要交换数据的主存地址。</li><li>传送长度计数器：简称 WC，用来记录传送数据的长度，计数溢出时，数据即传送完毕，自动发中断请求信号。</li><li>数据缓冲寄存器：用于暂存每次传送的数据。</li><li>DMA 请求触发器：每当 I/O 设备准备好数据后给出一个控制信号，使 DMA 请求触发器置位。</li><li>控制/状态逻辑：由控制和时序电路及状态标志组成，用于指定传送方向，修改传送参数，并对DMA请求信号和CPU响应信号进行协调和同步。</li><li>中断机构：当一个数据块传送完毕后触发中断机构，向CPU提出中断请求。</li></ul></li><li><p>注：在 DMA 传送过程中，DMA 控制器将接管 CPU 的地址总线、数据总线和控制总线，CPU 的主存控制信号被禁止使用。而当 DMA 传送结束后，将恢复 CPU 的一切权利并开始执行其操作。</p></li><li><p>CPU 和 DMA 控制器访问主存可能产生冲突</p><ul><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part7/image-20211030223325881.png" alt="image-20211030223325881"></li></ul></li></ul><h4 id="DMA-传送方式"><a href="#DMA-传送方式" class="headerlink" title="DMA 传送方式"></a>DMA 传送方式</h4><ul><li>主存和 DMA 控制器之间有一条数据通路，因此主存和 I/O 设备之间交换信息时，不通过 CPU。但当 I/O 设备和 CPU 同时访问主存时，可能发生冲突，为了有效地使用主存，DMA 控制器与 CPU 通常采用以下 3 种方法使用主存。<ol><li>停止 CPU 访问主存<ul><li>优点：控制简单</li><li>缺点：CPU 处于不工作状态或保持状态未充分发挥 CPU 对主存的利用率</li><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part7/image-20211031092120253.png" alt="image-20211031092120253"></li></ul></li><li>DMA 与 CPU 交替访存<ul><li>一个 CPU 周期，分为 C1 和 C2 两个周期。C1 专供 DMA 访存，C2 专供 CPU 访存</li><li>优点：不需要总线使用权的申请、建立和归还过程</li><li>缺点：硬件逻辑更为复杂</li><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part7/image-20211031092135200.png" alt="image-20211031092135200"></li></ul></li><li>周期挪用（周期窃取）<ul><li>周期指<strong>存取周期</strong>。</li><li>DMA 访问主存有三种可能：<ul><li>CPU 此时不访存（不冲突）</li><li>CPU 正在访存（存取周期结束让出总线）</li><li>CPU 与 DMA 同时请求访存（I/O 访存优先）</li></ul></li><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part7/image-20211031092208256.png" alt="image-20211031092208256"></li></ul></li></ol></li></ul><h4 id="DMA-方式的特点"><a href="#DMA-方式的特点" class="headerlink" title="DMA 方式的特点"></a>DMA 方式的特点</h4><ul><li>主存和 DMA 接口之间有一条直接数据通路。 由于 DMA 方式传送数据不需要经过 CPU，因此不必中断现行程序，<strong>I/O 与主机并行工作，程序和传送并行工作</strong>。</li><li>DMA 方式具有下列特点：<ul><li>它使主存与 CPU 的固定联系脱钩，主存既可被 CPU 访问，又可被外设访问。 </li><li>在数据块传送时，主存地址的确定、传送数据的计数等都由硬件电路直接实现。</li><li>主存中要开辟专用缓冲区，及时供给和接收外设的数据。</li><li>DMA 传送速度快，CPU 和外设并行工作，提高了系统效率。</li><li>DMA 在传送开始前要通过程序进行预处理，结束后要通过中断方式进行后处理。</li></ul></li></ul><table><thead><tr><th></th><th>中断</th><th>DMA</th></tr></thead><tbody><tr><td>数据传输</td><td>程序控制</td><td>硬件控制</td></tr><tr><td>中断请求</td><td>每次传送数据</td><td>只有后处理</td></tr><tr><td>响应时间</td><td>指令周期结束</td><td>总线空闲即可</td></tr><tr><td>场景</td><td>CPU 控制低速设备</td><td>MDA 控制器控制高速设备</td></tr><tr><td>优先级</td><td>低于 DMA</td><td>高于中断</td></tr><tr><td>异常处理</td><td>能处理异常事件</td><td>仅传送数据</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 计算机组成原理 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>计算机组成原理-Part6</title>
      <link href="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part6/"/>
      <url>/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part6/</url>
      
        <content type="html"><![CDATA[<h1 id="计算机组成原理-Part6——总线"><a href="#计算机组成原理-Part6——总线" class="headerlink" title="计算机组成原理-Part6——总线"></a>计算机组成原理-Part6——总线</h1><p>[TOC]</p><h2 id="总线概述"><a href="#总线概述" class="headerlink" title="总线概述"></a>总线概述</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><ul><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part6/image-20211025162259335.png" alt="image-20211025162259335"></li><li><strong>总线</strong>是一组能为多个部件<strong>分时共享</strong>的<strong>公共</strong>信息传送<strong>线路</strong>。</li><li>同一时刻只能有<strong>一个设备控制</strong>总线传输操作，可以有<strong>一个或多个设备</strong>从总线<strong>接收</strong>数据。</li><li>特点：<ul><li>共享：指总线上可以挂接多个部件，各个部件之间互相交换的信息都可以通过这组线路分时共享。</li><li>分时：指同一时刻只允许有一个部件向总线发送信息，如果系统中有多个部件，则它们只能分时地向总线发送信息。</li></ul></li><li>特性：<ul><li>机械特性：尺寸、形状、管脚数、排列顺序</li><li>电气特性：传输方向（数据双向、地址/控制单向）和有效的电平范围（高电平、低电平的定义范围）</li><li>功能特性：每根传输线的功能（地址、数据、控制）</li><li>时间特性：信号的时序关系</li></ul></li><li><strong>数据通路</strong>描述的是数据的路径，是逻辑上的概念。<strong>数据总线</strong>是承载数据的物理载体，<strong>地址总线</strong>一样可以成为数据通路的一部分。</li></ul><h3 id="总线分类（重点）"><a href="#总线分类（重点）" class="headerlink" title="总线分类（重点）"></a>总线分类（重点）</h3><ul><li>按数据传输格式：<ul><li>串行总线<ul><li>优点：1. 只需要一条传输线，成本低廉，广泛应用于长距离传输；2. 不容易发生跳变；3. 应用于计算机内部时，可以节省布线空间。</li><li>缺点：1. 在数据发送和接收的时候要进行拆卸和装配，要考虑串行-并行转换的问题。</li></ul></li><li>并行总线<ul><li>优点：1. 总线的逻辑时序比较简单，电路实现起来比较容易。</li><li>缺点：1. 信号线数量多，占用更多的布线空间；2. 远距离传输成本高昂；3. 由于工作频率较高时，并行的信号线之间会产生严重干扰，对每条线等长的要求也越高，所以无法持续提升工作频率。</li></ul></li><li>并行总线传输速度一定比串行总线快，是错误的。</li></ul></li><li>按总线功能（连接的部件）：<ul><li>片内总线<ul><li>片内总线是芯片内部的总线。</li><li>是 CPU 芯片内部<strong>寄存器与寄存器</strong>之间、<strong>寄存器与 ALU</strong> 之间的公共连接线。</li></ul></li><li>系统总线<ul><li>系统总线是计算机系统内各功能部件（CPU、主存、I/O接口）之间相互连接的总线。</li><li>按系统总线<strong>传输信息内容</strong>的不同，又可分为3类：<strong>数据总线</strong>（Data Bus）、<strong>地址总线</strong>（Address Bus）和<strong>控制总线</strong>（Control Bus）。</li><li>数据总线（双向）：用来传输各功能部件之间的数据信息，其位数与<strong>机器字长、存储字长有关</strong>。</li><li>地址总线（单向）：用来指出数据总线上的源数据或目的数据所在的主存单元或 I/O 端口的地址，地址总线的位数与<strong>主存地址空间大小</strong>和<strong>设备数量</strong>有关。</li><li>控制总线（单根单向，整体双向）：传输的是控制信息，包括 <strong>CPU 送出的控制命令</strong>和<strong>主存（或外设）返回 CPU 的反馈信号</strong>。</li></ul></li><li>通信总线<ul><li>通信总线是用于计算机系统之间或计算机系统与其他系统（如远程通信设备、测试设备）之间信息传送的总线，通信总线也称为外部总线。</li></ul></li></ul></li><li>按时序控制方式：<ul><li>同步总线</li><li>异步总线</li></ul></li></ul><h3 id="系统总线的结构（重点）"><a href="#系统总线的结构（重点）" class="headerlink" title="系统总线的结构（重点）"></a>系统总线的结构（重点）</h3><ul><li>单总线结构<ul><li>结构：CPU、主存、I/O设备（通过I/O接口）都连接在<strong>一组</strong>总线（而不是只有一根信号线）上，允许 I/O 设备之间、I/O 设备和 CPU 之间或 I/O 设备与主存之间直接交换信息。</li><li>优点：结构简单，成本低，易于接入新的设备。</li><li>缺点：带宽低、负载重，多个部件只能争用唯一的总线，且不支持并行传送操作。CPU、IO 的速度差异导致总线性能并不能完全发挥。</li><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part6/image-20211025190248221.png" alt="image-20211025190248221" style="zoom:80%;"></li></ul></li><li>双总线结构<ul><li>结构：双总线结构有两条总线，一条是主存总线，用于 CPU、主存和通道之间进行数据传送；另一条是 I/O 总线，用于多个外部设备与通道之间进行数据传送。</li><li>优点：将较低速的 I/O 设备从单总线上分离出来，实现存储器总线和 I/O 总线分离。</li><li>缺点：需要增加通道等硬件设备。</li><li>主存总线支持突发（猝发）传送：<strong>只需要送出一个首地址，就可以读写多个地址连续（超出一次数据总线的传输能力）的数据，而不需要每次都发送子地址</strong>。</li><li>通道是具有特殊功能的处理器，能对 I/O 设备进行统一管理。 通道程序放在主存中。</li><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part6/image-20211025190342462.png" alt="image-20211025190342462" style="zoom:80%;"></li></ul></li><li>三总线结构<ul><li>结构：三总线结构是在计算机系统各部件之间采用 3 条各自独立的总线来构成信息通路，这3条总线分别为主存总线、I/O 总线和直接内存访问 DMA 总线。</li><li>优点：<strong>提高了 I/O 设备的性能</strong>，使其更快地响应命令，提高系统吞吐量。</li><li>缺点：系统工作效率较低。（三条总线同时刻只有一个能工作）</li><li>DMA：Direct Memory Access，直接内存访问。</li><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part6/image-20211025190627701.png" alt="image-20211025190627701" style="zoom:80%;"></li></ul></li><li>四总线结构<ul><li>桥接器：用于连接不同的总线，具有数据缓冲、转换和控制功能。</li><li>靠近 CPU 的总线速度较快。</li><li>每级总线的设计遵循总线标准。</li></ul></li></ul><h3 id="总线的性能指标"><a href="#总线的性能指标" class="headerlink" title="总线的性能指标"></a>总线的性能指标</h3><ol><li><p>总线的传输周期（总线周期）</p><ul><li><strong>一次总线操作所需的时间</strong>（包括申请阶段、 寻址阶段、传输阶段和结束阶段），通常由若干个总线时钟周期构成。</li><li>总线周期与总线时钟周期的对应关系要具体按照题意，有可能会有多对一、一对一、一对多。</li></ul></li><li><p>总线时钟周期</p><ul><li>即<strong>机器的时钟周期</strong>。总线也要受 CPU 时钟的控制。</li><li>现在的计算机中，总线时钟周期也有可能由桥接器提供</li></ul></li><li><p>总线的工作频率</p><ul><li>总线上各种操作的频率，为<strong>总线周期的倒数</strong>。 </li><li>若总线周期=N个时钟周期，则总线的工作频率=时钟频率/N。 </li><li>实际上指<strong>一秒内传送几次数据</strong>。</li></ul></li><li><p>总线的时钟频率</p><ul><li>即机器的时钟频率，为<strong>时钟周期的倒数</strong>。 </li><li>若时钟周期为T，则时钟频率为1/T。 </li><li>实际上指<strong>一秒内有多少个时钟周期</strong>。</li></ul></li><li><p>总线宽度</p><ul><li>又称为<strong>总线位宽</strong>，它是总线上<strong>同时能够传输的数据位数</strong>，</li><li>一般说总线宽度，通常是指<strong>数据总线的根数</strong>，如 32 根数据信号线称为 32 位（bit）总线。</li></ul></li><li><p>总线带宽</p><ul><li>可理解为总线的<strong>数据传输速率</strong>，即<strong>单位时间内总线上可传输数据的位数</strong>，通常用每秒钟传送信息的字节数来衡量，单位可用字节/秒（B/s）表示。</li><li>总线带宽 = 总线工作频率 × 总线宽度（bit/s）= 总线工作频率 × (总线宽度/8)（B/s）= 总线宽度/总线周期（bit/s）= (总线宽度/8)/总线周期（B/s）</li><li>总线带宽是指总线本身所能达到的<strong>最高传输速率</strong>。在计算实际的<strong>有效数据传输率</strong>时，要用实际传输的数据量（<strong>去除冗余校验位之后</strong>）除以耗时。</li><li>注意，串行总线和并行总线之间的比较就需要用到：总线带宽 = 总线工作频率 × 总线宽度</li></ul></li><li><p>总线复用</p><ul><li><p>总线复用是指<strong>一种信号线在不同的时间传输不同的信息</strong>。</p><p>可以使用<strong>较少的线</strong>传输更多的信息，从而节省了空间和成本。</p></li></ul></li><li><p>信号线数</p><ul><li>地址总线、数据总线和控制总线 3 种总线数的总和称为信号线数。</li><li><strong>只传输一位 bit 数据的先叫做信号线</strong></li></ul></li></ol><ul><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part6/image-20211026092049020.png" alt="image-20211026092049020"></li></ul><h2 id="总线仲裁"><a href="#总线仲裁" class="headerlink" title="总线仲裁"></a>总线仲裁</h2><h3 id="基本概念-1"><a href="#基本概念-1" class="headerlink" title="基本概念"></a>基本概念</h3><ul><li>针对问题：总线作为一种共享设备，不可避免地会出现同一时刻有多个主设备竞争总线控制权的问题。</li><li><strong>主设备：</strong>获得总线控制权的设备。</li><li><strong>从设备：</strong>被主设备访问的设备，只能响应从主设备发来的各种总线命令。</li></ul><h3 id="总线仲裁分类"><a href="#总线仲裁分类" class="headerlink" title="总线仲裁分类"></a>总线仲裁分类</h3><h4 id="集中仲裁方式"><a href="#集中仲裁方式" class="headerlink" title="集中仲裁方式"></a>集中仲裁方式</h4><ul><li><p>主要工作流程：</p><ul><li>主设备发出请求信号；</li><li>若多个主设备同时要使用总线，则由总线控制器的判优、仲裁逻辑按一定的优先等级顺序确定哪个主设备能使用总线；</li><li>获得总线使用权的主设备开始传送数据。</li></ul></li><li><p>链式查询方式</p><ul><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part6/image-20211026094129115.png" alt="image-20211026094129115"></li><li>BS、BR、BG 都是一根信号线</li><li>优先级：<ul><li>离总线控制器越近的部件，其优先级越高；</li><li>离总线控制器越远的部件，其优先级越低。</li></ul></li><li>优点：链式查询方式优先级固定。只需很少几根控制线就能按一定优先次序实现总线控制，结构简单，扩充容易。</li><li>缺点：对硬件电路的故障敏感，并且优先级不能改变。当优先级高的部件频繁请求使用总线时，会使<strong>优先级较低的部件长期不能使用总线</strong>。</li></ul></li><li><p>计数器定时查询方式</p><ul><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part6/image-20211026111543103.png" alt="image-20211026111543103" style="zoom:80%;"></li><li>结构特点：用一个计数器控制总线使用权，相对链式查询方式多了一组设备地址线（设备地址线是一组线），少了一根总线响应线 BG；它仍共用一根总线请求线。</li><li>优点：<ul><li>计数初始值可以改变优先次序</li><li>对电路的故障没有链式敏感</li></ul></li><li>缺点：<ul><li>增加了控制线数。若设备有 n 个，则需 [log2n]+2 条控制线</li><li>控制相对比链式查询相对复杂</li></ul></li></ul></li><li><p>独立请求方式</p><ul><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part6/image-20211026112051799.png" alt="image-20211026112051799" style="zoom:80%;"></li><li>结构特点：每一个设备均有一对总线请求线 BRi 和总线允许线 BGi。</li><li>优点：<ul><li>响应速度快，总线允许信号 BG 直接从控制器发送到有关设备，不必在设备间传递或者查询。</li><li>对优先次序的控制相当灵活。</li></ul></li><li>缺点：<ul><li>控制线数量多。若设备有n个，则需要 2n+1 条控制线。</li><li>总线的控制逻辑更加复杂</li></ul></li></ul></li></ul><blockquote><p>“总线忙”信号的建立者是<strong>获得总线控制权的设备</strong>，而不是仲裁器发出。</p></blockquote><p><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part6/image-20211026112251788.png" alt="image-20211026112251788"></p><h4 id="分布仲裁方式"><a href="#分布仲裁方式" class="headerlink" title="分布仲裁方式"></a>分布仲裁方式</h4><ul><li>特点：不需要中央仲裁器，每个潜在的主模块都有自己的仲裁器和仲裁号，多个仲裁器竞争使用总线。</li><li>步骤<ul><li>当设备有总线请求时，它们就<strong>把各自唯一的仲裁号发送到共享的仲裁总线上</strong>；</li><li><strong>每个仲裁器</strong>将从仲裁<strong>总线上得到的仲裁号</strong>与自己的仲裁号进行<strong>比较</strong>；</li><li>如果仲裁总线上的号优先级高，则它的总线请求不予响应，并撤销它的仲裁号；</li><li>最后，获胜者的仲裁号保留在仲裁总线上。</li></ul></li></ul><h2 id="总线操作和定时"><a href="#总线操作和定时" class="headerlink" title="总线操作和定时"></a>总线操作和定时</h2><h3 id="基本概念-2"><a href="#基本概念-2" class="headerlink" title="基本概念"></a>基本概念</h3><ul><li>总线周期的四个阶段<ul><li>申请分配阶段：由需要使用总线的主模块（或主设备）提出申请，经总线仲裁机构决定将下一传输周期的总线使用权。也可将此阶段细分为<strong>传输请求</strong>和<strong>总线仲裁</strong>两个阶段。</li><li>寻址阶段：获得使用权的主模块通过总线发出本次要访问的从模块的地址及有关命令，<strong>启动参与本次传输的从模块</strong>。</li><li>传输阶段：主模块和从模块进行<strong>数据交换</strong>，可单向或双向进行数据传送。</li><li>结束阶段：主模块的<strong>有关信息</strong>均从系统总线上<strong>撤除</strong>，让出总线使用权。</li></ul></li><li>针对问题：占用总线的一对设备如何进行数据传输</li><li><strong>总线定时</strong>，指总线在双方交换数据的过程中需要时间上配合关系的控制，实质是一种协议或规则<ul><li>同步通信(同步定时方式)：由<strong>统一时钟</strong>控制数据传送</li><li>异步通信(异步定时方式)：采用<strong>应答方式</strong>，没有公共时钟标准</li><li>半同步通信：同步、异步结合</li><li>分离式通信：充分挖掘系统总线每瞬间的潜力</li></ul></li></ul><h3 id="同步定时方式"><a href="#同步定时方式" class="headerlink" title="同步定时方式"></a>同步定时方式</h3><ul><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part6/image-20211026141316738.png" alt="image-20211026141316738"></li><li>同步定时方式：总线控制器采用一个<strong>统一的时钟信号</strong>来协调发送和接收双方的传送定时关系。</li><li>假设：CPU 作为主设备，选择某个输入设备作为从设备<ol><li>CPU 在 T1 时刻的上升沿给出地址信息</li><li>在T2的上升沿给出读命令（低电平有效），与地址信息相符合的输入设备按命令进行一系列的内部操作，且必须在T3的上升沿来之前将CPU所需的数据送到数据总线上。</li><li>CPU在T3时钟周期内，将数据线上的信息传送到其内部寄存器中。</li><li>CPU在T4的上升沿撤销读命令，输入设备不再向数据总线上传送数据，撤销它对数据总线的驱动。</li></ol></li><li>优点：<strong>传送速度快</strong>，具有较高的传输速率；<strong>总线控制逻辑简单</strong>。</li><li>缺点：主从设备属于强制性同步；不能及时进行数据通信的有效性检验，<strong>可靠性较差</strong>。</li><li>同步通信适用于<strong>总线长度较短</strong>（总线长度短，传输更稳定）及总线<strong>所接部件的存取时间比较接近</strong>的系统。</li></ul><h3 id="异步定时方式"><a href="#异步定时方式" class="headerlink" title="异步定时方式"></a>异步定时方式</h3><ul><li>在异步定时方式中，没有统一的时钟，也没有固定的时间间隔，完全依靠传送双方相互制约的“握手”信号来实现定时控制。</li><li>主设备提出交换信息的“请求”信号（指明操作与地址），经接口传送到从设备；从设备接到主设备的请求后，通过接口向主设备发出“回答”信号。</li><li>根据“请求”和“回答”信号的撤销是否互锁，分为以下 3 种类型。<ul><li><strong>不互锁方式</strong>：速度最快，可靠性最差<ul><li>主设备发出“请求”信号后，<strong>不必等</strong>到接到从设备的“回答”信号，而是经过一段时间，便撤销“请求”信号。</li><li>而从设备在接到“请求”信号后，发出“回答”信号，并经过一段时间，<strong>自动撤销</strong>“回答”信号。双方不存在互锁关系。</li></ul></li><li><strong>半互锁方式</strong>：<ul><li>主设备发出“请求”信号后，<strong>必须等</strong>接到从设备的“回答”信号后，才撤销“请求”信号，有互锁的关系。</li><li>而从设备在接到“请求”信号后，发出“回答”信号，但不必等待获知主设备的“请求”信号已经撤销，而是隔一段时间后<strong>自动撤销</strong>“回答”信号，不存在互锁关系。</li></ul></li><li><strong>全互锁方式</strong>：最可靠，速度最慢<ul><li>主设备发出“请求”信号后，<strong>必须等</strong>从设备“回答”后，才撤销“请求”信号；</li><li>从设备发出“回答”信号，<strong>必须等</strong>获知主设备“请求”信号已撤销后，再撤销其“回答”信号。双方存在互锁关系。</li></ul></li></ul></li><li>优点：总线周期长度可变，能保证两个工作速度相差很大的部件或设备之间<strong>可靠</strong>地进行信息交换，自动适应时间的配合。</li><li>缺点：比同步控制方式稍复杂一些，速度比同步定时方式慢。</li><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part6/image-20211026144100498.png" alt="image-20211026144100498"></li></ul><h3 id="半同步通信（仅了解）"><a href="#半同步通信（仅了解）" class="headerlink" title="半同步通信（仅了解）"></a>半同步通信（仅了解）</h3><ul><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part6/image-20211026144310741.png" alt="image-20211026144310741"></li><li>半同步通信：统一时钟的基础上，增加一个“等待”响应信号 WAIT</li><li>当从设备跟不上主设备速度时，从设备通过 WAIT 信号线要求主设备等待</li></ul><h3 id="分离式通信（仅了解）"><a href="#分离式通信（仅了解）" class="headerlink" title="分离式通信（仅了解）"></a>分离式通信（仅了解）</h3><ul><li>上述三种通信的共同点<ul><li>主模块发地址 、命令 —— 使用总线</li><li>从模块准备数据 —— 不使用总线，<strong>总线空闲</strong></li><li>从模块向主模块发数据 —— 使用总线</li></ul></li><li>分离式通信的一个总线传输周期<ul><li>子周期 1：主模块申请占用总线，使用完后放弃总线的使用权</li><li>子周期 2：从模块申请占用总线，将各种信息送至总线上</li></ul></li><li>特点：<ul><li>各模块均有权申请占用总线</li><li>采用同步方式通信，不等对方回答</li><li>各模块准备数据时，不占用总线</li><li>总线利用率提高</li></ul></li></ul><h2 id="总线标准"><a href="#总线标准" class="headerlink" title="总线标准"></a>总线标准</h2><h3 id="基本概念-3"><a href="#基本概念-3" class="headerlink" title="基本概念"></a>基本概念</h3><ul><li>总线标准是国际上公布或推荐的互连各个模块的标准，是把各种不同的模块组成计算机系统时必须遵守的规范。</li><li><strong>系统总线</strong>：<strong>通常与 CPU 直接相连</strong>，用于连接 CPU 与北桥芯片、或 CPU 与主存等</li><li><strong>局部总线</strong>：<strong>没有直接与 CPU 连接</strong>，通常是连接高速的<strong>北桥芯片</strong>，用于连接了很多重要的硬件部件（如显卡、声卡等）</li><li><strong>设备总线</strong>、<strong>通信总线</strong>：通常由<strong>南桥芯片</strong>控制，用于连接计算机与计算机，或连接计算机与外部 I/O 设备</li></ul><h3 id="总线标准的发展"><a href="#总线标准的发展" class="headerlink" title="总线标准的发展"></a>总线标准的发展</h3><ul><li>系统总线<ul><li>ISA（Industry Standard Architecture）：<strong>并行总线</strong>，1984 年提出</li><li>EISA（Extended ISA）：<strong>并行总线</strong>，1988 年提出，在 ISA 基础上增加位宽</li><li>FBS、QPI：<strong>串行总线</strong>，Intel 提出的两种系统总线，用于连接 CPU 和北桥芯片；QPI 又称 multi-FSB</li></ul></li><li>局部总线<ul><li>VESA（Video Electronics Standard Architecture）：<strong>并行总线</strong>，1991 年提出，用于传输图像，但渐渐赶不上 CPU 的发展</li><li>PCI（Peripheral Component Interconnect）：<strong>并行总线</strong>，1992 年提出，速度和 VESA 差不多，但工作频率可以独立于 CPU 主频，用于连接显卡、声卡、网卡等，支持即插即用</li><li>AGP（Accelerated Graphics Port）：<strong>并行总线</strong>，1996 年提出，从 PCI2.1 基础上扩展而来，用于连接显存和主存</li><li>PCI-E（PCI-Express（3GIO））：<strong>串行总线</strong>，2001 年提出，工作频率很高，支持全双工通信</li></ul></li><li>设备/通信总线<ul><li>连接各种外设<ul><li>RS-232C（Recommended Standard）：<strong>串行总线</strong>，1970 年提出，用于极慢速的电传打印机</li><li>SCSI（Small Computer System Interface）：<strong>并行总线</strong>，1986 年提出，用于连接硬盘、打印机、扫描仪等</li><li>PCMCIA（Personal Computer Memory Card International Association）：<strong>并行总线</strong>，1991 年提出，用于连接外部存储卡，目的是增强个人电脑的信息互换</li><li>USB（Universal Serial Bus）：<strong>串行总线</strong>，1996 年提出，采用差模信号，每次只能传输 1 bit，工作频率可以很高</li></ul></li><li>连接硬盘<ul><li>IDE（Integrated Drive Electronics）：<strong>并行总线</strong>，19986 年提出，又称 Parallel ATA，主要用于连接硬盘、光驱等</li><li>SATA（Serial Advanced Technology Attachment）：<strong>串行总线</strong>，2001 年提出，Serial ATA，主要用于连接硬盘、光驱等</li></ul></li></ul></li></ul><h3 id="串行总线取代并行总线的原因"><a href="#串行总线取代并行总线的原因" class="headerlink" title="串行总线取代并行总线的原因"></a>串行总线取代并行总线的原因</h3><ul><li>并行总线：<ul><li>用 m 根线每次传送 m 个比特，用高/低电平表示 1/0，通常采用同步定时方式。</li><li>由于线间信号干扰，因此总线工作频率不能太高。</li><li>另外，各条线不能有长度差，长距离并行传输时工艺难度大。</li></ul></li><li>串行总线：<ul><li>用两根线每次传送一个比特，采用“差模信号”表示 1/0，通常采用异步定时方式，总线工作频率可以很高。</li><li>现在的串行总线通常基于包传输，如 80bit 为一个数据包，包与包之间有先后关系，因此可以用多个数据通路分别串行传输多个数据包，某种程度上现在的串行总线也有“并行”的特点</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机组成原理 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>计算机组成原理-Part5</title>
      <link href="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part5/"/>
      <url>/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part5/</url>
      
        <content type="html"><![CDATA[<h1 id="计算机组成原理-Part5——中央处理器"><a href="#计算机组成原理-Part5——中央处理器" class="headerlink" title="计算机组成原理-Part5——中央处理器"></a>计算机组成原理-Part5——中央处理器</h1><p>[TOC]</p><h2 id="CPU-的功能和结构"><a href="#CPU-的功能和结构" class="headerlink" title="CPU 的功能和结构"></a>CPU 的功能和结构</h2><h3 id="CPU-的功能"><a href="#CPU-的功能" class="headerlink" title="CPU 的功能"></a>CPU 的功能</h3><ol><li><strong>指令控制</strong>：完成<strong>取指令</strong>、<strong>分析指令</strong>和<strong>执行指令</strong>的操作，即程序的顺序控制。</li><li><strong>操作控制</strong>：CPU 产生并管理一条指令中的若干操作信号，从而<strong>控制相应的部件</strong>按指令要求进行动作。</li><li><strong>时间控制</strong>：为<strong>每条指令按时间顺序</strong>提供应有的控制信号。</li><li><strong>数据加工</strong>：对数据进行<strong>算术和逻辑运算</strong>。</li><li><strong>中断处理</strong>：管理<strong>总线</strong>及<strong>输入输出</strong>；处理<strong>异常情况</strong>和<strong>特殊请求</strong>。</li></ol><ul><li>运算器：<strong>数据加工</strong></li><li>控制器：<strong>操作控制</strong>、<strong>时间控制</strong>、<strong>指令控制</strong>、<strong>中断处理</strong></li></ul><h3 id="运算器的基本结构"><a href="#运算器的基本结构" class="headerlink" title="运算器的基本结构"></a>运算器的基本结构</h3><ul><li>运算器结构：<ul><li>算术逻辑单元：进行算术/逻辑运算。</li><li>通用寄存器组：如 AX、BX、CX、DX、SP 等。用于存放操作数（包括源操作数、目的操作数及中间结果）和各种地址信息等。</li><li>暂存寄存器：用于暂存<strong>从主存读来的数据</strong>，这个数据不能立即存放在通用寄存器中，否则会破坏其原有内容。</li><li>累加寄存器：是一个通用寄存器，用于暂时存放 ALU 运算的结果信息，用于实现加法运算。</li><li>程序状态字寄存器（PSW）：保留由算术逻辑运算指令或测试指令的结果的各种状态信息，如溢出标志（OP）、符号标志（SF）、零标志（ZF）、进位标志（CF）等。<strong>这些位参与并决定微操作的形成</strong>。</li><li>移位器：对运算结果进行移位运算。</li><li>计数器：控制乘除运算的操作步数。</li></ul></li></ul><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part5/image-20211023104243472.png" alt="image-20211023104243472" style="zoom:80%;"><ul><li><strong>专用数据通路方式</strong>：根据指令执行过程中的数据和地址的流动方向安排连接线路。<ul><li>特点：<strong>性能较高</strong>，基本不存在数据冲突现象，但<strong>结构复杂</strong>，硬件量大，不易实现。</li></ul></li><li>针对问题：<ul><li>如果 ALU 与寄存器组直接用导线连接，相当于多个寄存器同时并且一直向 ALU 传输数据</li></ul></li><li>改进方向：<ul><li>解决方法1：使用<strong>多路选择器</strong>根据控制信号选择一路输出</li><li>解决方法2：使用<strong>三态门</strong>可以控制每一路是否输出</li></ul></li></ul><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part5/image-20211023105644925.png" alt="image-20211023105644925" style="zoom:80%;"><ul><li><strong>CPU 内部单总线方式</strong>：将所有寄存器的输入端和输出端都连接到一条公共的通路上。<ul><li>特点：结构简单，容易实现，但数据传输存在较多冲突的现象，性能较低。</li></ul></li><li>针对问题：<ul><li>ALU 的计算结果会在电流不稳定时直接传回 CPU 内部总线，破坏寄存器信息</li></ul></li><li>改进方向：<ul><li>在 ALU 后加入<strong>暂存寄存器</strong>和<strong>三态门</strong>来等待稳定之后再将结果写入寄存器</li><li>通常会把 ALU 后的寄存器添加移位功能</li></ul></li></ul><h3 id="控制器的基本结构"><a href="#控制器的基本结构" class="headerlink" title="控制器的基本结构"></a>控制器的基本结构</h3><p><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part5/image-20211023121447512.png" alt="image-20211023121447512"></p><ol><li>程序计数器：存放下一条指令在主存中的地址。CPU 会根据 PC 的内容去主存中取指令。通常 PC 有自增功能，有的也会交给 ALU 进行加一。</li><li>指令寄存器：用于保存当前正在执行的指令。</li><li>指令译码器：仅<strong>对操作码字段进行译码</strong>，向控制器提供特定的操作信号。</li><li>微操作信号发生器：根据 <strong>IR 的内容</strong>（指令）、<strong>PSW 的内容</strong>（状态信息）及<strong>时序信号</strong>（时序脉冲），产生控制整个计算机系统所需的各种控制信号，其结构有<strong>组合逻辑型</strong>和<strong>存储逻辑型</strong>两种。</li><li>时序系统：用于产生各种时序信号，它们都是由统一时钟（CLOCK）分频得到。</li><li>存储器地址寄存器：用于存放所要访问的主存单元地址。</li><li>存储器数据寄存器：用于存放向主存写入的信息或从主存中读出的信息。</li></ol><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part5/image-20211023122455417.png" alt="image-20211023122455417"></p><ul><li>用户可见寄存器：通用寄存器组、程序状态字寄存器 PSW、程序计数器 PC</li><li>用户不可见寄存器：MAR、MDR、IR、暂存寄存器</li></ul><h2 id="指令执行过程"><a href="#指令执行过程" class="headerlink" title="指令执行过程"></a>指令执行过程</h2><h3 id="指令周期"><a href="#指令周期" class="headerlink" title="指令周期"></a>指令周期</h3><ul><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part5/image-20211023123259434.png" alt="image-20211023123259434" style="zoom:80%;"><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part5/image-20211023123229871.png" alt="image-20211023123229871" style="zoom:80%;"></li><li><strong>指令周期</strong>：CPU 从主存中每<strong>取出并执行</strong>一条指令所需的全部时间。<ul><li>指令周期常常用若干<strong>机器周期</strong>（<strong>CPU 周期</strong>）来表示。</li><li>一个机器周期又包含若干<strong>时钟周期</strong>（也称为<strong>节拍</strong>、<strong>T 周期</strong>、<strong>主频的倒数</strong>或 <strong>CPU 时钟周期</strong>，它是 CPU 操作的<strong>最基本单位</strong>）。</li></ul></li><li>每个指令周期内机器周期数可以<strong>不等</strong>，每个机器周期内的节拍数也可以<strong>不等</strong>。<ul><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part5/image-20211023124356581.png" alt="image-20211023124356581" style="zoom:80%;"></li></ul></li></ul><h3 id="指令周期数据流"><a href="#指令周期数据流" class="headerlink" title="指令周期数据流"></a>指令周期数据流</h3><ul><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part5/image-20211023130107891.png" alt="image-20211023130107891" style="zoom:80%;"></li><li><p>四个工作周期都有CPU访存操作，只是访存的目的不同。</p><ul><li><strong>取指周期</strong>是为了<strong>取指令</strong></li><li><strong>间址周期</strong>是为了<strong>取有效地址</strong></li><li><strong>执行周期</strong>是为了<strong>取操作数</strong></li><li><strong>中断周期</strong>是为了<strong>保存程序断点</strong></li></ul></li><li><p name="取指周期">取指周期（所有指令都一样）</p><ul><li>(PC) → MAR：当前指令地址送至存储器地址寄存器</li><li>1 → R：CU 发出控制信号，经控制总线传到主存，这里是给<strong>读信号接口</strong>输送一个高电平</li><li>M(MAR) → MDR：将 MAR 所指主存中的内容经数据总线送入 MDR</li><li>(MDR) → IR：将 MDR 中的内容（此时是指令）送入 IR</li><li>OP(IR) → ID：将指令（IR 中的操作码部分）传入指令译码器（Instruction Decoder，ID）</li><li>(PC)+1 → PC：CU 发出控制信号，形成下一条指令地址</li></ul></li><li><p>间址周期（所有指令都一样）</p><ul><li>Ad(IR/MDR) → MAR：将指令的地址码送入 MAR</li><li>1 → R：CU 发出控制信号，启动主存做<strong>读操作</strong></li><li>M(MAR) → MDR：将 MAR 所指主存中的内容经数据总线送入 MDR</li><li>(MDR) → Ad(IR)：将最终的有效地址（IR 中的地址码部分）送至指令的地址码字段</li></ul></li><li><p>执行周期（各不相同）</p><ul><li>执行周期的任务是根据 IR 中的指令字的操作码和操作数通过 ALU 操作产生执行结果。不同指令的执行周期操作不同，因此没有统一的数据流向。</li><li>CLA：clear ACC（ACC清零）<ul><li>0 → AC</li></ul></li><li>LDA X：load ACC（把X所指内容取到ACC）<ul><li>Ad ( IR ) → MAR</li><li>1 → R</li><li>M ( MAR ) → MDR</li><li>MDR → AC</li></ul></li><li>JMP X：（无条件转移)<ul><li>Ad(IR) → PC</li></ul></li><li>BAN X：Branch ACC Negative（当ACC为负时转移）<ul><li>A<del>0</del> • Ad (IR) + (!A<del>0</del>) • (PC) → PC</li></ul></li></ul></li><li><p>中断周期</p><ul><li>中断：暂停当前任务去完成其他任务。为了能够恢复当前任务，需要保存断点。一般使用堆栈来保存断点，假设 SP 指向栈顶元素（低地址部分）。进栈操作是先修改指针，后存入数据。</li><li>中断周期三个任务：<ul><li>保存断点</li><li>形成中断服务程序的入口地址</li><li>关中断</li></ul></li><li>(SP)-1 → SP，(SP) → MAR：CU 控制 SP 减1，修改后的地址送入 MAR</li><li>1 → W：CU 发出控制信号，启动主存做<strong>写操作</strong></li><li>(PC) → MDR：将断点（PC 内容）送入 MDR</li><li>向量地址 → PC：CU 控制将中断服务程序的入口地址（由向量地址形成部件产生）送入 PC</li></ul></li></ul><h3 id="指令执行方案"><a href="#指令执行方案" class="headerlink" title="指令执行方案"></a>指令执行方案</h3><ul><li>一个指令周期通常要包括几个时间段（执行步骤），每个步骤完成指令的一部分功能，几个依次执行的步骤完成这条指令的全部功能。</li><li>单指令周期<ul><li>所有指令都选用相同的执行时间来完成，指令之间串行执行。</li><li>指令周期取决于执行时间最长的指令的执行时间。对于可以在更短时间内完成的指令，要使用等待至最长的周期，会降低系统的运行速度。</li></ul></li><li>多指令周期<ul><li>对不同类型的指令选用不同的执行步骤来完成 ，指令之间串行执行。</li><li>可选用不同个数的时钟周期来完成不同指令的执行过程 。需要更复杂的硬件设计。</li></ul></li><li>流水线方案<ul><li>在每一个时钟周期启动一条指令，让多条指令处在<strong>不同的执行步骤</strong>中<strong>同时运行</strong>，指令之间并行执行。</li></ul></li></ul><h2 id="数据通路（大题高频）"><a href="#数据通路（大题高频）" class="headerlink" title="数据通路（大题高频）"></a>数据通路（大题高频）</h2><ul><li>数据通路：数据在功能部件之间传送的路径。<ul><li>寄存器-寄存器</li><li>寄存器-主存</li><li>寄存器-ALU</li></ul></li><li>数据通路的基本结构：<ul><li>CPU 内部单总线方式（ALU 必须配合暂存寄存器使用）</li><li>CPU 内部多总线方式（相比单总线成本更高，但是数据传输更有效率）</li><li>专用数据通路方式</li></ul></li></ul><h3 id="单总线结构"><a href="#单总线结构" class="headerlink" title="单总线结构"></a>单总线结构</h3><ul><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part5/image-20211023141239720.png" alt="image-20211023141239720" style="zoom:80%;"></li><li>寄存器之间数据传送<ul><li>(PC)→Bus：PCout 有效（PC 内容送总线）</li><li>Bus→MAR：MARin 有效（总线内容送 MAR）</li></ul></li><li>主存与CPU之间的数据传送<ul><li>(PC)→Bus→MAR：PCout 和 MARin 有效（现行指令地址→MAR）</li><li>1→R：CU 发读命令</li><li>MEM(MAR)→MDR：MDRinE 有效</li><li>MDR→Bus→IR：MDRout 和 IRin 有效（现行指令→IR）</li></ul></li><li>执行算术或逻辑运算<ul><li>Ad(IR/MDR)→Bus→MAR：MDRout 和 MARin 有效</li><li>1→R：CU 发读命令</li><li>MEM(MAR)→数据线→MDR：MDRin 有效</li><li>MDR→Bus→Y：MDRout 和 Yin 有效（操作数→Y）</li><li>(ACC)+(Y)→Z：ACCout 和 ALUin 有效（CU 向 ALU 发送加命令）</li><li>Z→ACC：Zout 和 ACCin 有效（结果→ACC）</li></ul></li></ul><h3 id="专用通路结构"><a href="#专用通路结构" class="headerlink" title="专用通路结构"></a>专用通路结构</h3><ul><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part5/image-20211023145547590.png" alt="image-20211023145547590" style="zoom:80%;"></li><li>取指周期<ul><li>(PC)→MAR：C0有效</li><li>(MAR)→主存：C1有效</li><li>1→R：控制单元向主存发送读命令</li><li>M(MAR)→MDR：C2有效</li><li>(MDR)→IR：C3有效</li><li>(PC)+1→PC</li><li>Op(IR)→CU：C4有效</li></ul></li></ul><blockquote><p>数据通路是计组大题高频考点！一定要做题巩固！</p></blockquote><h2 id="控制器的功能和工作原理"><a href="#控制器的功能和工作原理" class="headerlink" title="控制器的功能和工作原理"></a>控制器的功能和工作原理</h2><h3 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h3><ul><li>硬布线控制器：使用<strong>纯硬件</strong>的方式来实现控制器的功能</li><li>微程序控制器：使用<strong>软硬件结合</strong>的方式来实现控制器的功能</li><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part5/image-20211023185221891.png" alt="image-20211023185221891"></li><li>CPU 会在每个时钟周期内发出一个<strong>微命令</strong>，即完成一个对应<strong>微操作</strong>的控制信号。<ul><li>如，微命令1 使得 PCout、MARin 有效，从而完成对应的微操作1 (PC)-&gt;MAR。</li><li>微命令与微操作是相互对应的</li><li>特点：<ol><li>多个<strong>相容</strong>的微操作是可以<strong>在一个节拍内并行</strong>的。比如使用专用通路结构就可以提高微命令的并行数量</li><li>同一个微操作可能在不同的指令阶段中重复使用</li><li>在定长机器周期中，通常以<strong>访存所需节拍数</strong>作为参考</li><li>若实际所需节拍数较少，可将微操作安排在机器周期末尾进行</li></ol></li></ul></li><li>根据<strong>指令操作码</strong>、<strong>当前的机器周期</strong>、<strong>节拍信号</strong>、<strong>机器状态条件</strong>，即可确定现在这个节拍下应该发出哪些“微命令”</li><li>CPU 所处的周期由四个不同的触发器确定。</li></ul><h3 id="硬布线控制器"><a href="#硬布线控制器" class="headerlink" title="硬布线控制器"></a>硬布线控制器</h3><ul><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part5/image-20211023190651176.png" alt="image-20211023190651176"></li><li>设计步骤<ol><li><a href="#取指周期">分析每个阶段的微操作序列</a>（哪些指令在<strong>什么阶段</strong>、<strong>什么条件</strong>下会使用到<strong>什么微操作</strong>）</li><li>选择 CPU 的控制方式（定长/不定长周期，每个周期的节拍数）</li><li>安排微操作时序</li><li>电路设计（逻辑表达式与电路设计）<ul><li>列出操作时间表</li><li>写出微操作的最简表达式</li><li>画出逻辑图</li></ul></li></ol></li><li>安排微操作时序的原则<ol><li>微操作的<strong>先后顺序</strong>不得随意更改</li><li><strong>被控对象不同</strong>的微操作尽量安排在<strong>一个节拍</strong>内完成</li><li>占用<strong>时间较短</strong>的微操作尽量安排在<strong>一个节拍</strong>内完成，允许有先后顺序</li></ol></li><li>取指周期：<ul><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part5/image-20211023194220430.png" alt="image-20211023194220430" style="zoom:80%;"></li><li>M ( MAR ) -&gt; MDR：从主存取数据，用时较长，因此必须一个时钟周期才能保证微操作的完成</li><li>MDR -&gt; IR：是 CPU 内部寄存器之间的数据传送，速度很快，因此在一个时钟周期内可以紧接着完成第二个微命令 OP ( IR ) -&gt; ID。</li></ul></li><li>间址周期：<ul><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part5/image-20211023194429655.png" alt="image-20211023194429655" style="zoom:80%;"></li></ul></li><li>执行周期：<ul><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part5/image-20211023194744913.png" alt="image-20211023194744913" style="zoom:80%;"></li></ul></li><li>缺点：<ul><li>指令越多，设计、实现就越复杂，因此<strong>一般用于 RISC</strong>（精简指令集系统） </li><li>如果扩充一条新的指令，则控制器的设计就需要大改，因此<strong>扩充指令较困难</strong>。</li></ul></li><li>优点：<ul><li>由于使用纯硬件实现控制，因此执行<strong>速度很快</strong>。</li><li><strong>微操作控制信号</strong>由组合逻辑电路根据当前的指令码、状态和时序，<strong>即时产生</strong>。</li></ul></li></ul><h3 id="微程序控制器（考点）"><a href="#微程序控制器（考点）" class="headerlink" title="微程序控制器（考点）"></a>微程序控制器（考点）</h3><h4 id="基本原理-1"><a href="#基本原理-1" class="headerlink" title="基本原理"></a>基本原理</h4><h5 id="微程序的概念"><a href="#微程序的概念" class="headerlink" title="微程序的概念"></a>微程序的概念</h5><ul><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part5/image-20211024094522115.png" alt="image-20211024094522115"></li><li>基本思想：采用“存储程序”的思想，CPU 出厂前将所有指令的“微程序”存入“控制器存储器”中</li><li>层次结构：<ul><li>程序：由<strong>指令序列</strong>组成</li><li><strong>微程序</strong>：<ul><li>由<strong>微指令序列</strong>组成，<strong>每一种指令对应一个微程序</strong></li><li><strong>取指、间指、执行、中断周期微程序段</strong>，共同<strong>组成一个微程序</strong></li></ul></li><li><strong>指令</strong>：是对程序执行步骤的描述<ul><li>指令/微程序是对微指令功能的“封装”</li><li>是一个微指令序列</li></ul></li><li><strong>微指令</strong>：是对指令执行步骤的描述<ul><li>微指令中可能包含多个<strong>微命令</strong></li><li><strong>每一个微命令对应一个微操作</strong>，<strong>每一个微命令对应一条输出控制线</strong></li></ul></li></ul></li></ul><h5 id="微程序控制器基本结构"><a href="#微程序控制器基本结构" class="headerlink" title="微程序控制器基本结构"></a>微程序控制器基本结构</h5><ul><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part5/image-20211024180509785.png" alt="image-20211024180509785"></li><li><strong>微地址形成部件</strong>：产生初始微地址和后继微地址，以保证微指令的连续执行。</li><li><strong>CMAR</strong>：又称 <strong>μPC</strong>，微地址寄存器，接收微地址形成部件送来的微地址，为在 CM 中读取微指令作准备。</li><li><strong>地址译码</strong>：将地址码转化为存储单元控制信号。</li><li><strong>控制存储器 CM</strong>：简称<strong>控存</strong>，用于存放各指令对应的微程序，控制存储器是由<strong>只读存储器 ROM</strong> 构成。</li><li><strong>CMDR</strong>：别名：<strong>μIR</strong>，用于存放从 CM 中取出的微指令，它的位数同微指令字长相等。</li><li><strong>顺序逻辑</strong>：<ul><li>根据<strong>指令地址码的寻址特征位</strong>判断是否要跳过间址周期</li><li>根据<strong>中断信号</strong>判断是否进入中断周期</li></ul></li><li>所有指令的<strong>取指周期</strong>、<strong>间址周期</strong>、<strong>中断周期</strong>所对应的微指令序列都一样，<strong>可以共享使用</strong>。</li><li>取指周期微程序：（常考）<ul><li>通常是公用的，故如果某指令系统中有 n 条机器指令，则 CM 中微程序（段）的个数至少是 <strong>n+1</strong> 个</li><li>一些早期的 CPU、物联网设备的 CPU <strong>可以不提供间接寻址和中断功能</strong>，因此这类 CPU 可以不包含间址周期、中断周期的微程序段</li></ul></li><li>有的选择题中，虽然取指周期、执行周期<strong>在物理上</strong>是两个微程序，但<strong>逻辑上</strong>应该把它们看作一个整体。即，<strong>一条指令对应一个微程序</strong>。</li></ul><h4 id="微指令的设计"><a href="#微指令的设计" class="headerlink" title="微指令的设计"></a>微指令的设计</h4><h5 id="微指令的格式"><a href="#微指令的格式" class="headerlink" title="微指令的格式"></a>微指令的格式</h5><ul><li>水平型微指令：一条微指令能定义多个可并行的微命令。<ul><li>优点：微程序短，执行速度快；</li><li>缺点：微指令长，编写微程序较麻烦。</li><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part5/image-20211024182849406.png" alt="image-20211024182849406"></li></ul></li><li>垂直型微指令：一条微指令只能定义<strong>一个</strong>微命令<strong>，</strong>由微操作码字段规定具体功能<ul><li>优点：微指令短、简单、规整，便于编写微程序；</li><li>缺点：微程序长，执行速度慢，工作效率低。 </li><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part5/image-20211024182907683.png" alt="image-20211024182907683"></li></ul></li><li>混合型微指令：<ul><li>在垂直型的基础上增加一些不太复杂的并行操作。</li><li>微指令较短，仍便于编写；微程序也不长，执行速度加快。</li></ul></li></ul><blockquote><ul><li><strong>相容性</strong>微命令：可以并行完成的微命令。</li><li><strong>互斥性</strong>微命令：不允许并行完成的微命令。</li></ul></blockquote><h5 id="微指令的编码方式（高频）"><a href="#微指令的编码方式（高频）" class="headerlink" title="微指令的编码方式（高频）"></a>微指令的编码方式（高频）</h5><p><strong>微指令的编码方式</strong>，又称<strong>微指令的控制方式</strong>，指如何对微指令的控制字段进行编码，以形成控制信号。目标是在保证速度的情况下，尽量缩短微指令字长。</p><ol><li>直接编码（直接控制）方式<ul><li>在微指令的操作控制字段中，<strong>每一位代表一个微操作命令</strong>，某位为 1 表示该控制信号有效</li><li>优点：简单、直观，执行速度快，操作并行性好。</li><li>缺点：微指令字长过长，n 个微命令就要求微指令的操作字段有 n 位，造成控存容量极大。</li><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part5/image-20211024205924843.png" alt="image-20211024205924843"></li></ul></li><li>字段直接编码方式<ul><li>将微指令的控制字段分成若干“段”，<strong>每段经译码后发出控制信号</strong>微命令字段分段的原则：<ul><li><strong>互斥性</strong>微命令分在<strong>同一段内</strong>，<strong>相容性</strong>微命令分在<strong>不同段内</strong>。不同段/不同互斥类/相容的微命令可以并行</li><li><strong>每个小段</strong>中包含的<strong>信息位不能太多</strong>，否则将增加译码线路的复杂性和译码时间。</li><li>一般<strong>每个小段还要留出一个状态</strong>，表示本字段不发出任何微命令。因此，当某字段的长度为 3 位时，最多只能表示 7 个互斥的微命令，<strong>通常用 000 表示不操作</strong>。</li></ul></li><li>优点：可以缩短微指令字长。</li><li>缺点：要通过译码电路后再发出微命令，因此比直接编码方式慢 。</li><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part5/image-20211024210134498.png" alt="image-20211024210134498"></li></ul></li><li>字段间接编码方式<ul><li>一个字段的某些微命令需由另一个字段中的某些微命令来解释，由于不是靠字段直接译码发出的微命令，故称为字段间接编码，又称隐式编码。</li><li>优点：可进一步缩短微指令字长。</li><li>缺点：削弱了微指令的并行控制能力。通常作为字段直接编码方式的一种辅助手段。</li><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part5/image-20211024210333131.png" alt="image-20211024210333131"></li></ul></li></ol><h5 id="微指令的地址形成方式"><a href="#微指令的地址形成方式" class="headerlink" title="微指令的地址形成方式"></a>微指令的地址形成方式</h5><ol><li><strong>断定方式</strong>（常考）：微指令的下地址字段直接指出后继微指令的地址。</li><li>根据机器指令的<strong>操作码</strong>形成：当机器指令取至指令寄存器后，微指令的地址由操作码经微地址形成部件形成。（不常考）</li><li>增量<strong>计数器法</strong>（常考）：(CMAR) + 1 -&gt; CMAR/μPC</li><li>分支转移：操作控制字段+转移方式+转移地址。转移方式，指明判别条件；转移地址，指明转移成功后的去向。（不常考）</li><li>通过测试网络（不常考）</li><li>由<strong>硬件</strong>产生微程序入口地址：<ul><li>第一条微指令地址：由<strong>硬件</strong>产生（用专门的硬件记录取指周期微程序首地址）</li><li>中断周期：由<strong>硬件</strong>产生中断周期微程序首地址（用专门的硬件记录）</li></ul></li></ol><h4 id="微程序控制单元的设计"><a href="#微程序控制单元的设计" class="headerlink" title="微程序控制单元的设计"></a>微程序控制单元的设计</h4><ul><li><p><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part5/image-20211024232747714.png" alt="image-20211024232747714"></p></li><li><p>设计步骤：</p><ol><li><p>分析每个阶段的微操作序列</p></li><li><p>写出对应机器指令的微操作命令及节拍安排</p><ul><li><p> 写出每个周期所需要的微操作（参照硬布线）</p></li><li><p>补充微程序控制器特有的微操作：</p><p>a. 取指周期：</p><ul><li>Ad ( CMDR ) -&gt; CMAR（每条微指令结束都要进行）</li><li>OP ( IR ) -&gt; 微地址形成部件 -&gt; CMAR（取指周期结束，根据指令操作码确定其执行周期的微程序首地址）</li></ul><p>b. 执行周期：</p><ul><li>Ad(CMDR) -&gt; CMAR（每条微指令结束都要进行，最后一条微指令的下地址是 0）</li></ul></li></ul></li><li><p>确定微指令格式</p><ul><li>根据<strong>微操作个数</strong>决定采用何种<strong>编码方式</strong>，以确定微指令的<strong>操作控制字段的位数</strong>。</li><li>根据 CM 中存储的<strong>微指令总数</strong>，确定微指令的<strong>顺序控制字段的位数</strong>。</li><li>最后按操作控制字段位数和顺序控制字段位数就可确定<strong>微指令字长</strong>。</li></ul></li><li><p>编写微指令码点</p><ul><li>根据操作控制字段每一位代表的微操作命令，编写每一条微指令的码点。</li></ul></li></ol></li><li><p>读出微指令：</p><ul><li>取指周期的<strong>第一条微指令地址由硬件自动给出</strong></li><li>用微指令 a 的下地址表示 b 的地址。上一条微指令的下地址部分转到下一条微指令的译码，同样需要消耗一个节拍</li></ul></li></ul><h4 id="微程序设计分类"><a href="#微程序设计分类" class="headerlink" title="微程序设计分类"></a>微程序设计分类</h4><ol><li>静态微程序设计和动态微程序设计<ul><li>静态：微程序无需改变，采用 ROM</li><li>动态：通过改变<strong>微指令</strong>和<strong>微程序</strong>改变机器指令。有利于仿真，采用 EPROM</li></ul></li><li>毫微程序设计<ul><li>微程序设计：用微程序解释机器指令</li><li>毫微程序设计：用毫微程序解释微程序</li><li><strong>毫微指令与微指令</strong>的关系好比<strong>微指令与机器指令</strong>的关系</li></ul></li></ol><h3 id="硬布线与微程序的比较"><a href="#硬布线与微程序的比较" class="headerlink" title="硬布线与微程序的比较"></a>硬布线与微程序的比较</h3><table><thead><tr><th>对比项目</th><th>微程序控制器</th><th>硬布线控制器</th></tr></thead><tbody><tr><td>工作原理</td><td>读出微程序</td><td>电路即时产生</td></tr><tr><td>执行速度</td><td>慢</td><td>快</td></tr><tr><td>规整性</td><td>较规整</td><td>繁琐，不规整</td></tr><tr><td>应用场合</td><td>CISC CPU</td><td>RISC CPU</td></tr><tr><td>易扩充性</td><td>易扩充修改</td><td>困难</td></tr></tbody></table><h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part5/image-20211024235150778.png" alt="image-20211024235150778"></p><h2 id="指令流水线（大题考察）"><a href="#指令流水线（大题考察）" class="headerlink" title="指令流水线（大题考察）"></a>指令流水线（大题考察）</h2><h3 id="指令流水线的基本概念"><a href="#指令流水线的基本概念" class="headerlink" title="指令流水线的基本概念"></a>指令流水线的基本概念</h3><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><ul><li>指令流水：一条指令的执行过程可以分成多个阶段（或过程）。根据计算机的不同，具体的分法、数量也不同。<ul><li>取指（Instruction Fetch，IF）、分析（Instruction Decode，ID）、执行（Execute）、Memory、Writeback</li><li>分成 5 个阶段的 RISC 是比较常见的考法。</li></ul></li></ul><h4 id="执行方式"><a href="#执行方式" class="headerlink" title="执行方式"></a>执行方式</h4><ul><li>顺序执行方式：<ul><li>总耗时 T = n×3t = 3nt</li><li>传统冯·诺依曼机采用顺序执行方式，又称串行执行方式。</li><li>优点：控制简单，硬件代价小。</li><li>缺点：执行指令的速度较慢，在任何时刻，处理机中只有一条指令在执行，各功能部件的利用率很低。</li></ul></li><li>一次重叠执行方式：<ul><li>总耗时T = 3t + (n-1)×2t = (1+2n)t</li><li>优点：程序的执行时间缩短了1/3，各功能部件的利用率明显提高。</li><li>缺点：需要付出硬件上较大开销的代价，控制过程也比顺序执行复杂了。</li></ul></li><li>二次重叠执行方式：<ul><li>总耗时T = 3t + (n-1)×t = (2+n)t</li><li>与顺序执行方式相比，指令的执行时间缩短近2/3。这是一种理想的指令执行方式，在正常情况下，处理机中同时有3条指令在执行。</li></ul></li></ul><h4 id="表示方法（重要）"><a href="#表示方法（重要）" class="headerlink" title="表示方法（重要）"></a>表示方法（重要）</h4><ul><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part5/image-20211025092552132.png" alt="image-20211025092552132"></li><li>指令执行过程图：主要用于分析指令执行过程以及影响流水线的因素</li><li>时空图：主要用于分析流水线的性能</li></ul><h4 id="性能指标（重要）"><a href="#性能指标（重要）" class="headerlink" title="性能指标（重要）"></a>性能指标（重要）</h4><p><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part5/image-20211025093530754.png" alt="image-20211025093530754"></p><p>一条指令的执行分为 k 个阶段，每个阶段耗时 Δt ，一般取 Δt=一个时钟周期（应该是机器周期，在理想情况下可以当做时钟周期）</p><ul><li>吞吐率：在单位时间内流水线所完成的任务数量。<ul><li>吞吐率计算公式：$TP = \frac{n}{T_{k}}$</li><li>实际吞吐率为：$TP = \frac{n}{(k+n-1)Δt}$</li><li>当连续输入的任务 n→∞ 时，最大吞吐率为 TPmax=1/Δt。</li></ul></li><li>加速比：完成同样一批任务，<strong>不使用流水线所用的时间</strong>与<strong>使用流水线所用的时间</strong>之比。<ul><li>加速比公式：$S = \frac{T_{0}}{T_{k}}$</li><li>实际加速比：$S = \frac{knΔt}{(k+n-1)Δt} = \frac{kn}{(k+n-1)}$</li><li>当连续输入的任务 n→∞ 时，最大加速比为 Smax=k。</li></ul></li><li>效率：流水线的设备利用率称为流水线的效率。<ul><li>在时空图上，流水线的效率定义为完成<strong>n个任务占用的时空区有效面积</strong>与<strong>n个任务所用的时间与k个流水段所围成的时空区总面积</strong>之比。</li><li>效率公式：$E = \frac{n个任务占用k时空区有效面积}{n个任务所用的时间与k个流水段所围成的时空区总面积}=\frac{T_{0}}{kT_{k}}$</li><li>当连续输入的任务 n→∞ 时，最高效率为 Emax=1。</li><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part5/image-20211025095147120.png" alt="image-20211025095147120"></li></ul></li></ul><h3 id="指令流水线的影响因素和分类"><a href="#指令流水线的影响因素和分类" class="headerlink" title="指令流水线的影响因素和分类"></a>指令流水线的影响因素和分类</h3><h4 id="影响流水线的因素（重要）"><a href="#影响流水线的因素（重要）" class="headerlink" title="影响流水线的因素（重要）"></a>影响流水线的因素（重要）</h4><ul><li>结构相关（资源冲突）<ul><li>由于多条指令在同一时刻争用同一资源而形成的冲突称为结构相关。</li><li>解决办法：<ul><li>后一相关指令暂停一周期</li><li>资源重复配置：数据存储器+指令存储器</li></ul></li><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part5/image-20211025102708962.png" alt="image-20211025102708962"></li></ul></li><li>数据相关（数据冲突）<ul><li>数据相关指在一个程序中，存在必须等前一条指令执行完才能执行后一条指令的情况，则这两条指令即为数据相关。</li><li>解决办法：<ul><li>把遇到数据相关的指令及其后续指令都暂停一至几个时钟周期，直到数据相关问题消失后再继续执行。可分为<strong>硬件阻塞（stall）</strong>和<strong>软件插 入（NOP）</strong>两种方法。</li><li>数据旁路技术（转发机制）：通过增加电路（数据旁路），将上一步的 ALU 结果直接送入下一步的 ALU</li><li>编译优化：通过编译器调整指令顺序来解决数据相关。</li></ul></li><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part5/image-20211025102758077.png" alt="image-20211025102758077"></li></ul></li><li>控制相关（控制冲突）<ul><li>当流水线遇到改变 PC 值的指令（如转移指令、CALL、中断）而造成断流时，会引起控制相关。</li><li>解决办法：（由转移指令发生）<ul><li>转移指令预测。简单预测（永远猜true或false）动态预测（根据历史情况动态调整）</li><li>预取转移成功和不成功两个控制流方向上的目标指令（需要增加至能够支持两个方向的寄存器数量）</li><li>加快和提前形成条件码（类似于全加器并行）</li><li>提高转移方向的猜准率</li></ul></li><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part5/image-20211025103223036.png" alt="image-20211025103223036"></li></ul></li></ul><p><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part5/image-20211025103334530.png" alt="image-20211025103334530"></p><h4 id="流水线的分类"><a href="#流水线的分类" class="headerlink" title="流水线的分类"></a>流水线的分类</h4><ul><li>部件功能级、处理机级和处理机间级流水线（流水线使用的级别）<ul><li><strong>部件功能级流水</strong>就是将复杂的算术逻辑运算组成流水线工作方式。例如，可将浮点加法操作分成求阶差、对阶、尾数相加以及结果规格化等4个子过程。</li><li><strong>处理机级流水</strong>是把一条指令解释过程分成多个子过程，如前面提到的取指、译码、执行、访存及写回 5 个子过程。</li><li><strong>处理机间流水</strong>是一种宏流水，其中每一个处理机完成某一专门任务，各个处理机所得到的结果需存放在与下一个处理机所共享的存储器中。</li></ul></li><li>单功能流水线和多功能流水线（流水线可以完成的功能）<ul><li><strong>单功能流水线</strong>指只能实现一种固定的专门功能的流水线</li><li><strong>多功能流水线</strong>指通过各段间的不同连接方式可以同时或不同时地实现多种功能的流水线</li></ul></li><li>动态流水线和静态流水线（同一时间内各段之间的连接方式）<ul><li><strong>静态流水线</strong>指在同一时间内，流水线的各段只能按同一种功能的连接方式工作。</li><li><strong>动态流水线</strong>指在同一时间内，当某些段正在实现某种运算时，另一些段却正在进行另一种运算。这样对提高流水线的效率很有好处，但会使流水线控制变得很复杂。</li></ul></li><li>线性流水线和非线性流水线（各个功能段之间是否有反馈信号）<ul><li><strong>线性流水线</strong>中，从输入到输出，每个功能段只允许经过一次，不存在反馈回路。</li><li><strong>非线性流水线</strong>存在反馈回路，从输入到输出过程中，某些功能段将数次通过流水线，这种流水线适合进行线性递归的运算。</li></ul></li></ul><h4 id="流水线的多发技术"><a href="#流水线的多发技术" class="headerlink" title="流水线的多发技术"></a>流水线的多发技术</h4><ul><li><strong>超标量技术</strong>（空分复用）<ul><li>每个时钟周期内可<strong>并发多条独立指令</strong></li><li>要配置<strong>多个功能部件</strong>（多个 ALU、寄存器组）</li><li><strong>不能调整</strong>指令的<strong>执行顺序</strong>（乱序发射 CPU 可以调整顺序）</li><li>通过编译优化技术，把可并行执行的指令搭配起来</li><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part5/image-20211025105329051.png" alt="image-20211025105329051"></li></ul></li><li><strong>超流水技术</strong>（时分复用）<ul><li>在<strong>一个时钟周期内再分段</strong>（3段）</li><li>在一个时钟周期（机器周期，理想情况下min机器周期-&gt;时钟周期）内<strong>一个功能部件使用多次</strong>（ 3 次）</li><li><strong>不能调整</strong>指令的<strong>执行顺序</strong></li><li>靠编译程序解决优化问题</li><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part5/image-20211025105518773.png" alt="image-20211025105518773"></li></ul></li><li><strong>超长指令字</strong><ul><li>由<strong>编译程序</strong>挖掘出指令间<strong>潜在的并行性</strong></li><li>将<strong>多条能并行操作的指令组合</strong>成 一条</li><li>具有<strong>多个操作码字段</strong>的超长指令字（可达几百位）</li><li>采用<strong>多个处理部件</strong></li></ul></li></ul><h3 id="五段式指令流水线"><a href="#五段式指令流水线" class="headerlink" title="五段式指令流水线"></a>五段式指令流水线</h3><h4 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h4><ul><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part5/image-20211025100227733.png" alt="image-20211025100227733"></li><li>为方便流水线的设计，将每个阶段的耗时取成一样，以最长耗时为准。即此处应将机器周期设置为 100ns。</li><li>流水线<strong>每一个功能段</strong>部件后面都要有一个<strong>缓冲寄存器</strong>，或称为<strong>锁存器</strong>，其作用是<strong>保存本流水段的执行结果</strong>，提供给下一流水段使用。</li><li><strong>① IF 取指 -&gt; ② ID 译码&amp;取数 -&gt; ③ EX 执行 -&gt; ④ M 访存 -&gt; ⑤ WB 写回寄存器</strong></li><li>考试中常见的五类指令：<ul><li><strong>运算类指令</strong>、<strong>LOAD 指令</strong>、<strong>STORE 指令</strong>、<strong>条件转移指令</strong>、<strong>无条件转移指令</strong></li></ul></li></ul><h4 id="运算类指令的执行过程"><a href="#运算类指令的执行过程" class="headerlink" title="运算类指令的执行过程"></a>运算类指令的执行过程</h4><ul><li>IF：根据 PC 从指令 Cache 取指令至 IF 段的锁存器</li><li>ID：取出操作数至 ID 段锁存器</li><li>EX：运算，将结果存入 EX 段锁存器</li><li>M：空段（RISC 指令集不会在运算指令中访问主存，但是这段时间周期是需要消耗的）</li><li>WB：将运算结果写回指定寄存器</li></ul><table><thead><tr><th>运算类指令举例</th><th>指令的汇编格式</th><th>功能</th></tr></thead><tbody><tr><td>加法指令（两个寄存器相加）</td><td>ADD Rs, Rd</td><td>(Rs)+(Rd) -&gt; Rd</td></tr><tr><td>加法指令（寄存器与立即数相加）</td><td>ADD #996, Rd</td><td>996+(Rd) -&gt; Rd</td></tr><tr><td>算数左移指令</td><td>SHL Rd</td><td>(Rd)&lt;&lt;&lt;2 -&gt; Rd</td></tr></tbody></table><blockquote><ul><li>Rs 指源操作数（source）</li><li>Rd 指目的操作数（destination）</li></ul></blockquote><h4 id="LOAD-指令的执行过程"><a href="#LOAD-指令的执行过程" class="headerlink" title="LOAD 指令的执行过程"></a>LOAD 指令的执行过程</h4><ul><li>IF：根据 PC 从指令 Cache 取指令至 IF 段的锁存器</li><li>ID：将基址寄存器的值放到锁存器 A，将偏移量的值放到 Imm</li><li>EX：运算，得到有效地址</li><li>M：从数据 Cache 中取数并放入锁存器</li><li>WB：将取出的数写回寄存器</li><li>LOAD 也需要经过运算，才能得到有效地址</li></ul><table><thead><tr><th>指令的汇编格式</th><th>功能</th></tr></thead><tbody><tr><td>LOAD Rd, 996(Rs) 或 LOAD Rd, mem</td><td>(996+(Rs)) -&gt; Rd 或 (mem) -&gt; Rd</td></tr></tbody></table><blockquote><p>通常，RISC 处理器<strong>只有“取数 LOAD”和“存数 STORE”指令才能访问主存</strong></p></blockquote><h4 id="STORE-指令的执行过程"><a href="#STORE-指令的执行过程" class="headerlink" title="STORE 指令的执行过程"></a>STORE 指令的执行过程</h4><ul><li>IF：根据 PC 从指令 Cache 取指令至 IF 段的锁存器</li><li>ID：将基址寄存器的值放到锁存器 A，将偏移量的值放到 Imm。<strong>将要存的数放到 B</strong></li><li>EX：运算，得到有效地址。并将锁存器 B 的内容放到锁存器 Store。</li><li>M：写入数据 Cache</li><li>WB：空段</li></ul><table><thead><tr><th>指令的汇编格式</th><th>功能</th></tr></thead><tbody><tr><td>STORE Rs, 996(Rd) 或 STORE Rs, mem</td><td>Rs -&gt; (996+(Rd)) 或 Rs -&gt; (mem)</td></tr></tbody></table><h4 id="条件转移指令的执行过程"><a href="#条件转移指令的执行过程" class="headerlink" title="条件转移指令的执行过程"></a>条件转移指令的执行过程</h4><ul><li><p>IF：根据 PC 从指令 Cache 取指令至 IF 段的锁存器</p></li><li><p>ID：进行比较的两个数放入锁存器 A、B；偏移量放入 Imm</p></li><li><p>EX：运算，比较两个数</p></li><li><p>M：将目标 PC 值写回 PC（<strong>修改 PC 值不在写回阶段而是访存阶段</strong>）</p></li><li><p>WB：空段（<strong>写回阶段通常是修改通用寄存器</strong>）</p></li><li><p>转移类指令常采用<strong>相对寻址</strong></p></li><li><p>很多教材把写回 PC 的功能段称为“WrPC 段”，其耗时比 M 段更短，可安排在 M 段时间内完成。</p></li><li><p>通常在 IF 段结束止之后 PC 就会自动 +“1”</p></li></ul><table><thead><tr><th>指令的汇编格式</th><th>功能</th></tr></thead><tbody><tr><td>beq Rs, Rt, #偏移量</td><td>若(Rs)==(Rt)，则**(PC)+指令字长+(偏移量×指令字长) -&gt; PC<strong>；否则</strong>(PC)+指令字长 -&gt; PC**</td></tr><tr><td>bne Rs, Rt, #偏移量</td><td>若(Rs)!=(Rt)，则**(PC)+指令字长+(偏移量×指令字长) -&gt; PC<strong>；否则</strong>(PC)+指令字长 -&gt; PC**</td></tr></tbody></table><h4 id="无条件转移指令的执行过程"><a href="#无条件转移指令的执行过程" class="headerlink" title="无条件转移指令的执行过程"></a>无条件转移指令的执行过程</h4><ul><li>IF：根据 PC 从指令 Cache 取指令至IF段的锁存器</li><li>ID：偏移量放入 Imm</li><li>EX：将目标 PC 值写回 PC（<strong>这里修改 PC 值不在写回阶段而又是在执行阶段</strong>）</li><li>M：空段</li><li>WB：空段</li><li>“WrPC段”耗时比 EX 段更短，可安排在 EX 段时间内完成。<strong>尽早完成 WrPC 段、修改 PC 值，就越能避免控制冲突</strong>。当然，也有的地方会在 WB 段时间内才修改 PC 的值</li><li>偏移量通常采用补码表示</li></ul><table><thead><tr><th>指令的汇编格式</th><th>功能</th></tr></thead><tbody><tr><td>jmp #偏移量</td><td>(PC)+指令字长+(偏移量×指令字长) -&gt; PC</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 计算机组成原理 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>计算机组成原理-Part4</title>
      <link href="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part4/"/>
      <url>/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part4/</url>
      
        <content type="html"><![CDATA[<h1 id="计算机组成原理-Part4——指令系统"><a href="#计算机组成原理-Part4——指令系统" class="headerlink" title="计算机组成原理-Part4——指令系统"></a>计算机组成原理-Part4——指令系统</h1><p>[TOC]</p><h2 id="指令格式"><a href="#指令格式" class="headerlink" title="指令格式"></a>指令格式</h2><h3 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h3><ul><li>指令（机器指令）：一台计算机的所有指令的集合构成该机的<strong>指令系统</strong>，也称为<strong>指令集</strong>。</li><li>一台计算机只能执行自己指令系统中的指令，不能执行其他系统的指令。Eg：x86 架构、ARM架构</li><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part4/image-20211021233141411.png" alt="image-20211021233141411"></li></ul><h3 id="根据地址码数目不同分类"><a href="#根据地址码数目不同分类" class="headerlink" title="根据地址码数目不同分类"></a>根据地址码数目不同分类</h3><ul><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part4/image-20211021235538544.png" alt="image-20211021235538544"></li><li>一条指令可能包含不同数量的地址码</li><li>零地址指令<ul><li>不需要操作数，如空操作、停机、关中断等指令             </li></ul></li><li>一地址指令<ul><li>只需要单操作数，如加1、减1、取反、求补等<ul><li>指令含义：OP(A1) -&gt; A1 ，完成一条指令需要 3 次访存：<strong>取指 -&gt; 读A1 -&gt; 写A1</strong></li></ul></li><li>需要两个操作数，但其中一个操作数隐含在某个寄存器（如隐含在ACC）<ul><li>指令含义： (ACC)OP(A1) -&gt; ACC，完成一条指令需要2次访存：<strong>取指 -&gt; 读A1</strong></li></ul></li><li>注：A1 指某个主存地址， (A1)表示 A1 所指向的地址中的内容</li></ul></li><li>二地址指令<ul><li>常用于需要两个操作数的算术运算、逻辑运算相关指令</li><li>指令含义：(A1)OP(A2) -&gt; A1</li><li>完成一条指令需要访存 4 次，<strong>取指 -&gt; 读A1 -&gt; 读A2 -&gt; 写A1</strong></li></ul></li><li>三地址指令<ul><li>常用于需要两个操作数的算术运算、逻辑运算相关指令</li><li>指令含义：(A1)OP(A2) -&gt; A3</li><li>完成一条指令需要访存 4 次，<strong>取指 -&gt; 读A1 -&gt; 读A2 -&gt; 写A3</strong></li></ul></li><li>四地址指令<ul><li>指令含义：(A1)OP(A2) -&gt; A3，A4=下一条将要执行指令的地址</li><li>完成一条指令需要访存 4 次，<strong>取指 -&gt; 读A1 -&gt; 读A2 -&gt; 写A3</strong></li></ul></li><li><strong>若指令总长度固定不变，则地址码数量越多，寻址能力越差</strong></li></ul><h3 id="根据指令长度分类"><a href="#根据指令长度分类" class="headerlink" title="根据指令长度分类"></a>根据指令长度分类</h3><ul><li><strong>指令字长</strong>：一条指令的总长度（可能会变）<ul><li>机器字长：CPU进行一次整数运算所能处理的二进制数据的位数（通常和ALU直接相关）</li><li>存储字长：一个存储单元中的二进制代码位数（通常和MDR位数相同）</li><li>半字长指令、单字长指令、双字长指令——指令长度是机器字长的 n 倍</li><li>指令字长会影响取指令所需时间。如：机器字长=存储字长=16bit，则取一条双字长指令需要两次访存</li></ul></li><li><strong>定长指令字结构</strong>：指令系统中所有指令的长度都相等</li><li><strong>变长指令字结构</strong>：指令系统中各种指令的长度不等</li></ul><h3 id="根据操作码长度分类"><a href="#根据操作码长度分类" class="headerlink" title="根据操作码长度分类"></a>根据操作码长度分类</h3><ul><li><strong>定长操作码</strong>：指令系统中所有指令的操作码长度都相同<ul><li>控制器的译码电路设计简单，但灵活性较低</li><li>n 位 -&gt; 2^n^ 条指令</li><li>优：定长操作码对于简化计算机硬件设计，提高指令译码和识别速度很有利；</li><li>缺：指令数量增加时会占用更多固定位，留给表示操作数地址的位数受限。</li></ul></li><li><strong>可变长操作码</strong>：指令系统中各指令的操作码长度可变<ul><li>控制器的译码电路设计复杂， 但灵活性较高</li><li>不同地址数的指令可以具有不同长度的操作码，从而在满足需要的前提下，有效地缩短指令字长。</li><li>优： 在指令字长有限的前提下仍保持比较丰富的指令种类；</li><li>缺 ：增加了指令译码和分析的难度，使控制器的设计复杂化。</li></ul></li><li><strong>定长指令字结构+可变长操作码</strong> -&gt; <strong>扩展操作码指令格式</strong><ul><li>不同地址数的指令使用不同长度的操作码</li></ul></li></ul><h3 id="根据操作类型分类"><a href="#根据操作类型分类" class="headerlink" title="根据操作类型分类"></a>根据操作类型分类</h3><ul><li>数据传送类：进行主存与CPU之间的数据传送<ol><li>数据传送<ul><li>LOAD：把<strong>存储器</strong>中的数据放到<strong>寄存器</strong>中</li><li>STORE：把<strong>寄存器</strong>中的数据放到<strong>存储器</strong>中</li></ul></li></ol></li><li>运算类<ol start="2"><li>算术逻辑操作<ul><li>算术：加、减、乘、除、增 1、减 1、求补、浮点运算、十进制运算</li><li>逻辑：与、或、非、异或、位操作、位测试、位清除、位求反</li></ul></li><li>移位操作<ul><li>算术移位、逻辑移位、循环移位(带进位和不带进位)</li></ul></li></ol></li><li>程序控制类：改变程序执行的顺序<ol start="4"><li>转移操作<ul><li>无条件转移 JMP</li><li>条件转移 JZ：结果为 0；JO：结果溢出；JC：结果有进位</li><li>调用和返回 CALL 和 RETURN</li><li>陷阱(Trap)与陷阱指令</li></ul></li></ol></li><li>输入输出类（I/O）：进行CPU和I/O设备之间的数据传送<ol start="5"><li>输入输出操作<ul><li>CPU 寄存器与 IO 端口之间的数据传送（端口即 IO 接口中的寄存器）</li></ul></li></ol></li></ul><h2 id="扩展操作码指令格式"><a href="#扩展操作码指令格式" class="headerlink" title="扩展操作码指令格式"></a>扩展操作码指令格式</h2><ul><li>扩展操作码：定长指令字结构+可变长操作码</li><li>设计扩展操作码指令格式的注意点：<ul><li>不允许短码是长码的前缀。</li><li>各指令的操作码一定不能重复。</li></ul></li><li>通常情况下，对使用频率较高的指令，分配较短的操作码；对使用频率较低的指令，分配较长的操作码。从而尽可能减少指令译码和分析的时间。</li><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part4/image-20211022102529044.png" alt="image-20211022102529044"></li><li>设地址长度为 n，上一层留出 m 种状态，则下一层可扩展出 m×2^n^ 种状态</li></ul><h2 id="指令寻址"><a href="#指令寻址" class="headerlink" title="指令寻址"></a>指令寻址</h2><h3 id="顺序寻址"><a href="#顺序寻址" class="headerlink" title="顺序寻址"></a>顺序寻址</h3><ul><li>指令寻址：下一条欲执行指令的地址（<strong>始终由程序计数器PC给出</strong>）</li><li>顺序寻址：( PC ) + “1” -&gt; PC</li><li><strong>这里的“1”理解为 1 个指令的字长</strong>，实际加的值会因<strong>指令长度</strong>、<strong>编址方式</strong>而不同<ul><li><strong>定长</strong>指令字结构 + 按<strong>字</strong>编址 + 指令字长=存储字长=16bit=2B：每次 PC + 1 </li><li><strong>定长</strong>指令字结构 + 按<strong>字节</strong>编址 + 指令字长=存储字长=16bit=2B：每次 PC + 2</li><li><strong>变长</strong>指令字结构 + 按<strong>字节</strong>编址 + 指令字长!=存储字长=16bit=2B：每次 PC + n<ul><li>根据指令的类型，CPU 可能还要进行多次访存，<strong>每次读入一个字</strong></li><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part4/image-20211022130853433.png" alt="image-20211022130853433" style="zoom:80%;"></li></ul></li></ul></li></ul><h3 id="跳跃寻址"><a href="#跳跃寻址" class="headerlink" title="跳跃寻址"></a>跳跃寻址</h3><ul><li>跳跃寻址：由转移指令指出</li><li>CPU 与 PC 之间的顺序：<ul><li>CPU 取出 PC 中存储的指令</li><li>PC += 1</li><li>CPU 执行取出的指令<ul><li>如果是执行转移指令，则修改 PC 内容</li></ul></li><li>CPU 取出 PC 中存储的指令。Loop</li></ul></li><li>每一条指令的执行都分为 “取指令”、“执行指令” 两个阶段</li><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part4/image-20211022131031340.png" alt="image-20211022131031340"></li></ul><h2 id="数据寻址"><a href="#数据寻址" class="headerlink" title="数据寻址"></a>数据寻址</h2><h3 id="指令寻址-v-s-数据寻址"><a href="#指令寻址-v-s-数据寻址" class="headerlink" title="指令寻址 v.s. 数据寻址"></a>指令寻址 v.s. 数据寻址</h3><ul><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part4/image-20211022132436880.png" alt="image-20211022132436880"></li><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part4/image-20211022132520543.png" alt="image-20211022132520543"></li><li>求出操作数的真实地址，称为有效地址（EA）。</li></ul><h3 id="直接与间接寻址"><a href="#直接与间接寻址" class="headerlink" title="直接与间接寻址"></a>直接与间接寻址</h3><h4 id="直接寻址"><a href="#直接寻址" class="headerlink" title="直接寻址"></a>直接寻址</h4><ul><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part4/image-20211022133342005.png" alt="image-20211022133342005" style="zoom:80%;"></li><li>直接寻址：指令字中的<strong>形式地址 A 就是操作数的真实地址 EA(effective address)**，即 **EA=A</strong> 。</li><li>共访存 <strong>2</strong> 次：取指令访存1次；执行指令访存 1 次。</li><li>优点：<ul><li>简单，指令执行阶段仅访问一次主存，不需专门计算操作数的地址。</li></ul></li><li>缺点：<ul><li>A 的位数决定了该指令操作数的寻址范围。</li><li>操作数的地址不易修改。</li></ul></li></ul><h4 id="间接寻址"><a href="#间接寻址" class="headerlink" title="间接寻址"></a>间接寻址</h4><ul><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part4/image-20211022134527227.png" alt="image-20211022134527227" style="zoom:80%;"></li><li>间接寻址：指令的地址字段给出的形式地址是<strong>操作数有效地址所在的存储单元的地址</strong>，也就是操作数地址的地址，即 <strong>EA=(A)</strong> 。</li><li>共访存 <strong>3</strong> 次：取指令访存 1 次；执行指令访存 2 次。</li><li>优点：<ul><li>可扩大寻址范围（有效地址 EA 的位数大于形式地址 A 的位数）。</li><li>便于编制程序（用间接寻址可以方便地完成子程序返回）。</li></ul></li><li>缺点：<ul><li>指令在执行阶段要多次访存（一次间址需两次访存，多次寻址需根据存储字的最高位确定几次访存）。</li></ul></li></ul><h4 id="寄存器寻址"><a href="#寄存器寻址" class="headerlink" title="寄存器寻址"></a>寄存器寻址</h4><ul><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part4/image-20211022135027732.png" alt="image-20211022135027732" style="zoom:80%;"></li><li>寄存器寻址：在指令字中直接给出操作数所在的寄存器编号，即 **EA=R<del>i</del>**，其操作数在由 R<del>i</del> 所指的寄存器内。</li><li>共访存 <strong>1</strong> 次：取指令访存 1 次；执行指令访存 0 次。</li><li>优点：<ul><li>指令在<strong>执行阶段</strong>不访问主存，<strong>只访问寄存器</strong></li><li>指令字短且执行速度快，支持<strong>向量/矩阵运算</strong>。</li></ul></li><li>缺点：<ul><li>寄存器价格昂贵，计算机中寄存器个数有限 。</li></ul></li></ul><h4 id="寄存器间接寻址"><a href="#寄存器间接寻址" class="headerlink" title="寄存器间接寻址"></a>寄存器间接寻址</h4><ul><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part4/image-20211022135538548.png" alt="image-20211022135538548" style="zoom:80%;"></li><li>寄存器间接寻址：寄存器 R<del>i</del> 中给出的不是一个操作数，而是<strong>操作数所在主存单元的地址</strong>，即 <strong>EA=(R<del>i</del>)</strong> 。</li><li>共访存 <strong>2</strong> 次：取指令访存 1 次；执行指令访存 1 次。</li><li>特点：<ul><li>与一般间接寻址相比速度更快，但指令的执行阶段需要访问主存（因为操作数在主存中）。</li></ul></li></ul><h4 id="隐含寻址"><a href="#隐含寻址" class="headerlink" title="隐含寻址"></a>隐含寻址</h4><ul><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part4/image-20211022135948636.png" alt="image-20211022135948636" style="zoom:80%;"></li><li>隐含寻址：不是明显地给出操作数的地址，而是在指令中隐含着操作数的地址。</li><li>共访存 <strong>1</strong> 次：取指令访存 1 次；执行指令访存 0 次。</li><li>优点：有利于缩短指令字长。</li><li>缺点：需增加存储操作数或隐含地址的硬件。</li></ul><h4 id="立即寻址"><a href="#立即寻址" class="headerlink" title="立即寻址"></a>立即寻址</h4><ul><li>立即寻址：形式地址 A 就是<strong>操作数本身</strong>，又称为立即数，一般采用补码形式。“#”表示立即寻址特征。</li><li>共访存 <strong>1</strong> 次：取指令访存 1 次；执行指令访存 0 次。</li><li>优点：指令执行阶段不访问主存，<strong>指令执行时间最短</strong></li><li>缺点：A 的位数限制了立即数的范围。<ul><li>如 A 的位数为 n，且立即数采用补码时，可表示的数据范围为：−2^n-1^ ～ 2^n-1^−1</li></ul></li></ul><h3 id="偏移寻址"><a href="#偏移寻址" class="headerlink" title="偏移寻址"></a>偏移寻址</h3><h4 id="基址寻址（多道程序）"><a href="#基址寻址（多道程序）" class="headerlink" title="基址寻址（多道程序）"></a>基址寻址（多道程序）</h4><ul><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part4/image-20211022142356006.png" alt="image-20211022142356006"></li><li>基址寻址：将 CPU 中基址寄存器（base address register，BR）的内容加上指令格式中的形式地址 A，而形成操作数的有效地址，即 <strong>EA=(BR)+A</strong>。<ul><li>操作系统第三章第一节学习，OS 课中的“重定位寄存器”就是“基址寄存器”</li><li>程序运行前，CPU 将 BR 的值修改为该程序的起始地址（存在操作系统 PCB 中）</li></ul></li><li>基址寄存器是<strong>面向操作系统</strong>的，<strong>其内容仅由操作系统或管理程序确定，对于程序员是透明的</strong>。<ul><li>基址寄存器的内容不变（作为基地址），形式地址可变（作为偏移量）。</li><li>当采用通用寄存器作为基址寄存器时，可由<strong>用户决定哪个寄存器作为基址寄存器</strong>，但其<strong>内容仍由操作系统确定</strong>。</li></ul></li><li>优点：<ul><li>便于程序在内存里的地址浮动，方便实现<strong>多道程序</strong>并发运行</li><li>可扩大寻址范围（基址寄存器的位数大于形式地址的位数）</li><li>用户<strong>不必考虑自己的程序存于主存的哪一空间区域</strong>，故<strong>有利于多道程序设计</strong></li></ul></li></ul><h4 id="变址寻址（循环程序）"><a href="#变址寻址（循环程序）" class="headerlink" title="变址寻址（循环程序）"></a>变址寻址（循环程序）</h4><ul><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part4/image-20211022181842393.png" alt="image-20211022181842393"></li><li>变址寻址：有效地址 EA 等于指令字中的形式地址 A 与变址寄存器 IX 的内容相加之和，即 <strong>EA=(IX)+A</strong>。其中 <strong>IX 可为变址寄存器（专用）</strong>，也<strong>可用通用寄存器作为变址寄存器</strong>。</li><li>变址寄存器是<strong>面向用户</strong>的，<strong>变址寄存器的内容可由用户改变</strong><ul><li>基址寄存器的内容不变（作为偏移量），形式地址可变（作为基地址）。</li></ul></li><li>优点：<ul><li>在数组处理过程中，可设定 A 为数组的首地址，不断改变变址寄存器 IX(index register) 的内容，便可很容易地表示数组中任一数据的地址，<strong>适合编制循环程序</strong>。</li></ul></li><li>两者同样可以一起使用——基址&amp;变址复合寻址</li></ul><h4 id="相对寻址（转移指令）"><a href="#相对寻址（转移指令）" class="headerlink" title="相对寻址（转移指令）"></a>相对寻址（转移指令）</h4><ul><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part4/image-20211022185157913.png" alt="image-20211022185157913"></li><li>相对寻址：把程序计数器 PC 的内容加上指令格式中的形式地址 A 而形成操作数的有效地址，即 <strong>EA=(PC)+A</strong>。<ul><li><strong>A 是相对于下一条指令（PC 所指地址）的偏移量</strong>，可正可负，<strong>补码表示</strong> 。因为 PC 会在取出指令后立刻加一。</li></ul></li><li>优点：<ul><li>便于一段代码在程序内部的浮动。</li></ul></li><li>相对寻址广泛应<strong>用于转移指令</strong>。</li></ul><h3 id="堆栈寻址"><a href="#堆栈寻址" class="headerlink" title="堆栈寻址"></a>堆栈寻址</h3><h4 id="堆栈寻址-1"><a href="#堆栈寻址-1" class="headerlink" title="堆栈寻址"></a>堆栈寻址</h4><ul><li>堆栈寻址：操作数存放在堆栈中，隐含使用堆栈指针（Stack Pointer, SP）作为操作数地址。</li><li>堆栈是一块按“后进先出（LIFO）”原则管理的存储区，该存储区中被读/写单元的地址是用堆栈指针给出的。</li><li>堆栈可以由寄存器组（硬堆栈，成本高）或者主存中划分一块区域（软堆栈，成本低）实现。</li><li>有堆栈才可以方便地实现保护现场、调用函数。</li></ul><h3 id="数据寻址总结"><a href="#数据寻址总结" class="headerlink" title="数据寻址总结"></a>数据寻址总结</h3><table><thead><tr><th>寻址方式</th><th>有效地址</th><th>访存次数（指令执行期间）</th></tr></thead><tbody><tr><td>直接寻址</td><td>EA=A</td><td>1</td></tr><tr><td>一次间接寻址</td><td>EA=(A)</td><td>2</td></tr><tr><td>寄存器寻址</td><td>EA=R<del>i</del></td><td>0</td></tr><tr><td>寄存器间接一次寻址</td><td>EA=(R<del>i</del>)</td><td>1</td></tr><tr><td>隐含寻址</td><td>程序指定</td><td>0</td></tr><tr><td>立即寻址</td><td>A 即是操作数</td><td>0</td></tr><tr><td>基址寻址</td><td>EA=(BR)+A</td><td>1</td></tr><tr><td>变址寻址</td><td>EA=(IX)+A</td><td>1</td></tr><tr><td>相对寻址</td><td>EA=(PC)+A</td><td>1</td></tr><tr><td>堆栈寻址</td><td>入栈/出栈时 EA 的确定方式不同</td><td>硬堆栈不访存，软堆栈访存1次</td></tr></tbody></table><h2 id="CISC-和-RISC"><a href="#CISC-和-RISC" class="headerlink" title="CISC 和 RISC"></a>CISC 和 RISC</h2><ul><li>CISC：Complex Instruction Set Computer<ul><li>设计思路：一条指令完成一个复杂的基本功能。</li></ul></li><li>RISC：Reduced Instruction Set Computer<ul><li>设计思路：一条指令完成一个基本“动作”；多条指令组合完成一个复杂的基本功能。</li></ul></li></ul><table><thead><tr><th>对比项目</th><th>CISC</th><th>RISC</th></tr></thead><tbody><tr><td>指令系统</td><td>复杂</td><td>简单</td></tr><tr><td>代表</td><td>x86 架构</td><td>ARM 架构</td></tr><tr><td>指令数目</td><td>一般大于 200 条</td><td>一般小于 100 条</td></tr><tr><td>指令字长</td><td>不固定</td><td>定长</td></tr><tr><td>可访存指令</td><td>不加限制</td><td>有 Load/Store 指令</td></tr><tr><td>各指令执行时间</td><td>相差较大</td><td>大部分在一个周期内</td></tr><tr><td>各指令执行频率</td><td>相差较大</td><td>都比较常用</td></tr><tr><td>通用寄存器数量</td><td>较少</td><td>多</td></tr><tr><td>目标代码</td><td>难以用优化编译提高程序效率</td><td>可以用优化编译提高程序效率</td></tr><tr><td>控制方式</td><td>大部分为微程序控制（更慢）</td><td>大部分为组合逻辑控制（更快）</td></tr><tr><td>指令流水线</td><td>可以实现</td><td>必须实现</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 计算机组成原理 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>计算机组成原理-Part3</title>
      <link href="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part3/"/>
      <url>/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part3/</url>
      
        <content type="html"><![CDATA[<h1 id="计算机组成原理-Part3——存储系统"><a href="#计算机组成原理-Part3——存储系统" class="headerlink" title="计算机组成原理-Part3——存储系统"></a>计算机组成原理-Part3——存储系统</h1><p>[TOC]</p><h2 id="存储系统基本概念"><a href="#存储系统基本概念" class="headerlink" title="存储系统基本概念"></a>存储系统基本概念</h2><h3 id="存储器的层次结构"><a href="#存储器的层次结构" class="headerlink" title="存储器的层次结构"></a>存储器的层次结构</h3><ul><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part3/image-20211018200033029.png" alt="image-20211018200033029"></li><li>辅存中的数据要调入主存后才能被 CPU 访问</li><li>主存—辅存：实现虚拟存储系统，<strong>解决了主存容量不够的问题</strong></li><li>Cache—主存：<strong>解决了主存与 CPU 速度不匹配的问题</strong></li></ul><h3 id="存储器的分类"><a href="#存储器的分类" class="headerlink" title="存储器的分类"></a>存储器的分类</h3><ol><li>层次：<ul><li>高速缓存（Cache）</li><li>主存储器（主存、内存）</li><li>辅助存储器（辅存、外存）</li></ul></li><li>存储介质：<ul><li>半导体存储器（主存、Cache）</li><li>磁表面存储器（磁盘、磁带）</li><li>光存储器（光盘）</li></ul></li><li>存取方式：<ul><li><strong>随机存取存储器</strong>（Random Access Memory，RAM）（内存）<ul><li>只读存储器 ROM 也是随机存取方式</li></ul></li><li>串行访问存储器：读写某个存储单元所需时间与存储单元的物理位置有关<ul><li>顺序存取存储器（Sequential Access Memory，SAM）（磁带）：读写一个存储单元所需时间取决于存储单元所在的物理位置</li><li>直接存取存储器（Direct Access Memory，DAM）（磁盘）：既有随机存取特性，也有顺序存取特性。先直接选取信息所在区域，然后按顺序方式存取。</li></ul></li><li>相联存储器（Associative Memory），即可按内容访问的存储器（Content Addressed Memory，CAM）：可以按照内容检索到存储位置进行读写，“快表”就是一种相联存储器。</li></ul></li><li>信息的可更改性：<ul><li>读写存储器（Read/Write Memory）：即可读、也可写（磁盘、内存、Cache）</li><li>只读存储器（Read Only Memory）：只能读，不能写（实体音乐专辑通常采用 CD-ROM、实体电影采用蓝光光碟、BIOS 通常写在 ROM 中）</li></ul></li><li>信息的可保存性：<ul><li>断电后，存储信息消失的存储器——易失性存储器（主存、Cache）</li><li>断电后，存储信息依然保持的存储器——非易失性存储器（磁盘、光盘）</li><li>信息读出后，原存储信息被破坏——破坏性读出（如 DRAM 芯片，读出数据后要进行重写）</li><li>信息读出后，原存储信息不被破坏——非破坏性读出（如 SRAM 芯片、磁盘、光盘）</li></ul></li></ol><h3 id="存储器的性能指标"><a href="#存储器的性能指标" class="headerlink" title="存储器的性能指标"></a>存储器的性能指标</h3><ol><li>存储容量：存储字数（MDR）×字长（MAR）。</li><li>单位成本：每位价格=总成本/总容量。（每个 bit 位的成本）</li><li>存储速度：数据传输率=数据的宽度/存储周期。<ul><li>数据的宽度=存储字长</li><li>数据传输率=主存带宽</li></ul></li></ol><p><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part3/image-20211018202338820.png" alt="image-20211018202338820"></p><ul><li><strong>存取时间</strong>（T<del>a</del>）：指从启动一次存储器操作到完成该操作所经历的时间，分为读出时间和写入时间。</li><li><strong>存取周期</strong>（T<del>m</del>）：又称<strong>读写周期</strong>或<strong>访问周期</strong>。它是指存储器进行一次完整的读写操作所需的全部时间，即连续两次独立地访问存储器操作（读或写操作）之间所需的最小时间间隔。<ul><li><strong>存取周期=存取时间+恢复时间</strong></li></ul></li><li><strong>主存带宽</strong>（B<del>m</del>）：又称<strong>数据传输率</strong>，表示每秒从主存进出信息的最大数量，单位为字/秒、字节/秒（B/s）或位/秒（b/s）。</li></ul><h2 id="主存储器的基本组成"><a href="#主存储器的基本组成" class="headerlink" title="主存储器的基本组成"></a>主存储器的基本组成</h2><h3 id="半导体元件的原理"><a href="#半导体元件的原理" class="headerlink" title="半导体元件的原理"></a>半导体元件的原理</h3><ul><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part3/image-20211018203602384.png" alt="image-20211018203602384"></li><li>MOS 管相当于一种电控开关，输入电压达到某个阈值时，MOS 管就可以接通</li><li>之所以是<strong>按存储字读写</strong>，是因为<strong>一个存储单元共用一条线来控制 MOS 管</strong>，只能同时读取或同时写入一个字</li></ul><h3 id="存储芯片的基本原理"><a href="#存储芯片的基本原理" class="headerlink" title="存储芯片的基本原理"></a>存储芯片的基本原理</h3><ul><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part3/image-20211018204801463.png" alt="image-20211018204801463"></li><li>头上划线表示该信号低电平有效</li><li>引脚与数据线<ul><li>地址线</li><li>数据线</li><li>片选线：一块内存条可能有多块存储芯片<ul><li>CS：Chip-Select；CE：Chip-Enable（两种表示方式皆可，当有上划线则表示低电平有效）</li><li>对选中存储芯片的片选线给予低电平，对未选中的给予高电平</li></ul></li><li>读写线<ul><li>当使用不同数量的读写线，则对外暴露的引脚是不一样的</li><li>使用 WE(Write Enable)、OE，则两根读写线</li><li>使用 WE或WR 则一根读写线（低电平写，高电平读）</li></ul></li></ul></li><li>译码器驱动电路：将地址信号转化成字选通线的高低电平</li><li>存储矩阵（存储体）：由多个存储单元构成，每个存储单元又由多个存储元构成</li></ul><h3 id="如何实现不同的寻址方式"><a href="#如何实现不同的寻址方式" class="headerlink" title="如何实现不同的寻址方式"></a>如何实现不同的寻址方式</h3><ul><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part3/image-20211018223923446.png" alt="image-20211018223923446"></li><li>一般以<strong>字节</strong>编址，即每个字节对应一个地址。同时也能够支持按半字、字、双字寻址</li><li>存储单元的长度并不影响按何种方式寻址，但是一次读写数据必须按字为单位</li><li>n 根地址线能够寻 2^n^ 个存储单元</li></ul><h2 id="SRAM-和-DRAM"><a href="#SRAM-和-DRAM" class="headerlink" title="SRAM 和 DRAM"></a>SRAM 和 DRAM</h2><ul><li>随机存取存储器（Random Access Memory，RAM）<ul><li>Dynamic Random Access Memory，即动态RAM</li><li>Static Random Access Memory，即静态RAM</li><li><strong>DRAM</strong> 用于<strong>主存</strong>；<strong>SRAM</strong> 用于 <strong>Cache</strong></li></ul></li><li>核心区别：<strong>存储元不一样</strong><ul><li>DRAM芯片：使用<strong>栅极电容</strong>存储信息</li><li>SRAM芯片：使用<strong>双稳态触发器</strong>存储信息</li></ul></li></ul><h3 id="存储元件不同导致的特性差异"><a href="#存储元件不同导致的特性差异" class="headerlink" title="存储元件不同导致的特性差异"></a>存储元件不同导致的特性差异</h3><h4 id="栅极电容"><a href="#栅极电容" class="headerlink" title="栅极电容"></a>栅极电容</h4><p><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part3/image-20211019205541116.png" alt="image-20211019205541116"></p><ul><li>存储状态<ul><li>1：电容内存储了电荷</li><li>0：电容内未存储电荷</li></ul></li><li>读出状态<ul><li>读出 1：MOS 管接通，电容放电，数据线上产生电流</li><li>读出 0：MOS 管接通后，数据线上无电流</li></ul></li><li>特点<ul><li>电容放电信息被破坏，是<strong>破坏性读出</strong>。所以，读出后应有<strong>重写</strong>操作，也称“再生”</li><li>读写速度<strong>更慢</strong></li><li><strong>制造成本更低，集成度高，功耗低</strong></li></ul></li></ul><h4 id="双稳态触发器"><a href="#双稳态触发器" class="headerlink" title="双稳态触发器"></a>双稳态触发器</h4><p><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part3/image-20211019205912531.png" alt="image-20211019205912531"></p><ul><li>存储状态<ul><li>1：A 高电平 B 低电平</li><li>0：A 低电平 B 高电平</li></ul></li><li>读出状态<ul><li>读出 0：BL 为低电平，BLX 无信号</li><li>读出 1：BLX 为低电平，BL 无信号</li></ul></li><li>特点<ul><li>读出数据，触发器状态保持稳定，是<strong>非破坏性读出</strong>，<strong>无需重写</strong></li><li>读写速度<strong>更快</strong></li><li><strong>制造成本更高，集成度低，功耗大</strong></li></ul></li></ul><h4 id="DRAM-和-SRAM-对比（高频）"><a href="#DRAM-和-SRAM-对比（高频）" class="headerlink" title="DRAM 和 SRAM 对比（高频）"></a>DRAM 和 SRAM 对比（高频）</h4><table><thead><tr><th>类型特点</th><th>SRAM（静态 RAM）</th><th>DRAM（动态 RAM）</th></tr></thead><tbody><tr><td>存储信息</td><td>触发器</td><td>电容</td></tr><tr><td>破坏性读出</td><td>否</td><td>是</td></tr><tr><td>读出后需要重写</td><td>否</td><td>是</td></tr><tr><td>运行速度</td><td>快</td><td>man</td></tr><tr><td>集成度</td><td>低</td><td>高</td></tr><tr><td>发热量</td><td>大</td><td>小</td></tr><tr><td>存储成本</td><td>高</td><td>低</td></tr><tr><td>易失/非易失性存储器</td><td>易失（断电后丢失信息）</td><td>易失（断电后丢失信息）</td></tr><tr><td>需要刷新</td><td>不需要</td><td>需要</td></tr><tr><td>送行列地址</td><td>同时送</td><td>分两次送</td></tr><tr><td>常用与制作</td><td>Cache</td><td>主存</td></tr></tbody></table><h3 id="DRAM-的刷新"><a href="#DRAM-的刷新" class="headerlink" title="DRAM 的刷新"></a>DRAM 的刷新</h3><p><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part3/image-20211019220838787.png" alt="image-20211019220838787"></p><ul><li><p>为什么刷新？</p><ul><li>双稳态（静态RAM，SRAM）只要不断电，触发器的状态就不会改变。所以<strong>不需要刷新</strong>。</li><li>栅极电容（动态RAM，DRAM）电容内的电荷只能维持 2ms。即便不断电，2ms 后信息也会消失。所以，2ms 之内必须“刷新”一次（给电容充电）</li></ul></li><li><p>多久需要刷新一次？刷新周期：若题目没有指明，则一般为 <strong>2ms</strong></p></li><li><p>每次刷新多少存储单元？以行为单位，<strong>每次刷新一行存储单元</strong></p><ul><li>为什么要用行列地址？<strong>减少选通线的数量</strong>。拆分为行列地址（<strong>DRAM行、列地址等长</strong>）</li></ul></li><li><p>如何刷新？有硬件支持，读出一行的信息后重新写入，<strong>占用1个读/写周期（存取周期）</strong></p></li><li><p>在什么时刻刷新？</p><ul><li>假设 DRAM 内部结构排列成 128×128 的形式，读/写周期 0.5us。2ms 共 <code>2ms / 0.5us = 4000</code> 个周期</li></ul></li><li><p><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part3/image-20211019215622587.png" alt="image-20211019215622587"></p></li><li><p>“刷新”由存储器独立完成，不需要 CPU 控制。</p></li></ul><h3 id="DRAM-的地址线复用技术"><a href="#DRAM-的地址线复用技术" class="headerlink" title="DRAM 的地址线复用技术"></a>DRAM 的地址线复用技术</h3><ul><li><strong>SRAM 同时送行列地址</strong>；<strong>DRAM 分两次送行列地址</strong>。</li><li>同时送指的是将地址的前后两部分同时送给行地址译码器和列地址译码器。这样的话，<strong>地址有 n 位，就要设计 n 根地址线</strong></li><li>但是 DRAM 的存储容量较大。所以将<strong>地址线、引脚减半</strong>，先将<strong>前半部分送入行地址缓冲器</strong>，再将<strong>后半部分送入列地址缓冲器</strong></li></ul><h2 id="只读存储器-ROM"><a href="#只读存储器-ROM" class="headerlink" title="只读存储器 ROM"></a>只读存储器 ROM</h2><h3 id="各种-ROM"><a href="#各种-ROM" class="headerlink" title="各种 ROM"></a>各种 ROM</h3><ol><li><strong>MROM（Mask Read-Only Memory）</strong>——掩模式只读存储器<ul><li>厂家按照客户需求，在芯片生产过程中直接写入信息，之后<strong>任何人不可重写</strong>（只能读出）</li><li>可靠性高、灵活性差、生产周期长、只适合批量定制</li></ul></li><li><strong>PROM（Programmable Read-Only Memory）</strong>——可编程只读存储器<ul><li>用户可用专门的PROM写入器写入信息，<strong>写一次之后就不可更改</strong></li></ul></li><li><strong>EPROM（Erasable Programmable Read-Only Memory）</strong>——可擦除可编程只读存储器<ul><li>允许用户写入信息，之后用某种方法擦除数据，<strong>修改次数有限，写入时间很长</strong></li><li>UVEPROM（ultraviolet rays）——用紫外线照射8~20分钟，<strong>擦除所有信息</strong></li><li>EEPROM（也常记为E2 PROM，第一个E是Electrically）——可用“电擦除”的方式，<strong>擦除特定的字</strong></li></ul></li><li><strong>Flash Memory</strong> ——闪速存储器（注：U盘、SD卡就是闪存）<ul><li>在EEPROM 基础上发展而来，断电后也能保存信息，且<strong>可进行多次快速擦除重写</strong></li><li>注意：由于闪存需要先擦除在写入，因此<strong>闪存的“写”速度要比“读”速度更慢</strong>。</li><li>每个存储元只需单个MOS管，位密度比RAM高</li></ul></li><li><strong>SSD（Solid State Drives）</strong>—— 固态硬盘<ul><li>由控制单元+存储单元（Flash 芯片）构成，与闪速存储器的核心区别在于控制单元不一样，但存储介质都类似，<strong>可进行多次快速擦除重写</strong>。</li><li>SSD速度快、功耗低、价格高。</li><li>手机辅存也使用Flash 芯片，但相比SSD使用的芯片集成度高、功耗低、价格贵</li></ul></li></ol><ul><li>很多 ROM 芯片虽然名字是“Read-Only”，但<strong>很多 ROM 也可以“写”</strong></li><li>RAM（Random Access Memory）芯片是易失性的，ROM（Read-Only Memory）芯片是非易失性的。<strong>很多 ROM 也具有“随机存取”的特性</strong></li></ul><h3 id="计算机内的重要-ROM"><a href="#计算机内的重要-ROM" class="headerlink" title="计算机内的重要 ROM"></a>计算机内的重要 ROM</h3><ul><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part3/image-20211019223754947.png" alt="image-20211019223754947"></li><li>针对问题<ul><li>断电后，RAM内数据全部丢失</li><li>操作系统安装在辅存</li></ul></li><li><strong>主板上的</strong> BIOS 芯片（ROM），存储了“自举装入程序”，负责引导装入操作系统（开机）</li><li>逻辑上，<strong>主存由 RAM+ROM 组成</strong>，且二者常统一编址</li><li>我们常说“内存条”就是“主存”，但事实上，主板上的 ROM 芯片也是“主存”的一部分</li></ul><h2 id="主存储器与-CPU-的连接"><a href="#主存储器与-CPU-的连接" class="headerlink" title="主存储器与 CPU 的连接"></a>主存储器与 CPU 的连接</h2><h3 id="单块存储芯片与-CPU-的连接"><a href="#单块存储芯片与-CPU-的连接" class="headerlink" title="单块存储芯片与 CPU 的连接"></a>单块存储芯片与 CPU 的连接</h3><ul><li><p>针对问题：想要扩展主存<strong>字数</strong></p><ul><li>改进方向：<strong>字扩展</strong></li><li>连接多块存储芯片来扩展主存字数</li></ul></li><li><p>针对问题：想要扩展<strong>存储字长</strong></p><ul><li>改进方向：<strong>位扩展</strong></li><li>一个存储字长是 8bit，而数据总线一般有 64bit</li><li>为了尽可能发挥数据总线的性能，要保持<strong>数据总线宽度=存储字长</strong>，提高一次读写的数据量</li></ul></li><li><p>现在 MDR 和 MAR 常集成于 CPU 内部，存储芯片内只需要一个普通的寄存器（暂存输入输出数据）</p><ul><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part3/image-20211020121325377.png" alt="image-20211020121325377" style="zoom:80%;"></li><li>CPU 和主存之间通过<strong>数据总线</strong>、<strong>地址总线</strong>、<strong>控制总线</strong>连接</li><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part3/image-20211020123151574.png" alt="image-20211020123151574" style="zoom:80%;"></li><li>对外暴露的引脚：地址线+数据线+片选线+读写控制线</li></ul></li></ul><h3 id="多块存储芯片与-CPU-的连接"><a href="#多块存储芯片与-CPU-的连接" class="headerlink" title="多块存储芯片与 CPU 的连接"></a>多块存储芯片与 CPU 的连接</h3><h4 id="位扩展法"><a href="#位扩展法" class="headerlink" title="位扩展法"></a>位扩展法</h4><ul><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part3/image-20211020130901005.png" alt="image-20211020130901005" style="zoom:80%;"></li><li>将 <strong>n</strong> 片 <strong>k×m</strong> 位的存储芯片，集合成 <strong>k×(m×n)</strong> 的芯片</li></ul><h4 id="字扩展法"><a href="#字扩展法" class="headerlink" title="字扩展法"></a>字扩展法</h4><h5 id="线选法"><a href="#线选法" class="headerlink" title="线选法"></a>线选法</h5><ul><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part3/image-20211020131651225.png" alt="image-20211020131651225" style="zoom:80%;"></li><li><strong>n</strong> 条线可提供 <strong>n</strong> 个片选信号</li><li>将 <strong>n</strong> 片 <strong>k×m</strong> 位的存储芯片，集合成 <strong>(n×k)×m</strong> 的芯片</li></ul><h5 id="片选法"><a href="#片选法" class="headerlink" title="片选法"></a>片选法</h5><ul><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part3/image-20211020131755343.png" alt="image-20211020131755343"></li><li><strong>n</strong> 条线可提供 <strong>2^n^</strong> 个片选信号</li><li>将 <strong>n</strong> 片 <strong>k×m</strong> 位的存储芯片，集合成 <strong>(n^2^×k)×m</strong> 的芯片</li><li>要注意译码器的接线，若 A<del>15</del> 无接线，则 A<del>15</del> 取值与地址无关</li></ul><table><thead><tr><th>线选法</th><th>译码片选法</th></tr></thead><tbody><tr><td>n 条线 -&gt; n 个片选信号</td><td>n 条线 -&gt; 2^n^ 个片选信号</td></tr><tr><td>电路简单</td><td>电路复杂</td></tr><tr><td>地址空间不连续</td><td>地址空间连续</td></tr></tbody></table><h4 id="字位扩展法"><a href="#字位扩展法" class="headerlink" title="字位扩展法"></a>字位扩展法</h4><ul><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part3/image-20211020133531141.png" alt="image-20211020133531141"></li><li>同时扩展字位</li></ul><h3 id="译码器知识补充"><a href="#译码器知识补充" class="headerlink" title="译码器知识补充"></a>译码器知识补充</h3><ul><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part3/image-20211020135655208.png" alt="image-20211020135655208" style="zoom:80%;"></li><li>低电平有效还是高电平有效，在译码器与存储芯片之间是相互协调同步的，<strong>都带圈或都不带圈</strong>。带圈则低电平，否则高电平。</li><li>译码器会有<strong>一个或者多个</strong>使能端，带圈则低电平，否则高电平。<ul><li>CPU 可使用译码器的使能端控制片选信号的生效时间</li><li>保证地址的信号稳定之后，再由 MREQ 发出存储器请求信号，然后译码器发出片选信号</li></ul></li><li>RAM的读周期<ul><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part3/image-20211020135621066.png" alt="image-20211020135621066"></li></ul></li></ul><h2 id="双端口-RAM-和多模块存储器"><a href="#双端口-RAM-和多模块存储器" class="headerlink" title="双端口 RAM 和多模块存储器"></a>双端口 RAM 和多模块存储器</h2><h3 id="存取周期"><a href="#存取周期" class="headerlink" title="存取周期"></a>存取周期</h3><ul><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part3/image-20211020140333261.png" alt="image-20211020140333261"></li><li>存取周期：可以连续读/写的最短时间间隔<ul><li><strong>存取周期T = 存取时间r + 恢复时间</strong></li></ul></li><li>DRAM 芯片的恢复时间比较长，有可能是存取时间的几倍（SRAM的恢复时间较短）<ul><li>如：存取时间为 r，存取周期为 T，T=4r</li><li>针对问题：多核CPU都要访存；CPU 读写速度比主存快很多，而主存恢复时间太长</li></ul></li></ul><h3 id="双端口-RAM"><a href="#双端口-RAM" class="headerlink" title="双端口 RAM"></a>双端口 RAM</h3><ul><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part3/image-20211020140651218.png" alt="image-20211020140651218"></li><li>作用：<strong>优化多核 CPU 访问一根内存条的速度</strong></li><li><strong>需要有两组完全独立的数据线、地址线、控制线</strong>。</li><li><strong>CPU、RAM 中控制电路也更复杂</strong>。</li><li>两个端口对同一主存操作有以下 4 种情况：<ol><li>两个端口同时对不同的地址单元存取数据。 </li><li>两个端口同时对同一地址单元读出数据。 </li><li>两个端口同时对同一地址单元写入数据。 （禁止）</li><li>两个端口同时对同一地址单元，一个写入数据，另一个读出数据。（禁止）</li></ol></li><li>置“busy”信号为 0，由判断逻辑决定暂时关闭一个端口（即被延时）</li></ul><h3 id="多模块存储器"><a href="#多模块存储器" class="headerlink" title="多模块存储器"></a>多模块存储器</h3><h4 id="多体并行存储器"><a href="#多体并行存储器" class="headerlink" title="多体并行存储器"></a>多体并行存储器</h4><ul><li><p><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part3/image-20211020151139894.png" alt="image-20211020151139894"></p></li><li><p><strong>高位交叉编址</strong>：<strong>更慢</strong>；<strong>低位交叉编址</strong>：<strong>更快</strong></p></li><li><p>为什么要探讨“连续访问”的情况？诸如数组、程序代码，都是在连续空间中存储的。</p></li><li><p>低位交叉编址</p><ul><li>采用“流水线”的方式并行存取（宏观上并行访问 m 个模块，微观上串行访问 m 个模块）</li><li>宏观上，一个存储周期内，m 体交叉存储器可以提供的数据量为单个模块的 m 倍。</li></ul></li><li><p>应该取多少个存储体？</p><ul><li>存取周期为 T，<strong>存取时间</strong>（<strong>总线传输周期</strong>）为 r，为了使流水线不间断，应保证模块数 <strong>m≥T/r</strong></li><li>存取时间：<strong>存储体的性能瓶颈</strong>。总线传输周期：<strong>将数据传给 CPU 所需要的时间</strong>。<ul><li>虽然意义不同，但<strong>都代表了 CPU 存取一次的时间都不可能低于 r</strong></li></ul></li><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part3/image-20211020151753136.png" alt="image-20211020151753136"></li></ul></li><li><p>通过地址 x，确定为第几个存储体</p><ul><li>通过二进制 体内地址+体号 中的<strong>体号</strong>确定</li><li>通过十进制对地址取余 <strong>x%m</strong></li></ul></li></ul><h4 id="单体多字存储器"><a href="#单体多字存储器" class="headerlink" title="单体多字存储器"></a>单体多字存储器</h4><ul><li>每次并行读出 m 个连续的<strong>字</strong></li><li>总线宽度也要扩展成 m</li><li>速度效率因为是一次读出 m 个字，所以跟多体并行存储器是差不多的<ul><li>但是相比多体并行存储器，单体多字存储器更加不灵活</li></ul></li></ul><h2 id="Cache-的基本概念和原理（高频）"><a href="#Cache-的基本概念和原理（高频）" class="headerlink" title="Cache 的基本概念和原理（高频）"></a>Cache 的基本概念和原理（高频）</h2><h3 id="高速缓冲存储器-Cache"><a href="#高速缓冲存储器-Cache" class="headerlink" title="高速缓冲存储器 Cache"></a>高速缓冲存储器 Cache</h3><ul><li>针对问题：双端口 RAM、多模块存储器<strong>提高存储器的工作速度</strong>，但<strong>与 CPU 差距依然很大</strong></li><li>改进方向：更高速的存储单元 <strong>Cache</strong> 和存储体系的改善“<strong>Cache-主存</strong>”层次</li><li>依据：程序访问的<strong>局部性原理</strong></li><li>Cache 的工作原理：<ul><li><strong>Cache 被集成在CPU内部</strong>，Cache <strong>用 SRAM 实现</strong>，速度快，成本高。</li><li>将可能会被经常用到的代码/数据<strong>复制</strong>一份到 Cache</li></ul></li></ul><h3 id="局部性原理"><a href="#局部性原理" class="headerlink" title="局部性原理"></a>局部性原理</h3><ul><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part3/image-20211020221430934.png" alt="image-20211020221430934"></li><li>空间局部性：在最近的未来要用到的信息(指令和数据)，很可能与现在正在使用的信息在<strong>存储空间</strong>上是邻近的<ul><li>Eg：数组元素、顺序执行的指令代码</li></ul></li><li>时间局部性：在最近的未来要用到的信息，很可能是现在<strong>正在使用的信息</strong><ul><li>Eg：循环结构的指令代码</li></ul></li><li>基于局部性原理，可以把 CPU 目前访问的地址“周围”的部分数据放到 Cache 中</li><li>程序 B 按“列优先”访问二维数组，空间局部性更差，更难利用 Cache 的优势</li></ul><h3 id="性能分析"><a href="#性能分析" class="headerlink" title="性能分析"></a>性能分析</h3><ul><li>设 t<del>c</del> 为访问一次 Cache 所需时间，t<del>m</del> 为访问一次主存所需时间</li><li><strong>命中率</strong> H：CPU 欲访问的信息已在 Cache 中存在的比率</li><li><strong>缺失（未命中）率</strong> M：1 - H</li><li>“Cache—主存”系统的<strong>平均访问时间</strong> t 为：<ul><li>先访问 Cache，若 Cache 未命中再访问主存：t = H * t<del>c</del> + (1 - H) * (t<del>c</del> + t<del>m</del>)</li><li>同时访问 Cache 和主存，若 Cache 命中则立即停止访问主存：t = H * t<del>c</del> + (1 - H) * t<del>m</del> </li></ul></li></ul><h3 id="存储空间分块"><a href="#存储空间分块" class="headerlink" title="存储空间分块"></a>存储空间分块</h3><ul><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part3/image-20211020223722710.png" alt="image-20211020223722710"></li><li>主存与 Cache 之间<strong>以“块”为单位</strong>进行数据交换。</li><li>主存地址可以看作为：<strong>块号 + 块内地址</strong></li><li><strong>操作系统</strong>中，通常将主存中的“一个<strong>块</strong>”也称为“一个<strong>页/页面/页框</strong>”</li><li>Cache 中的“<strong>块</strong>”也称为“<strong>行</strong>” </li><li><strong>每次被访问的主存块，一定会被立即调入 Cache</strong>。</li><li><strong>Cache 的块和主存的块大小相等</strong>。</li></ul><h2 id="Cache-和主存的映射方式"><a href="#Cache-和主存的映射方式" class="headerlink" title="Cache 和主存的映射方式"></a>Cache 和主存的映射方式</h2><h3 id="Cache-中存储的信息"><a href="#Cache-中存储的信息" class="headerlink" title="Cache 中存储的信息"></a>Cache 中存储的信息</h3><ul><li>针对问题：<strong>如何确定 Cache 与主存的数据块对应关系</strong></li><li>Cache 中存储的信息：<strong>有效位（0/1标记是否有效）</strong>+ <strong>标记（来自主存的块号）</strong>+ 块数据</li><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part3/image-20211021090740397.png" alt="image-20211021090740397"></li></ul><h3 id="全相联映射"><a href="#全相联映射" class="headerlink" title="全相联映射"></a>全相联映射</h3><ul><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part3/image-20211021092031684.png" alt="image-20211021092031684"></li><li>映射规则：主存块可以放在 Cache 的<strong>任意位置</strong> </li><li>优点：<strong>Cache 存储空间利用充分，命中率高</strong></li><li>缺点：<strong>查找标记慢，可能要遍历所有行</strong></li><li>CPU 访存：<ul><li>将想要访问的主存地址的<strong>前 22 位</strong>主存块号，对比 Cache 中所有块的<strong>标记</strong>；</li><li>若标记匹配且有效位=1，则 Cache 命中，访问块内地址为 001110 的单元。</li><li>若未命中或有效位=0，则正常访问主存</li></ul></li></ul><h3 id="直接映射"><a href="#直接映射" class="headerlink" title="直接映射"></a>直接映射</h3><ul><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part3/image-20211021093735633.png" alt="image-20211021093735633"></li><li>映射规则：每个主存块只能放到一个特定的位置：<strong>Cache块号 = 主存块号 % Cache总块数</strong> </li><li>优点：对于任意地址<strong>只需要比对一遍标记，速度最快</strong></li><li>缺点：即使其他地方有空闲 Cache 块，但是不一定能使用。存储空间利用不充分，命中率低</li><li>优化标记：<ul><li>若 <strong>Cache总块数=2^n^</strong> 则主存块号末尾 n 位<strong>直接反映它在 Cache 中的位置</strong></li><li>其主存块号的其余位即为标记</li></ul></li><li>CPU 访存：<ul><li>根据主存块号的<strong>后 3 位确定 Cache 行</strong></li><li>若主存块号的<strong>前 19 位与 Cache 标记匹配</strong>且有效位=1，则 Cache 命中，访问块内地址为 001110 的单元。</li><li>若未命中或有效位=0，则正常访问主存</li></ul></li></ul><h3 id="组相连映射"><a href="#组相连映射" class="headerlink" title="组相连映射"></a>组相连映射</h3><ul><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part3/image-20211021094545290.png" alt="image-20211021094545290"></li><li>映射规则：Cache 块分为若干组，每个主存块可放到特定分组中的任意一个位置：<strong>组号 = 主存块号 % 分组数</strong> </li><li>n 路组相联映射——每 n 个Cache 行为一组</li><li>优点：是前两种的折中方式</li><li>CPU 访存：<ul><li>根据主存块号的<strong>后 2 位确定所属分组号</strong></li><li>若主存块号的<strong>前 20 位与分组内的某个标记匹配</strong>且有效位=1， 则 Cache 命中，访问块内地址为 001110 的单元。</li><li>若未命中或有效位=0，则正常访问主存</li></ul></li></ul><h2 id="Cache-替换算法"><a href="#Cache-替换算法" class="headerlink" title="Cache 替换算法"></a>Cache 替换算法</h2><ul><li><p><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part3/image-20211021204805492.png" alt="image-20211021204805492"></p></li><li><p>针对问题：Cache 很小，主存很大。如何替换满 Cache 的块数据</p></li><li><p><strong>抖动现象</strong>：<strong>频繁的换入换出现象（刚被替换的块很快又被调入）</strong></p></li><li><p><strong>随机算法</strong>（<strong>RAND</strong>, Random）—— 若 Cache 已满，则随机选择一块替换。</p><ul><li>评价：：实现简单，但完全没考虑局部性原理，命中率低，实际效果很不稳定</li></ul></li><li><p><strong>先进先出算法</strong>（<strong>FIFO</strong>, First In First Out）—— 若 Cache 已满，则替换最先被调入 Cache 的块</p><ul><li>评价：：实现简单，依然没考虑局部性原理，最先被调入 Cache 的块也有可能是被频繁访问的</li></ul></li><li><p><strong>近期最少使用算法</strong>（<strong>LRU</strong>, Least Recently Used ）—— 为每一个 Cache 块设置一个“<strong>计数器</strong>”，用于记录每个 Cache 块已经有多久没被访问了。当 Cache 满后<strong>替换“计数器”最大的</strong></p><ul><li>机器实现：<ul><li>命中时，<strong>所命中的行的计数器清零</strong>，<strong>比其低的计数器加1，比其高的不变</strong>；</li><li>未命中且还有空闲行时，新装入的行的计数器置0，其余非空闲行全加1；</li><li>未命中且无空闲行时，计数值最大的行的信息块被淘汰，新装行的块的计数器置0，其余全加1。</li></ul></li><li><strong>刷题策略</strong>：当需要确定替换谁时，<strong>在“依次访问主存块”列表向前数 n 位，最后一个即为淘汰项</strong></li><li><strong>Cache 块的总数=2^n^，则计数器只需 n 位</strong>。且 Cache 装满后所有计数器的值一定不重复</li><li>评价：<ul><li>基于“局部性原理”，近期被访问过的主存块，在不久的将来也很有可能被再次访问，因此淘汰最久没被访问过的块是合理的。LRU 算法的<strong>实际运行效果优秀，Cache 命中率高</strong>。</li><li>但若<strong>被频繁访问的主存块数量 &gt; Cache 行的数量</strong>，则有可能发生“抖动”，如：{1,2,3,4,5,1,2,3,4,5,1,2…}</li></ul></li></ul></li><li><p><strong>最不经常使用算法</strong>（<strong>LFU</strong>, Least Frequently Used ）—— 为每一个 Cache 块设置一个“<strong>计数器</strong>”，用于记录每个 Cache 块被访问过几次。当 Cache 满后<strong>替换“计数器”最小的</strong></p><ul><li>若有多个计数器最小的行，可按行号递增、或 FIFO 策略进行选择</li><li>计数器范围可能会很大</li><li>评价：曾经被经常访问的主存块<strong>在未来不一定会用到</strong>（如：微信视频聊天相关的块），并没有很好地遵循局部性原理，因此<strong>实际运行效果不如 LRU</strong></li></ul></li><li><p>最常考察的是近期最少使用算法 LRU，同时也不太会考察计数器，掌握刷题策略即可</p></li></ul><h2 id="Cache-写策略"><a href="#Cache-写策略" class="headerlink" title="Cache 写策略"></a>Cache 写策略</h2><ul><li>针对问题：CPU 修改了 Cache 中的数据副本，如何确保主存中数据母本的一致性？</li><li>读操作不会导致数据不一致性，所以只需要讨论写操作</li></ul><h3 id="写命中"><a href="#写命中" class="headerlink" title="写命中"></a>写命中</h3><h4 id="全写法"><a href="#全写法" class="headerlink" title="全写法"></a>全写法</h4><ul><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part3/image-20211021212957934.png" alt="image-20211021212957934"></li><li>全写法(写直通法，write-through) —— 当CPU对Cache写命中时，必须把数据同时写入 Cache 和主存，一般使用写缓冲(write buffer)</li><li><strong>访存次数增加，速度变慢</strong>，但<strong>更能保证数据一致性</strong>。</li><li>使用写缓冲时：CPU 写的速度很快，若写操作不频繁，则效果很好。若写操作很频繁，可能会因为写缓冲饱和而发生阻塞。</li></ul><h4 id="写回法"><a href="#写回法" class="headerlink" title="写回法"></a>写回法</h4><ul><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part3/image-20211021212704830.png" alt="image-20211021212704830"></li><li>写回法(write-back) —— 当 CPU 对 Cache 写命中时，<strong>只修改 Cache 的内容，而不立即写入主存，只有当此块被换出时才写回主存</strong> </li><li>要新增一个<strong>脏位</strong>，表示是否经过修改</li><li><strong>减少了访存次数</strong>，但<strong>存在数据不一致的隐患</strong>。</li></ul><h3 id="写不命中"><a href="#写不命中" class="headerlink" title="写不命中"></a>写不命中</h3><h4 id="写分配法"><a href="#写分配法" class="headerlink" title="写分配法"></a>写分配法</h4><ul><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part3/image-20211021213711247.png" alt="image-20211021213711247"></li><li>写分配法(write-allocate)——当 CPU 对 Cache 写不命中时，把主存中的块调入 Cache，在 Cache 中修改。<strong>通常搭配写回法使用</strong>。</li></ul><h4 id="非写分配法"><a href="#非写分配法" class="headerlink" title="非写分配法"></a>非写分配法</h4><ul><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part3/image-20211021213515741.png" alt="image-20211021213515741"></li><li>非写分配法(not-write-allocate)——当 CPU 对 Cache <strong>写不命中时</strong>只写入主存，不调入Cache。<strong>搭配全写法使用</strong>。<ul><li>全写法—— 当 CPU 对 Cache <strong>写命中时</strong>，必须把数据同时写入Cache和主存，一般使用写缓冲</li><li>只有“读”未命中时才会调入 Cache</li></ul></li></ul><h3 id="多级-Cache"><a href="#多级-Cache" class="headerlink" title="多级 Cache"></a>多级 Cache</h3><ul><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part3/image-20211021213826421.png" alt="image-20211021213826421"></li><li>各级 Cache 之间常采用“全写法+非写分配法”。保证数据一致性。</li><li>Cache-主存 之间常采用“写回法+写分配法”。减少访存次数。</li></ul><h2 id="页式存储器"><a href="#页式存储器" class="headerlink" title="页式存储器"></a>页式存储器</h2><h3 id="页式存储"><a href="#页式存储" class="headerlink" title="页式存储"></a>页式存储</h3><ul><li>页式存储系统：<ul><li>一个程序(进程)<strong>在逻辑上被分为若干个大小相等的页面</strong>；</li><li><strong>页面大小与块的大小相同</strong>；</li><li><strong>每个页面可以离散地放入不同的主存块中</strong>，从而提高主存的利用率。</li></ul></li><li>CPU 执行的机器指令中，使用的是“逻辑地址”，因此<strong>需要通过“页表”将逻辑地址转为物理地址</strong>。<ul><li>逻辑地址（虚地址）：程序员视角看到的地址<ul><li>逻辑地址= 逻辑页号+页内地址（虚地址=虚页号+页内地址）</li></ul></li><li>物理地址（实地址）：实际在主存中的地址<ul><li>物理地址= 主存块号+页内地址（实地址=实页号+页内地址）</li></ul></li><li>页表的作用：记录了每个逻辑页面存放在哪个主存块中</li><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part3/image-20211021220933259.png" alt="image-20211021220933259"></li></ul></li></ul><h3 id="地址变换过程"><a href="#地址变换过程" class="headerlink" title="地址变换过程"></a>地址变换过程</h3><ul><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part3/image-20211021221504428.png" alt="image-20211021221504428"></li><li>快表是一种“相联存储器”，可以按内容寻访</li><li>快表中存储的是页表项的副本；Cache中存储的是主存块的副本。</li></ul><h2 id="虚拟存储器"><a href="#虚拟存储器" class="headerlink" title="虚拟存储器"></a>虚拟存储器</h2><h3 id="页式虚拟存储器"><a href="#页式虚拟存储器" class="headerlink" title="页式虚拟存储器"></a>页式虚拟存储器</h3><ul><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part3/image-20211021231033684.png" alt="image-20211021231033684"></li><li>有效位：这个页面是否已调入主存</li><li>脏位：这个页面是否被修改过</li><li>引用位：用于“页面置换算法”，比如，可以用来统计这个页面被访问过多少次</li><li>物理页：即主存块号</li><li>磁盘地址：即这个页面的数据在磁盘中的存放位置</li></ul><h3 id="段-页-式虚拟存储器"><a href="#段-页-式虚拟存储器" class="headerlink" title="段(页)式虚拟存储器"></a>段(页)式虚拟存储器</h3><ul><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part3/image-20211021231601239.png" alt="image-20211021231601239"></li><li>页式虚拟存储器——拆分成大小相等的页面</li><li>段式虚拟存储器——按照功能模块拆分。如：#0 段是自己的代码，#1 段是库函数代码，#2 段是变量</li><li>段页式虚拟存储器——把程序按逻辑结构分段，每段再划分为固定大小的页，主存空间也划分为大小相等的页。<ul><li>程序对主存的调入、调出仍以页为基本传送单位。</li><li><strong>每个程序对应一个段表</strong>，每段对应一个页表。</li><li>虚拟地址：段号+段内页号+页内地址</li></ul></li></ul><h1 id="习题课"><a href="#习题课" class="headerlink" title="习题课"></a>习题课</h1><h2 id="3-1-3"><a href="#3-1-3" class="headerlink" title="3.1.3"></a>3.1.3</h2><ol><li><p>存取方式与存储方式</p><ul><li>存取方式：随机存取、串行（顺序）存取、直接存取</li><li>存储方式：顺序、链式、索引、散列</li></ul><p>存储器分类：</p><ul><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part3/image-20211225164146029.png" alt="image-20211225164146029"></li></ul></li><li><p>磁盘属于：串行访问存储器 - 直接存取存储器</p><ul><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part3/image-20211225164339641.png" alt="image-20211225164339641"></li></ul></li><li><p>存取周期 = 存取时间 + 恢复时间</p></li><li><p>注意单位</p></li><li><p>相联存储器工作方式：</p><ul><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part3/image-20211225165429253.png" alt="image-20211225165429253"></li></ul></li><li><p><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part3/image-20211225165555408.png" alt="image-20211225165555408"></p></li><li><p>数据传输率 = 传输数据量 / 耗时</p><ul><li>1s = 1×10^3^ms = 1×10^6^us = 1×10^9^ns </li></ul></li><li><p>略</p></li></ol><h2 id="3-2-2"><a href="#3-2-2" class="headerlink" title="3.2.2"></a>3.2.2</h2><ol><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part3/image-20211225181430102.png" alt="image-20211225181430102" style="zoom:67%;"></li><li>存储系统：cache、主存、辅存</li><li>同 1</li><li>略</li><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part3/image-20211225181742673.png" alt="image-20211225181742673"></li><li>略</li></ol><p>大题</p><ol><li><p>略</p></li><li><p>规范解法：</p><ul><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part3/image-20211225182731893.png" alt="image-20211225182731893"></li></ul><p>cache/主存系统访问效率</p><ul><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part3/image-20211225183010512.png" alt="image-20211225183010512"></li></ul><p>变体</p><ul><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part3/image-20211225183145205.png" alt="image-20211225183145205"></li></ul></li></ol><h2 id="3-3-4"><a href="#3-3-4" class="headerlink" title="3.3.4"></a>3.3.4</h2><ol><li><p><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part3/image-20211225200305039.png" alt="image-20211225200305039"></p></li><li><p>略</p></li><li><p>地址线取决于寻址单元的个数；数据线取决于每个存储单元的容量，即存储字长。</p></li><li><p>原理：</p><ul><li>利用存储元电路中栅极电容上的电荷来存储信息</li></ul><p>特点：</p><ul><li>相对比于SRAM,需要刷新，刷新对CPU是透明的，以行为单位</li><li>地址复用技术，地址线是原来的1/2，且地址信号分行和列传送</li></ul></li><li><p><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part3/image-20211225200915238.png" alt="image-20211225200915238"></p></li><li><p>略</p></li><li><p>RAM：<strong>都是易失性存储器</strong></p><p>ROM：<strong>都是非易失性存储器</strong></p></li><li><p>略</p></li><li><p>DRAM：</p><ul><li><p>这里片选线是由行列通选来代替了</p></li><li><p><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part3/image-20211225201345205.png" alt="image-20211225201345205"></p></li></ul></li><li><p>注意 1M=2^20^</p></li><li><p>略</p></li><li><p>随机存储器 RAM、只读存储器 ROM <strong>都是使用半导体来制作</strong>。</p><p>只读存储器发展出擦写功能，但写的速度远小于读</p></li><li><p>同 7</p></li><li><p><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part3/image-20211225202117993.png" alt="image-20211225202117993"></p></li><li><p>主存需要由 <strong>RAM 和 ROM</strong> 一起组成。</p></li><li><p>同 14；EPROM 不能取代 RAM</p></li><li><p>如果工作中内容会产生变化，则不能拿来当做存储器</p></li><li><p>Synchronous Dynamic Random Access Memory。同步动态随机存储器，与CPU时钟严格同步</p></li></ol><p>大题</p><ol><li><ul><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part3/image-20211225203434402.png" alt="image-20211225203422410" style="zoom:82%;"><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part3/image-20211225203422410.png" alt="image-20211225203422410" style="zoom:80%;"></li><li><p>①采用高速DRAM芯片；②采用多体交叉存储结构；③刷新存储器至显示控制器的内部总线宽度加倍；④采用双端口存储器将刷新端口和更新端口分开。</p></li></ul></li><li><p>刷新和地址数据线无关</p><ul><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part3/image-20211225204309552.png" alt="image-20211225204309552"></li><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part3/image-20211225204537007.png" alt="image-20211225204537007"></li><li>题意下的物理实现：一根选通线控制两行单元<ul><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part3/image-20211225205100904.png" alt="image-20211225205100904"></li></ul></li></ul></li></ol><h2 id="3-4-5"><a href="#3-4-5" class="headerlink" title="3.4.5"></a>3.4.5</h2><ol><li></li><li></li></ol><h2 id="3-5-3"><a href="#3-5-3" class="headerlink" title="3.5.3"></a>3.5.3</h2><h2 id="3-6-6"><a href="#3-6-6" class="headerlink" title="3.6.6"></a>3.6.6</h2><h2 id="3-7-6"><a href="#3-7-6" class="headerlink" title="3.7.6"></a>3.7.6</h2>]]></content>
      
      
      <categories>
          
          <category> 计算机组成原理 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>计算机组成原理-Part2</title>
      <link href="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part2/"/>
      <url>/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part2/</url>
      
        <content type="html"><![CDATA[<h1 id="计算机组成原理-Part2——数据的表示和运算"><a href="#计算机组成原理-Part2——数据的表示和运算" class="headerlink" title="计算机组成原理-Part2——数据的表示和运算"></a>计算机组成原理-Part2——数据的表示和运算</h1><p>[TOC]</p><h2 id="数制与编码"><a href="#数制与编码" class="headerlink" title="数制与编码"></a>数制与编码</h2><h3 id="进位计数制及其相互转换"><a href="#进位计数制及其相互转换" class="headerlink" title="进位计数制及其相互转换"></a>进位计数制及其相互转换</h3><h4 id="r-进制计数法"><a href="#r-进制计数法" class="headerlink" title="r 进制计数法"></a>r 进制计数法</h4><ul><li><strong>基数</strong>：每个数码位所用到的不同符号的个数，r 进制的基数为 r</li><li><strong>位权</strong>：处于第 i 位的权重，值为 r^i^</li><li>每个位上的取值范围：0 ~ r-1</li></ul><h4 id="其他进制-gt-十进制"><a href="#其他进制-gt-十进制" class="headerlink" title="其他进制 -&gt; 十进制"></a>其他进制 -&gt; 十进制</h4><ul><li>r 进制数：K<del>n</del>K<del>n-1</del>……K<del>1</del>K<del>0</del>K<del>-1</del>……K<del>-m</del></li><li>十进制：  K<del>n</del> × r^n^ + K<del>n-1</del> × r^n-1^ + …… + K<del>1</del> × r^1^ + K<del>0</del> × r^0^ + K<del>-1</del> × r^-1^ + …… + K<del>-m</del> × r^m^ </li></ul><table><thead><tr><th>2^12^</th><th>2^11^</th><th>2^10^</th><th>2^9^</th><th>2^8^</th><th>2^7^</th><th>2^6^</th><th>2^5^</th><th>2^4^</th><th>2^3^</th><th>2^2^</th><th>2^1^</th><th>2^0^</th><th>2^-1^</th><th>2^-2^</th><th>2^-3^</th></tr></thead><tbody><tr><td>4096</td><td>2048</td><td>1024</td><td>512</td><td>256</td><td>128</td><td>64</td><td>32</td><td>16</td><td>8</td><td>4</td><td>2</td><td>1</td><td>0.5</td><td>0.25</td><td>0.125</td></tr></tbody></table><h4 id="二、八、十六进制之间相互转换"><a href="#二、八、十六进制之间相互转换" class="headerlink" title="二、八、十六进制之间相互转换"></a>二、八、十六进制之间相互转换</h4><ul><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part2/image-20211003084155324.png" alt="image-20211003084155324"></li><li>各种进制的常见书写方式<ul><li>二进制（Binary）：(1010001010010)<del>2</del>    或    1010001010010B</li><li>八进制：(1652)<del>8</del></li><li>十六进制（hex）：(1652)<del>16</del>    或     1652H    或    0x1652</li><li>十进制（dec）：(1652)<del>10</del>    或    1652D</li></ul></li><li>注意需要补位：整数向前补 0，小数向后补 0。</li></ul><h4 id="十进制-gt-其他进制"><a href="#十进制-gt-其他进制" class="headerlink" title="十进制 -&gt; 其他进制"></a>十进制 -&gt; 其他进制</h4><ul><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part2/image-20211003085557768.png" alt="image-20211003085557768"></li><li>整数部分除法：先除得的余数为低位（靠近0）</li><li>小数部分乘法：先进位的整数为高位（靠近0）</li><li>也可以使用拼凑法：枚举 r 进制数与十进制数的对应表</li><li>有的十进制小数无法使用二进制精确表示，如：0.3</li></ul><h4 id="真值和机器数"><a href="#真值和机器数" class="headerlink" title="真值和机器数"></a>真值和机器数</h4><ul><li><strong>真值</strong>：符合人类习惯的数字</li><li><strong>机器数</strong>：数字实际存到机器里的形式，正负号需要被“数字化”</li></ul><h3 id="BCD码（408大纲已删）"><a href="#BCD码（408大纲已删）" class="headerlink" title="BCD码（408大纲已删）"></a>BCD码（408大纲已删）</h3><ul><li>BCD ：Binary-Coded Decimal，用二进制编码的十进制<ul><li>8421 码（掌握加法）</li><li>余 3 码</li><li>2421 码</li></ul></li><li>针对问题：二进制方便计算机处理、十进制符合人类习惯，但是转换麻烦</li><li>改进方向：快速转换，一一对应</li><li><strong>以 4bit 二进制码表示 0~9</strong>。一共 16 种情况，6 种冗余。</li></ul><h4 id="8421-码"><a href="#8421-码" class="headerlink" title="8421 码"></a>8421 码</h4><ul><li>4 位二进制权值分别为：8 4 2 1</li><li>8421 码是有权码</li><li>8421 码的加法：<strong>先用十进制加法得出结果，再转 8421 码</strong></li><li>8421码中，1010～1111 没有定义</li><li>在机器的视角中，若发现结果<strong>非法定义</strong>（6+7）或<strong>出现进位</strong>（9+9），则需要继续 +6 进行修正。</li></ul><table><thead><tr><th>0</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th><th>7</th><th>8</th><th>9</th></tr></thead><tbody><tr><td>0000</td><td>0001</td><td>0010</td><td>0011</td><td>0100</td><td>0101</td><td>0110</td><td>0111</td><td>1000</td><td>1001</td></tr></tbody></table><h4 id="余-3-码"><a href="#余-3-码" class="headerlink" title="余 3 码"></a>余 3 码</h4><ul><li>余3码：8421码 + (0011)<del>2</del></li><li>余 3 码的每个权位不固定，所以是无权码</li></ul><table><thead><tr><th>0</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th><th>7</th><th>8</th><th>9</th></tr></thead><tbody><tr><td>0011</td><td>0100</td><td>0101</td><td>0110</td><td>0111</td><td>1000</td><td>1001</td><td>1010</td><td>1011</td><td>1100</td></tr></tbody></table><h4 id="2421-码"><a href="#2421-码" class="headerlink" title="2421 码"></a>2421 码</h4><ul><li>4 位二进制权值分别为：2 4 2 1</li><li>0<del>4 首位必须是 0，5</del>9 首位必须是 1</li></ul><table><thead><tr><th>0</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th><th>7</th><th>8</th><th>9</th></tr></thead><tbody><tr><td>0000</td><td>0001</td><td>0010</td><td>0011</td><td>0100</td><td>1011</td><td>1100</td><td>1101</td><td>1110</td><td>1111</td></tr></tbody></table><h3 id="字符与字符串"><a href="#字符与字符串" class="headerlink" title="字符与字符串"></a>字符与字符串</h3><h4 id="ASCII-码"><a href="#ASCII-码" class="headerlink" title="ASCII 码"></a>ASCII 码</h4><ul><li>键盘共 128 个字符，可以用 7 位二进制编码。<ul><li>为了存入计算机，通常在最高位补 0，凑足1B</li></ul></li><li>可印刷字符：32～126，其余为控制（如：127 DEL）、通信（如：6 ACK）字符</li><li>数字 0~9：<strong>48</strong>(0011 0000)～<strong>57</strong>(0011 1001)<ul><li>数字的 ASCII 码的<strong>前四位是 0011，后四位是 8421 码</strong></li></ul></li><li>大写字母 A~Z：<strong>65</strong>(0100 0001)～<strong>90</strong>(0101 1010)<ul><li>大写字母 ASCII 码<strong>前三位都是 010，后五位是 1~26</strong></li></ul></li><li>小写字母 a~z：<strong>97</strong>(0110 0001)～<strong>122</strong>(0111 1010)<ul><li>小写字母 ASCII 码<strong>前三位都是 011，后五位是 1~26</strong></li></ul></li><li>所有数字、大写字母、小写字母的编码都是连续的</li></ul><blockquote><p>求解某字符 ASCII 码时，要充分利用上述规律，避免十进制、二进制转换。</p></blockquote><h4 id="汉字的表示和编码"><a href="#汉字的表示和编码" class="headerlink" title="汉字的表示和编码"></a>汉字的表示和编码</h4><ul><li>GB 2312-100（19100年）：汉字+各种符号共7445个</li><li><strong>区位码：94 个区，每区 94 个位置</strong>。相当于把所有汉字存放在了 94*94 的方阵中，通过两个字节长度来定位汉字</li><li><strong>国标码：区位码 + 20H</strong>。防止信息交换时与“控制/通信字符”冲突</li><li><strong>汉字(机)内码：国标码 + 100H</strong>。保证高位为1，与ASCII码区分</li><li>输入法 -&gt; 国标码 -&gt; 汉字内码 -&gt;  (国标码 -&gt; )汉字字形码（像素方阵）</li></ul><h4 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h4><ul><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part2/image-20211003101235176.png" alt="image-20211003101235176"></li><li><strong>按字节编址：每个地址对应 1B/1字节（存储单元大小为 1B/8b）</strong></li><li>很多语言中，“\0”作为字符串结尾标志</li><li>在所有计算机中，多字节数据都被存放在连续的字节序列中。根据数据中各字节的排列顺序不同，可能有“大端模式”、“小端模式”<ul><li>大端模式：将数据的<strong>最高有效字节存放在低地址单元</strong>中（低位到高位顺序读取）</li><li>小端模式：将数据的<strong>最高有效字节存放在高地址单元</strong>中（遇到多字节数据需要倒着读）</li></ul></li></ul><h3 id="奇偶校验码（计网要考）"><a href="#奇偶校验码（计网要考）" class="headerlink" title="奇偶校验码（计网要考）"></a>奇偶校验码（计网要考）</h3><h4 id="校验原理"><a href="#校验原理" class="headerlink" title="校验原理"></a>校验原理</h4><ul><li>位错误：在 bit 位上发生的突变。0 变 1，1 变 0</li><li><strong>码字</strong>：由若干位代码组成的一个字</li><li><strong>两个码字间的距离</strong>：将两个码字逐位进行对比，<strong>具有不同的位的个数</strong></li><li><strong>码距</strong>：一种编码方案中，合法码字之间的最小距离。<strong>最少变动多少位可以在各合法码字之间转换</strong></li><li>当 d=1 时，无检错能力；当 d=2 时，有检错能力；当 d≥3 时，若设计合理，可能具有检错、纠错能力</li></ul><h4 id="奇偶校验码"><a href="#奇偶校验码" class="headerlink" title="奇偶校验码"></a>奇偶校验码</h4><ul><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part2/image-20211004142023267.png" alt="image-20211004142023267" style="zoom:100%;"></li><li><strong>奇校验码</strong>：在有效信息位之外添加一位校验位，使得整个校验码中“1”的个数为<strong>奇数</strong>。</li><li><strong>偶校验码</strong>：在有效信息位之外添加一位校验位，使得整个校验码中“1”的个数为<strong>偶数</strong>。</li><li>本质：如果出现<strong>奇数次的位错误，则可以检测出错误</strong>；如果出现<strong>偶数次位错误，则检不出错误</strong>。</li><li><strong>偶校验的硬件实现</strong>：取各位的信息依次进行异或（模2加）运算，得到的结果即为偶校验位。<ul><li>进行偶校验且结果为 0 时，则通过校验。</li><li>进行奇校验且结果为 1 时，则通过校验。</li></ul></li><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part2/image-20211004143356036.png" alt="image-20211004143356036" style="zoom:100%;"></li></ul><h3 id="海明校验码（计网要考）"><a href="#海明校验码（计网要考）" class="headerlink" title="海明校验码（计网要考）"></a>海明校验码（计网要考）</h3><h4 id="基本思想"><a href="#基本思想" class="headerlink" title="基本思想"></a>基本思想</h4><ul><li>针对问题：偶校验只能发现<strong>奇数位错误</strong>，且<strong>无法确定出错位置</strong>，想要获得正确信息则必须重新传输信息。</li><li>改进方向：将信息位分组进行偶校验 —&gt; 多个校验位 —&gt; 多个校验位标注出错位置<ul><li>1 个校验位之只能携带 2 种状态信息（对/错）</li><li>多个校验位能携带多种状态信息（对/错，错在哪）</li></ul></li><li>信息位 n 位 + 校验位 k 位 = 共 n+k 位<ul><li>k 位校验位代表最多能表示 2^k^ 种状态</li><li>校验位表示的状态应该要考虑到 n+k 的任何一位都有可能出错</li><li>重要公式：<strong>2^k^ ≥ n + k + 1</strong></li></ul></li><li>本质：分 k 组偶校验</li></ul><h4 id="海明码求解步骤（TODO）"><a href="#海明码求解步骤（TODO）" class="headerlink" title="海明码求解步骤（TODO）"></a>海明码求解步骤（TODO）</h4><p>Eg：信息位为 1010，求解海明码。</p><ol><li><p>确定海明码的位数：</p><ul><li>2^k^ ≥ n + k + 1</li><li>n=4 =&gt; k=3</li></ul></li><li><p>确定校验位的分布：</p><ul><li><p>设信息位 D<del>4</del>D<del>3</del>D<del>2</del>D<del>1</del>（1010），共4位；校验位 P<del>3</del>P<del>2</del>P<del>1</del>，共3位；对应的海明码为 H<del>7</del>H<del>6</del>H<del>5</del>H<del>4</del>H<del>3</del>H<del>2</del>H<del>1</del></p></li><li><p><strong>校验位 P<del>i</del> 放在海明位号为 2^i−1^ 的位置上</strong></p></li><li><p>校验位 P<del>i</del> 与位置序号第 i 位为 1 的信息位归为同一组，进行偶校验</p></li><li><table><thead><tr><th>H<del>7</del></th><th>H<del>6</del></th><th>H<del>5</del></th><th>H<del>4</del></th><th>H<del>3</del></th><th>H<del>2</del></th><th>H<del>1</del></th></tr></thead><tbody><tr><td>D<del>4</del></td><td>D<del>3</del></td><td>D<del>2</del></td><td>P<del>3</del></td><td>D<del>1</del></td><td>P<del>2</del></td><td>P<del>1</del></td></tr><tr><td>1</td><td>0</td><td>1</td><td>0</td><td>0</td><td>1</td><td>0</td></tr></tbody></table></li></ul></li><li><p>求校验位的值：</p><ul><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part2/image-20211004151532962.png" alt="image-20211004151532962" style="zoom:100%;"></li><li>将海明码信息位的下标转二进制矩阵，一列为一组，对应 1 的信息拿出来做偶校验，结果就是海明码校验位的值。</li></ul></li><li><p>纠错：</p><ul><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part2/image-20211004154938467.png" alt="image-20211004154938467" style="zoom:100%;"></li><li>题目的下标顺序不影响做题（TODO）</li></ul></li></ol><h4 id="海明码的检错、纠错能力"><a href="#海明码的检错、纠错能力" class="headerlink" title="海明码的检错、纠错能力"></a>海明码的检错、纠错能力</h4><ul><li>海明码的检错、纠错能力：<ul><li>纠错能力：1位（无法区分到底是 1 位错还是 2 位错）</li><li>检错能力：2位</li></ul></li><li>为了区分是 1 位错误还是 2 位错误，需加上“全校验位”，对整体进行偶校验。</li><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part2/image-20211004155557262.png" alt="image-20211004155557262"></li></ul><h3 id="循环冗余校验码（计网要考）"><a href="#循环冗余校验码（计网要考）" class="headerlink" title="循环冗余校验码（计网要考）"></a>循环冗余校验码（计网要考）</h3><h4 id="基本思想-1"><a href="#基本思想-1" class="headerlink" title="基本思想"></a>基本思想</h4><ul><li>循环冗余校验（Cyclic Redundancy Check，CRC）</li><li>数据发送、接受方<strong>共同约定一个“除数”</strong></li><li>K个信息位+R个校验位 作为“被除数”，<strong>添加校验位以保证除法的余数为 0</strong><ul><li>收到数据后，进行除法检查余数是否为0</li><li>若余数非 0 说明出错，则进行重传或纠错</li></ul></li></ul><h4 id="构造、检错、纠错"><a href="#构造、检错、纠错" class="headerlink" title="构造、检错、纠错"></a>构造、检错、纠错</h4><ul><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part2/image-20211004164514722.png" alt="image-20211004164514722" style="zoom:100%;"></li><li>流程：<ol><li>题目给出生成多项式、信息码</li><li>K = 信息码的长度 = 6，R = 生成多项式最高次幂 = 3 =&gt; 校验码位数 N = K + R = 9</li><li>信息码左移 R 位，低位补 0。利用生成多项式系数进行模2除法，得余数为校验码。</li><li>将接受到的码字用生成多项式进行模2除法，余数为000则代表没有出错，否则不然。</li></ol></li><li>循环冗余校验码的检错、纠错特性：<ul><li>可检测出所有奇数个错误</li><li>可检测出所有双比特的错误</li><li>可检测出所有小于等于校验位长度的连续错误</li><li>对于确定的生成多项式，出错位与余数是相对应的</li><li>当码字长度超出检错码可表示的能力时，出错位与余数的对应关系将进行循环</li><li>K个信息位，R个校验位，若生成多项式选择得当，且 2^R^≥K+R+1，则 CRC 码可纠正1位错</li></ul></li></ul><h2 id="定点数的表示与运算"><a href="#定点数的表示与运算" class="headerlink" title="定点数的表示与运算"></a>定点数的表示与运算</h2><blockquote><ul><li>定点数：小数点的位置固定（定点数也包含小数）<ul><li>常规计数</li><li>Eg：996.007</li></ul></li><li>浮点数：小数点的位置不固定<ul><li>科学计数法</li><li>Eg：9.96007*102</li></ul></li></ul></blockquote><h3 id="定点数的表示"><a href="#定点数的表示" class="headerlink" title="定点数的表示"></a>定点数的表示</h3><h4 id="无符号数的定点表示"><a href="#无符号数的定点表示" class="headerlink" title="无符号数的定点表示"></a>无符号数的定点表示</h4><ul><li>无符号数：<strong>整个机器字长的全部二进制位均为数值位</strong>，没有符号位，相当于数的绝对值。</li><li>通常只有无符号整数，而没有无符号小数（unsigned int/long）</li><li>表示范围：<strong>n 位 bit 的无符号数表示范围为：0 ～ 2n-1</strong><ul><li>Eg：8位二进制数： 2^8^ 种不同的状态，表示 0000 0000 ～ 1111 1111，即 0 ~ 255</li></ul></li></ul><h4 id="有符号数的定点表示"><a href="#有符号数的定点表示" class="headerlink" title="有符号数的定点表示"></a>有符号数的定点表示</h4><ul><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part2/image-20211007120237263.png" alt="image-20211007120237263" style="zoom:100%;"></li><li>可用 <strong>原码、反码、补码</strong> 三种方式来表示定点整数和定点小数。还可用 <strong>移码</strong> 表示定点整数。</li><li>若真值为 x，则用 <strong>[x]原、[x]反、[x]补、[x]移</strong> 分别表示真值所对应的原码、反码、补码、移码</li><li>若机器字长为 n+1 位，则符号位占 1 位，尾数占 n 位</li><li>表示定点整数，默认小数点隐含在尾数后；表示定点小数，默认小数点隐含在符号位后尾数前。</li></ul><h5 id="原码表示定点整数和定点小数"><a href="#原码表示定点整数和定点小数" class="headerlink" title="原码表示定点整数和定点小数"></a>原码表示定点整数和定点小数</h5><ul><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part2/image-20211007121910742.png" alt="image-20211007121910742" style="zoom:100%;"></li><li>未指明机器字长时，整数尾数前端的 0 可略去，小数尾数后端的 0 可略去。</li><li>要注意<strong>第一位是符号位</strong>，切不能当成数值。</li><li>整数原码常用 <strong>逗号</strong> 分割符号位和尾数，小数原码常用 <strong>小数点</strong> 分割符号位和尾数。</li><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part2/image-20211007123125347.png" alt="image-20211007123125347" style="zoom:100%;"></li><li>在整数和小数的原码表示中，<strong>真值 0 有 +0 和 -0 两种形式</strong>，即两种二进制状态对应了同一种真值。<ul><li>因此即使机器字长为 n+1 位，理论上能够表示 2^n+1^ 种情况，但实际上值表示了 <strong>2^n+1^-1</strong> 种。</li></ul></li><li>原码整数表示范围：**-(2^n^-1)≤x≤2^n^-1<strong>；源码小数表示范围：</strong>-(1-2^n^)≤x≤1-2^n^**。</li></ul><h5 id="反码表示定点整数和定点小数"><a href="#反码表示定点整数和定点小数" class="headerlink" title="反码表示定点整数和定点小数"></a>反码表示定点整数和定点小数</h5><ul><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part2/image-20211007124524338.png" alt="image-20211007124524338" style="zoom:100%;"></li><li>反码：<strong>若符号位为0，则反码与原码相同；若符号位为1，则数值位全部取反。</strong></li><li>表示范围和源码相同。</li></ul><blockquote><p>“反码”只是“原码”转变为“补码”的一个中间状态，实际中并没什么卵用——并没有解决“真值 0 有 +0 和 -0 两种形式”这个问题。</p></blockquote><h5 id="补码表示定点整数和定点小数"><a href="#补码表示定点整数和定点小数" class="headerlink" title="补码表示定点整数和定点小数"></a>补码表示定点整数和定点小数</h5><ul><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part2/image-20211007131951644.png" alt="image-20211007131951644" style="zoom:100%;"></li><li>补码：正数的补码=原码；负数的补码=反码末位+1（要考虑进位）</li><li>补码的真值 0 只有一种表示形式：[+0]补= [-0]补= 00000000<ul><li>定点整数<ul><li>[-2^7^]补 = **1,**0000000</li><li>表示范围：−2^n^ ≤ x ≤ 2^n^−1</li></ul></li><li>定点小数<ul><li>[-1]补 = **1.**0000000 </li><li>表示范围：-1 ≤ x ≤ 1-2^-n^</li></ul></li></ul></li><li><strong>由 [x]补 快速求 [-x]补 的方法：符号位、数值位全部取反，末位+1</strong></li></ul><h5 id="移码表示定点整数"><a href="#移码表示定点整数" class="headerlink" title="移码表示定点整数"></a>移码表示定点整数</h5><ul><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part2/image-20211007143059138.png" alt="image-20211007143059138" style="zoom:100%;"></li><li>移码：<strong>补码的基础上将符号位取反</strong>。注意：<strong>移码只能用于表示整数</strong>。</li><li>移码表示的整数很方便对比大小</li><li>在浮点数中将大量是使用源码</li></ul><h3 id="原码补码移码的作用"><a href="#原码补码移码的作用" class="headerlink" title="原码补码移码的作用"></a>原码补码移码的作用</h3><ul><li>无符号数：可以进行直接加减运算。</li><li>原码的加减运算：需要将符号位单独区分，但是这样将增加硬件成本、计算复杂度。<ul><li>因此需要用加法运算来代替减法运算 =&gt; 将减法操作转换成取模运算（例如：-3mod12=9）</li></ul></li><li>补码的本质：为了能够进行直接加运算，将系统设计成了循环。</li><li>反码的本质：将原码的负数部分进行了反转，是补码能够循环的铺垫。</li><li>移码的本质：使用偏置将补码的循环提前了半个周期。</li></ul><table><thead><tr><th>二进制机器数</th><th>二进制表示无符号数</th><th>二进制表示原码</th><th>二进制表示反码</th><th>二进制表示补码</th><th>二进制表示移码</th></tr></thead><tbody><tr><td>0000 0000</td><td><strong>0</strong></td><td><strong>+0</strong></td><td><strong>+0</strong></td><td><strong>±0</strong></td><td>-128</td></tr><tr><td>0000 0001</td><td>1</td><td>1</td><td>1</td><td>1</td><td>-127</td></tr><tr><td>……</td><td>……</td><td>……</td><td>……</td><td>……</td><td>……</td></tr><tr><td>0111 1111</td><td>127</td><td>127</td><td>127</td><td>127</td><td>-1</td></tr><tr><td>1000 0000</td><td>128</td><td><strong>-0</strong></td><td>-127</td><td>-128</td><td><strong>±0</strong></td></tr><tr><td>1000 0001</td><td>129</td><td>-1</td><td>-126</td><td>-127</td><td>1</td></tr><tr><td>……</td><td>……</td><td>……</td><td>……</td><td>……</td><td>……</td></tr><tr><td>1111 1111</td><td>255</td><td>-127</td><td><strong>-0</strong></td><td>-1</td><td>127</td></tr></tbody></table><ul><li>带余除法——设 x, m∈Z, m&gt;0 则存在唯一决定的整数 q 和 r，使得：x = q*m + r , 0 ≤ r &lt; m <ul><li>(mod 12) 把所有整数分为 12 类（余数为 0~11）</li><li>(mod 12) 余数相同的数，都是同一类，都是等价的</li><li>在 (mod m) 的条件下，若能<strong>找到负数的补数</strong>，就可以<strong>用正数的加法来等价替代减法</strong><ul><li>若二个数绝对值之和=模，则称这两个数互为补数</li></ul></li><li><strong>模 - a的绝对值 = a的补数</strong></li><li>↑ 这是补码的原生定义</li></ul></li><li>反码 + 原码 + 1 = 模</li><li>补码的作用： 使用补码可将减法操作转变为等价的加法，ALU 中无需集成减法器。执行加法操作时，符号位一起参与运算。</li></ul><h3 id="移位运算"><a href="#移位运算" class="headerlink" title="移位运算"></a>移位运算</h3><h4 id="算数移位"><a href="#算数移位" class="headerlink" title="算数移位"></a>算数移位</h4><ul><li><p>移位：通过改变各个数码位和小数点的相对位置，从而改变各数码位的位权。可用移位运算实现乘法、除法</p></li><li><p>原码的算数移位——<strong>符号位保持不变，仅对数值位进行移位</strong>。</p><ul><li>右移：高位补0，低位舍弃。若舍弃的位=0，<strong>则相当于÷2</strong>；若舍弃的位≠0，则会丢失<strong>精度</strong></li><li>左移：低位补0，高位舍弃。若舍弃的位=0，<strong>则相当于×2</strong>；若舍弃的位≠0，则会出现<strong>严重误差</strong></li></ul></li><li><p>反码的算数移位</p><ul><li>正数的反码与原码相同，因此对正数反码的移位运算也和原码相同。<ul><li>右移：<strong>高位补0</strong>，低位舍弃。</li><li>左移：<strong>低位补0</strong>，高位舍弃。</li></ul></li><li>负数的反码数值位与原码相反，因此负数反码的移位在补位上有所变化。<ul><li>右移：<strong>高位补1</strong>，低位舍弃。</li><li>左移：<strong>低位补1</strong>，高位舍弃。</li></ul></li></ul></li><li><p>补码的算数移位</p><ul><li>正数的补码与原码相同，因此对正数补码的移位运算也和原码相同。<ul><li>右移：<strong>高位补0</strong>，低位舍弃。</li><li>左移：<strong>低位补0</strong>，高位舍弃。</li></ul></li><li>负数补码=反码末位+1，导致反码最右边几个连续的1都因进位而变为0，直到进位碰到第一个0为止。<ul><li>负数补码中：最右边的1及其右边同原码；最右边的1的左边同反码负数补码。</li><li>右移（同反码）：<strong>高位补1</strong>，低位舍弃。</li><li>左移（同原码）：<strong>低位补0</strong>，高位舍弃。</li></ul></li></ul></li><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part2/image-20211008121454539.png" alt="image-20211008121454539" style="zoom:100%;"></li><li><p>Eg：-20×7 = -20×(2^0^+2^1^+2^2^) = (-20左移0位) + (-20左移1位) + (-20左移2位)</p></li></ul><h4 id="逻辑移位"><a href="#逻辑移位" class="headerlink" title="逻辑移位"></a>逻辑移位</h4><ul><li>逻辑右移：高位补0，低位舍弃。</li><li>逻辑左移：低位补0，高位舍弃。</li><li>可以把逻辑移位看作是对“无符号数”的算数移位</li><li>Eg：<img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part2/image-20211008122429002.png" alt="image-20211008122429002" style="zoom:100%;"></li></ul><h4 id="循环移位"><a href="#循环移位" class="headerlink" title="循环移位"></a>循环移位</h4><ul><li>不带进位位：用<strong>移出的位补上空缺</strong></li><li>带进位位：用<strong>进位位的值补上空缺</strong>，而<strong>移出的位放到进位位</strong></li><li>Eg：交换高低位字节时常用（大端存储&lt;=&gt;小端存储）</li></ul><h3 id="加减运算和溢出判断"><a href="#加减运算和溢出判断" class="headerlink" title="加减运算和溢出判断"></a>加减运算和溢出判断</h3><h4 id="原码的加减法"><a href="#原码的加减法" class="headerlink" title="原码的加减法"></a>原码的加减法</h4><ul><li>要考虑 2*2 种情况，并且同时实现加法器和减法器</li><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part2/image-20211008124354552.png" alt="image-20211008124354552"></li></ul><h4 id="补码的加减法"><a href="#补码的加减法" class="headerlink" title="补码的加减法"></a>补码的加减法</h4><ul><li><p>负数的补码转原码：</p><ul><li>数值位取反，+1</li><li>-1，数值位取反</li><li>负数补码中，最右边的1及其右边同原码，最右边的1的左边同反码</li></ul></li><li><p>[(负数)]补 &lt;=&gt; [(负数)]原：<strong>取负数补码最右边的一位1，其本身与其右侧不变，左侧数值位全部取反</strong>。（常用）</p></li><li><p>[x]补 =&gt; [-x]补：<strong>连同符号位一起取反加1</strong>。</p></li></ul><h4 id="溢出判断"><a href="#溢出判断" class="headerlink" title="溢出判断"></a>溢出判断</h4><ul><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part2/image-20211008151859101.png" alt="image-20211008151859101"></li><li>溢出情况：<ul><li>只有“正数+正数 ”才会上溢 —— 正+正=负</li><li>只有“负数+负数 ”才会下溢 —— 负+负=正</li></ul></li><li>判断方法：<ul><li>法一：采用一位符号位设 A 的符号为 A<del>S</del>，B 的符号为 B<del>S</del>，运算结果的符号为 S<del>S</del>，则溢出逻辑表达式为：<ul><li>$V = A_{s}B_{s}\overline{S_{s}} + \overline{A_{s}}\overline{B_{s}}S_{s}$</li><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part2/image-20211008163931615.png" alt="image-20211008163931615" style="zoom:100%;"></li><li>若 V=0，表示无溢出；若 V=1，表示有溢出。</li><li><strong>A<del>S</del> 为 1 且 B<del>S</del> 为 1 且 S<del>S</del> 为 0</strong> 或 <strong>A<del>S</del> 为 0 且 B<del>S</del> 为 0 且 S<del>S</del> 为 1</strong>。</li></ul></li><li>法二：采用一位符号位，根据数据位进位情况判断溢出符号位的进位 C<del>S</del>，最高数值位的进位 C<del>1</del><ul><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part2/image-20211008163814192.png" alt="image-20211008163814192" style="zoom:100%;"></li><li>$V=C_{S}⊕ C_{1}$</li><li>若 V=0，表示无溢出；若 V=1，表示有溢出。</li><li><strong>最高数值位进位且符号位不进位</strong> 或 <strong>符号位进位而最高数值位不进位</strong>。</li></ul></li><li>法三：<ul><li>采用双符号位：正数符号为 00，负数符号为 11</li><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part2/image-20211008163848872.png" alt="image-20211008163848872" style="zoom:100%;"></li><li>记两个符号位为 S<del>S1</del>S<del>S2</del> ，则 $V=S_{S1}\otimes S_{S2}$。若 V=0，表示无溢出；若 V=1，表示有溢出。</li><li><strong>第一个符号位表明应该得到的符号，第二个符号位表明实际得到的符号。</strong></li><li>双符号位补码又称：模 4 补码；单符号位补码又称：模 2 补码。</li><li>实际存储时只存储一个符号位，运算时会复制一个符号位</li></ul></li></ul></li><li>同+同=异  =&gt;  发生溢出</li></ul><h4 id="符号扩展"><a href="#符号扩展" class="headerlink" title="符号扩展"></a>符号扩展</h4><ul><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part2/image-20211008164330993.png" alt="image-20211008164330993" style="zoom:100%;"></li><li>定点整数的符号扩展：在原符号位和数值位<strong>中间</strong>添加新位，正数都添0；负数<strong>原码添0，反码、补码添1</strong></li><li>定点小数的符号扩展：在原符号位和数值位<strong>后面</strong>添加新位，正数都添0；负数<strong>原码、补码添0，反码添1</strong></li></ul><h3 id="乘法运算"><a href="#乘法运算" class="headerlink" title="乘法运算"></a>乘法运算</h3><h4 id="乘法运算的实现思想"><a href="#乘法运算的实现思想" class="headerlink" title="乘法运算的实现思想"></a>乘法运算的实现思想</h4><ul><li>用移位实现乘数累加</li><li>Eg：0.1101×0.1011 = (1101×1×2^-8^ ) + (1101×1×2^-7^) + (1101×0×2^-6^) + (1101×1×2^-5^)</li></ul><h4 id="原码的一位乘法"><a href="#原码的一位乘法" class="headerlink" title="原码的一位乘法"></a>原码的一位乘法</h4><ul><li><strong>符号单独处理</strong>：符号位 = x<del>s</del>⊕y<del>s</del></li><li><strong>数值位取绝对值进行乘法</strong>计算</li><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part2/image-20211009130101904.png" alt="image-20211009130101904" style="zoom:100%;"></li><li>在机器实现乘法中：<ul><li>ACC 存放<strong>乘积高位</strong>，MQ 存放<strong>乘数与乘积低位</strong>，X 存放<strong>被乘数</strong></li><li>在正式进行乘法之前，<strong>ACC 置零</strong></li><li>先将 X 中被乘数与 MQ 最低位的乘积结果<strong>加到 ACC 中</strong></li><li>再将 ACC、MQ 整体<strong>逻辑右移</strong>一位<ul><li>逻辑右移，高位补零</li><li>ACC 的低位移到 MQ 的高位</li><li>MQ 的低位用完之后直接丢弃</li><li>此时，AC、MQ 中运算得到的位上的结果称作<strong>部分积</strong></li></ul></li><li>数值位一共 n 位，则<strong>循环 n 次</strong><ul><li>乘数的符号位不用参与运算。ACC+MQ 是一个整体，而 MQ 由取绝对值，所以最多只有 4 为有效，原本的符号位不会对结果造成影响。</li><li>小数点隐含位置在 ACC 的第二位</li></ul></li><li><strong>修改 ACC 的符号位</strong>：x<del>s</del>⊕y<del>s</del>=1</li></ul></li><li>之所以称为“一位乘法”是因为每次都使用 MQ 的最后一位进行乘积相加，还有更快的“二位乘法”但不做要求。</li><li>Tips：<ul><li>乘数的符号位不参与运算，可以省略</li><li>原码一位乘可以只用单符号位，也可以用双符号位</li><li>答题时最终结果最好写为原码机器数</li></ul></li></ul><h4 id="补码的一位乘法（Booth算法）"><a href="#补码的一位乘法（Booth算法）" class="headerlink" title="补码的一位乘法（Booth算法）"></a>补码的一位乘法（Booth算法）</h4><ul><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part2/image-20211009134039359.png" alt="image-20211009134039359" style="zoom:100%;"></li><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part2/image-20211009143142389.png" alt="image-20211009143142389" style="zoom:100%;"></li><li>机器实现补码乘法时：<ul><li>MQ 相比原码乘法需要在最低位后面加一位辅助位。同时 CPU 中寄存器大小应当一致，所以<ul><li>ACC、X 使用<strong>双符号位</strong>，MQ 使用<strong>单符号位以及一位辅助位</strong>，部分积也是使用<strong>双符号位</strong></li></ul></li><li>与原码乘法不同，每次加法是：<code>ACC + [(辅助位-MQ最低位)x]补</code></li><li>与原码乘法不同，每次移位是：<strong>补码的算数移位</strong><ul><li>符号位不动，数值位右移，正数右移补0，负数右移补1（符号位是啥就补啥）</li></ul></li><li>加法与移位的循环分别是 n+1 和 n 次，即<strong>乘数的单符号位也会参与计算</strong></li><li>与原码乘法不同，最后的符号确定已在计算过程中完成，无需再次校验。</li></ul></li></ul><h3 id="除法运算"><a href="#除法运算" class="headerlink" title="除法运算"></a>除法运算</h3><h4 id="除法运算的实现思想"><a href="#除法运算的实现思想" class="headerlink" title="除法运算的实现思想"></a>除法运算的实现思想</h4><ul><li>被除数、余数本质相同，是我们还需要去拼凑的数</li><li>商是我们尽可能去接近需要拼凑的数但不能超过</li></ul><h4 id="原码的除法运算"><a href="#原码的除法运算" class="headerlink" title="原码的除法运算"></a>原码的除法运算</h4><h5 id="恢复余数法"><a href="#恢复余数法" class="headerlink" title="恢复余数法"></a>恢复余数法</h5><ul><li>ACC 放被除数和余数，MQ 放商，X 放除数</li><li><strong>符号单独处理</strong>：符号位 = x<del>s</del>⊕y<del>s</del></li><li><strong>数值位取绝对值进行除法</strong>计算</li><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part2/image-20211011153443169.png" alt="image-20211011153443169" style="zoom:100%;"></li><li>在机器实现除法中：<ul><li>在正式进行乘法之前，<strong>MQ 置零</strong></li><li>首先<strong>默认商/MQ最低位为 1</strong>，将除数的相反数的补码与被除数/余数（ ACC ）相加（将 ACC 减去除数）<ul><li>(ACC)+ [−|y|]补 -&gt; ACC</li><li><strong>若相减之后余数符号位为 1</strong>（小于 0），则表明商不应该为 1，而是 0</li><li><strong>则将 ACC 的值再次加上除数</strong>，恢复成原样</li><li>并<strong>将商改成 0</strong></li><li>若最后一步余数是负数，则一样要进行上面的纠正</li></ul></li><li>ACC、MQ 整体逻辑左移<ul><li>MQ 低位补零</li><li>ACC 高位丢弃</li></ul></li><li>机器字长有 n+1 位，就要算 n+1 位的商，左移 n 次</li><li><strong>修改 MQ 的符号位</strong>：x<del>s</del>⊕y<del>s</del>=0</li></ul></li></ul><h5 id="不恢复余数法（加减交替法）"><a href="#不恢复余数法（加减交替法）" class="headerlink" title="不恢复余数法（加减交替法）"></a>不恢复余数法（加减交替法）</h5><ul><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part2/image-20211011155159488.png" alt="image-20211011155159488" style="zoom:100%;"></li><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part2/image-20211011154706460.png" alt="image-20211011154706460" style="zoom:100%;"></li><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part2/image-20211011155635905.png" alt="image-20211011155635905" style="zoom:100%;"></li><li>当余数（ACC）为负时，商 0<ul><li>恢复余数法：+|除数（X）|，再左移，再-|除数（X）|</li><li>加减交替法：左移，再+|除数（X）|</li></ul></li><li>在加减交替法中<ul><li>余数（ACC）的正负性与商相同</li><li>符号位同样需要额外判定</li><li>若最后的余数（ACC）为负，需商0，并+[|y|]补得到正确余数</li></ul></li></ul><h4 id="补码的除法运算（加减交替法）"><a href="#补码的除法运算（加减交替法）" class="headerlink" title="补码的除法运算（加减交替法）"></a>补码的除法运算（加减交替法）</h4><ul><li>符号位参与运算</li><li>被除数/余数、除数采用双符号位</li><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part2/image-20211014133724204.png" alt="image-20211014133724204" style="zoom:100%;"></li><li>第一步，比较<strong>被除数</strong>（ACC）和除数（X）符号<ul><li>同号，则被除数-除数</li><li>异号，则被除数+除数</li></ul></li><li>然后，比较<strong>余数</strong>（ACC）和除数（X）符号（每次循环保证两者相加符号不同，结果与被除）<ul><li>同号，<strong>商1</strong>，余数左移，减去除数</li><li>异号，<strong>商0</strong>，余数左移，加上除数</li></ul></li><li>重复 n 次</li><li>MQ 的最后一位恒置 1（精度误差不超过 2^-n^）</li></ul><h4 id="除法运算总结"><a href="#除法运算总结" class="headerlink" title="除法运算总结"></a>除法运算总结</h4><table><thead><tr><th>除法类型</th><th>符号位参与运算</th><th>加减次数</th><th>移位方向</th><th>移位次数</th><th>上商、加减原则</th><th>说明</th></tr></thead><tbody><tr><td>原码加减交替法</td><td>否</td><td>N+1 或 N+2</td><td>左</td><td>N</td><td>余数的正负</td><td>若最终余数为负，则恢复余数</td></tr><tr><td>补码加减交替法</td><td>是</td><td>N+1</td><td>左</td><td>N</td><td>余数和除数是否同号</td><td>商末位恒置 1</td></tr></tbody></table><h3 id="强制类型转换"><a href="#强制类型转换" class="headerlink" title="强制类型转换"></a>强制类型转换</h3><ul><li>C 语言中定点整数（int、long、short）是用<strong>补码</strong>存储的。</li><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part2/image-20211015192650002.png" alt="image-20211015192650002" style="zoom:100%;"></li></ul><h3 id="数据的存储和排列"><a href="#数据的存储和排列" class="headerlink" title="数据的存储和排列"></a>数据的存储和排列</h3><ul><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part2/image-20211015195134394.png" alt="image-20211015195134394" style="zoom:100%;"></li><li>最高有效字节（<strong>MSB</strong>）最低有效字节（<strong>LSB</strong>）</li><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part2/image-20211015200927531.png" alt="image-20211015200927531"></li><li>现代计算机<strong>通常是按字节编址</strong>，即每个字节对应1个地址<ul><li>通常也支持按字、按半字、按字节寻址</li></ul></li><li>假设存储字长为32位，则1个字=32bit，半字=16bit<ul><li>要将按字寻址转成按字节寻址，则将值左移2位</li></ul></li><li><strong>每次访存只能读/写1个字</strong></li><li>c语言的数据类型长度<ul><li>char：1字节</li><li>short：2字节</li><li>int：4字节</li><li>long：8字节</li></ul></li><li>使用<strong>边界对齐方式</strong>可以<strong>提高读取效率</strong>，而使用<strong>边界不对齐方式</strong>可以<strong>减少存储开销</strong>。</li></ul><h2 id="浮点数的表示与运算"><a href="#浮点数的表示与运算" class="headerlink" title="浮点数的表示与运算"></a>浮点数的表示与运算</h2><h3 id="浮点数的表示"><a href="#浮点数的表示" class="headerlink" title="浮点数的表示"></a>浮点数的表示</h3><h4 id="浮点数的作用和基本原理"><a href="#浮点数的作用和基本原理" class="headerlink" title="浮点数的作用和基本原理"></a>浮点数的作用和基本原理</h4><ul><li>针对问题：定点数可表示的数字范围有限，但我们不能无限制地增加数据的长度</li><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part2/image-20211016153947660.png" alt="image-20211016153947660"></li><li>阶码：常用补码或移码表示的定点整数</li><li>尾数：常用原码或补码表示的定点小数</li><li>浮点数的真值：N=r^E^×M<ul><li>阶码的底 r，通常为 2</li><li>阶码 E 反映浮点数的<strong>表示范围</strong>及小数点的实际位置</li><li>尾数 M 的数值部分的位数 n 反映浮点数的<strong>精度</strong></li><li>尾数给出一个小数，阶码正负与数值指明了尾数左移/右移(小数点向后/向前移动)几位。</li></ul></li></ul><h4 id="浮点数规格化"><a href="#浮点数规格化" class="headerlink" title="浮点数规格化"></a>浮点数规格化</h4><ul><li>规格化浮点数：规定尾数的最高数值位必须是一个有效值 。</li><li>左规：当浮点数运算的结果为非规格化（尾数的最高数值位为 0）时，将尾数算数左移 1 位，阶码减 1。<ul><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part2/image-20211016194214228.png" alt="image-20211016194214228"></li></ul></li><li>右规：当浮点数运算的结果尾数出现溢出（双符号位为01或10）时，将尾数算数右移 1 位，阶码加 1。<ul><li>第一位符号位是正确的符号位</li><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part2/image-20211016194118837.png" alt="image-20211016194118837"></li></ul></li><li>规格化浮点数的特点：<ul><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part2/image-20211016204436786.png" alt="image-20211016204436786"></li><li>规格化的原码尾数，最高数值位一定是 1</li><li>规格化的补码尾数，符号位与最高数值位一定相反</li></ul></li></ul><h4 id="浮点数表示范围（大纲外）"><a href="#浮点数表示范围（大纲外）" class="headerlink" title="浮点数表示范围（大纲外）"></a>浮点数表示范围（大纲外）</h4><ul><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part2/image-20211016204413711.png" alt="image-20211016204413711"></li><li>对于下溢，只需要当做0处理</li><li>对于上溢，必须作为异常</li></ul><h3 id="浮点数标准IEEE75"><a href="#浮点数标准IEEE75" class="headerlink" title="浮点数标准IEEE75"></a>浮点数标准IEEE75</h3><ul><li><p>读音：I triple E——IEEE</p></li><li><p>移码的定义：<strong>移码 = 真值 + 偏置值</strong>（偏置值并不固定）</p><ul><li>在之前所学的移码中：偏置值为 128D=1000 0000B，即 2^n-1^</li><li>在 IEEE75 中，偏置值为 <strong>127D=0111 1111B</strong>，即 <strong>2^n-1^-1</strong></li></ul></li><li><p><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part2/image-20211018121445755.png" alt="image-20211018121445755"></p></li><li></li><li><p>阶码全1、全0时用作特殊用途。因此阶码的正常范围：**-126~127**</p><ul><li>规格化短浮点真值：(-1)^s^×1.M×2^E-127^</li><li>规格化长浮点真值：(-1)^s^×1.M×2^E-1023^</li><li>计算<strong>移码/阶码的真值</strong>时，不用在二进制上面计算，可以<strong>先把看见的移码当做无符号数计算值</strong>，然后<strong>减去偏置值127</strong></li></ul></li></ul><table><thead><tr><th>类型</th><th>数符</th><th>阶码</th><th>尾数</th><th>总位数</th><th>偏置值（十六进制）</th><th>偏置值（十进制）</th></tr></thead><tbody><tr><td>短浮点数(float)</td><td>1</td><td>8</td><td>23</td><td>32</td><td>7FH</td><td>127</td></tr><tr><td>长浮点数(double)</td><td>1</td><td>11</td><td>52</td><td>64</td><td>3FFH</td><td>1023</td></tr><tr><td>临时浮点数(long double)</td><td>1</td><td>15</td><td>64</td><td>80</td><td>3FFFH</td><td>16383</td></tr></tbody></table><ul><li><p><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part2/image-20211018115935229.png" alt="image-20211018115935229"></p></li><li><p>IEEE 754 单精度浮点型能表示的最小绝对值、最大绝对值</p><ul><li>最小绝对值：尾数全为0，阶码真值最小-126，对应移码机器数 0000 0001。此时整体的真值为 (1.0)<del>2</del>×2^-126^</li><li>最大绝对值：尾数全为1，阶码真值最大 127，对应移码机器数 1111 1110。此时整体的真值为 (1.111…11)<del>2</del>×2^127^</li></ul></li></ul><table><thead><tr><th>格式</th><th>格式化的最小绝对值</th><th>格式化的最大绝对值</th></tr></thead><tbody><tr><td>单精度</td><td>E=1，M=0：1.0×2^1−127^=2^-126^</td><td>E=254，M=.11…1：1.11…1×2^254−127^=2^127^×(2−2^−23^)</td></tr><tr><td>双精度</td><td>E=1，M=0：1.0×2^1−1023^=2^-1022^</td><td>E=254，M=.11…1：1.11…1×2^2046−1023^=2^1023^×(2−2^−52^)</td></tr></tbody></table><ul><li><strong>只有 1≤E≤254时，真值 = (−1)^s^×1.M×2^E−127^</strong></li><li>当阶码E全为0<ul><li>尾数M不全为0时，表示非规格化小数 ±(0.xx…x)<del>2</del>×2^-126^<ul><li>隐含最高位变为 0</li><li>阶码真值固定视为 -126</li></ul></li><li>尾数M全为0时，表示真值 ±0</li></ul></li><li>当阶码E全为1<ul><li>尾数M不全为0时，表示非数值 “NaN” (Not a Number)<ul><li>如：0/0、∞-∞ 等非法运算的结果就是 NaN</li></ul></li><li>尾数M全为0时，表示无穷大 ±∞</li></ul></li></ul><blockquote><p>由浮点数确定真值（阶码不是全0、也不是全1）：</p><ol><li>根据“某浮点数”确定数符、阶码、尾数的分布</li><li>确定尾数 1.M（注意补充最高的隐含位1）</li><li>确定阶码的真值 = 移码 - 偏置值 （可将移码看作无符号数，用无符号数的值减去偏置值）</li><li>(−1)^s^×1.M×2^E−偏置值^</li></ol></blockquote><h3 id="浮点数的运算"><a href="#浮点数的运算" class="headerlink" title="浮点数的运算"></a>浮点数的运算</h3><h4 id="浮点数的加减运算"><a href="#浮点数的加减运算" class="headerlink" title="浮点数的加减运算"></a>浮点数的加减运算</h4><ul><li>浮点数加减运算步骤<ul><li>转换格式（真值D-&gt;机器数B；注意审题：用补/移码表示阶码和尾数）</li><li>对阶（使两个数的阶码相等，小阶向大阶看齐，尾数毎右移一位，阶码加1）</li><li>尾数加减</li><li>规格化</li><li>舍入（可以有不同的舍入规则）<ul><li>0舍1入：移去为0则舍，为1则入（可能会使尾数又溢出，此时需再做一次右规。）</li><li>恒置1：无论移去0还是1，都使右移后的尾数末位置1（这种方法同样有使尾数变大和变小的两种可能。）</li></ul></li><li>判溢出（尾数溢出未必导致整体溢出，只有阶数溢出才是真正的溢出）</li></ul></li><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part2/image-20211018135039513.png" alt="image-20211018135039513"></li></ul><h4 id="强制类型转换-1"><a href="#强制类型转换-1" class="headerlink" title="强制类型转换"></a>强制类型转换</h4><table><thead><tr><th>类型</th><th>16位机器</th><th>32位机器</th><th>64位机器</th></tr></thead><tbody><tr><td>char</td><td>8</td><td>8</td><td>8</td></tr><tr><td>short</td><td>16</td><td>16</td><td>16</td></tr><tr><td>int</td><td>16</td><td>32</td><td>32</td></tr><tr><td>long</td><td>32</td><td>32</td><td>64</td></tr><tr><td>long long</td><td>64</td><td>64</td><td>64</td></tr><tr><td>float</td><td>16</td><td>32（23+1）</td><td>32</td></tr><tr><td>double</td><td>64</td><td>64（52+1）</td><td>64</td></tr></tbody></table><ul><li>没有特殊说明，则默认 32 位机器</li><li>无损转换：char -&gt; int -&gt; long -&gt; double；float -&gt; double。<ul><li>在 32 位中，这些转换过程没有损失</li><li>在 64 位中，long -&gt; double 会出现精度损失</li></ul></li><li>有损转换：int -&gt; float；float -&gt; int<ul><li>判断是否会有精度损失，要从有效数字方面考虑</li><li>int：表示整数，范围 -2^31^ ～ 2^31^-1 ，有效数字 <strong>32</strong> 位</li><li>float：表示整数及小数，范围 ±[2^-126^ ～ 2^127^×(2−2^−23^)]，有效数字 <strong>23+1=24</strong> 位</li><li>int -&gt; float：可能损失精度（如 2^24^~2^31^-1 中无法被 float 表示的）</li><li>float -&gt; int：可能溢出（范围过大）及损失精度（表示小数）</li></ul></li></ul><h2 id="算术逻辑单元（ALU）"><a href="#算术逻辑单元（ALU）" class="headerlink" title="算术逻辑单元（ALU）"></a>算术逻辑单元（ALU）</h2><h3 id="电路的基本原理、加法器设计"><a href="#电路的基本原理、加法器设计" class="headerlink" title="电路的基本原理、加法器设计"></a>电路的基本原理、加法器设计</h3><h4 id="作用与原理"><a href="#作用与原理" class="headerlink" title="作用与原理"></a>作用与原理</h4><ul><li>机器字长是 CPU（ALU）一次能够处理的长度，一般等于寄存器的长度。因为输入输出数据存放的寄存器也要和 CPU 处理长度一致。</li><li>ALU 的功能。由控制单元 CU 发出的控制信号决定<ul><li>算术运算：加、减、乘、除等</li><li>逻辑运算：与、或、非、异或等</li><li>辅助功能：移位、求补等</li></ul></li></ul><h4 id="电路基础知识"><a href="#电路基础知识" class="headerlink" title="电路基础知识"></a>电路基础知识</h4><p><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part2/image-20211018152119179.png" alt="image-20211018152119179"></p><h4 id="加法器的实现"><a href="#加法器的实现" class="headerlink" title="加法器的实现"></a>加法器的实现</h4><h5 id="一位全加器"><a href="#一位全加器" class="headerlink" title="一位全加器"></a>一位全加器</h5><p><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part2/image-20211018153352014.png" alt="image-20211018153352014">、</p><h5 id="串行加法器"><a href="#串行加法器" class="headerlink" title="串行加法器"></a>串行加法器</h5><p><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part2/image-20211018153857365.png" alt="image-20211018153857365"></p><ul><li>串行加法器：只有一个全加器，数据逐位串行送入加法器中进行运算。<ul><li>进位触发器用来寄存进位信号，以便参与下一次运算。</li></ul></li><li>如果操作数长 n 位，加法就要分 n 次进行，每次产生一位和，并且串行逐位地送回寄存器。</li></ul><h5 id="并行加法器"><a href="#并行加法器" class="headerlink" title="并行加法器"></a>并行加法器</h5><p><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part2/image-20211018153931233.png" alt="image-20211018153931233"></p><ul><li>串行进位的并行加法器：把 n 个全加器串接起来，就可进行两个 n 位数的相加。</li><li>串行进位又称为行波进位，每一级进位直接依赖于前一级的进位，即进位信号是逐级形成的。</li><li>其性能很大程度依赖于 <strong>FA 产生进位</strong>和<strong>传递进位</strong>的速度</li></ul><h3 id="加法器、ALU的改进"><a href="#加法器、ALU的改进" class="headerlink" title="加法器、ALU的改进"></a>加法器、ALU的改进</h3><ul><li>第 i 位向更高位的进位 C<del>i</del> 可根据 <strong>被加数、加数的第 1~i 位</strong>、<strong>C<del>0</del></strong> 即可确定</li><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part2/image-20211018171510387.png" alt="image-20211018171510387"></li><li>并行进位的<strong>并行加法器</strong>：各级进位信号同时形成，又称为<strong>先行进位</strong>、<strong>同时进位</strong></li><li>为了避免电路过于复杂，设计为 4 个 FA 为一组，组成一个 CLA</li><li>G<del>i</del>：进位产生函数。（由本位确定的是否进位）</li><li>P<del>i</del>：进位传递函数。（本位会控制/屏蔽前一位的进位信息）</li><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part2/image-20211018172125934.png" alt="image-20211018172125934"></li><li>完成组内并行之后，各组之间依然是串行的结构<ul><li><strong>单级先行进位方式</strong>，又称为<strong>组内并行、组间串行</strong>进位方式。</li></ul></li><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part2/image-20211018172358547.png" alt="image-20211018172358547"></li><li>通过 CLA 电路，同时产生各组之间的进位信息<ul><li><strong>多级先行进位</strong>方式，又称为<strong>组内并行、组间并行</strong>进位方式</li></ul></li><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part2/image-20211018173324132.png" alt="image-20211018173324132"></li></ul><h1 id="习题课"><a href="#习题课" class="headerlink" title="习题课"></a>习题课</h1><h2 id="todo"><a href="#todo" class="headerlink" title="todo"></a>todo</h2>]]></content>
      
      
      <categories>
          
          <category> 计算机组成原理 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>计算机组成原理-Part1</title>
      <link href="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part1/"/>
      <url>/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part1/</url>
      
        <content type="html"><![CDATA[<h1 id="计算机组成原理-Part1——计算机系统概述"><a href="#计算机组成原理-Part1——计算机系统概述" class="headerlink" title="计算机组成原理-Part1——计算机系统概述"></a>计算机组成原理-Part1——计算机系统概述</h1><p>[TOC]</p><h2 id="开篇"><a href="#开篇" class="headerlink" title="开篇"></a>开篇</h2><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part1/image-20211002105534456.png" alt="image-20211002105534456" style="zoom:80%;"><ul><li><p>CPU、内存、硬盘上都有针脚。这些针脚就是用来接收高低电平的电信号的。</p></li><li><p>传递电信号就需要电脑主板上的印刷电路，这是可以导电的。</p></li><li><p>计算机体系结构 vs 计算机组成原理</p><ul><li><p>计算机体系结构：机器语言程序员所见到的计算机系统的属性概念性的结构与功能特性（指令系统、数据类型、寻址技术、I/O机理）</p><p>如何设计硬件与软件之间的接口。如：有无乘法指令</p></li><li><p>计算机组成原理：实现计算机体系结构所体现的属性，对程序员“透明”（具体指令的实现）</p><p>如何用硬件实现所定义的接口。如：如何实现乘法指令</p></li></ul></li></ul><h2 id="计算机发展历程（408大纲已删）"><a href="#计算机发展历程（408大纲已删）" class="headerlink" title="计算机发展历程（408大纲已删）"></a>计算机发展历程（408大纲已删）</h2><ul><li><p>计算机系统</p><ul><li><p>软件</p><ul><li><p>系统软件：用来管理整个计算机系统。</p><p>例如：操作系统、数据库管理系统(DBMS)、标准程序库(编程使用库)、网络软件(实现网络协议的模块)、语言处理程序(将高级语言转换成低级语言)、服务程序(调试程序)等。</p></li><li><p>应用软件：按任务需要编织成的各种程序。</p></li></ul></li><li><p>硬件</p></li></ul><p>计算机性能的好坏取决于“软”、“硬”件功能的总和。</p></li><li><p>硬件发展历程</p></li></ul><table><thead><tr><th>发展阶段</th><th>时间</th><th>逻辑元件</th><th>速度(次/秒)</th><th>内存</th><th>外存</th></tr></thead><tbody><tr><td>第一代</td><td>1946-1957</td><td><strong>电子管</strong></td><td>几千-几万</td><td>汞延迟线、磁鼓</td><td>穿孔卡片、纸带</td></tr><tr><td>第二代</td><td>1958-1964</td><td><strong>晶体管</strong></td><td>几万-几十万</td><td>磁芯存储器</td><td>磁带</td></tr><tr><td>第三代</td><td>1964-1971</td><td>中小规模<strong>集成电路</strong></td><td>几十万-几百万</td><td>半导体存储器</td><td>磁带、磁盘</td></tr><tr><td>第四代</td><td>1972-现在</td><td>大规模、超大规模集成电路</td><td>上千万-万亿</td><td>半导体存储器</td><td>磁盘、磁带、光盘、半导体存储器</td></tr></tbody></table><ul><li>发展趋势<ul><li>更微型、多用途</li><li>更巨型、超高速</li></ul></li></ul><h2 id="计算机系统层次结构"><a href="#计算机系统层次结构" class="headerlink" title="计算机系统层次结构"></a>计算机系统层次结构</h2><h3 id="计算机硬件的基本组成"><a href="#计算机硬件的基本组成" class="headerlink" title="计算机硬件的基本组成"></a>计算机硬件的基本组成</h3><h4 id="早期冯诺依曼结构"><a href="#早期冯诺依曼结构" class="headerlink" title="早期冯诺依曼结构"></a>早期冯诺依曼结构</h4><ul><li><strong>存储程序</strong>：将指令以二进制代码的形式事先输入计算机的主存储器，从首地址开始顺序执行指令至结束。<ul><li>针对问题：虽然早期冯诺依曼机的计算速度很快，但是 ENIAC 需要手动接线来控制计算，因此速度并不理想。</li></ul></li><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part1/image-20211002184657874.png" alt="image-20211002184657874"></li><li>在计算机系统中，软件和硬件在逻辑上是等效的。</li><li>冯·诺依曼计算机的特点：<ul><li><strong>计算机由五大部件组成：输入设备、输出设备、主存储器、运算器、控制器</strong></li><li>指令和数据以<strong>同等地位</strong>存于存储器，可<strong>按地址寻访</strong></li><li>指令和数据用二进制表示</li><li><strong>指令由操作码和地址码组成</strong></li><li>存储程序被首次提出</li><li><strong>以运算器为中心</strong>（输入/输出设备与存储器之间的数据传送通过运算器完成）</li></ul></li></ul><h4 id="现代计算机结构"><a href="#现代计算机结构" class="headerlink" title="现代计算机结构"></a>现代计算机结构</h4><ul><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part1/image-20211002185341049.png" alt="image-20211002185341049"></li><li>现代计算机：<strong>以存储器为中心</strong></li><li><strong>CPU=运算器+控制器</strong></li><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part1/image-20211002185424956.png" alt="image-20211002185424956"></li><li>计组中的主机只包括：<strong>CPU 和主存</strong>。硬盘等不属于主机。</li></ul><h3 id="认识各个硬件部件"><a href="#认识各个硬件部件" class="headerlink" title="认识各个硬件部件"></a>认识各个硬件部件</h3><h4 id="主存储器"><a href="#主存储器" class="headerlink" title="主存储器"></a>主存储器</h4><ul><li>MAR（Memory Address Register）：<strong>存储地址寄存器</strong>，专门存放单次操作的数据地址</li><li>MDR（Memory Data Register）：<strong>存储数据寄存器</strong>，专门存放单次操作的数据内容</li><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part1/image-20211002191934325.png" alt="image-20211002191934325"></li><li>存储单元：每个存储单元用来存放一串二进制代码。每个存储单元对应一个地址信息（即 MAR 中应当指明的信息）</li><li>存储字(<strong>word</strong>)：每个存储单元中的一串二进制代码，就是一个存储字</li><li>存储字长：存储单元/每个存储字中，包含的二进制代码的位数。*<em>长度一般为：k * 8 bit*</em></li><li>存储元：即存储二进制的电子元件（电容），每个存储元可存 1bit</li><li><strong>数据在存储体内按地址存储</strong></li><li><strong>MAR 位数反映存储单元的个数</strong>：MAR=4位 -&gt; 总共有 2^4^ 个存储单元</li><li><strong>MDR 位数 = 存储字长</strong>：MDR = 16位 -&gt; 每个存储单元可存放 16bit，1个字(word) = 16bit</li><li>易混淆：<ul><li><strong>1个字节（Byte）= 8bit</strong></li><li>1B = 1个字节，1b = 1个bit</li><li><strong>字(word)的长度由机器本身决定</strong></li></ul></li></ul><h4 id="运算器"><a href="#运算器" class="headerlink" title="运算器"></a>运算器</h4><ul><li>运算器：用于实现算术运算（如：加减乘除）、逻辑运算（如：与或非）</li><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part1/image-20211002193854953.png" alt="image-20211002193854953" style="zoom:80%;"></li><li>ACC：累加器，用于存放操作数，或运算结果</li><li>MQ：乘商寄存器，在乘、除运算时，用于存放操作数或运算结果</li><li>X：通用的操作数寄存器/通用寄存器，用于存放操作数。通常有多个，不过只需要一个就可以完成大部分运算</li><li>ALU：（※核心元件）算术逻辑单元，通过内部复杂的电路实现算数运算、逻辑运算</li></ul><h4 id="控制器"><a href="#控制器" class="headerlink" title="控制器"></a>控制器</h4><ul><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part1/image-20211002194312723.png" alt="image-20211002194312723" style="zoom:80%;"></li><li>CU（Control Unit）：（※核心元件）控制单元，分析指令，给出控制信号</li><li>IR（Instruction Register）：指令寄存器，存放<strong>当前执行的指令</strong></li><li>PC（Program Counter）：程序计数器，存放<strong>下一条指令地址</strong>，有自动加1功能</li></ul><h4 id="计算机工作流程"><a href="#计算机工作流程" class="headerlink" title="计算机工作流程"></a>计算机工作流程</h4><ul><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part1/image-20211002200948818.png" alt="image-20211002200948818" style="zoom:80%;"></li><li>工作过程：<ul><li>初始状态：指令、数据存入主存，PC 指向第一条指令</li><li>PC -&gt; MAR -&gt; 从存储体中取指令放入 MDR -&gt; 由于处于取指令周期，将指令数据放入 IR -&gt; 由 CU 分析指令（前半段二进制码） -&gt; 变量地址（后半段二进制）放入 MAR -&gt; 从存储体中取指令放入 MDR -&gt; 由于执行指令周期，将变量数据放入运算器寄存器中 -&gt; 执行运算并将结果放入 ACC -&gt; …… </li></ul></li><li>注：现在的计算机通常把 MAR、MDR 也集成在 CPU 内</li></ul><h3 id="计算机系统的多级层次结构"><a href="#计算机系统的多级层次结构" class="headerlink" title="计算机系统的多级层次结构"></a>计算机系统的多级层次结构</h3><h4 id="五层机器结构"><a href="#五层机器结构" class="headerlink" title="五层机器结构"></a>五层机器结构</h4><ul><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part1/image-20211003001409155.png" alt="image-20211003001409155" style="zoom:80%;"></li><li>下层是上层的基础，上层是下层的扩展<ul><li>高级语言机器</li><li>汇编语言机器</li><li>操作系统机器</li><li>传统机器</li><li>微程序机器</li></ul></li></ul><h4 id="三个级别语言"><a href="#三个级别语言" class="headerlink" title="三个级别语言"></a>三个级别语言</h4><ul><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part1/image-20211003002429374.png" alt="image-20211003002429374" style="zoom:80%;"></li><li>编译、汇编、解释程序，可统称“翻译程序”<ul><li>编译程序：将高级语言的源程序<strong>一次性</strong>翻译成汇编语言，或者直接翻译为机器语言的执行程序（只需翻译一次）</li><li>解释程序：将高级语言的源程序<strong>逐语句</strong>翻译成机器语言，并立即执行。（每次执行都要翻译）</li><li>汇编程序：将汇编语言翻译成机器语言。</li></ul></li></ul><h2 id="计算机的性能指标"><a href="#计算机的性能指标" class="headerlink" title="计算机的性能指标"></a>计算机的性能指标</h2><h3 id="存储器"><a href="#存储器" class="headerlink" title="存储器"></a>存储器</h3><ul><li><strong>MAR位数</strong>反映<strong>存储单元的个数</strong>（最多支持多少个）</li><li><strong>MDR位数</strong>=存储字长=<strong>每个存储单元的大小</strong></li><li><strong>总容量 = 存储单元个数×存储字长 bit = 存储单元个数×存储字长/8 Byte</strong> (1Byte=8bit)<ul><li>Eg：MAR为 32 位，MDR 为 8 位；总容量 = 2^32^ * 8 bit = 4 GB</li></ul></li></ul><blockquote><p>注：此处描述<strong>文件、容量大小</strong>等所用的 K、M、G、T </p><p>2^10^B：KB        2^20^B：MB        2^30^B：GB        2^40^B：TB</p></blockquote><h3 id="CPU"><a href="#CPU" class="headerlink" title="CPU"></a>CPU</h3><ul><li><strong>CPU 主频</strong>（时钟频率）：CPU 内数字脉冲信号振荡的频率。<ul><li>1s 内进行的数字脉冲信号次数</li><li>CPU 主频 = 1/CPU 时钟周期</li><li>单位：赫兹，Hz</li></ul></li><li><strong>CPU 时钟周期</strong>：一次脉冲信号的周期。<ul><li>单位：微秒、纳秒</li></ul></li><li><strong>CPI</strong>（Clock cycle Per Instruction）：执行一条指令所需的时钟周期数<ul><li>不同的指令，CPI 有可能不同</li><li>相同的指令，根据不同 CPU 的实现方式不同、当前内存负载不同等等一系列状态，CPI 也可能不同</li><li>可以影响 CPI 的因素太多，一般只讨论平均 CPI</li></ul></li><li><strong>执行一条指令的耗时</strong> = CPI × CPU时钟周期</li><li><strong>CPU 执行时间</strong>（整个程序的耗时）= CPU时钟周期数 / 主频 =（指令条数 * CPI）/ 主频</li><li><strong>IPS</strong>（ Instructions Per Second ）：每秒执行多少条指令<ul><li>IPS =  主频 / 平均 CPI</li><li>度量指标时经常使用 KIPS、MIPS</li></ul></li><li><strong>FLOPS</strong>（Floating-point Operations Per Second）：每秒执行多少次浮点运算<ul><li>度量指标时经常使用 KFLOPS、MFLOPS、GFLOPS、TFLOPS、PFLOPS、EFLOPS、ZFLOPS</li></ul></li></ul><blockquote><p>注：此处<strong>频率、速率</strong>常用的 K、M、G、T 为数量单位</p><p>K=Kilo=千=10^3^，M=Million=百万=10^6^，G=Giga=十亿=10^9^ ，T=Tera=万亿= 10^12^，P=10^3^T，E=10^3^P，Z=10^3^E</p></blockquote><h3 id="系统整体"><a href="#系统整体" class="headerlink" title="系统整体"></a>系统整体</h3><ul><li><p>数据通路带宽：数据总线一次所能并行传送信息的位数（各硬件部件通过数据总线传输数据）</p><ul><li>CPU &lt;=&gt; 主存储器 &lt;=&gt; I/O 设备。这之间的数据传输都需要依靠数据总线传输。</li></ul></li><li><p>吞吐量：指系统在单位时间内处理请求的数量。</p><ul><li>取决于信息能多快地输入内存，CPU 能多快地取指令，数据能多快地从内存取出或存入，以及所得结果能多快地从内存送给一台外部设备。</li><li>这些步骤中的每一步都关系到主存，因此，<strong>系统吞吐量主要取决于主存的存取周期</strong>。</li></ul></li><li><p>响应时间：指从用户向计算机发送一个请求，到系统对该请求做出响应并获得它所需要的结果的等待时间。</p><ul><li>通常包括 CPU 时间（运行一个程序所花费的时间）与等待时间（用于磁盘访问、存储器访问、I/O 操作、操作系统开销等时间）。</li></ul></li><li><p>基准程序：是用来测量计算机处理速度的一种实用程序，以便于被测量的计算机性能可以与运行相同程序的其它计算机性能进行比较。</p></li><li><p>思考：</p><ul><li>Q：主频高的 CPU 一定比主频低的CPU快吗？</li><li>A：不一定，如两个 CPU，A 的主频为 2GHz，平均 CPI=10；B 的主频 1GHz，平均 CPI=1…</li><li>Q：若 A、B 两个 CPU 的平均 CPI 相同，那么 A 一定更快吗？</li><li>A：也不一定，还要看指令系统。如：A 不支持乘法指令，只能用多次加法实现乘法；而 B 支持乘法指令。</li><li>Q：基准程序执行得越快说明机器性能越好吗？</li><li>A：基准程序中的语句存在频度差异，运行结果也不能完全说明问题，要看硬件具体的运用场景</li></ul></li></ul><h1 id="习题课"><a href="#习题课" class="headerlink" title="习题课"></a>习题课</h1><h2 id="1-1-4"><a href="#1-1-4" class="headerlink" title="1.1.4"></a>1.1.4</h2><ol><li><p>电子管 -&gt; 晶体管（开始出现高级语言 FORTRAN 和操作系统） -&gt; 中小规模集成电路 -&gt; 大规模集成电路</p></li><li><p><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part1/image-20211225130138631.png" alt="image-20211225130138631"></p></li><li><p>略</p></li><li><p>略</p></li><li><p>如果一个元器件可以表示 n 种状态，就可以使用 n 进制的信息位。</p><p>制约运算速度的主要因素：进位（串行部分）</p><p>要看处理的对象，才能比较是否方便（如开关、汉字个数）</p></li></ol><h2 id="1-2-6"><a href="#1-2-6" class="headerlink" title="1.2.6"></a>1.2.6</h2><ol><li>重点在于完整，计算机系统包括软件和硬件<ul><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part1/image-20211225132823528.png" alt="image-20211225132823528"></li></ul></li><li>冯诺依曼机是控制流驱动：先分析指令，再取数据<ul><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part1/image-20211225133004461.png" alt="image-20211225133004461"></li><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part1/image-20211225133134302.png" alt="image-20211225133134302"></li><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part1/image-20211225133357184.png" alt="image-20211225133357184"></li></ul></li><li>冯诺依曼机特点：存储程序</li><li>区分指令还是数据，是根据指令周期的不同阶段<ul><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part1/image-20211225134033970.png" alt="image-20211225134033970"></li></ul></li><li>软硬件逻辑上等效/具有等效性</li><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part1/image-20211225134555944.png" alt="image-20211225134555944"></li><li>同 6</li><li>地址译码器在内存，MAR 现在集成在 CPU 中<ul><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part1/image-20211225134729933.png" alt="image-20211225134729933"></li></ul></li><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part1/image-20211225134936136.png" alt="image-20211225134936136"></li><li>运算器不包含地址寄存器<ul><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part1/image-20211225135007694.png" alt="image-20211225135007694"></li></ul></li><li>寄存器 &gt; cache &gt; 主存</li><li><strong>地址空间</strong>由<strong>地址码长度</strong>决定，与<strong>存储字长</strong>无关</li><li>略</li><li>计算机软件<ul><li>系统软件（保证计算机正确运行的软件）<ul><li>操作系统</li><li>编译程序（语言处理软件）</li><li>连接程序（服务型程序）</li><li>数据库管理系统（DBMS）</li></ul></li><li>应用软件（为了解决某个应用领域中的问题而编制的软件）<ul><li>文本处理</li><li>数据库系统（DBS）</li></ul></li></ul></li><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part1/image-20211225135814437.png" alt="image-20211225135814437"></li><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part1/image-20211225140538572.png" alt="image-20211225140538572"></li><li>软硬件<strong>等效 ≠ 等价</strong>（效果一样，但是<strong>设计思想和代价都不一样</strong>）</li><li>略</li><li>同 14</li><li>相联存储器<strong>既可以按地址寻址，也可以按内容寻址</strong><ul><li>常用于段表、页表、块表、Cache 存放块地址</li></ul></li><li>下层是上层的基础，上层是下层的扩展</li><li>有且仅有机器语言可以直接执行</li><li>数据由指令的地址码给出</li></ol><h2 id="1-3-3"><a href="#1-3-3" class="headerlink" title="1.3.3"></a>1.3.3</h2><ol><li><p>数据通路、编译优化、时钟频率</p><ul><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part1/image-20211225142841289.png" alt="image-20211225142841289"></li></ul></li><li><p>速度指标</p><ul><li>标量机顺序执行，向量机并行执行，一般向量机更快</li><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part1/image-20211225143020163.png" alt="image-20211225143020163"></li></ul></li><li><p>同 2</p></li><li><p>同 1.2.6 的 9</p><ul><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part1/image-20211225134936136.png" alt="image-20211225134936136"></li></ul></li><li><p>机器字长如上，数据运算的基本单位长度；寄存器的基本单元是D触发器；字是 8 的倍数，不固定。</p></li><li><p>同 4；数据字长：数据总线一次能并行传输的位数，不一定等于 MDR。</p><ul><li>若存储字长 16 位，数据字长 4 位，则分 4 次发送</li></ul></li><li><p>多少位的计算机，则代表多少位的机器字长、多少位的寄存器</p></li><li><p><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part1/image-20211225153130706.png" alt="image-20211225153130706"></p></li><li><p>同 7</p></li><li><p>IR、MDR、MAR 对用户透明</p><ul><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part1/image-20211225154130102.png" alt="image-20211225154130102"></li></ul></li><li><p><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part1/image-20211225154540395.png" alt="image-20211225154540395"></p></li><li><p>时钟频率会影响程序运行速度，与每条指令所需多少时钟周期无关</p><ul><li>系统结构、组织，RISC or CISC，可以影响 CPI</li></ul></li><li><p>用户角度 -&gt; 交互 -&gt; 吞吐率</p></li><li><p><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part1/image-20211225155304411.png" alt="image-20211225155304411"></p></li><li><p>兼容：指计算机软件或硬件的通用性，即使用或运行在某个型号的计算机系统中的硬件，软件也能应用于另外一个型号的计算机系统时，则称这两台计算机在硬件或软件上存在兼容性。</p></li><li><p>知识储备！</p><ul><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part1/image-20211225155558146.png" alt="image-20211225155558146"></li><li>字：计算机进行数据处理时，一次存取、加工和传送的数据长度，不固定。</li><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part1/image-20211225155813190.png" alt="image-20211225155813190"></li><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part1/image-20211225155906567.png" alt="image-20211225155906567"></li></ul></li><li><p>IPS = 主频 / CPI</p></li><li><p>速度 +50% -&gt; 时间 / 150%</p></li><li><p>程序执行时间 = CPI × 指令条数 × 时钟周期</p></li><li><p>运行时间 = 指令数 × CPI / 主频</p><ul><li><blockquote><p>指令系统的组织逻辑：</p><ul><li>不同的实现方式 -&gt; 不同的 CPI</li><li>若指令集体系结构（ISA）和实现方式相同 -&gt; CPI 相同</li></ul></blockquote></li></ul></li><li><p>按指令长度分类（指令字长)：半字长指令、单字长指令、双字长指令</p><ul><li>指令寄存器 IR，要能够存储系统中最长的指令</li><li>定长指令字结构：指令系统中所有指令的长度都相等</li><li>变长指令字结构：指令系统中各种指令的长度不等</li></ul><p>浮点寄存器：</p><ul><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part1/image-20211225161715442.png" alt="image-20211225161715442"></li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> 计算机组成原理 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>推荐系统-完结目录</title>
      <link href="/2021/09/%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F-%E5%AE%8C%E7%BB%93%E7%9B%AE%E5%BD%95/"/>
      <url>/2021/09/%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F-%E5%AE%8C%E7%BB%93%E7%9B%AE%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<h1 id="推荐系统——完结目录"><a href="#推荐系统——完结目录" class="headerlink" title="推荐系统——完结目录"></a>推荐系统——完结目录</h1><p>教程传送门：</p><ul><li><p>老弓的学习日记：<a href="https://space.bilibili.com/34230158/search/video?keyword=%E6%8E%A8%E8%8D%90">https://space.bilibili.com/34230158/search/video?keyword=%E6%8E%A8%E8%8D%90</a></p></li><li><p>CSDN博文：<a href="https://blog.csdn.net/wuzhongqiang/article/details/107891787">https://blog.csdn.net/wuzhongqiang/article/details/107891787</a></p></li><li><p>王喆 – 《深度学习推荐系统》</p></li><li><p><a href="https://github.com/RUCAIBox/RecBole">https://github.com/RUCAIBox/RecBole</a></p></li></ul><p>RecBole 项目救命，快速复现，我愿称之为神。</p><table><thead><tr><th align="center"><a href="/2021/09/%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F-Part1/">推荐系统-Part1——概述</a></th></tr></thead><tbody><tr><td align="center"><strong><a href="/2021/09/%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F-Part2/">推荐系统-Part2——传统推荐模型</a></strong></td></tr><tr><td align="center"><strong><a href="/2021/09/%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F-Part3/">推荐系统-Part3——深度学习推荐模型</a></strong></td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 推荐系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>推荐系统-Part3</title>
      <link href="/2021/09/%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F-Part3/"/>
      <url>/2021/09/%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F-Part3/</url>
      
        <content type="html"><![CDATA[<h1 id="推荐系统-Part3——深度学习推荐模型"><a href="#推荐系统-Part3——深度学习推荐模型" class="headerlink" title="推荐系统-Part3——深度学习推荐模型"></a>推荐系统-Part3——深度学习推荐模型</h1><p>[TOC]</p><h2 id="AutoRec-模型"><a href="#AutoRec-模型" class="headerlink" title="AutoRec 模型"></a>AutoRec 模型</h2><ul><li>AutoRec 是将自编码器的思想和协同过滤结合起来的一种单隐层的神经网络推荐模型。</li><li>基本原理：利用协同过滤中的共现矩阵，完成物品向量或者用户向量的自编码，再利用自编码的结果得到用户对物品的预估评分。</li><li><img src="/2021/09/%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F-Part3/image-20210927202124750.png" alt="image-20210927202124750"></li><li>AutoRec 模型由于结构比较简单，表达能力不足，并且往往共现矩阵非常稀疏，更加加大了模型的预测难度。</li><li>所以，AutoRec 只是将深度学习思想应用于推荐系统的初步尝试，没有真正的投入到实践。</li></ul><h2 id="DeepCrossing-模型"><a href="#DeepCrossing-模型" class="headerlink" title="DeepCrossing 模型"></a>DeepCrossing 模型</h2><h3 id="基本思路"><a href="#基本思路" class="headerlink" title="基本思路"></a>基本思路</h3><p>输入一般会有类别型特征(如广告id)和数值型特征(如广告预算)两种情况。对于类别型特征，我们需要进行one-hot编码处理，而数值型特征，一般需要进行归一化处理，这样算是把数据进行了一个简单清洗。DeepCrossing 模型就是利用这些特征向量进行CRT预估。</p><p>为了完成端到端的训练，DeepCrossing 要在内部网络结构中解决如下问题：</p><ol><li>离散类特征编码后过于稀疏，不利于直接输入神经网络训练，需要解决稀疏特征向量稠密化的问题</li><li>如何解决特征自动交叉组合的问题</li><li>如何在输出层中达成问题设定的优化目标</li></ol><h3 id="网络结构"><a href="#网络结构" class="headerlink" title="网络结构"></a>网络结构</h3><ul><li>DeepCrossing 都是常规的结构，但具有革命意义，因为没有任何人工特征工程的参与。</li><li>相比于 FM、FFM 只具备二阶特征交叉能力的模型，DeepCrossing 可以通过调整神经网络的深度进行特征之间的深度交叉，这也是 Deep Crossing 名称的由来。</li></ul><p><img src="/2021/09/%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F-Part3/image-20210927223004876.png" alt="image-20210927223004876"></p><ol><li>Embedding 层：<ul><li>Embedding 的目的是将高维稀疏特征转化为低维稠密特征。</li><li>Feature#1 表示one-hot编码后非常稀疏的类别特征；Feature#2是数值型特征，不需要 embedding，直接进入 Stacking 层。</li><li>以字典形式存储每个类别特征域对应的 Embedding 矩阵，可以将 LabelEncoder 编码转化成一个数值型的特征向量。</li><li>每个类别特征域对应的 Embedding 矩阵的具体参数需要通过训练获得。</li></ul></li><li>Stacking 层：把不同的Embedding特征和数值型特征拼接在一起，形成新的包含全部特征的特征向量，该层通常也称为连接层</li><li>Multiple Residual Units 层：采用了多层残差网络的多层感知机。这样对特征向量各个维度进行充分的交叉组合，使得模型能够抓取更多的非线性特征和组合特征信息。</li><li>Scoring 层：输出层。对于 CTR 预估二分类问题，采用逻辑回归；对于多分类，采用 Softmax 模型。</li></ol><h2 id="NeuralCF-模型"><a href="#NeuralCF-模型" class="headerlink" title="NeuralCF 模型"></a>NeuralCF 模型</h2><h3 id="推荐算法中的两个根本性思路"><a href="#推荐算法中的两个根本性思路" class="headerlink" title="推荐算法中的两个根本性思路"></a>推荐算法中的两个根本性思路</h3><ul><li><p>用户和物品的表征：即如何更好地把用户特征和物品特征信息表示出来。隐语义模型(MF)，使用了 embedding 的思路去表示用户和物品，从而用向量的乘积表示用户对物品的喜好程度。</p></li><li><p>特征交叉：即考虑特征之间的交互信息以丰富数据的表达能力。因子分解机(FM)系列，就将特征两两交叉。</p></li></ul><p><img src="/2021/09/%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F-Part3/image-20210928101611434.png" alt="image-20210928101611434"></p><h3 id="存在问题"><a href="#存在问题" class="headerlink" title="存在问题"></a>存在问题</h3><ol><li>矩阵分解算法：试图在协同过滤共现矩阵的基础上，使用更稠密的隐向量表示用户和物品，挖掘用户和物品的隐含兴趣和隐含特征，在一定程度上弥补了协同过滤模型处理稀疏矩阵能力不足的问题。</li><li>隐向量的学习过程，在深度学习中就可以看成是一个简单的神经网络表示；用户向量和物品向量可以看成 embedding 方法。而最终的评分值(预测值)，就是用户向量和物品向量内积后的相似度。</li><li>而问题就在相似度计算上：相似度计算一般采用余弦相似度。其中必然包含两个向量做<strong>内积</strong>的过程，用向量之间的夹角大小来衡量相似度。</li><li>按理说相似用户，其隐向量也应该相似。但是研究表明单靠夹角衡量相似度不一定可靠。</li></ol><blockquote><p>这是因为，隐向量内积获得夹角关系，是降维至二维的操作。这一步造成了不可逆的信息损失。</p></blockquote><img src="/2021/09/%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F-Part3/image-20210928101521711.png" alt="image-20210928101521711" style="zoom:67%;"><h3 id="原始-NeuralCF"><a href="#原始-NeuralCF" class="headerlink" title="原始 NeuralCF"></a>原始 NeuralCF</h3><p>Neural CF 模型是从传统的协同过滤方法(MF)的基础上进行的改进：</p><ol><li>把MF里面用户向量和物品向量的点积操作换成了<strong>多层神经网络</strong>，使得两个向量可以做更充分的交叉，得到更多有价值的特征组合信息；</li><li>另外一个就是神经网络的激活函数可以引入更多的非线性，让模型的表达能力更强。</li></ol><p><img src="/2021/09/%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F-Part3/image-20210928102102351.png" alt="image-20210928102102351"></p><h3 id="GMF-广义矩阵分解"><a href="#GMF-广义矩阵分解" class="headerlink" title="GMF 广义矩阵分解"></a>GMF 广义矩阵分解</h3><ul><li><p>原始的矩阵分解：</p><ol><li>用户向量与物品向量进行内积。</li></ol></li><li><p>GMF 广义矩阵分解：</p><ol><li>用户向量与物品向量进行元素积。</li><li>神经网络拟合互操作结果。</li></ol></li><li><p>GMF 步骤：</p><ol><li>将 NeuralCF 的 Neural CF Layers 替换成 user 和 item 的 Embedding 做点积（对应元素相乘），得到一个和 Embedding 等长的向量</li><li>隐形量进行对应元素相乘之后，给每个元素分配权重（也就是各个隐向量维度的重要性不一定相同），等价于一个 Linear 层。（如果 h 是一个全1向量的话，那模型实际上就是 MF 了。）</li><li>使用 sigmoid 预测分数。</li></ol></li><li><p>GMF 评价：虽然赋予了权重，但依然没有摆脱降维带来的信息损失。</p></li></ul><h3 id="NeuralCF-混合模型-MLP-GMF"><a href="#NeuralCF-混合模型-MLP-GMF" class="headerlink" title="NeuralCF 混合模型(MLP + GMF)"></a>NeuralCF 混合模型(MLP + GMF)</h3><p><img src="/2021/09/%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F-Part3/image-20210928111455990.png" alt="image-20210928111455990"></p><ul><li>混合了 MLP 和 GMF，需要注意的是两个墨西哥的 embedding 是分开的。</li><li>无论是 MLP 还是 GMF，都采用 Embedding 的方式生成隐向量，而不是传统的矩阵分解 MF。</li><li>根据评分矩阵生成的隐向量（User 和 Item 的 Embedding 向量），其中每一个维度都可以看做是一种抽象特征，而特征交叉就是针对 Embedding 向量的每个维度进行交叉。</li><li>特征交叉的方式：<ol><li>GMF：线性方式——向量点积</li><li>MLP：非线性方式——多层神经网络</li><li>NeuralCF ：混合上述两种方式</li></ol></li></ul><h2 id="PNN-模型"><a href="#PNN-模型" class="headerlink" title="PNN 模型"></a>PNN 模型</h2><h3 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h3><ul><li>NeuralCF 不足：只用到了用户向量和物品向量，可以看成一个MF的加强版，但是没有考虑其他特征信息，这无疑是一种浪费。</li><li>Product-based Neural Network(PNN)：在加入多组特征的基础上研究的特征交叉，这个模型和 Deep Crossing 模型的架构类似，只不过把 Deep Crossing 的 stacking 层换成了 Product 层，也就是不同特征的 embedding 向量不再是简单的堆叠，而是两两交互，更有针对性的获取特征之间的交叉信息。</li><li>在这里面研究了两两特征之间的内积和外积两种交叉方式，提出了具体的两种模型 IPNN 和 OPNN。</li></ul><h3 id="网络结构-1"><a href="#网络结构-1" class="headerlink" title="网络结构"></a>网络结构</h3><p><img src="/2021/09/%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F-Part3/image-20210928135958913.png" alt="image-20210928135958913"></p><ol><li>输入层：模型输入由 N 个特征域（Field）组成，都是离散稀疏的分类特征。数值型特征要在类别性特征交叉完之后再合并。</li><li>Embedding 层：和 DeepCrossing 一样，对每一个离散稀疏的 Field 特征域进行 Embedding 操作，参数是通过神经网络的反向传播进行学习。</li><li>Product 层：<ul><li>线性操作部分和乘积操作部分。丰富了特征交叉的能力。</li><li>z 区域表示单独特征，是单个特征与参数 w 的运算；p 区域表示交叉特征，是特征两两内积后的特征与参数 w 的计算。</li><li>p 部分又分为内积(IPNN)和外积(OPNN)</li></ul></li><li>L1、L2 层：两层全连接，输入包含了离散型特征 l<del>p</del> 和 l<del>z</del> 以及数值型特征。</li><li>输出层：二分类预测问题，使用 sigmoid 激活输出。</li></ol><h2 id="Wide-amp-Deep模型"><a href="#Wide-amp-Deep模型" class="headerlink" title="Wide&amp;Deep模型"></a>Wide&amp;Deep模型</h2><h3 id="记忆能力和泛化能力"><a href="#记忆能力和泛化能力" class="headerlink" title="记忆能力和泛化能力"></a>记忆能力和泛化能力</h3><ul><li><p>记忆能力：</p><ul><li>模型直接学习并利用历史数据中物品和特征的“共现频率”的能力。</li><li>记住了历史数据的分布特点，由原始数据直接影响结果。</li></ul></li><li><p>泛化能力：</p><ul><li>模型传递特征的相关性，以及发掘稀疏甚至从未出现过的稀有特征与最终标签相关性的能力。</li><li>让数据稀少的用户或者物品也能生成隐性特征，获得全局数据的泛化支撑，深度发掘数据中的潜在模式。</li></ul></li></ul><h3 id="背景介绍"><a href="#背景介绍" class="headerlink" title="背景介绍"></a>背景介绍</h3><ul><li>在CTR预估任务中，利用手工构造的交叉组合特征来使线性模型具有“记忆性”，使模型记住共现频率较高的特征组合，往往能达到一个不错的baseline，且可解释性强。但这种方式有较为明显的缺点：1. 特征工程需要耗费太多精力。2. 对于未曾出现过的特征组合，权重系数为0，无法进行泛化。</li><li>为了加强模型的泛化能力，研究者引入了DNN结构、将高维稀疏特征编码为低维稠密的 Embedding vector，有效提高模型的泛化能力。但是，基于 Embedding 的方式遇到高度稀疏且高秩的共现矩阵时，长尾的一些特征值无法被充分学习，即使两者没有任何关系，也会由于 dense embedding 导致预测值非0，这便会造成模型泛化过度。</li><li>因此，现在主要的两种模型：<ol><li>协同过滤、逻辑回归等：能够从历史数据中学习到高频共现的特征组合能力，但是泛化能力不足；</li><li>矩阵分解、深度学习等：能够利用相关性的传递去探索历史数据中未出现的特征组合，挖掘数据潜在的关联模式，但是对于特定的场景（数据分布长尾，共现矩阵稀疏高秩）很难有效学习低纬度的表示，造成推荐的过渡泛化。</li></ol></li><li>Wide&amp;Deep 模型，将线性模型与 DNN  结合起来，在提高模型泛化能力的同时，兼顾模型的记忆性。</li><li>Wide&amp;Deep 后来成为推荐领域的经典模式，奠定了后面深度学习模型的基础。这个是一个里程碑式的改变，模型架构并没有多复杂，重点在于思想。</li></ul><h3 id="网络结构-2"><a href="#网络结构-2" class="headerlink" title="网络结构"></a>网络结构</h3><img src="/2021/09/%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F-Part3/image-20210928143913425.png" alt="image-20210928143913425" style="zoom:150%;"><p>W&amp;D 模型把单输入层的 Wide 部分和 Embedding + 多层全连接的部分连接起来，一起输入最终的输出层得到预测结果。单层的 wide 层善于处理大量的稀疏的 id 类特征，Deep 部分利用深层的特征交叉，挖掘在特征背后的数据模式。</p><h4 id="Wide"><a href="#Wide" class="headerlink" title="Wide"></a>Wide</h4><p>Wide 部分是一个广义的线性模型，用来处理神经网络并不擅长的离散特征。</p><ul><li>特征转换：cross-product transformation(原始特征的交互特征)，如果两个特征同时为1的时候，这个特征就是1，否则就是0，这是一种特征组合。</li><li>优化器：带 L1 正则的 FTRL 算法(Follow-the-regularized-leader)，该算法非常注重模型稀疏性质，可以使特征更加稀疏，即大部分参数都为0，就大大压缩了模型权重及特征向量的维度。</li></ul><blockquote><p>Wide 部分模型训练完之后留下来的特征都是非常重要的，那么模型的“记忆能力”就可以理解为发现”直接的”，“暴力的”，“显然的”关联规则的能力。</p></blockquote><h4 id="Deep"><a href="#Deep" class="headerlink" title="Deep"></a>Deep</h4><p>Deep 部分是 Embedding+MLP 的神经网络模型，用来挖掘藏在特征背后的数据模式。</p><p>输入的特征有两类：1. 数值型特征；2. 类别型特征(会经过 embedding)。</p><blockquote><p>大规模稀疏特征通过 Embedding 转化为低维密集型特征。</p><p>DNN 模型随着层数的增加，中间的特征就越抽象，也就提高了模型的泛化能力。</p></blockquote><h3 id="谷歌推荐系统的工业经验"><a href="#谷歌推荐系统的工业经验" class="headerlink" title="谷歌推荐系统的工业经验"></a>谷歌推荐系统的工业经验</h3><p>Wide&amp;Deep 模型本身的结构非常简单，但如何根据自己的场景去选择哪些特征放在 Wide 部分，哪些特征放在 Deep 部分是用好该模型的前提。</p><p><img src="/2021/09/%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F-Part3/image-20210928150837339.png" alt="image-20210928150837339"></p><p>Google Pay 通过检索来实现推荐的召回，将大规模的 App 应用缩小到小规模（例如100）的相关应用。然后在通过用户特征、上下文特征、用户行为特征等来建立推荐模型，估计用户点击每个 App 的概率分数进行排序，推荐 Top K 个 App。</p><p><img src="/2021/09/%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F-Part3/image-20210928151001327.png" alt="image-20210928151001327"></p><ol><li>Deep部分：全量的特征向量，包括用户年龄(age)、已安装应用数量(#app installs)、设备类型(device class)、已安装应用(installed app)、曝光应用impression app)等特征。其中，已安装应用，曝光应用等类别型特征，需要经过embedding层输入连接层，而数值型的特征和前面的特征拼接起来直接输入连接层，经过3层的Relu全连接层。</li><li>Wide部分：输入仅仅是已安装应用和曝光应用两类特征。其中已安装应用代表用户的历史行为，而曝光应用代表当前待推荐应用。选择这两部分是想发现当前曝光 APP 和用户已安装 APP 之间的关联，以充分发挥Wide的记忆能力，影响最终的得分。这部分是 L1 正则化的 FTRL 优化器，可能是因为这两个 id 类特征向量组合，在维度爆炸的同时，会让原本已经非常稀疏的 multihot 特征向量变得更加稀疏。因此采用FTRL过滤掉那些稀疏特征是非常好的工程经验。</li><li>两者结合：最后将两部分的特征再进行一个拼接，输出到 logistics Loss 层进行输出。</li></ol><h2 id="Deep-amp-Cross-模型"><a href="#Deep-amp-Cross-模型" class="headerlink" title="Deep&amp;Cross 模型"></a>Deep&amp;Cross 模型</h2><h3 id="基本思路-1"><a href="#基本思路-1" class="headerlink" title="基本思路"></a>基本思路</h3><ul><li>针对问题：Wide 部分有一个不足就是需要人工进行特征的组合筛选，过程繁琐且需要经验；2阶的FM模型在线性的时间复杂度中自动进行特征交互，但是这些特征交互的表现能力并不够，并且随着阶数的上升，模型复杂度会大幅度提高。</li><li>改进方向：用一个 Cross Network 替换掉 Wide 部分，来自动进行特征之间的交叉，并且网络的时间和空间复杂度都是线性的。</li></ul><h3 id="网络结构-3"><a href="#网络结构-3" class="headerlink" title="网络结构"></a>网络结构</h3><p><img src="/2021/09/%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F-Part3/image-20210928152058933.png" alt="image-20210928152058933"></p><ol><li>Embedding and stacking layer：作用依然是把稀疏离散的类别型特征变成低维密集型。</li><li>Cross Network：目的是增加特征之间的交互力度。<ul><li><img src="/2021/09/%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F-Part3/image-20210928154001138.png" alt="image-20210928154001138"></li><li>交叉层的操作的二阶部分非常类似 PNN 提到的外积操作。</li><li>思想上类似于残差连接。</li><li>x1 中包含了所有的 x0 的 1、2 阶特征的交互，x2 包含了所有的 x1、x0 的 1、2、3 阶特征的交互。因此，交叉网络层的叉乘阶数是有限的。第 l 层特征对应的最高叉乘阶数为 l+1。</li><li>每一层特征权重共享。</li><li>交叉网络的时间和空间复杂度是线性的。因为每一层都只有w和b，没有激活函数的存在，相对于深度学习网络，交叉网络的复杂性可以忽略不计。</li><li>Cross网络是FM的泛化形式</li><li>当两个稀疏特征不全为 1 时，就不会训练权重，也就不会进行交互。</li></ul></li><li>Deep Network：与 D&amp;W 相同。</li><li>组合层：将两个网络的输出拼接，并且 Logistics 回归</li></ol><h2 id="FNN-模型"><a href="#FNN-模型" class="headerlink" title="FNN 模型"></a>FNN 模型</h2><h3 id="基本思路-2"><a href="#基本思路-2" class="headerlink" title="基本思路"></a>基本思路</h3><ul><li><p>FNN 是在 W&amp;D 之前提出的</p></li><li><p>针对问题：1. Embedding 层收敛速度过慢；2. FM 虽然考虑了二阶交叉，但无法延伸到高阶交叉信息的学习。</p></li><li><p>Embedding 层收敛速度慢的原因：1. 输入极端稀疏化，众多的 0 导致 w 无法更新；2. 参数量往往占整个神经网络的大半以上。</p></li><li><p>解决方案：</p><ol><li>提前预训练好一个 FM 模型，该模型可以用来得到各特征隐向量。</li><li>然后用 FM 训练好的特征隐向量对正式训练的模型进行 Embedding 层的权重初始化。</li></ol></li></ul><h3 id="网络结构与训练细节"><a href="#网络结构与训练细节" class="headerlink" title="网络结构与训练细节"></a>网络结构与训练细节</h3><p><img src="/2021/09/%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F-Part3/image-20210928181946861.png" alt="image-20210928181946861"></p><ul><li>类似于 Deep Crossing 模型的经典深度神经网络，从稀疏输入向量到稠密向量的转换依然是embedding结构。</li><li>FNN 模型针对 Embedding 层收敛速度慢的问题，用 FM 模型替换了下面的 Embedding 层，并且在模型的正式训练之前，先提前训练好 FM，然后用 FM 训练好的特征隐向量对正式训练的模型进行 Embedding 层的初始化操作。</li><li>采用两阶段训练方式，是为了将 FM 作为有价值先验知识加入到模型中。防止因为数据稀疏带来的歧义造成模型参数偏差、加速模型收敛、充分利用 FM 的特征表达。</li><li>类似于迁移学习。</li></ul><h3 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h3><ul><li>优点：<ul><li>采用预训练的方式</li><li>采用了组合模型的思想，引入 DNN，可以进行特征的高阶组合，减少特征工程。</li></ul></li><li>缺点：<ul><li>两阶段的训练模型，应用过程不方便，且模型能力受限于 FM 表征能力的上限。</li><li>只关注于高阶特征的组合交叉，容易丢失记忆能力。</li><li>全连接层将向量的所有元素加权求和，不会对Field进行区分，本质又回到了 Deep Crossing 的问题。</li><li>特征的学习没有针对性。</li><li>两阶段的训练方式给神经网络调参带来难题。</li></ul></li></ul><h2 id="DeepFM-模型"><a href="#DeepFM-模型" class="headerlink" title="DeepFM 模型"></a>DeepFM 模型</h2><h3 id="基本思路-3"><a href="#基本思路-3" class="headerlink" title="基本思路"></a>基本思路</h3><ul><li>存在问题：<ul><li>简单的线性模型虽然简单，同样这样是它的不足，就是限制了模型的表达能力，随着数据的大且复杂，这种模型并不能充分挖掘数据中的隐含信息，且忽略了特征间的交互，如果想交互，需要复杂的特征工程。</li><li>FM模型考虑了特征的二阶交叉，但是这种交叉仅停留在了二阶层次，虽然说能够进行高阶，但是计算量和复杂性一下子随着阶数的增加一下子就上来了。所以二阶是最常见的情况，会忽略高阶特征交叉的信息</li><li>DNN，适合天然的高阶交叉信息的学习，但是低阶的交叉会忽略掉</li><li>W&amp;D 把简单的LR模型和DNN模型进行了组合，使得模型既能够学习高阶组合特征，又能够学习低阶的特征模式。但是W&amp;D的wide部分是用了LR模型，这一块依然是需要一些经验性的特征工程，且 Wide 部分和 Deep 部分需要两种不同的输入模式，这个在具体实际应用中需要很强的业务经验。</li></ul></li></ul><h3 id="网络结构-4"><a href="#网络结构-4" class="headerlink" title="网络结构"></a>网络结构</h3><p><img src="/2021/09/%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F-Part3/image-20210928185114897.png" alt="image-20210928185114897"></p><ul><li>DeepFM 也是两部分组成，左边的 FM + 右边的 DNN。</li><li>与 W&amp;D 和 DCN 相比，DNN 部分是相同的，区别在于 Wide 部分：1. W&amp;D 采用的是 LR；2. Deep&amp;Cross 采用 Cross 交叉网络；3. DeepFM 采用了 FM。后两者都是针对于 W&amp;D 的 wide 不具备自动特征组合能力的缺陷进行改进的。</li><li>Input、Embedding：与 Wide&amp;Deep 不同的是，DeepFM 中的 Wide 部分与 Deep 部分共享了输入特征，即 Embedding 向量。</li><li>FM：与 FNN 不同，FM 的隐向量参数也是当做学习参数一块学习的，以端到端方式训练整个网络。作者发现，通过高阶和低阶交互特征一块来进行反向传播更新参数反而会使得模型表现更佳，当然这也依赖于共享Embedding输入的策略。</li><li>Deep：与 Wide 使用相同的特征 Embedding。</li></ul><h3 id="论文细节"><a href="#论文细节" class="headerlink" title="论文细节"></a>论文细节</h3><ul><li><p>特征交互本质：</p><ul><li>二阶特征交互：通过对主流应用市场的研究，我们发现人们经常在用餐时间下载送餐的应用程序，这就表明应用类别和时间戳之间的（阶数-2）交互作用是 CTR 预测的一个信号。</li><li>三阶或者高阶特征交互：我们还发现男性青少年喜欢射击游戏和 RPG 游戏，这意味着应用类别、用户性别和年龄的(阶数-3)交互是 CTR 的另一个信号。</li><li>同时考虑低阶和高阶的交互特征，比单独考虑其中之一有更多的提升。</li></ul></li><li><p>人工特征工程的挑战性：</p><ul><li>一些特征工程比较容易理解，就比如上面提到的那两个，这时候往往我们都能很容易的设计或者组合那样的特征。 然而，其他大部分特征交互都隐藏在数据中，难以先验识别（比如经典的关联规则”尿布和啤酒“就是从数据中挖掘出来的，而不是由专家发现的），只能由机器学习自动捕捉。即使是对于容易理解的交互，专家们似乎也不可能详尽地对它们进行建模，特别是当特征的数量很大的时候。</li><li>所以，尽量的避免人工特征工程，构建端到端的推荐系统时作者研究该篇论文的另一动机所在（改进了W&amp;D）</li></ul></li><li><img src="/2021/09/%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F-Part3/image-20210928192807353.png" alt="image-20210928192807353" style="zoom:150%;"></li><li><p>FNN、PNN、W&amp;D 比较：</p><ul><li>FNN 模型：预训练的方式增加了开销，模型能力受限于 FM 表征能力的上限，且只考虑了高阶交互</li><li>PNN 模型：IPNN 的内积计算非常复杂，OPNN 的外积近似计算损失了很多信息，结果不稳定，且同样忽视了低阶交互</li><li>W&amp;D 模型：虽然是考虑到了低阶和高阶交互，兼顾了模型的泛化和记忆，但是 Wide 部分输入需要专业的特征工程经验，作者这里还举了个例子，比如用户安装应用和应用推荐中曝光应用的交叉，这个需要一些强的业务经验。</li></ul></li></ul><h2 id="NFM-模型"><a href="#NFM-模型" class="headerlink" title="NFM 模型"></a>NFM 模型</h2><h3 id="基本思路-4"><a href="#基本思路-4" class="headerlink" title="基本思路"></a>基本思路</h3><ul><li>NFM(Neural Factorization Machines)</li><li>FM 的问题：真实世界中的数据往往是非线性且内部结构复杂，而 FM 还是个线性模型，且交互仅仅限于二阶交互，所以作者认为 FM 在处理真实数据的时候，表达能力并不好。</li><li>改进方向：用一个表达能力更强的函数（神经网络）来替代原 FM 中二阶隐向量内积的部分。</li><li><img src="/2021/09/%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F-Part3/image-20210928213549920.png" alt="image-20210928213549920"></li></ul><h3 id="网络结构-5"><a href="#网络结构-5" class="headerlink" title="网络结构"></a>网络结构</h3><p><img src="/2021/09/%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F-Part3/image-20210928213748093.png" alt="image-20210928213748093"></p><p>类似于 PNN，由 product_layer 换成了 Bi-Interaction Pooling，这个也是NFM的核心结构了。</p><ul><li>Input、Embedding、DNN、Output 层：同之前。</li><li>Bi-Interaction Pooling layer：在 Embedding 和 DNN 之间加入的特征交叉池化层。<ul><li><img src="/2021/09/%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F-Part3/image-20210928214540185.png" alt="image-20210928214540185"></li><li>可以认为是特征域和特征域之间做交叉</li></ul></li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li>NFM 相比较于其他模型的核心创新点是特征交叉池化层，实现了 FM 和 DNN 的无缝连接，NN 可以在 low level 就学习到包含更多信息的组合特征。集合了 FM 二阶交叉线性和 DNN 高阶交叉非线性的优势，非常适合处理稀疏数据的场景任务</li><li>在特征交叉层和隐藏层加入 dropout 技术，有利于缓解过拟合，dropout也是线性隐向量模型过拟合的策略</li><li>在 NFM 中，使用 BN+Dropout 的组合会使得学习的稳定性下降， 具体使用的时候要注意</li><li>特征交叉池化层能够较好的对二阶特征信息的交互进行学习编码，这时候，就会减少 DNN 的很多负担，只需要很少的隐藏层就可以学习到高阶特征信息，也就是 NFM 相比之前的 DNN，模型结构更浅，更简单，但是性能更好，训练和调参更容易</li><li>NFM 对参数初始化相对不敏感，也就是不会过度依赖于预训练，模型的鲁棒性较强</li><li>深度学习模型的层数不总是越深越好，太深了会产生过拟合的问题，且优化起来也会困难</li></ul><h2 id="AFM-模型"><a href="#AFM-模型" class="headerlink" title="AFM 模型"></a>AFM 模型</h2><h3 id="基本思路-5"><a href="#基本思路-5" class="headerlink" title="基本思路"></a>基本思路</h3><ul><li>AFM(Attentional Factorization Machines)</li><li>针对问题：NFM 的特征交叉池化层对于各个交叉特征向量进行加和，没有考虑不同特征对结果的影响程度。这可能会影响最后的预测效果，因为不是所有的交互特征都能够对最后的预测起作，而没有用的交互特征就可能会产生噪声。</li><li>改进方向：引入注意力机制，学习不同交叉特征对于结果的不同影响程度。</li></ul><h3 id="网络结构-6"><a href="#网络结构-6" class="headerlink" title="网络结构"></a>网络结构</h3><p><img src="/2021/09/%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F-Part3/image-20210928220446143.png" alt="image-20210928220446143"></p><ul><li><p>Input、embedding、Output 层：同之前。</p></li><li><p>Pair-wise Interaction Layer：和 NFM 是一样的，采用的也是每对 Embedding 向量进行各个元素对应相乘（element-wise product）交互。</p></li><li><p>Attention based Pooling layer：在 Pair-wise Interaction Layer 和 Output layer 中间加入的 Attention 注意力网络。</p><ul><li><p><img src="/2021/09/%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F-Part3/image-20210928221437267.png" alt="image-20210928221437267"></p></li><li><p>主要思路：不同的特征交互向量在将它们压缩为单个表示时，根据对预测结果的影响程度给其加上不同权重。</p></li><li><p>其中aij表示v<del>i</del>⊙v<del>j</del>对的注意力分数，表示该交互特征对于预测目标的重要性程度。这个注意力分数可以作为参数然后通过最小化预测损失来进行学习，但是对于从未在训练数据中共同出现的特征，就无法估计其交互作用的注意力得分。所以为了解决泛化问题，这里才使用了一个多层感知器（MLP）将注意力得分参数化，就是上面的那个 Attention Net。</p></li><li><p>该注意力网络的结构是一个简单的单全连接层加 softmax 输出层的结构</p></li><li><p><img src="/2021/09/%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F-Part3/image-20210928221953070.png" alt="image-20210928221953070"></p></li></ul></li></ul><h2 id="DIN-模型"><a href="#DIN-模型" class="headerlink" title="DIN 模型"></a>DIN 模型</h2><h3 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h3><ul><li>Deep Interest Network(DIN) 模型非常重要，是基于业务的观察，从实际应用的角度进行的模型改进，完全符合以需求为导向的创新原则。</li><li>DIN 的论文写得非常精彩，建议读原文，里面不仅提出了DIN模型，并基于真实场景下大规模数据集的模型训练问题，提出了两种重要的训练技术。</li><li>DIN 模型的创新点或者解决的问题就是使用了注意力机制来对用户的兴趣动态模拟，非常注重用户的历史行为特征（历史购买过的商品或者类别信息）。</li></ul><h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><ul><li>拥有大量的用户历史行为信息。</li><li>用户兴趣多种多样，并且变化多端。</li><li>用户的兴趣往往蕴含在历史行为当中。</li><li>用户是否点击商品，很大程度上依赖于他的历史行为。</li><li>广告推荐两个主要的阶段：召回和排序。<ul><li>召回(matching stage): 通过协同过滤等方法生成与访问用户相关的候选广告列表</li><li>排序：就是通过排序模型来预测用户对于候选广告的点击概率，根据概率生成推荐列表</li></ul></li><li>大部分的推荐场景下都会有这两大步骤， 而商品广告推荐和一些其他推荐有些区别的是很注重用户的历史行为，因为这个直接与用户的兴趣相关， 而用户兴趣又反过来和商品挂钩。</li></ul><h3 id="基本思路-6"><a href="#基本思路-6" class="headerlink" title="基本思路"></a>基本思路</h3><ul><li>Embeding&amp;MLP 模型的存在问题：1. 无法表达用户广泛的兴趣；2. 并不是用户所有的历史行为特征都会对某个商品广告点击预测起到作用。</li><li>改进方向：1. 应该考虑到用户的历史行为商品与当前商品广告的一个关联性（局部兴趣），模拟出用户对商品的兴趣程度（注意力得分）。</li></ul><h3 id="特征表示"><a href="#特征表示" class="headerlink" title="特征表示"></a>特征表示</h3><img src="/2021/09/%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F-Part3/image-20210928231725615.png" alt="image-20210928231725615" style="zoom: 80%;"><p>工业上的CTR预测数据集一般都是 multi-group categorial form 的形式，就是类别型特征最为常见。</p><h3 id="网络结构-7"><a href="#网络结构-7" class="headerlink" title="网络结构"></a>网络结构</h3><img src="/2021/09/%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F-Part3/image-20210929082029917.png" alt="image-20210929082029917"><p>base 模型：</p><ol><li>Embedding layer：把高维稀疏的输入转成低维稠密向量。multi-hot 编码会得到一个 embedding 向量的列表。</li><li>pooling layer：pooling 层的作用是将用户的历史行为，即不定长的 embedding 向量，最终变成一个定长的向量。</li><li>Concat layer：把所有特征 embedding 向量，从特征维度拼接，作为MLP的输入。</li><li>MLP：普通全连接。</li><li>Loss：二分类的问题。<img src="/2021/09/%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F-Part3/image-20210929080649441.png" alt="image-20210929080649441"></li></ol><p>存在问题：</p><ol><li>用户的历史行为特征和当前的候选广告特征拼接之前，一点交互过程都没有。</li><li>拼接之后给 MLP，虽然有交互，但是既丢失了部分信息，也引入了部分噪声<ul><li>丢失信息：已经无法看出到底用户历史行为中的哪个商品与当前商品比较相关。</li><li>引入噪声：因为当前候选广告商品交互的是池化之后的历史特征 embedding，其包含了所有的历史商品信息。</li></ul></li></ol><p>改进思路：</p><ol><li>对于给定的候选广告，DIN 通过考虑历史行为与其相关性，自适应地计算用户兴趣的表示向量，该向量随不同广告而变化。</li></ol><img src="/2021/09/%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F-Part3/image-20210928231838285.png" alt="image-20210928231838285"><p>DIN 模型的 Activation Unit：</p><ul><li>位于 embedding 和 pooling 层之间。</li><li>用于计算用户历史行为商品和当前候选商品之间的相关性，即每个历史商品的权重。</li><li>不进行 softmax，目的是为了保留用户的兴趣强度。否则可能会因为过长的序列和 0-1 映射，使得权重差距不明显。</li></ul><h3 id="论文细节-1"><a href="#论文细节-1" class="headerlink" title="论文细节"></a>论文细节</h3><ol><li><p>Mini-batch Aware Regularization：为了防止模型过拟合，一般会加入正则化，而L2正则化加入的时候，是对于所有的参数都会起作用。像这种真实数据集中，每个mini-batch的样本特征是非常稀疏的，这种情况下根本就没有必要考虑所有的参数进去，这个复杂度会非常大。仅约束那些在当前 mini-batch 样本中出现的特征(不为0的那些特征) embedding 就可以了。</p></li><li><p>Data Adaptive Activation Function：随着数据分布而动态调整的自适应激活函数。</p><ul><li><img src="/2021/09/%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F-Part3/image-20210929084620252.png" alt="image-20210929084620252"></li><li><img src="/2021/09/%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F-Part3/image-20210929084636564.png" alt="image-20210929084636564"></li><li>这里的 E(s) 和 Var(s) 是每个 mini-batch 里面样本的均值和方差，当然这是训练集部分，测试集的时候采用的是在数据上平滑的均值和方差。由于把均值和方差考虑进去了，那么这个函数的调整就可以根据数据的分布进行自适应，这样会更加的灵活且合理。</li></ul></li><li><p>衡量模型改进程度的评价标准 RelaImpr：</p><ul><li><img src="/2021/09/%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F-Part3/image-20210929084951620.png" alt="image-20210929084951620"></li><li>基于 base model 评价模型的提高程度</li><li><img src="/2021/09/%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F-Part3/image-20210929085036339.png" alt="image-20210929085036339"></li><li>#inpressiong<del>i</del> 和 AUC<del>i</del> 分别是 i 用户的喜好和 AUC。</li><li>AUC = P(P<del>正样本</del> &gt; P<del>负样本</del>)</li></ul></li></ol><h2 id="DIEN-模型"><a href="#DIEN-模型" class="headerlink" title="DIEN 模型"></a>DIEN 模型</h2><h3 id="基本思路-7"><a href="#基本思路-7" class="headerlink" title="基本思路"></a>基本思路</h3><ol><li><p>DIN有两点不足：</p><ul><li>直接将用户过去的历史行为当做了用户的兴趣，缺乏对具体行为背后的潜在兴趣进行专门的建模。只计算了当前候选广告与过去历史行为的相关性，根据这个做出推荐，但历史行为之间的依赖关系并没有很好的模拟出来。历史行为其实也是一个随时间排序的序列，既然是时间相关的序列，就一定存在或深或浅的前后依赖关系，而这样的序列信息或者说依赖关系对推荐过程是非常有价值的(能够反映用户背后的潜在兴趣变化)，大量研究发现这种信息能够用于构建更丰富的用户模型并发现附加的行为模式，而DIN模型包括之前的MLP系列模型都无法学习到这样的序列依赖关系。</li><li>DIN 模型没法捕捉到用户的兴趣变化过程，作者在论文中用到了一个词叫做”兴趣漂移”，即在相邻的访问中，用户的意图可能非常不同，用户的一个行为可能依赖于很久以前的行为。而一个用户对不同目标项的点击行为受到不同兴趣部分的影响，如果没法学习用户的兴趣演化，就很容易基于用户所有购买历史行为综合推荐，而不是针对“下一次购买”推荐，DIN虽然是能够更加注重与当前候选物品相关的历史行为，但是这些行为并不能表示出用户的兴趣变化过程，所以序列信息是非常之重要的。</li><li>总结：DIN 忽略了序列信息，容易基于历史行为综合推荐，而不是针对下一次购买进行推荐。</li></ul></li><li><p>序列的重要性：</p><p>例如：上周一位用户在挑选一双篮球鞋，这位用户上周的行为序列都会集中在篮球鞋这个品类的商品上，但是完成购买之后，本周的购物兴趣可能变成买机械键盘。</p><ul><li>加强了最近行为对下次行为预测的影响。比如上面的例子，用户近期购买机械键盘的概率会明显高于再买篮球鞋的概率。</li><li>序列模型能够学习到购买趋势的信息。这个感觉就是在建模用户的兴趣演化，在上面例子中，序列模型能在一定程度上建立“篮球鞋”到“机械键盘”的转移概率，如果这个转移概率在全局统计意义上足够高，那么用户购买篮球鞋时，推荐机械键盘也会是一个不错的选项。直观上，两者的用户群体很有可能一致。</li></ul></li><li><p>兴趣的实际状况：</p><ul><li>同一时刻下，可能会拥有多种不同的兴趣，应该用兴趣状态描述</li><li>兴趣是动态变化的，拥有各自的演化过程</li><li>兴趣发展是有一定前因后果的</li><li>当前时刻的兴趣，都有可能由上个时刻的兴趣概率转移</li></ul></li><li><p>改进方向：将 DIN 的 embedding 到 concat 之间的部分替换成兴趣进化网络。</p></li></ol><h3 id="网络结构-8"><a href="#网络结构-8" class="headerlink" title="网络结构"></a>网络结构</h3><p><img src="/2021/09/%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F-Part3/image-20210929091931368.png" alt="image-20210929091931368"></p><ol><li>行为序列层(Behavior Layer)：主要作用是把原始的 id 类行为序列转成 Embedding 行为序列， 和 DIN 下面的 Embedding 层一样。</li><li>兴趣抽取层(Interest Extractor Layer): 主要作用是通过模拟用户的兴趣迁移过程，挖掘提取用户行为背后潜藏的状态，DIN 模型没有这个东西。这个也就是 DIN 的不足①的改进，能够学习到历史序列行为之间的序列依赖关系。<ul><li>auxiliary loss：帮助监督更新这一层的 GRU 参数。让当前时刻输出的隐藏状态 h<del>t</del> 尽量的与下一个时刻用户点击的行为 embedding 相似，与下一个时刻里面用户没有点击过的行为 embedding 越远。</li><li>原来的 GRU 是只在最后一个时间步进行输出，然后与真实 label 进行了一个交叉熵的计算，而改进的这个核心点是每个时间步都会有一个输出，然后都会与一个 label 进行一个交叉熵计算，所以这里就会多出了时间步 t 维度上的加和损失，还有点不同就是 label 这里，当前时间步用的 label 是下一个时间步的输入值。</li><li>引入 auxiliary loss 的原因：目标商品的点击行为是由最后的兴趣触发，而 label 只能监督最后的兴趣，对隐藏层的状态不能有效监督。</li></ul></li><li>兴趣进化层(Interest Evolving Layer)：主要作用是通过兴趣抽取层在兴趣抽取层的基础上加入注意力机制，模拟与目标广告相关的兴趣进化过程。这个和 DIN 引入注意力的思路其实是一脉相承的， 注意力的计算得分都是一致的。只不过这里这里不是把这个注意力计算的得分与兴趣抽取层的 h 简单加权组合了，而是把这个注意力操作嵌入到了 GRU 更新门里面去，形成了一个 AUGRU 的结构，用这个层来更有针对性的模拟与目标广告相关的兴趣进化路径。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 推荐系统 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>推荐系统-Part2</title>
      <link href="/2021/09/%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F-Part2/"/>
      <url>/2021/09/%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F-Part2/</url>
      
        <content type="html"><![CDATA[<h1 id="推荐系统-Part2——传统推荐模型"><a href="#推荐系统-Part2——传统推荐模型" class="headerlink" title="推荐系统-Part2——传统推荐模型"></a>推荐系统-Part2——传统推荐模型</h1><p>[TOC]</p><h2 id="协同过滤-CF"><a href="#协同过滤-CF" class="headerlink" title="协同过滤(CF)"></a>协同过滤(CF)</h2><h3 id="基本思想"><a href="#基本思想" class="headerlink" title="基本思想"></a>基本思想</h3><blockquote><p>协同过滤是推荐系统的必看内容，因为该算法是后来推荐算法的基本思想。</p></blockquote><ul><li>基本思想：根据用户之前的喜好以及其他兴趣相近的用户的选择来给用户推荐物品(基于对用户历史行为数据的挖掘发现用户的喜好偏向，并预测用户可能喜好的产品进行推荐)。</li><li>一般是仅仅基于用户的行为数据（评价、购买、下载等）, 而不依赖于项的任何附加信息（物品自身特征）或者用户的任何附加信息（年龄， 性别等）。</li><li>目前应用比较广泛的协同过滤算法是基于邻域的方法， 而这种方法主要有下面两种算法：<ul><li>基于用户的协同过滤算法(UserCF): 给用户推荐和他兴趣相似的其他用户喜欢的产品</li><li>基于物品的协同过滤算法(ItemCF): 给用户推荐和他之前喜欢的物品相似的物品</li></ul></li></ul><h3 id="目标场景"><a href="#目标场景" class="headerlink" title="目标场景"></a>目标场景</h3><ul><li><p>存在一系列数据：行为用户记录，列为用户行为目标(包括点击、点赞、购买哪些商品/视频等一些列行为)。</p><p><img src="/2021/09/%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F-Part2/image-20210927170905175.png" alt="image-20210927170905175"></p></li></ul><h3 id="相似度计算"><a href="#相似度计算" class="headerlink" title="相似度计算"></a>相似度计算</h3><ol><li><p>杰卡德相似度：衡量两个集合的相似度，也就是交并比。</p><ul><li><img src="/2021/09/%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F-Part2/image-20210926195359526.png" alt="image-20210926195359526"></li></ul></li><li><p>余弦相似度：衡量了两个用户向量(矩阵中的行向量) i 和 j 之间的向量夹角的大小，夹角越小，说明相似度越大，两个用户越相似。</p><ul><li><p><img src="/2021/09/%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F-Part2/image-20210926195502822.png" alt="image-20210926195502822"></p></li><li><p>局限性：对于不规范的评分数据敏感。例如：A 用户比较喜欢打高分(以95分为优秀)，而 B 用户比较喜欢打低分(以80分为优秀)。</p></li><li><p>```python<br>from sklearn.metrics.pairwise import cosine_similarity</p><p>i = [1, 0, 0, 0]<br>j = [1, 0.5, 0.5, 0]<br>consine_similarity([a, b])</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">3. 皮尔逊相关系数：先将两个向量都减去分别的均值，消除偏置的影响，然后再计算向量角度 consine 值。</span><br><span class="line"></span><br><span class="line">   - ![image-20210926202642997](推荐系统-Part2&#x2F;image-20210926202642997.png)</span><br><span class="line"></span><br><span class="line">   - &#96;&#96;&#96;python</span><br><span class="line">     from scipy.stats import pearsonr</span><br><span class="line">     </span><br><span class="line">     i &#x3D; [1, 0, 0, 0]</span><br><span class="line">     j &#x3D; [1, 0.5, 0.5, 0]</span><br><span class="line">     pearsonr(i, j)</span><br></pre></td></tr></table></figure></li></ul></li><li><p>其他：欧式距离、曼哈顿距离、马氏距离。</p><ul><li>欧式距离体现数值上的绝对差异，而余弦距离体现方向上的相对差异。</li><li>如果要分析两个用户对于不同视频的偏好：以观看比例作为特征时，用户A观看向量(0,1)，用户B观看向量(1,0)，此时二者的余弦距离很大，而欧式距离很小。因此，更关注相对差异，应当用余弦距离。</li><li>如果要分析用户活跃度：以登录次数和平均观看时长作为特征时，余弦距离会认为(1,10)和(10,100)两个用户距离很近，但显然这两个用户活跃度是有着极大差异的。此时我们关注的是数值绝对差异，应当使用欧式距离。</li></ul></li></ol><h3 id="最终结果预测"><a href="#最终结果预测" class="headerlink" title="最终结果预测"></a>最终结果预测</h3><ol><li>利用 用户相似度(Wu,s) 和 相似用户的评价(Rs,p) 加权平均获得用户的评价预测：<ul><li><img src="/2021/09/%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F-Part2/image-20210926211009685.png" alt="image-20210926211009685"></li></ul></li><li>在用户相似度和相似用户的评价加权平均的基础上，将用户的评价都减去此用户的所有评分的均值：<ul><li><img src="/2021/09/%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F-Part2/image-20210926211027717.png" alt="image-20210926211027717"></li></ul></li></ol><h3 id="基于用户的协同过滤"><a href="#基于用户的协同过滤" class="headerlink" title="基于用户的协同过滤"></a>基于用户的协同过滤</h3><ul><li><p>对于需要个性化推荐的用户A，可以先找到和用户A有相似兴趣的其他用户，然后把那些用户喜欢的且用户A没有听说过的物品推荐给A。</p><p><img src="/2021/09/%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F-Part2/image-20210927170929803.png" alt="image-20210927170929803"></p></li></ul><p>步骤：</p><ol><li>根据已有的用户向量，计算与目标用户的相似度，找到最相似的 n 个用户。</li><li>根据这 n 个相似用户对目标行为的分数，加权平均来预测目标用户对目标行为的分数。</li></ol><p>缺点：</p><ol><li>数据稀疏性：在大型的电子商务中物品繁多，不同用户之间买的物品重叠性低，难以找到偏好相似的用户。<strong>UserCF 不适用于那些正反馈获取较困难的应用场景</strong>。</li><li>算法扩展性：需要维护用户相似度矩阵，该矩阵的存储开销大，且随着用户数量的增加而增加。<strong>不适合用户数据量大的情况使用</strong>。</li></ol><h3 id="基于物品的协同过滤"><a href="#基于物品的协同过滤" class="headerlink" title="基于物品的协同过滤"></a>基于物品的协同过滤</h3><ul><li><p>对于需要推广的物品A，可以先找到和物品A有相似用户群体的其他物品，然后把物品A推荐给相似物品的用户群体。</p></li><li><p>减缓 UserCF 的数据稀疏性和算法扩展性问题。</p><p><img src="/2021/09/%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F-Part2/image-20210927171027279.png" alt="image-20210927171027279"></p></li></ul><p>步骤：</p><ol><li>根据已有的物品向量，计算与目标物品之间的相似度，找到最相似的 n 个物品。</li><li>根据物品的相似度和用户的历史行为给用户生成推荐列表（购买了该商品的用户也经常购买的其他商品）</li></ol><p>优点：</p><ol><li>Item-based 算法的预测结果比 User-based 算法的质量要高一点。</li><li>由于 Item-based 算法可以预先计算好物品的相似度，所以在线的预测性能比 User-based 算法高。</li></ol><p>缺点：</p><ol><li>依然存在数据稀疏性。</li><li>用户的增长也会导致物品相似度矩阵维护难度变大。</li></ol><h3 id="应用场景区别"><a href="#应用场景区别" class="headerlink" title="应用场景区别"></a>应用场景区别</h3><table><thead><tr><th></th><th>UserCF</th><th>ItemCF</th></tr></thead><tbody><tr><td>性能</td><td>适合用户较少的场合，否则维护用户相似度矩阵代价较大</td><td>适合物品数远小于用户数的场合。如果物品太多，则维护物品相似度矩阵代价大</td></tr><tr><td>领域</td><td>时效性较强、具备强社交性、用户个性化弱的场合（热点新闻、发觉潜在喜好）</td><td>兴趣变化较为稳定、物品更新慢、用户个性化强烈的领域（推荐艺术品， 音乐， 电影）</td></tr><tr><td>实时性</td><td>用户的新行为不一定对推荐结果造成立即变化</td><td>用户的新行为一定会导致推荐结果的实时变化</td></tr><tr><td>推荐理由</td><td>很难提供令用户信服的推荐结识</td><td>利用用户的历史行为为用户推荐解释，具有信服力</td></tr></tbody></table><h3 id="存在问题分析"><a href="#存在问题分析" class="headerlink" title="存在问题分析"></a>存在问题分析</h3><ol><li>无法利用更多的信息。完全没有利用到物品或者用户的自身属性，仅利用用户与物品的交互信息就可以实现推荐，是一个可解释性强，直观、但也存在问题的模型。</li><li>较差的稀疏向量处理能力，泛化能力弱。热门物品具有很强的头部效应，容易跟大量物品产生相似，而尾部物品由于特征向量稀疏，导致很少被推荐。</li></ol><h2 id="矩阵分解-MF"><a href="#矩阵分解-MF" class="headerlink" title="矩阵分解(MF)"></a>矩阵分解(MF)</h2><h3 id="基本思路"><a href="#基本思路" class="headerlink" title="基本思路"></a>基本思路</h3><ul><li>矩阵分解算法通过引入了隐向量的概念，加强了模型处理稀疏矩阵的能力，也为后续深度学习推荐系统算法中 Embedding 的使用打下了基础。</li><li>也就是加入隐含层，抽象化用户和物品之间的特征。这个特征信息需要去挖掘。</li><li>针对问题：1. 协同过滤处理稀疏向量能力差；2. 维护相似矩阵难度大</li></ul><h3 id="隐语义模型"><a href="#隐语义模型" class="headerlink" title="隐语义模型"></a>隐语义模型</h3><ul><li><p>核心思想：通过隐含特征（latent factor）联系用户兴趣和物品（item），基于用户的行为找出潜在的主题和分类，然后对 item 进行自动聚类，划分到不同类别/主题（用户的兴趣）。</p><p><img src="/2021/09/%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F-Part2/image-20210926223713170.png" alt="image-20210926223713170"></p></li><li><p>矩阵分解算法将 m×n 维的共享矩阵 R分解成 m×k 维的用户矩阵 U 和 k×n 维的物品矩阵 V 相乘的形式。其中 m 是用户数量，n 是物品数量，k是隐向量维度（隐含特征个数），只不过这里的隐含特征变得不可解释了。k 的大小决定了隐向量表达能力的强弱，k 越大，表达信息就越强。</p></li><li><p>抽象的特征使得用户和物品向量更加稠密，解决了处理稀疏向量能力差的问题。</p></li><li><p>维护相似矩阵由用户相似矩阵的 m×m 和物品矩阵的 n×n 降低到了 (m+n)×k，解决了维护相似矩阵难度大的问题。</p></li><li><p>预测评分公式：<img src="/2021/09/%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F-Part2/image-20210926224159177.png" alt="image-20210926224159177"></p></li></ul><h3 id="MF的几种方式"><a href="#MF的几种方式" class="headerlink" title="MF的几种方式"></a>MF的几种方式</h3><ul><li>特征值分解(EVD)：1. 要求矩阵是方阵，是不符合实际场景的。</li><li>奇异值分解(SVD)：1. 要求矩阵稠密，而实际场景非常稀疏。2. 一旦补全会导致空间复杂度非常高，且补得不一定正确。3. 计算复杂度非常高，基本无法使用。</li></ul><h4 id="Basic-SVD-LFM、Funk-SVD"><a href="#Basic-SVD-LFM、Funk-SVD" class="headerlink" title="Basic SVD(LFM、Funk-SVD)"></a>Basic SVD(LFM、Funk-SVD)</h4><ul><li>把矩阵分解问题转换成最优化问题，通过梯度下降进行优化。</li><li>预测函数：<img src="/2021/09/%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F-Part2/image-20210926230607417.png" alt="image-20210926230607417"></li><li>损失函数：<img src="/2021/09/%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F-Part2/image-20210926230642256.png" alt="image-20210926230642256"></li><li>优化目标：<img src="/2021/09/%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F-Part2/image-20210926230705295.png" alt="image-20210926230705295"></li><li>求梯度：<img src="/2021/09/%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F-Part2/image-20210926230925915.png" alt="image-20210926230925915"></li><li>梯度更新：<img src="/2021/09/%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F-Part2/image-20210926231028214.png" alt="image-20210926231028214"></li></ul><h4 id="RSVD"><a href="#RSVD" class="headerlink" title="RSVD"></a>RSVD</h4><ul><li>在 Basic SVD 的基础上，在目标函数中加入正则化参数（加入惩罚项），对于目标函数来说，Q矩阵和V矩阵中的所有值都是变量，这些变量在不知道哪个变量会带来过拟合的情况下，对所有变量都进行惩罚：<img src="/2021/09/%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F-Part2/image-20210926233756786.png" alt="image-20210926233756786"></li><li>梯度的更新公式就变成了：<img src="/2021/09/%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F-Part2/image-20210926233828417.png" alt="image-20210926233828417"></li></ul><p>进一步优化：</p><ul><li><p>Netfix Prize中提出了另一种LFM，在原来的基础上加了偏置项，来消除用户和物品打分的偏差，预测公式：</p><p><img src="/2021/09/%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F-Part2/image-20210926233946536.png" alt="image-20210926233946536"></p></li><li><p>这个预测公式加入了3项偏置μ,b<del>u</del>,b<del>i</del>：</p><ul><li>μ：训练集中所有记录的评分的全局平均数。在不同网站平台中， 因为网站定位和销售物品不同，网站的整体评分分布也会显示差异。比如有的网站中用户就喜欢打高分，有的网站中用户就喜欢打低分。而全局平均数可以表示网站本身对用户评分的影响。</li><li>b<del>u</del>：用户偏差系数，可以使用定值(用户 u 给出的所有评分的均值)，也可以当做训练参数。这一项表示了用户的评分习惯中和物品没有关系的那种因素。比如有些用户比较苛刻，对什么东西要求很高，那么他评分就会偏低；而有些用户比较宽容，对什么东西都觉得不错，那么评分就偏高。</li><li>b<del>i</del>：物品偏差系数，可以使用定值(物品 i 收到的所有评分的均值)，也可以当做训练参数。这一项表示了物品接受的评分中和用户没有关系的因素。比如有些物品本身质量就很高，因此获得的评分相对比较高，有的物品本身质量很差，因此获得的评分相对较低。</li></ul></li></ul><h4 id="SVD"><a href="#SVD" class="headerlink" title="SVD++"></a>SVD++</h4><ul><li>之前都是从用户和用户之间的相似度、其他用户对物品的评分进行预测推荐，而缺少考虑用户本身的历史行为对评分预测的影响。</li><li>即，之前只考虑分解当前的共现矩阵，注意：此时并没有考虑该用户评分的历史物品。</li><li>经过一系列的演化，最终预测公式为：<img src="/2021/09/%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F-Part2/image-20210927094726696.png" alt="image-20210927094726696"></li><li>其中，1/√|N(u)| 是为了保证方差一致性。</li></ul><h3 id="优点-amp-局限性"><a href="#优点-amp-局限性" class="headerlink" title="优点&amp;局限性"></a>优点&amp;局限性</h3><p>优点：</p><ol><li>泛化能力强，一定程度上解决了数据稀疏的问题，通过为用户和物品的隐语义标签抽象化了特征。</li><li>空间复杂度低。UserCF(m×m)、ItemCF(n×n) -&gt; 用户隐向量(m×k) + 物品隐向量(n×k)</li><li>更好的扩展性和灵活性。可以和其他特征组合拼接，与深度学习网络无缝结合。</li></ol><p>局限性：</p><ol><li>与协同过滤一样，无法利用用户特征、物品特征、上下文特征。</li><li>缺乏用户历史行为时，无法推荐。</li></ol><h2 id="逻辑回归-LR"><a href="#逻辑回归-LR" class="headerlink" title="逻辑回归(LR)"></a>逻辑回归(LR)</h2><h3 id="基本思想-1"><a href="#基本思想-1" class="headerlink" title="基本思想"></a>基本思想</h3><ul><li>基础知识：逻辑回归、极大似然估计。<ul><li>逻辑回归做为神经网络中的最基础单一神经元</li><li>逻辑回归假设数据服从伯努利分布，通过极大化似然函数的方法，运用梯度下降来求解参数，来达到将数据二分类的目的。</li></ul></li><li>针对问题：协同过滤无法有效利用用户、物品、上下文等多种不同的特征。</li><li>改进方向：将推荐问题转化成了一个二分类问题。</li></ul><h3 id="推荐过程"><a href="#推荐过程" class="headerlink" title="推荐过程"></a>推荐过程</h3><ol><li><p>将用户年龄、性别、物品属性、物品描述、当前时间、当前地点等特征转成数值型向量。</p></li><li><p>确定逻辑回归的优化目标，比如把点击率预测转换成二分类问题，这样就可以得到分类问题常用的损失作为目标，训练模型。</p></li><li><p>在预测的时候，将特征向量输入模型产生预测，得到用户“点击”物品的概率。</p></li><li><p>利用点击概率对候选物品排序，得到推荐列表。</p><p><img src="/2021/09/%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F-Part2/image-20210927171345229.png" alt="image-20210927171345229"></p></li></ol><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ol><li>LR模型形式简单，可解释性好，从特征的权重可以看到不同的特征对最后结果的影响。</li><li>训练时便于并行化，在预测时只需要对特征进行线性加权，性能好，适合处理海量id类特征。用id类特征有一个很重要的好处，就是防止信息损失（相对于范化的 CTR 特征），对于头部资源会有更细致的描述。</li><li>资源占用小，尤其是内存。在实际的工程应用中只需要存储权重比较大的特征及特征对应的权重。</li><li>方便输出结果调整。逻辑回归可以很方便的得到最后的分类结果，因为输出的是每个样本的概率分数，我们可以很容易的对这些概率分数进行cutoff，也就是划分阈值。</li><li>工程化需要。在深度学习技术之前，逻辑回归凭借易于并行化、模型简单、训练开销小等特点，占领工程领域的主流。因为即使工程团队发现了复杂模型会提升效果，但一般如果没有把握击败逻辑回归的话仍然不敢尝试或者升级。</li></ol><h3 id="局限性"><a href="#局限性" class="headerlink" title="局限性"></a>局限性</h3><ol><li>表达能力不强，无法进行特征交叉、特征筛选等一系列高级操作，因此可能造成信息的损失。</li><li>准确率并不是很高。因为这毕竟是一个线性模型加了个 sigmoid，形式非常的简单，很难去拟合数据的真实分布。</li><li>处理非线性数据较麻烦。逻辑回归在不引入其他方法的情况下，只能处理线性可分的数据，如果想处理非线性，首先对连续特征的处理需要先进行离散化，而人工分桶的方式会引入多种问题。</li><li>LR 需要进行人工特征组合，这就需要开发者有非常丰富的领域经验，才能不走弯路。这样的模型迁移起来比较困难，换一个领域又需要重新进行大量的特征工程。</li></ol><h2 id="自动特征交叉"><a href="#自动特征交叉" class="headerlink" title="自动特征交叉"></a>自动特征交叉</h2><h3 id="基本思想-2"><a href="#基本思想-2" class="headerlink" title="基本思想"></a>基本思想</h3><ul><li><p>该算法属于对逻辑回归(LR)算法应用在推荐系统上的一个改进，在LR模型的基础上加上了特征交叉项，该思想不仅在传统的推荐算法中继续使用过，在深度学习推荐算法中也对其进行了改进与应用。</p></li><li><p>针对问题：逻辑回归只对单一特征做简单加权，不具备特征交叉生成组合特征的能力，因此表达能力受到了限制。</p></li><li><p>如：“化妆品”类商品与“女”性，“球类运动配件”的商品与“男”性，“电影票”的商品与“电影”品类偏好……</p></li></ul><h3 id="POLY2——特征交叉的开始"><a href="#POLY2——特征交叉的开始" class="headerlink" title="POLY2——特征交叉的开始"></a>POLY2——特征交叉的开始</h3><ul><li>POLY2是二阶多项式模型，对所有特征进行两两交叉、暴力组合。</li><li>针对问题：在逻辑回归里面，如果想得到组合特征，往往需要人工在特征工程的时候手动的组合特征，然后再进行筛选，低效且玄学。</li><li>数学形式：<img src="/2021/09/%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F-Part2/image-20210927165630280.png" alt="image-20210927165630280"></li><li>优点：<ol><li>保留了逻辑回归的优点：充分利用用户特征、物品特征、上下文特征。</li><li>一定程度上解决了特征组合的问题。</li></ol></li><li>存在问题：<ol><li>推荐系统中的数据稀疏性是实际问题中不可避免的挑战(类别型数据经过独热），经过特征较差之后特征向量更加稀疏，使得大部分特征交叉的权重缺乏有效训练，无法收敛。</li><li>训练复杂度由 O(n) 上升到 O(n^2^)</li></ol></li></ul><h3 id="FM——隐向量特征交叉"><a href="#FM——隐向量特征交叉" class="headerlink" title="FM——隐向量特征交叉"></a>FM——隐向量特征交叉</h3><ul><li>因子分解机(Factorization Machine, FM)</li><li>针对问题：1. 在面对稀疏数据向量时，PLOY2特征交叉项无法收敛。2. PLOY2 计算复杂度过高。</li><li>数学模型：<img src="/2021/09/%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F-Part2/image-20210927172557690.png" alt="image-20210927172557690" style="zoom:67%;"></li><li>优点：<ol><li>极大降低了训练开销 O(n^2^) -&gt; O(kn)</li><li>引入隐向量，更好地解决数据稀疏性的问题</li><li>FM 模型是利用两个特征的 Embedding 做内积得到二阶特征交叉的权重。可以将训练好的 FM 特征离线训练保存，以便其他拓展。</li></ol></li></ul><h3 id="FFM——引入特征域"><a href="#FFM——引入特征域" class="headerlink" title="FFM——引入特征域"></a>FFM——引入特征域</h3><ul><li><p>域感知因子分解机(Field-aware Factorization Machine, FFM)</p></li><li><p>先对特征根据性质的不同进行了一个分类，不同的分类就是不同的域，域内特征一般都是同一个 categorical 特征经过 One-Hot 编码生成的数值特征。</p><p>对于连续特征，一个特征就对应一个域；或者可以对连续特征离散化，一个分箱成为一个特征，总的分箱是一个域。</p><p><img src="/2021/09/%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F-Part2/image-20210927185945062.png" alt="image-20210927185945062"></p></li><li><p>改进方向：针对不同的交叉域要学习不同的隐向量特征</p></li><li><p>优点：引入了更多有价值的信息，表达能力更强。</p></li><li><p>缺点：</p><ol><li>参数量：FM: k×n -&gt; FFM: f×k×n</li><li>时间复杂度：FM: O(kn) -&gt; FFM: O(kn^2^)</li><li>局限在二阶特征交叉</li></ol></li><li><p>工业改进：</p><ol><li>模型上：双线性FFM(新浪微博张俊林团队)，减少参数量的一种优化思路，共享W矩阵。</li><li>业务上：对特征域再进行抽象，减少域的数量。比如说，对 100 个域进行再分类，分为上下文特征、用户特征、item特征、交互特征和匹配特征五大类，实际应用时只考虑这 5 个域即可。</li></ol></li></ul><h2 id="GBDT-LR"><a href="#GBDT-LR" class="headerlink" title="GBDT+LR"></a>GBDT+LR</h2><h3 id="基本思想-3"><a href="#基本思想-3" class="headerlink" title="基本思想"></a>基本思想</h3><ul><li>该模型仍然是对LR模型的改进，使用树模型做特征交叉，相比于 FM 的二阶特征交叉，树模型可以对特征进行深度的特征交叉，充分利用了特征之间的相关性。</li><li>针对问题：<ol><li>LR 模型无法进行特征交叉、特征筛选等一些列操作。</li><li>FM、FFM只能做二姐特征交叉，如果继续提高特征交叉的维度，会不可避免地出现组合爆炸和计算复杂度过高的问题。</li></ol></li></ul><h3 id="GBDT"><a href="#GBDT" class="headerlink" title="GBDT"></a>GBDT</h3><ul><li><p>GBDT 全称梯度提升决策树，在传统机器学习算法里面是对真实分布拟合的最好的几种算法之一。</p><ul><li>GBDT 每轮的训练是在上一轮的训练的残差基础之上进行训练的。</li><li>GBDT 无论用于分类还是回归一直都是使用的 CART 回归树。</li></ul><p><img src="/2021/09/%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F-Part2/image-20210927191924299.png" alt="image-20210927191924299"></p></li><li><p>优点：可以自动进行多维度特征的发掘与有效组合。</p></li><li><p>局限性：</p><ol><li>对于海量的 id 类特征，GBDT 由于树的深度和棵树限制（防止过拟合），不能有效的存储</li><li>另外海量特征在也会存在性能瓶颈，当 GBDT 的 one hot 特征大于 10 万维时，就必须做分布式的训练才能保证不爆内存。</li></ol><p>所以 GBDT 通常配合少量的反馈 CTR 特征来表达，这样虽然具有一定的范化能力，但是同时会有信息损失，对于头部资源不能有效的表达。</p></li></ul><h3 id="GBDT-LR-1"><a href="#GBDT-LR-1" class="headerlink" title="GBDT+LR"></a>GBDT+LR</h3><ul><li>GBDT和LR的优缺点可以进行互补</li><li><img src="/2021/09/%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F-Part2/image-20210927192931637.png" alt="image-20210927192931637"></li><li>训练：GBDT 建树的过程相当于自动进行的特征组合和离散化，从根结点到叶子节点的这条路径就可以看成是不同特征进行的特征组合。用叶子节点可以唯一地表示这条路径，并作为一个离散特征传入 LR 进行二次训练。（GBDT 和 LR 是分两步进行训练的，所以不存在 LR 梯度回传至 GBDT）</li><li>预测：会先走 GBDT 的每棵树，得到某个叶子节点对应的一个离散特征(即一组特征组合)，然后把该特征以 one-hot 形式传入 LR 进行线性加权预测。</li><li>优点：<ol><li>大大推进了特征工程模型化这一重要趋势。意味着特征工程可以完全交由一个模型独立完成，模型的输入可以是原始的特征向量，不必在特征工程上投入过多的人工筛选和模型设计的精力。</li><li>在一定程度上解决了高阶特征交叉的问题。</li></ol></li><li>缺点：容易过拟合。</li></ul><h2 id="LS-PLM-MLR"><a href="#LS-PLM-MLR" class="headerlink" title="LS-PLM(MLR)"></a>LS-PLM(MLR)</h2><ul><li><p>针对问题：LR 表达能力差</p></li><li><p>解决思路：</p><ul><li>通过聚类，构造带权 LR。</li><li>在逻辑回归的基础上，采用分而治之的思路：先对样本进行聚类，在对样本分片中应用逻辑回归进行 CTR 预估。</li><li>目的：让 CTR 预估模型对不同的用户群体、不同的应用场景更有针对性。</li></ul></li><li><p>预测函数：<img src="/2021/09/%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F-Part2/image-20210927194722571.png" alt="image-20210927194722571"></p></li><li><p>优点：</p><ol><li>端到端的非线性学习能力</li><li>稀疏性强，部署更加轻量级</li></ol></li><li><p>提升模型性能的 trick：</p><ol><li><p>结构化先验增量训练（用户特征进行训练，广告特征进行分类）</p><img src="/2021/09/%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F-Part2/image-20210927195859754.png" alt="image-20210927195859754" style="zoom: 80%;"></li><li><p>线性偏置</p></li><li><p>模型级联</p></li></ol></li></ul>]]></content>
      
      
      <categories>
          
          <category> 推荐系统 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>推荐系统-Part1</title>
      <link href="/2021/09/%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F-Part1/"/>
      <url>/2021/09/%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F-Part1/</url>
      
        <content type="html"><![CDATA[<h1 id="推荐系统-Part1——概述"><a href="#推荐系统-Part1——概述" class="headerlink" title="推荐系统-Part1——概述"></a>推荐系统-Part1——概述</h1><p>[TOC]</p><h2 id="推荐系统概述"><a href="#推荐系统概述" class="headerlink" title="推荐系统概述"></a>推荐系统概述</h2><h3 id="传统推荐模型"><a href="#传统推荐模型" class="headerlink" title="传统推荐模型"></a>传统推荐模型</h3><p>传统推荐模型化关系图：<img src="/2021/09/%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F-Part1/Javaimage-20200923143443499.png" alt="img"></p><ol><li>协同过滤</li><li>矩阵分解算法——协同过滤的进化</li><li>逻辑回归——融合多种特征的推荐模型</li><li>PLOY2、FM、FFM——自动特征交叉</li><li>GBDT+LR——特征工程模型化的开端</li><li>LS-PLM(MLR)——混合逻辑回归</li></ol><h3 id="深度学习推荐模型"><a href="#深度学习推荐模型" class="headerlink" title="深度学习推荐模型"></a>深度学习推荐模型</h3><p>模型发展时间线：<img src="/2021/09/%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F-Part1/Javaimage-20200923143559968.png" alt="img"></p><ol><li>AutoRec、DeepCrossing——改变神经网络复杂程度</li><li>NeuralCF、PNN——改变特征交叉方式</li><li>Wide&amp;Deep、Deep&amp;Cross——记忆与泛化并存</li><li>FNN、DeepFM、NFM——FM 在深度学习中的身影重现</li><li>AFM、DIN——当推荐系统遇上注意力机制</li><li>DIEN——序列模型与推荐系统的火花碰撞</li></ol><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>随着信息技术和互联网的发展，我们已经步入了一个信息过载的时代，无论是信息消费者还是信息生产者都遇到了很大的挑战：</p><ul><li>信息消费者：希望从大量的信息中找到自己感兴趣的信息。</li><li>信息生产者：希望让自己生产的信息脱颖而出，受到广大用户的关注。</li></ul><p>推荐系统，是缓解信息过载的重要技术。通过分析用户的历史行为给用户的兴趣建模，从而主动给用户推荐给能够满足他们兴趣和需求的信息。一方面帮助用户发现对自己有价值的信息，一方面让信息能够展现在对它感兴趣的用户前面。</p><h2 id="论文要求"><a href="#论文要求" class="headerlink" title="论文要求"></a>论文要求</h2><p>随着互联网、物联网、区块链、大数据、人工智能、5G技术的不断发展，特别是移动网络的发展，信息量成爆炸式增长。作为缓解信息过载的重要技术，推荐系统目前已经在健康、智能交通、教育、电子商务等领域有相当成功的应用。然而随着用户需求的持续变化，传统的推荐算法面临一些新的问题，如冷启动、推荐新颖度不够、数据稀疏等。针对这些问题，学者们将新技术应用于推荐系统中，产生了一批新的推荐方法。探讨如何将这些新的理论、方法及技术应用于推荐系统，对更好地提供个性化推荐服务具有积极的指导意义和重要的实践价值，也将促进智能时代的信息技术的持续发展。 </p><p>《武汉大学学报（理学版）》是国内知名期刊，也是北大核心期刊和CSCD-C收录期刊。《武汉大学学报（理学版）》与中国软件大会（ChinaSoft2021）合作征稿，计划于2021年出版“面向人工智能的推荐系统前沿研究”专题。本专题将收录国内外有关推荐系统研究领域创新性和突破性的高水平研究成果，深入探讨推荐系统相关基础理论、关键技术以及支撑平台等方面创新成果，并探讨相关成果在产业界的应用前景。读者群体包括软件工程、人工智能、服务计算等相关领域的专家学者、研究人员和专业工程师等。欢迎从事该领域研究的学者积极投稿。 </p><p>一、征文范围 </p><p>包括但不限于以下主题： </p><p>（1）  推荐系统的理论性研究 </p><p>（2）  面向时间序列的推荐系统研究 </p><p>（3）  基于因果推断的推荐系统研究 </p><p>（4）  面向工业领域的推荐系统及决策研究 </p><p>（4）  基于推荐系统的软件工程 </p><p>二、投稿要求 </p><p>（1）  论文应属于作者的科研成果，未在国内外公开发行的刊物或会议上发表，不存在一稿多投问题。 </p><p>（2）  论文一律用word格式排版，格式体例参考近期出版的《武汉大学学报（理学版）》的要求。<a href="http://whdy.cbpt.cnki.net/WKD/WebPublication/index.aspx?mid=whdy">http://whdy.cbpt.cnki.net/WKD/WebPublication/index.aspx?mid=whdy</a> </p><p>（3）  投稿和评审方式：本专题投稿论文需经过两轮投稿和评审。 </p><p>三、论文截止时间：10月10号 </p><p>四、投稿方式： </p><p>编 辑 部： <a href="mailto:whdz@whu.edu.cn">whdz@whu.edu.cn</a>, 027-68752220          </p><p>通信地址：武汉大学本科生院楼北楼《武汉大学学报（理学版）》编辑部，430072 </p><p>特邀编委：黄 勃   副教授   上海工程技术大学  <a href="mailto:huangbosues@sues.edu.cn">huangbosues@sues.edu.cn</a>   </p><p>​               武 星   副教授   上海大学  <a href="mailto:xingwu@shu.edu.cn">xingwu@shu.edu.cn</a></p>]]></content>
      
      
      <categories>
          
          <category> 推荐系统 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>PyTorch-完结目录</title>
      <link href="/2021/09/PyTorch-%E5%AE%8C%E7%BB%93%E7%9B%AE%E5%BD%95/"/>
      <url>/2021/09/PyTorch-%E5%AE%8C%E7%BB%93%E7%9B%AE%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<h1 id="PyTorch-完结目录"><a href="#PyTorch-完结目录" class="headerlink" title="PyTorch-完结目录"></a>PyTorch-完结目录</h1>]]></content>
      
      
      <categories>
          
          <category> PyTorch </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PyTorch-Part3</title>
      <link href="/2021/09/PyTorch-Part3/"/>
      <url>/2021/09/PyTorch-Part3/</url>
      
        <content type="html"><![CDATA[<h1 id="PyTorch-Part3——TensorFlow-转-PyTorch"><a href="#PyTorch-Part3——TensorFlow-转-PyTorch" class="headerlink" title="PyTorch-Part3——TensorFlow 转 PyTorch"></a>PyTorch-Part3——TensorFlow 转 PyTorch</h1><p>[TOC]</p><h2 id="函数对应"><a href="#函数对应" class="headerlink" title="函数对应"></a>函数对应</h2><p>TensorFlow - tf.reshape 函数 &amp; Pytorch - torch.reshape 函数</p><p>TensorFlow - tf.concat 函数 &amp; Pytorch - torch.cat 函数</p><p>TensorFlow - tf.abs 函数 &amp;</p><ul><li>针对张量的每一位的元素分别计算其绝对值，并输出原格式的新张量。</li></ul><p>TensorFlow - tf.expand_dims 函数 &amp; torch.unsqueeze</p><ul><li><p>TensorFlow - tf.less 函数 &amp;<br>torch.le same as torch.ge — &gt;=<br>torch.lt same as torch.gt — &gt;<br>与torch.min相同的是，其均是用来比较两个张量每一位元素的最小值，不同的是tf.less输出的是是否为最小值的bool值，torch.min是输出两元素中的最小值并重新组合成张量。<br>返回值： 一个 torch.ByteTensor 张量，包含了每个位置的比较结果(是否 input &gt;= other )。 返回类型： Tensor</p></li><li><p>torch.le(input, other, out=None) -&gt; Tensor:</p></li><li><p>逐元素比较input和other，即是否input &lt;= other，第二个参数可以为一个数或与第一个参数相同形状和类型的张量。</p></li><li><p>torch.lt(input, other, out=None) -&gt; Tensor:</p></li><li><p>逐元素比较input和other，即是否input &lt; other</p></li></ul><p>TensorFlow - tf.equal 函数 &amp; torch.equal</p><ul><li>若两个张量有相同的形状和元素值，则返回True， 否则False。</li></ul><p>TensorFlow - tf.greater_equal 函数 &amp; torch.ge torch.gt</p><ul><li>逐元素比较input和other，是否input &gt; other。若两个张量有相同的形状和元素值，则返回True，否则False。</li></ul><p>TensorFlow - tf.norm 函数 &amp; torch.norm</p><p>TensorFlow - tf.argmin 函数 &amp; torch.argmin</p><p>TensorFlow - tf.gather_nd 函数 &amp;</p><ul><li><p>目前torch中自带的同类型函数只有torch.gather，用于处理指定一维度，无gather_nd的用法，但开源工具torchsample中则加入了类似的函数th_gather_nd，模仿tensorflow中的使用，详见：<br>torchsample推荐安装，有点类似于tf中的keras，提供高级api，减少开发时间，实用。</p><p>Pytorch的高级训练，数据增强和实用程序(torchsample/Keras)</p></li></ul><p>TensorFlow - tf.gather 函数 &amp; torch.gather</p><ul><li>根据索引从参数轴上收集切片.</li></ul><p>TensorFlow - tf.shape 函数 &amp; torch.size</p><p>TensorFlow - tf.range 函数 &amp; torch.arange / torch.range</p><p>TensorFlow - tf.stack 函数 &amp; torch.stack</p><p>TensorFlow - tf.reduce_mean 函数 &amp; torch.mean</p><p>TensorFlow - tf.cast 函数 &amp;</p><ul><li>torch中没有相似的类型转换函数，直接使用torch.FloatTensor()或data.float()类似的进行转换就可以了。</li></ul><p>TensorFlow - tf.count_nonzero 函数 &amp; torch.nonzero</p><ul><li>计算并输出各个维度上非０元素的个数。</li></ul><p>TensorFlow - tf.tile 函数 &amp; Tensor.repeat()</p><p>Tensorflow tf.where &amp; torch.le / torch.lt</p><p>Tensorflow tf.nn.in_top_k</p><ul><li><p>tensorflow    pytroch<br>tf.reshape(input, shape)    input.view()<br>tf.expand_dims(input, dim)    input.unsqueeze(dim) / input.view()<br>tf.squeeze(input, dim)    torch.squeeze(dim)/ input.view()<br>tf.gather(input1, input2)    input1[input2]<br>tf.tile(input, shape)    input.repeat(shape)<br>tf.boolean_mask(input, mask)    input[mask] #注意，mask是bool值，不是0,1的数值<br>tf.concat(input1, input2)    torch.cat(input1, input2)<br>tf.matmul()    torch.matmul()<br>tf.minium(input, min)    torch.clamp(input, max=min)<br>tf.equal(input1, input2)    torch.eq(input1, input2)/ input1 == input2<br>tf.logical_and(input1, input2)    input1 &amp; input2<br>tf.logical_not(input)    ~ input<br>tf.reduce_logsumexp(input, [dim])    torch.logsumexp(input, dim=dim)<br>tf.reduce_any(input, dim)    input.any(dim)<br>tf.reduce_mean(input)    torch.mean(input)<br>tf.reduce_sum(input)    input.sum()<br>tf.transpose(input)    input.t()<br>tf.softmax_cross_entroy_with_logits(logits, labels)    torch.nn.CrossEntropyLoss(logits, labels)</p></li><li><p>获取词向量：</p></li><li><p>tensorflow中: input_emb = tf.gather(tf.get_variable(“input_emb”, [num, embedding_size]), input)<br>pytorch中：1.embedding = nn.Embedding(num, embedding_size)，2.input_emb = embedding (input)<br>只是初始化embedding矩阵</p></li><li><p>tensorflow中: input_emb = tf.get_variable(“input_emb”, [num, embedding_size])<br>pytorch中：1.embedding = nn.Embedding(num, embedding_size)， 2.input_emb = embedding .weight</p></li><li><p>基本重构完成代码之后，检查代码以下方面：</p><ol><li>👌 初始化网络权重是否正确</li><li>👌 如果有预训练模型，检查是否加载正确</li><li>👌 检查优化器，整个任务是相同的学习率，还是说是不同层，设置了不同的学习率</li><li>👌 如果数据预处理也需要改动，最好也检查一下预处理是否正确</li></ol></li></ul><p><a href="https://blog.csdn.net/qq_41895190/article/details/89954394">https://blog.csdn.net/qq_41895190/article/details/89954394</a></p><blockquote><p>两个 tf 流程</p><ol><li><a href="https://www.cnblogs.com/tengge/p/6376073.html">https://www.cnblogs.com/tengge/p/6376073.html</a></li><li><a href="https://blog.csdn.net/lcczzu/article/details/91449731">https://blog.csdn.net/lcczzu/article/details/91449731</a></li></ol></blockquote><h2 id="常见的loss问题"><a href="#常见的loss问题" class="headerlink" title="常见的loss问题"></a>常见的loss问题</h2><h3 id="train-loss与test-loss结果分析"><a href="#train-loss与test-loss结果分析" class="headerlink" title="train loss与test loss结果分析"></a>train loss与test loss结果分析</h3><p>train loss 不断下降，test loss不断下降，说明网络仍在学习;</p><p>train loss 不断下降，test loss趋于不变，说明网络过拟合;</p><p>train loss 趋于不变，test loss不断下降，说明数据集100%有问题;</p><p>train loss 趋于不变，test loss趋于不变，说明学习遇到瓶颈，需要减小学习率或批量数目;</p><p>train loss 不断上升，test loss不断上升，说明网络结构设计不当，训练超参数设置不当，数据集经过清洗等问题。</p><p>二，<br>这个比较长，比较完整 Loss和神经网络训练</p><p><a href="https://blog.csdn.net/u011534057/article/details/51452564">https://blog.csdn.net/u011534057/article/details/51452564</a></p><p>有1.梯度检验2.训练前检查，3.训练中监控4.首层可视化5.模型融合和优化等等等</p><p>三，<a href="https://www.zhihu.com/question/38937343">https://www.zhihu.com/question/38937343</a></p><p>四，<a href="https://blog.csdn.net/u010911921/article/details/71079367">https://blog.csdn.net/u010911921/article/details/71079367</a></p><p>原文地址：<a href="http://blog.csdn.net/u010911921/article/details/71079367">http://blog.csdn.net/u010911921/article/details/71079367</a><br>这段在使用caffe的时候遇到了两个问题都是在训练的过程中loss基本保持常数值，特此记录一下。</p><p>1.loss等于87.33不变<br>loss等于87.33这个问题是在对Inception-V3网络不管是fine-tuning还是train的时候遇到的，无论网络迭代多少次，网络的loss一直保持恒定。</p><p>查阅相关资料以后发现是由于loss的最大值由FLT_MIN计算得到，FLT_MIN是其对应的自然对数正好是-87.3356，这也就对应上了loss保持87.3356了。</p><p>这说明softmax在计算的过程中得到了概率值出现了零，由于softmax是用指数函数计算的，指数函数的值都是大于0的，所以应该是计算过程中出现了float溢出的异常，也就是出现了inf，nan等异常值导致softmax输出为0.</p><p>当softmax之前的feature值过大时，由于softmax先求指数，会超出float的数据范围，成为inf。inf与其他任何数值的和都是inf，softmax在做除法时任何正常范围的数值除以inf都会变成0.然后求loss就出现了87.3356的情况。</p><p>解决办法</p><p>由于softmax输入的feature由两部分计算得到：一部分是输入数据，另一部分是各层的权值等组成</p><p>减小初始化权重，以使得softmax的输入feature处于一个比较小的范围</p><p>降低学习率，这样可以减小权重的波动范围</p><p>如果有BN(batch normalization)层，finetune时最好不要冻结BN的参数，否则数据分布不一致时很容易使输出值变得很大(注意将batch_norm_param中的use_global_stats设置为false )。</p><p>观察数据中是否有异常样本或异常label导致数据读取异常</p><p>本文遇到的情况采用降低学习率的方法，learning rate设置为0.01或者原来loss的或者。</p><p>2.loss保持0.69左右<br>采用VGG-16在做一个二分类问题,所以计算loss时等价与下面的公式：</p><p>当p=0.5时，loss正好为0.693147，也就是训练过程中，无论如何调节网络都不收敛。最初的网络配置文件卷积层的参数如下所示：</p><p>从VGG-16训练好的模型进行fine-tuning也不发生改变，当在网络中加入初始化参数和decay_mult以后再次训练网络开始收敛。</p><p>但是具体是什么原因造成的，暂时还没有找到，难道是初始化参数的问题还是？</p><p>参考资料<br><a href="http://blog.csdn.net/jkfdqjjy/article/details/52268565?locationNum=14">http://blog.csdn.net/jkfdqjjy/article/details/52268565?locationNum=14</a></p><p><a href="https://groups.google.com/forum/#!topic/caffe-users/KEgrRlwXz9c">https://groups.google.com/forum/#!topic/caffe-users/KEgrRlwXz9c</a></p><p><a href="https://www.zhihu.com/question/68603783">https://www.zhihu.com/question/68603783</a></p><p>loss一直不下降的原因有很多，可以从头到尾滤一遍： 1）数据的输入是否正常，data和label是否一致。 2）网络架构的选择，一般是越深越好，也分数据集。 并且用不用在大数据集上pre-train的参数也很重要的 3）loss 对不对。</p><p>具体到语音，很多是把audio转成频谱图送给CNN训练。</p><p>NIPS16 有个soundNet(torch的code)，语音分类的performance很高，我觉得可以用来初始化你的model 参数, 可以参考下。</p><p>还有我见的3D-CNN 多用于视频，做audio 用3D 的工作比较少，倒是见过是用1维卷积做audio的</p><blockquote><p><a href="https://blog.csdn.net/u011534057/article/details/51452564/">https://blog.csdn.net/u011534057/article/details/51452564/</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> PyTorch </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>PyTorch-Part2</title>
      <link href="/2021/09/PyTorch-Part2/"/>
      <url>/2021/09/PyTorch-Part2/</url>
      
        <content type="html"><![CDATA[<h1 id="PyTorch-Part2——Pytorch-模型训练"><a href="#PyTorch-Part2——Pytorch-模型训练" class="headerlink" title="PyTorch-Part2——Pytorch 模型训练"></a>PyTorch-Part2——Pytorch 模型训练</h1><p>[TOC]</p><h2 id="数据-Data"><a href="#数据-Data" class="headerlink" title="数据(Data)"></a>数据(Data)</h2><h3 id="数据集划分"><a href="#数据集划分" class="headerlink" title="数据集划分"></a>数据集划分</h3><ul><li><p>严谨的人工智能模型应用应当划分训练集(train set)、测试集(test set)和验证集(valid/dev set)三部分。</p></li><li><p>训练集就用来训练模型，测试集是用来估计模型在实际应用中的泛化能力，而验证集是用于模型选择和调参的。</p><p>在研究过程中，验证集和测试集作用都是一样的，只是对模型的泛化能力进行一个观测。</p><p>而当在工程应用中，由于尽可能地用尽所有数据集并迭代，要防止模型过拟合到测试集上，要有验证集对其进行约束。</p></li><li><p>可以使用 <code>train : test : valid = 8 : 1 : 1</code> 这个比例。</p></li></ul><blockquote><p><a href="https://blog.csdn.net/u011995719/article/details/77451213">https://blog.csdn.net/u011995719/article/details/77451213</a></p></blockquote><h3 id="PyTorch读取数据集"><a href="#PyTorch读取数据集" class="headerlink" title="PyTorch读取数据集"></a>PyTorch读取数据集</h3><ul><li><p>自定义数据集要继承 <code>Dataset</code> 类，并重写 <code>__getitem__()</code> 和 <code>__len__()</code> 方法</p><ul><li><code>__init__()</code>：生成数据的路径列表，尤其对于非结构化数据集，不能直接将所有数据读入内存。</li><li><code>__getitem__()</code>：由 DataLoader 进行调用，返回相应索引的数据，同时进行一系列的数据增强扩充数据集的多样性。</li><li><code>__len__()</code>：提供数据集长度的查询。</li></ul></li><li><p>读取数据流程：</p><ol><li><p>在 MyDataset 中初始化图片路径和标签、数据增强方式</p></li><li><p>在 DataLoader 中初始化 num_workers、shuffle、batch_size、sampler、batch_sampler、collate_fn。即多进程读取数据、采样与拼接方法。</p><p>在 sampler 中会调用到 MyDataset 的 <code>__len__()</code> 方法。</p></li><li><p>在 iteration 进行时，DataLoder 才读取一个 batch 的图片数据。由 batch_sampler 与 collate_fn 确定一个 batch 的 indices 并进行拼接。</p><p>在 collate_fn 中会调用 MyDataset 类中的 <code>__getitem__()</code> 方法。</p></li></ol></li><li><p>在训练时，一般要对图片进行以下操作：</p><ol><li>随机裁剪</li><li>ToTensor：包含①[h, w, c] -&gt; [c, h, w]；② /255：归一化至 0~1 区间。</li><li>数据标准化(减均值，除以标准差)</li></ol></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"><span class="keyword">from</span> torch.utils.data <span class="keyword">import</span> Dataset</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyDataset</span>(<span class="params">Dataset</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, txt_path, transform=<span class="literal">None</span>, target_transform=<span class="literal">None</span></span>):</span></span><br><span class="line">        fh = <span class="built_in">open</span>(txt_path, <span class="string">&#x27;r&#x27;</span>)</span><br><span class="line">        imgs = []</span><br><span class="line">        <span class="keyword">for</span> line <span class="keyword">in</span> fh:</span><br><span class="line">            line = line.rstrip()</span><br><span class="line">            words = line.split()</span><br><span class="line">            imgs.append((words[<span class="number">0</span>], <span class="built_in">int</span>(words[<span class="number">1</span>])))</span><br><span class="line"></span><br><span class="line">        self.imgs = imgs  <span class="comment"># 最主要就是要生成这个list， 然后DataLoader中给index，通过getitem读取图片数据</span></span><br><span class="line">        self.transform = transform</span><br><span class="line">        self.target_transform = target_transform</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getitem__</span>(<span class="params">self, index</span>):</span></span><br><span class="line">        fn, label = self.imgs[index]</span><br><span class="line">        img = Image.<span class="built_in">open</span>(fn).convert(<span class="string">&#x27;RGB&#x27;</span>)  <span class="comment"># 像素值 0~255，在transfrom.totensor会除以255，使像素值变成 0~1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> self.transform <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            img = self.transform(img)  <span class="comment"># 在这里做transform，转为tensor等等</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> img, label</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__len__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(self.imgs)</span><br></pre></td></tr></table></figure><h3 id="transforms-的二十二个方法-干货"><a href="#transforms-的二十二个方法-干货" class="headerlink" title="transforms 的二十二个方法(干货)"></a>transforms 的二十二个方法(干货)</h3><ol><li>裁剪——Crop<ul><li>中心裁剪：<code>transforms.CenterCrop(size)</code><ul><li><strong>size-</strong> (sequence or int)，若为 sequence，则为(h,w)，若为 int，则(size,size)</li></ul></li><li>随机裁剪：<code>transforms.RandomCrop(size, padding=None, pad_if_needed=False, fill=0, padding_mode=&#39;constant&#39;)</code><ul><li><strong>size-</strong> (sequence or int)，若为 sequence，则为(h,w)，若为 int，则(size,size)</li><li><strong>padding-</strong>(sequence or int, optional)，当为 int时， 例如padding=a时，图片上下左右均填充a个像素；当为tupple时，(a, b)，则左右填充a个像素，上下填充b个像素；(a, b, c, d)， 则左填充a个像素，下填充b个像素，右填充c个像素, 上填充d个像素。</li><li><strong>fill-</strong> (int or tuple)，填充的值（仅当padding_mode=’constant’）。int 时，各通道均填充该值，当长度为 3 的 tuple 时，表示 RGB 通道需要填充的值。</li><li><strong>padding_mode-</strong> 填充模式：1. constant，常量。2. edge，按照图片边缘的像素值来填充。3. reflect，镜像填充，最后一个像素不镜像。 4. symmetric，最后一个像素镜像。</li></ul></li><li>随机长宽比裁剪：<code>transforms.RandomResizedCrop(size, scale=(0.08, 1.0), ratio=(0.75, 1.33), interpolation=2) </code><ul><li><strong>size-</strong> 所需裁剪图片尺寸。</li><li><strong>scale-</strong> 随机裁剪面积比例，默认scale=(0.08, 1.0)，表示随机 crop 出来的图片会在的 0.08倍至 1 倍之间。</li><li><strong>ratio-</strong> 随机长宽比设置，默认(3/4, 4/3)</li><li><strong>interpolation</strong>- 插值的方法，默认为双线性插值(PIL.Image.BILINEAR)</li></ul></li><li>上下左右中心裁剪：<code>transforms.FiveCrop(size)</code><ul><li><strong>size-</strong> (sequence or int)，若为 sequence,则为(h,w)，若为 int，则(size,size)</li></ul></li><li>上下左右中心裁剪后翻转：<code>transforms.TenCrop(size, vertical_flip=False)</code><ul><li><strong>size-</strong> (sequence or int)，若为 sequence,则为(h,w)，若为 int，则(size,size)</li><li><strong>vertical_flip</strong>- (bool)，是否垂直翻转，默认为 flase，即默认为水平翻转</li></ul></li></ul></li><li>翻转和旋转——Flip and Rotation<ul><li>依概率 p 水平翻转：<code>transforms.RandomHorizontalFlip(p=0.5)</code><ul><li><strong>p-</strong> 概率，默认值为 0.5</li></ul></li><li>依概率 p 垂直翻转：<code>transforms.RandomVerticalFlip(p=0.5)</code><ul><li><strong>p-</strong> 概率，默认值为 0.5</li></ul></li><li>随机旋转：<code>transforms.RandomRotation(degrees, resample=False, expand=False, center=None)</code><ul><li><strong>degress</strong>- (sequence or float or int) ，若为 int，则在（-int，+int）之间随机旋转，若为 sequence，则在 s[0]~s[1] 度之间随机旋转</li><li><strong>resample</strong>- 重采样方法</li><li><strong>expand</strong>- 是否扩大图片，以保存图片原有信息</li><li><strong>center</strong>- 旋转中心，(0, 0)为左上角。默认为图片中心</li></ul></li></ul></li><li>图像变换<ul><li>resize：<code>transforms.Resize(size, interpolation=2)</code><ul><li><strong>size</strong>- If size is an int, if height &gt; width, then image will be rescaled to (size * height / width, size)，所以建议 size 设定为 h*w</li><li><strong>interpolation</strong>- 插值方法选择，默认为 PIL.Image.BILINEAR</li></ul></li><li>标准化：<code>transforms.Normalize(mean, std)</code><ul><li>对数据按通道进行标准化，即先减均值，再除以标准差，注意是 [h, w, c]</li></ul></li><li>转为 tensor，并归一化至[0-1]：<code>transforms.ToTensor</code><ul><li>归一化至[0-1]是直接除以 255，若自己的 ndarray 数据尺度有变化，则需要自行修改。</li></ul></li><li>填充图像边缘：<code>transforms.Pad(padding, fill=0, padding_mode=&#39;constant&#39;)</code><ul><li>同 随机裁剪 RandomCrop 的参数</li></ul></li><li>修改亮度、对比度和饱和度：<code>transforms.ColorJitter(brightness=0, contrast=0, saturation=0, hue=0)</code><ul><li><strong>brightness</strong>- 亮度调整因子。当为a时，从 max((0, 1-a), 1+a) 中随机选择；当为(a, b)时，从[a, b]中随机选择。</li><li><strong>constant</strong>- 对比度参数，同brightness</li><li><strong>saturation</strong>- 饱和度参数，同brightness</li><li><strong>hue</strong>- 色相参数，当为a时，从[-a, a]中选择参数，注：0 &lt;= a &lt;= 0.5；当为(a, b)时，从[a, b]中选择参数，注：-0.5 &lt;= a &lt;= b &lt;= 0.5</li></ul></li><li>转灰度图：<code>transforms.Grayscale(num_output_channels=1)</code><ul><li><strong>num_output_channels</strong>- 输出通道数，只能设置1或者3</li></ul></li><li>线性变换：<code>transforms.LinearTransformation(transformation_matrix)</code><ul><li>对矩阵做线性变化，可用于白化处理。 whitening: zero-center the data, compute the data covariance matrix</li></ul></li><li>仿射变换：<code>transforms.RandomAffine(degrees, translate=None, scale=None, shear=None, resample=False, fillcolor=0)</code><ul><li><strong>degrees</strong>- 旋转角度设置</li><li><strong>translate</strong>- 平移区间设置如(a, b), a设置宽(width), b设置高(height) 。图像在宽维度的平移区间为 -img_width * a &lt; dx &lt; img_width * a</li><li><strong>scale</strong>- 缩放比例（以面积为单位）</li><li><strong>file_color</strong>- 填充颜色设置</li><li><strong>share</strong>- 错切角度设置，有水平错切和垂直错切，若为a，则仅在x轴错切，错切角度为(-a, a)之间；若为(a, b), 则a设置x轴角度，b设置y的角度；若为(a, b, c, d), 则a，b设置x轴度，c， d设置y角度</li><li><strong>resample</strong>- 重采样方式有NEAREST、BILINEAR、BICUBIC</li></ul></li><li>依概率 p 转为灰度图：<code>transforms.RandomGrayscale(p=0.1)</code><ul><li><strong>p</strong>- 概率值，图像被转换为灰度图的概率</li></ul></li><li>将数据转换为 PILImage：<code>transforms.ToPILImage(mode=None)</code><ul><li><strong>mode</strong>- 为 None 时，为 1 通道， mode=3 通道默认转换为 RGB，4 通道默认转换为 RGBA</li></ul></li><li>随机遮挡：<code>transforms.RandomErasing(p=0.5, scale=(0.02, 0.33), ratio=(0.3, 3.3), value=0, inplace=False)</code><ul><li><strong>p</strong>- 概率值</li><li><strong>scale</strong>- 遮挡区域与输入图像的比例范围</li><li><strong>ratio</strong>- 遮挡区域长宽比</li><li><strong>value</strong>- 设置遮挡区域的像素值，(R, G, B) or (Gray), value为字符串(不一定非要random)时，随机填充像素值。</li><li><strong>inplace</strong>- 改变自身</li></ul></li><li>transforms.Lambda：Apply a user-defined lambda as a transform</li></ul></li><li>对 transforms 操作，使数据增强更灵活<ul><li>transforms.RandomChoice(transforms)，从给定的一系列 transforms 中选一个进行操作</li><li>transforms.RandomApply(transforms, p=0.5)，给一个 transform 加上概率，依概率进行操作</li><li>transforms.RandomOrder，将 transforms 中的操作随机打乱</li></ul></li><li>自定义 transforms <ul><li>仅接收一个参数，返回一个参数</li><li>注意上下游的输出与输入</li></ul></li></ol><h3 id="计算-Normalize-所用均值和方差"><a href="#计算-Normalize-所用均值和方差" class="headerlink" title="计算 Normalize 所用均值和方差"></a>计算 Normalize 所用均值和方差</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    随机挑选CNum张图片，进行按通道计算均值mean和标准差std</span></span><br><span class="line"><span class="string">    先将像素从0～255归一化至 0-1 再计算</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">train_txt_path = os.path.join(<span class="string">&quot;..&quot;</span>, <span class="string">&quot;..&quot;</span>, <span class="string">&quot;Data/train.txt&quot;</span>)</span><br><span class="line">CNum = <span class="number">2000</span>  <span class="comment"># 挑选多少图片进行计算</span></span><br><span class="line"></span><br><span class="line">img_h, img_w = <span class="number">32</span>, <span class="number">32</span></span><br><span class="line">imgs = np.zeros([img_w, img_h, <span class="number">3</span>, <span class="number">1</span>])</span><br><span class="line">means, stdevs = [], []</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(train_txt_path, <span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    lines = f.readlines()</span><br><span class="line">    random.shuffle(lines)  <span class="comment"># shuffle , 随机挑选图片</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(CNum):</span><br><span class="line">        img_path = lines[i].rstrip().split()[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">        img = cv2.imread(img_path)</span><br><span class="line">        img = cv2.resize(img, (img_h, img_w))</span><br><span class="line"></span><br><span class="line">        img = img[:, :, :, np.newaxis]</span><br><span class="line">        imgs = np.concatenate((imgs, img), axis=<span class="number">3</span>)</span><br><span class="line">        print(i)</span><br><span class="line"></span><br><span class="line">imgs = imgs.astype(np.float32) / <span class="number">255.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>):</span><br><span class="line">    pixels = imgs[:, :, i, :].ravel()  <span class="comment"># 拉成一行</span></span><br><span class="line">    means.append(np.mean(pixels))</span><br><span class="line">    stdevs.append(np.std(pixels))</span><br><span class="line"></span><br><span class="line">means.reverse()  <span class="comment"># BGR --&gt; RGB</span></span><br><span class="line">stdevs.reverse()</span><br><span class="line"></span><br><span class="line">print(<span class="string">&quot;normMean = &#123;&#125;&quot;</span>.<span class="built_in">format</span>(means))</span><br><span class="line">print(<span class="string">&quot;normStd = &#123;&#125;&quot;</span>.<span class="built_in">format</span>(stdevs))</span><br><span class="line">print(<span class="string">&#x27;transforms.Normalize(normMean = &#123;&#125;, normStd = &#123;&#125;)&#x27;</span>.<span class="built_in">format</span>(means, stdevs))</span><br></pre></td></tr></table></figure><h2 id="模型-Model"><a href="#模型-Model" class="headerlink" title="模型(Model)"></a>模型(Model)</h2><h3 id="模型定义"><a href="#模型定义" class="headerlink" title="模型定义"></a>模型定义</h3><ul><li>三个要点<ul><li>必须继承 <code>nn.Module</code> 这个类，要让 PyTorch 知道这个类是一个 Module。</li><li>在 <code>__init__(self)</code> 中设置好需要的隐藏层(如 conv、pooling、Linear、BatchNorm等)。</li><li>在 <code>forward(self, x)</code> 中用定义好的网络结构进行组装，定义前馈过程。</li></ul></li><li>可以使用类似 <code>_make_layer()</code> 类似的方法来辅助自定义网络层。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> .BasicModule <span class="keyword">import</span> BasicModule</span><br><span class="line"><span class="keyword">from</span> torch <span class="keyword">import</span> nn</span><br><span class="line"><span class="keyword">from</span> torch.nn <span class="keyword">import</span> functional <span class="keyword">as</span> F</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ResidualBlock</span>(<span class="params">nn.Module</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    实现子module: Residual Block</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, inchannel, outchannel, stride=<span class="number">1</span>, shortcut=<span class="literal">None</span></span>):</span></span><br><span class="line">        <span class="built_in">super</span>(ResidualBlock, self).__init__()</span><br><span class="line">        self.left = nn.Sequential(</span><br><span class="line">            nn.Conv2d(inchannel, outchannel, <span class="number">3</span>, stride, <span class="number">1</span>, bias=<span class="literal">False</span>),</span><br><span class="line">            nn.BatchNorm2d(outchannel),</span><br><span class="line">            nn.ReLU(inplace=<span class="literal">True</span>),</span><br><span class="line">            nn.Conv2d(outchannel, outchannel, <span class="number">3</span>, <span class="number">1</span>, <span class="number">1</span>, bias=<span class="literal">False</span>),</span><br><span class="line">            nn.BatchNorm2d(outchannel))</span><br><span class="line">        self.right = shortcut</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span>(<span class="params">self, x</span>):</span></span><br><span class="line">        out = self.left(x)</span><br><span class="line">        residual = x <span class="keyword">if</span> self.right <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">else</span> self.right(x)</span><br><span class="line">        out += residual</span><br><span class="line">        <span class="keyword">return</span> F.relu(out)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ResNet34</span>(<span class="params">BasicModule</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    实现主module：ResNet34</span></span><br><span class="line"><span class="string">    ResNet34包含多个layer，每个layer又包含多个Residual block</span></span><br><span class="line"><span class="string">    用子module来实现Residual block，用_make_layer函数来实现layer</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, num_classes=<span class="number">2</span></span>):</span></span><br><span class="line">        <span class="built_in">super</span>(ResNet34, self).__init__()</span><br><span class="line">        self.model_name = <span class="string">&#x27;resnet34&#x27;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 前几层: 图像转换</span></span><br><span class="line">        self.pre = nn.Sequential(</span><br><span class="line">            nn.Conv2d(<span class="number">3</span>, <span class="number">64</span>, <span class="number">7</span>, <span class="number">2</span>, <span class="number">3</span>, bias=<span class="literal">False</span>),</span><br><span class="line">            nn.BatchNorm2d(<span class="number">64</span>),</span><br><span class="line">            nn.ReLU(inplace=<span class="literal">True</span>),</span><br><span class="line">            nn.MaxPool2d(<span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>))</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 重复的layer，分别有3，4，6，3个residual block</span></span><br><span class="line">        self.layer1 = self._make_layer(<span class="number">64</span>, <span class="number">128</span>, <span class="number">3</span>)</span><br><span class="line">        self.layer2 = self._make_layer(<span class="number">128</span>, <span class="number">256</span>, <span class="number">4</span>, stride=<span class="number">2</span>)</span><br><span class="line">        self.layer3 = self._make_layer(<span class="number">256</span>, <span class="number">512</span>, <span class="number">6</span>, stride=<span class="number">2</span>)</span><br><span class="line">        self.layer4 = self._make_layer(<span class="number">512</span>, <span class="number">512</span>, <span class="number">3</span>, stride=<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 分类用的全连接</span></span><br><span class="line">        self.fc = nn.Linear(<span class="number">512</span>, num_classes)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_make_layer</span>(<span class="params">self, inchannel, outchannel, block_num, stride=<span class="number">1</span></span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        构建layer,包含多个residual block</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        shortcut = nn.Sequential(</span><br><span class="line">            nn.Conv2d(inchannel, outchannel, <span class="number">1</span>, stride, bias=<span class="literal">False</span>),</span><br><span class="line">            nn.BatchNorm2d(outchannel))</span><br><span class="line"></span><br><span class="line">        layers = []</span><br><span class="line">        layers.append(ResidualBlock(inchannel, outchannel, stride, shortcut))</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, block_num):</span><br><span class="line">            layers.append(ResidualBlock(outchannel, outchannel))</span><br><span class="line">        <span class="keyword">return</span> nn.Sequential(*layers)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span>(<span class="params">self, x</span>):</span></span><br><span class="line">        x = self.pre(x)</span><br><span class="line"></span><br><span class="line">        x = self.layer1(x)</span><br><span class="line">        x = self.layer2(x)</span><br><span class="line">        x = self.layer3(x)</span><br><span class="line">        x = self.layer4(x)</span><br><span class="line"></span><br><span class="line">        x = F.avg_pool2d(x, <span class="number">7</span>)</span><br><span class="line">        x = x.view(x.size(<span class="number">0</span>), -<span class="number">1</span>)  <span class="comment"># 按batch_size展平</span></span><br><span class="line">        <span class="keyword">return</span> self.fc(x)</span><br></pre></td></tr></table></figure><h3 id="Sequential"><a href="#Sequential" class="headerlink" title="Sequential"></a>Sequential</h3><ul><li>可以用 list 或者 OrderedDict 进行网络的堆叠。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Example of using Sequential</span></span><br><span class="line">model = nn.Sequential(</span><br><span class="line">    nn.Conv2d(<span class="number">1</span>, <span class="number">20</span>, <span class="number">5</span>),</span><br><span class="line">    nn.ReLU(),</span><br><span class="line">    nn.Conv2d(<span class="number">20</span>, <span class="number">64</span>, <span class="number">5</span>),</span><br><span class="line">    nn.ReLU()</span><br><span class="line">)</span><br><span class="line"><span class="comment"># Example of using Sequential with OrderedDict</span></span><br><span class="line">model = nn.Sequential(OrderedDict([</span><br><span class="line">    (<span class="string">&#x27;conv1&#x27;</span>, nn.Conv2d(<span class="number">1</span>, <span class="number">20</span>, <span class="number">5</span>)),</span><br><span class="line">    (<span class="string">&#x27;relu1&#x27;</span>, nn.ReLU()),</span><br><span class="line">    (<span class="string">&#x27;conv2&#x27;</span>, nn.Conv2d(<span class="number">20</span>, <span class="number">64</span>, <span class="number">5</span>)),</span><br><span class="line">    (<span class="string">&#x27;relu2&#x27;</span>, nn.ReLU())</span><br><span class="line">]))</span><br></pre></td></tr></table></figure><h3 id="权值初始化"><a href="#权值初始化" class="headerlink" title="权值初始化"></a>权值初始化</h3><h4 id="权值初始化流程"><a href="#权值初始化流程" class="headerlink" title="权值初始化流程"></a>权值初始化流程</h4><ul><li>初始化流程<ul><li>第一步，先设定什么层用什么初始化方法，初始化方法在 torch.nn.init 中给出；</li><li>第二步，实例化一个模型之后，执行该函数，即可完成初始化。</li></ul></li><li><code>named_children()</code>和<code>named_modules()</code>的区别：<a href="https://blog.csdn.net/watermelon1123/article/details/98036360">https://blog.csdn.net/watermelon1123/article/details/98036360</a></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 定义权值初始化</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">initialize_weights</span>(<span class="params">self</span>):</span></span><br><span class="line">    <span class="keyword">for</span> m <span class="keyword">in</span> self.modules():</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">isinstance</span>(m, nn.Conv2d):</span><br><span class="line">            torch.nn.init.xavier_normal_(m.weight.data)</span><br><span class="line">            <span class="keyword">if</span> m.bias <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">                m.bias.data.zero_()</span><br><span class="line">        <span class="keyword">elif</span> <span class="built_in">isinstance</span>(m, nn.BatchNorm2d):</span><br><span class="line">            m.weight.data.fill_(<span class="number">1</span>)</span><br><span class="line">            m.bias.data.zero_()</span><br><span class="line">        <span class="keyword">elif</span> <span class="built_in">isinstance</span>(m, nn.Linear):</span><br><span class="line">            torch.nn.init.normal_(m.weight.data, <span class="number">0</span>, <span class="number">0.01</span>)</span><br><span class="line">            m.bias.data.zero_()</span><br></pre></td></tr></table></figure><h4 id="权值初始化的十种方法-干货"><a href="#权值初始化的十种方法-干货" class="headerlink" title="权值初始化的十种方法(干货)"></a>权值初始化的十种方法(干货)</h4><ol><li>Xavier 均匀分布：<code>torch.nn.init.xavier_uniform_(tensor, gain=1)</code><ul><li>xavier 初始化方法中服从均匀分布 U(−a,a) ，分布的参数 a = gain * sqrt(6/fan_in+fan_out)。也称为 Glorot initialization。</li><li><strong>gain</strong>- 增益的大小是依据激活函数类型来设定。</li><li>eg：nn.init.xavier_uniform_(w, gain=nn.init.calculate_gain(‘relu’))</li></ul></li><li>Xavier 正态分布：<code>torch.nn.init.xavier_normal_(tensor, gain=1)</code><ul><li>xavier 初始化方法中服从正态分布，mean=0,std = gain * sqrt(2/fan_in + fan_out)</li><li>kaiming 初始化方法，论文在《 Delving deep into rectifiers: Surpassing human-level performance on ImageNet classification》，公式推导同样从“方差一致性”出法，kaiming是针对 xavier 初始化方法在 relu 这一类激活函数表现不佳而提出的改进，详细可以参看论文。</li></ul></li><li>kaiming 均匀分布：<code>torch.nn.init.kaiming_uniform_(tensor, a=0, mode=&#39;fan_in&#39;, nonlinearity=&#39;leaky_relu&#39;)</code><ul><li>此为均匀分布，U～（-bound, bound）, bound = sqrt(6/(1+a^2)*fan_in)。其中，a 为激活函数的负半轴的斜率，relu 是 0。</li><li><strong>mode</strong>- 可选为 fan_in 或 fan_out, fan_in 使正向传播时，方差一致; fan_out 使反向传播时，方差一致</li><li><strong>nonlinearity</strong>- 可选 relu 和 leaky_relu ，默认值为 。 leaky_relu</li><li>eg：nn.init.kaiming_uniform_(w, mode=’fan_in’, nonlinearity=’relu’)</li></ul></li><li>kaiming 正态分布：<code>torch.nn.init.kaiming_normal_(tensor, a=0, mode=&#39;fan_in&#39;, nonlinearity=&#39;leaky_relu&#39;)</code><ul><li>此为 0 均值的正态分布，N～ (0,std)，其中 std = sqrt(2/(1+a^2)*fan_in) </li><li><strong>a</strong>- 激活函数的负半轴的斜率，relu 是 0</li><li><strong>mode</strong>- 可选为 fan_in 或 fan_out。fan_in 使正向传播时，方差一致；fan_out 使反向传播时，方差一致</li><li><strong>nonlinearity</strong>- 可选 relu 和 leaky_relu ，默认值为 leaky_relu。</li><li>eg：nn.init.kaiming_normal_(w, mode=’fan_out’, nonlinearity=’relu’)</li></ul></li><li>均匀分布初始化：<code>torch.nn.init.uniform_(tensor, a=0, b=1)</code><ul><li>使值服从均匀分布 U(a,b)</li></ul></li><li>正态分布初始化：<code>torch.nn.init.normal_(tensor, mean=0, std=1)</code><ul><li>使值服从正态分布 N(mean, std)，默认值为 0，1</li></ul></li><li>常数初始化：<code>torch.nn.init.constant_(tensor, val)</code><ul><li>使值为常数 val nn.init.constant_(w, 0.3)</li></ul></li><li>单位矩阵初始化：<code>torch.nn.init.eye_(tensor)</code><ul><li>将二维 tensor 初始化为单位矩阵（the identity matrix）</li></ul></li><li>正交初始化：<code>torch.nn.init.orthogonal_(tensor, gain=1)</code><ul><li>使得 tensor 是正交的，论文:Exact solutions to the nonlinear dynamics of learning in deep linear neural networks” - Saxe, A. et al. (2013)</li></ul></li><li>稀疏初始化：<code>torch.nn.init.sparse_(tensor, sparsity, std=0.01)</code><ul><li>从正态分布 N～（0. std）中进行稀疏化，使每一个 column 有一部分为 0</li><li><strong>sparsity</strong>- 每一个 column 稀疏的比例，即为 0 的比例</li><li>eg：nn.init.sparse_(w, sparsity=0.1)</li></ul></li><li>计算增益：<code>torch.nn.init.calculate_gain(nonlinearity, param=None)</code></li></ol><blockquote><p>其实，在创建网络实例的过程中, 一旦调用 nn.Conv2d 的时候就会有对权值进行初始化。</p><p>在 PyTorch1.0 版本后，Conv2d 改用了 <code>kaiming_uniform_()</code> 进行初始化，可以在 <code>torch/nn/modules/conv.py</code> 中的 _ConvNd 类中的函数 <code>reset_parameters()</code> 中看到初始化方式。</p></blockquote><h3 id="模型加载与保存-Finetune"><a href="#模型加载与保存-Finetune" class="headerlink" title="模型加载与保存 Finetune"></a>模型加载与保存 Finetune</h3><ul><li>模型 Finetune 权值初始化：<ol><li>保存模型，拥有一个预训练模型</li><li>加载模型，把预训练模型中的权值取出来</li><li>初始化，将网络的权重用预训练模型初始化</li></ol></li><li>官方文档中介绍了两种保存模型的方法，一种是保存整个模型，另外一种是仅保存模型参数（官方推荐用这种方法）</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1. 创建 net</span></span><br><span class="line">net = Net()</span><br><span class="line"><span class="comment"># 2. 获取已创建 net 的 state_dict</span></span><br><span class="line">net_state_dict = net.state_dict()</span><br><span class="line"><span class="comment"># 3. 加载模型，这里只是加载模型的参数</span></span><br><span class="line">pretrained_dict = torch.load(<span class="string">&#x27;net_params.pkl&#x27;</span>)</span><br><span class="line"><span class="comment"># 4. 将 pretrained_dict 里不属于 net_state_dict 的键剔除掉</span></span><br><span class="line">pretrained_dict_1 = &#123;k: v <span class="keyword">for</span> k, v <span class="keyword">in</span> pretrained_dict.items() <span class="keyword">if</span> k <span class="keyword">in</span> net_state_dict&#125;</span><br><span class="line"><span class="comment"># 5. 用预训练模型的参数字典 对 新模型的参数字典 net_state_dict 进行更新</span></span><br><span class="line">net_state_dict.update(pretrained_dict_1)</span><br><span class="line"><span class="comment"># 6. 将更新了参数的字典 “放”回到网络中</span></span><br><span class="line">net.load_state_dict(net_state_dict)</span><br><span class="line"><span class="comment"># 7. 将网络的参数保存下来</span></span><br><span class="line">torch.save(net.state_dict(), <span class="string">&#x27;net_params.pkl&#x27;</span>)</span><br></pre></td></tr></table></figure><h3 id="不同层设置不同的学习率"><a href="#不同层设置不同的学习率" class="headerlink" title="不同层设置不同的学习率"></a>不同层设置不同的学习率</h3><ul><li>在利用 pre-trained model 的参数做初始化之后，我们可能想让 fc 层更新相对快一些，而希望前面的权值更新小一些，这就可以通过为不同的层设置不同的学习率来达到此目的。</li><li>为不同层设置不同的学习率，主要通过优化器对多个参数组进行设置不同的参数。所以，只需要将原始的参数组，划分成两个，甚至更多的参数组，然后分别进行设置学习率。</li><li>这里将原始参数“切分”成 fc3 层参数和其余参数，为 fc3 层设置更大的学习率。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">lr_init: <span class="built_in">float</span> = <span class="number">0.001</span></span><br><span class="line">    </span><br><span class="line"><span class="comment"># 将fc3层的参数从原始网络参数中剔除</span></span><br><span class="line">ignored_params = <span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">id</span>, net.fc3.parameters()))  <span class="comment"># 返回的是 parameters 的内存地址</span></span><br><span class="line">base_params = <span class="built_in">filter</span>(<span class="keyword">lambda</span> p: <span class="built_in">id</span>(p) <span class="keyword">not</span> <span class="keyword">in</span> ignored_params, net.parameters())</span><br><span class="line"></span><br><span class="line"><span class="comment"># 为fc3层设置需要的学习率</span></span><br><span class="line">optimizer = optim.SGD([</span><br><span class="line">    &#123;<span class="string">&#x27;params&#x27;</span>: base_params&#125;,</span><br><span class="line">    &#123;<span class="string">&#x27;params&#x27;</span>: net.fc3.parameters(), <span class="string">&#x27;lr&#x27;</span>: lr_init*<span class="number">10</span>&#125;</span><br><span class="line">],  lr_init, momentum=<span class="number">0.9</span>, weight_decay=<span class="number">1e-4</span>)</span><br><span class="line"></span><br><span class="line">criterion = nn.CrossEntropyLoss()                                                   <span class="comment"># 选择损失函数</span></span><br><span class="line">scheduler = torch.optim.lr_scheduler.StepLR(optimizer, step_size=<span class="number">50</span>, gamma=<span class="number">0.1</span>)     <span class="comment"># 设置学习率下降策略</span></span><br></pre></td></tr></table></figure><ul><li>挑选出特定的层的机制是利用内存地址作为过滤条件，将需要单独设定的部分参数从总的参数中剔除。<ul><li><code>net.fc3.parameters()</code> 是一个&lt;generator object parameters at 0x11b63bf00&gt;</li><li><code>ignored_params</code> 是包含 net.fc3 中 weight、bias 两者对应参数的内存地址列表</li><li><code>base_params</code> 是一个 list，每个元素是一个 Parameter 类，其中剔除了 net.fc3 的 weight、bias</li></ul></li></ul><blockquote><p><strong>冻结权重</strong>与<strong>优化器仅传入部分参数</strong>两者是等价的。</p><p>个人认为：1. 用requires_grad=False会提高内存优化，因为不需要保存梯度。2. 仅传入优化器可以提高运行速度，因为不用对部分参数进行计算</p><p><a href="https://blog.csdn.net/answer3664/article/details/108493753">https://blog.csdn.net/answer3664/article/details/108493753</a></p></blockquote><h2 id="损失函数-Loss-Function"><a href="#损失函数-Loss-Function" class="headerlink" title="损失函数(Loss Function)"></a>损失函数(Loss Function)</h2><h3 id="PyTorch-的十七个损失函数-干货"><a href="#PyTorch-的十七个损失函数-干货" class="headerlink" title="PyTorch 的十七个损失函数(干货)"></a>PyTorch 的十七个损失函数(干货)</h3><ul><li>训练网络的过程，是不断优化网络权值使得损失函数值最小化的过程。</li></ul><ol><li><p>L1loss：<code>torch.nn.L1Loss(size_average=None, reduce=None)</code></p><ul><li><p>计算 output 和 target 之差的绝对值</p><img src="/2021/09/PyTorch-Part2/image-20210913142253796.png" alt="image-20210913142253796" style="zoom:67%;"></li><li><p><strong>reduce</strong>(bool)- 返回值是否为标量，默认为 True</p><p><strong>size_average</strong>(bool)- 当 reduce=True 时有效。为 True 时，返回的 loss 为平均值；为 False时，返回的各样本的 loss 之和</p></li></ul></li><li><p>MSELoss：<code>torch.nn.MSELoss(size_average=None, reduce=None, reduction=&#39;elementwise_mean&#39;)</code></p><ul><li><p>计算 output 和 target 之差的平方</p><img src="/2021/09/PyTorch-Part2/image-20210913142318096.png" alt="image-20210913142318096" style="zoom:67%;"></li><li><p><strong>reduce</strong>(bool)- 返回值是否为标量，默认为 True</p><p><strong>size_average</strong>(bool)- 当 reduce=True 时有效。为 True 时，返回的 loss 为平均值；为 False时，返回的各样本的 loss 之和</p></li></ul></li><li><p>CrossEntropyLoss：<code>torch.nn.CrossEntropyLoss(weight=None, size_average=None, ignore_index=-100, reduce=None, reduction=&#39;elementwise_mean&#39;)</code></p><ul><li><p>将输入经过 softmax 激活函数之后，再计算其与 target 的交叉熵损失。</p><p>该方法将 nn.LogSoftmax() 和 nn.NLLLoss() 进行了结合。严格意义上的交叉熵损失函数应该是 nn.NLLLoss()。</p><img src="/2021/09/PyTorch-Part2/image-20210913142855509.png" alt="image-20210913142855509" style="zoom:67%;"></li><li><p><strong>weight</strong>(Tensor)- 为每个类别的 loss 设置权值，常用于类别不均衡问题。weight 必须是 float类型的 tensor，其长度要于类别 C 一致，即每一个类别都要设置有 weight。</p><p><strong>size_average</strong>(bool)- 当 reduce=True 时有效。为 True 时，返回的 loss 为平均值；为 False时，返回的各样本的 loss 之和。</p><p><strong>reduce</strong>(bool)- 返回值是否为标量，默认为 True</p><p><strong>ignore_index</strong>(int)- 忽略某一类别，不计算其 loss，其 loss 会为 0，并且，在采用size_average 时，不会计算那一类的 loss，除的时候的分母也不会统计那一类的样本。</p></li></ul></li><li><p>NLLLoss：<code>torch.nn.NLLLoss(weight=None, size_average=None, ignore_index=-100, reduce=None, reduction=&#39;elementwise_mean&#39;)</code></p><ul><li><p>不带 log_softmax 层的 CrossEntropyLoss 。</p><img src="/2021/09/PyTorch-Part2/image-20210913144640040.png" alt="image-20210913144640040" style="zoom:67%;"></li><li><p><strong>weight</strong>(Tensor)- 为每个类别的 loss 设置权值，常用于类别不均衡问题。weight 必须是 float类型的 tensor，其长度要于类别 C 一致，即每一个类别都要设置有 weight。</p><p><strong>size_average</strong>(bool)- 当 reduce=True 时有效。为 True 时，返回的 loss 为除以权重之和的平均值；为 False 时，返回的各样本的 loss 之和。</p><p><strong>reduce</strong>(bool)- 返回值是否为标量，默认为 True。</p><p><strong>ignore_index</strong>(int)- 忽略某一类别，不计算其 loss，其 loss 会为 0，并且，在采用 size_average 时，不会计算那一类的 loss，除的时候的分母也不会统计那一类的样本。</p></li></ul></li><li><p>PoissonNLLLoss：<code>torch.nn.PoissonNLLLoss(log_input=True, full=False, size_average=None, eps=1e-08, reduce=None, reduction=&#39;elementwise_mean&#39;)</code></p><ul><li><p>用于 target 服从泊松分布的分类任务。</p><img src="/2021/09/PyTorch-Part2/image-20210913144654680.png" alt="image-20210913144654680" style="zoom:67%;"></li><li><p>log_input(bool)- 为 True 时，计算公式为：loss(input,target)=exp(input) - target * input; 为 False 时，loss(input,target)=input - target * log(input+eps)</p><p><strong>full</strong>(bool)- 是否计算全部的 loss。例如，当采用斯特林公式近似阶乘项时，此为 target*log(target) - target+0.5∗log(2πtarget)</p><p><strong>eps</strong>(float)- 当 log_input = False 时，用来防止计算 log(0)，而增加的一个修正项。即</p><p><strong>loss</strong>(input,target)=input - target * log(input+eps)</p><p><strong>size_average</strong>(bool)- 当 reduce=True 时有效。为 True 时，返回的 loss 为平均值；为 False时，返回的各样本的 loss 之和。</p><p><strong>reduce</strong>(bool)- 返回值是否为标量，默认为 True</p></li></ul></li><li><p>KLDivLoss：<code>torch.nn.KLDivLoss(size_average=None, reduce=None, reduction=&#39;elementwise_mean&#39;)</code></p><ul><li><p>计算 input 和 target 之间的 KL 散度( Kullback–Leibler divergence) 。又称为相对熵(Relative Entropy)，用于描述两个概率分布之间的差异。</p><p>要想获得真正的 KL 散度，需要如下操作：1. reduce = True ；size_average=False；2. 计算得到的 loss 要对 batch 进行求平均</p><img src="/2021/09/PyTorch-Part2/image-20210913144829614.png" alt="image-20210913144829614" style="zoom:67%;"></li><li><p><strong>size_average</strong>(bool)- 当 reduce=True 时有效。为 True 时，返回的 loss 为平均值，平均值为</p><p><strong>element</strong>-wise 的，而不是针对样本的平均；为 False 时，返回是各样本各维度的 loss 之和。</p><p><strong>reduce</strong>(bool)- 返回值是否为标量，默认为 True。</p></li></ul></li><li><p>BCELoss：<code>torch.nn.BCELoss(weight=None, size_average=None, reduce=None, reduction=&#39;elementwise_mean&#39;)</code></p><ul><li><p>二分类任务时的交叉熵计算函数。可以认为是 <strong>nn.CrossEntropyLoss</strong> 函数的特例。在 BCELoss 之前，input 一般为 sigmoid 激活层的输出。</p><img src="/2021/09/PyTorch-Part2/image-20210913145243878.png" alt="image-20210913145243878" style="zoom:67%;"></li><li><p><strong>weight</strong>(Tensor)- 为每个类别的 loss 设置权值，常用于类别不均衡问题。</p><p><strong>size_average</strong>(bool)- 当 reduce=True 时有效。为 True 时，返回的 loss 为平均值；为 False 时，返回的各样本的 loss 之和。</p><p><strong>reduce</strong>(bool)- 返回值是否为标量，默认为 True</p></li></ul></li><li><p>BCEWithLogitsLoss：<code>torch.nn.BCEWithLogitsLoss(weight=None, size_average=None, reduce=None, reduction=&#39;elementwise_mean&#39;, pos_weight=None)</code></p><ul><li><p>将 Sigmoid 与 BCELoss 结合，类似于 CrossEntropyLoss(将 nn.LogSoftmax()和 nn.NLLLoss() 进行结合）。即 input 会经过 Sigmoid 激活函数，将 input 变成概率分布的形式。</p><img src="/2021/09/PyTorch-Part2/image-20210913145354209.png" alt="image-20210913145354209" style="zoom:67%;"></li><li><p><strong>weight</strong>(Tensor)- : 为 batch 中单个样本设置权值，If given, has to be a Tensor of size “nbatch”.</p><p><strong>pos_weight</strong>-: 正样本的权重, 当 p&gt;1，提高召回率，当 P&lt;1，提高精确度。可达到权衡召回率(Recall)和精确度(Precision)的作用。 Must be a vector with length equal to the number of classes.</p><p><strong>size_average</strong>(bool)- 当 reduce=True 时有效。为 True 时，返回的 loss 为平均值；为 False 时，返回的各样本的 loss 之和。</p><p><strong>reduce</strong>(bool)- 返回值是否为标量，默认为 True</p></li></ul></li><li><p>MarginRankingLoss：<code>torch.nn.MarginRankingLoss(margin=0, size_average=None, reduce=None, reduction=&#39;elementwise_mean&#39;)</code></p><ul><li><p>计算两个向量之间的相似度，当两个向量之间的距离大于 margin，则 loss 为正，小于 margin，loss 为 0。</p><img src="/2021/09/PyTorch-Part2/image-20210913145522074.png" alt="image-20210913145522074" style="zoom:67%;"></li><li><p><strong>margin</strong>(float)- x1 和 x2 之间的差异。</p><p><strong>size_average</strong>(bool)- 当 reduce=True 时有效。为 True 时，返回的 loss 为平均值；为 False时，返回的各样本的 loss 之和。</p><p><strong>reduce</strong>(bool)- 返回值是否为标量，默认为 True。</p></li></ul></li><li><p>HingeEmbeddingLoss：<code>torch.nn.HingeEmbeddingLoss(margin=1.0, size_average=None, reduce=None, reduction=&#39;elementwise_mean&#39;)</code></p><ul><li><p>为折页损失的拓展，主要用于衡量两个输入是否相似。used for learning nonlinear embeddings or semi-supervised</p></li><li><p><strong>margin</strong>(float)- 默认值为 1，容忍的差距。</p><p><strong>size_average</strong>(bool)- 当 reduce=True 时有效。为 True 时，返回的 loss 为平均值；为 False时，返回的各样本的 loss 之和。</p><p><strong>reduce</strong>(bool)- 返回值是否为标量，默认为 True。</p></li></ul></li><li><p>MultiLabelMarginLoss：<code>torch.nn.MultiLabelMarginLoss(size_average=None, reduce=None, reduction=&#39;elementwise_mean&#39;)</code></p><ul><li><p>用于一个样本属于多个类别时的分类任务。例如一个四分类任务，样本 x 属于第 0 类，第 1 类，不属于第 2 类，第 3 类。</p><img src="/2021/09/PyTorch-Part2/image-20210913145842583.png" alt="image-20210913145842583"></li><li><p><strong>size_average</strong>(bool)- 当 reduce=True 时有效。为 True 时，返回的 loss 为平均值；为 False时，返回的各样本的 loss 之和。</p><p><strong>reduce</strong>(bool)- 返回值是否为标量，默认为 True。</p><p><strong>Input</strong>: (C) or (N,C) where N is the batch size and C is the number of classes.</p><p><strong>Target</strong>: (C) or (N,C), same shape as the input.</p></li></ul></li><li><p>SmoothL1Loss：<code>torch.nn.SmoothL1Loss(size_average=None, reduce=None, reduction=&#39;elementwise_mean&#39;)</code></p><ul><li><p>计算平滑 L1 损失，属于 Huber Loss 中的一种(因为参数 δ 固定为 1 了)。</p><p>Huber Loss 常用于回归问题，其最大的特点是对离群点（outliers）、噪声不敏感，具有较强的鲁棒性。</p><p>当误差绝对值小于 δ，采用 L2 损失；若大于 δ，采用 L1 损失。</p><img src="/2021/09/PyTorch-Part2/image-20210913150004347.png" alt="image-20210913150004347" style="zoom:67%;"></li><li><p><strong>size_average</strong>(bool)- 当 reduce=True 时有效。为 True 时，返回的 loss 为平均值；为 False时，返回的各样本的 loss 之和。</p><p><strong>reduce</strong>(bool)- 返回值是否为标量，默认为 True。</p></li></ul></li><li><p>SoftMarginLoss：<code>torch.nn.SoftMarginLoss(size_average=None, reduce=None, reduction=&#39;elementwise_mean&#39;)</code></p><ul><li><p>Creates a criterion that optimizes a two-class classification logistic loss between input tensor x and target tensor y (containing 1 or -1). </p><img src="/2021/09/PyTorch-Part2/image-20210913150303241.png" alt="image-20210913150303241"></li><li><p><strong>size_average</strong>(bool)- 当 reduce=True 时有效。为 True 时，返回的 loss 为平均值；为 False时，返回的各样本的 loss 之和。</p><p><strong>reduce</strong>(bool)- 返回值是否为标量，默认为 True。</p></li></ul></li><li><p>MultiLabelSoftMarginLoss：<code>torch.nn.MultiLabelSoftMarginLoss(weight=None, size_average=None, reduce=None, reduction=&#39;elementwise_mean&#39;)</code></p><ul><li><p>SoftMarginLoss 多标签版本，a multi-label one-versus-all loss based on max-entropy.</p><p><img src="/2021/09/PyTorch-Part2/image-20210913150349060.png" alt="image-20210913150349060"></p></li><li><p><strong>weight</strong>(Tensor)- 为每个类别的 loss 设置权值。weight 必须是 float 类型的 tensor，其长度要于类别 C 一致，即每一个类别都要设置有 weight。</p></li></ul></li><li><p>CosineEmbeddingLoss：torch.nn.CosineEmbeddingLoss(margin=0, size_average=None, reduce=None, reduction=’elementwise_mean’)</p><ul><li><p>用 Cosine 函数来衡量两个输入是否相似。 used for learning nonlinear embeddings or semi-supervised</p><p><img src="/2021/09/PyTorch-Part2/image-20210913150448355.png" alt="image-20210913150448355"></p></li><li><p><strong>margin</strong>(float)- ： 取值范围[-1,1]， 推荐设置范围 [0, 0.5] </p><p><strong>size_average</strong>(bool)- 当 reduce=True 时有效。为 True 时，返回的 loss 为平均值；为 False时，返回的各样本的 loss 之和。</p><p><strong>reduce</strong>(bool)- 返回值是否为标量，默认为 True。</p></li></ul></li><li><p>MultiMarginLoss：<code>torch.nn.MultiMarginLoss(p=1, margin=1, weight=None, size_average=None, reduce=None, reduction=&#39;elementwise_mean&#39;)</code></p><ul><li><p>计算多分类的折页损失。</p><p><img src="/2021/09/PyTorch-Part2/image-20210913150527386.png" alt="image-20210913150527386"></p></li><li><p><strong>p</strong>(int)- 默认值为 1，仅可选 1 或者 2。</p><p><strong>margin</strong>(float)- 默认值为 1</p><p><strong>weight</strong>(Tensor)- 为每个类别的 loss 设置权值。weight 必须是 float 类型的 tensor，其长度要与类别 C 一致，即每一个类别都要设置有 weight。</p><p><strong>size_average</strong>(bool)- 当 reduce=True 时有效。为 True 时，返回的 loss 为平均值；为 False时，返回的各样本的 loss 之和。</p><p><strong>reduce</strong>(bool)- 返回值是否为标量，默认为 True。</p></li></ul></li><li><p>TripletMarginLoss：torch.nn.TripletMarginLoss(margin=1.0, p=2, eps=1e-06, swap=False, size_average=None, reduce=None, reduction=’elementwise_mean’)</p><ul><li><p>计算三元组损失，人脸验证中常用。</p><p><img src="/2021/09/PyTorch-Part2/image-20210913150644479.png" alt="image-20210913150644479"></p></li><li><p><strong>margin</strong>(float)- 默认值为 1</p><p><strong>p</strong>(int)- The norm degree ，默认值为 2</p><p><strong>swap</strong>(float)– The distance swap is described in detail in the paper Learning shallow convolutional </p><p><strong>feature</strong> descriptors with triplet losses by V. Balntas, E. Riba et al. Default: False</p><p><strong>size_average</strong>(bool)- 当 reduce=True 时有效。为 True 时，返回的 loss 为平均值；为 False时，返回的各样本的 loss 之和。</p><p><strong>reduce</strong>(bool)- 返回值是否为标量，默认为 True。</p></li></ul></li></ol><h2 id="优化器-Optimizer"><a href="#优化器-Optimizer" class="headerlink" title="优化器(Optimizer)"></a>优化器(Optimizer)</h2><h3 id="优化器类"><a href="#优化器类" class="headerlink" title="优化器类"></a>优化器类</h3><ul><li>PyTorch 中所有的优化器均是 Optimizer 的子类。</li></ul><h4 id="参数组"><a href="#参数组" class="headerlink" title="参数组"></a>参数组</h4><ul><li>参数组(param_groups)在 finetune、某层定制学习率、某层学习率置零等操作中，将发挥重要作用。</li><li>optimizer 对参数的管理是基于组的概念，可以为每一组参数配置特定的 lr、momentum、weight_decay 等等。</li><li>参数组在 optimizer 中表现为一个 list(self.param_groups)，其中每个元素是 dict，表示一个参数及其相应配置，在 dict 中包含’params’、’weight_decay’、’lr’ 、’momentum’等字段。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">w1 = torch.randn((<span class="number">2</span>, <span class="number">2</span>), requires_grad=<span class="literal">True</span>)</span><br><span class="line">w2 = torch.randn((<span class="number">2</span>, <span class="number">2</span>), requires_grad=<span class="literal">True</span>)</span><br><span class="line">w3 = torch.randn((<span class="number">2</span>, <span class="number">2</span>), requires_grad=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 一个参数组</span></span><br><span class="line">optimizer_1 = optim.SGD([w1, w3], lr=<span class="number">0.1</span>)</span><br><span class="line">print(<span class="string">&#x27;len(optimizer.param_groups): &#x27;</span>, <span class="built_in">len</span>(optimizer_1.param_groups))</span><br><span class="line">print(optimizer_1.param_groups, <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 两个参数组</span></span><br><span class="line">optimizer_2 = optim.SGD([&#123;<span class="string">&#x27;params&#x27;</span>: w1, <span class="string">&#x27;lr&#x27;</span>: <span class="number">0.1</span>&#125;,</span><br><span class="line">                         &#123;<span class="string">&#x27;params&#x27;</span>: w2, <span class="string">&#x27;lr&#x27;</span>: <span class="number">0.001</span>&#125;])</span><br><span class="line">print(<span class="string">&#x27;len(optimizer.param_groups): &#x27;</span>, <span class="built_in">len</span>(optimizer_2.param_groups))</span><br><span class="line">print(optimizer_2.param_groups)</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">len(optimizer.param_groups): 1</span></span><br><span class="line"><span class="string">[&#123;&#x27;params&#x27;: [tensor([[0.6320, 0.4332], [-0.0429, -0.4769]], requires_grad=True), </span></span><br><span class="line"><span class="string">             tensor([[0.4598, 0.3449], [0.5621, -1.2329]], requires_grad=True)],</span></span><br><span class="line"><span class="string">  &#x27;lr&#x27;: 0.1, &#x27;momentum&#x27;: 0, &#x27;dampening&#x27;: 0, &#x27;weight_decay&#x27;: 0, &#x27;nesterov&#x27;: False&#125;]</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">len(optimizer.param_groups): 2</span></span><br><span class="line"><span class="string">[&#123;&#x27;params&#x27;: [tensor([[0.6320, 0.4332], [-0.0429, -0.4769]], requires_grad=True)], </span></span><br><span class="line"><span class="string">  &#x27;lr&#x27;: 0.1, &#x27;momentum&#x27;: 0, &#x27;dampening&#x27;: 0, &#x27;weight_decay&#x27;: 0, &#x27;nesterov&#x27;: False&#125;, </span></span><br><span class="line"><span class="string"> &#123;&#x27;params&#x27;: [tensor([[-0.8244, 2.3955], [0.6752, -0.0980]], requires_grad=True)], </span></span><br><span class="line"><span class="string">  &#x27;lr&#x27;: 0.001, &#x27;momentum&#x27;: 0, &#x27;dampening&#x27;: 0, &#x27;weight_decay&#x27;: 0, &#x27;nesterov&#x27;: False&#125;]</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure><h4 id="优化器常用方法"><a href="#优化器常用方法" class="headerlink" title="优化器常用方法"></a>优化器常用方法</h4><ol><li><code>zero_grad()</code>：将梯度清零。<ul><li>由于 PyTorch 不会自动清零梯度，所以在每一次反向传播之前都应当进行此操作。</li></ul></li><li><code>state_dict()</code>：将优化器的状态作为dict返回。返回 state、param_groups 组成的字典。<ul><li><strong>state</strong> - 保存当前优化状态的字典。 其内容优化器类之间有所不同。<br><strong>param_groups</strong> - 包含所有参数组的字典</li></ul></li><li><code>load_state_dict(state_dict)</code>：加载优化器状态。<ul><li>常用于 finetune。</li></ul></li><li><code>add_param_group()</code>：给 optimizer 管理的参数组中增加一组参数。<ul><li>可为该组参数定制 lr、momentum、weight_decay 等，在 finetune 中常用。</li></ul></li><li><code>step(closure)</code>：执行一步权值更新, 其中可传入参数 closure（一个闭包）。<ul><li>如，当采用 LBFGS 优化方法时，需要多次计算，因此需要传入一个闭包去允许它们重新计算 loss 。</li></ul></li></ol><h3 id="PyTorch-的十个优化器-干货"><a href="#PyTorch-的十个优化器-干货" class="headerlink" title="PyTorch 的十个优化器(干货)"></a>PyTorch 的十个优化器(干货)</h3><ol><li><p>torch.optim.SGD：<code>torch.optim.SGD(params, lr=&lt;object object&gt;, momentum=0, dampening=0, weight_decay=0, nesterov=False)</code></p><ul><li><p>实现带动量的 SGD 优化算法，并且均可拥有 weight_decay 项。</p></li><li><p><strong>params</strong>(iterable)- 参数组(参数组的概念请查看 3.2 优化器基类：Optimizer)，优化器要管理的那部分参数。</p><p><strong>lr</strong>(float)- 初始学习率，可按需随着训练过程不断调整学习率。</p><p><strong>momentum</strong>(float)- 动量，通常设置为 0.9，0.8</p><p><strong>dampening</strong>(float)- 若采用 nesterov，dampening 必须为 0.</p><p><strong>weight_decay</strong>(float)- 权值衰减系数，也就是 L2 正则项的系数</p><p><strong>nesterov</strong>(bool)- bool 选项，是否使用 NAG(Nesterov accelerated gradient)</p></li></ul></li><li><p>torch.optim.ASGD：<code>torch.optim.ASGD(params, lr=0.01, lambd=0.0001, alpha=0.75, t0=1000000.0, weight_decay=0)</code></p><ul><li><p>ASGD 也称为 SAG，表示随机平均梯度下降(Averaged Stochastic Gradient Descent)，简单地说 ASGD 就是用空间换时间的一种 SGD。</p><p><a href="http://riejohnson.com/rie/stograd_nips.pdf">http://riejohnson.com/rie/stograd_nips.pdf</a> </p></li><li><p><strong>params</strong>(iterable)- 参数组(参数组的概念请查看 3.1 优化器基类：Optimizer)，优化器要优化的那些参数。</p><p><strong>lr</strong>(float)- 初始学习率，可按需随着训练过程不断调整学习率。</p><p><strong>lambd</strong>(float)- 衰减项，默认值 1e-4。</p><p><strong>alpha</strong>(float)- power for eta update ，默认值 0.75。</p><p><strong>t0</strong>(float)- point at which to start averaging，默认值 1e6。</p><p><strong>weight_decay</strong>(float)- 权值衰减系数，也就是 L2 正则项的系数。</p></li></ul></li><li><p>torch.optim.Rprop：<code>torch.optim.Rprop(params, lr=0.01, etas=(0.5, 1.2), step_sizes=(1e-06, 50))</code></p><ul><li><p>实现 Rprop 优化方法(弹性反向传播)，该优化方法适用于 full-batch，不适用于 mini-batch，因而在 mini-batch 大行其道的时代里，很少见到。</p><p>《Martin Riedmiller und Heinrich Braun: Rprop -A Fast Adaptive Learning Algorithm. Proceedings of the International Symposium on Computer and Information Science VII, 1992》</p></li></ul></li><li><p>torch.optim.Adagrad：<code>torch.optim.Adagrad(params, lr=0.01, lr_decay=0, weight_decay=0, initial_accumulator_value=0)</code></p><ul><li><p>Adagrad(Adaptive Gradient) 是一种自适应优化方法，是自适应的为各个参数分配不同的学习率。这个学习率的变化，会受到梯度的大小和迭代次数的影响。梯度越大，学习率越小；梯度越小，学习率越大。缺点是训练后期，学习率过小，因为 Adagrad 累加之前所有的梯度平方作为分母。</p><p><a href="http://www.jmlr.org/papers/volume12/duchi11a/duchi11a.pdf">Adaptive Subgradient Methods for Online Learning and Stochastic Optimization John Duchi, Elad Hazan, Yoram Singer; 12(Jul):2121−2159, 2011.</a></p></li></ul></li><li><p>torch.optim.Adadelta：<code>torch.optim.Adadelta(params, lr=1.0, rho=0.9, eps=1e-06, weight_decay=0)</code></p><ul><li><p>实现 Adadelta 优化方法。<strong>Adadelta</strong> 是 <strong>Adagrad</strong> 的改进。Adadelta 分母中采用距离当前时间点比较近的累计项，这可以避免在训练后期，学习率过小。</p><p><a href="https://arxiv.org/pdf/1212.5701.pdf">https://arxiv.org/pdf/1212.5701.pdf</a></p></li></ul></li><li><p>torch.optim.RMSprop：<code>torch.optim.RMSprop(params, lr=0.01, alpha=0.99, eps=1e-08, weight_decay=0, momentum=0, centered=False)</code></p><ul><li><p>实现 RMSprop 优化方法（Hinton 提出），RMS 是均方根（root meam square）的意思。RMSprop 和 Adadelta 一样，也是对 Adagrad 的一种改进。RMSprop 采用均方根作为分母，可缓解 Adagrad 学习率下降较快的问题，并且引入均方根，可以减少摆动</p><p><a href="http://www.cs.toronto.edu/~tijmen/csc321/slides/lecture_slides_lec6.pdf">http://www.cs.toronto.edu/~tijmen/csc321/slides/lecture_slides_lec6.pdf</a></p></li></ul></li><li><p>torch.optim.Adam(AMSGrad)：<code>torch.optim.Adam(params, lr=0.001, betas=(0.9, 0.999), eps=1e- 08, weight_decay=0, amsgrad=False)</code></p><ul><li><p>实现 Adam(Adaptive Moment Estimation))优化方法。Adam 是一种自适应学习率的优化方法，Adam 利用梯度的一阶矩估计和二阶矩估计动态的调整学习率。吴老师课上说过，Adam 是结合了 Momentum 和 RMSprop，并进行了偏差修正。</p><p><a href="https://arxiv.org/abs/1412.6980">Adam: A Method for Stochastic Optimization</a></p></li><li><p><strong>amsgrad</strong>- 是否采用 AMSGrad 优化方法，asmgrad 优化方法是针对 Adam 的改进，通过添加额外的约束，使学习率始终为正值。</p></li></ul></li><li><p>torch.optim.Adamax：<code>torch.optim.Adamax(params, lr=0.002, betas=(0.9, 0.999), eps=1e-08, weight_decay=0)</code></p><ul><li><p>实现 Adamax 优化方法。Adamax 是对 Adam 增加了一个学习率上限的概念</p><p><a href="https://arxiv.org/abs/1412.6980">Adam: A Method for Stochastic Optimization</a></p></li></ul></li><li><p>torch.optim.SparseAdam：<code>torch.optim.SparseAdam(params, lr=0.001, betas=(0.9, 0.999), eps=1e-08)</code></p><ul><li>针对稀疏张量的一种“阉割版”Adam 优化方法。</li></ul></li><li><p>torch.optim.LBFGS：<code>torch.optim.LBFGS(params, lr=1, max_iter=20, max_eval=None, tolerance_grad=1e-05, tolerance_change=1e-09, history_size=100, line_search_fn=None)</code></p><ul><li>实现 L-BFGS（Limited-memory Broyden–Fletcher–Goldfarb–Shanno）优化方法。L-BFGS 属于拟牛顿算法。L-BFGS 是对 BFGS 的改进，特点就是节省内存。</li></ul></li></ol><h3 id="PyTorch-的六个学习率调整方法-干货"><a href="#PyTorch-的六个学习率调整方法-干货" class="headerlink" title="PyTorch 的六个学习率调整方法(干货)"></a>PyTorch 的六个学习率调整方法(干货)</h3><ol><li><p>StepLR：<code>torch.optim.lr_scheduler.StepLR(optimizer, step_size, gamma=0.1, last_epoch=-1)</code></p><ul><li><p>等间隔调整学习率，调整倍数为 gamma 倍，调整间隔为 step_size。</p><p>间隔单位是 step。需要注意的是，step 通常是指 epoch，不要当成 iteration 。</p></li><li><p><strong>step_size</strong>(int)- 学习率下降间隔数，若为 30，则会在 30、60、90……个 step 时，将学习率调整为 lr*gamma。</p><p><strong>gamma</strong>(float)- 学习率调整倍数，默认为 0.1 倍，即下降 10 倍。</p><p><strong>last_epoch</strong>(int)- 上一个 epoch 数，这个变量用来指示学习率是否需要调整。当 last_epoch 符合设定的间隔时，就会对学习率进行调整。当为 -1 时，学习率设置为初始值。</p></li></ul></li><li><p>MultiStepLR：<code>torch.optim.lr_scheduler.MultiStepLR(optimizer, milestones, gamma=0.1, last_epoch=-1)</code></p><ul><li><p>按设定的间隔调整学习率。这个方法适合后期调试使用，观察 loss 曲线，为每个实验定制学习率调整时机</p></li><li><p><strong>milestones</strong>(list)- 一个 list，每一个元素代表何时调整学习率，list 元素必须是递增的。如 milestones=[30, 80, 120]</p><p><strong>gamma</strong>(float)- 学习率调整倍数，默认为 0.1 倍，即下降 10 倍。</p><p><strong>last_epoch</strong>(int)- 上一个 epoch 数，这个变量用来指示学习率是否需要调整。当 last_epoch 符合设定的间隔时，就会对学习率进行调整。当为 -1 时，学习率设置为初始值。</p></li></ul></li><li><p>ExponentialLR：<code>torch.optim.lr_scheduler.ExponentialLR(optimizer, gamma, last_epoch=-1)</code></p><ul><li><p>按指数衰减调整学习率，调整公式: lr = lr * gamma**epoch</p></li><li><p><strong>gamma</strong>- 学习率调整倍数的底，指数为 epoch，即 gamma**epoch</p><p><strong>last_epoch</strong>(int)- 上一个 epoch 数，这个变量用来指示学习率是否需要调整。当 last_epoch 符合设定的间隔时，就会对学习率进行调整。当为-1 时，学习率设置为初始值。</p></li></ul></li><li><p>CosineAnnealingLR：<code>torch.optim.lr_scheduler.CosineAnnealingLR(optimizer, T_max, eta_min=0, last_epoch=-1)</code></p><ul><li><p>余弦退火，以余弦函数为周期，并在每个周期最大值时重新设置学习率。</p><p><a href="https://arxiv.org/abs/1608.03983">《SGDR: Stochastic Gradient Descent with Warm Restarts》(ICLR-2017)</a></p></li><li><p><strong>T_max</strong>(int)- 一次学习率周期的迭代次数，即 T_max 个 epoch 之后重新设置学习率。</p><p><strong>eta_min</strong>(float)- 最小学习率，即在一个周期中，学习率最小会下降到 eta_min，默认值为 0。</p></li></ul></li><li><p>ReduceLROnPlateau：<code>torch.optim.lr_scheduler.ReduceLROnPlateau(optimizer, mode=&#39;min&#39;,factor=0.1, patience=10, verbose=False, threshold=0.0001, threshold_mode=&#39;rel&#39;, cooldown=0, min_lr=0, eps=1e-08)</code></p><ul><li><p>检测指定的指标，当某指标不再变化（下降或升高）时，调整学习率。这是非常实用的学习率调整策略。</p><p>例如，当验证集的 loss 不再下降时，进行学习率调整；或者监测验证集的 accuracy，当 accuracy 不再上升时，则调整学习率。</p></li><li><p><strong>mode</strong>(str)- 模式选择，有 min 和 max 两种模式，min 表示当指标不再降低(如监测loss)，max 表示当指标不再升高(如监测 accuracy)。</p><p><strong>factor</strong>(float)- 学习率调整倍数(等同于其它方法的 gamma)，即学习率更新为 lr = lr * factor</p><p><strong>patience</strong>(int)- “耐心”，即忍受该指标多少个 step 不变化，当忍无可忍时，调整学习率。</p><p><strong>verbose</strong>(bool)- 是否打印学习率信息：print(‘Epoch {:5d}: reducing learning rate’ ‘ of group {} to {:.4e}.’.format(epoch, i, new_lr))</p><p><strong>threshold</strong>(float)- Threshold for measuring the new optimum，配合 threshold_mode 使用。</p><p><strong>threshold_mode</strong>(str)- 选择判断指标是否达最优的模式，有两种模式，rel 和 abs。 当 threshold_mode=rel，并且 mode=max 时，dynamic_threshold = best * ( 1 + threshold )；</p><p>​        当 threshold_mode=rel，并且 mode=min 时，dynamic_threshold = best * ( 1 -threshold )； </p><p>​        当 threshold_mode=abs，并且 mode=max 时，dynamic_threshold = best + threshold ； </p><p>​        当 threshold_mode=rel，并且 mode=max 时，dynamic_threshold = best - threshold </p><p><strong>cooldown</strong>(int)- “冷却时间“，当调整学习率之后，让学习率调整策略冷静一下，让模型再训练一段时间，再重启监测模式。</p><p><strong>min_lr</strong>(float or list)- 学习率下限，可为 float，或者 list，当有多个参数组时，可用 list 进行设置。</p><p><strong>eps</strong>(float)- 学习率衰减的最小值，当学习率变化小于 eps 时，则不调整学习率。</p></li></ul></li><li><p>LambdaLR：<code>torch.optim.lr_scheduler.LambdaLR(optimizer, lr_lambda, last_epoch=- 1)</code></p><ul><li><p>为不同参数组自定义学习率调整策略。调整规则为，lr = base_lr * lmbda(self.last_epoch) 。</p></li><li><p><strong>lr_lambda</strong>(function or list)- 一个计算学习率调整倍数的函数，输入通常为 step，当有多个参数组时，设为 list。</p><p><strong>last_epoch</strong>(int)- 上一个 epoch 数，这个变量用来指示学习率是否需要调整。当 last_epoch 符合设定的间隔时，就会对学习率进行调整。当为-1 时，学习率设置为初始值。</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">model = resnet18(pretrained=<span class="literal">False</span>)  <span class="comment"># 加载模型</span></span><br><span class="line">optimizer = torch.optim.SGD(params=[  <span class="comment"># 初始化优化器，并设置两个param_groups</span></span><br><span class="line">    &#123;<span class="string">&#x27;params&#x27;</span>: model.layer2.parameters()&#125;,</span><br><span class="line">    &#123;<span class="string">&#x27;params&#x27;</span>: model.layer3.parameters(), <span class="string">&#x27;lr&#x27;</span>: <span class="number">0.2</span>&#125;,</span><br><span class="line">], lr=<span class="number">1</span>, momentum=<span class="number">0.9</span>, weight_decay=<span class="number">0.005</span>)  <span class="comment"># base_lr = 0.1</span></span><br><span class="line"></span><br><span class="line">epochs = <span class="number">500</span>  <span class="comment"># 训练次数</span></span><br><span class="line">warm_up_epoch = <span class="number">5</span></span><br><span class="line">t_max = epochs - warm_up_epoch  <span class="comment"># cos衰减周期</span></span><br><span class="line">lr_max = <span class="number">0.1</span>  <span class="comment"># 最大值</span></span><br><span class="line">lr_min = <span class="number">0.001</span>  <span class="comment"># 最小值</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_warmup_cos_lambda</span>(<span class="params">lr_max, lr_min, start, warm_up_epoch, t_max</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">warmup_cos_lambda</span>(<span class="params">cur_epoch</span>):</span></span><br><span class="line">        <span class="keyword">if</span> cur_epoch &lt; start:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">elif</span> cur_epoch &lt; warm_up_epoch + start:</span><br><span class="line">            <span class="keyword">return</span> (cur_epoch - start) / warm_up_epoch + lr_min</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> (lr_max - lr_min) * (<span class="number">1.0</span> + math.cos((cur_epoch - start - warm_up_epoch) / t_max * math.pi)) / <span class="number">2</span> + lr_min</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> warmup_cos_lambda</span><br><span class="line"></span><br><span class="line"><span class="comment"># LambdaLR</span></span><br><span class="line">scheduler = torch.optim.lr_scheduler.LambdaLR(</span><br><span class="line">    optimizer,</span><br><span class="line">    lr_lambda=[</span><br><span class="line">        get_warmup_cos_lambda(lr_max, lr_min, <span class="number">0</span>, warm_up_epoch, t_max),</span><br><span class="line">        get_warmup_cos_lambda(lr_max, lr_min, <span class="number">5</span>, warm_up_epoch, t_max)</span><br><span class="line">    ]</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> epoch <span class="keyword">in</span> <span class="built_in">range</span>(epochs):</span><br><span class="line">    print(optimizer.param_groups[<span class="number">0</span>][<span class="string">&#x27;lr&#x27;</span>], optimizer.param_groups[<span class="number">1</span>][<span class="string">&#x27;lr&#x27;</span>])</span><br><span class="line">    optimizer.step()</span><br><span class="line">    scheduler.step()</span><br></pre></td></tr></table></figure><h3 id="scheduler-step"><a href="#scheduler-step" class="headerlink" title="scheduler.step()"></a>scheduler.step()</h3></li></ol><ul><li>当调用 <code>scheduler.step(epoch=None)</code> 时，如果不传入 epoch，默认成员变量 last_epoch+=1，如果传入 epoch，则直接更新 last_epoch。</li><li>因此，scheduler.step() 要放在 epoch 的 for 循环当中执行。当然也可以放在每个 batch 的 iter 中更新，这样更加细致。</li><li>更新完 last_epoch 之后，则调用 <code>get_lr()</code> 获取当前 epoch 下，该参数组的学习率。</li></ul><h2 id="可视化"><a href="#可视化" class="headerlink" title="可视化"></a>可视化</h2><h3 id="TensorBoardX"><a href="#TensorBoardX" class="headerlink" title="TensorBoardX"></a>TensorBoardX</h3><ul><li>无法显示图表有可能是因为浏览器差异。</li></ul><h4 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h4><blockquote><p>在浏览器中查看可视化数据，只要在命令行中开启 tensorboard ：<code>tensorboard --logdir=&lt;your_log_dir&gt;</code></p><p>其中的 <your_log_dir> 既可以是单个 run 的路径，也可以是多个 run 的父目录。如 runs/ 下面可能会有很多的子文件夹，每个文件夹都代表了一次实验，我们令 –logdir=runs/ 就可以在 tensorboard 可视化界面中方便地横向比较不同实验所得数据的差异。</your_log_dir></p></blockquote><ol><li><p>SummaryWriter：<code>SummaryWriter(logdir=None, comment=&quot;&quot;, purge_step=None, max_queue=10, flush_secs=120, filename_suffix=&#39;&#39;, write_to_disk=True, log_dir=None, comet_config=&#123;&quot;disabled&quot;: True&#125;, **kwargs)</code></p><ul><li><p>创建一个 SummaryWriter 的实例</p></li><li><p><strong>logdir</strong>- 用该路径来保存日志。无参数，默认将使用 runs/日期时间</p><p><strong>comment</strong>- 文件夹后缀，将使用 runs/日期时间-comment 路径来保存日志</p><p><strong>filename_suffix</strong>- 设置 event file 文件名后缀</p></li><li><p>```python<br>writer = SummaryWriter(log_dir=’./tensorboard event file’, filename_suffix=str(cfg.EPOCH_NUMBER), comment=’test_tensorboard’)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">2. add_scalar：&#96;add_scalar(tag, scalar_value, global_step&#x3D;None, walltime&#x3D;None)&#96;</span><br><span class="line"></span><br><span class="line">   - 在一个图表中记录一个标量的变化，常用于 loss、accuracy、learning rate 曲线的记录。</span><br><span class="line"></span><br><span class="line">   - **tag**(string)- 该图的标签，类似于 polt.title</span><br><span class="line"></span><br><span class="line">     **scalar_value**(float or string&#x2F;blobname)- 用于存储的值，曲线图的 y 坐标。注意，对于 PyTorch scalar tensor，需要调用 &#96;.item()&#96; 方法获取其数值</span><br><span class="line"></span><br><span class="line">     **global_step**(int)- 曲线图的 x 坐标</span><br><span class="line"></span><br><span class="line">     **walltime**(float)- 为 event 文件的文件名设置时间，默认为 time.time()</span><br><span class="line">     </span><br><span class="line">   - &#96;&#96;&#96;python</span><br><span class="line">     writer.add_scalar(&#39;Train Loss&#39;, train_loss &#x2F; num_mini_batch, epoch)</span><br></pre></td></tr></table></figure></li></ul></li><li><p>add_scalars：<code>add_scalars(main_tag, tag_scalar_dict, global_step=None, walltime=None)</code></p><ul><li><p>在一个图表中记录多个标量的变化，常用于对比，如 trainLoss 和 validLoss 的比较等。</p></li><li><p><strong>main_tag</strong>(string)- 该图的标签。</p><p><strong>tag_scalar_dict</strong>(dict)- key 是变量的 tag，value 是变量的值。</p><p><strong>global_step</strong>(int)- 曲线图的 x 坐标</p><p><strong>walltime</strong>(float)- 为 event 文件的文件名设置时间，默认为 time.time()</p></li><li><pre><code class="python">    writer.add_scalars(&#39;data/scalar_group&#39;, &#123;&quot;xsinx&quot;: x * np.sin(x),                                             &quot;xcosx&quot;: x * np.cos(x),                                             &quot;arctanx&quot;: np.arctan(x)&#125;, x)<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">4. add_histogram：&#96;add_histogram(tag, values, global_step&#x3D;None, bins&#x3D;&#39;tensorflow&#39;, walltime&#x3D;None)&#96;</span><br><span class="line"></span><br><span class="line">   - 绘制直方图和多分位数折线图，常用于监测权值及梯度的分布变化情况，便于诊断网络更新方向是否正确。</span><br><span class="line"></span><br><span class="line">   - **tag**(string)- 该图的标签，类似于 polt.title。</span><br><span class="line"></span><br><span class="line">     **values**(torch.Tensor, numpy.array or string&#x2F;blobname)- 用于绘制直方图的值</span><br><span class="line"></span><br><span class="line">     **global_step**(int)- 曲线图的 y 坐标</span><br><span class="line"></span><br><span class="line">     **bins**(string)- 决定如何取 bins，默认为‘tensorflow’，可选：’auto’, ‘fd’等</span><br><span class="line"></span><br><span class="line">     **walltime**(float)- 为 event 文件的文件名设置时间，默认为 time.time()</span><br><span class="line"></span><br><span class="line">5. add_image：&#96;add_image(tag, img_tensor, global_step&#x3D;None, walltime&#x3D;None)&#96;</span><br><span class="line"></span><br><span class="line">   - 绘制图片，可用于检查模型的输入，监测 feature map 的变化，或是观察 weight。</span><br><span class="line"></span><br><span class="line">   - **tag**(string)- 该图的标签，类似于 polt.title。</span><br><span class="line"></span><br><span class="line">     **img_tensor**(torch.Tensor,numpy.array, or string&#x2F;blobname)- 需要可视化的图片数据， shape &#x3D; [C,H,W]。</span><br><span class="line"></span><br><span class="line">     **global_step**(int)- x 坐标。</span><br><span class="line"></span><br><span class="line">     **walltime**(float)- 为 event 文件的文件名设置时间，默认为 time.time()。</span><br><span class="line"></span><br><span class="line">   - 通常会借助 torchvision.utils.make_grid() 将一组图片绘制到一个窗口</span><br><span class="line"></span><br><span class="line">   - torchvision.utils.make_grid：&#96;torchvision.utils.make_grid(tensor, nrow&#x3D;8, padding&#x3D;2, normalize&#x3D;False, range&#x3D;None, scale_each&#x3D;False, pad_value&#x3D;0)&#96;</span><br><span class="line"></span><br><span class="line">     - 将一组图片拼接成一张图片，便于可视化。</span><br><span class="line"></span><br><span class="line">     - **tensor**(Tensor or list)- 需可视化的数据，shape:(B x C x H x W) ,B 表示 batch 数，即几张图片</span><br><span class="line"></span><br><span class="line">       **nrow**(int)- 一行显示几张图，默认值为 8。</span><br><span class="line"></span><br><span class="line">       **padding**(int)- 每张图片之间的间隔，默认值为 2。</span><br><span class="line"></span><br><span class="line">       **normalize**(bool)- 是否进行归一化至(0,1)。</span><br><span class="line"></span><br><span class="line">       **range**(tuple)- 设置归一化的 min 和 max，若不设置，默认从 tensor 中找 min 和 max。</span><br><span class="line"></span><br><span class="line">       **scale_each**(bool)- 每张图片是否单独进行归一化，还是 min 和 max 的一个选择。</span><br><span class="line"></span><br><span class="line">       **pad_value**(float)- 填充部分的像素值，默认为 0，即黑色。</span><br><span class="line"></span><br><span class="line">6. add_graph：&#96;add_graph(model, input_to_model&#x3D;None, verbose&#x3D;False, **kwargs)&#96;</span><br><span class="line"></span><br><span class="line">   - 绘制网络结构拓扑图。</span><br><span class="line"></span><br><span class="line">   - **model**(torch.nn.Module)- 模型实例</span><br><span class="line"></span><br><span class="line">     **inpjt_to_model**(torch.autograd.Variable)- 模型的输入数据，可以生成一个随机数，只要 shape 符合要求即可</span><br><span class="line">     </span><br><span class="line">   - &#96;&#96;&#96;python</span><br><span class="line">     init_img &#x3D; torch.zeros((1, 3, 400, 400), device&#x3D;device)</span><br><span class="line">     init_msg &#x3D; torch.zeros((1, secret_size), device&#x3D;device)</span><br><span class="line">     tb_writer.add_graph(StegaStampEncoder, &#123;&quot;img&quot;: init_img, &quot;msg&quot;: init_msg&#125;)</span><br></pre></td></tr></table></figure></code></pre></li><li><p>另外一种用于 debug 检查模型的方法：summary() 可输出模型每层输入输出的 shape 以及模型总量。使用前需要在终端 pip install torchsummary。</p><ul><li><pre><code class="python">from torchsummary import summaryprint(summary(net, (3, 360, 640), device=&quot;cpu&quot;))<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">7. add_embedding：&#96;add_embedding(mat, metadata&#x3D;None, label_img&#x3D;None, global_step&#x3D;None, tag&#x3D;&#39;default&#39;, metadata_header&#x3D;None)&#96;</span><br><span class="line"></span><br><span class="line">   - 在三维空间或二维空间展示数据分布，可选 T-SNE、PCA 和 CUSTOM 方法。</span><br><span class="line"></span><br><span class="line">   - **mat**(torch.Tensor or numpy.array)- 需要绘制的数据，一个样本必须是一个向量形式。</span><br><span class="line"></span><br><span class="line">     **shape** &#x3D; (N,D)，N 是样本数，D 是特征维数。</span><br><span class="line"></span><br><span class="line">     **metadata**(list)- 数据的标签，是一个 list，长度为 N。</span><br><span class="line"></span><br><span class="line">     **label_img**(torch.Tensor)- 空间中展示的图片，shape &#x3D; (N,C,H,W)。</span><br><span class="line"></span><br><span class="line">     **global_step**(int)- Global step value to record，不理解这里有何用处呢？知道的朋友补充一下吧。</span><br><span class="line"></span><br><span class="line">     **tag**(string)- 标签</span><br><span class="line"></span><br><span class="line">8. add_text：&#96;add_text(tag, text_string, global_step&#x3D;None, walltime&#x3D;None)&#96;</span><br><span class="line"></span><br><span class="line">   - 记录文字</span><br><span class="line"></span><br><span class="line">9. add_video：&#96;add_video(tag, vid_tensor, global_step&#x3D;None, fps&#x3D;4, walltime&#x3D;None)&#96;</span><br><span class="line"></span><br><span class="line">   - 记录 video</span><br><span class="line"></span><br><span class="line">10. add_figure：&#96;add_figure(tag, figure, global_step&#x3D;None, close&#x3D;True, walltime&#x3D;None)&#96;</span><br><span class="line"></span><br><span class="line">    - 添加 matplotlib 图片到图像中</span><br><span class="line"></span><br><span class="line">11. add_image_with_boxes：&#96;add_image_with_boxes(tag, img_tensor, box_tensor, global_step&#x3D;None, walltime&#x3D;None, **kwargs)&#96;</span><br><span class="line"></span><br><span class="line">    - 图像中绘制 Box，目标检测中会用到</span><br><span class="line"></span><br><span class="line">12. add_pr_curve：&#96;add_pr_curve(tag, labels, predictions, global_step&#x3D;None, num_thresholds&#x3D;127, weights&#x3D;None, walltime&#x3D;None)&#96;</span><br><span class="line"></span><br><span class="line">    - 绘制 PR 曲线</span><br><span class="line"></span><br><span class="line">13. add_pr_curve_raw：&#96;add_pr_curve_raw(tag, true_positive_counts, false_positive_counts, true_negative_counts, false_negative_counts, precision, recall, global_step&#x3D;None, num_thresholds&#x3D;127, weights&#x3D;None, walltime&#x3D;None)&#96;</span><br><span class="line"></span><br><span class="line">    - 从原始数据上绘制 PR 曲线</span><br><span class="line"></span><br><span class="line">14. export_scalars_to_json：&#96;export_scalars_to_json(path)&#96;</span><br><span class="line"></span><br><span class="line">    - 将 scalars 信息保存到 json 文件，便于后期使用</span><br><span class="line"></span><br><span class="line">#### 卷积核可视化 </span><br><span class="line"></span><br><span class="line">- 神经网络中最重要的就是权值，而人们对神经网络理解有限，所以我们需要通过尽可能了解权值来帮助诊断网络的训练情况。除了查看权值分布图和多折线分位图，还可以对卷积核权值进行可视化，来辅助我们分析网络。对卷积核权值进行可视化，在一定程度上帮助我们诊断网络的训练好坏，因此对卷积核权值的可视化十分有必要。</span><br><span class="line">- 可视化原理很简单，对单个卷积核进行“归一化”至 0～255，然后将其展现出来即可，这一系列操作可以借助 TensorboardX 的 add_image 来实现。</span><br><span class="line">- 决定一张特征图需要的卷积核的维度由输入通道决定，生成的特征图数量由卷积核的数量决定。</span><br><span class="line"></span><br><span class="line">&#96;&#96;&#96;python</span><br><span class="line">import os</span><br><span class="line">import torch</span><br><span class="line">import torchvision.utils as vutils</span><br><span class="line">from tensorboardX import SummaryWriter</span><br><span class="line">import torch.nn as nn</span><br><span class="line">import torch.nn.functional as F</span><br><span class="line"></span><br><span class="line">net &#x3D; Net()  # 创建一个网络</span><br><span class="line">pretrained_dict &#x3D; torch.load(os.path.join(&quot;..&quot;, &quot;2_model&quot;, &quot;net_params.pkl&quot;))</span><br><span class="line">net.load_state_dict(pretrained_dict)</span><br><span class="line"></span><br><span class="line">writer &#x3D; SummaryWriter(log_dir&#x3D;os.path.join(&quot;..&quot;, &quot;..&quot; &quot;Result&quot;, &quot;visual_weights&quot;))</span><br><span class="line">params &#x3D; net.state_dict()</span><br><span class="line">for k, v in params.items():</span><br><span class="line">    if &#39;conv&#39; in k and &#39;weight&#39; in k:</span><br><span class="line"></span><br><span class="line">        c_int &#x3D; v.size()[1]  # 输入层通道数</span><br><span class="line">        c_out &#x3D; v.size()[0]  # 输出层通道数</span><br><span class="line"></span><br><span class="line">        # 以feature map为单位，绘制一组卷积核，一张feature map对应的卷积核个数为输入通道数</span><br><span class="line">        for j in range(c_out):</span><br><span class="line">            print(k, v.size(), j)</span><br><span class="line">            kernel_j &#x3D; v[j, :, :, :].unsqueeze(1)  # 压缩维度，为make_grid制作输入</span><br><span class="line">            kernel_grid &#x3D; vutils.make_grid(kernel_j, normalize&#x3D;True, scale_each&#x3D;True, nrow&#x3D;c_int)  # 1*输入通道数, w, h</span><br><span class="line">            writer.add_image(k + &#39;_split_in_channel&#39;, kernel_grid, global_step&#x3D;j)  # j 表示feature map数</span><br><span class="line"></span><br><span class="line">        # 将一个卷积层的卷积核绘制在一起，每一行是一个 feature map 的卷积核</span><br><span class="line">        k_w, k_h &#x3D; v.size()[-1], v.size()[-2]</span><br><span class="line">        kernel_all &#x3D; v.view(-1, 1, k_w, k_h)</span><br><span class="line">        kernel_grid &#x3D; vutils.make_grid(kernel_all, normalize&#x3D;True, scale_each&#x3D;True, nrow&#x3D;c_int)  # 1*输入通道数, w, h</span><br><span class="line">        writer.add_image(k + &#39;_all&#39;, kernel_grid, global_step&#x3D;666)</span><br><span class="line">writer.close()</span><br></pre></td></tr></table></figure>#### 特征图可视化</code></pre></li></ul></li></ul></li><li><p>获取图片，将其转换成模型输入前的数据格式，即一系列 transform，</p></li><li><p>获取模型各层操作，手动的执行每一层操作，拿到所需的 feature maps，</p></li><li><p>借助 tensorboardX 进行绘制。</p></li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> torchvision.utils <span class="keyword">as</span> vutils</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> tensorboardX <span class="keyword">import</span> SummaryWriter</span><br><span class="line"><span class="keyword">import</span> torch.nn.functional <span class="keyword">as</span> F</span><br><span class="line"><span class="keyword">import</span> torchvision.transforms <span class="keyword">as</span> transforms</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line">sys.path.append(<span class="string">&quot;..&quot;</span>)</span><br><span class="line"><span class="keyword">from</span> utils.utils <span class="keyword">import</span> MyDataset, Net, normalize_invert</span><br><span class="line"><span class="keyword">from</span> torch.utils.data <span class="keyword">import</span> DataLoader</span><br><span class="line"></span><br><span class="line">vis_layer = <span class="string">&#x27;conv1&#x27;</span></span><br><span class="line">log_dir = os.path.join(<span class="string">&quot;..&quot;</span>, <span class="string">&quot;..&quot;</span> <span class="string">&quot;Result&quot;</span>, <span class="string">&quot;visual_featuremaps&quot;</span>)</span><br><span class="line">txt_path = os.path.join(<span class="string">&quot;..&quot;</span>, <span class="string">&quot;..&quot;</span>, <span class="string">&quot;Data&quot;</span>, <span class="string">&quot;visual.txt&quot;</span>)</span><br><span class="line">pretrained_path = os.path.join(<span class="string">&quot;..&quot;</span>, <span class="string">&quot;..&quot;</span>, <span class="string">&quot;Data&quot;</span>, <span class="string">&quot;net_params_72p.pkl&quot;</span>)</span><br><span class="line"></span><br><span class="line">net = Net()</span><br><span class="line">net.load_state_dict(torch.load(pretrained_path))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 数据预处理</span></span><br><span class="line">normMean = [<span class="number">0.49139968</span>, <span class="number">0.48215827</span>, <span class="number">0.44653124</span>]</span><br><span class="line">normStd = [<span class="number">0.24703233</span>, <span class="number">0.24348505</span>, <span class="number">0.26158768</span>]</span><br><span class="line">testTransform = transforms.Compose([</span><br><span class="line">    transforms.Resize((<span class="number">32</span>, <span class="number">32</span>)),</span><br><span class="line">    transforms.ToTensor(),</span><br><span class="line">    transforms.Normalize(normMean, normStd)</span><br><span class="line">])</span><br><span class="line"><span class="comment"># 载入数据</span></span><br><span class="line">test_data = MyDataset(txt_path=txt_path, transform=testTransform)</span><br><span class="line">test_loader = DataLoader(dataset=test_data, batch_size=<span class="number">1</span>)</span><br><span class="line">img, label = <span class="built_in">iter</span>(test_loader).<span class="built_in">next</span>()</span><br><span class="line"></span><br><span class="line">x = img</span><br><span class="line">writer = SummaryWriter(log_dir=log_dir)</span><br><span class="line"><span class="keyword">for</span> name, layer <span class="keyword">in</span> net._modules.items():</span><br><span class="line">    <span class="comment"># 为fc层预处理x</span></span><br><span class="line">    x = x.view(x.size(<span class="number">0</span>), -<span class="number">1</span>) <span class="keyword">if</span> <span class="string">&quot;fc&quot;</span> <span class="keyword">in</span> name <span class="keyword">else</span> x</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 对x执行单层运算</span></span><br><span class="line">    x = layer(x)</span><br><span class="line">    print(x.size())</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 由于__init__()相较于forward()缺少relu操作，需要手动增加</span></span><br><span class="line">    x = F.relu(x) <span class="keyword">if</span> <span class="string">&#x27;conv&#x27;</span> <span class="keyword">in</span> name <span class="keyword">else</span> x</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 依据选择的层，进行记录feature maps</span></span><br><span class="line">    <span class="keyword">if</span> name == vis_layer:</span><br><span class="line">        <span class="comment"># 绘制feature maps</span></span><br><span class="line">        x1 = x.transpose(<span class="number">0</span>, <span class="number">1</span>)  <span class="comment"># C，B, H, W  ---&gt; B，C, H, W</span></span><br><span class="line">        img_grid = vutils.make_grid(x1, normalize=<span class="literal">True</span>, scale_each=<span class="literal">True</span>, nrow=<span class="number">2</span>)  <span class="comment"># B，C, H, W</span></span><br><span class="line">        writer.add_image(vis_layer + <span class="string">&#x27;_feature_maps&#x27;</span>, img_grid, global_step=<span class="number">666</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 绘制原始图像</span></span><br><span class="line">        img_raw = normalize_invert(img, normMean, normStd)  <span class="comment"># 图像去标准化</span></span><br><span class="line">        img_raw = np.array(img_raw * <span class="number">255</span>).clip(<span class="number">0</span>, <span class="number">255</span>).squeeze().astype(<span class="string">&#x27;uint8&#x27;</span>)</span><br><span class="line">        writer.add_image(<span class="string">&#x27;raw img&#x27;</span>, img_raw, global_step=<span class="number">666</span>)  <span class="comment"># j 表示feature map数</span></span><br><span class="line">writer.close()</span><br></pre></td></tr></table></figure><h4 id="梯度及权值分布可视化"><a href="#梯度及权值分布可视化" class="headerlink" title="梯度及权值分布可视化"></a>梯度及权值分布可视化</h4><h5 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h5><ul><li>在网络训练过程中，我们常常会遇到梯度消失、梯度爆炸等问题，我们可以通过记录每个 epoch 的梯度的值来监测梯度的情况，还可以记录权值，分析权值更新的方向是否符合规律。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">from</span> torch.utils.data <span class="keyword">import</span> DataLoader</span><br><span class="line"><span class="keyword">import</span> torchvision.transforms <span class="keyword">as</span> transforms</span><br><span class="line"><span class="keyword">from</span> torch.autograd <span class="keyword">import</span> Variable</span><br><span class="line"><span class="keyword">import</span> torch.nn <span class="keyword">as</span> nn</span><br><span class="line"><span class="keyword">import</span> torch.optim <span class="keyword">as</span> optim</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line">sys.path.append(<span class="string">&quot;..&quot;</span>)</span><br><span class="line"><span class="keyword">from</span> utils.utils <span class="keyword">import</span> MyDataset, validate, show_confMat, Net</span><br><span class="line"><span class="keyword">from</span> tensorboardX <span class="keyword">import</span> SummaryWriter</span><br><span class="line">train_txt_path = os.path.join(<span class="string">&quot;..&quot;</span>, <span class="string">&quot;..&quot;</span>, <span class="string">&quot;Data&quot;</span>, <span class="string">&quot;train.txt&quot;</span>)</span><br><span class="line">valid_txt_path = os.path.join(<span class="string">&quot;..&quot;</span>, <span class="string">&quot;..&quot;</span>, <span class="string">&quot;Data&quot;</span>, <span class="string">&quot;valid.txt&quot;</span>)</span><br><span class="line"></span><br><span class="line">classes_name = [<span class="string">&#x27;plane&#x27;</span>, <span class="string">&#x27;car&#x27;</span>, <span class="string">&#x27;bird&#x27;</span>, <span class="string">&#x27;cat&#x27;</span>, <span class="string">&#x27;deer&#x27;</span>, <span class="string">&#x27;dog&#x27;</span>, <span class="string">&#x27;frog&#x27;</span>, <span class="string">&#x27;horse&#x27;</span>, <span class="string">&#x27;ship&#x27;</span>, <span class="string">&#x27;truck&#x27;</span>]</span><br><span class="line"></span><br><span class="line">train_bs = <span class="number">16</span></span><br><span class="line">valid_bs = <span class="number">16</span></span><br><span class="line">lr_init = <span class="number">0.001</span></span><br><span class="line">max_epoch = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># log</span></span><br><span class="line">log_dir = os.path.join(<span class="string">&quot;..&quot;</span>, <span class="string">&quot;..&quot;</span>, <span class="string">&quot;Result&quot;</span>, <span class="string">&quot;hist_grad_weight&quot;</span>)</span><br><span class="line"></span><br><span class="line">writer = SummaryWriter(log_dir=log_dir)</span><br><span class="line"></span><br><span class="line"><span class="comment"># ------------------------------------ step 1/4 : 加载数据-------------------------------------------------</span></span><br><span class="line"><span class="comment"># 数据预处理设置</span></span><br><span class="line">normMean = [<span class="number">0.4948052</span>, <span class="number">0.48568845</span>, <span class="number">0.44682974</span>]</span><br><span class="line">normStd = [<span class="number">0.24580306</span>, <span class="number">0.24236229</span>, <span class="number">0.2603115</span>]</span><br><span class="line">trainTransform = transforms.Compose([</span><br><span class="line">    transforms.Resize(<span class="number">32</span>),</span><br><span class="line">    transforms.RandomCrop(<span class="number">32</span>, padding=<span class="number">4</span>),</span><br><span class="line">    transforms.ToTensor(),</span><br><span class="line">    transforms.Normalize(normMean, normStd)</span><br><span class="line">])</span><br><span class="line"></span><br><span class="line">validTransform = transforms.Compose([</span><br><span class="line">    transforms.ToTensor(),</span><br><span class="line">    transforms.Normalize(normMean, normStd)</span><br><span class="line">])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 构建MyDataset实例</span></span><br><span class="line">train_data = MyDataset(txt_path=train_txt_path, transform=trainTransform)</span><br><span class="line">valid_data = MyDataset(txt_path=valid_txt_path, transform=validTransform)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 构建DataLoder</span></span><br><span class="line">train_loader = DataLoader(dataset=train_data, batch_size=train_bs, shuffle=<span class="literal">True</span>)</span><br><span class="line">valid_loader = DataLoader(dataset=valid_data, batch_size=valid_bs)</span><br><span class="line"></span><br><span class="line"><span class="comment"># ------------------------------------ step 2/4 : 网络初始化----------------------------------------------</span></span><br><span class="line">net = Net()  <span class="comment"># 创建一个网络</span></span><br><span class="line">net.initialize_weights()  <span class="comment"># 初始化权值</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ------------------------------------ step 3/4 : 定义损失函数和优化器 ------------------------------------</span></span><br><span class="line">criterion = nn.CrossEntropyLoss()  <span class="comment"># 选择损失函数</span></span><br><span class="line">optimizer = optim.SGD(net.parameters(), lr=lr_init, momentum=<span class="number">0.9</span>, dampening=<span class="number">0.1</span>)  <span class="comment"># 选择优化器</span></span><br><span class="line">scheduler = torch.optim.lr_scheduler.StepLR(optimizer, step_size=<span class="number">50</span>, gamma=<span class="number">0.1</span>)  <span class="comment"># 设置学习率下降策略</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ------------------------------------ step 4/4 : 训练 --------------------------------------------------</span></span><br><span class="line"><span class="keyword">for</span> epoch <span class="keyword">in</span> <span class="built_in">range</span>(max_epoch):</span><br><span class="line">    loss_sigma = <span class="number">0.0</span>  <span class="comment"># 记录一个epoch的loss之和</span></span><br><span class="line">    correct = <span class="number">0.0</span></span><br><span class="line">    total = <span class="number">0.0</span></span><br><span class="line">    scheduler.step()  <span class="comment"># 更新学习率</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i, data <span class="keyword">in</span> <span class="built_in">enumerate</span>(train_loader):</span><br><span class="line">        <span class="comment"># 获取图片和标签</span></span><br><span class="line">        inputs, labels = data</span><br><span class="line">        inputs, labels = Variable(inputs), Variable(labels)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># forward, backward, update weights</span></span><br><span class="line">        optimizer.zero_grad()</span><br><span class="line">        outputs = net(inputs)</span><br><span class="line">        loss = criterion(outputs, labels)</span><br><span class="line">        loss.backward()</span><br><span class="line">        optimizer.step()</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 统计预测信息</span></span><br><span class="line">        _, predicted = torch.<span class="built_in">max</span>(outputs.data, <span class="number">1</span>)</span><br><span class="line">        total += labels.size(<span class="number">0</span>)</span><br><span class="line">        correct += (predicted == labels).squeeze().<span class="built_in">sum</span>().numpy()</span><br><span class="line">        loss_sigma += loss.item()</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 每10个iteration 打印一次训练信息，loss为10个iteration的平均</span></span><br><span class="line">        <span class="keyword">if</span> i % <span class="number">10</span> == <span class="number">9</span>:</span><br><span class="line">            loss_avg = loss_sigma / <span class="number">10</span></span><br><span class="line">            loss_sigma = <span class="number">0.0</span></span><br><span class="line">            print(<span class="string">&quot;Training: Epoch[&#123;:0&gt;3&#125;/&#123;:0&gt;3&#125;] Iteration[&#123;:0&gt;3&#125;/&#123;:0&gt;3&#125;] Loss: &#123;:.4f&#125; Acc:&#123;:.2%&#125;&quot;</span>.<span class="built_in">format</span>(</span><br><span class="line">                epoch + <span class="number">1</span>, max_epoch, i + <span class="number">1</span>, <span class="built_in">len</span>(train_loader), loss_avg, correct / total))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 每个epoch，记录梯度，权值</span></span><br><span class="line">    <span class="keyword">for</span> name, layer <span class="keyword">in</span> net.named_parameters():</span><br><span class="line">        writer.add_histogram(name + <span class="string">&#x27;_grad&#x27;</span>, layer.grad.cpu().data.numpy(), epoch)</span><br><span class="line">        writer.add_histogram(name + <span class="string">&#x27;_data&#x27;</span>, layer.cpu().data.numpy(), epoch)</span><br><span class="line"></span><br><span class="line">print(<span class="string">&#x27;Finished Training&#x27;</span>)</span><br></pre></td></tr></table></figure><h5 id="可视化分析"><a href="#可视化分析" class="headerlink" title="可视化分析"></a>可视化分析</h5><h6 id="权值-weights-的监控"><a href="#权值-weights-的监控" class="headerlink" title="权值 weights 的监控"></a>权值 weights 的监控</h6><p>经过 100 个 epoch 的训练，来看看第一个卷积层的权值分布的变化。x 轴即变量大小，y 轴为 gloabl_step。</p><p>图 1 x=0.306， y=0， 数值显示为 0.00，表示第 0 个 epoch 时，权值为 0.306 的个数为 0.00。 </p><img src="/2021/09/PyTorch-Part2/image-20210914221527396.png" alt="image-20210914221527396" style="zoom:67%;"><p>图 2， x=0.306， y=85， 数值显示为 5.71，表示第 85 个 epoch 时，权值在 0.306 区间的有 5.71 个。</p><img src="/2021/09/PyTorch-Part2/image-20210914221609780.png" alt="image-20210914221609780" style="zoom:67%;"><p>通过 HISTOGRAMS 可以看到第一个卷积层的权值随着训练的不断的“扩散”，一开始是个比较标准的高斯分布，并且最大值不会超过 0.3。</p><p>而到了后期，权值会发散到 0.6+，这个问题也是需要关注的，若权值太大容易导致过拟合。因为模型的输出值会被该特征所主导，从而引起过拟合现象，这个可以通过权值衰减(weight_decay)来缓解。</p><h6 id="偏置-bias-的监控"><a href="#偏置-bias-的监控" class="headerlink" title="偏置 bias 的监控"></a>偏置 bias 的监控</h6><p>通常会监控输出层的 bias 的大小，若有特别大，或者特别小的 bias，那么某一类别的召回率可能会很低，可以通过观察输出层的 bias 来诊断是否在这一环节出问题。</p><p>从图上可以看到，一开始 10 个类别的 bias 都比较小，随着训练的进行，每个类别都有了自己的固定的 bias 大小。</p><img src="/2021/09/PyTorch-Part2/image-20210914221837983.png" alt="image-20210914221837983" style="zoom:67%;"><h6 id="梯度的监控"><a href="#梯度的监控" class="headerlink" title="梯度的监控"></a>梯度的监控</h6><p>下图为第一个卷积层权值的梯度变化情况，可以看到，几乎都是服从高斯分布的。倘若前面几层的梯度非常小，那么就是梯度流通不畅导致的，可以考虑残差结构或者辅助损失层等 trick 来解决梯度消失。</p><img src="/2021/09/PyTorch-Part2/image-20210914221932315.png" alt="image-20210914221932315" style="zoom:67%;"><h6 id="文末思考："><a href="#文末思考：" class="headerlink" title="文末思考："></a>文末思考：</h6><ol><li><p>通过观察各层的梯度，权值分布，我们可以针对性的设置学习率，为那些梯度小的层设置更大的学习率，让那些层可以有效的更新。</p></li><li><p>对权值特别大的那些层，可以考虑为那一层设置更大的 weight_decay，是否能有效降低该层权值大小呢。</p></li><li><p>通过对梯度的观察，可以合理的设置梯度 clip 的值。</p></li></ol><h4 id="混淆矩阵及其可视化"><a href="#混淆矩阵及其可视化" class="headerlink" title="混淆矩阵及其可视化"></a>混淆矩阵及其可视化</h4><p>混淆矩阵(Confusion Matrix)常用来观察分类结果，其是一个 N*N 的方阵，N 表示类别数。混淆矩阵的行表示真实类别，列表示预测类别。</p><img src="/2021/09/PyTorch-Part2/image-20210914222323808.png" alt="image-20210914222323808" style="zoom: 67%;"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show_confMat</span>(<span class="params">confusion_mat, classes_name, set_name, out_dir</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    可视化混淆矩阵，保存png格式</span></span><br><span class="line"><span class="string">    :param confusion_mat: nd-array</span></span><br><span class="line"><span class="string">    :param classes_name: list,各类别名称</span></span><br><span class="line"><span class="string">    :param set_name: str, eg: &#x27;valid&#x27;, &#x27;train&#x27;</span></span><br><span class="line"><span class="string">    :param out_dir: str, png输出的文件夹</span></span><br><span class="line"><span class="string">    :return:</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># 归一化</span></span><br><span class="line">    confusion_mat_N = confusion_mat.copy()</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(classes_name)):</span><br><span class="line">        confusion_mat_N[i, :] = confusion_mat[i, :] / confusion_mat[i, :].<span class="built_in">sum</span>()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 获取颜色</span></span><br><span class="line">    cmap = plt.cm.get_cmap(<span class="string">&#x27;Greys&#x27;</span>)  <span class="comment"># 更多颜色: http://matplotlib.org/examples/color/colormaps_reference.html</span></span><br><span class="line">    plt.imshow(confusion_mat_N, cmap=cmap)</span><br><span class="line">    plt.colorbar()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 设置文字</span></span><br><span class="line">    xlocations = np.array(<span class="built_in">range</span>(<span class="built_in">len</span>(classes_name)))</span><br><span class="line">    plt.xticks(xlocations, classes_name, rotation=<span class="number">60</span>)</span><br><span class="line">    plt.yticks(xlocations, classes_name)</span><br><span class="line">    plt.xlabel(<span class="string">&#x27;Predict label&#x27;</span>)</span><br><span class="line">    plt.ylabel(<span class="string">&#x27;True label&#x27;</span>)</span><br><span class="line">    plt.title(<span class="string">&#x27;Confusion_Matrix_&#x27;</span> + set_name)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 打印数字</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(confusion_mat_N.shape[<span class="number">0</span>]):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(confusion_mat_N.shape[<span class="number">1</span>]):</span><br><span class="line">            plt.text(x=j, y=i, s=<span class="built_in">int</span>(confusion_mat[i, j]), va=<span class="string">&#x27;center&#x27;</span>, ha=<span class="string">&#x27;center&#x27;</span>, color=<span class="string">&#x27;red&#x27;</span>, fontsize=<span class="number">10</span>)</span><br><span class="line">    <span class="comment"># 保存</span></span><br><span class="line">    plt.savefig(os.path.join(out_dir, <span class="string">&#x27;Confusion_Matrix_&#x27;</span> + set_name + <span class="string">&#x27;.png&#x27;</span>))</span><br><span class="line">    plt.close()</span><br></pre></td></tr></table></figure><h3 id="wandb-待补充"><a href="#wandb-待补充" class="headerlink" title="wandb(待补充)"></a>wandb(待补充)</h3><blockquote><p>GitHub：<a href="https://github.com/wandb/client">https://github.com/wandb/client</a></p><p>文档：<a href="https://docs.wandb.ai/">https://docs.wandb.ai/</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> PyTorch </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>PyTorch-Part1</title>
      <link href="/2021/09/PyTorch-Part1/"/>
      <url>/2021/09/PyTorch-Part1/</url>
      
        <content type="html"><![CDATA[<h1 id="PyTorch-Part1——基本概念"><a href="#PyTorch-Part1——基本概念" class="headerlink" title="PyTorch-Part1——基本概念"></a>PyTorch-Part1——基本概念</h1><p>[TOC]</p><h2 id="资源汇总（后续放入总结篇）"><a href="#资源汇总（后续放入总结篇）" class="headerlink" title="资源汇总（后续放入总结篇）"></a>资源汇总（后续放入总结篇）</h2><ol><li><a href="https://github.com/zergtant/pytorch-handbook">PyTorch-handbook 中文手册</a>：与 PyTorch 版本保持一致。</li><li><a href="https://github.com/TingsongYu/PyTorch_Tutorial">《Pytorch模型训练实用教程》</a>：PyTorch 模型训练方面的干货教程。特别工业化，真的非常棒。</li><li><a href="https://www.pytorch123.com/">PyTorch官方教程中文版</a>：标准教程，主要是因为有stn。</li><li><a href="https://github.com/chenyuntc/pytorch-book">《深度学习框架PyTorch：入门与实践》</a>：理论和实战，动漫头像生成器。</li><li><a href="https://github.com/bharathgs/Awesome-pytorch-list">Awesome-Pytorch-list</a>：庞大的 PyTorch 资源库。</li><li><a href="https://github.com/pytorch/examples">PyTorch Examples</a>：入门案例，可以在这个基础上增改自己的代码。</li><li><a href="https://discuss.pytorch.org/">PyTorch Forums</a>：PyTorch 官方论坛，可以经常翻阅，减少弯路。</li></ol><ol><li><a href="https://blog.csdn.net/tszupup/article/details/112916388">检查是否可导</a></li><li><a href="https://www.zhihu.com/question/291987781">哪些操作不可微</a></li></ol><p>本篇笔记只记录 PyTorch 常用操作</p><ol><li>按照训练顺序记录各步骤常用方法</li><li>实战干货总结</li><li>不同网络案例代码</li><li>底层剖析与数学原理</li><li>tf1转pytorch</li></ol><h2 id="Pytorch-简介"><a href="#Pytorch-简介" class="headerlink" title="Pytorch 简介"></a>Pytorch 简介</h2><ul><li>Torch 是一个与 Numpy 类似的张量（Tensor）操作库，与 Numpy 不同的是 Torch 对GPU支持的很好，Lua 是 Torch 的上层包装。</li><li>PyTorch 和 Torch 使用包含所有相同性能的C库：TH, THC, THNN, THCUNN，只是使用了不同的上层包装语言。</li><li>PyTorch 框架设计相当简洁优雅且高效快速。</li><li>与 google 的 Tensorflow 类似，FAIR 的支持足以确保 PyTorch 获得持续的开发更新。</li><li>PyTorch 拥有完善的文档，作者亲自维护论坛。</li></ul><h2 id="PyTorch-安装与测试"><a href="#PyTorch-安装与测试" class="headerlink" title="PyTorch 安装与测试"></a>PyTorch 安装与测试</h2><ul><li><p>PyTorch 官网：<a href="https://pytorch.org/">https://pytorch.org/</a></p></li><li><p>CUDA安装：<a href="https://blog.csdn.net/Mind_programmonkey/article/details/99688839/">https://blog.csdn.net/Mind_programmonkey/article/details/99688839/</a></p></li><li><p>测试安装：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line">torch.__version__</span><br><span class="line">torch.cuda.is_available()</span><br></pre></td></tr></table></figure></li><li><p><a href="https://pytorch.org/tutorials/beginner/deep_learning_60min_blitz.html">https://pytorch.org/tutorials/beginner/deep_learning_60min_blitz.html</a>)</p></li></ul><h2 id="张量"><a href="#张量" class="headerlink" title="张量"></a>张量</h2><h3 id="创建张量"><a href="#创建张量" class="headerlink" title="创建张量"></a>创建张量</h3><ul><li>快速测试可以经常使用 <code>torch.rand()</code>。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建未初始化的5行3列的矩阵，注意和 torch.zeros 是不同的</span></span><br><span class="line">x = torch.empty(<span class="number">5</span>, <span class="number">3</span>)</span><br><span class="line"><span class="comment"># 创建一个随机初始化的矩阵</span></span><br><span class="line">x = torch.rand(<span class="number">5</span>, <span class="number">3</span>)</span><br><span class="line"><span class="comment"># 创建一个 0 填充的矩阵，数据类型为 long，long 不允许计算梯度</span></span><br><span class="line">x = torch.zeros(<span class="number">5</span>, <span class="number">3</span>, dtype=torch.long)</span><br><span class="line"><span class="comment"># 创建 tensor 并使用现有数据初始化，只要有一个是 float，则都为 float</span></span><br><span class="line">x = torch.tensor([<span class="number">5.5</span>, <span class="number">3</span>])</span><br><span class="line"><span class="comment"># _like 方法: 根据现有的张量创建相同大小的张量</span></span><br><span class="line">x = torch.randn_like(x, dtype=torch.<span class="built_in">float</span>)</span><br><span class="line">x = torch.ones_like(x).to(torch.<span class="built_in">float</span>)</span><br><span class="line"><span class="comment"># 获取张量大小。size() 和 shape 是等价的。</span></span><br><span class="line">print(x.size())</span><br><span class="line">print(x.shape)</span><br></pre></td></tr></table></figure><ul><li>可以好好体会下面一个例子: <code>batch_size=2 channel=3 size=(h=4, w=5)</code></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span> x = torch.rand((<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>), dtype=torch.<span class="built_in">float</span>, requires_grad=<span class="literal">True</span>)</span><br><span class="line">tensor([[[[<span class="number">0.0628</span>, <span class="number">0.6673</span>, <span class="number">0.3958</span>, <span class="number">0.0904</span>, <span class="number">0.2442</span>],</span><br><span class="line">          [<span class="number">0.4635</span>, <span class="number">0.0213</span>, <span class="number">0.2310</span>, <span class="number">0.1643</span>, <span class="number">0.7705</span>],</span><br><span class="line">          [<span class="number">0.6754</span>, <span class="number">0.9084</span>, <span class="number">0.3516</span>, <span class="number">0.8552</span>, <span class="number">0.5362</span>],</span><br><span class="line">          [<span class="number">0.0650</span>, <span class="number">0.8016</span>, <span class="number">0.1424</span>, <span class="number">0.3343</span>, <span class="number">0.0216</span>]],</span><br><span class="line"></span><br><span class="line">         [[<span class="number">0.2237</span>, <span class="number">0.5758</span>, <span class="number">0.1204</span>, <span class="number">0.8498</span>, <span class="number">0.4453</span>],</span><br><span class="line">          [<span class="number">0.0703</span>, <span class="number">0.1054</span>, <span class="number">0.4191</span>, <span class="number">0.1271</span>, <span class="number">0.9603</span>],</span><br><span class="line">          [<span class="number">0.4301</span>, <span class="number">0.9627</span>, <span class="number">0.9707</span>, <span class="number">0.9125</span>, <span class="number">0.9281</span>],</span><br><span class="line">          [<span class="number">0.4365</span>, <span class="number">0.1514</span>, <span class="number">0.9759</span>, <span class="number">0.4679</span>, <span class="number">0.8695</span>]],</span><br><span class="line"></span><br><span class="line">         [[<span class="number">0.4225</span>, <span class="number">0.5115</span>, <span class="number">0.2755</span>, <span class="number">0.1248</span>, <span class="number">0.8858</span>],</span><br><span class="line">          [<span class="number">0.4288</span>, <span class="number">0.8042</span>, <span class="number">0.2394</span>, <span class="number">0.6829</span>, <span class="number">0.5082</span>],</span><br><span class="line">          [<span class="number">0.7765</span>, <span class="number">0.7435</span>, <span class="number">0.2163</span>, <span class="number">0.9029</span>, <span class="number">0.6852</span>],</span><br><span class="line">          [<span class="number">0.2889</span>, <span class="number">0.3367</span>, <span class="number">0.8794</span>, <span class="number">0.9265</span>, <span class="number">0.6639</span>]]],</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        [[[<span class="number">0.8373</span>, <span class="number">0.0672</span>, <span class="number">0.8151</span>, <span class="number">0.7912</span>, <span class="number">0.2508</span>],</span><br><span class="line">          [<span class="number">0.9232</span>, <span class="number">0.5653</span>, <span class="number">0.1964</span>, <span class="number">0.0986</span>, <span class="number">0.5448</span>],</span><br><span class="line">          [<span class="number">0.8444</span>, <span class="number">0.8974</span>, <span class="number">0.0763</span>, <span class="number">0.9074</span>, <span class="number">0.7959</span>],</span><br><span class="line">          [<span class="number">0.6146</span>, <span class="number">0.1738</span>, <span class="number">0.0814</span>, <span class="number">0.7200</span>, <span class="number">0.0448</span>]],</span><br><span class="line"></span><br><span class="line">         [[<span class="number">0.9523</span>, <span class="number">0.3441</span>, <span class="number">0.1840</span>, <span class="number">0.9286</span>, <span class="number">0.4231</span>],</span><br><span class="line">          [<span class="number">0.9800</span>, <span class="number">0.4126</span>, <span class="number">0.8632</span>, <span class="number">0.8323</span>, <span class="number">0.2245</span>],</span><br><span class="line">          [<span class="number">0.9756</span>, <span class="number">0.5459</span>, <span class="number">0.1382</span>, <span class="number">0.2115</span>, <span class="number">0.0617</span>],</span><br><span class="line">          [<span class="number">0.8045</span>, <span class="number">0.4060</span>, <span class="number">0.6943</span>, <span class="number">0.0992</span>, <span class="number">0.4955</span>]],</span><br><span class="line"></span><br><span class="line">         [[<span class="number">0.0712</span>, <span class="number">0.9649</span>, <span class="number">0.7187</span>, <span class="number">0.5300</span>, <span class="number">0.8720</span>],</span><br><span class="line">          [<span class="number">0.2673</span>, <span class="number">0.9442</span>, <span class="number">0.5604</span>, <span class="number">0.2986</span>, <span class="number">0.2902</span>],</span><br><span class="line">          [<span class="number">0.8061</span>, <span class="number">0.5989</span>, <span class="number">0.4864</span>, <span class="number">0.7042</span>, <span class="number">0.1167</span>],</span><br><span class="line">          [<span class="number">0.6609</span>, <span class="number">0.0652</span>, <span class="number">0.9130</span>, <span class="number">0.8308</span>, <span class="number">0.6552</span>]]]], requires_grad=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure><h3 id="操作张量"><a href="#操作张量" class="headerlink" title="操作张量"></a>操作张量</h3><ul><li>加法</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"></span><br><span class="line">x = torch.ones(<span class="number">5</span>, <span class="number">3</span>)</span><br><span class="line">y = torch.ones(<span class="number">5</span>, <span class="number">3</span>)</span><br><span class="line"><span class="comment"># 1. 直接运算符相加</span></span><br><span class="line">z = x + y</span><br><span class="line"><span class="comment"># 2. .add() 方法</span></span><br><span class="line">z = torch.add(x, y)</span><br><span class="line"><span class="comment"># 3. 替换指定张量</span></span><br><span class="line">z = torch.empty(<span class="number">5</span>, <span class="number">3</span>)</span><br><span class="line">torch.add(x, y, out=z)</span><br><span class="line"><span class="comment"># 4. 将 x 加在y上</span></span><br><span class="line">y.add_(x)</span><br></pre></td></tr></table></figure><blockquote><p>任何 以 <code>_</code> 结尾的操作都会用结果替换原变量。例如：<code>x.copy_(y)</code>、<code>x.t_()</code>，都会改变 <code>x</code>。</p></blockquote><ul><li>使用索引切片操作张量</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">x = torch.ones(<span class="number">5</span>, <span class="number">3</span>)</span><br><span class="line">print(x)</span><br><span class="line">print(x[:, <span class="number">1</span>])</span><br><span class="line">print(x[:, [<span class="number">1</span>]])  <span class="comment"># 依然保持二维</span></span><br></pre></td></tr></table></figure><ul><li><code>torch.view()</code>：改变张量的维度和大小</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">x = torch.rand((<span class="number">4</span>, <span class="number">4</span>), dtype=torch.<span class="built_in">float</span>)</span><br><span class="line">y = x.view(<span class="number">16</span>)</span><br><span class="line">z = x.view(-<span class="number">1</span>, <span class="number">1</span>, <span class="number">8</span>)  <span class="comment"># -1 为自动推断</span></span><br><span class="line">print(x.size(), y.size(), z.size())</span><br></pre></td></tr></table></figure><ul><li><code>.item()</code>：以Python数据类型获取张量中的数值</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">x = torch.randn(<span class="number">1</span>)</span><br><span class="line">print(x)</span><br><span class="line">print(<span class="built_in">type</span>(x.item()))</span><br></pre></td></tr></table></figure><blockquote><p>100+ Tensor operations, including transposing, indexing, slicing, mathematical operations, linear algebra, random numbers, etc., are described here <a href="https://pytorch.org/docs/torch">https://pytorch.org/docs/torch</a>.</p></blockquote><h3 id="NumPy-转换"><a href="#NumPy-转换" class="headerlink" title="NumPy 转换"></a>NumPy 转换</h3><blockquote><p>Torch Tensor与NumPy数组共享底层内存地址，修改任何一个都会导致另一个变化。</p></blockquote><ul><li><code>.numpy()</code>：将一个 Torch Tensor 转换为 NumPy 数组</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">a = torch.ones(<span class="number">5</span>)  <span class="comment"># tensor([1., 1., 1., 1., 1.])</span></span><br><span class="line">b = a.numpy()  <span class="comment"># [1. 1. 1. 1. 1.]</span></span><br><span class="line"><span class="comment"># 共享内存的操作</span></span><br><span class="line">a.add_(<span class="number">1</span>)</span><br><span class="line">print(a)  <span class="comment"># tensor([2., 2., 2., 2., 2.])</span></span><br><span class="line">print(b)  <span class="comment"># [2. 2. 2. 2. 2.]</span></span><br><span class="line"><span class="comment"># 不共享内存的操作</span></span><br><span class="line">a = a + <span class="number">1</span></span><br><span class="line">print(a)  <span class="comment"># tensor([2., 2., 2., 2., 2.])</span></span><br><span class="line">print(b)  <span class="comment"># [1. 1. 1. 1. 1.]</span></span><br></pre></td></tr></table></figure><ul><li><code>torch.from_numpy(a)</code>：NumPy Array 转化成 Torch Tensor</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">a = np.ones(<span class="number">5</span>)</span><br><span class="line">b = torch.from_numpy(a)</span><br><span class="line"><span class="comment"># 共享内存的操作</span></span><br><span class="line">a += <span class="number">1</span></span><br><span class="line">np.add(a, <span class="number">1</span>, out=a)</span><br><span class="line"><span class="comment"># 不共享内存的操作</span></span><br><span class="line">a = a + <span class="number">1</span></span><br><span class="line">a = np.add(a, <span class="number">1</span>)</span><br></pre></td></tr></table></figure><h3 id="CUDA-张量"><a href="#CUDA-张量" class="headerlink" title="CUDA 张量"></a>CUDA 张量</h3><ul><li><code>torch.device(&quot;cuda:0&quot;)</code>：参数可以为 <code>&quot;cuda:0&quot;/&quot;cuda&quot;/&quot;cpu&quot;</code>。</li><li><code>device参数</code>：可传参同上。</li><li><code>.to(device)</code>：可以指定数据类型，也移动到指定设备。<ul><li>同时指定时顺序需要为：<code>.to(device, torch.float)</code></li><li>注意：只调用 <code>.to(&quot;cuda&quot;)</code> 并没有复制张量到 GPU 上，而是返回了一个 copy。所以，需要把它赋值给一个新的张量并在GPU上使用这个张量。</li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">x = torch.randn(<span class="number">3</span>)</span><br><span class="line">device = torch.device(<span class="string">&quot;cuda:0&quot;</span>)        <span class="comment"># 创建 CUDA 设备对象</span></span><br><span class="line">y = torch.ones_like(x, device=device)  <span class="comment"># 直接在 CUDA 中创建张量</span></span><br><span class="line">x = x.to(device)                       <span class="comment"># .to(&quot;cuda&quot;) 将张量移动到 cuda 中</span></span><br><span class="line">z = x + y</span><br><span class="line">print(z)</span><br><span class="line">print(z.to(<span class="string">&quot;cpu&quot;</span>, torch.double))       <span class="comment"># 同时指定设备与类型</span></span><br></pre></td></tr></table></figure><h2 id="自动求导机制-Autograd"><a href="#自动求导机制-Autograd" class="headerlink" title="自动求导机制(Autograd)"></a>自动求导机制(Autograd)</h2><ul><li> <code>torch.autograd</code> 包是 PyTorch 中所有神经网络的核心，它为张量上的所有操作提供了自动求导。</li><li> <code>torch.autograd</code> 是一个在运行时定义的框架，这意味着反向传播是根据你的代码来确定如何运行，并且每次迭代可以是不同的。</li></ul><h3 id="张量（Tensor）"><a href="#张量（Tensor）" class="headerlink" title="张量（Tensor）"></a>张量（Tensor）</h3><ul><li><p><code>torch.Tensor</code> 是这个包的核心类。</p><ul><li>如果设置 <code>.requires_grad=True</code>，那么将会追踪所有对于该张量的操作。当完成计算后通过调用 <code>.backward()</code>，自动计算所有的梯度，这个张量的所有梯度将会积累到 <code>.grad</code> 属性。</li><li>要阻止张量跟踪历史记录，可以调用 <code>.detach()</code> 方法将其与计算历史记录分离，并禁止跟踪它将来的计算记录。</li><li>为了防止跟踪历史记录（和使用内存），可以将代码块包装在<code>with torch.no_grad()：</code>中。在评估模型时特别有用，因为模型可能具有 <code>requires_grad = True</code> 的可训练参数，但是我们不需要梯度计算。</li></ul></li><li><p>在自动梯度计算中还有另外一个重要的类 <code>Function</code>.</p><ul><li><code>Tensor</code> 和 <code>Function</code> 互相连接并生成一个非循环图，它表示和存储了完整的计算历史。每个张量都有一个 <code>.grad_fn</code> 属性，这个属性引用了一个创建了 <code>Tensor</code> 的 <code>Function</code> （除非这个张量是用户手动创建的，即，这个张量的 <code>grad_fn</code> 是 <code>None</code>）。</li><li>如果需要计算导数，你可以在 <code>Tensor</code> 上调用 <code>.backward()</code>。 如果 <code>Tensor</code> 是一个标量（即它包含一个元素数据）则不需要为 <code>backward()</code> 指定任何参数，但是如果它有更多的元素，你需要指定一个<code>gradient</code> 参数来匹配张量的形状。</li></ul></li><li><p>在其他的文章中可能会看到说将 Tensor 包裹到 Variable 中提供自动梯度计算。Variable 在0.41版中已经被标注为过期了，现在可以直接使用 Tensor，官方文档：<a href="https://pytorch.org/docs/stable/autograd.html#variable-deprecated">https://pytorch.org/docs/stable/autograd.html#variable-deprecated</a></p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">x = torch.ones(<span class="number">2</span>, <span class="number">2</span>, requires_grad=<span class="literal">True</span>)</span><br><span class="line">print(x)  <span class="comment"># requires_grad=True</span></span><br><span class="line">y = x + <span class="number">2</span>  <span class="comment"># &lt;AddBackward0 object at 0x0000025D5A03A860&gt;</span></span><br><span class="line">print(y)  <span class="comment"># 进行了一次加运算得出结果 y，因此自动生成了 grad_fn 追踪张量操作，但还没有生成梯度</span></span><br><span class="line"></span><br><span class="line">z = y * y * <span class="number">3</span>  <span class="comment"># grad_fn=&lt;MulBackward0&gt;</span></span><br><span class="line">out = z.mean()  <span class="comment"># grad_fn=&lt;MeanBackward0&gt;</span></span><br></pre></td></tr></table></figure><h3 id="梯度"><a href="#梯度" class="headerlink" title="梯度"></a>梯度</h3><ul><li><img src="/2021/09/PyTorch-Part1/image-20210912171608055.png" alt="image-20210912171608055" style="zoom:150%;"></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 现在让我们来看一个vector-Jacobian product的例子</span></span><br><span class="line">x = torch.randn(<span class="number">3</span>, requires_grad=<span class="literal">True</span>)</span><br><span class="line">y = x * <span class="number">2</span></span><br><span class="line"><span class="keyword">while</span> y.data.norm() &lt; <span class="number">1000</span>:</span><br><span class="line">    y = y * <span class="number">2</span></span><br><span class="line">print(y)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在这个情形中，y不再是个标量。torch.autograd无法直接计算出完整的雅可比行列，但是如果我们只想要vector-Jacobian product，只需将向量作为参数传入backward：</span></span><br><span class="line">gradients = torch.tensor([<span class="number">0.1</span>, <span class="number">1.0</span>, <span class="number">0.0001</span>], dtype=torch.<span class="built_in">float</span>)</span><br><span class="line">y.backward(gradients)</span><br><span class="line">print(x.grad)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果.requires_grad=True但是你又不希望进行autograd的计算， 那么可以将变量包裹在 with torch.no_grad()中:</span></span><br><span class="line">print(x.requires_grad)</span><br><span class="line">print((x ** <span class="number">2</span>).requires_grad)</span><br><span class="line"><span class="keyword">with</span> torch.no_grad():</span><br><span class="line">    print((x ** <span class="number">2</span>).requires_grad)</span><br></pre></td></tr></table></figure><blockquote><p><code>autograd</code> 和 <code>Function</code> 的官方文档 <a href="https://pytorch.org/docs/autograd">https://pytorch.org/docs/autograd</a></p></blockquote><p>model.train():<br>在使用pytorch构建神经网络的时候，训练过程中会在程序上方添加一句model.train()，作用是启用batch normalization和drop out。</p><p>model.eval():<br>测试过程中会使用model.eval()，这时神经网络会沿用batch normalization的值，并不使用drop out。</p>]]></content>
      
      
      <categories>
          
          <category> PyTorch </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Typora-完结目录</title>
      <link href="/2021/09/Typora-%E5%AE%8C%E7%BB%93%E7%9B%AE%E5%BD%95/"/>
      <url>/2021/09/Typora-%E5%AE%8C%E7%BB%93%E7%9B%AE%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<h1 id="Typora——完结目录"><a href="#Typora——完结目录" class="headerlink" title="Typora——完结目录"></a>Typora——完结目录</h1><p>推荐资源：</p><ul><li>Typora 使用手册：<a href="https://support.typora.io/">https://support.typora.io/</a></li></ul><p>写了大半年的Markdown，总结并重新学习。</p><table><thead><tr><th align="center"><strong><a href="/2021/09/Typora-Part1/">Typora-Part1——Markdown、Hexo与Typora</a></strong></th></tr></thead><tbody><tr><td align="center"><strong><a href="/2021/09/Typora-Part2/">Typora-Part2——技术文档写作规范</a></strong></td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> Typora </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MarkDown </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Typora-Part2</title>
      <link href="/2021/09/Typora-Part2/"/>
      <url>/2021/09/Typora-Part2/</url>
      
        <content type="html"><![CDATA[<h1 id="Typora-Part2——技术文档写作规范"><a href="#Typora-Part2——技术文档写作规范" class="headerlink" title="Typora-Part2——技术文档写作规范"></a>Typora-Part2——技术文档写作规范</h1><p>[TOC]</p><blockquote><p>本文来自： <a href="https://github.com/ruanyf">ruanyf</a>/<a href="https://github.com/ruanyf/document-style-guide">document-style-guide</a></p></blockquote><h2 id="1-标题"><a href="#1-标题" class="headerlink" title="1.标题"></a>1.标题</h2><h3 id="1-1层级"><a href="#1-1层级" class="headerlink" title="1.1层级"></a>1.1层级</h3><p>标题分为四级。</p><ul><li>一级标题：文章的标题</li><li>二级标题：文章主要部分的大标题</li><li>三级标题：二级标题下面一级的小标题</li><li>四级标题：三级标题下面某一方面的小标题</li></ul><p>下面是示例。</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 一级标题</span></span><br><span class="line"></span><br><span class="line"><span class="section">## 二级标题</span></span><br><span class="line"></span><br><span class="line"><span class="section">### 三级标题</span></span><br><span class="line"></span><br><span class="line"><span class="section">#### 四级标题</span></span><br></pre></td></tr></table></figure><h3 id="1-2原则"><a href="#1-2原则" class="headerlink" title="1.2原则"></a>1.2原则</h3><p><strong>（1）一级标题下，不能直接出现三级标题。</strong></p><p>示例：下面的文章结构，缺少二级标题。</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 一级标题</span></span><br><span class="line"></span><br><span class="line"><span class="section">### 三级标题</span></span><br></pre></td></tr></table></figure><p><strong>（2）标题要避免孤立编号（即同级标题只有一个）。</strong></p><p>示例：下面的文章结构，<code>二级标题 A</code>只包含一个三级标题，完全可以省略<code>三级标题 A</code>。</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">## 二级标题 A</span></span><br><span class="line"></span><br><span class="line"><span class="section">### 三级标题 A</span></span><br><span class="line"></span><br><span class="line"><span class="section">## 二级标题 B</span></span><br></pre></td></tr></table></figure><p><strong>（3）下级标题不重复上一级标题的名字。</strong></p><p>示例：下面的文章结构，二级标题与下属的三级标题同名，建议避免。</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">## 概述</span></span><br><span class="line"></span><br><span class="line"><span class="section">### 概述</span></span><br></pre></td></tr></table></figure><p><strong>（4）谨慎使用四级标题，尽量避免出现，保持层级的简单，防止出现过于复杂的章节。</strong></p><p>如果三级标题下有并列性的内容，建议只使用项目列表（Item list）。</p><p>示例：下面的结构二要好于结构一。后者适用的场景，主要是较长篇幅的内容。</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">结构一</span><br><span class="line"></span><br><span class="line"><span class="section">### 三级标题</span></span><br><span class="line"></span><br><span class="line"><span class="section">#### 四级标题 A</span></span><br><span class="line"></span><br><span class="line"><span class="section">#### 四级标题 B</span></span><br><span class="line"></span><br><span class="line"><span class="section">#### 四级标题 C</span></span><br><span class="line"></span><br><span class="line">结构二</span><br><span class="line"></span><br><span class="line"><span class="section">### 三级标题</span></span><br><span class="line"></span><br><span class="line"><span class="strong">**（1）A**</span></span><br><span class="line"></span><br><span class="line"><span class="strong">**（2）B**</span></span><br><span class="line"></span><br><span class="line"><span class="strong">**（3）C**</span></span><br></pre></td></tr></table></figure><h2 id="2-文本"><a href="#2-文本" class="headerlink" title="2.文本"></a>2.文本</h2><h3 id="2-1字间距"><a href="#2-1字间距" class="headerlink" title="2.1字间距"></a>2.1字间距</h3><p>全角中文字符与半角英文字符之间，应有一个半角空格。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">错误：本文介绍如何快速启动Windows系统。</span><br><span class="line"></span><br><span class="line">正确：本文介绍如何快速启动 Windows 系统。</span><br></pre></td></tr></table></figure><p>全角中文字符与半角阿拉伯数字之间，有没有半角空格都可，但必须保证风格统一，不能两种风格混杂。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">正确：2011年5月15日，我订购了5台笔记本电脑与10台平板电脑。</span><br><span class="line"></span><br><span class="line">正确：2011 年 5 月 15 日，我订购了 5 台笔记本电脑与 10 台平板电脑。</span><br></pre></td></tr></table></figure><p>半角的百分号，视同阿拉伯数字。</p><p>英文单位若不翻译，单位前的阿拉伯数字与单位间不留空格。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">错误：一部容量为 16 GB 的智能手机</span><br><span class="line"></span><br><span class="line">正确：一部容量为 16GB 的智能手机</span><br></pre></td></tr></table></figure><p>半角英文字符和半角阿拉伯数字，与全角标点符号之间不留空格。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">错误：他的电脑是 MacBook Air 。</span><br><span class="line"></span><br><span class="line">正确：他的电脑是 MacBook Air。</span><br></pre></td></tr></table></figure><h3 id="2-2-句子"><a href="#2-2-句子" class="headerlink" title="2.2 句子"></a>2.2 句子</h3><ul><li>避免使用长句。句子内部不使用逗号时，总长度不应该超过 40 个字；使用逗号时，总长度不应该超过 100 字或者正文的 3 行。</li><li>尽量使用简单句和并列句，避免使用复合句。</li></ul><h3 id="2-3写作风格"><a href="#2-3写作风格" class="headerlink" title="2.3写作风格"></a>2.3写作风格</h3><p><strong>（1）尽量不使用被动语态，改为使用主动语态。</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">错误：假如此软件尚未被安装，</span><br><span class="line"></span><br><span class="line">正确：假如尚未安装这个软件，</span><br></pre></td></tr></table></figure><p><strong>（2）不使用非正式的语言风格。</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">错误：Lady Gaga 的演唱会真是酷毙了，从没看过这么给力的表演！！！</span><br><span class="line"></span><br><span class="line">正确：无法参加本次活动，我深感遗憾。</span><br></pre></td></tr></table></figure><p><strong>（3）不使用冷僻、生造或者文言文的词语，而要使用现代汉语的常用表达方式。</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">错误：这是唯二的快速启动的方法。</span><br><span class="line"></span><br><span class="line">正确：这是仅有的两种快速启动的方法。</span><br></pre></td></tr></table></figure><p><strong>（4）用对“的”、“地”、“得”。</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">她露出了开心的笑容。</span><br><span class="line">（形容词＋的＋名词）</span><br><span class="line"></span><br><span class="line">她开心地笑了。</span><br><span class="line">（副词＋地＋动词）</span><br><span class="line"></span><br><span class="line">她笑得很开心。</span><br><span class="line">（动词＋得＋副词）</span><br></pre></td></tr></table></figure><p><strong>（5）使用代词时（比如“其”、“该”、“此”、“这”等词），必须明确指代的内容，保证只有一个含义。</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">错误：从管理系统可以监视中继系统和受其直接控制的分配系统。</span><br><span class="line"></span><br><span class="line">正确：从管理系统可以监视两个系统：中继系统和受中继系统直接控制的分配系统。</span><br></pre></td></tr></table></figure><p><strong>（6）名词前不要使用过多的形容词。</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">错误：此设备的使用必须在接受过本公司举办的正式的设备培训的技师的指导下进行。</span><br><span class="line"></span><br><span class="line">正确：此设备必须在技师的指导下使用，且指导技师必须接受过由本公司举办的正式设备培训。</span><br></pre></td></tr></table></figure><p><strong>（7）不包含任何标点符号的单个句子，或者以逗号分隔的句子构件，长度尽量保持在 20 个字以内；20～29 个字的句子，可以接受；30～39 个字的句子，语义必须明确，才能接受；多于 40 个字的句子，在任何情况下都不能接受。</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">错误：本产品适用于从由一台服务器进行动作控制的单一节点结构到由多台服务器进行动作控制的并行处理程序结构等多种体系结构。</span><br><span class="line"></span><br><span class="line">正确：本产品适用于多种体系结构。无论是由一台服务器（单一节点结构），还是由多台服务器（并行处理结构）进行动作控制，均可以使用本产品。</span><br></pre></td></tr></table></figure><p><strong>（8）同样一个意思，尽量使用肯定句表达，不使用否定句表达。</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">错误：请确认没有接通装置的电源。</span><br><span class="line"></span><br><span class="line">正确：请确认装置的电源已关闭。</span><br></pre></td></tr></table></figure><p><strong>（9）避免使用双重否定句。</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">错误：没有删除权限的用户，不能删除此文件。</span><br><span class="line"></span><br><span class="line">正确：用户必须拥有删除权限，才能删除此文件。</span><br></pre></td></tr></table></figure><h3 id="2-4英文处理"><a href="#2-4英文处理" class="headerlink" title="2.4英文处理"></a>2.4英文处理</h3><p><strong>（1）英文原文如果使用了复数形式，翻译成中文时，应该将其还原为单数形式。</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">英文：⋯information stored in random access memory (RAMs)⋯</span><br><span class="line"></span><br><span class="line">中文：……存储在随机存取存储器（RAM）里的信息……</span><br></pre></td></tr></table></figure><p><strong>（2）外文缩写可以使用半角圆点(<code>.</code>)表示缩写。</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">U</span><span class="selector-class">.S</span><span class="selector-class">.A</span>.</span><br><span class="line"><span class="selector-tag">Apple</span>, <span class="selector-tag">Inc</span>.</span><br></pre></td></tr></table></figure><p><strong>（3）表示中文时，英文省略号（<code>⋯</code>）应改为中文省略号（<code>……</code>）。</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">英文：5 minutes later⋯</span><br><span class="line"></span><br><span class="line">中文：5 分钟过去了⋯⋯</span><br></pre></td></tr></table></figure><p><strong>（4）英文书名或电影名改用中文表达时，双引号应改为书名号。</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">英文：He published an article entitled <span class="string">&quot;The Future of the Aviation&quot;</span>.</span><br><span class="line"></span><br><span class="line">中文：他发表了一篇名为《航空业的未来》的文章。</span><br></pre></td></tr></table></figure><p><strong>（5）第一次出现英文词汇时，在括号中给出中文标注。此后再次出现时，直接使用英文缩写即可。</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">IOC（International Olympic Committee，国际奥林匹克委员会）。这样定义后，便可以直接使用“IOC”了。</span><br></pre></td></tr></table></figure><p><strong>（6）专有名词中每个词第一个字母均应大写，非专有名词则不需要大写。</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">“American Association of Physicists in Medicine”（美国医学物理学家协会）是专有名词，需要大写。</span><br><span class="line"></span><br><span class="line">“online transaction processing”（在线事务处理）不是专有名词，不应大写。</span><br></pre></td></tr></table></figure><h2 id="3-段落"><a href="#3-段落" class="headerlink" title="3.段落"></a>3.段落</h2><h3 id="3-1原则"><a href="#3-1原则" class="headerlink" title="3.1原则"></a>3.1原则</h3><ul><li>一个段落只能有一个主题，或一个中心句子。</li><li>段落的中心句子放在段首，对全段内容进行概述。后面陈述的句子为核心句服务。</li><li>一个段落的长度不能超过七行，最佳段落长度小于等于四行。</li><li>段落的句子语气要使用陈述和肯定语气，避免使用感叹语气。</li><li>段落之间使用一个空行隔开。</li><li>段落开头不要留出空白字符。</li></ul><h3 id="3-2引用"><a href="#3-2引用" class="headerlink" title="3.2引用"></a>3.2引用</h3><p><strong>（1）引用第三方内容时，应注明出处。</strong></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">One man’s constant <span class="keyword">is</span> another man’s variable. — Alan Perlis</span><br></pre></td></tr></table></figure><p><strong>（2）如果是全篇转载，请在全文开头显著位置注明作者和出处，并链接至原文。</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">本文转载自 WikiQuote</span><br></pre></td></tr></table></figure><p><strong>（3）使用外部图片时，必须在图片下方或文末标明来源。</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">本文部分图片来自 Wikipedia</span><br></pre></td></tr></table></figure><h2 id="4-数值"><a href="#4-数值" class="headerlink" title="4.数值"></a>4.数值</h2><h3 id="4-1半角数字"><a href="#4-1半角数字" class="headerlink" title="4.1半角数字"></a>4.1半角数字</h3><p>数字一律使用半角形式，不得使用全角形式。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">错误： 这件商品的价格是１０００元。</span><br><span class="line"></span><br><span class="line">正确： 这件商品的价格是 1000 元。</span><br></pre></td></tr></table></figure><h3 id="4-2千分号"><a href="#4-2千分号" class="headerlink" title="4.2千分号"></a>4.2千分号</h3><p>数值为千位以上，应添加千分号（半角逗号）。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">XXX 公司的实收资本为 RMB1,258,000。</span><br></pre></td></tr></table></figure><p>对于 4 ～ 6 位的数值，千分号是选用的，比如<code>1000</code>和<code>1,000</code>都可以接受。对于7位及以上的数值，千分号是必须的。</p><p>多位小数要从小数点后从左向右添加千分号，比如<code>4.234,345</code>。</p><h3 id="4-3货币"><a href="#4-3货币" class="headerlink" title="4.3货币"></a>4.3货币</h3><p>货币应为阿拉伯数字，并在数字前写出货币符号，或在数字后写出货币中文名称。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$1</span>,000</span><br><span class="line">1,000 美元</span><br></pre></td></tr></table></figure><h3 id="4-4数值范围"><a href="#4-4数值范围" class="headerlink" title="4.4数值范围"></a>4.4数值范围</h3><p>表示数值范围时，用<code>～</code>连接。参见《标点符号》一节的“连接号”部分。</p><p>带有单位或百分号时，两个数字都要加上单位或百分号，不能只加后面一个。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">错误：132～234kg</span><br><span class="line">正确：132kg～234kg</span><br><span class="line"></span><br><span class="line">错误：67～89%</span><br><span class="line">正确：67%～89%</span><br></pre></td></tr></table></figure><h3 id="4-5变化程度的表示法"><a href="#4-5变化程度的表示法" class="headerlink" title="4.5变化程度的表示法"></a>4.5变化程度的表示法</h3><p>数字的增加要使用“增加了”、“增加到”。“了”表示增量，“到”表示定量。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">增加到过去的两倍</span><br><span class="line">（过去为一，现在为二）</span><br><span class="line"></span><br><span class="line">增加了两倍</span><br><span class="line">（过去为一，现在为三）</span><br></pre></td></tr></table></figure><p>数字的减少要使用“降低了”、“降低到”。“了”表示增量，“到”表示定量。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">降低到百分之八十</span><br><span class="line">（定额是一百，现在是八十）</span><br><span class="line"></span><br><span class="line">降低了百分之八十</span><br><span class="line">（原来是一百，现在是二十）</span><br></pre></td></tr></table></figure><p>不能用“降低N倍”或“减少N倍”的表示法，要用“降低百分之几”或“减少百分之几”。因为减少（或降低）一倍表示数值原来为一百，现在等于零。</p><h2 id="5-标点符号"><a href="#5-标点符号" class="headerlink" title="5.标点符号"></a>5.标点符号</h2><h3 id="5-1原则"><a href="#5-1原则" class="headerlink" title="5.1原则"></a>5.1原则</h3><ul><li>中文语句的标点符号，均应该采取全角符号，这样可以保证视觉的一致。</li><li>如果整句为英文，则该句使用英文/半角标点。</li><li>句号、问号、叹号、逗号、顿号、分号和冒号不得出现在一行之首。</li></ul><h3 id="5-2句号"><a href="#5-2句号" class="headerlink" title="5.2句号"></a>5.2句号</h3><p>中文语句中的结尾处应该用全角句号（<code>。</code>）。</p><p>句子末尾用括号加注时，句号应在括号之外。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">错误：关于文件的输出，请参照第 1.3 节（见第 26 页。）</span><br><span class="line"></span><br><span class="line">正确：关于文件的输出，请参照第 1.3 节（见第 26 页）。</span><br></pre></td></tr></table></figure><h3 id="5-3逗号"><a href="#5-3逗号" class="headerlink" title="5.3逗号"></a>5.3逗号</h3><p>逗号<code>，</code>表示句子内部的一般性停顿。</p><p>注意避免“一逗到底”，即整个段落除了结尾，全部停顿都使用逗号。</p><h3 id="5-4顿号"><a href="#5-4顿号" class="headerlink" title="5.4顿号"></a>5.4顿号</h3><p>句子内部的并列词，应该用全角顿号(<code>、</code>) 分隔，而不用逗号，即使并列词是英语也是如此。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">错误：我最欣赏的科技公司有 Google, Facebook, 腾讯, 阿里和百度等。</span><br><span class="line"></span><br><span class="line">正确：我最欣赏的科技公司有 Google、Facebook、腾讯、阿里和百度等。</span><br></pre></td></tr></table></figure><p>英文句子中，并列词语之间使用半角逗号（<code>,</code>）分隔。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">例句：Microsoft Office includes Word, Excel, PowerPoint, Outlook and other components.</span><br></pre></td></tr></table></figure><h3 id="5-5分号"><a href="#5-5分号" class="headerlink" title="5.5分号"></a>5.5分号</h3><p>分号<code>；</code>表示复句内部并列分句之间的停顿。</p><h3 id="5-6引号"><a href="#5-6引号" class="headerlink" title="5.6引号"></a>5.6引号</h3><p>引用时，应该使用全角双引号（<code>“ ”</code>），注意前后双引号不同。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">例句：许多人都认为客户服务的核心是“友好”和“专业”。</span><br></pre></td></tr></table></figure><p>引号里面还要用引号时，外面一层用双引号，里面一层用单引号（<code>‘ ’</code>），注意前后单引号不同。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">例句：鲍勃解释道：“我要放音乐，可萨利说，‘不行！’。”</span><br></pre></td></tr></table></figure><h3 id="5-7圆括号"><a href="#5-7圆括号" class="headerlink" title="5.7圆括号"></a>5.7圆括号</h3><p>补充说明时，使用全角圆括号<code>（）</code>，括号前后不加空格。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">例句：请确认所有的连接（电缆和接插件）均安装牢固。</span><br></pre></td></tr></table></figure><h3 id="5-8冒号"><a href="#5-8冒号" class="headerlink" title="5.8冒号"></a>5.8冒号</h3><p>全角冒号（<code>：</code>）常用在需要解释的词语后边，引出解释和说明。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">例句：请确认以下几项内容：时间、地点、活动名称，以及来宾数量。</span><br></pre></td></tr></table></figure><p>表示时间时，应使用半角冒号（<code>:</code>）。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">例句：早上 8<span class="selector-pseudo">:00</span></span><br></pre></td></tr></table></figure><h3 id="5-9省略号"><a href="#5-9省略号" class="headerlink" title="5.9省略号"></a>5.9省略号</h3><p>省略号<code>……</code>表示语句未完、或者语气的不连续。它占两个汉字空间、包含六个省略点，不要使用<code>。。。</code>或<code>...</code>等非标准形式。</p><p>省略号不应与“等”这个词一起使用。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">错误：我们为会餐准备了香蕉、苹果、梨…等各色水果。</span><br><span class="line"></span><br><span class="line">正确：我们为会餐准备了各色水果，有香蕉、苹果、梨……</span><br><span class="line"></span><br><span class="line">正确：我们为会餐准备了香蕉、苹果、梨等各色水果。</span><br></pre></td></tr></table></figure><h3 id="5-10感叹号"><a href="#5-10感叹号" class="headerlink" title="5.10感叹号"></a>5.10感叹号</h3><p>应该使用平静的语气叙述，尽量避免使用感叹号<code>！</code>。</p><p>不得多个感叹号连用，比如<code>！！</code>和<code>!!!</code>。</p><h3 id="5-11破折号"><a href="#5-11破折号" class="headerlink" title="5.11破折号"></a>5.11破折号</h3><p>破折号<code>————</code>一般用于进一步解释。</p><p>破折号应占两个汉字的位置。如果破折号本身只占一个汉字的位置，那么前后应该留出一个半角空格。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">例句：直觉————尽管它并不总是可靠的————告诉我，这事可能出了些问题。</span><br><span class="line"></span><br><span class="line">例句：直觉 —— 尽管它并不总是可靠的 —— 告诉我，这事可能出了些问题。</span><br></pre></td></tr></table></figure><h3 id="5-12连接号"><a href="#5-12连接号" class="headerlink" title="5.12连接号"></a>5.12连接号</h3><p>连接号用于连接两个类似的词。</p><p>以下场合应该使用直线连接号（<code>-</code>），占一个半角字符的位置。</p><ul><li>两个名词的复合</li><li>图表编号</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">例句：氧化-还原反应</span><br><span class="line"></span><br><span class="line">例句：图 1-1</span><br></pre></td></tr></table></figure><p>以下场合应该使用波浪连接号（<code>～</code>），占一个全角字符的位置。</p><ul><li>数值范围（例如日期、时间或数字）</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">例句：2009 年～2011 年</span><br></pre></td></tr></table></figure><p>注意，波浪连接号前后两个值都应该加上单位。</p><p>波浪连接号也可以用汉字“至”代替。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">例句：周围温度：-20°C 至 -10°C</span><br></pre></td></tr></table></figure><h2 id="6-文档体系"><a href="#6-文档体系" class="headerlink" title="6.文档体系"></a>6.文档体系</h2><h3 id="6-1结构"><a href="#6-1结构" class="headerlink" title="6.1结构"></a>6.1结构</h3><p>软件手册是一部完整的书，建议采用下面的结构。</p><ul><li><p><strong>简介</strong>（Introduction）： [必备] [文件] 提供对产品和文档本身的总体的、扼要的说明</p></li><li><p><strong>快速上手</strong>（Getting Started）：[可选] [文件] 如何最快速地使用产品</p></li><li><p>入门篇</p><p>（Basics）： [必备] [目录] 又称”使用篇“，提供初级的使用教程</p><ul><li><strong>环境准备</strong>（Prerequisite）：[必备] [文件] 软件使用需要满足的前置条件</li><li><strong>安装</strong>（Installation）：[可选] [文件] 软件的安装方法</li><li><strong>设置</strong>（Configuration）：[必备] [文件] 软件的设置</li></ul></li><li><p><strong>进阶篇</strong>（Advanced)：[可选] [目录] 又称”开发篇“，提供中高级的开发教程</p></li><li><p><strong>API</strong>（Reference）：[可选] [目录|文件] 软件 API 的逐一介绍</p></li><li><p><strong>FAQ</strong>：[可选] [文件] 常见问题解答</p></li><li><p>附录</p><p>（Appendix）：[可选] [目录] 不属于教程本身、但对阅读教程有帮助的内容</p><ul><li><strong>Glossary</strong>：[可选] [文件] 名词解释</li><li><strong>Recipes</strong>：[可选] [文件] 最佳实践</li><li><strong>Troubleshooting</strong>：[可选] [文件] 故障处理</li><li><strong>ChangeLog</strong>：[可选] [文件] 版本说明</li><li><strong>Feedback</strong>：[可选] [文件] 反馈方式</li></ul></li></ul><p>下面是两个真实范例，可参考。</p><ul><li><a href="http://redux.js.org/index.html">Redux 手册</a></li><li><a href="http://flight-manual.atom.io/">Atom 手册</a></li></ul><h3 id="6-2文件名"><a href="#6-2文件名" class="headerlink" title="6.2文件名"></a>6.2文件名</h3><p>文档的文件名不得含有空格。</p><p>文件名必须使用半角字符，不得使用全角字符。这也意味着，中文不能用于文件名。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">错误： 名词解释<span class="selector-class">.md</span></span><br><span class="line"></span><br><span class="line">正确： <span class="selector-tag">glossary</span><span class="selector-class">.md</span></span><br></pre></td></tr></table></figure><p>文件名建议只使用小写字母，不使用大写字母。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">错误：<span class="selector-tag">TroubleShooting</span><span class="selector-class">.md</span></span><br><span class="line"></span><br><span class="line">正确：<span class="selector-tag">troubleshooting</span><span class="selector-class">.md</span> </span><br></pre></td></tr></table></figure><p>为了醒目，某些说明文件的文件名，可以使用大写字母，比如<code>README</code>、<code>LICENSE</code>。</p><p>文件名包含多个单词时，单词之间建议使用半角的连词线（<code>-</code>）分隔。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">不佳：<span class="selector-tag">advanced_usage</span><span class="selector-class">.md</span></span><br><span class="line"></span><br><span class="line">正确：<span class="selector-tag">advanced-usage</span><span class="selector-class">.md</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Typora </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Typora-Part1</title>
      <link href="/2021/09/Typora-Part1/"/>
      <url>/2021/09/Typora-Part1/</url>
      
        <content type="html"><![CDATA[<h1 id="Typora-Part1——Markdown、Hexo与Typora"><a href="#Typora-Part1——Markdown、Hexo与Typora" class="headerlink" title="Typora-Part1——Markdown、Hexo与Typora"></a>Typora-Part1——Markdown、Hexo与Typora</h1><p>[TOC]</p><h2 id="Markdown"><a href="#Markdown" class="headerlink" title="Markdown"></a>Markdown</h2><ul><li>Markdown 是一种轻量级标记语言，通过简单的标记语法，使普通文本内容具有一定的格式。</li><li>Markdown 编写的文档可以导出 HTML 、Word、图像、PDF、Epub 等多种格式的文件。</li><li>Markdown 编写的文档后缀为 .md、.markdown。</li><li>Markdown 具有一系列衍生版本，用于扩展 Markdown 的功能（如表格、脚注、内嵌HTML等）。这些功能原初的Markdown尚不具备，它们能让Markdown转换成更多的格式，例如LaTeX，Docbook。</li><li>Markdown 增强版中比较有名的有 Markdown Extra、MultiMarkdown、Maruku 等。这些衍生版本要么基于工具，如Pandoc；要么基于网站，如 GitHub 和 Wikipedia，在语法上基本兼容，但在一些语法和渲染效果上有改动。</li></ul><h2 id="Hexo"><a href="#Hexo" class="headerlink" title="Hexo"></a>Hexo</h2><ul><li>Hexo 是一款快速、简洁且高效的博客框架。</li><li>Hexo 支持 GitHub Flavored Markdown 的所有功能，可以快速生成模板文档，编辑完成后可以快速部署到 GitHub Pages 等平台。</li><li>Typora 支持在文档头部加上基于 YAML 的 front-matter 信息，这一特性适用于把 Markdown 文档分类归档上传到用 Hexo 框架搭建的博客中。</li><li>Hexo 和 Typora 两者可以高效结合，非常好用。</li></ul><h2 id="Typora"><a href="#Typora" class="headerlink" title="Typora"></a>Typora</h2><blockquote><p>Typora 官网：<a href="https://typora.io/">https://typora.io/</a> </p></blockquote><ul><li>Typora 是一款 Markdown 编辑器，支持 MacOS 、Windows、Linux 平台。<ul><li>包含多种主题，并且可以自己通过css样式定义风格。</li><li>编辑文本的同时直接渲染出效果——所见即所得。</li><li>支持导出HTML、PDF、Word、图片等多种类型文件。</li></ul></li></ul><h2 id="在-Typora-中编辑-Markdown-文本"><a href="#在-Typora-中编辑-Markdown-文本" class="headerlink" title="在 Typora 中编辑 Markdown 文本"></a>在 Typora 中编辑 Markdown 文本</h2><blockquote><p>可以使用反斜杠 <code>\</code> 来防止转义。</p></blockquote><h3 id="基本功能"><a href="#基本功能" class="headerlink" title="基本功能"></a>基本功能</h3><h4 id="标题段落"><a href="#标题段落" class="headerlink" title="标题段落"></a>标题段落</h4><ul><li><p>段落只是一行或多行连续的文本。在markdown源代码中，段落由两个或多个空行分隔。在Typora中，只需要一个空行（按Enter一次）即可创建一个新段落。</p></li><li><p>按Shift+Enter可创建单个换行符。大多数其他 markdown 解析器将忽略单换行符，因此为了使其他降价解析器识别换行符，可以在行的末尾留下两个空格，或者插入<code>&lt;br/&gt;</code>。</p></li></ul><table><thead><tr><th>功能</th><th>快捷键</th><th>Markdown</th><th>HTML</th></tr></thead><tbody><tr><td>段落</td><td>Ctrl+0</td><td></td><td>&lt;p&gt; &lt;/p&gt;</td></tr><tr><td>n级标题</td><td>Ctrl+n</td><td>#*n + space*2</td><td>&lt;h1&gt; &lt;/h1&gt;</td></tr><tr><td>提升标题级别</td><td>Ctrl+‘+’</td><td></td><td></td></tr><tr><td>降低标题级别</td><td>Ctrl+‘-’</td><td></td><td></td></tr></tbody></table><h4 id="字体操作"><a href="#字体操作" class="headerlink" title="字体操作"></a>字体操作</h4><table><thead><tr><th>功能</th><th>快捷键</th><th>Markdown</th><th>HTML</th><th>备注</th></tr></thead><tbody><tr><td>加粗</td><td>Ctrl+B</td><td>**加粗** 或 __加粗__</td><td>&lt;B&gt;加粗&lt;/B&gt;</td><td></td></tr><tr><td>下划线</td><td>Ctrl+U</td><td></td><td>&lt;u&gt;下划线&lt;/u&gt;</td><td></td></tr><tr><td>倾斜</td><td>Ctrl+I</td><td>*倾斜* 或 _倾斜_</td><td>&lt;I&gt;倾斜&lt;/I&gt;</td><td></td></tr><tr><td>删除线</td><td>Alt+Shift+5</td><td>~~删除线~~</td><td></td><td></td></tr><tr><td>清除样式</td><td>Ctrl+\</td><td></td><td></td><td>这个好用，清干净</td></tr><tr><td>下标</td><td></td><td>H~2~O</td><td>&lt;sub&gt;下标&lt;/sub&gt;</td><td>需要在设置中启动</td></tr><tr><td>上标</td><td></td><td>2^10^</td><td>&lt;sup&gt;上标&lt;/sup&gt;</td><td>需要在设置中启动</td></tr><tr><td>高亮</td><td></td><td>==高亮==</td><td></td><td>需要在设置中启动</td></tr></tbody></table><h4 id="插入功能"><a href="#插入功能" class="headerlink" title="插入功能"></a>插入功能</h4><h5 id="插入快捷键"><a href="#插入快捷键" class="headerlink" title="插入快捷键"></a>插入快捷键</h5><table><thead><tr><th>功能</th><th>快捷键</th><th>Markdown</th><th>HTML</th><th>备注</th></tr></thead><tbody><tr><td>插入图片</td><td>Ctrl+Shift+I</td><td>![alt 属性文本](图片地址 “可选标题”)</td><td>&lt;img src=””/&gt;</td><td>建议直接复制粘贴图片。</td></tr><tr><td>插入表格</td><td>Ctrl+T</td><td></td><td></td><td></td></tr><tr><td>插入有序列表</td><td>Ctrl+Shift+[</td><td>num+ . +space</td><td>&lt;ol&gt;&lt;li&gt;*n&lt;/ol&gt;</td><td></td></tr><tr><td>插入无序列表</td><td>Ctrl+Shift+]</td><td>‘-/+/*’+space</td><td>&lt;ul&gt;&lt;li&gt;*n&lt;/ul&gt;</td><td>选定行按TAB以嵌套</td></tr><tr><td>插入超链接</td><td>Ctrl+K</td><td>[链接名称](链接地址) 或 &lt;链接地址&gt;</td><td>&lt;a href=””&gt; &lt;/a&gt;</td><td></td></tr><tr><td>插入代码片</td><td>Ctrl+Shift+`</td><td>``</td><td></td><td>开启匹配Markdown字符</td></tr><tr><td>插入代码块</td><td>Ctrl+Shift+K</td><td>```+lang</td><td></td><td></td></tr><tr><td>插入公式块</td><td>Ctrl+Shift+M</td><td>$$</td><td></td><td></td></tr><tr><td>插入引用块</td><td>Ctrl+Shift+Q</td><td>&gt;+space</td><td></td><td>可以嵌套</td></tr><tr><td>插入目录</td><td></td><td>[TOC]+enter</td><td></td><td></td></tr><tr><td>插入注释</td><td></td><td></td><td>&lt;!– comments –&gt;</td><td>html注释</td></tr><tr><td>插入分割线</td><td></td><td>— 或 ***</td><td></td><td></td></tr><tr><td>任务列表</td><td></td><td>-space[space]space</td><td></td><td>[]里换成x就是打上勾</td></tr></tbody></table><h5 id="插入图片说明"><a href="#插入图片说明" class="headerlink" title="插入图片说明"></a>插入图片说明</h5><ul><li><p>只有html标签可以指定图片属性。</p></li><li><p>建议将图片保存至当前目录的同名文件夹下，这样结构清晰。</p><p><img src="/2021/09/Typora-Part1/image-20210901220801184.png" alt="image-20210901220801184"></p></li></ul><h5 id="链接详解"><a href="#链接详解" class="headerlink" title="链接详解"></a>链接详解</h5><ul><li>Ctrl + 左键，跳转指定url</li></ul><ol><li>内联链接：<ul><li>[浅幽丶奈芙莲](<a href="http://nephrencake.gitee.io/">http://nephrencake.gitee.io/</a>)</li></ul></li><li>引用链接：<ul><li>[浅幽丶奈芙莲][变量名]</li><li>[变量名]: <a href="http://nephrencake.gitee.io/">http://nephrencake.gitee.io/</a></li></ul></li><li>直接使用地址：<ul><li>&lt;<a href="http://nephrencake.gitee.io/&gt;">http://nephrencake.gitee.io/&gt;</a></li></ul></li></ol><ul><li><p>HTML页内跳转：</p><p name="top">这里是页头</p><p><a href="#top">回页头</a></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">name</span>=<span class="string">&quot;top&quot;</span>&gt;</span>这里是页头<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#top&quot;</span>&gt;</span>回页头<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><h5 id="脚注详解"><a href="#脚注详解" class="headerlink" title="脚注详解"></a>脚注详解</h5></li><li><p>脚注语法：</p><ul><li>文本[^说明文字]</li><li>[^说明文字]: 解释说明</li></ul></li><li><p>示例：使用 Markdown<a href="Markdown%E6%98%AF%E4%B8%80%E7%A7%8D%E7%BA%AF%E6%96%87%E6%9C%AC%E6%A0%87%E8%AE%B0%E8%AF%AD%E8%A8%80">^1</a>可以效率的书写文档, 直接转换成 HTML[^2], 你可以使用 Typora[^T] 编辑器进行书写。</p></li></ul><p>[^2]:HyperText Markup Language 超文本标记语言<br>[^T]:NEW WAY TO READ &amp; WRITE MARKDOWN.扩展操作</p><h3 id="扩展操作"><a href="#扩展操作" class="headerlink" title="扩展操作"></a>扩展操作</h3><h4 id="表格扩展"><a href="#表格扩展" class="headerlink" title="表格扩展"></a>表格扩展</h4><h5 id="表格快捷键"><a href="#表格快捷键" class="headerlink" title="表格快捷键"></a>表格快捷键</h5><ul><li>在表格中，可以使用鼠标拖动行或者列，达到交换行和列。</li></ul><table><thead><tr><th>功能</th><th>快捷键</th><th>备注</th></tr></thead><tbody><tr><td>下方插入行</td><td>Ctrl+Enter</td><td></td></tr><tr><td>上移该行</td><td>Alt+↑</td><td></td></tr><tr><td>下移该行</td><td>Alt+↓</td><td></td></tr><tr><td>左移该列</td><td>Win+←</td><td>左右移动表格列的快捷键与WinDows系统自带的快捷键冲突</td></tr><tr><td>右移该列</td><td>Win+→</td><td></td></tr><tr><td>删除该行</td><td>Ctrl+Shift+BackSpace</td><td></td></tr></tbody></table><h5 id="表格详解"><a href="#表格详解" class="headerlink" title="表格详解"></a>表格详解</h5><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"># 1. 表格的Markdown语法</span><br><span class="line">| 表头   | 表头   | 表头   |</span><br><span class="line">| ------ | ------ | ------ |</span><br><span class="line">| 单元格 | 单元格 | 单元格 |</span><br><span class="line">| 单元格 | 单元格 | 单元格 |</span><br><span class="line">    </span><br><span class="line"># 2. 可以设置表格的对齐方式：</span><br><span class="line"># - -: 设置内容和标题栏居右对齐。</span><br><span class="line"># - :- 设置内容和标题栏居左对齐。</span><br><span class="line"># - :-: 设置内容和标题栏居中对齐。</span><br><span class="line">| 左对齐 | 右对齐 | 居中对齐 |</span><br><span class="line">| :----- | -----: | :------: |</span><br><span class="line">| 单元格 | 单元格 |  单元格  |</span><br><span class="line">| 单元格 | 单元格 |  单元格  |</span><br><span class="line">    </span><br><span class="line"># HTML语法</span><br><span class="line"><span class="tag">&lt;<span class="name">table</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">caption</span>&gt;</span>标题内容<span class="tag">&lt;/<span class="name">caption</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span>表格内容<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span>表格内容<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span>表格内容<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span>表格内容<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="视图操作"><a href="#视图操作" class="headerlink" title="视图操作"></a>视图操作</h4><h5 id="侧边栏"><a href="#侧边栏" class="headerlink" title="侧边栏"></a>侧边栏</h5><table><thead><tr><th>功能</th><th>快捷键</th></tr></thead><tbody><tr><td>大纲视图</td><td>Ctrl+Shift+1</td></tr><tr><td>文件列表视图</td><td>Ctrl+Shift+2</td></tr><tr><td>文件树视图</td><td>Ctrl+Shift+3</td></tr><tr><td>显示/隐藏侧边栏</td><td>Ctrl+Shift+L</td></tr><tr><td>放大视图</td><td>Ctrl+Shift+‘+’</td></tr><tr><td>缩小视图</td><td>Ctrl+Shift+‘-’</td></tr><tr><td>恢复原来大小视图</td><td>Ctrl+Shift+9</td></tr></tbody></table><h5 id="编辑模式"><a href="#编辑模式" class="headerlink" title="编辑模式"></a>编辑模式</h5><table><thead><tr><th>功能</th><th>快捷键</th><th>备注</th></tr></thead><tbody><tr><td>源代码模式</td><td>Ctrl+/</td><td></td></tr><tr><td>专注模式</td><td>F8</td><td>当前编辑行为黑，其他行为灰色</td></tr><tr><td>打字机模式</td><td>F9</td><td>光标始终在屏幕中央位置</td></tr></tbody></table><h5 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h5><table><thead><tr><th>功能</th><th>快捷键</th></tr></thead><tbody><tr><td>全屏</td><td>F11</td></tr><tr><td>应用内窗口切换</td><td>Ctrl+Tab</td></tr><tr><td>开发者工具</td><td>Shift+F12</td></tr></tbody></table><h4 id="搜索扩展"><a href="#搜索扩展" class="headerlink" title="搜索扩展"></a>搜索扩展</h4><table><thead><tr><th>功能</th><th>快捷键</th></tr></thead><tbody><tr><td>查找/搜索</td><td>Ctrl+F</td></tr><tr><td>替换</td><td>Ctrl+H</td></tr><tr><td>查找下一个</td><td>F3</td></tr><tr><td>查找上一个</td><td>Shift+F3</td></tr></tbody></table><h3 id="编辑操作"><a href="#编辑操作" class="headerlink" title="编辑操作"></a>编辑操作</h3><h4 id="选择操作"><a href="#选择操作" class="headerlink" title="选择操作"></a>选择操作</h4><table><thead><tr><th>功能</th><th>快捷键</th></tr></thead><tbody><tr><td>全选</td><td>Ctrl+A</td></tr><tr><td>选择当前行/句</td><td>Ctrl+L</td></tr><tr><td>选择相同格式文字</td><td>Ctrl+E</td></tr><tr><td>选择当前单词</td><td>Ctrl+D</td></tr><tr><td>删除当前单词</td><td>Ctrl+Shift+D</td></tr></tbody></table><h4 id="跳转操作"><a href="#跳转操作" class="headerlink" title="跳转操作"></a>跳转操作</h4><table><thead><tr><th>功能</th><th>快捷键</th></tr></thead><tbody><tr><td>跳转到文首</td><td>Ctrl+Home</td></tr><tr><td>跳转到所选内容</td><td>Ctrl+J</td></tr><tr><td>跳转到文末</td><td>Ctrl+End</td></tr></tbody></table><h4 id="粘贴复制操作"><a href="#粘贴复制操作" class="headerlink" title="粘贴复制操作"></a>粘贴复制操作</h4><table><thead><tr><th>功能</th><th>快捷键</th></tr></thead><tbody><tr><td>普通复制</td><td>Ctrl+C</td></tr><tr><td>普通粘贴</td><td>Ctrl+V</td></tr><tr><td>剪切</td><td>Ctrl+X</td></tr><tr><td>复制为MarkDown标记语法</td><td>Ctrl+Shift+C</td></tr><tr><td>粘贴为纯文本</td><td>Ctrl+Shift+V</td></tr></tbody></table><h4 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h4><table><thead><tr><th>功能</th><th>快捷键</th><th>备注</th></tr></thead><tbody><tr><td>新建</td><td>Ctrl+N</td><td></td></tr><tr><td>新建窗口</td><td>Ctrl+Shift+N</td><td>在Windows中，这两个作用一样</td></tr><tr><td>打开文件</td><td>Ctrl+O</td><td></td></tr><tr><td>快速打开</td><td>Ctrl+P</td><td>在最近打开中打开</td></tr><tr><td>保存</td><td>Ctrl+S</td><td></td></tr><tr><td>另存为</td><td>Ctrl+Shift+S</td><td></td></tr><tr><td>偏好设置</td><td>Ctrl+，</td><td>似乎跟搜狗快捷键冲突</td></tr><tr><td>关闭</td><td>Ctrl+W</td><td></td></tr><tr><td>重新打开关闭的文件</td><td>Ctrl+Shift+T</td><td></td></tr><tr><td>文件目录查找</td><td>Ctrl+Shift+F</td><td></td></tr></tbody></table><h3 id="Typora快键键修改"><a href="#Typora快键键修改" class="headerlink" title="Typora快键键修改"></a>Typora快键键修改</h3><ol><li>在Typora菜单栏中，文件–&gt;偏好设置–&gt;打开高级设置</li><li>在打开的文件夹中找到conf.user.json文件</li><li>修改KeyBeing中的键值对，重新设置快捷键</li><li>重启Typora软件即可生效</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;keyBinding&quot;</span>: &#123;</span><br><span class="line">    <span class="comment">// for example:</span></span><br><span class="line">    <span class="comment">// &quot;Always on Top&quot;: &quot;Ctrl+Shift+P&quot;</span></span><br><span class="line">    <span class="string">&quot;Always on Top&quot;</span>: <span class="string">&quot;Ctrl+Shift+P&quot;</span>,</span><br><span class="line">    <span class="string">&quot;Code Fences&quot;</span>: <span class="string">&quot;Ctrl+Shift+F&quot;</span>,</span><br><span class="line">    <span class="string">&quot;Ordered List&quot;</span>: <span class="string">&quot;Ctrl+Alt+o&quot;</span>,</span><br><span class="line">    <span class="string">&quot;Unordered List&quot;</span>: <span class="string">&quot;Ctrl+Alt+u&quot;</span></span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><h3 id="数学公式"><a href="#数学公式" class="headerlink" title="数学公式"></a>数学公式</h3><blockquote><p>LaTeX 语法移步：<a href="https://blog.csdn.net/happyday_d/article/details/83715440">https://blog.csdn.net/happyday_d/article/details/83715440</a></p></blockquote><ul><li>可以通过使用 MathJax 来实现 LaTeX 的数学符号的表达。</li><li>在Markdown语法中，数学的公式块是通过利用 <code>$...$</code> 以及 <code>$$...$$</code> 标记借用 LaTeX 语言来实现的：</li></ul><p>$$<br>\mathbf{V}_1 \times \mathbf{V}_2 =  \begin{vmatrix}<br>\mathbf{i} &amp; \mathbf{j} &amp; \mathbf{k} \<br>\frac{\partial X}{\partial u} &amp;  \frac{\partial Y}{\partial u} &amp; 0 \<br>\frac{\partial X}{\partial v} &amp;  \frac{\partial Y}{\partial v} &amp; 0 \<br>\end{vmatrix}<br>$$</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$$</span><br><span class="line">\mathbf&#123;V&#125;<span class="emphasis">_1 \times \mathbf&#123;V&#125;_</span>2 =  \begin&#123;vmatrix&#125; </span><br><span class="line">\mathbf&#123;i&#125; &amp; \mathbf&#123;j&#125; &amp; \mathbf&#123;k&#125; \\</span><br><span class="line">\frac&#123;\partial X&#125;&#123;\partial u&#125; &amp;  \frac&#123;\partial Y&#125;&#123;\partial u&#125; &amp; 0 \\</span><br><span class="line">\frac&#123;\partial X&#125;&#123;\partial v&#125; &amp;  \frac&#123;\partial Y&#125;&#123;\partial v&#125; &amp; 0 \\</span><br><span class="line">\end&#123;vmatrix&#125;</span><br><span class="line">$$</span><br></pre></td></tr></table></figure><h3 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h3><blockquote><p>炫酷画图方法：<a href="https://support.typora.io/Draw-Diagrams-With-Markdown/">https://support.typora.io/Draw-Diagrams-With-Markdown/</a></p></blockquote><ul><li>我选择直接扔图片。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">st&#x3D;&gt;start: Start</span><br><span class="line">op&#x3D;&gt;operation: Your Operation</span><br><span class="line">cond&#x3D;&gt;condition: Yes or No?</span><br><span class="line">e&#x3D;&gt;end</span><br><span class="line"></span><br><span class="line">st-&gt;op-&gt;cond</span><br><span class="line">cond(yes)-&gt;e</span><br><span class="line">cond(no)-&gt;op</span><br></pre></td></tr></table></figure><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="code">```flow</span></span><br><span class="line"><span class="code">st=&gt;start: Start</span></span><br><span class="line"><span class="code">op=&gt;operation: Your Operation</span></span><br><span class="line"><span class="code">cond=&gt;condition: Yes or No?</span></span><br><span class="line"><span class="code">e=&gt;end</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="code">st-&gt;op-&gt;cond</span></span><br><span class="line"><span class="code">cond(yes)-&gt;e</span></span><br><span class="line"><span class="code">cond(no)-&gt;op</span></span><br><span class="line"><span class="code">```</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Typora </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>OpenCV-Part5</title>
      <link href="/2021/09/OpenCV-Part5/"/>
      <url>/2021/09/OpenCV-Part5/</url>
      
        <content type="html"><![CDATA[<h1 id="OpenCV-Part5——综合运用"><a href="#OpenCV-Part5——综合运用" class="headerlink" title="OpenCV-Part5——综合运用"></a>OpenCV-Part5——综合运用</h1><p>[TOC]</p><p>注：本篇仅为记录本人使用过的比较实战高阶的OpenCV算法流程。</p><h2 id="K-Means聚类"><a href="#K-Means聚类" class="headerlink" title="K-Means聚类"></a>K-Means聚类</h2><ul><li>从分布的角度重新构造图像色彩度，减少图像中颜色数量。</li><li><code>cv2.kmeans(data, K, bestLabels, criteria, attempts, flags)</code>：<ul><li>data：np.float32数据类型，每个功能应该放在一个列中</li><li>K：集群数(nclusters)</li><li>bestLabels：预设的分类标签，没有则设为None</li><li>criteria：迭代终止标准。满足此条件时，算法迭代停止。它由3个参数的元组组成：<code>（type，max_iter，epsilon）</code>。<ul><li>type：<ul><li><code>cv2.TERM_CRITERIA_EPS</code>：如果达到指定的精度epsilon，则停止算法迭代。</li><li><code>cv2.TERM_CRITERIA_MAX_ITER</code>：在指定的迭代次数max_iter之后停止算法。</li><li><code>cv2.TERM_CRITERIA_EPS + cv2.TERM_CRITERIA_MAX_ITER</code>：当满足上述任何条件时停止迭代。</li></ul></li><li>max_iter：指定最大迭代次数的整数</li><li>epsilon：要求的准确性</li></ul></li><li>attempts：重复试验kmeans算法次数，将会返回最好的一次结果。</li><li>flags：该标志用于指定初始中心的采用方式。通常会使用两个标志：<code>cv2.KMEANS_PP_CENTERS</code>和<code>cv2.KMEANS_RANDOM_CENTERS</code>。</li><li>返回三个数据：<ul><li>retval：从每个点到它们相应中心的平方距离之和。</li><li>bestLabels：标签数组。是不固定的。</li><li>centers：一组聚类中心。即标签对应的值。</li></ul></li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"></span><br><span class="line">img = cv2.imread(<span class="string">&#x27;test.jpg&#x27;</span>)</span><br><span class="line">Z = img.reshape((-<span class="number">1</span>, <span class="number">3</span>))  <span class="comment"># 把所有像素拉成一条直线</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 1. convert to np.float32</span></span><br><span class="line">Z = np.float32(Z)  <span class="comment"># uint8 -&gt; float32</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. define criteria, number of clusters(K) and apply kmeans()</span></span><br><span class="line">criteria = (cv2.TERM_CRITERIA_EPS + cv2.TERM_CRITERIA_MAX_ITER, <span class="number">10</span>, <span class="number">1.0</span>)</span><br><span class="line">K = <span class="number">3</span></span><br><span class="line">ret, label, center = cv2.kmeans(Z, K, <span class="literal">None</span>, criteria, <span class="number">10</span>, cv2.KMEANS_RANDOM_CENTERS)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. Now convert back into uint8, and make original image</span></span><br><span class="line">center = np.uint8(center)  <span class="comment"># float32 -&gt; uint8</span></span><br><span class="line">res = center[label.flatten()]  <span class="comment"># 将标签数组赋予真正的bgr值</span></span><br><span class="line">res2 = res.reshape(img.shape)  <span class="comment"># 重构图像</span></span><br><span class="line"></span><br><span class="line">cv2.imshow(<span class="string">&#x27;res2&#x27;</span>, res2)</span><br><span class="line">cv2.waitKey(<span class="number">0</span>)</span><br><span class="line">cv2.destroyAllWindows()</span><br></pre></td></tr></table></figure><h2 id="极坐标与直角坐标变换"><a href="#极坐标与直角坐标变换" class="headerlink" title="极坐标与直角坐标变换"></a>极坐标与直角坐标变换</h2><h3 id="极坐标转直角坐标"><a href="#极坐标转直角坐标" class="headerlink" title="极坐标转直角坐标"></a>极坐标转直角坐标</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> math</span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"></span><br><span class="line">cir_img = cv2.imread(<span class="string">&#x27;4-1.jpg&#x27;</span>)</span><br><span class="line">cv2.imshow(<span class="string">&#x27;panoramagram&#x27;</span>, cir_img)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 得到圆形区域的中心坐标</span></span><br><span class="line">x0, y0 = cir_img.shape[<span class="number">0</span>] // <span class="number">2</span>, cir_img.shape[<span class="number">1</span>] // <span class="number">2</span></span><br><span class="line"><span class="comment"># 通过圆形区域半径构造展开后的图像</span></span><br><span class="line">radius = cir_img.shape[<span class="number">0</span>] // <span class="number">2</span></span><br><span class="line">rect_height = radius</span><br><span class="line">rect_width = <span class="built_in">int</span>(<span class="number">2</span> * math.pi * radius)</span><br><span class="line">rect_img = np.zeros((rect_height, rect_width, <span class="number">3</span>), dtype=<span class="string">&quot;u1&quot;</span>)</span><br><span class="line"></span><br><span class="line">start = <span class="number">0</span>  <span class="comment"># 从正下方开始切，start设定偏移角度，单位为度</span></span><br><span class="line">except_count = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(rect_width):</span><br><span class="line">    theta = <span class="number">2</span> * math.pi * (j / rect_width) + <span class="number">2</span> * math.pi * (start / <span class="number">360</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(rect_height):</span><br><span class="line">        <span class="comment"># 适应椭圆的极坐标展开</span></span><br><span class="line">        x = (x0 - i) * math.cos(theta) + x0  <span class="comment"># &quot;sin&quot; is clockwise but &quot;cos&quot; is anticlockwise</span></span><br><span class="line">        y = (y0 - i) * math.sin(theta) + y0</span><br><span class="line">        x, y = <span class="built_in">int</span>(x), <span class="built_in">int</span>(y)</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            rect_img[i, j, :] = cir_img[x, y, :]</span><br><span class="line">        <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">            except_count = except_count + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">print(except_count)</span><br><span class="line">cv2.imwrite(<span class="string">&quot;rect_img.jpg&quot;</span>, rect_img)</span><br><span class="line">cv2.imshow(<span class="string">&quot;rect_img&quot;</span>, rect_img)</span><br><span class="line">cv2.waitKey(<span class="number">0</span>)</span><br></pre></td></tr></table></figure><h3 id="直角坐标转极坐标"><a href="#直角坐标转极坐标" class="headerlink" title="直角坐标转极坐标"></a>直角坐标转极坐标</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> math</span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"></span><br><span class="line">img_name = <span class="string">&#x27;8.jpeg&#x27;</span></span><br><span class="line">img = cv2.imread(img_name)</span><br><span class="line">cv2.imshow(<span class="string">&#x27;panoramagram&#x27;</span>, img)</span><br><span class="line">img = wrapped_img = cv2.resize(img, <span class="literal">None</span>, fx=<span class="number">2</span>, fy=<span class="number">2</span>, interpolation=cv2.INTER_CUBIC)</span><br><span class="line"><span class="comment"># 准备工作，计算原图像尺寸和变换后的图片大小</span></span><br><span class="line">x0 = img.shape[<span class="number">0</span>]</span><br><span class="line">y0 = img.shape[<span class="number">1</span>]</span><br><span class="line">print(x0, y0)</span><br><span class="line"><span class="comment"># 最大半径计算</span></span><br><span class="line">radius = <span class="built_in">int</span>(y0 / (<span class="number">2</span> * math.pi))</span><br><span class="line">w = <span class="number">2</span> * radius</span><br><span class="line">h = <span class="number">2</span> * radius</span><br><span class="line">wrapped_img = <span class="number">255</span> * np.ones((w, h, <span class="number">3</span>), dtype=<span class="string">&quot;u1&quot;</span>)</span><br><span class="line"></span><br><span class="line">except_count = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(y0):</span><br><span class="line">    <span class="comment"># 1. 求极坐标系中对应的角度theta</span></span><br><span class="line">    theta = <span class="number">2</span> * math.pi * (j / y0)</span><br><span class="line">    <span class="comment"># print(theta)</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(x0):</span><br><span class="line">        <span class="comment"># 2. 计算半径缩放系数</span></span><br><span class="line">        wrapped_radius = (i - x0) * radius / x0</span><br><span class="line">        <span class="comment"># 3. 利用对应关系进行换算</span></span><br><span class="line">        y = wrapped_radius * math.cos(theta) + radius</span><br><span class="line">        x = wrapped_radius * math.sin(theta) + radius</span><br><span class="line">        x, y = <span class="built_in">int</span>(x), <span class="built_in">int</span>(y)</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            wrapped_img[x, y, :] = img[i, j, :]</span><br><span class="line">            <span class="comment"># 注意点,在数学坐标系中的坐标与数字图像中的坐标表示存在差异需要注意</span></span><br><span class="line">        <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">            except_count = except_count + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">print(except_count)</span><br><span class="line"><span class="comment"># 提取ROI区域进行平滑处理，效果一般</span></span><br><span class="line">roi = wrapped_img[<span class="number">0</span>:radius, radius - <span class="number">5</span>:radius + <span class="number">5</span>, :]</span><br><span class="line">roi_blur = cv2.blur(roi, (<span class="number">3</span>, <span class="number">3</span>))</span><br><span class="line">wrapped_img[<span class="number">0</span>:radius, radius - <span class="number">5</span>:radius + <span class="number">5</span>, :] = roi_blur</span><br><span class="line"><span class="comment"># wrapped_img = cv2.resize(wrapped_img,None,fx=1,fy=1,interpolation=cv2.INTER_CUBIC)</span></span><br><span class="line">name = <span class="string">&#x27;p_&#x27;</span> + img_name</span><br><span class="line">cv2.imwrite(name, wrapped_img)</span><br><span class="line">cv2.imshow(<span class="string">&quot;Unwrapped&quot;</span>, wrapped_img)</span><br><span class="line">cv2.waitKey(<span class="number">0</span>)</span><br></pre></td></tr></table></figure><h2 id="傅里叶变换实现的高低通滤波"><a href="#傅里叶变换实现的高低通滤波" class="headerlink" title="傅里叶变换实现的高低通滤波"></a>傅里叶变换实现的高低通滤波</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> matplotlib <span class="keyword">import</span> pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">img = cv2.imread(<span class="string">&#x27;source/work3/lena.jpg&#x27;</span>, <span class="number">0</span>)</span><br><span class="line"><span class="comment"># 返回结果与Numpy相同，但有两个通道。第一个通道为有结果的实部，第二个通道为有结果的虚部。</span></span><br><span class="line">img_dft = cv2.dft(np.float32(img), flags=cv2.DFT_COMPLEX_OUTPUT)</span><br><span class="line"><span class="comment"># 移频 将FFT输出中的直流分量移动到频谱的中央</span></span><br><span class="line">img_shift = np.fft.fftshift(img_dft)</span><br><span class="line"></span><br><span class="line">center_row, center_col = <span class="built_in">int</span>(img.shape[<span class="number">0</span>] / <span class="number">2</span>), <span class="built_in">int</span>(img.shape[<span class="number">1</span>] / <span class="number">2</span>)</span><br><span class="line"><span class="comment"># 低通滤波</span></span><br><span class="line">cov = np.zeros((img.shape[<span class="number">0</span>], img.shape[<span class="number">1</span>], <span class="number">2</span>), np.uint8)</span><br><span class="line">cov[center_row - <span class="number">30</span>:center_row + <span class="number">30</span>, center_col - <span class="number">30</span>:center_col + <span class="number">30</span>, :] = <span class="number">1</span></span><br><span class="line">f1_shift = img_shift * cov</span><br><span class="line">f1_ishift = np.fft.ifftshift(f1_shift)</span><br><span class="line">f1_back = cv2.idft(f1_ishift)</span><br><span class="line">f1_back = cv2.magnitude(f1_back[:, :, <span class="number">0</span>], f1_back[:, :, <span class="number">1</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 高通滤波</span></span><br><span class="line">cov = np.ones((img.shape[<span class="number">0</span>], img.shape[<span class="number">1</span>], <span class="number">2</span>), np.uint8)</span><br><span class="line">cov[center_row - <span class="number">30</span>:center_row + <span class="number">30</span>, center_col - <span class="number">30</span>:center_col + <span class="number">30</span>] = <span class="number">0</span></span><br><span class="line">f2_shift = img_shift * cov</span><br><span class="line">f2_ishift = np.fft.ifftshift(f2_shift)</span><br><span class="line">f2_back = cv2.idft(f2_ishift)</span><br><span class="line">f2_back = cv2.magnitude(f2_back[:, :, <span class="number">0</span>], f2_back[:, :, <span class="number">1</span>])</span><br><span class="line"></span><br><span class="line">plt.subplot(<span class="number">221</span>), plt.imshow(img, cmap=<span class="string">&#x27;gray&#x27;</span>)</span><br><span class="line">plt.title(<span class="string">&#x27;Input Image&#x27;</span>), plt.xticks([]), plt.yticks([])</span><br><span class="line">plt.subplot(<span class="number">222</span>), plt.imshow(f1_back, cmap=<span class="string">&#x27;gray&#x27;</span>)</span><br><span class="line">plt.title(<span class="string">&#x27;LPF&#x27;</span>), plt.xticks([]), plt.yticks([])</span><br><span class="line">plt.subplot(<span class="number">223</span>), plt.imshow(img, cmap=<span class="string">&#x27;gray&#x27;</span>)</span><br><span class="line">plt.title(<span class="string">&#x27;Input Image&#x27;</span>), plt.xticks([]), plt.yticks([])</span><br><span class="line">plt.subplot(<span class="number">224</span>), plt.imshow(f2_back, cmap=<span class="string">&#x27;gray&#x27;</span>)</span><br><span class="line">plt.title(<span class="string">&#x27;HPF&#x27;</span>), plt.xticks([]), plt.yticks([])</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><h2 id="直方图传递"><a href="#直方图传递" class="headerlink" title="直方图传递"></a>直方图传递</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> matplotlib <span class="keyword">import</span> pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 计算直方图累计概率</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">histCalculate</span>(<span class="params">src</span>):</span></span><br><span class="line">    m, n = np.shape(src)</span><br><span class="line">    <span class="comment"># 直方图</span></span><br><span class="line">    hist = np.zeros(<span class="number">256</span>, dtype=np.float32)</span><br><span class="line">    <span class="comment"># 累积直方图</span></span><br><span class="line">    cumhist = np.zeros(<span class="number">256</span>, dtype=np.float32)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            hist[src[i, j]] += <span class="number">1</span></span><br><span class="line">    cumhist[<span class="number">0</span>] = hist[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">256</span>):</span><br><span class="line">        cumhist[i] = cumhist[i - <span class="number">1</span>] + hist[i]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> cumhist / (m * n)  <span class="comment"># 累积直方图概率</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 直方图规定化</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">histNormalize</span>(<span class="params">img1, img2</span>):</span></span><br><span class="line">    <span class="comment"># 代匹配直方图</span></span><br><span class="line">    img1Pro = histCalculate(img1)</span><br><span class="line">    <span class="comment"># 参考直方图</span></span><br><span class="line">    img2Pro = histCalculate(img2)</span><br><span class="line"></span><br><span class="line">    correspondValue = np.zeros(<span class="number">256</span>, dtype=np.uint8)</span><br><span class="line">    <span class="comment"># 直方图传递</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">256</span>):</span><br><span class="line">        diff = np.<span class="built_in">abs</span>(img1Pro[i] - img2Pro[i])</span><br><span class="line">        matchValue = i</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">256</span>):</span><br><span class="line">            <span class="keyword">if</span> np.<span class="built_in">abs</span>(img1Pro[i] - img2Pro[j]) &lt; diff:</span><br><span class="line">                diff = np.<span class="built_in">abs</span>(img1Pro[i] - img2Pro[j])</span><br><span class="line">                matchValue = j</span><br><span class="line">        correspondValue[i] = matchValue</span><br><span class="line">    <span class="keyword">return</span> cv2.LUT(img1, correspondValue)</span><br><span class="line"></span><br><span class="line">img1 = cv2.imread(<span class="string">&#x27;source/detect2.jpg&#x27;</span>, <span class="number">0</span>)</span><br><span class="line">img1 = cv2.resize(img1, (<span class="number">640</span>, <span class="number">640</span> * img1.shape[<span class="number">0</span>] // img1.shape[<span class="number">1</span>]))</span><br><span class="line">img2 = cv2.imread(<span class="string">&#x27;source/detect1.jpg&#x27;</span>, <span class="number">0</span>)</span><br><span class="line">img2 = cv2.resize(img2, (<span class="number">640</span>, <span class="number">640</span> * img1.shape[<span class="number">0</span>] // img1.shape[<span class="number">1</span>]))</span><br><span class="line"><span class="comment"># print(img1.shape, img2.shape)</span></span><br><span class="line"></span><br><span class="line">img_out = histNormalize(img1, img2)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 计算直方图</span></span><br><span class="line">hist1 = cv2.calcHist([img1], channels=[<span class="number">0</span>], mask=<span class="literal">None</span>, histSize=[<span class="number">256</span>], ranges=[<span class="number">0</span>, <span class="number">256</span>])</span><br><span class="line">hist2 = cv2.calcHist([img2], channels=[<span class="number">0</span>], mask=<span class="literal">None</span>, histSize=[<span class="number">256</span>], ranges=[<span class="number">0</span>, <span class="number">256</span>])</span><br><span class="line">hist3 = cv2.calcHist([img_out], channels=[<span class="number">0</span>], mask=<span class="literal">None</span>, histSize=[<span class="number">256</span>], ranges=[<span class="number">0</span>, <span class="number">256</span>])</span><br><span class="line"></span><br><span class="line">plt.subplot(<span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>), plt.imshow(img1, cmap=<span class="string">&#x27;gray&#x27;</span>)</span><br><span class="line">plt.title(<span class="string">&#x27;img1&#x27;</span>), plt.xticks([]), plt.yticks([])</span><br><span class="line">plt.subplot(<span class="number">2</span>, <span class="number">3</span>, <span class="number">2</span>), plt.imshow(img2, cmap=<span class="string">&#x27;gray&#x27;</span>)</span><br><span class="line">plt.title(<span class="string">&#x27;img2&#x27;</span>), plt.xticks([]), plt.yticks([])</span><br><span class="line">plt.subplot(<span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>), plt.imshow(img_out, cmap=<span class="string">&#x27;gray&#x27;</span>)</span><br><span class="line">plt.title(<span class="string">&#x27;img_out&#x27;</span>), plt.xticks([]), plt.yticks([])</span><br><span class="line"></span><br><span class="line">plt.subplot(<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>), plt.plot(hist1, <span class="string">&#x27;r&#x27;</span>)</span><br><span class="line">plt.title(<span class="string">&#x27;img1 hist ratio&#x27;</span>)</span><br><span class="line">plt.subplot(<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>), plt.plot(hist2, <span class="string">&#x27;b&#x27;</span>)</span><br><span class="line">plt.title(<span class="string">&#x27;img2 hist ratio&#x27;</span>)</span><br><span class="line">plt.subplot(<span class="number">2</span>, <span class="number">3</span>, <span class="number">6</span>), plt.plot(hist3, <span class="string">&#x27;g&#x27;</span>)</span><br><span class="line">plt.title(<span class="string">&#x27;img_out hist ratio&#x27;</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><h2 id="np旋转缩放的手动实现"><a href="#np旋转缩放的手动实现" class="headerlink" title="np旋转缩放的手动实现"></a>np旋转缩放的手动实现</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">scale</span>(<span class="params">img, ratio_h, ratio_w</span>):</span></span><br><span class="line">    <span class="keyword">try</span>:  <span class="comment"># 适应3通道图</span></span><br><span class="line">        target_img = np.zeros((<span class="built_in">int</span>(img.shape[<span class="number">1</span>] * ratio_h), <span class="built_in">int</span>(img.shape[<span class="number">0</span>] * ratio_w), img.shape[<span class="number">2</span>]), dtype=img.dtype)</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        target_img = np.zeros((<span class="built_in">int</span>(img.shape[<span class="number">1</span>] * ratio_h), <span class="built_in">int</span>(img.shape[<span class="number">0</span>] * ratio_w)), dtype=img.dtype)</span><br><span class="line"></span><br><span class="line">    convert_matrix = [[ratio_h, <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">                      [<span class="number">0</span>, ratio_w, <span class="number">0</span>],</span><br><span class="line">                      [<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>]]  <span class="comment"># 变换矩阵</span></span><br><span class="line">    convert_matrix_inv = np.linalg.inv(convert_matrix)  <span class="comment"># 逆变换</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">int</span>(img.shape[<span class="number">1</span>] * ratio_h)):</span><br><span class="line">        <span class="keyword">for</span> y <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">int</span>(img.shape[<span class="number">0</span>] * ratio_w)):</span><br><span class="line">            target_pos = [x, y, <span class="number">1</span>]</span><br><span class="line">            origin_pos = np.dot(convert_matrix_inv, target_pos)  <span class="comment"># 原像素点的位置</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (img.shape[<span class="number">0</span>] &gt;= origin_pos[<span class="number">0</span>] + <span class="number">1</span> <span class="keyword">and</span> img.shape[<span class="number">1</span>] &gt;= origin_pos[<span class="number">1</span>] + <span class="number">1</span>) <span class="keyword">and</span> (origin_pos &gt;= <span class="number">0</span>).<span class="built_in">all</span>():</span><br><span class="line">                x_low = np.floor(origin_pos[<span class="number">0</span>])</span><br><span class="line">                x_up = np.ceil(origin_pos[<span class="number">0</span>])</span><br><span class="line">                y_low = np.floor(origin_pos[<span class="number">1</span>])</span><br><span class="line">                y_up = np.ceil(origin_pos[<span class="number">1</span>])  <span class="comment"># 最靠近原像素点的左上点和右下点</span></span><br><span class="line"></span><br><span class="line">                s = origin_pos[<span class="number">0</span>] - x_low</span><br><span class="line">                t = origin_pos[<span class="number">1</span>] - y_low  <span class="comment"># 原像素在像素方格中的位置</span></span><br><span class="line"></span><br><span class="line">                p1 = img[<span class="built_in">int</span>(x_low), <span class="built_in">int</span>(y_low)]</span><br><span class="line">                p2 = img[<span class="built_in">int</span>(x_up), <span class="built_in">int</span>(y_low)]</span><br><span class="line">                p3 = img[<span class="built_in">int</span>(x_low), <span class="built_in">int</span>(y_up)]</span><br><span class="line">                p4 = img[<span class="built_in">int</span>(x_up), <span class="built_in">int</span>(y_up)]  <span class="comment"># 包裹原像素点的四个像素点的值</span></span><br><span class="line"></span><br><span class="line">                <span class="comment"># 插值</span></span><br><span class="line">                value = (<span class="number">1</span> - s) * (<span class="number">1</span> - t) * p1 + (<span class="number">1</span> - s) * t * p3 + (<span class="number">1</span> - t) * s * p2 + s * t * p4</span><br><span class="line">                target_img[x, y] = value</span><br><span class="line">    <span class="keyword">return</span> target_img</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">rotate</span>(<span class="params">img, angle</span>):</span></span><br><span class="line">    beta = angle / <span class="number">180</span> * np.pi</span><br><span class="line">    new_width = <span class="built_in">int</span>(<span class="built_in">abs</span>(img.shape[<span class="number">1</span>] * np.cos(beta)) + <span class="built_in">abs</span>(img.shape[<span class="number">0</span>] * np.sin(beta)))</span><br><span class="line">    new_height = <span class="built_in">int</span>(<span class="built_in">abs</span>(img.shape[<span class="number">1</span>] * np.sin(beta)) + <span class="built_in">abs</span>(img.shape[<span class="number">0</span>] * np.cos(beta)))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span>:  <span class="comment"># 适应3通道图</span></span><br><span class="line">        target_img = np.zeros((new_height, new_width, img.shape[<span class="number">2</span>]), dtype=img.dtype)</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        target_img = np.zeros((new_height, new_width), dtype=img.dtype)</span><br><span class="line"></span><br><span class="line">    rotate_matrix = [[np.cos(beta), np.sin(beta), <span class="number">0</span>],</span><br><span class="line">                     [-np.sin(beta), np.cos(beta), <span class="number">0</span>],</span><br><span class="line">                     [<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>]]  <span class="comment"># 旋转</span></span><br><span class="line">    translation_matrix = [[<span class="number">1</span>, <span class="number">0</span>, -img.shape[<span class="number">1</span>] / <span class="number">2</span>],</span><br><span class="line">                      [<span class="number">0</span>, <span class="number">1</span>, -img.shape[<span class="number">0</span>] / <span class="number">2</span>],</span><br><span class="line">                      [<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>]]  <span class="comment"># 平移</span></span><br><span class="line">    convert_matrix = np.dot(rotate_matrix, translation_matrix)  <span class="comment"># 目标变换矩阵</span></span><br><span class="line">    convert_matrix_inv = np.linalg.inv(convert_matrix)  <span class="comment"># 逆矩阵</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(new_width):</span><br><span class="line">        <span class="keyword">for</span> y <span class="keyword">in</span> <span class="built_in">range</span>(new_height):</span><br><span class="line">            <span class="comment"># 由于之前是先转换后再加上宽高的一半得到的坐标，所以此处做逆运算时就要先减去宽高的一半</span></span><br><span class="line">            target_pos = [<span class="built_in">int</span>(x - new_width / <span class="number">2</span>), <span class="built_in">int</span>(y - new_height / <span class="number">2</span>), <span class="number">1</span>]</span><br><span class="line">            origin_pos = np.dot(convert_matrix_inv, target_pos)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (img.shape[<span class="number">0</span>] &gt; origin_pos[<span class="number">0</span>] + <span class="number">1</span> <span class="keyword">and</span> img.shape[<span class="number">1</span>] &gt; origin_pos[<span class="number">1</span>] + <span class="number">1</span>) <span class="keyword">and</span> (origin_pos &gt;= <span class="number">0</span>).<span class="built_in">all</span>():</span><br><span class="line">                x_low = np.floor(origin_pos[<span class="number">0</span>])</span><br><span class="line">                x_up = np.ceil(origin_pos[<span class="number">0</span>])</span><br><span class="line">                y_low = np.floor(origin_pos[<span class="number">1</span>])</span><br><span class="line">                y_up = np.ceil(origin_pos[<span class="number">1</span>])  <span class="comment"># 最靠近原像素点的左上点和右下点</span></span><br><span class="line"></span><br><span class="line">                s = origin_pos[<span class="number">0</span>] - x_low</span><br><span class="line">                t = origin_pos[<span class="number">1</span>] - y_low  <span class="comment"># 原像素在像素方格中的位置</span></span><br><span class="line"></span><br><span class="line">                p1 = img[<span class="built_in">int</span>(x_low), <span class="built_in">int</span>(y_low)]</span><br><span class="line">                p2 = img[<span class="built_in">int</span>(x_up), <span class="built_in">int</span>(y_low)]</span><br><span class="line">                p3 = img[<span class="built_in">int</span>(x_low), <span class="built_in">int</span>(y_up)]</span><br><span class="line">                p4 = img[<span class="built_in">int</span>(x_up), <span class="built_in">int</span>(y_up)]  <span class="comment"># 包裹原像素点的四个像素点的值</span></span><br><span class="line"></span><br><span class="line">                <span class="comment"># 插值</span></span><br><span class="line">                value = (<span class="number">1</span> - s) * (<span class="number">1</span> - t) * p1 + (<span class="number">1</span> - s) * t * p3 + (<span class="number">1</span> - t) * s * p2 + s * t * p4</span><br><span class="line">                target_img[x, y] = value</span><br><span class="line">    <span class="keyword">return</span> target_img</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">part3_1</span>():</span></span><br><span class="line">    img0 = cv2.imread(<span class="string">&#x27;source/work2/lena.jpg&#x27;</span>)</span><br><span class="line">    img = scale(img0, ratio_h=<span class="number">1.6</span>, ratio_w=<span class="number">2.3</span>)  <span class="comment"># 宽放大2.3, 高放大1.6</span></span><br><span class="line">    print(img0.shape, img.shape)  <span class="comment"># (256, 256, 3) -&gt; (512, 512, 3)</span></span><br><span class="line">    cv2.imshow(<span class="string">&quot;img&quot;</span>, img)</span><br><span class="line">    cv2.waitKey()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">part1</span>():</span></span><br><span class="line">    img = np.array([[<span class="number">1</span>, <span class="number">4</span>, <span class="number">7</span>],</span><br><span class="line">                    [<span class="number">2</span>, <span class="number">5</span>, <span class="number">8</span>],</span><br><span class="line">                    [<span class="number">3</span>, <span class="number">6</span>, <span class="number">9</span>]])</span><br><span class="line">    print(scale(img, <span class="number">2.3</span>, <span class="number">1.6</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">part2</span>():</span></span><br><span class="line">    img = np.array([[<span class="number">59</span>, <span class="number">60</span>, <span class="number">58</span>, <span class="number">57</span>],</span><br><span class="line">                  [<span class="number">61</span>, <span class="number">59</span>, <span class="number">59</span>, <span class="number">57</span>],</span><br><span class="line">                  [<span class="number">62</span>, <span class="number">59</span>, <span class="number">60</span>, <span class="number">58</span>],</span><br><span class="line">                  [<span class="number">59</span>, <span class="number">61</span>, <span class="number">60</span>, <span class="number">56</span>]])</span><br><span class="line">    print(rotate(img, <span class="number">45</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">part3_1</span>():</span></span><br><span class="line">    img0 = cv2.imread(<span class="string">&#x27;source/work2/lena.jpg&#x27;</span>)</span><br><span class="line">    img = scale(img0, ratio_h=<span class="number">1.6</span>, ratio_w=<span class="number">2.3</span>)  <span class="comment"># 宽放大2.3, 高放大1.6</span></span><br><span class="line">    print(img0.shape, img.shape)  <span class="comment"># (256, 256, 3) -&gt; (512, 512, 3)</span></span><br><span class="line">    cv2.imshow(<span class="string">&quot;img&quot;</span>, img)</span><br><span class="line">    cv2.waitKey()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">part3_2</span>():</span></span><br><span class="line">    img0 = cv2.imread(<span class="string">&#x27;source/work2/lena.jpg&#x27;</span>)</span><br><span class="line">    img = rotate(img0, -<span class="number">45</span>)  <span class="comment"># 逆时针旋转45</span></span><br><span class="line">    print(img0.shape, img.shape)  <span class="comment"># (256, 256, 3) -&gt; (362, 362, 3)</span></span><br><span class="line">    cv2.imshow(<span class="string">&quot;img&quot;</span>, img)</span><br><span class="line">    cv2.waitKey()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    part1()</span><br><span class="line">    part2()</span><br><span class="line">    part3_1()</span><br><span class="line">    part3_2()</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> OpenCV </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>OpenCV-完结目录</title>
      <link href="/2021/08/OpenCV-%E5%AE%8C%E7%BB%93%E7%9B%AE%E5%BD%95/"/>
      <url>/2021/08/OpenCV-%E5%AE%8C%E7%BB%93%E7%9B%AE%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<h1 id="OpenCV——完结目录"><a href="#OpenCV——完结目录" class="headerlink" title="OpenCV——完结目录"></a>OpenCV——完结目录</h1><p>推荐资源：</p><ol><li><a href="http://www.woshicver.com/">OpenCV中文官方文档</a></li></ol><p>在实习时用到，随后做一次总结与再学习，记录遇到的注意点与个人理解。</p><p>该笔记还未记录直方图到机器学习的部分，主要是 python-opencv 框架的使用。</p><table><thead><tr><th align="center"><a href="/2021/08/OpenCV-Part1/">OpenCV-Part1——基础操作</a></th></tr></thead><tbody><tr><td align="center"><strong><a href="/2021/08/OpenCV-Part2/">OpenCV-Part2——图像处理（上）</a></strong></td></tr><tr><td align="center"><strong><a href="/2021/08/OpenCV-Part3/">OpenCV-Part3——图像处理（中）</a></strong></td></tr><tr><td align="center"><strong><a href="/2021/08/OpenCV-Part4/">OpenCV-Part4——图像处理（下）</a></strong></td></tr><tr><td align="center"><strong><a href="/2021/09/OpenCV-Part5/">OpenCV-Part5——综合运用</a></strong></td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> OpenCV </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OpenCV-Part4</title>
      <link href="/2021/08/OpenCV-Part4/"/>
      <url>/2021/08/OpenCV-Part4/</url>
      
        <content type="html"><![CDATA[<h1 id="OpenCV-Part4——图像处理（下）"><a href="#OpenCV-Part4——图像处理（下）" class="headerlink" title="OpenCV-Part4——图像处理（下）"></a>OpenCV-Part4——图像处理（下）</h1><p>[TOC]</p><h2 id="直方图"><a href="#直方图" class="headerlink" title="直方图"></a>直方图</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><ul><li><p>直方图，是在X轴上具有像素值（不总是从0到255的范围），在Y轴上具有图像中相应像素数的图。</p></li><li><p>直方图，可以用来总体了解图像的强度分布。</p></li><li><p>直方图只是理解图像的另一种方式。通过查看图像的直方图，可以直观地了解该图像的对比度，亮度，强度分布等。</p></li><li><p><img src="/2021/08/OpenCV-Part4/histogram_sample.jpg" alt="img"></p><p>如图，此直方图是针对灰度图像而非彩色图像绘制的。其左侧区域显示图像中较暗像素的数量，而右侧区域则显示明亮像素的数量。</p><p>从该直方图中，可以看到暗区域多于亮区域，而中间灰度值的数量就非常少。</p></li><li><p>有关直方图的术语：</p><ul><li>BINS：像素值的区间段数。将整个直方图在 x 轴上分成 n 个子部分，每个子部分的值就是其中所有像素数的总和，每个子部分都称为一个 BIN 。当 x 轴采用 255 个值来展示直方图时，BINS=255。可用于对具体像素精度不在乎，而意图找固定区间段划分的像素总量的情况。在 OpenCV 中也称作 histSize 。</li><li>DIMS：收集数据的参数量。当仅收集关于强度值的一件事的数据时，这里是1。</li><li>RANGE：测量的强度值范围。通常为[0, 256]，即所有强度值。</li></ul></li></ul><h3 id="查找并绘制直方图"><a href="#查找并绘制直方图" class="headerlink" title="查找并绘制直方图"></a>查找并绘制直方图</h3><h4 id="OpenCV计算直方图"><a href="#OpenCV计算直方图" class="headerlink" title="OpenCV计算直方图"></a>OpenCV计算直方图</h4><ul><li><code>cv2.calcHist(images，channels，mask，histSize，ranges，hist，accumulate)</code>：查找直方图。<ul><li><code>images</code>：<code>uint8</code>或<code>float32</code>类型的源图像。需要由列表[img]包裹。</li><li><code>channels</code>：计算直方图的通道索引。对于灰度图像，则其值为[0]。对于彩色图像，可以传递[0]、[1]或[2]分别计算蓝色，绿色或红色通道的直方图。需要由列表[channels]包裹。</li><li><code>mask</code>：图像掩码。None：查找完整图像的直方图。否则为查找特定区域mask掩码的直方图。</li><li><code>histSize</code>：像素值的区间段数。需要放在方括号中。对于全尺寸，我们通过[256]。需要由列表[histSize]包裹。</li><li><code>ranges</code>：测量的强度值范围。通常为<code>[0, 256]</code>。</li></ul></li><li>Numpy 也有计算直方图的函数，但是 <code>cv2.calcHist()</code> 比 <code>np.histogram()</code> 快大约40倍。因此，尽可能使用OpenCV函数。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">img = cv2.imread(<span class="string">&#x27;home.jpg&#x27;</span>, <span class="number">0</span>)</span><br><span class="line">hist = cv2.calcHist([img], channels=[<span class="number">0</span>], mask=<span class="literal">None</span>, histSize=[<span class="number">256</span>], ranges=[<span class="number">0</span>, <span class="number">256</span>])</span><br></pre></td></tr></table></figure><h4 id="Matplotlib绘制直方图"><a href="#Matplotlib绘制直方图" class="headerlink" title="Matplotlib绘制直方图"></a>Matplotlib绘制直方图</h4><ol><li><p><code>matplotlib.pyplot.hist()</code> ：Matplotlib自带直方图绘图功能，能够直接找到直方图并将其绘制。而无需使用 <code>cv2.calcHist() </code>查找直方图。</p><ul><li><pre><code class="python">import numpy as npimport cv2from matplotlib import pyplot as pltimage = cv2.imread(&#39;home.jpg&#39;)# numpy的ravel函数功能是将多维数组降为一维数组plt.hist(image.ravel(), bins=256, range=[0, 256], histtype=&quot;step&quot;, color=&#39;black&#39;)  # 对整图的，需要注意和灰度是有区别的！plt.hist(image[:, :, 0].ravel(), bins=256, range=[0, 256], histtype=&quot;step&quot;, color=&#39;blue&#39;)plt.hist(image[:, :, 1].ravel(), bins=256, range=[0, 256], histtype=&quot;step&quot;, color=&#39;green&#39;)plt.hist(image[:, :, 2].ravel(), bins=256, range=[0, 256], histtype=&quot;step&quot;, color=&#39;red&#39;)plt.show()<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">   </span><br><span class="line">2. &#96;cv2.calcHist()&#96;+&#96;plt.plot()&#96;：先找到直方图数据，再使用matplotlib的法线图。分离了数据和画图，更符合程序解耦设计。</span><br><span class="line"></span><br><span class="line">   - &#96;&#96;&#96;python</span><br><span class="line">     import numpy as np</span><br><span class="line">     import cv2</span><br><span class="line">     from matplotlib import pyplot as plt</span><br><span class="line">     </span><br><span class="line">     image &#x3D; cv2.imread(&#39;home.jpg&#39;)</span><br><span class="line">     color &#x3D; [&quot;blue&quot;, &quot;green&quot;, &quot;red&quot;]</span><br><span class="line">     ranges &#x3D; [0, 256]</span><br><span class="line">     # 同时列出数据下标和数据</span><br><span class="line">     for i, color in enumerate(color):</span><br><span class="line">         hist &#x3D; cv2.calcHist([image], channels&#x3D;[i], mask&#x3D;None, histSize&#x3D;[256], ranges&#x3D;ranges)</span><br><span class="line">         print(type(hist), hist.shape)  # &lt;class &#39;numpy.ndarray&#39;&gt;  (256, 1)</span><br><span class="line">         plt.plot(hist, color&#x3D;color)</span><br><span class="line">         plt.xlim(ranges)</span><br><span class="line">     plt.show()</span><br></pre></td></tr></table></figure>![img](OpenCV-Part4/histogram_rgb_plot.jpg)</code></pre></li></ul></li></ol><h3 id="直方图均衡化"><a href="#直方图均衡化" class="headerlink" title="直方图均衡化"></a>直方图均衡化</h3><h4 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h4><ul><li>直方图均衡化，可以使限制在某一区间的色彩亮度均衡到整个色彩区间上，使像素在直方图上的分布更均匀。</li><li>直方图均衡化，是用来改善图像的全局亮度和对比度的。例如，在对人脸数据进行训练之前，对人脸图像进行直方图均衡化处理，使其具有相同的光照条件。</li><li><img src="/2021/08/OpenCV-Part4/histogram_equalization.png" alt="img"></li></ul><h4 id="全局均衡化"><a href="#全局均衡化" class="headerlink" title="全局均衡化"></a>全局均衡化</h4><ul><li><code>cv2.equalizeHist()</code>：只能输入灰度图像，输出直方图均衡化后的图像。 </li><li><code>np.hstack((img1, img2))</code>：横向拼接。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">equ = cv2.equalizeHist(img)</span><br><span class="line">cv2.imshow(<span class="string">&#x27;equalization&#x27;</span>, np.hstack((img, equ)))  <span class="comment"># 并排显示</span></span><br><span class="line">cv2.waitKey(<span class="number">0</span>)</span><br></pre></td></tr></table></figure><p><img src="/2021/08/OpenCV-Part4/equalization_opencv.jpg" alt="img"></p><h4 id="自适应直方图均衡化-CLAHE"><a href="#自适应直方图均衡化-CLAHE" class="headerlink" title="自适应直方图均衡化(CLAHE)"></a>自适应直方图均衡化(CLAHE)</h4><ul><li>当一张图同时拥有较多暗部和亮部时，全局均衡化极其容易丢失信息。</li><li>自适应直方图均衡，可以将图像分成称为 tiles 的小块（在 OpenCV 中，tileSize 默认为 8x8 ）。并在每个较小的区域中，进行直方图均衡。</li><li>如果在 tiles 中有噪音，则应用了对比度限制：任何直方图 bin 超出指定的对比度限制（在OpenCV中默认为40），则在应用直方图均衡之前，将这些像素裁剪并均匀地分布到其他bin。</li><li><code>cv2.createCLAHE(clipLimit, tileGridSize)</code>：CLAHE 自适应直方图均衡化。<ul><li><code>clipLimit</code>：颜色对比度的阈值。</li><li><code>titleGridSize</code>：进行像素均衡化的网格大小。</li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cl1 = cv2.createCLAHE(clipLimit=<span class="number">2.0</span>, tileGridSize=(<span class="number">8</span>, <span class="number">8</span>)).apply(img)</span><br><span class="line">cv2.imshow(<span class="string">&#x27;equalization&#x27;</span>, np.hstack((img, cl1)))  <span class="comment"># 并排显示</span></span><br><span class="line">cv2.waitKey(<span class="number">0</span>)</span><br></pre></td></tr></table></figure><img src="/2021/08/OpenCV-Part4/image-20210902221852779.png" alt="image-20210902221852779" style="zoom:67%;"><h3 id="二维直方图"><a href="#二维直方图" class="headerlink" title="二维直方图"></a>二维直方图</h3><h4 id="定义-2"><a href="#定义-2" class="headerlink" title="定义"></a>定义</h4><ul><li>上述都是在计算一维直方图，因为仅考虑一个特征，即像素的灰度强度值。</li><li>但是在二维直方图中，需要考虑两个特征：每个像素的 <code>色相(Hue)</code> 和 <code>饱和度(Saturation)</code> 值。</li><li>二维直方图，通常用于查找颜色直方图。</li></ul><h4 id="查找并绘制直方图-1"><a href="#查找并绘制直方图-1" class="headerlink" title="查找并绘制直方图"></a>查找并绘制直方图</h4><h5 id="OpenCV计算二维直方图"><a href="#OpenCV计算二维直方图" class="headerlink" title="OpenCV计算二维直方图"></a>OpenCV计算二维直方图</h5><ul><li><p>对于颜色直方图，我们需要将图像从BGR转换为HSV。对于一维直方图，我们从BGR转换为灰度</p></li><li><p><code>cv2.calcHist()</code>：对于二维直方图，使用相同的函数，但其参数将进行如下修改：</p><ul><li><code>channels=[0, 1]</code>：因为需要同时处理H和S平面。</li><li><code>histSize=[180, 256]</code>：对于H平面为180，对于S平面为256。</li><li><code>ranges=[0, 180, 0, 256]</code>：色相值介于0和180之间，饱和度介于0和256之间。</li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"></span><br><span class="line">img = cv2.imread(<span class="string">&#x27;home.jpg&#x27;</span>)</span><br><span class="line">hsv = cv2.cvtColor(img, cv2.COLOR_BGR2HSV)</span><br><span class="line">hist = cv2.calcHist([hsv], channels=[<span class="number">0</span>, <span class="number">1</span>], mask=<span class="literal">None</span>, histSize=[<span class="number">180</span>, <span class="number">256</span>], ranges=[<span class="number">0</span>, <span class="number">180</span>, <span class="number">0</span>, <span class="number">256</span>])</span><br></pre></td></tr></table></figure><h5 id="Matplotlib绘制二维直方图"><a href="#Matplotlib绘制二维直方图" class="headerlink" title="Matplotlib绘制二维直方图"></a>Matplotlib绘制二维直方图</h5><ul><li>matplotlib.pyplot.imshow()：绘制2D直方图。</li><li>使用此功能时，插值法应采用最近邻以获得更好的结果。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">from</span> matplotlib <span class="keyword">import</span> pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">img = cv2.imread(<span class="string">&quot;test.jpg&quot;</span>)</span><br><span class="line">hsv = cv2.cvtColor(img, cv2.COLOR_BGR2HSV)</span><br><span class="line">hist = cv2.calcHist([hsv], channels=[<span class="number">0</span>, <span class="number">1</span>], mask=<span class="literal">None</span>, histSize=[<span class="number">180</span>, <span class="number">256</span>], ranges=[<span class="number">0</span>, <span class="number">180</span>, <span class="number">0</span>, <span class="number">256</span>])</span><br><span class="line">plt.imshow(hist, interpolation=<span class="string">&#x27;nearest&#x27;</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><ul><li><p>下面是输入图像及其颜色直方图。X轴显示S值，Y轴显示色相。</p><img src="http://qiniu.aihubs.net/2dhist_matplotlib.jpg" alt="img" style="zoom:200%;"></li><li><p>在该直方图中，可以在H = 100 和 S = 200 附近看到一些较高的值，对应于天空的蓝色。同样，在 H = 25 和 S = 100 附近可以看到另一个峰值，对应于宫殿的黄色。</p></li></ul><h3 id="YUV色彩空间对彩色图像做直方图均衡化"><a href="#YUV色彩空间对彩色图像做直方图均衡化" class="headerlink" title="YUV色彩空间对彩色图像做直方图均衡化"></a>YUV色彩空间对彩色图像做直方图均衡化</h3><ul><li><p>YUV色彩空间是把亮度（Luma）与色度（Chroma）分离。</p><ul><li>“Y”表示亮度，也就是灰度值。</li><li>“U”表示蓝色通道与亮度的差值。</li><li>“V”表示红色通道与亮度的差值。</li></ul></li><li><p>对彩色图像进行直方图均衡化时，先将图像从RGB空间转到YUV空间，然后对亮度Y通道进行直方图均衡化得到通道Y”，然后将Y”UV通道进行合并。</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">img = cv2.imread(<span class="string">&#x27;input.jpg&#x27;</span>)</span><br><span class="line"></span><br><span class="line">img_yuv = cv2.cvtColor(img, cv2.COLOR_BGR2YUV)</span><br><span class="line"><span class="comment"># equalize the histogram of the Y channel</span></span><br><span class="line">img_yuv[:, :, <span class="number">0</span>] = cv2.createCLAHE(clipLimit=<span class="number">2.0</span>, tileGridSize=(<span class="number">8</span>, <span class="number">8</span>)).apply(img_yuv[:, :, <span class="number">0</span>])</span><br><span class="line"><span class="comment"># convert the YUV image back to RGB format</span></span><br><span class="line">img_output = cv2.cvtColor(img_yuv, cv2.COLOR_YUV2BGR)</span><br><span class="line"></span><br><span class="line">cv2.imshow(<span class="string">&#x27;Color input image&#x27;</span>, img)</span><br><span class="line">cv2.imshow(<span class="string">&#x27;Histogram equalized&#x27;</span>, img_output)</span><br><span class="line">cv2.waitKey(<span class="number">0</span>)</span><br></pre></td></tr></table></figure><h3 id="直方图比较"><a href="#直方图比较" class="headerlink" title="直方图比较"></a>直方图比较</h3><ul><li>对输入的两张图像进行直方图均衡化后，可以对两个图像的直方图进行对比，从对比的结果得到一些的结论。</li><li><code>cv2.compareHist(H1, H2, method)</code>：对比两个图像的直方图。<code>method</code>有三中可用：<ul><li><code>cv2.HISTCMP_BHATTACHARYYA</code>：巴氏距离，越小越相似。</li><li><code>cv2.HISTCMP_CORREL</code>：相关性，越大越相似。</li><li><code>cv2.HISTCMP_CHISQR</code>：卡方，越大越不相似。</li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">create_rgb_hist</span>(<span class="params">image</span>):</span></span><br><span class="line">    h, w, c = image.shape</span><br><span class="line">    rgbHist = np.zeros([<span class="number">16</span> * <span class="number">16</span> * <span class="number">16</span>, <span class="number">1</span>], np.float32)</span><br><span class="line">    bsize = <span class="number">256</span> / <span class="number">16</span></span><br><span class="line">    <span class="keyword">for</span> row <span class="keyword">in</span> <span class="built_in">range</span>(h):</span><br><span class="line">        <span class="keyword">for</span> col <span class="keyword">in</span> <span class="built_in">range</span>(w):</span><br><span class="line">            b = image[row, col, <span class="number">0</span>]</span><br><span class="line">            g = image[row, col, <span class="number">1</span>]</span><br><span class="line">            r = image[row, col, <span class="number">2</span>]</span><br><span class="line">            index = np.<span class="built_in">int</span>(b / bsize) * <span class="number">16</span> * <span class="number">16</span> + np.<span class="built_in">int</span>(g / bsize) * <span class="number">16</span> + np.<span class="built_in">int</span>(r / bsize)</span><br><span class="line">            rgbHist[np.<span class="built_in">int</span>(index), <span class="number">0</span>] = rgbHist[np.<span class="built_in">int</span>(index), <span class="number">0</span>] + <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> rgbHist</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hist_compare</span>(<span class="params">image1, image2</span>):</span></span><br><span class="line">    hist1 = create_rgb_hist(image1)</span><br><span class="line">    hist2 = create_rgb_hist(image2)</span><br><span class="line">    match1 = cv2.compareHist(hist1, hist2, cv2.HISTCMP_BHATTACHARYYA)</span><br><span class="line">    match2 = cv2.compareHist(hist1, hist2, cv2.HISTCMP_CORREL)</span><br><span class="line">    match3 = cv2.compareHist(hist1, hist2, cv2.HISTCMP_CHISQR)</span><br><span class="line">    <span class="comment"># 巴氏距离越小越相似，相关性越大越相似，卡方越大越不相似</span></span><br><span class="line">    print(<span class="string">&quot;巴氏距离&quot;</span>, match1)</span><br><span class="line">    print(<span class="string">&quot;相关性&quot;</span>, match2)</span><br><span class="line">    print(<span class="string">&quot;卡方&quot;</span>, match3)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    img1 = cv2.imread(<span class="string">&quot;img5.jpg&quot;</span>)</span><br><span class="line">    img2 = cv2.imread(<span class="string">&quot;img6.jpg&quot;</span>)</span><br><span class="line">    cv2.imshow(<span class="string">&quot;img1&quot;</span>, img1)</span><br><span class="line">    cv2.imshow(<span class="string">&quot;img2&quot;</span>, img2)</span><br><span class="line">    hist_compare(img1, img2)</span><br><span class="line">    cv2.waitKey(<span class="number">0</span>)</span><br><span class="line">    cv2.destroyAllWindows()</span><br></pre></td></tr></table></figure><p><img src="https://img2018.cnblogs.com/blog/760885/201906/760885-20190626155749111-319065259.png" alt="img"></p><h3 id="直方图反投影"><a href="#直方图反投影" class="headerlink" title="直方图反投影"></a>直方图反投影</h3><h4 id="定义-3"><a href="#定义-3" class="headerlink" title="定义"></a>定义</h4><ul><li>直方图反投影，常用于图像分割或在图像中查找感兴趣的对象。本质是定位模板图像在输入图像的位置。</li><li>直方图反投影，一般使用的是颜色直方图，颜色直方图比灰度直方图更容易定义对象。</li><li>流程：1. 选定一个目标图像，这个图像应包含并尽可能填充我们的检测目标对象；2. 创建该图像的直方图；3. 将该直方图反投影到需要检测的测试图像上，计算出每个像素属于该目标的概率。</li><li>直方图反投影可以与 camshift 算法等配合使用。</li><li>我选择 U-Net。</li></ul><h4 id="OpenCV的反投影"><a href="#OpenCV的反投影" class="headerlink" title="OpenCV的反投影"></a>OpenCV的反投影</h4><ul><li><code>cv2.calcBackProject(images, channels, hist, ranges, scale, dst)</code>：<ul><li><code>hist</code>：目标进行归一化后的直方图。</li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"></span><br><span class="line">roi = cv2.imread(<span class="string">&#x27;rose_red.png&#x27;</span>)</span><br><span class="line">hsv = cv2.cvtColor(roi, cv2.COLOR_BGR2HSV)</span><br><span class="line">target = cv2.imread(<span class="string">&#x27;rose.png&#x27;</span>)</span><br><span class="line">hsvt = cv2.cvtColor(target, cv2.COLOR_BGR2HSV)</span><br><span class="line"><span class="comment"># 1. 计算检测目标的直方图</span></span><br><span class="line">roihist = cv2.calcHist([hsv], [<span class="number">0</span>, <span class="number">1</span>], <span class="literal">None</span>, [<span class="number">180</span>, <span class="number">256</span>], [<span class="number">0</span>, <span class="number">180</span>, <span class="number">0</span>, <span class="number">256</span>])</span><br><span class="line"><span class="comment"># 2. 归一化目标直方图</span></span><br><span class="line">cv2.normalize(roihist, roihist, <span class="number">0</span>, <span class="number">255</span>, cv2.NORM_MINMAX)</span><br><span class="line"><span class="comment"># 3. 反传算法</span></span><br><span class="line">dst = cv2.calcBackProject([hsvt], channels=[<span class="number">0</span>, <span class="number">1</span>], hist=roihist, ranges=[<span class="number">0</span>, <span class="number">180</span>, <span class="number">0</span>, <span class="number">256</span>], scale=<span class="number">1</span>)</span><br><span class="line"><span class="comment"># 4. 用圆盘卷积核对概率图像进行均值滤波</span></span><br><span class="line">disc = cv2.getStructuringElement(cv2.MORPH_ELLIPSE, (<span class="number">5</span>, <span class="number">5</span>))</span><br><span class="line">cv2.filter2D(dst, -<span class="number">1</span>, disc, dst)</span><br><span class="line"><span class="comment"># 5. 应用阈值作，获得mask</span></span><br><span class="line">ret, thresh = cv2.threshold(dst, <span class="number">50</span>, <span class="number">255</span>, <span class="number">0</span>)</span><br><span class="line">thresh = cv2.merge((thresh, thresh, thresh))</span><br><span class="line">res = cv2.bitwise_and(target, thresh)</span><br><span class="line">res = np.vstack((target, thresh, res))  <span class="comment"># 上下拼接</span></span><br><span class="line">cv2.imwrite(<span class="string">&#x27;res.jpg&#x27;</span>, res)</span><br></pre></td></tr></table></figure><ul><li><p>如下示例中，蓝色矩形的区域为目标对象，使用直方图反投影提取整个地面。</p><img src="/2021/08/OpenCV-Part4/backproject_opencv.jpg" alt="img" style="zoom: 33%;"></li></ul><h2 id="傅里叶变换"><a href="#傅里叶变换" class="headerlink" title="傅里叶变换"></a>傅里叶变换</h2><h3 id="定义-4"><a href="#定义-4" class="headerlink" title="定义"></a>定义</h3><ul><li><p>傅立叶变换，可以用于分析各种滤波器的频率特性。</p></li><li><p>对于正弦信号：如果幅度在短时间内变化快，则为高频信号；如果变化慢，则为低频信号。</p><p>可以将相同的想法扩展到图像：图像中的振幅在边缘点或噪声急剧变化，边缘和噪声就是图像中的高频内容；如果图像中幅度没有太大变化，则就是低频分量。</p></li><li><p>傅里叶变换，可以将一幅图片分解为正弦和余弦两个分量，即可以将一幅图像从其空间域（spatial domain）转换为频域（frequency domain）。</p></li></ul><blockquote><p>详细讲解傅里叶的文章：</p><ul><li><a href="https://zhuanlan.zhihu.com/p/19759362">https://zhuanlan.zhihu.com/p/19759362</a></li><li><a href="https://zhuanlan.zhihu.com/p/28478034">https://zhuanlan.zhihu.com/p/28478034</a></li></ul></blockquote><ul><li><p><img src="/2021/08/OpenCV-Part4/bb8de9d8a622ec08852a334ed34f404b_b.jpg" alt="img"></p></li><li><p>正弦波就是一个圆周运动在一条直线上的投影。所以频域的基本单元也可以理解为一个始终在旋转的圆：</p><img src="/2021/08/OpenCV-Part4/Fourier_series_square_wave_circles_animation.gif" alt="File:Fourier series square wave circles animation.gif" style="zoom: 80%;"></li><li><p>时域与频域之间的联系：</p><img src="/2021/08/OpenCV-Part4/Fourier_series_and_transform.gif" alt="File:Fourier series and transform.gif" style="zoom:80%;"></li></ul><h3 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h3><ol><li><p>灰度图 与 傅里叶变换：</p><ul><li><p>可以看到白色区域大多在中心，显示低频率的内容比较多。</p></li><li><img src="/2021/08/OpenCV-Part4/image-20210903141954326.png" alt="image-20210903141954326" style="zoom: 30%;"></li></ul></li><li><p>傅里叶变换删去低频内容：</p><ul><li><p>删除图像中的低频内容，即将HPF应用于图像，本质是提取边缘。</p></li><li><img src="/2021/08/OpenCV-Part4/image-20210903142034836.png" alt="image-20210903142034836" style="zoom: 67%;"></li></ul></li><li><p>傅里叶变换删去高频内容：</p><ul><li><p>删除图像中的高频内容，即将LPF应用于图像，本质是模糊图像。</p></li><li><img src="/2021/08/OpenCV-Part4/image-20210903142118824.png" alt="image-20210903142118824" style="zoom: 33%;"></li></ul></li><li><p>各滤波器是 HPF（High Pass Filter）还是 LPF（Low Pass Filter）：</p><ul><li><p>白点在中间的就是 LPF ，白点在四周的就是 HPF。</p></li><li><img src="http://qiniu.aihubs.net/fft5.jpg" alt="img" style="zoom:80%;"></li></ul></li></ol><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><ul><li>对于图像，可以使用2D离散傅里叶变换（DFT, 2D Discrete Fourier Transform）查找频域。同时，可以使用快速傅立叶变换（FFT, Fast Fourier Transform）的快速算法用于DFT的计算。</li><li>OpenCV使用 <code>cv2.dft()</code>、<code>cv2.idft()</code> 实现傅里叶变换，效率更高。</li><li>Numpy使用 <code>np.ifft2()</code>、<code>np.fft.ifftshift()</code> 实现傅里叶变换，使用更友好。</li><li>DFT的性能优化：在一定的阵列尺寸下，DFT计算的性能较好。当数组大小为2的幂时，速度最快。大小为2、3和5的乘积的数组也可以非常有效地处理。<br>为达到最佳性能，可以通过OpenCV提供的函数 <code>cv2.getOptimalDFTSize()</code> 寻找最佳尺寸。<br>然后将图像填充成最佳性能大小的阵列：1. 对于OpenCV，必须手动填充零；2. 对于Numpy，可以指定FFT计算的新大小，自动填充零。</li><li>通过使用最优阵列，大概能提升4倍的效率。而OpenCV本身也比Numpy效率快近3倍。</li></ul><h4 id="Numpy中的傅里叶变换"><a href="#Numpy中的傅里叶变换" class="headerlink" title="Numpy中的傅里叶变换"></a>Numpy中的傅里叶变换</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> matplotlib <span class="keyword">import</span> pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">img = cv2.imread(<span class="string">&#x27;test.jpg&#x27;</span>, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 1. 使用Numpy实现傅里叶变换 fft.fft2()</span></span><br><span class="line">f = np.fft.fft2(img)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 一旦得到结果，零频率分量（直流分量）将出现在左上角。</span></span><br><span class="line"><span class="comment"># 如果要将其置于中心，则需要使用 np.fft.fftshift() 将结果在两个方向上移动。</span></span><br><span class="line"><span class="comment"># 一旦找到了频率变换，就能找到幅度谱。</span></span><br><span class="line">fshift = np.fft.fftshift(f)</span><br><span class="line">magnitude_spectrum = <span class="number">20</span> * np.log(np.<span class="built_in">abs</span>(fshift))</span><br><span class="line"></span><br><span class="line">plt.subplot(<span class="number">121</span>), plt.imshow(img, cmap=<span class="string">&#x27;gray&#x27;</span>)</span><br><span class="line">plt.title(<span class="string">&#x27;Input Image&#x27;</span>), plt.xticks([]), plt.yticks([])</span><br><span class="line">plt.subplot(<span class="number">122</span>), plt.imshow(magnitude_spectrum, cmap=<span class="string">&#x27;gray&#x27;</span>)</span><br><span class="line">plt.title(<span class="string">&#x27;Magnitude Spectrum&#x27;</span>), plt.xticks([]), plt.yticks([])</span><br><span class="line">plt.show()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. 找到了频率变换，就可以进行高通滤波和重建图像，也就是求逆DFT</span></span><br><span class="line">rows, cols = img.shape</span><br><span class="line">crow, ccol = rows // <span class="number">2</span>, cols // <span class="number">2</span></span><br><span class="line">fshift[crow - <span class="number">30</span>:crow + <span class="number">30</span>, ccol - <span class="number">30</span>:ccol + <span class="number">30</span>] = <span class="number">0</span></span><br><span class="line">f_ishift = np.fft.ifftshift(fshift)</span><br><span class="line">img_back = np.fft.ifft2(f_ishift)</span><br><span class="line">img_back = np.<span class="built_in">abs</span>(img_back)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 4. 众所周知，高通滤波是一种边缘检测操作。这也表明大部分图像数据存在于频谱的低频区域。</span></span><br><span class="line"><span class="comment"># 仔细观察结果可以看到最后一张用JET颜色显示的图像，有一些瑕疵，即显示了一些波纹状的结构，这是振铃效应。</span></span><br><span class="line"><span class="comment"># 这是由于用矩形窗口mask造成的，掩码mask被转换为sinc形状，从而导致此问题。所以矩形窗口不用于过滤，更好的选择是高斯mask。</span></span><br><span class="line">plt.subplot(<span class="number">131</span>), plt.imshow(img, cmap=<span class="string">&#x27;gray&#x27;</span>)</span><br><span class="line">plt.title(<span class="string">&#x27;Input Image&#x27;</span>), plt.xticks([]), plt.yticks([])</span><br><span class="line">plt.subplot(<span class="number">132</span>), plt.imshow(img_back, cmap=<span class="string">&#x27;gray&#x27;</span>)</span><br><span class="line">plt.title(<span class="string">&#x27;Image after HPF&#x27;</span>), plt.xticks([]), plt.yticks([])</span><br><span class="line">plt.subplot(<span class="number">133</span>), plt.imshow(img_back)</span><br><span class="line">plt.title(<span class="string">&#x27;Result in JET&#x27;</span>), plt.xticks([]), plt.yticks([])</span><br><span class="line"></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><h4 id="OpenCV中的傅里叶变换"><a href="#OpenCV中的傅里叶变换" class="headerlink" title="OpenCV中的傅里叶变换"></a>OpenCV中的傅里叶变换</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> matplotlib <span class="keyword">import</span> pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">img = cv2.imread(<span class="string">&#x27;test.jpg&#x27;</span>, <span class="number">0</span>)</span><br><span class="line">rows, cols = img.shape</span><br><span class="line"></span><br><span class="line"><span class="comment"># 1. 计算DFT效率最佳的尺寸</span></span><br><span class="line">nrows = cv2.getOptimalDFTSize(rows)</span><br><span class="line">ncols = cv2.getOptimalDFTSize(cols)</span><br><span class="line">print(<span class="string">f&quot;rows: <span class="subst">&#123;rows&#125;</span>-&gt;<span class="subst">&#123;nrows&#125;</span>; cols: <span class="subst">&#123;cols&#125;</span>-&gt;<span class="subst">&#123;ncols&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 将大小扩充成2、3和5的乘积</span></span><br><span class="line">nimg = np.zeros((nrows, ncols))</span><br><span class="line">nimg[:rows, :cols] = img</span><br><span class="line">img = nimg</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. OpenCV计算快速傅里叶变换: 输入图像应首先转换为 np.float32 ，然后使用函数 cv2.dft() 和 cv2.idft() 。</span></span><br><span class="line"><span class="comment"># 返回结果与Numpy相同，但有两个通道。第一个通道为有结果的实部，第二个通道为有结果的虚部。</span></span><br><span class="line">dft = cv2.dft(np.float32(img), flags=cv2.DFT_COMPLEX_OUTPUT)</span><br><span class="line">dft_shift = np.fft.fftshift(dft)</span><br><span class="line">magnitude_spectrum = <span class="number">20</span> * np.log(cv2.magnitude(dft_shift[:, :, <span class="number">0</span>], dft_shift[:, :, <span class="number">1</span>]))</span><br><span class="line"></span><br><span class="line">plt.subplot(<span class="number">121</span>), plt.imshow(img, cmap=<span class="string">&#x27;gray&#x27;</span>)</span><br><span class="line">plt.title(<span class="string">&#x27;Input Image&#x27;</span>), plt.xticks([]), plt.yticks([])</span><br><span class="line">plt.subplot(<span class="number">122</span>), plt.imshow(magnitude_spectrum, cmap=<span class="string">&#x27;gray&#x27;</span>)</span><br><span class="line">plt.title(<span class="string">&#x27;Magnitude Spectrum&#x27;</span>), plt.xticks([]), plt.yticks([])</span><br><span class="line">plt.show()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 4. 删除图像中的高频内容(将LPF应用于图像/模糊图像)</span></span><br><span class="line"><span class="comment"># 首先创建一个在低频时具有高值的mask掩码，中心正方形为1，其他均为0。即传递LF内容，在HF区域为0。</span></span><br><span class="line">rows, cols = img.shape</span><br><span class="line">crow, ccol = rows // <span class="number">2</span>, cols // <span class="number">2</span></span><br><span class="line">mask = np.zeros((rows, cols, <span class="number">2</span>), np.uint8)</span><br><span class="line">mask[crow - <span class="number">30</span>:crow + <span class="number">30</span>, ccol - <span class="number">30</span>:ccol + <span class="number">30</span>] = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 5. 应用掩码Mask和求逆DTF</span></span><br><span class="line">fshift = dft_shift * mask</span><br><span class="line">f_ishift = np.fft.ifftshift(fshift)</span><br><span class="line">img_back = cv2.idft(f_ishift)</span><br><span class="line">img_back = cv2.magnitude(img_back[:, :, <span class="number">0</span>], img_back[:, :, <span class="number">1</span>])</span><br><span class="line"></span><br><span class="line">plt.subplot(<span class="number">121</span>), plt.imshow(img, cmap=<span class="string">&#x27;gray&#x27;</span>)</span><br><span class="line">plt.title(<span class="string">&#x27;Input Image&#x27;</span>), plt.xticks([]), plt.yticks([])</span><br><span class="line">plt.subplot(<span class="number">122</span>), plt.imshow(img_back, cmap=<span class="string">&#x27;gray&#x27;</span>)</span><br><span class="line">plt.title(<span class="string">&#x27;Magnitude Spectrum&#x27;</span>), plt.xticks([]), plt.yticks([])</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><h4 id="HPF-or-LPF"><a href="#HPF-or-LPF" class="headerlink" title="HPF or LPF"></a>HPF or LPF</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> matplotlib <span class="keyword">import</span> pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 简单的均值滤波</span></span><br><span class="line">mean_filter = np.ones((<span class="number">3</span>, <span class="number">3</span>))</span><br><span class="line"><span class="comment"># 构建高斯滤波</span></span><br><span class="line">x = cv2.getGaussianKernel(<span class="number">5</span>, <span class="number">10</span>)</span><br><span class="line">gaussian = x * x.T</span><br><span class="line"><span class="comment"># 不同的边缘检测算法Scharr-x方向</span></span><br><span class="line">scharr = np.array([[-<span class="number">3</span>, <span class="number">0</span>, <span class="number">3</span>],</span><br><span class="line">                   [-<span class="number">10</span>, <span class="number">0</span>, <span class="number">10</span>],</span><br><span class="line">                   [-<span class="number">3</span>, <span class="number">0</span>, <span class="number">3</span>]])</span><br><span class="line"><span class="comment"># Sobel_x</span></span><br><span class="line">sobel_x = np.array([[-<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>],</span><br><span class="line">                    [-<span class="number">2</span>, <span class="number">0</span>, <span class="number">2</span>],</span><br><span class="line">                    [-<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>]])</span><br><span class="line"><span class="comment"># Sobel_y</span></span><br><span class="line">sobel_y = np.array([[-<span class="number">1</span>, -<span class="number">2</span>, -<span class="number">1</span>],</span><br><span class="line">                    [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">                    [<span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>]])</span><br><span class="line"><span class="comment"># 拉普拉斯</span></span><br><span class="line">laplacian = np.array([[<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>],</span><br><span class="line">                      [<span class="number">1</span>, -<span class="number">4</span>, <span class="number">1</span>],</span><br><span class="line">                      [<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>]])</span><br><span class="line"></span><br><span class="line">filters = [mean_filter, gaussian, laplacian, sobel_x, sobel_y, scharr]</span><br><span class="line">filter_name = [<span class="string">&#x27;mean_filter&#x27;</span>, <span class="string">&#x27;gaussian&#x27;</span>, <span class="string">&#x27;laplacian&#x27;</span>, <span class="string">&#x27;sobel_x&#x27;</span>, <span class="string">&#x27;sobel_y&#x27;</span>, <span class="string">&#x27;scharr_x&#x27;</span>]</span><br><span class="line">fft_filters = [np.fft.fft2(x) <span class="keyword">for</span> x <span class="keyword">in</span> filters]</span><br><span class="line">fft_shift = [np.fft.fftshift(y) <span class="keyword">for</span> y <span class="keyword">in</span> fft_filters]</span><br><span class="line">mag_spectrum = [np.log(np.<span class="built_in">abs</span>(z) + <span class="number">1</span>) <span class="keyword">for</span> z <span class="keyword">in</span> fft_shift]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">6</span>):</span><br><span class="line">    plt.subplot(<span class="number">2</span>, <span class="number">3</span>, i + <span class="number">1</span>), plt.imshow(mag_spectrum[i], cmap=<span class="string">&#x27;gray&#x27;</span>)</span><br><span class="line">    plt.title(filter_name[i]), plt.xticks([]), plt.yticks([])</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><h2 id="模板匹配"><a href="#模板匹配" class="headerlink" title="模板匹配"></a>模板匹配</h2><ul><li>模板匹配，在较大图像中查找模板图像位置的方法。</li><li>我选择深度学习。</li></ul><h3 id="OpenCV中的模板匹配"><a href="#OpenCV中的模板匹配" class="headerlink" title="OpenCV中的模板匹配"></a>OpenCV中的模板匹配</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">from</span> matplotlib <span class="keyword">import</span> pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">img = cv2.imread(<span class="string">&#x27;test.jpg&#x27;</span>, <span class="number">0</span>)</span><br><span class="line">template = cv2.imread(<span class="string">&#x27;test2.png&#x27;</span>, <span class="number">0</span>)</span><br><span class="line">w, h = template.shape[::-<span class="number">1</span>]</span><br><span class="line"><span class="comment"># 列表中所有的6种比较方法</span></span><br><span class="line">methods = [<span class="string">&#x27;cv2.TM_CCOEFF&#x27;</span>, <span class="string">&#x27;cv2.TM_CCOEFF_NORMED&#x27;</span>, <span class="string">&#x27;cv2.TM_CCORR&#x27;</span>,</span><br><span class="line">           <span class="string">&#x27;cv2.TM_CCORR_NORMED&#x27;</span>, <span class="string">&#x27;cv2.TM_SQDIFF&#x27;</span>, <span class="string">&#x27;cv2.TM_SQDIFF_NORMED&#x27;</span>]</span><br><span class="line"><span class="keyword">for</span> meth <span class="keyword">in</span> methods:</span><br><span class="line">    img_ = img.copy()</span><br><span class="line">    method = <span class="built_in">eval</span>(meth)</span><br><span class="line">    <span class="comment"># 应用模板匹配</span></span><br><span class="line">    res = cv2.matchTemplate(img_, template, method)</span><br><span class="line">    min_val, max_val, min_loc, max_loc = cv2.minMaxLoc(res)</span><br><span class="line">    <span class="comment"># 如果方法是TM_SQDIFF或TM_SQDIFF_NORMED，则取最小值</span></span><br><span class="line">    <span class="keyword">if</span> method <span class="keyword">in</span> [cv2.TM_SQDIFF, cv2.TM_SQDIFF_NORMED]:</span><br><span class="line">        top_left = min_loc</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        top_left = max_loc</span><br><span class="line">    bottom_right = (top_left[<span class="number">0</span>] + w, top_left[<span class="number">1</span>] + h)</span><br><span class="line">    cv2.rectangle(img_, top_left, bottom_right, <span class="number">255</span>, <span class="number">2</span>)</span><br><span class="line">    </span><br><span class="line">    plt.subplot(<span class="number">121</span>), plt.imshow(res, cmap=<span class="string">&#x27;gray&#x27;</span>)</span><br><span class="line">    plt.title(<span class="string">&#x27;Matching Result&#x27;</span>), plt.xticks([]), plt.yticks([])</span><br><span class="line">    plt.subplot(<span class="number">122</span>), plt.imshow(img_, cmap=<span class="string">&#x27;gray&#x27;</span>)</span><br><span class="line">    plt.title(<span class="string">&#x27;Detected Point&#x27;</span>), plt.xticks([]), plt.yticks([])</span><br><span class="line">    plt.suptitle(meth)</span><br><span class="line">    plt.show()</span><br></pre></td></tr></table></figure><h3 id="多对象模板匹配"><a href="#多对象模板匹配" class="headerlink" title="多对象模板匹配"></a>多对象模板匹配</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">img_rgb = cv2.imread(<span class="string">&#x27;mario.png&#x27;</span>)</span><br><span class="line">img_gray = cv2.cvtColor(img_rgb, cv2.COLOR_BGR2GRAY)</span><br><span class="line">template = cv2.imread(<span class="string">&#x27;mario_coin.png&#x27;</span>, <span class="number">0</span>)</span><br><span class="line">w, h = template.shape[::-<span class="number">1</span>]</span><br><span class="line">res = cv2.matchTemplate(img_gray, template, cv2.TM_CCOEFF_NORMED)</span><br><span class="line">threshold = <span class="number">0.8</span></span><br><span class="line">loc = np.where(res &gt;= threshold)</span><br><span class="line"><span class="keyword">for</span> pt <span class="keyword">in</span> <span class="built_in">zip</span>(*loc[::-<span class="number">1</span>]):</span><br><span class="line">    cv2.rectangle(img_rgb, pt, (pt[<span class="number">0</span>] + w, pt[<span class="number">1</span>] + h), (<span class="number">0</span>, <span class="number">0</span>, <span class="number">255</span>), <span class="number">2</span>)</span><br><span class="line">cv2.imwrite(<span class="string">&#x27;res.png&#x27;</span>, img_rgb)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> OpenCV </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>OpenCV-Part3</title>
      <link href="/2021/08/OpenCV-Part3/"/>
      <url>/2021/08/OpenCV-Part3/</url>
      
        <content type="html"><![CDATA[<h1 id="OpenCV-Part3——图像处理（中）"><a href="#OpenCV-Part3——图像处理（中）" class="headerlink" title="OpenCV-Part3——图像处理（中）"></a>OpenCV-Part3——图像处理（中）</h1><p>[TOC]</p><h2 id="图像边缘检测"><a href="#图像边缘检测" class="headerlink" title="图像边缘检测"></a>图像边缘检测</h2><h3 id="边缘检测"><a href="#边缘检测" class="headerlink" title="边缘检测"></a>边缘检测</h3><ul><li>边缘是图像中的重要的结构性特征，边缘往往存在于目标和背景之间、不同的区域之间，因此它可以作为图像分割的重要依据。</li><li>边缘检测是检测图像中的像素点，其周围的像素值是否发生了急剧的变化，这个剧烈的变化就是不同物体的边界。<ul><li>边缘其实就是图像上灰度级变化很快、梯度很大的点的集合。</li><li>图像的梯度可以用一阶导数和二阶偏导数来求解。</li><li>边缘检测提取的是图像中不连续部分的特征，将闭合的边缘提取出来便可以作为一个区域。</li></ul></li><li>与区域划分相比，边缘检测不需要逐个的对像素进行比较，比较适合大图像的处理。</li><li>图像数据以二/三维矩阵的形式存储的，对一幅图像的求导相当于对一个曲面求导。<ul><li>对图像求导、获取一幅图像的梯度：使用模板（Roberts、Prewitt、Sobel、Lapacian算子）对原图像进行卷积。</li><li>OpenCV 提供的梯度滤波器（高通滤波器）：Sobel、Scharr、Laplacian、Canny。</li><li>使用一阶导的算子有 Prewitt、Sobel、Canny；使用二阶导的有 Lapacian 。Scharr 是对 Sobel（使用小的卷积核求解求解梯度角度时）的优化。</li></ul></li></ul><h3 id="各种算子比较"><a href="#各种算子比较" class="headerlink" title="各种算子比较"></a>各种算子比较</h3><h4 id="Roberts-算子"><a href="#Roberts-算子" class="headerlink" title="Roberts 算子"></a>Roberts 算子</h4><ul><li>Roberts 算子又称为交叉微分算子，是基于交叉差分的一阶微分算子。比较简单，计算量小。</li><li>Roberts 常用来处理具有陡峭的低噪声图像，当图像边缘接近于正 45° 或负 45° 时，该算法处理效果更理想。其缺点是对边缘的定位不太准确，提取的边缘线条较粗。</li><li>对应的模板：<img src="/2021/08/OpenCV-Part3/20200604163101990-163037519253316.png" alt="img"></li></ul><h4 id="Prewitt-算子"><a href="#Prewitt-算子" class="headerlink" title="Prewitt 算子"></a>Prewitt 算子</h4><ul><li><p>Prewitt 算子也是一种一阶微分算子。由 Roberts 的 2×2 改为 3×3 模板矩阵，增加了计算量。</p></li><li><p>Prewitt 在水平方向和垂直方向分别利用两个方向模板与图像进行邻域卷积，边缘检测效果比 Robert 算子更加明显。</p></li><li><p>Prewitt 在权重上对局部像素进行了平均，对噪声有抑制作用。但是同时像素平均也代表了对图像的低通滤波，所以 Prewitt 算子对边缘的定位不如 Roberts 算子。</p></li><li><p>Prewitt 会造成边缘点的误判，因为许多噪声点的灰度值也很大。而且对于幅值较小的边缘点，其边缘反而丢失了。</p></li><li><p>对应的模板：<img src="/2021/08/OpenCV-Part3/image-20210830155817284.png" alt="image-20210830155817284" style="zoom: 67%;"></p></li></ul><h4 id="Sobel-算子"><a href="#Sobel-算子" class="headerlink" title="Sobel 算子"></a>Sobel 算子</h4><ul><li><p>Sobel 是结合了高斯平滑与微分求导的一阶微分算子。在 Prewitt 基础上，将权值改为符合高斯分布。</p></li><li><p>Sobel 考虑了不同距离的相邻点对当前像素点的影响，距离越近的像素点对应当前像素的影响越大，从而实现锐化边缘。因此，比 Prewitt 和 Roberts 都更能准确检测图像边缘。</p></li><li><p>Sobel 算子根据像素点上下左右邻点灰度加权差，在边缘处达到极值这一现象检测边缘，对噪声具有平滑作用，并提供较为精确的边缘方向信息。</p></li><li><p>对应的模板：<img src="/2021/08/OpenCV-Part3/image-20210830155931977.png" alt="image-20210830155931977"></p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">img = cv2.imread(<span class="string">&#x27;box.png&#x27;</span>, <span class="number">0</span>)</span><br><span class="line"><span class="comment"># 使用float64为了保留负数信息</span></span><br><span class="line">sobelx = cv2.Sobel(img, cv2.CV_64F, <span class="number">1</span>, <span class="number">0</span>, ksize=<span class="number">5</span>)</span><br><span class="line">sobely = cv2.Sobel(img, cv2.CV_64F, <span class="number">0</span>, <span class="number">1</span>, ksize=<span class="number">5</span>)</span><br></pre></td></tr></table></figure><h4 id="Laplacian-算子"><a href="#Laplacian-算子" class="headerlink" title="Laplacian 算子"></a>Laplacian 算子</h4><ul><li><p>拉普拉斯（Laplacian）是一个二阶微分算子，是二阶 Sobel 导数，常用于图像增强和边缘提取。</p></li><li><p>Laplacian 原理：在卷积邻域内，如果中心像素的灰度更高，则提升中心像素的灰度；反之则降低中心像素的灰度。</p><ol><li>模板与图像进行卷积运算：当中心像素灰度等于邻域内其他像素的平均灰度时，结果为0；当中心像素高于平均灰度时，结果为正数；当中心像素低于平均灰度时，结果为负数。</li><li>对上述卷积运算结果用适当的衰弱因子处理后，加在原中心像素上，就可以实现图像的锐化处理。</li></ol></li><li><p>Laplacian 算子模板分为四邻域和八邻域，四邻域是对邻域中心像素的四方向求梯度，八邻域是对八方向求梯度。</p><ol><li>四邻域模板：<img src="/2021/08/OpenCV-Part3/20200604163300437.png" alt="img" style="zoom:67%;"></li><li>八邻域模板：<img src="/2021/08/OpenCV-Part3/20200604163310938.png" alt="img" style="zoom:67%;"></li></ol></li><li><p>Laplacian 用于图像增强时，有这几个比较适合的场合。</p><ul><li>由于是通过二次微分正峰和负峰之间的过零点来确定边缘线的位置，因此对孤立点或端点更为敏感，这一特性适用于以突出图像中的孤立点、孤立线或线端点为目的的场合。</li><li>用来改善因扩散效应的模糊特别有效，因为它符合降制模型。扩散效应是成像过程中经常发生的现象。</li></ul></li><li><p>Laplacian 用于边缘提取时，一般不使用其原始形式。它对于边缘和噪声都非常敏感，在锐化边缘的同时也会增强图像中的噪声，所以需要先对图像进行平滑处理。</p><ul><li>原因：1. Laplacian 对噪声具有无法接受的敏感性；2. 同时其幅值产生算边缘，这是复杂的分割不希望有的结果；3. 不能检测边缘的方向。</li><li>取而代之，一般使用的是高斯型拉普拉斯算子(Laplacian of a Gaussian,LoG)，利用该LoG算子进行卷积 等价于 高斯模糊+拉普拉斯。所以，在 LoG 中使用高斯函数的目的就是对图像进行平滑处理，使用 Laplacian 的目的是提供一幅由零交叉确定边缘位置的图像。图像的平滑处理减少了噪声的影响，并且还抵消由 Laplacian 算子的二阶导数引起的逐渐增加的噪声影响。</li></ul></li><li><p>Laplacian 用于图像分割时的作用：</p><ul><li>利用它的零交叉性质进行边缘定位。</li><li>确定一个像素是在一条边缘暗的一面还是亮的一面。</li></ul></li><li><p>图像锐化处理的作用是使灰度反差增强，从而使模糊图像变得更加清晰。图像模糊的实质就是图像受到平均运算或积分运算，因此可以对图像进行逆运算，如微分运算能够突出图像细节，使图像变得更为清晰。</p><p>由于拉普拉斯是一种微分算子，它的应用可增强图像中灰度突变的区域，减弱灰度的缓慢变化区域。因此，锐化处理可选择拉普拉斯算子对原图像进行处理，产生描述灰度突变的图像，再将拉普拉斯图像与原始图像叠加。最终结果是使图像中的各灰度值得到保留、灰度突变处的对比度得到增强，在保留图像背景的前提下，突现出图像中小的细节信息锐化图像。</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">img = cv2.imread(<span class="string">&#x27;box.png&#x27;</span>, <span class="number">0</span>)</span><br><span class="line">laplacian = cv2.Laplacian(img, cv2.CV_64F)</span><br></pre></td></tr></table></figure><p><img src="/2021/08/OpenCV-Part3/gradients.jpg" alt="img"></p><h4 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h4><ul><li><p>对于使用数据类型为<code>cv2.CV_8U</code>或<code>np.uint8</code>，会有一个小问题：黑色到白色的过渡被视为正斜率（具有正值），而白色到黑色的过渡被视为负斜率（具有负值）。因此，当将数据转换为np.uint8时，所有负斜率均设为零，即错过这一边缘信息。</p></li><li><p>如果要检测两个边缘，更好的选择是将输出数据类型保留为更高的形式，例如<code>cv2.CV_16S</code>，<code>cv2.CV_64F</code>等，取其绝对值，然后转换回<code>cv2.CV_8U</code>。 </p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">img = cv2.imread(<span class="string">&#x27;box.png&#x27;</span>, <span class="number">0</span>)</span><br><span class="line"><span class="comment"># Output dtype = cv2.CV_8U</span></span><br><span class="line">sobelx8u = cv2.Sobel(img, cv2.CV_8U, <span class="number">1</span>, <span class="number">0</span>, ksize=<span class="number">5</span>)</span><br><span class="line"><span class="comment"># Output dtype = cv2.CV_64F. Then take its absolute and convert to cv.CV_8U</span></span><br><span class="line">sobelx64f = cv2.Sobel(img, cv2.CV_64F, <span class="number">1</span>, <span class="number">0</span>, ksize=<span class="number">5</span>)</span><br><span class="line">abs_sobel64f = np.absolute(sobelx64f)</span><br><span class="line">sobel_8u = np.uint8(abs_sobel64f)</span><br></pre></td></tr></table></figure> <img src="/2021/08/OpenCV-Part3/double_edge.jpg" alt="img" style="zoom:150%;"><h3 id="Canny边缘检测算子"><a href="#Canny边缘检测算子" class="headerlink" title="Canny边缘检测算子"></a>Canny边缘检测算子</h3><h4 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h4><ul><li><p>Canny 算子是一个具有滤波、增强、检测的多阶段的边缘检测算子。其产生的边缘很细，没有强弱之分，边缘检测性能比前面几种都要好。</p></li><li><p>Canny 的具体算法步骤：</p><ol><li><p>用高斯滤波器<strong>平滑图像</strong>；</p><ul><li>去除噪声。由于边缘检测很容易受到噪声影响，所以第一步是使用 5x5 的高斯滤波器去除噪声。</li></ul></li><li><p>用一阶偏导的有限差分来<strong>计算并记录梯度和幅值方向</strong>；</p><ul><li><p>对平滑后的图像使用 Sobel 算子计算水平方向和竖直方向的一阶导数（图像梯度）Gx 和 Gy 。根据得到的这两幅梯度图 Gx 和 Gy 找到边界的梯度和方向，公式如下：</p><img src="/2021/08/OpenCV-Part3/image-20210831114755186.png" alt="image-20210831114755186" style="zoom:80%;"></li><li><p>梯度的方向一般总是与边界垂直。梯度方向被归为四类：垂直，水平，和两个对角线。</p></li></ul></li><li><p>对梯度幅值进行<strong>非极大值抑制</strong>：</p><ul><li><p>在获得梯度的方向和大小之后，应该对整幅图像做一个扫描，去除那些非边界上的点。对每一个像素进行检查，看这个点的梯度是不是周围具有相同梯度方向的点中最大的。</p><img src="/2021/08/OpenCV-Part3/image-20210831115028137.png" alt="image-20210831115028137" style="zoom:80%;"></li><li><p>现在你得到的是一个包含“窄边界”的二值图像。</p></li></ul></li><li><p>用<strong>双阈值算法检测和连接边缘</strong>：</p><ul><li><p>现在要确定那些边界才是真正的边界。这时我们需要设置两个阈值：minVal 和 maxVal。当图像的灰度梯度高于 maxVal 时被认为是真的边界，那些低于 minVal 的边界会被抛弃。如果介于两者之间的话，就要看这个点是否与某个被确定为真正的边界点相连，如果是就认为它也是边界点，如果不是就抛弃。</p><img src="/2021/08/OpenCV-Part3/image-20210831115538954.png" alt="image-20210831115538954" style="zoom: 67%;"></li><li><p>A 高于阈值 maxVal 所以是真正的边界点，C 虽然低于 maxVal 但高于minVal 并且与 A 相连，所以也被认为是真正的边界点。而 B 就会被抛弃，因为他不仅低于 maxVal 而且不与真正的边界点相连。所以选择合适的 maxVal和 minVal 对于能否得到好的结果非常重要。在这一步一些小的噪声点也会被除去，因为我们假设边界都是一些长的线段。</p></li></ul></li></ol></li></ul><h4 id="OpenCV中的Canny检测"><a href="#OpenCV中的Canny检测" class="headerlink" title="OpenCV中的Canny检测"></a>OpenCV中的Canny检测</h4><ul><li><code>cv2.Canny(src, threshold1, threshold2)</code>：封装了 Canny 的所有步骤。<ul><li><code>threshold1, threshold2</code>：即双阈值算法的 minVal 和 maxVal 。</li><li><code>perture_size</code>：用于查找图像渐变的 Sobel 内核的大小。默认为3。</li><li><code>L2gradient</code>：用于查找梯度幅度的方程式。如果为<code>True</code>，则使用更精确的公式，默认为<code>False</code>。</li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">edges = cv2.Canny(img, threshold1=<span class="number">100</span>, threshold2=<span class="number">200</span>)  <span class="comment"># 建议放入彩色图</span></span><br></pre></td></tr></table></figure><h2 id="图像金字塔"><a href="#图像金字塔" class="headerlink" title="图像金字塔"></a>图像金字塔</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><ul><li>图像金字塔，是同一图像、不同分辨率的图像的集合。</li><li>图像金字塔，可以协助同时在不同分辨率的相同图像中进行目标检测，即同时检测不同大小的对象，因为我们不能确定对象将会以多大的尺寸显示在图像中。</li></ul><h3 id="构造图像金字塔"><a href="#构造图像金字塔" class="headerlink" title="构造图像金字塔"></a>构造图像金字塔</h3><ul><li><p>构造图像金字塔一般包括二个步骤：</p><ol><li>利用低通滤波器平滑图像</li><li>对平滑后的图像进行采样</li></ol></li><li><p>有两种采样方式：上采样（分辨率逐级升高，不会恢复细节信息）和下采样（分辨率逐级降低，会丢失细节信息）。</p></li><li><p>使用函数<code>cv2.pyrDown()</code>和<code>cv2.pyrUp()</code>构建图像金字塔。</p><ul><li><code>cv2.pyrDown()</code>：从一个高分辨率大尺寸的图像向上构建一个金子塔（尺寸变小，分辨率降低）。</li><li><code>cv2.pyrUp()</code>：从一个低分辨率小尺寸的图像向下构建一个金子塔（尺寸变大，但分辨率不会增加）。</li></ul></li><li><p>下采样过后的层也称为 Octave 。</p><p><img src="/2021/08/OpenCV-Part3/v2-8c6640fe15ab1ecd253a4c06d3b40ddf_720w.jpg" alt="img"></p></li></ul><h4 id="高斯金字塔"><a href="#高斯金字塔" class="headerlink" title="高斯金字塔"></a>高斯金字塔</h4><ul><li>高斯金字塔的构造过程：<ol><li>用高斯内核与图像卷积。</li><li>删除所有偶数行列。</li></ol></li><li>此时<code>higher_reso</code>与<code>higher_reso2</code>是不一样的，因为一旦进行下采样就丢失了细节信息。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">higher_reso = cv2.imread(<span class="string">&#x27;messi5.jpg&#x27;</span>) </span><br><span class="line">lower_reso = cv2.pyrDown(higher_reso)  <span class="comment"># 下采样</span></span><br><span class="line">higher_reso2 = cv.pyrUp(lower_reso)  <span class="comment"># 上采样</span></span><br></pre></td></tr></table></figure><h4 id="拉普拉斯金字塔"><a href="#拉普拉斯金字塔" class="headerlink" title="拉普拉斯金字塔"></a>拉普拉斯金字塔</h4><ul><li>拉普拉斯金字塔由高斯金字塔的高低层级差形成，仅为图像边缘信息。</li><li>拉普拉斯金字塔可以用于图像压缩。</li></ul><h3 id="使用金字塔进行图像融合"><a href="#使用金字塔进行图像融合" class="headerlink" title="使用金字塔进行图像融合"></a>使用金字塔进行图像融合</h3><ul><li>金字塔另一种常用的应用是图像融合。将两个不同层级或不同图像的 Octave 经过变换成相同大小并堆叠在一起，这可以使图像获得不同的特征数据（特征融合）。</li></ul><ol><li>加载两个图像</li><li>查找两个图像的高斯金字塔（在此示例中， 级别数为6）</li><li>在高斯金字塔中，找到其拉普拉斯金字塔</li><li>然后在每个拉普拉斯金字塔级别中加入A的左半部分和B的右半部分</li><li>最后从此联合图像金字塔中重建原始图像。</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">A = cv2.imread(<span class="string">&#x27;test2.png&#x27;</span>)</span><br><span class="line">B = cv2.imread(<span class="string">&#x27;test.jpg&#x27;</span>)</span><br><span class="line"><span class="comment"># 注意：为了使后面可以逐渐减半，这里的尺寸必须为2的次幂</span></span><br><span class="line">A = cv2.resize(A, (<span class="number">256</span>, <span class="number">256</span>), interpolation=cv2.INTER_CUBIC)</span><br><span class="line">B = cv2.resize(B, (<span class="number">256</span>, <span class="number">256</span>), interpolation=cv2.INTER_CUBIC)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成高斯金字塔</span></span><br><span class="line">G = A.copy()</span><br><span class="line">gpA = [G]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>):</span><br><span class="line">    G = cv2.pyrDown(G)</span><br><span class="line">    gpA.append(G)</span><br><span class="line"></span><br><span class="line">G = B.copy()</span><br><span class="line">gpB = [G]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>):</span><br><span class="line">    G = cv2.pyrDown(G)</span><br><span class="line">    gpB.append(G)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 产生Laplacian金字塔</span></span><br><span class="line">lpA = [gpA[<span class="number">5</span>]]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>, <span class="number">0</span>, -<span class="number">1</span>):</span><br><span class="line">    GE = cv2.pyrUp(gpA[i])</span><br><span class="line">    L = cv2.subtract(gpA[i - <span class="number">1</span>], GE)</span><br><span class="line">    lpA.append(L)</span><br><span class="line"></span><br><span class="line">lpB = [gpB[<span class="number">5</span>]]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>, <span class="number">0</span>, -<span class="number">1</span>):</span><br><span class="line">    GE = cv2.pyrUp(gpB[i])</span><br><span class="line">    L = cv2.subtract(gpB[i - <span class="number">1</span>], GE)</span><br><span class="line">    lpB.append(L)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 合并</span></span><br><span class="line">LS = []</span><br><span class="line"><span class="keyword">for</span> la, lb <span class="keyword">in</span> <span class="built_in">zip</span>(lpA, lpB):</span><br><span class="line">    rows, cols, dpt = la.shape</span><br><span class="line">    ls = np.hstack((la[:, <span class="number">0</span>:cols // <span class="number">2</span>], lb[:, cols // <span class="number">2</span>:]))</span><br><span class="line">    LS.append(ls)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重新构建图像</span></span><br><span class="line">ls_ = LS[<span class="number">0</span>]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">6</span>):</span><br><span class="line">    ls_ = cv2.pyrUp(ls_)</span><br><span class="line">    ls_ = cv2.add(ls_, LS[i])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 连接</span></span><br><span class="line">real = np.hstack((A[:, :cols // <span class="number">2</span>], B[:, cols // <span class="number">2</span>:]))</span><br><span class="line"></span><br><span class="line">cv2.imshow(<span class="string">&quot;LS&quot;</span>, ls_)</span><br><span class="line">cv2.imshow(<span class="string">&quot;Real&quot;</span>, real)</span><br><span class="line"></span><br><span class="line">cv2.waitKey(<span class="number">0</span>)</span><br><span class="line">cv2.destroyAllWindows()</span><br></pre></td></tr></table></figure><h2 id="图像轮廓"><a href="#图像轮廓" class="headerlink" title="图像轮廓"></a>图像轮廓</h2><h3 id="轮廓定义"><a href="#轮廓定义" class="headerlink" title="轮廓定义"></a>轮廓定义</h3><ul><li>轮廓，是连接具有相同颜色或强度的所有连续点（沿边界）的曲线。轮廓是用于形状分析以及对象检测和识别的有用工具。</li><li>为了找到轮廓，通常应用阈值或Canny边缘检测。</li></ul><h3 id="查找轮廓"><a href="#查找轮廓" class="headerlink" title="查找轮廓"></a>查找轮廓</h3><ul><li><code>findContours(image, mode, method)</code>：从黑色背景中找到白色物体的轮廓。<ul><li><code>image</code>：仅接受二值图。</li><li><code>mode</code>：轮廓检索模式。<ul><li><code>cv2.RETR_EXTERNAL</code>：表示只检测外轮廓。</li><li><code>cv2.RETR_LIST</code>：检测的轮廓不建立等级关系。</li><li><code>cv2.RETR_CCOMP</code>：建立两个等级的轮廓，上面的一层为外边界，里面的一层为内孔的边界信息。如果内孔内还有一个连通物体，这个物体的边界也在顶层。</li><li><code>cv2.RETR_TREE</code>：建立一个等级树结构的轮廓。</li></ul></li><li><code>method</code>：轮廓近似方法。<ul><li><code>cv2.CHAIN_APPROX_NONE</code>：存储所有的轮廓点，相邻的两个点的像素位置差不超过1。</li><li><code>cv2.CHAIN_APPROX_SIMPLE</code>：压缩水平、垂直、对角线方向的元素，只保留该方向的终点坐标，例如一个矩形轮廓只需4个点来保存轮廓信息</li><li><code>cv2.CHAIN_APPROX_TC89_L1/CV_CHAIN_APPROX_TC89_KCOS</code>：使用 teh-Chinl chain 近似算法</li></ul></li><li><code>contours</code>：返回的第一个值，图像中所有轮廓组成的list。<ul><li>每个轮廓的类型为<code>ndarray</code>，本质是轮廓上的点的集合。</li></ul></li><li><code>hierarchy</code>：返回的第二个可选值，是一个<code>ndarray</code>，其元素个数和轮廓个数相同。<ul><li>每个轮廓<code>contours[i]</code>对应4个轮廓层级属性<code>hierarchy[i][0] ~ hierarchy[i][3]</code>，分别表示后一个轮廓、前一个轮廓、父轮廓、内嵌轮廓的索引。如果没有对应项，则该值为负数。</li></ul></li></ul></li><li>在OpenCV中，<code>findContours()</code>的版本区别：<ul><li>OpenCV3.2 之前，函数会修改源图像。OpenCV3.2 之后，不再修改源图像。</li><li>OpenCV2 返回两个值：<code>contours</code>、<code>hierarchy</code>。OpenCV3 返回三个值：<code>img</code>、<code>countours</code>、<code>hierarchy</code>。这里可以用 try-except 解决版本兼容问题。</li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">im = cv2.imread(<span class="string">&#x27;test.jpg&#x27;</span>)</span><br><span class="line">imgray = cv2.cvtColor(im, cv2.COLOR_BGR2GRAY)</span><br><span class="line">ret, thresh = cv2.threshold(imgray, <span class="number">127</span>, <span class="number">255</span>, <span class="number">0</span>)  <span class="comment"># 转二值</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    img, contours, hierarchy = cv2.findContours(thresh, mode=cv2.RETR_EXTERNAL, method=cv2.CHAIN_APPROX_SIMPLE)</span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line">    contours, hierarchy = cv2.findContours(thresh, mode=cv2.RETR_EXTERNAL, method=cv2.CHAIN_APPROX_SIMPLE)</span><br></pre></td></tr></table></figure><h3 id="绘制轮廓"><a href="#绘制轮廓" class="headerlink" title="绘制轮廓"></a>绘制轮廓</h3><ul><li><p><code>cv2.drawContours(image, contours, contourIdx, color, thickness, lineType, hierarchy, maxLevel, offset)</code>：绘制任何形状的轮廓。</p><ul><li><code>image</code>：指明在哪幅图像上绘制轮廓。</li><li><code>contours</code>：轮廓集合。</li><li><code>contourIdx</code>：指定绘制轮廓集合中的哪条轮廓，如果是-1，则绘制其中的所有轮廓。</li><li><code>thickness</code>：表明轮廓线的宽度，如果是-1(cv2.FILLED)，则为填充。</li></ul></li><li><p>在图像中绘制所有轮廓：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cv2.drawContours(img, contours, -<span class="number">1</span>, (<span class="number">0</span>, <span class="number">255</span>, <span class="number">0</span>), <span class="number">3</span>)</span><br></pre></td></tr></table></figure></li><li><p>绘制单个轮廓，如第四个轮廓：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cv2.drawContours(img, contours, <span class="number">3</span>, (<span class="number">0</span>, <span class="number">255</span>, <span class="number">0</span>), <span class="number">3</span>)</span><br><span class="line"><span class="comment"># 更好用的等价方法</span></span><br><span class="line">cnt = contours[<span class="number">4</span>]</span><br><span class="line">cv2.drawContours(img, [cnt], <span class="number">0</span>, (<span class="number">0</span>,<span class="number">255</span>,<span class="number">0</span>), <span class="number">3</span>)</span><br></pre></td></tr></table></figure></li><li><p>绘制面积最大的轮廓：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 找到最大的轮廓</span></span><br><span class="line">area = []</span><br><span class="line"><span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(contours)):</span><br><span class="line">    area.append(cv2.contourArea(contours[k]))</span><br><span class="line">max_idx = np.argmax(np.array(area))</span><br><span class="line">cnt = contours[max_idx]</span><br><span class="line">cv2.drawContours(img, [cnt], <span class="number">0</span>, (<span class="number">0</span>,<span class="number">255</span>,<span class="number">0</span>), <span class="number">3</span>)</span><br></pre></td></tr></table></figure></li></ul><h3 id="轮廓特征"><a href="#轮廓特征" class="headerlink" title="轮廓特征"></a>轮廓特征</h3><h4 id="特征矩"><a href="#特征矩" class="headerlink" title="特征矩"></a>特征矩</h4><ul><li>特征矩可以帮助计算目标的特征，例如物体的质心、面积等。</li><li><code>cv2.moments()</code>：提供所有计算出的矩值字典。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">img = cv2.imread(<span class="string">&#x27;test.jpg&#x27;</span>, <span class="number">0</span>)</span><br><span class="line">thresh = cv2.Canny(img, <span class="number">100</span>, <span class="number">200</span>)</span><br><span class="line">image, contours, hierarchy = cv2.findContours(thresh, <span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">cnt = contours[<span class="number">0</span>]</span><br><span class="line">M = cv2.moments(cnt)</span><br><span class="line">print(M)</span><br><span class="line"><span class="comment"># &#123;&#x27;m00&#x27;: 6.0, &#x27;m10&#x27;: 3258.0, &#x27;m01&#x27;: 3474.0, &#x27;m20&#x27;: 1769095.6666666665, &#x27;m11&#x27;: 1886382.0, &#x27;m02&#x27;: 2011451.0, &#x27;m30&#x27;: 960620757.0, &#x27;m21&#x27;: 1024306391.0, &#x27;m12&#x27;: 1092217893.0, &#x27;m03&#x27;: 1164635919.0, &#x27;mu20&#x27;: 1.6666666665114462, &#x27;mu11&#x27;: 0.0, &#x27;mu02&#x27;: 5.0, &#x27;mu30&#x27;: 2.384185791015625e-07, &#x27;mu21&#x27;: 8.987262845039368e-08, &#x27;mu12&#x27;: 0.0, &#x27;mu03&#x27;: 0.0, &#x27;nu20&#x27;: 0.04629629629198462, &#x27;nu11&#x27;: 0.0, &#x27;nu02&#x27;: 0.1388888888888889, &#x27;nu30&#x27;: 2.7037215925843386e-09, &#x27;nu21&#x27;: 1.0191763034546432e-09, &#x27;nu12&#x27;: 0.0, &#x27;nu03&#x27;: 0.0&#125;</span></span><br></pre></td></tr></table></figure><ul><li>计算质心：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cx = <span class="built_in">int</span>(M[<span class="string">&#x27;m10&#x27;</span>] / M[<span class="string">&#x27;m00&#x27;</span>])</span><br><span class="line">cy = <span class="built_in">int</span>(M[<span class="string">&#x27;m01&#x27;</span>] / M[<span class="string">&#x27;m00&#x27;</span>])</span><br><span class="line">print(cx, cy)</span><br><span class="line"><span class="comment"># 543 579</span></span><br></pre></td></tr></table></figure><h4 id="轮廓面积"><a href="#轮廓面积" class="headerlink" title="轮廓面积"></a>轮廓面积</h4><ul><li><code>cv2.contourArea(curve)</code>：轮廓面积，等价于矩<code>M[&#39;m00&#39;]</code>。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">area = cv2.contourArea(cnt) </span><br></pre></td></tr></table></figure><h4 id="轮廓周长"><a href="#轮廓周长" class="headerlink" title="轮廓周长"></a>轮廓周长</h4><ul><li><code>cv2.arcLength(curve, closed)</code>：轮廓弧长。<ul><li><code>closed</code>：<code>True</code>指定形状是闭合轮廓，<code>False</code>为曲线。</li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">perimeter = cv2.arcLength(cnt, closed=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure><h3 id="轮廓凹凸状况"><a href="#轮廓凹凸状况" class="headerlink" title="轮廓凹凸状况"></a>轮廓凹凸状况</h3><h4 id="轮廓近似"><a href="#轮廓近似" class="headerlink" title="轮廓近似"></a>轮廓近似</h4><ul><li>例如试图在图像中找到一个正方形，但是由于图像问题，没能得到一个完美的正方形，则可以近似形状。</li><li><code>cv2.approxPolyDP(curve, epsilon, closed)</code>：根据指定的精度，将轮廓形状近似为顶点数量较少的其他形状。由Douglas-Peucker算法实现。<ul><li><code>epsilon</code>：是一个精度参数，表示从轮廓到近似轮廓的最大距离。需要正确选择epsilon才能获得正确的输出。</li><li><code>closed</code>：指定曲线是否闭合。</li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">epsilon = <span class="number">0.3</span> * cv2.arcLength(cnt, <span class="literal">True</span>)</span><br><span class="line">approx = cv2.approxPolyDP(cnt, epsilon, <span class="literal">True</span>)</span><br></pre></td></tr></table></figure><ul><li><p>在第二张图片中，绿线显示了<code>ε=周长×10％</code>时的近似曲线。第三张图中，显示了<code>ε=周长×1％</code>时的情况。</p><p><img src="/2021/08/OpenCV-Part3/approx-16304145028132.jpg" alt="img"></p></li></ul><h4 id="轮廓凸包"><a href="#轮廓凸包" class="headerlink" title="轮廓凸包"></a>轮廓凸包</h4><ul><li><p>凸包与轮廓逼近相似，在某些情况下两者可能提供相同的结果。</p></li><li><p><code>cv2.convexHull(points, hull, clockwise, returnPoints)</code>：检查曲线是否存在凸凹缺陷并进行校正。</p><ul><li><code>points</code>：传入轮廓点集。</li><li><code>hull</code>：输出，通常不需要。</li><li><code>clockwise</code>：方向标志。<code>True</code>表示输出的凸包是顺时针方向的，否则为逆时针。</li><li><code>returnPoints</code>：默认值为<code>True</code>。返回凸包点的(x, y)坐标。如果设置为 False，则返回凸包点在轮廓中相应的索引。</li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hull = cv2.convexHull(cnt) </span><br></pre></td></tr></table></figure><h4 id="检查凸度"><a href="#检查凸度" class="headerlink" title="检查凸度"></a>检查凸度</h4><ul><li><code>cv2.isContourConvex(point)</code>：检查曲线是否凸出。只返回True或False。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">k = cv2.isContourConvex(cnt) </span><br></pre></td></tr></table></figure><h4 id="凸性缺陷"><a href="#凸性缺陷" class="headerlink" title="凸性缺陷"></a>凸性缺陷</h4><ul><li>凸包的任何偏差都可以被认为是凸性缺陷。</li><li><code>cv2.convexityDefects()</code>：查找凸性缺陷。<ul><li>在寻找凸包时，对<code>cv2.convexHull(points, returnPoints)</code>必须传递<code>returnPoints=False</code>。</li><li>返回一个数组，其中每行包含这些值：**[起点、终点、最远点、到最远点的近似距离]**。</li><li>该函数返回的前三个值是cnt的索引。</li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"></span><br><span class="line">img = cv2.imread(<span class="string">&#x27;test.jpg&#x27;</span>)</span><br><span class="line">thresh = cv2.Canny(img, <span class="number">100</span>, <span class="number">200</span>)</span><br><span class="line">_, contours, hierarchy = cv2.findContours(thresh, <span class="number">2</span>, <span class="number">1</span>)</span><br><span class="line">cnt = contours[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查找凸性缺陷</span></span><br><span class="line">hull = cv2.convexHull(cnt, returnPoints=<span class="literal">False</span>)</span><br><span class="line">defects = cv2.convexityDefects(cnt, hull)  </span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(defects.shape[<span class="number">0</span>]):</span><br><span class="line">    s, e, f, d = defects[i, <span class="number">0</span>]</span><br><span class="line">    start = <span class="built_in">tuple</span>(cnt[s][<span class="number">0</span>])</span><br><span class="line">    end = <span class="built_in">tuple</span>(cnt[e][<span class="number">0</span>])</span><br><span class="line">    far = <span class="built_in">tuple</span>(cnt[f][<span class="number">0</span>])</span><br><span class="line">    cv2.line(img, start, end, [<span class="number">0</span>, <span class="number">255</span>, <span class="number">0</span>], <span class="number">2</span>)</span><br><span class="line">    cv2.circle(img, far, <span class="number">5</span>, [<span class="number">0</span>, <span class="number">0</span>, <span class="number">255</span>], -<span class="number">1</span>)</span><br><span class="line">cv2.imshow(<span class="string">&#x27;img&#x27;</span>, img)</span><br><span class="line">cv2.waitKey(<span class="number">0</span>)</span><br></pre></td></tr></table></figure><ul><li><img src="/2021/08/OpenCV-Part3/defects.jpg" alt="img"></li></ul><h4 id="点多边形测试"><a href="#点多边形测试" class="headerlink" title="点多边形测试"></a>点多边形测试</h4><ul><li><code>cv2.pointPolygonTest(contour, pt, measureDist)</code>：计算图像中某一点到轮廓线的最短距离。<ul><li><code>measureDist</code>：如果不想找到距离，则设置为False，因为设置为False可使速度提高2-3倍。<ul><li><code>True</code>：计算有符号距离。点在轮廓线外时为负数，点在轮廓线内时为正数，点在轮廓线上时为零。</li><li><code>False</code>：判断该点是在轮廓线外部还是内部。点在轮廓线外时为<code>-1</code>，点在轮廓线内时为<code>+1</code>，点在轮廓线上时为<code>0</code>。</li></ul></li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dist = cv2.pointPolygonTest(contour=cnt, pt=(<span class="number">50</span>, <span class="number">50</span>), measureDist=<span class="literal">True</span>)  <span class="comment"># 检查(50, 50)到轮廓线的最短距离</span></span><br></pre></td></tr></table></figure><h4 id="形状匹配"><a href="#形状匹配" class="headerlink" title="形状匹配"></a>形状匹配</h4><ul><li><code>cv2.matchShapes()</code>：比较两个形状或两个轮廓，返回一个显示相似性的度量。结果越低，匹配越好。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"></span><br><span class="line">img1 = cv2.imread(<span class="string">&#x27;star.jpg&#x27;</span>, <span class="number">0</span>)</span><br><span class="line">img2 = cv2.imread(<span class="string">&#x27;star2.jpg&#x27;</span>, <span class="number">0</span>)</span><br><span class="line">ret, thresh = cv2.threshold(img1, <span class="number">127</span>, <span class="number">255</span>, <span class="number">0</span>)</span><br><span class="line">ret, thresh2 = cv2.threshold(img2, <span class="number">127</span>, <span class="number">255</span>, <span class="number">0</span>)</span><br><span class="line">contours, hierarchy = cv2.findContours(thresh, <span class="number">2</span>, <span class="number">1</span>)</span><br><span class="line">cnt1 = contours[<span class="number">0</span>]</span><br><span class="line">contours, hierarchy = cv2.findContours(thresh2, <span class="number">2</span>, <span class="number">1</span>)</span><br><span class="line">cnt2 = contours[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">ret = cv2.matchShapes(cnt1, cnt2, <span class="number">1</span>, <span class="number">0.0</span>)</span><br><span class="line">print(ret)</span><br></pre></td></tr></table></figure><ul><li><p>在以下案例中：匹配图像A与本身=0.0；匹配图像A与图像B=0.001946；匹配图像A与图像C=0.326911。</p><p><img src="http://qiniu.aihubs.net/matchshapes.jpg" alt="img"></p></li><li><p>即使是图像旋转也不会对这个比较产生很大的影响。</p></li></ul><h3 id="拟合轮廓"><a href="#拟合轮廓" class="headerlink" title="拟合轮廓"></a>拟合轮廓</h3><h4 id="直角矩形"><a href="#直角矩形" class="headerlink" title="直角矩形"></a>直角矩形</h4><ul><li><code>cv2.boundingRect(points)</code>：不考虑物体旋转，拟合最小矩形框。注意，其面积不是最小的。<ul><li><code>points</code>：目标轮廓的点集。</li><li><code>(x，y)</code>为矩形的左上角坐标，而<code>(w，h)</code>为矩形的宽度和高度。</li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x, y, w, h = cv2.boundingRect(cnt)</span><br><span class="line">cv2.rectangle(img, (x, y), (x + w, y + h), (<span class="number">0</span>, <span class="number">255</span>, <span class="number">0</span>), <span class="number">2</span>)</span><br></pre></td></tr></table></figure><h4 id="旋转矩形"><a href="#旋转矩形" class="headerlink" title="旋转矩形"></a>旋转矩形</h4><ul><li><code>cv2.minAreaRect(point)</code>：考虑旋转，拟合面积最小的外接矩形。<ul><li><code>point</code>：目标轮廓的点集。</li><li>返回一个Box2D结构：<code>(中心坐标(x, y), (宽, 高), 旋转角度)</code>。</li></ul></li><li>cv2.boxPoints()：<code>(中心坐标(x, y), (宽, 高), 旋转角度)</code> -&gt; <code>[[x, y] * 4]</code><ul><li>注意版本区别：OpenCV2中为<code>cv2.cv.BoxPoints</code>，OpenCV3中为<code>cv2.boxPoints()</code>。同样可以用 try-except 兼容版本问题。</li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">rect = cv2.minAreaRect(cnt)</span><br><span class="line">box = cv2.boxPoints(rect)</span><br><span class="line">box = np.int0(box)</span><br><span class="line">cv2.drawContours(img, [box], contourIdx=<span class="number">0</span>, color=(<span class="number">0</span>, <span class="number">0</span>, <span class="number">255</span>), thickness=<span class="number">2</span>)  <span class="comment"># 画(拟合后矩形的)轮廓</span></span><br><span class="line">cv2.polylines(img, [box], isClosed=<span class="literal">True</span>, color=(<span class="number">0</span>, <span class="number">255</span>, <span class="number">255</span>), thickness=<span class="number">2</span>)  <span class="comment"># 画多边形</span></span><br></pre></td></tr></table></figure><ul><li><img src="/2021/08/OpenCV-Part3/image-20210831214555327.png" alt="image-20210831214555327" style="zoom: 50%;"></li></ul><h4 id="最小闭合圈"><a href="#最小闭合圈" class="headerlink" title="最小闭合圈"></a>最小闭合圈</h4><ul><li><code>cv2.minEnclosingCircle(point)</code>：拟合最小外接圆。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(x, y), radius = cv2.minEnclosingCircle(cnt)</span><br><span class="line">center = (<span class="built_in">int</span>(x), <span class="built_in">int</span>(y))</span><br><span class="line">radius = <span class="built_in">int</span>(radius)</span><br><span class="line">cv2.circle(img, center, radius, (<span class="number">0</span>, <span class="number">255</span>, <span class="number">0</span>), <span class="number">2</span>)</span><br></pre></td></tr></table></figure><h4 id="拟合椭圆"><a href="#拟合椭圆" class="headerlink" title="拟合椭圆"></a>拟合椭圆</h4><ul><li><code>cv2.fitEllipse(point)</code>：内接椭圆的旋转矩形。</li><li>很多时候效果并不是非常理想，并没有做到外接。</li><li>需要5个点以上才能拟合椭圆，否则只能用圆形。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ellipse = cv2.fitEllipse(cnt)</span><br><span class="line">(x, y), (w, h), t = ellipse</span><br><span class="line">e_x, e_y, e_a, e_b, e_t = <span class="built_in">int</span>(x), <span class="built_in">int</span>(y), <span class="built_in">int</span>(w / <span class="number">2</span>), <span class="built_in">int</span>(h / <span class="number">2</span>), <span class="built_in">int</span>(t)</span><br><span class="line">cv2.ellipse(img, (e_x, e_y), (e_a, e_b), e_t, <span class="number">0</span>, <span class="number">360</span>, (<span class="number">255</span>, <span class="number">0</span>, <span class="number">0</span>), <span class="number">5</span>)</span><br></pre></td></tr></table></figure><ul><li><img src="/2021/08/OpenCV-Part3/image-20210831221246120.png" alt="image-20210831221246120" style="zoom:50%;"></li></ul><h4 id="拟合直线"><a href="#拟合直线" class="headerlink" title="拟合直线"></a>拟合直线</h4><ul><li><code>cv2.fitLine(points, distType, param, reps, aeps)</code>：在一组点集上近似一条直线。</li><li>也没啥用。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">rows, cols = img.shape[:<span class="number">2</span>]</span><br><span class="line">[vx, vy, x, y] = cv2.fitLine(cnt, cv2.DIST_L2, <span class="number">0</span>, <span class="number">0.01</span>, <span class="number">0.01</span>)</span><br><span class="line">lefty = <span class="built_in">int</span>((-x * vy / vx) + y)</span><br><span class="line">righty = <span class="built_in">int</span>(((cols - x) * vy / vx) + y)</span><br><span class="line">cv2.line(img, (cols - <span class="number">1</span>, righty), (<span class="number">0</span>, lefty), (<span class="number">0</span>, <span class="number">255</span>, <span class="number">0</span>), <span class="number">2</span>)</span><br></pre></td></tr></table></figure><h3 id="轮廓性质"><a href="#轮廓性质" class="headerlink" title="轮廓性质"></a>轮廓性质</h3><h4 id="长宽比"><a href="#长宽比" class="headerlink" title="长宽比"></a>长宽比</h4><ul><li>长宽比：对象边界矩形的宽高比。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x, y, w, h = cv2.boundingRect(cnt)</span><br><span class="line">aspect_ratio = <span class="built_in">float</span>(w) / h</span><br></pre></td></tr></table></figure><h4 id="范围"><a href="#范围" class="headerlink" title="范围"></a>范围</h4><ul><li>范围：轮廓区域与边界矩形区域的比值。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">area = cv2.contourArea(cnt)</span><br><span class="line">x, y, w, h = cv2.boundingRect(cnt)</span><br><span class="line">rect_area = w * h</span><br><span class="line">extent = <span class="built_in">float</span>(area) / rect_area</span><br></pre></td></tr></table></figure><h4 id="坚实度"><a href="#坚实度" class="headerlink" title="坚实度"></a>坚实度</h4><ul><li>坚实度：等高线面积与其凸包面积之比。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">area = cv2.contourArea(cnt)</span><br><span class="line">hull = cv2.convexHull(cnt)</span><br><span class="line">hull_area = cv2.contourArea(hull)</span><br><span class="line">solidity = <span class="built_in">float</span>(area) / hull_area</span><br></pre></td></tr></table></figure><h4 id="等效直径"><a href="#等效直径" class="headerlink" title="等效直径"></a>等效直径</h4><ul><li>等效直径：面积与轮廓面积相同的圆的直径。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">area = cv2.contourArea(cnt)</span><br><span class="line">equi_diameter = np.sqrt(<span class="number">4</span> * area / np.pi)</span><br></pre></td></tr></table></figure><h4 id="取向"><a href="#取向" class="headerlink" title="取向"></a>取向</h4><ul><li>取向：物体指向的角度。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(x, y), (MA, ma), angle = cv2.fitEllipse(cnt)</span><br></pre></td></tr></table></figure><h4 id="掩码"><a href="#掩码" class="headerlink" title="掩码"></a>掩码</h4><ul><li>掩码：构成该对象的所有点。</li><li>Numpy给出的坐标是<code>(行、列)</code>格式，而OpenCV给出的坐标是<code>(x,y)</code>格式。注意，<code>row = x, column = y</code>。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mask = np.zeros(imgray.shape, np.uint8)</span><br><span class="line">cv2.drawContours(mask, [cnt], <span class="number">0</span>, <span class="number">255</span>, -<span class="number">1</span>)</span><br><span class="line">pixelpoints = np.transpose(np.nonzero(mask))</span><br><span class="line"><span class="comment"># pixelpoints = cv2.findNonZero(mask)  # 等价方法</span></span><br></pre></td></tr></table></figure><h4 id="最大值、最小值及其位置"><a href="#最大值、最小值及其位置" class="headerlink" title="最大值、最小值及其位置"></a>最大值、最小值及其位置</h4><ul><li>可以使用掩码图像找到这些参数。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">min_val, max_val, min_loc, max_loc = cv2.minMaxLoc(imgray, mask=mask)</span><br></pre></td></tr></table></figure><h4 id="平均颜色、平均强度"><a href="#平均颜色、平均强度" class="headerlink" title="平均颜色、平均强度"></a>平均颜色、平均强度</h4><ul><li>找到对象的平均颜色，或者灰度模式下物体的平均强度。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mean_val = cv2.mean(img, mask=mask)</span><br></pre></td></tr></table></figure><h4 id="极端点"><a href="#极端点" class="headerlink" title="极端点"></a>极端点</h4><ul><li>极端点：指对象的最顶部，最底部，最右侧和最左侧的点。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">leftmost = <span class="built_in">tuple</span>(cnt[cnt[:, :, <span class="number">0</span>].argmin()][<span class="number">0</span>])</span><br><span class="line">rightmost = <span class="built_in">tuple</span>(cnt[cnt[:, :, <span class="number">0</span>].argmax()][<span class="number">0</span>])</span><br><span class="line">topmost = <span class="built_in">tuple</span>(cnt[cnt[:, :, <span class="number">1</span>].argmin()][<span class="number">0</span>])</span><br><span class="line">bottommost = <span class="built_in">tuple</span>(cnt[cnt[:, :, <span class="number">1</span>].argmax()][<span class="number">0</span>])</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> OpenCV </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>OpenCV-Part2</title>
      <link href="/2021/08/OpenCV-Part2/"/>
      <url>/2021/08/OpenCV-Part2/</url>
      
        <content type="html"><![CDATA[<h1 id="OpenCV-Part2——图像处理（上）"><a href="#OpenCV-Part2——图像处理（上）" class="headerlink" title="OpenCV-Part2——图像处理（上）"></a>OpenCV-Part2——图像处理（上）</h1><p>[TOC]</p><h2 id="HSV色彩空间"><a href="#HSV色彩空间" class="headerlink" title="HSV色彩空间"></a>HSV色彩空间</h2><h3 id="RGB与HSV格式转换"><a href="#RGB与HSV格式转换" class="headerlink" title="RGB与HSV格式转换"></a>RGB与HSV格式转换</h3><ul><li><code>cv2.cvtColor(img, cv2.COLOR_BGR2HSV)</code>：将BGR图片转换成HSV格式。</li><li><code>cv2.inRange(img_hsv, lower, upper)</code>：提取范围内的区域。</li><li>HSV图像的每个像素<code>[h, w]</code>按[H, S, V]顺序存储。其中，H范围[0, 179]、S范围[0, 255]、V范围[0, 255]。</li><li>在对像素值标量进行表达式计算时，要将类型从<code>numpy.uint8</code>转<code>int</code>，防止越界。</li><li>在针对提取某一种颜色之前，可以通过高通滤波来锐化边缘，提高对颜色较淡区域的捕捉能力。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 提取红色区域</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">extract_red</span>():</span></span><br><span class="line">    img = cv2.imread(<span class="string">&quot;test.jpg&quot;</span>)</span><br><span class="line">    img_hsv = cv2.cvtColor(img, cv2.COLOR_BGR2HSV)</span><br><span class="line">    <span class="comment"># 区间1</span></span><br><span class="line">    lower_red_1 = np.array([<span class="number">0</span>, <span class="number">45</span>, <span class="number">177</span>])</span><br><span class="line">    upper_red_1 = np.array([<span class="number">30</span>, <span class="number">255</span>, <span class="number">255</span>])</span><br><span class="line">    mask_1 = cv2.inRange(img_hsv, lower_red_1, upper_red_1)</span><br><span class="line">    <span class="comment"># 区间2</span></span><br><span class="line">    lower_red_2 = np.array([<span class="number">150</span>, <span class="number">45</span>, <span class="number">177</span>])</span><br><span class="line">    upper_red_2 = np.array([<span class="number">180</span>, <span class="number">255</span>, <span class="number">255</span>])</span><br><span class="line">    mask_2 = cv2.inRange(img_hsv, lower_red_2, upper_red_2)</span><br><span class="line">    <span class="comment"># 在空白画布上拼接两个区间</span></span><br><span class="line">    mask = mask_1 + mask_2</span><br><span class="line">    img_ = cv2.bitwise_and(img, img, mask=mask)  <span class="comment"># 这里不要去创建空白的np数组，浪费效率</span></span><br><span class="line">    cv2.imshow(<span class="string">&quot;img_&quot;</span>, img_)</span><br><span class="line">    cv2.waitKey(<span class="number">0</span>)</span><br></pre></td></tr></table></figure><h3 id="找到要追踪的HSV值"><a href="#找到要追踪的HSV值" class="headerlink" title="找到要追踪的HSV值"></a>找到要追踪的HSV值</h3><ul><li>使用相同的函数<code>cv2.cvtColor()</code>传递期望的BGR值，而不是传递图像。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查找绿色的HSV值，</span></span><br><span class="line">green = np.uint8([[[<span class="number">0</span>,<span class="number">255</span>,<span class="number">0</span> ]]])</span><br><span class="line">hsv_green = cv2.cvtColor(green, cv2.COLOR_BGR2HSV)</span><br><span class="line">print(hsv_green)  <span class="comment"># [[[60, 255, 255]]]</span></span><br></pre></td></tr></table></figure><h2 id="图像几何变换"><a href="#图像几何变换" class="headerlink" title="图像几何变换"></a>图像几何变换</h2><h3 id="缩放"><a href="#缩放" class="headerlink" title="缩放"></a>缩放</h3><ul><li><code>cv2.resize()</code>：调整图像的大小。图像的大小可以手动指定，也可以指定缩放比例。出于调整大小的目的，默认使用的插值方法为<code>cv2.INTER_LINEAR</code>。<ul><li><code>dsize</code>：shape是[高, 宽]，dsize是(宽, 高)。</li><li><code>fx/fy</code>：缩放比例。</li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">img = cv2.imread(<span class="string">&quot;test.jpg&quot;</span>)</span><br><span class="line">img_ = cv2.resize(img, dsize=<span class="literal">None</span>, fx=<span class="number">2</span>, fy=<span class="number">2</span>)</span><br><span class="line">img_ = cv2.resize(img, dsize=(img.shape[<span class="number">1</span>] // <span class="number">2</span>, img.shape[<span class="number">0</span>] // <span class="number">2</span>))</span><br></pre></td></tr></table></figure><h3 id="平移"><a href="#平移" class="headerlink" title="平移"></a>平移</h3><ul><li><code>cv2.warpAffine()</code>：<ul><li><code>dsize</code>：输出图像的大小，其形式为<code>(width，height)</code>。记住<code>width</code> =列数/宽，<code>height</code> =行数/高。</li></ul></li><li>将变换矩阵放入<code>np.float32</code>类型的Numpy数组中，并传递给<code>cv2.warpAffine</code>函数。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 偏移(100, 50)</span></span><br><span class="line">h, w, _ = img.shape</span><br><span class="line">M = np.float32([[<span class="number">1</span>, <span class="number">0</span>, <span class="number">100</span>], [<span class="number">0</span>, <span class="number">1</span>, <span class="number">50</span>]])</span><br><span class="line">dst = cv2.warpAffine(img, M, (w, h))</span><br></pre></td></tr></table></figure><p><img src="/2021/08/OpenCV-Part2/translation.jpg" alt="img"></p><h3 id="旋转"><a href="#旋转" class="headerlink" title="旋转"></a>旋转</h3><ul><li><code>cv2.getRotationMatrix2D(center, angle, scale)</code>：获取旋转矩阵。<ul><li><code>center</code>：旋转中心(x, y)。</li><li><code>angle</code>：逆时针旋转角度，可以为负数。</li><li><code>scale</code>：以center为中心的缩放比例。</li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">img = cv2.imread(<span class="string">&quot;test.jpg&quot;</span>)</span><br><span class="line">x, y = img.shape[<span class="number">1</span>] // <span class="number">2</span>, img.shape[<span class="number">0</span>] // <span class="number">2</span></span><br><span class="line">mat_rotate = cv2.getRotationMatrix2D(center=(x, y), angle=-<span class="number">90</span>, scale=<span class="number">0.5</span>)</span><br><span class="line">img = cv2.warpAffine(img, M=mat_rotate, dsize=(img.shape[<span class="number">1</span>], img.shape[<span class="number">0</span>]))</span><br></pre></td></tr></table></figure><ul><li>在如上的方法中，在非正方形的图中旋转，很有可能会受到画布大小的限制。</li><li>对于90°旋转可以使用<code>np.rot90</code>函数。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">img_ = np.rot90(img)</span><br></pre></td></tr></table></figure><h3 id="翻转"><a href="#翻转" class="headerlink" title="翻转"></a>翻转</h3><ul><li><code>cv2.flip(scr, flipCode)</code>：上下/左右翻转图像。<ul><li><code>flipCode</code>：1为水平翻转，0位垂直翻转</li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">img = cv2.flip(img, flipCode=<span class="number">1</span>) </span><br></pre></td></tr></table></figure><h3 id="变换"><a href="#变换" class="headerlink" title="变换"></a>变换</h3><ul><li>OpenCV提供了两个转换函数<code>cv2.warpAffine</code>和<code>cv2.warpPerspective</code>。</li><li><code>cv2.warpAffine</code>采用2x3转换矩阵，而<code>cv2.warpPerspective</code>采用3x3转换矩阵作为输入。</li></ul><h4 id="仿射变换"><a href="#仿射变换" class="headerlink" title="仿射变换"></a>仿射变换</h4><ul><li>在仿射变换中，原始图像中的所有平行线在输出图像中仍将平行。</li><li>通过输入图像中的三个点及其在输出图像中的对应位置，使用<code>cv2.getAffineTransform</code>创建相应的变换矩阵，该矩阵将传递给<code>cv2.warpAffine</code>。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">img = cv2.imread(<span class="string">&quot;test.jpg&quot;</span>)</span><br><span class="line">pts1 = np.float32([[<span class="number">50</span>, <span class="number">50</span>], [<span class="number">200</span>, <span class="number">50</span>], [<span class="number">50</span>, <span class="number">200</span>]])</span><br><span class="line">pts2 = np.float32([[<span class="number">10</span>, <span class="number">100</span>], [<span class="number">200</span>, <span class="number">50</span>], [<span class="number">100</span>, <span class="number">250</span>]])</span><br><span class="line">M = cv2.getAffineTransform(pts1, pts2)</span><br><span class="line">img = cv2.warpAffine(img, M=M, dsize=(img.shape[<span class="number">1</span>], img.shape[<span class="number">0</span>]))</span><br></pre></td></tr></table></figure><img src="/2021/08/OpenCV-Part2/image-20210823211535020.png" alt="image-20210823211535020" style="zoom:67%;"><h4 id="透视变换"><a href="#透视变换" class="headerlink" title="透视变换"></a>透视变换</h4><ul><li>对于透视变换，在转换后，直线也将保持直线。要找到此变换矩阵，需要在输入图像上的4个点，以及在输出图像上对应的4个点。在这4个点中，其中3个不应共线。</li><li>可以通过<code>cv2.getPerspectiveTransform</code>找到该3x3变换矩阵，应用于<code>cv2.warpPerspective</code>。</li><li>注意，这里应用的是3x3变换矩阵，与2x2变换矩阵的方法是不一样的。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">img = cv2.imread(<span class="string">&quot;test.jpg&quot;</span>)</span><br><span class="line">pts1 = np.float32([[<span class="number">180</span>, <span class="number">50</span>], [<span class="number">600</span>, <span class="number">200</span>], [<span class="number">50</span>, <span class="number">430</span>], [<span class="number">470</span>, <span class="number">570</span>]])</span><br><span class="line">pts2 = np.float32([[<span class="number">0</span>, <span class="number">0</span>], [<span class="number">300</span>, <span class="number">0</span>], [<span class="number">0</span>, <span class="number">300</span>], [<span class="number">300</span>, <span class="number">300</span>]])</span><br><span class="line">M = cv2.getPerspectiveTransform(pts1, pts2)</span><br><span class="line">img = cv2.warpPerspective(img, M=M, dsize=(<span class="number">300</span>, <span class="number">300</span>))</span><br></pre></td></tr></table></figure><img src="/2021/08/OpenCV-Part2/image-20210823213417052.png" alt="image-20210823213417052" style="zoom:50%;"><h2 id="图像二值化"><a href="#图像二值化" class="headerlink" title="图像二值化"></a>图像二值化</h2><h3 id="简单阈值"><a href="#简单阈值" class="headerlink" title="简单阈值"></a>简单阈值</h3><ul><li><p><code>cv2.threshold(src, thresh, maxval, type)</code>：对于每个像素，应用同一阈值，用于对像素值进行分类。</p><ul><li><code>cv2.THRESH_BINARY</code>：对于设定的thresh，小于则将当前像素值设置为 0(黑色)，超过则将像素值设置为maxval(白色)。</li><li><code>cv2.THRESH_BINARY_INV</code>：与<code>THRESH_BINARY</code>互为翻转，可以用这一type省去手动翻转的过程。</li><li><code>cv2.THRESH_TRUNC</code>：对于设定的thresh，小于则将当前像素值*2，超过则将像素值设置为maxval(白色)。</li><li><code>cv2.THRESH_TOZERO</code>：对于设定的thresh，小于则将当前像素值设置为 0(黑色)，超过则像素值不变。</li><li><code>cv2.THRESH_TOZERO_INV</code>：对于设定的thresh，小于则将当前像素值*2，超过则将像素值设置为 0(黑色)。</li></ul></li><li><p>输入图像应该是单通道灰度图像。</p></li></ul><ul><li>该方法返回两个输出。第一个是使用的阈值，第二个输出是阈值后的图像。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"></span><br><span class="line">img = cv2.imread(<span class="string">&#x27;radient.png&#x27;</span>, cv2.IMREAD_GRAYSCALE)</span><br><span class="line">ret, thresh1 = cv2.threshold(img, <span class="number">127</span>, <span class="number">255</span>, cv2.THRESH_BINARY)</span><br><span class="line">ret, thresh2 = cv2.threshold(img, <span class="number">127</span>, <span class="number">255</span>, cv2.THRESH_BINARY_INV)</span><br><span class="line">ret, thresh3 = cv2.threshold(img, <span class="number">127</span>, <span class="number">255</span>, cv2.THRESH_TRUNC)</span><br><span class="line">ret, thresh4 = cv2.threshold(img, <span class="number">127</span>, <span class="number">255</span>, cv2.THRESH_TOZERO)</span><br><span class="line">ret, thresh5 = cv2.threshold(img, <span class="number">127</span>, <span class="number">255</span>, cv2.THRESH_TOZERO_INV)</span><br><span class="line">cv2.imshow(<span class="string">&quot;BINARY&quot;</span>, thresh1)</span><br><span class="line">cv2.imshow(<span class="string">&quot;BINARY_INV&quot;</span>, thresh2)</span><br><span class="line">cv2.imshow(<span class="string">&quot;TRUNC&quot;</span>, thresh3)</span><br><span class="line">cv2.imshow(<span class="string">&quot;TOZERO&quot;</span>, thresh4)</span><br><span class="line">cv2.imshow(<span class="string">&quot;TOZERO_INV&quot;</span>, thresh5)</span><br><span class="line">cv2.waitKey(<span class="number">0</span>)</span><br></pre></td></tr></table></figure><p><img src="/2021/08/OpenCV-Part2/threshold.jpg" alt="img"></p><h3 id="自适应阈值"><a href="#自适应阈值" class="headerlink" title="自适应阈值"></a>自适应阈值</h3><ul><li><code>cv2.threshold</code>：使用一个值作为全局像素的阈值，这样不能具备普适性，例如，图像在不同区域具有不同的光照条件时。</li><li><code>cv2.adaptiveThreshold</code>：基于像素周围的小区域确定像素的阈值。对于同一图像的不同区域，获取不同的阈值。<ul><li><code>cv2.ADAPTIVE_THRESH_MEAN_C</code>：阈值是邻近区域的<strong>平均值</strong>减去常数<code>C</code>。</li><li><code>cv2.ADAPTIVE_THRESH_GAUSSIAN_C</code>：阈值是邻域值的<strong>高斯加权总和</strong>减去常数<code>C</code>。</li><li><code>BLOCKSIZE</code>：核大小，给定奇数边长。</li><li><code>C</code>：从邻域像素的平均或加权总和中减去的常数。</li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"></span><br><span class="line">img = cv2.imread(<span class="string">&#x27;test.jpg&#x27;</span>, cv2.IMREAD_GRAYSCALE)</span><br><span class="line">thresh1 = cv2.adaptiveThreshold(img, maxValue=<span class="number">255</span>, adaptiveMethod=cv2.ADAPTIVE_THRESH_GAUSSIAN_C,</span><br><span class="line">                                thresholdType=cv2.THRESH_BINARY, blockSize=<span class="number">101</span>, C=<span class="number">15</span>)</span><br><span class="line">cv2.imshow(<span class="string">&quot;BINARY&quot;</span>, thresh1)</span><br><span class="line">cv2.waitKey(<span class="number">0</span>)</span><br></pre></td></tr></table></figure><img src="/2021/08/OpenCV-Part2/image-20210828195757940.png" alt="image-20210828195757940" style="zoom:80%;"><h3 id="Otsu二值化（大津法）"><a href="#Otsu二值化（大津法）" class="headerlink" title="Otsu二值化（大津法）"></a>Otsu二值化（大津法）</h3><ul><li><p>Otsu方法将考虑仅具有两个主要的不同像素值的图像（双峰图像），即直方图仅包含两个峰。</p></li><li><p><code>cv2.threshold(img, thresh, maxval, type=cv2.THRESH_BINARY + cv2.THRESH_OTSU)</code>：Otsu二值化，从图像直方图中自动确定最佳全局阈值以区分这两个值，而无需手动选择。找到最佳阈值后，使用的阈值将作为第一输出返回。</p><ul><li><code>cv2.THRESH_OTSU</code>：作为附加标志传递，实质上是int类型相加。</li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">from</span> matplotlib <span class="keyword">import</span> pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">img = cv2.imread(<span class="string">&#x27;test.jpg&#x27;</span>, cv2.IMREAD_GRAYSCALE)</span><br><span class="line"><span class="comment"># 1. 采用值为127的全局阈值</span></span><br><span class="line">ret1, th1 = cv2.threshold(img, <span class="number">127</span>, <span class="number">255</span>, cv2.THRESH_BINARY)</span><br><span class="line"><span class="comment"># 2. 直接采用Otsu阈值法</span></span><br><span class="line">ret2, th2 = cv2.threshold(img, <span class="number">0</span>, <span class="number">255</span>, cv2.THRESH_BINARY + cv2.THRESH_OTSU)</span><br><span class="line"><span class="comment"># 3. 首先使用5x5高斯核对图像进行滤波以去除噪声，然后应用Otsu阈值处理</span></span><br><span class="line">ret3, th3 = cv2.threshold(cv2.GaussianBlur(img, (<span class="number">5</span>, <span class="number">5</span>), <span class="number">0</span>), <span class="number">0</span>, <span class="number">255</span>, </span><br><span class="line">                          cv2.THRESH_BINARY + cv2.THRESH_OTSU)</span><br><span class="line"><span class="comment"># 绘制所有图像及其直方图</span></span><br><span class="line">images = [img, <span class="number">0</span>, th1,</span><br><span class="line">          img, <span class="number">0</span>, th2,</span><br><span class="line">          blur, <span class="number">0</span>, th3]</span><br><span class="line">titles = [<span class="string">&#x27;Original Noisy Image&#x27;</span>, <span class="string">&#x27;Histogram&#x27;</span>, <span class="string">&#x27;Global Thresholding (v=127)&#x27;</span>,</span><br><span class="line">          <span class="string">&#x27;Original Noisy Image&#x27;</span>, <span class="string">&#x27;Histogram&#x27;</span>, <span class="string">&quot;Otsu&#x27;s Thresholding&quot;</span>,</span><br><span class="line">          <span class="string">&#x27;Gaussian filtered Image&#x27;</span>, <span class="string">&#x27;Histogram&#x27;</span>, <span class="string">&quot;Otsu&#x27;s Thresholding&quot;</span>]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>):</span><br><span class="line">    plt.subplot(<span class="number">3</span>, <span class="number">3</span>, i * <span class="number">3</span> + <span class="number">1</span>), plt.imshow(images[i * <span class="number">3</span>], <span class="string">&#x27;gray&#x27;</span>)</span><br><span class="line">    plt.title(titles[i * <span class="number">3</span>]), plt.xticks([]), plt.yticks([])</span><br><span class="line">    plt.subplot(<span class="number">3</span>, <span class="number">3</span>, i * <span class="number">3</span> + <span class="number">2</span>), plt.hist(images[i * <span class="number">3</span>].ravel(), <span class="number">256</span>)</span><br><span class="line">    plt.title(titles[i * <span class="number">3</span> + <span class="number">1</span>]), plt.xticks([]), plt.yticks([])</span><br><span class="line">    plt.subplot(<span class="number">3</span>, <span class="number">3</span>, i * <span class="number">3</span> + <span class="number">3</span>), plt.imshow(images[i * <span class="number">3</span> + <span class="number">2</span>], <span class="string">&#x27;gray&#x27;</span>)</span><br><span class="line">    plt.title(titles[i * <span class="number">3</span> + <span class="number">2</span>]), plt.xticks([]), plt.yticks([])</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure> <img src="/2021/08/OpenCV-Part2/otsu.jpg" alt="img"><h2 id="图像卷积"><a href="#图像卷积" class="headerlink" title="图像卷积"></a>图像卷积</h2><h3 id="模糊、滤波与卷积的区别"><a href="#模糊、滤波与卷积的区别" class="headerlink" title="模糊、滤波与卷积的区别"></a>模糊、滤波与卷积的区别</h3><blockquote><p>图像卷积的本质，是提取图像不同『频段』的特征。<a href="https://zhuanlan.zhihu.com/p/28478034">https://zhuanlan.zhihu.com/p/28478034</a></p><p>图像模糊(平滑)和滤波，都属于卷积，不同滤波方法之间只是卷积核不同。</p></blockquote><h3 id="低-高通滤波概念"><a href="#低-高通滤波概念" class="headerlink" title="低/高通滤波概念"></a>低/高通滤波概念</h3><p>图像滤波既可以在实域进行，也可以在频域进行。通过滤波，可以强调一些特征或者去除图像中一些不需要的部分。</p><p>滤波是一个邻域操作算子，利用给定像素周围的像素的值决定此像素的最终的输出值。</p><ul><li><p>高通滤波器（HPF）：根据中心像素与周围像素的亮度差值来提升像素的亮度，保留变化强烈的部分，过滤缓和部分。用于：增强、锐化、边缘提取。</p><p>通过高通滤波器进行滤波后，再和原图像叠加，可以增强图像中灰度级变化较快的部分。</p></li><li><p>低通滤波器（LPF）：当中心像素与周围像素的亮度差值大于一个特定值时，平滑该像素的亮度。用于：平滑、模糊、去除噪点。</p><p>低通滤波器容许低频信号通过，但截止了高频信号（噪音，边界）。</p></li></ul><h3 id="自定义滤波"><a href="#自定义滤波" class="headerlink" title="自定义滤波"></a>自定义滤波</h3><ul><li><code>cv2.filter2D(src, ddepth, kernel)</code>：将内核与图像进行卷积。<ul><li><code>ddepth</code>：表示目标图像的所需深度。 当ddepth=-1时，表示输出图像与原图像有相同的深度。</li><li><code>kernel</code>：滤波器/卷积核。如果要将不同的内核应用于不同的通道，需要将图像拆分为单独的颜色平面，分别处理。</li></ul></li><li>在OpenCV中可以自己定义滤波器，然后使用<code>filter2D()</code>对一幅图像进行卷积操作。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="comment"># 高通滤波器模板实现</span></span><br><span class="line">kernel_3x3 = np.array([[-<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>],</span><br><span class="line">                       [-<span class="number">1</span>, <span class="number">8</span>, -<span class="number">1</span>],</span><br><span class="line">                       [-<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>]])</span><br><span class="line">kernel_5x5 = np.array([[-<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>],</span><br><span class="line">                       [-<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>, -<span class="number">1</span>],</span><br><span class="line">                       [-<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">2</span>, -<span class="number">1</span>],</span><br><span class="line">                       [-<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>, -<span class="number">1</span>],</span><br><span class="line">                       [-<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>]])</span><br><span class="line"></span><br><span class="line">img = cv2.imread(<span class="string">&quot;test.jpg&quot;</span>, <span class="number">0</span>)</span><br><span class="line">k3 = cv2.filter2D(img, ddepth=-<span class="number">1</span>, kernel=kernel_3x3)</span><br><span class="line">k5 = cv2.filter2D(img, ddepth=-<span class="number">1</span>, kernel=kernel_5x5)</span><br><span class="line"></span><br><span class="line">cv2.imshow(<span class="string">&quot;img&quot;</span>, img)</span><br><span class="line">cv2.imshow(<span class="string">&quot;3x3&quot;</span>, k3)</span><br><span class="line">cv2.imshow(<span class="string">&quot;5x5&quot;</span>, k5)</span><br><span class="line">cv2.waitKey(<span class="number">0</span>)</span><br></pre></td></tr></table></figure><p><img src="/2021/08/OpenCV-Part2/image-20210829164529053.png" alt="image-20210829164529053"></p><h3 id="常用的图像滤波"><a href="#常用的图像滤波" class="headerlink" title="常用的图像滤波"></a>常用的图像滤波</h3><p>线性滤波（方框滤波、均值滤波、高斯滤波）、非线性滤波（中值滤波、双边滤波）</p><h4 id="方框滤波"><a href="#方框滤波" class="headerlink" title="方框滤波"></a>方框滤波</h4><ul><li><p>方框滤波即一个具有相同权重的二维矩阵。</p></li><li><p>大小 3x3 、权重为 a 的kernel：<img src="/2021/08/OpenCV-Part2/20200525191244444.png" alt="img"></p></li><li><p><code>cv2.boxFilter(src, ddepth, ksize, normalize)</code>：当可选参数 <code>normalize=True</code> 时，方框滤波就是均值滤波，a=1/9； <code>normalize=False</code> 时，a=1，相当于求区域内的像素和。</p></li></ul><h4 id="均值滤波"><a href="#均值滤波" class="headerlink" title="均值滤波"></a>均值滤波</h4><ul><li><code>cv2.blur(src, ksize)</code>：对图像进行均值滤波，即将图像与归一化框滤波器进行卷积。</li><li>保持这个kernel在一个像素点上，获取内核区域下所有像素的平均值，并替换中心元素。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">from</span> matplotlib <span class="keyword">import</span> pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">img = cv2.imread(<span class="string">&#x27;opencv_logo.png&#x27;</span>)[:, :, ::-<span class="number">1</span>]  <span class="comment"># 转换成plt格式</span></span><br><span class="line">kernel = np.ones((<span class="number">5</span>, <span class="number">5</span>), np.float32) / <span class="number">25</span></span><br><span class="line">print(kernel)  <span class="comment"># 5*5的二维矩阵，每个权重为0.04</span></span><br><span class="line"></span><br><span class="line">dst = cv2.filter2D(img, ddepth=-<span class="number">1</span>, kernel=kernel)  <span class="comment"># 法一：filter2D + 手动创建kernel 实现均值滤波</span></span><br><span class="line">dst = cv2.blur(img, (<span class="number">5</span>, <span class="number">5</span>))  <span class="comment"># 法二：blur 直接实现均值滤波</span></span><br><span class="line">dst = cv2.boxFilter(img, ddepth=-<span class="number">1</span>, (<span class="number">5</span>, <span class="number">5</span>), normalize=<span class="literal">True</span>)  <span class="comment"># 法三：boxFilter + normalize=True 实现均值滤波</span></span><br><span class="line"></span><br><span class="line">plt.subplot(<span class="number">121</span>), plt.imshow(img), plt.title(<span class="string">&#x27;Original&#x27;</span>)</span><br><span class="line">plt.xticks([]), plt.yticks([])</span><br><span class="line">plt.subplot(<span class="number">122</span>), plt.imshow(dst), plt.title(<span class="string">&#x27;Averaging&#x27;</span>)</span><br><span class="line">plt.xticks([]), plt.yticks([])</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p> <img src="/2021/08/OpenCV-Part2/filter.jpg" alt="img"></p><h4 id="高斯模糊"><a href="#高斯模糊" class="headerlink" title="高斯模糊"></a>高斯模糊</h4><ul><li>不同于均值滤波，高斯滤波的卷积核权重：中间像素点权重最高，远离中心的像素根据离中心的距离递减，符合正态分布。</li><li>均值滤波是求平均数，高斯滤波是高斯求加权平均数。</li><li><code>cv2.GaussianBlur(src, ksize, sigmaX)</code>：高斯滤波可以有效的从图像中去除高斯噪音。<ul><li>高斯核的宽和高（必须是奇数）</li><li>高斯函数沿 X，Y 方向的标准差。如果只指定了 X 方向的的标准差，Y 方向也会取相同值。如果两个标准差都是 0，那么函数会根据核函数的大小自动计算。</li></ul></li><li><code>cv.getGaussianKernel()</code>：构建一个高斯内核。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">blur = cv2.GaussianBlur(img, (<span class="number">5</span>, <span class="number">5</span>), <span class="number">0</span>)</span><br></pre></td></tr></table></figure><p><img src="/2021/08/OpenCV-Part2/gaussian.jpg" alt="img"></p><h4 id="中位模糊"><a href="#中位模糊" class="headerlink" title="中位模糊"></a>中位模糊</h4><ul><li><code>cv2.medianBlur()</code>：中值模糊，保证了中心元素不会是新计算的值，而是该内核区域中所有像素的中值。</li><li>很容易消除掉孤立的斑点(如0或255)，对于消除椒盐噪声和斑点噪声非常有效。</li><li>中值是一种非线性操作，效率相比线性滤波要慢。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">median = cv2.medianBlur(img, <span class="number">5</span>)</span><br></pre></td></tr></table></figure><p><img src="/2021/08/OpenCV-Part2/median.jpg" alt="img"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sp_noise</span>(<span class="params">image, prob</span>):</span></span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    添加椒盐噪声</span></span><br><span class="line"><span class="string">    prob: 噪声比例</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    output = np.zeros(image.shape, np.uint8)</span><br><span class="line">    thres = <span class="number">1</span> - prob</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(image.shape[<span class="number">0</span>]):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(image.shape[<span class="number">1</span>]):</span><br><span class="line">            rdn = random.random()</span><br><span class="line">            <span class="keyword">if</span> rdn &lt; prob:</span><br><span class="line">                output[i][j] = <span class="number">0</span></span><br><span class="line">            <span class="keyword">elif</span> rdn &gt; thres:</span><br><span class="line">                output[i][j] = <span class="number">255</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                output[i][j] = image[i][j]</span><br><span class="line">    <span class="keyword">return</span> output</span><br></pre></td></tr></table></figure><h4 id="双边滤波"><a href="#双边滤波" class="headerlink" title="双边滤波"></a>双边滤波</h4><ul><li>高斯滤波器是求中心点邻近区域像素的高斯加权平均值，只考虑像素之间的空间关系（平面上的距离），而不会考虑像素值之间的关系（像素值之间的相似度/强度差）。</li><li>所以使用线性滤波器进行模糊无法判断一个像素是否位于边界，基本都会损失掉图像细节信息，边缘信息很难保留下来。</li><li>双边滤波同时使用空间高斯权重和灰度值相似性高斯权重。空间高斯函数确保只有邻近区域的像素对中心点有影响，灰度值相似性高斯函数确保只有与中心像素灰度值相近的才会被用来做模糊运算。由于边缘的像素强度变化较大，因此可以保留边缘。</li><li>双边滤波属于非线性滤波，相比线性滤波会比较慢。</li><li><code>cv2.bilateralFilter()</code>：双边滤波。保持边界清晰的情况下有效去除噪音。<ul><li><code>d</code>：邻域直径</li><li><code>sigmaColor</code>：空间高斯函数标准差</li><li><code>sigmaSpace</code>：灰度值相似性高斯函数标准差</li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bilateralFilter = cv2.bilateralFilter(img, d=<span class="number">9</span>, sigmaColor=<span class="number">75</span>, sigmaSpace=<span class="number">75</span>)</span><br></pre></td></tr></table></figure><img src="/2021/08/OpenCV-Part2/bilateral.jpg" alt="img" style="zoom:200%;"><h2 id="形态学转换"><a href="#形态学转换" class="headerlink" title="形态学转换"></a>形态学转换</h2><h3 id="理论"><a href="#理论" class="headerlink" title="理论"></a>理论</h3><ul><li>形态学操作是根据图像形状进行的简单操作。</li><li>常见图像形态学运算：腐蚀、膨胀、开运算、闭运算、骨架抽取、极线腐蚀、击中击不中变换、Top-hat变换、颗粒分析、流域变换、形态学梯度等。</li><li>最基本的形态学操作是：膨胀(dilation)和腐蚀(erosion)。</li><li>形态学转换在一般情况下是对<strong>二值化图像</strong>进行操作。</li><li>腐蚀和膨胀是对像素值大的部分而言的，即白色(255)部分而不是黑色(0)部分。<ul><li>膨胀就是图像中的高亮部分进行膨胀，效果图拥有比原图<strong>更大的白色区域</strong>。</li><li>腐蚀就是原图中的高亮部分被腐蚀，效果图拥有比原图<strong>更小的白色区域</strong>。</li></ul></li></ul><h3 id="结构元素"><a href="#结构元素" class="headerlink" title="结构元素"></a>结构元素</h3><ul><li><p>形态学操作其实也是将图像与核进行卷积。</p></li><li><p>核（即结构元素/模板/掩码）可以是任何的形状（矩形/椭圆/十字形）和大小，其中心点称为锚点(anchorpoint)。</p></li><li><p><code>cv2.getStructuringElement(shape, ksize)</code>：生成不同形状的结构元素。</p><ul><li><code>shape</code>：形状。</li><li><code>ksize</code>：大小。</li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 矩形内核</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>cv2.getStructuringElement(shape=cv2.MORPH_RECT, ksize=(<span class="number">5</span>, <span class="number">5</span>))</span><br><span class="line">array([[<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>],</span><br><span class="line">       [<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>],</span><br><span class="line">       [<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>],</span><br><span class="line">       [<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>],</span><br><span class="line">       [<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>]], dtype=uint8)</span><br><span class="line"><span class="comment"># 椭圆内核</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>cv2.getStructuringElement(shape=cv2.MORPH_ELLIPSE, ksize=(<span class="number">5</span>, <span class="number">5</span>))</span><br><span class="line">array([[<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">       [<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>],</span><br><span class="line">       [<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>],</span><br><span class="line">       [<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>],</span><br><span class="line">       [<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>]], dtype=uint8)</span><br><span class="line"><span class="comment"># 十字内核</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>cv2.getStructuringElement(shape=cv2.MORPH_CROSS, ksize=(<span class="number">5</span>, <span class="number">5</span>))</span><br><span class="line">array([[<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">       [<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">       [<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>],</span><br><span class="line">       [<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">       [<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>]], dtype=uint8)</span><br></pre></td></tr></table></figure><h3 id="常用的形态学转换"><a href="#常用的形态学转换" class="headerlink" title="常用的形态学转换"></a>常用的形态学转换</h3><ul><li><code>cv2.morphologyEx(src, op, kernel)</code>：形态学转换方法<ul><li><code>op</code>：形态学运算类型。可选包括 侵蚀、膨胀、开闭运算等等。</li></ul></li></ul><h4 id="侵蚀"><a href="#侵蚀" class="headerlink" title="侵蚀"></a>侵蚀</h4><ul><li>侵蚀前景（白色）物体的边界。</li><li>对于原始图像中的每个像素点，内核下的所有像素只要有一个像素为0，则像素元素为0。</li><li>效果：1. 分离出两个独立对象；2. 消除孤立的白色噪点；3. 白色物体中的黑色空洞会被扩大。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">img = cv2.imread(<span class="string">&#x27;j.png&#x27;</span>, cv2.IMREAD_GRAYSCALE)  <span class="comment"># 注意要控制为目标为白色</span></span><br><span class="line">kernel = np.ones((<span class="number">5</span>, <span class="number">5</span>), np.uint8)</span><br><span class="line"></span><br><span class="line">erode = cv2.erode(img, kernel=kernel, iterations=<span class="number">1</span>)</span><br><span class="line">erode = cv2.morphologyEx(img, op=cv2.MORPH_ERODE, kernel=kernel)</span><br></pre></td></tr></table></figure><p><img src="/2021/08/OpenCV-Part2/erosion.png" alt="img"></p><h4 id="扩张"><a href="#扩张" class="headerlink" title="扩张"></a>扩张</h4><ul><li>扩张前景（白色）物体的边界。</li><li>对于原始图像中的每个像素点，内核下的所有像素只要有一个像素为1，则像素元素为1。</li><li>效果：1. 连接两个对象为一个整体；2. 填补白色物体中的黑色空洞；3. 主体外区域的白色噪点会被放大。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dilation = cv2.dilate(img, kernel=kernel, iterations=<span class="number">1</span>) </span><br><span class="line">dilation = cv2.morphologyEx(img, op=cv2.MORPH_DILATE, kernel=kernel)</span><br></pre></td></tr></table></figure><p><img src="/2021/08/OpenCV-Part2/dilation.png" alt="img"></p><h4 id="开运算"><a href="#开运算" class="headerlink" title="开运算"></a>开运算</h4><ul><li>开运算 等价于 <strong>侵蚀</strong>×1+<strong>扩张</strong>×1。</li><li>开运算×1 等价于 开运算×n。</li><li>作用：1. 消除目标外的背景噪音、孤立点；2. 平滑物体轮廓(如果边缘上有凸起)。</li><li>注意：开运算过后的变量名不要设置为open，这与打开文件的方法名重复。闭运算同理。</li></ul><blockquote><ol><li>开/闭运算的精髓在于对细小孤立的白/黑区域(即可能被看做前/背景的噪声)进行消除，而对连续平滑的主体不产生影响。</li><li>对一张黑白图进行开运算 等价于 对其反色的图进行闭运算。</li></ol></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># morphologyEx</span></span><br><span class="line">opening = cv2.morphologyEx(img, op=cv2.MORPH_OPEN, kernel=kernel)</span><br><span class="line"><span class="comment"># erode + dilate</span></span><br><span class="line">erode = cv2.erode(img, kernel=kernel, iterations=<span class="number">1</span>)</span><br><span class="line">opening = cv2.dilate(erode, kernel=kernel, iterations=<span class="number">1</span>)</span><br></pre></td></tr></table></figure><p><img src="/2021/08/OpenCV-Part2/opening.png" alt="img"></p><h4 id="闭运算"><a href="#闭运算" class="headerlink" title="闭运算"></a>闭运算</h4><ul><li>闭运算 等价于 <strong>扩张</strong>×1+<strong>侵蚀</strong>×1。</li><li>闭运算×1 等价于 闭运算×n。</li><li>作用：1. 填补目标内部的黑洞、连接目标裂缝；2. 平滑物体轮廓(如果边缘上有凹陷)。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># morphologyEx</span></span><br><span class="line">closing = cv2.morphologyEx(img, op=cv2.MORPH_CLOSE, kernel=kernel)</span><br><span class="line"><span class="comment"># dilate + erode</span></span><br><span class="line">dilate = cv2.dilate(img, kernel=kernel, iterations=<span class="number">1</span>)</span><br><span class="line">closing = cv2.erode(dilate, kernel=kernel, iterations=<span class="number">1</span>)</span><br></pre></td></tr></table></figure><p><img src="/2021/08/OpenCV-Part2/closing.png" alt="img"></p><h4 id="梯度"><a href="#梯度" class="headerlink" title="梯度"></a>梯度</h4><ul><li>基本梯度 等价于 膨胀后的图像减去腐蚀后的图像。表现图像扩张和侵蚀之间的区别，</li><li>作用：提取对象的轮廓。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># morphologyEx</span></span><br><span class="line">gradient = cv2.morphologyEx(img, op=cv2.MORPH_GRADIENT, kernel=kernel)</span><br><span class="line"><span class="comment"># dilate - erode</span></span><br><span class="line">dilate = cv2.dilate(img, kernel=kernel, iterations=<span class="number">1</span>)</span><br><span class="line">erode = cv2.erode(img, kernel=kernel, iterations=<span class="number">1</span>)</span><br><span class="line">gradient = dilate - erode</span><br></pre></td></tr></table></figure><p><img src="/2021/08/OpenCV-Part2/gradient.jpg" alt="gradient"></p><h4 id="顶帽"><a href="#顶帽" class="headerlink" title="顶帽"></a>顶帽</h4><ul><li>顶帽 等价于 源图像减去开运算后的图像。</li><li>作用：显示开操作所去掉的白噪点。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># morphologyEx</span></span><br><span class="line">tophat = cv2.morphologyEx(img, cv2.MORPH_TOPHAT, kernel) </span><br><span class="line"><span class="comment"># img - open</span></span><br><span class="line">tophat = img - cv2.morphologyEx(img, cv2.MORPH_OPEN, kernel)</span><br></pre></td></tr></table></figure><p><img src="/2021/08/OpenCV-Part2/tophat.jpg" alt="tophat"></p><h4 id="黑帽"><a href="#黑帽" class="headerlink" title="黑帽"></a>黑帽</h4><ul><li>黑帽 等价于 闭运算后的图像减去源图像。</li><li>作用：显示闭操作所填充的黑洞及裂缝。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># morphologyEx</span></span><br><span class="line">blackhat = cv2.morphologyEx(img, cv2.MORPH_BLACKHAT, kernel) </span><br><span class="line"><span class="comment"># close - img</span></span><br><span class="line">blackhat = cv2.morphologyEx(img, cv2.MORPH_CLOSE, kernel) - img</span><br></pre></td></tr></table></figure><p><img src="/2021/08/OpenCV-Part2/blackhat.png" alt="blackhat"></p>]]></content>
      
      
      <categories>
          
          <category> OpenCV </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>OpenCV-Part1</title>
      <link href="/2021/08/OpenCV-Part1/"/>
      <url>/2021/08/OpenCV-Part1/</url>
      
        <content type="html"><![CDATA[<h1 id="OpenCV-Part1——基础操作"><a href="#OpenCV-Part1——基础操作" class="headerlink" title="OpenCV-Part1——基础操作"></a>OpenCV-Part1——基础操作</h1><p>[TOC]</p><h2 id="OpenCV"><a href="#OpenCV" class="headerlink" title="OpenCV"></a>OpenCV</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><ul><li>OpenCV是计算机视觉中经典的专用库。</li><li>OpenCV-Python为OpenCV提供了Python接口，使得使用者在Python中能够调用C/C++，在保证易读性和运行效率的前提下，实现所需的功能。</li><li>所有OpenCV数组结构都与Numpy数组相互转换，所以要使用OpenCV-Python编写优化的代码，必须先明白Numpy。</li><li>本笔记以OpenCV4为主，会有个别版本上的差异，可能的话会提供解决方案。</li></ul><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install opencv-python</span><br></pre></td></tr></table></figure><h2 id="GUI特性"><a href="#GUI特性" class="headerlink" title="GUI特性"></a>GUI特性</h2><h3 id="图像入门"><a href="#图像入门" class="headerlink" title="图像入门"></a>图像入门</h3><h4 id="读取图像"><a href="#读取图像" class="headerlink" title="读取图像"></a>读取图像</h4><ul><li>鉴于兼容windows和linux，文件路径请用<code>/</code>分隔</li><li>文件路径中不得出现中文</li><li>可以选择图像加载方式：<ul><li>cv2.IMREAD_COLOR：默认加载彩色图像。任何图像的透明度都会被忽视。</li><li>cv2.IMREAD_GRAYSCALE：以灰度模式加载图像。</li><li>cv2.IMREAD_UNCHANGED：加载图像，包括alpha通道。</li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">img = cv2.imread(<span class="string">&quot;validation/origin/circle/4101035072410.jpg&quot;</span>, cv2.IMREAD_COLOR)</span><br></pre></td></tr></table></figure><h4 id="显示图像"><a href="#显示图像" class="headerlink" title="显示图像"></a>显示图像</h4><ul><li>图像窗口名称参数不建议使用中文</li><li>如果创建同名窗口两次，则第二张图片会替换前一张图片</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cv2.imshow(<span class="string">&quot;img&quot;</span>, img)</span><br></pre></td></tr></table></figure><h4 id="等待事件"><a href="#等待事件" class="headerlink" title="等待事件"></a>等待事件</h4><ul><li>如果想要暂停并显示图片，必须使用<code>cv2.waitKey(0)</code>，不能用<code>input</code>替代</li><li>可以选择等待时间参数：<ul><li>非零：单位为毫秒，期间如果按下键，则忽略剩余时间、直接运行</li><li>0：无限期地等待一次敲击键</li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cv2.waitKey(<span class="number">0</span>)</span><br></pre></td></tr></table></figure><ul><li>返回参数为keyCode，通过此可以设置检测特定的按键</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> cv2.waitKey(<span class="number">1000</span>) != <span class="built_in">ord</span>(<span class="string">&quot;q&quot;</span>):</span><br><span class="line">    cv2.imshow(<span class="string">&quot;img&quot;</span>, img)</span><br></pre></td></tr></table></figure><h4 id="销毁窗口"><a href="#销毁窗口" class="headerlink" title="销毁窗口"></a>销毁窗口</h4><ul><li>cv2.destroyAllWindows()：会销毁创建的所有窗口</li><li>cv2.destroyWindow()：销毁特定窗口</li></ul><h4 id="创建窗口"><a href="#创建窗口" class="headerlink" title="创建窗口"></a>创建窗口</h4><ul><li>手动创建窗口，并指定窗口是否可以调整大小<ul><li>cv2.WINDOW_AUTOSIZE：默认，按照图像大小固定窗口大小</li><li>cv2.WINDOW_NORMAL：可以自动调整大小，对于大分辨率图像的查看有帮助</li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cv2.namedWindow(<span class="string">&#x27;image&#x27;</span>, cv2.WINDOW_NORMAL)</span><br></pre></td></tr></table></figure><h4 id="写入图像"><a href="#写入图像" class="headerlink" title="写入图像"></a>写入图像</h4><ul><li>同样路径不得出现中文，否则无输出</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cv2.imwrite(<span class="string">&quot;test.jpg&quot;</span>, img)</span><br></pre></td></tr></table></figure><h4 id="OpenCV与其他库"><a href="#OpenCV与其他库" class="headerlink" title="OpenCV与其他库"></a>OpenCV与其他库</h4><h5 id="OpenCV与Matplotlib互转"><a href="#OpenCV与Matplotlib互转" class="headerlink" title="OpenCV与Matplotlib互转"></a>OpenCV与Matplotlib互转</h5><ul><li>OpenCV加载的彩色图像处于BGR模式，但是Matplotlib以RGB模式显示。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">from</span> matplotlib <span class="keyword">import</span> pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">img = cv2.imread(<span class="string">&quot;validation/origin/circle/4101035072410.jpg&quot;</span>)</span><br><span class="line">img = img[:, :, ::-<span class="number">1</span>]</span><br><span class="line">plt.imshow(img)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><h5 id="PIL-Image转换成OpenCV"><a href="#PIL-Image转换成OpenCV" class="headerlink" title="PIL.Image转换成OpenCV"></a>PIL.Image转换成OpenCV</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"><span class="keyword">import</span> numpy</span><br><span class="line"></span><br><span class="line">image = Image.<span class="built_in">open</span>(<span class="string">&quot;test.jpg&quot;</span>)</span><br><span class="line">image.show()</span><br><span class="line">img = cv2.cvtColor(numpy.asarray(image), cv2.COLOR_RGB2BGR)</span><br><span class="line">cv2.imshow(<span class="string">&quot;img&quot;</span>, img)</span><br><span class="line">cv2.waitKey(<span class="number">0</span>)</span><br></pre></td></tr></table></figure><h5 id="OpenCV转换成PIL-Image"><a href="#OpenCV转换成PIL-Image" class="headerlink" title="OpenCV转换成PIL.Image"></a>OpenCV转换成PIL.Image</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"></span><br><span class="line">img = cv2.imread(<span class="string">&quot;test.jpg&quot;</span>)</span><br><span class="line">cv2.imshow(<span class="string">&quot;img&quot;</span>, img)</span><br><span class="line">image = Image.fromarray(cv2.cvtColor(img, cv2.COLOR_BGR2RGB))</span><br><span class="line">image.show()</span><br><span class="line">cv2.waitKey(<span class="number">0</span>)</span><br></pre></td></tr></table></figure><h3 id="视频入门"><a href="#视频入门" class="headerlink" title="视频入门"></a>视频入门</h3><h4 id="读取摄像头视频"><a href="#读取摄像头视频" class="headerlink" title="读取摄像头视频"></a>读取摄像头视频</h4><ul><li>需要创建一个 VideoCapture 对象。它的参数可以是设备索引或视频文件的名称。</li><li><code>cap.read()</code>：返回是否正确读取帧。可以通过检查此返回值来判断是否到达视频的结尾。</li><li><code>cap.isOpened()</code>：返回是否初始化捕获。否则，使用<code>cap.open()</code>打开它。</li><li>当打开视频文件时，播放速度会不受限制，最好是从fps属性动态计算每帧之间相隔的时间，作为参数传入<code>cv2.waitKey()</code></li><li>使用视频捕获必须确保安装了正确的 ffmpeg 或 gstreamer 版本。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"></span><br><span class="line">cap = cv2.VideoCapture(<span class="number">0</span>)</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> cap.isOpened():</span><br><span class="line">    exit(<span class="string">&quot;Cannot open camera&quot;</span>)</span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    ret, frame = cap.read()  <span class="comment"># 逐帧读取</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> ret:  <span class="comment"># 如果成功读取帧，ret为True</span></span><br><span class="line">        print(<span class="string">&quot;Can&#x27;t receive frame (stream end?). Exiting ...&quot;</span>)</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    cv2.imshow(<span class="string">&#x27;frame&#x27;</span>, frame)  <span class="comment"># 显示当前帧</span></span><br><span class="line">    <span class="keyword">if</span> cv2.waitKey(<span class="number">1</span>) == <span class="built_in">ord</span>(<span class="string">&#x27;q&#x27;</span>):</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">cap.release()  <span class="comment"># 完成所有操作后，释放捕获器</span></span><br><span class="line">cv2.destroyAllWindows()</span><br></pre></td></tr></table></figure><h4 id="视频属性"><a href="#视频属性" class="headerlink" title="视频属性"></a>视频属性</h4><h5 id="属性方法"><a href="#属性方法" class="headerlink" title="属性方法"></a>属性方法</h5><ul><li><code>cap.get(propId)</code>：查看视频的属性。</li><li><code>cap.set(propId，value)</code>：修改视频的属性。</li><li>cap画布的长宽上下限似乎和摄像头本身有关。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">cap = cv2.VideoCapture(<span class="number">0</span>)</span><br><span class="line">print(cap.get(cv2.CAP_PROP_FRAME_WIDTH), cap.get(cv2.CAP_PROP_FRAME_HEIGHT))</span><br><span class="line">cap.<span class="built_in">set</span>(cv2.CAP_PROP_FRAME_WIDTH, cap.get(cv2.CAP_PROP_FRAME_WIDTH) * <span class="number">2</span>)</span><br><span class="line">print(cap.get(cv2.CAP_PROP_FRAME_WIDTH), cap.get(cv2.CAP_PROP_FRAME_HEIGHT))</span><br><span class="line">cap.<span class="built_in">set</span>(cv2.CAP_PROP_FRAME_WIDTH, cap.get(cv2.CAP_PROP_FRAME_WIDTH) * <span class="number">0.1</span>)</span><br><span class="line">print(cap.get(cv2.CAP_PROP_FRAME_WIDTH), cap.get(cv2.CAP_PROP_FRAME_HEIGHT))</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">640.0 480.0</span></span><br><span class="line"><span class="string">1280.0 720.0</span></span><br><span class="line"><span class="string">320.0 240.0</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure><h5 id="propId对应表"><a href="#propId对应表" class="headerlink" title="propId对应表"></a>propId对应表</h5><table><thead><tr><th>propid</th><th>属性</th><th>视频流属性</th></tr></thead><tbody><tr><td>0</td><td>CV_CAP_PROP_POS_MSEC</td><td>视频文件以毫秒为单位的当前位置或视频捕获时间戳（就是说你这个位置是视频当中的第几秒第几毫秒）</td></tr><tr><td>1</td><td>CV_CAP_PROP_POS_FRAMES</td><td>基于索引的帧解码/捕获（就是说你现在的位置是视频的第几帧位置）</td></tr><tr><td>2</td><td>CV_CAP_PROP_POS_AVI_RATIO</td><td>视频文件的相对位置:0 -电影,开始1 -电影结束（就是说输出0表示视频刚开始，输出1表示视频结束了）</td></tr><tr><td>3</td><td>CV_CAP_PROP_FRAME_WIDTH</td><td>视频流画面的宽度</td></tr><tr><td>4</td><td>CV_CAP_PROP_FRAME_HEIGHT</td><td>视频流画面的长度</td></tr><tr><td>5</td><td>CV_CAP_PROP_FPS</td><td>视频流的帧频</td></tr><tr><td>6</td><td>CV_CAP_PROP_FOURCC</td><td>编辑器的四字符编码</td></tr><tr><td>7</td><td>CV_CAP_PROP_FRAME_COUNT</td><td>视屏文件的帧数</td></tr><tr><td>8</td><td>CV_CAP_PROP_FORMAT</td><td>Format of the Mat objects returned by retrieve()</td></tr><tr><td>9</td><td>CV_CAP_PROP_MODE</td><td>Backend-specific value indicating the current capture mode</td></tr><tr><td>10</td><td>CV_CAP_PROP_BRIGHTNESS</td><td>Brightness of the image (only for cameras)摄像机图像的亮度(只有摄像头才可以)</td></tr><tr><td>11</td><td>CV_CAP_PROP_CONTRAST</td><td>Contrast of the image (only for cameras).摄像机图像的对比度(只有摄像头才可以)</td></tr><tr><td>12</td><td>CV_CAP_PROP_SATURATION</td><td>Saturation of the image (only for cameras)摄像机图像的饱和度(只有摄像头才可以)</td></tr><tr><td>13</td><td>CV_CAP_PROP_HUE</td><td>图片的色调(只有摄像头才可以)</td></tr><tr><td>14</td><td>CV_CAP_PROP_GAIN</td><td>Gain of the image(只有摄像头才可以)</td></tr><tr><td>15</td><td>CV_CAP_PROP_EXPOSURE</td><td>Exposure 曝光(只有摄像头才可以)</td></tr><tr><td>16</td><td>CV_CAP_PROP_CONVERT_RGB</td><td>布尔值指示是否应该转换为RGB图</td></tr><tr><td>17</td><td>CV_CAP_PROP_WHITE_BALANCE_U</td><td>The U value of the whitebalance setting (note: only supported by DC1394 v 2.x backend currently)</td></tr><tr><td>18</td><td>CV_CAP_PROP_WHITE_BALANCE_V</td><td>The V value of the whitebalance setting (note: only supported by DC1394 v 2.x backend currently)</td></tr><tr><td>19</td><td>CV_CAP_PROP_RECTIFICATION</td><td>Rectification flag for stereo cameras (note: only supported by DC1394 v 2.x backend currently)</td></tr><tr><td>20</td><td>CV_CAP_PROP_ISO_SPEED</td><td>The ISO speed of the camera (note: only supported by DC1394 v 2.x backend currently)</td></tr><tr><td>21</td><td>CV_CAP_PROP_BUFFERSIZE</td><td>Amount of frames stored in internal buffer memory (note: only supported by DC1394 v 2.x backend currently)</td></tr></tbody></table><h4 id="保存视频"><a href="#保存视频" class="headerlink" title="保存视频"></a>保存视频</h4><ul><li>需要创建一个 VideoWriter 对象。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"></span><br><span class="line">cap = cv2.VideoCapture(<span class="number">0</span>)</span><br><span class="line"><span class="comment"># 定义编解码器并创建VideoWriter对象</span></span><br><span class="line">fourcc = cv2.VideoWriter_fourcc(*<span class="string">&#x27;XVID&#x27;</span>)</span><br><span class="line">writer = cv2.VideoWriter(<span class="string">&#x27;output.avi&#x27;</span>, fourcc, <span class="number">30.0</span>, (<span class="number">640</span>, <span class="number">480</span>))</span><br><span class="line"><span class="keyword">while</span> cap.isOpened():</span><br><span class="line">    ret, frame = cap.read()</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> ret:</span><br><span class="line">        print(<span class="string">&quot;Can&#x27;t receive frame (stream end?). Exiting ...&quot;</span>)</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    <span class="comment"># 写翻转的框架</span></span><br><span class="line">    writer.write(frame)</span><br><span class="line">    cv2.imshow(<span class="string">&#x27;frame&#x27;</span>, frame)</span><br><span class="line">    <span class="keyword">if</span> cv2.waitKey(<span class="number">1</span>) == <span class="built_in">ord</span>(<span class="string">&#x27;q&#x27;</span>):</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"><span class="comment"># 完成工作后释放所有内容</span></span><br><span class="line">cap.release()</span><br><span class="line">writer.release()</span><br><span class="line">cv2.destroyAllWindows()</span><br></pre></td></tr></table></figure><h3 id="绘图功能"><a href="#绘图功能" class="headerlink" title="绘图功能"></a>绘图功能</h3><ul><li>color：对于bgr颜色要传递元组，例如<code>(255,0,0)</code>，传递int则视为b值。</li><li>thickness：线条厚度，默认为<code>1</code>；对于封闭图形，<code>-1</code>位填充。</li><li>lineType：线的类型，默认为为8连接线；对于曲线可以设置为抗锯齿线<code>cv2.LINE_AA</code>。</li></ul><h4 id="画线"><a href="#画线" class="headerlink" title="画线"></a>画线</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cv2.line(img, pt1=(<span class="number">0</span>, <span class="number">0</span>), pt2=(<span class="number">511</span>, <span class="number">511</span>), color=(<span class="number">255</span>, <span class="number">0</span>, <span class="number">0</span>), thickness=<span class="number">5</span>, lineType=cv2.LINE_AA)</span><br></pre></td></tr></table></figure><h4 id="画矩形"><a href="#画矩形" class="headerlink" title="画矩形"></a>画矩形</h4><ul><li>两个点分别为左上角和右下角</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cv2.rectangle(img, pt1=(<span class="number">384</span>, <span class="number">0</span>), pt2=(<span class="number">510</span>, <span class="number">128</span>), color=(<span class="number">0</span>, <span class="number">255</span>, <span class="number">0</span>), thickness=<span class="number">3</span>)</span><br></pre></td></tr></table></figure><h4 id="画圆"><a href="#画圆" class="headerlink" title="画圆"></a>画圆</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cv2.circle(img, center=(<span class="number">447</span>, <span class="number">63</span>), radius=<span class="number">63</span>, color=(<span class="number">0</span>, <span class="number">0</span>, <span class="number">255</span>), thickness=-<span class="number">1</span>)</span><br></pre></td></tr></table></figure><h4 id="画椭圆"><a href="#画椭圆" class="headerlink" title="画椭圆"></a>画椭圆</h4><ul><li>angle：按顺时针偏转的角度</li><li>startAngle、endAngle：按顺时针计算区间。[0, 0]则无椭圆，[0, 360]则完整椭圆。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cv2.ellipse(img, center=(<span class="number">256</span>, <span class="number">256</span>), axes=(<span class="number">100</span>, <span class="number">50</span>), angle=<span class="number">0</span>, startAngle=<span class="number">0</span>, endAngle=<span class="number">180</span>, color=<span class="number">255</span>, thickness=-<span class="number">1</span>)</span><br></pre></td></tr></table></figure><p><img src="/2021/08/OpenCV-Part1/image-20210816075339107.png" alt="image-20210816075339107"></p><h4 id="画多边形"><a href="#画多边形" class="headerlink" title="画多边形"></a>画多边形</h4><ul><li>必须转换成int32</li><li>注意pts要用列表装饰</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pts = [[<span class="number">10</span>, <span class="number">5</span>], [<span class="number">20</span>, <span class="number">30</span>], [<span class="number">70</span>, <span class="number">20</span>], [<span class="number">50</span>, <span class="number">10</span>]]</span><br><span class="line">pts = np.array(pts).astype(np.int32).reshape((-<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>))</span><br><span class="line">cv2.polylines(img, pts=[pts], isClosed=<span class="literal">True</span>, color=(<span class="number">0</span>, <span class="number">255</span>, <span class="number">255</span>), thickness=<span class="number">3</span>)</span><br></pre></td></tr></table></figure><h4 id="添加文本"><a href="#添加文本" class="headerlink" title="添加文本"></a>添加文本</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cv2.putText(img, text=<span class="string">&#x27;OpenCV&#x27;</span>, org=(<span class="number">10</span>, <span class="number">350</span>), fontFace=cv2.FONT_HERSHEY_SIMPLEX, </span><br><span class="line">            fontScale=<span class="number">1</span>, color=(<span class="number">255</span>, <span class="number">255</span>, <span class="number">255</span>), thickness=<span class="number">2</span>, lineType=cv2.LINE_AA)</span><br></pre></td></tr></table></figure><h3 id="鼠标作为画笔"><a href="#鼠标作为画笔" class="headerlink" title="鼠标作为画笔"></a>鼠标作为画笔</h3><h4 id="可用事件与回调函数"><a href="#可用事件与回调函数" class="headerlink" title="可用事件与回调函数"></a>可用事件与回调函数</h4><ul><li>列出所有可用事件</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2 <span class="keyword">as</span> cv</span><br><span class="line">events = [i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">dir</span>(cv) <span class="keyword">if</span> <span class="string">&#x27;EVENT&#x27;</span> <span class="keyword">in</span> i]</span><br><span class="line">print( events )</span><br></pre></td></tr></table></figure><ul><li><code>setMouseCallback</code>：鼠标回调函数，参数是固定的，会自动与窗口绑定</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"></span><br><span class="line">drawing = <span class="literal">False</span>  <span class="comment"># 如果按下鼠标，则为真</span></span><br><span class="line">mode = <span class="literal">True</span>  <span class="comment"># 如果为真，绘制矩形。按 m 键可以切换到曲线</span></span><br><span class="line">ix, iy = -<span class="number">1</span>, -<span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 鼠标回调函数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">draw_circle</span>(<span class="params">event, x, y, flags, param</span>):</span></span><br><span class="line">    <span class="keyword">global</span> ix, iy, drawing, mode</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> event == cv2.EVENT_LBUTTONDOWN:</span><br><span class="line">        drawing = <span class="literal">True</span></span><br><span class="line">        ix, iy = x, y</span><br><span class="line">    <span class="keyword">elif</span> event == cv2.EVENT_MOUSEMOVE:</span><br><span class="line">        <span class="keyword">if</span> drawing:</span><br><span class="line">            <span class="keyword">if</span> mode:</span><br><span class="line">                cv2.rectangle(img, (ix, iy), (x, y), (<span class="number">0</span>, <span class="number">255</span>, <span class="number">0</span>), -<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                cv2.circle(img, (x, y), <span class="number">5</span>, (<span class="number">0</span>, <span class="number">0</span>, <span class="number">255</span>), -<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">elif</span> event == cv2.EVENT_LBUTTONUP:</span><br><span class="line">        drawing = <span class="literal">False</span></span><br><span class="line">        <span class="keyword">if</span> mode:</span><br><span class="line">            cv2.rectangle(img, (ix, iy), (x, y), (<span class="number">0</span>, <span class="number">255</span>, <span class="number">0</span>), -<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            cv2.circle(img, (x, y), <span class="number">5</span>, (<span class="number">0</span>, <span class="number">0</span>, <span class="number">255</span>), -<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="comment"># 创建一个黑色的图像，一个窗口，并绑定到窗口的功能</span></span><br><span class="line">    img = np.zeros((<span class="number">512</span>, <span class="number">512</span>, <span class="number">3</span>), np.uint8)</span><br><span class="line">    cv2.namedWindow(<span class="string">&#x27;image&#x27;</span>)</span><br><span class="line">    cv2.setMouseCallback(<span class="string">&#x27;image&#x27;</span>, draw_circle)</span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">not</span> cv2.waitKey(<span class="number">25</span>) &amp; <span class="number">0xFF</span> == <span class="number">27</span>:</span><br><span class="line">        cv2.imshow(<span class="string">&#x27;image&#x27;</span>, img)</span><br><span class="line">    cv2.destroyAllWindows()</span><br></pre></td></tr></table></figure><h2 id="核心操作"><a href="#核心操作" class="headerlink" title="核心操作"></a>核心操作</h2><h3 id="图像基本操作"><a href="#图像基本操作" class="headerlink" title="图像基本操作"></a>图像基本操作</h3><h4 id="访问和修改像素值"><a href="#访问和修改像素值" class="headerlink" title="访问和修改像素值"></a>访问和修改像素值</h4><ul><li><p>对于 BGR 图像，它返回一个由蓝色、绿色和红色值组成的数组。对于灰度图像，只返回相应的灰度。</p></li><li><p>通常会使用numpy切片图像，不建议使用numpy索引来访问、修改单个像素值。</p></li><li><p>访问、修改单个像素值时，使用方法<code>item()</code>和<code>itemset())</code>被认为更好，但是它们始终操作单通道。</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">print(img[<span class="number">100</span>, <span class="number">100</span>])  <span class="comment"># 彩色图片返回 [蓝, 绿, 红]</span></span><br><span class="line"><span class="comment"># [157, 166, 200]</span></span><br><span class="line">print(img[<span class="number">100</span>, <span class="number">100</span>, <span class="number">0</span>])  <span class="comment"># 仅访问蓝色像素</span></span><br><span class="line"><span class="comment"># 157</span></span><br><span class="line">img[<span class="number">100</span>, <span class="number">100</span>] = [<span class="number">157</span>, <span class="number">166</span>, <span class="number">200</span>]  <span class="comment"># 修改像素</span></span><br><span class="line">img[<span class="number">100</span>, <span class="number">100</span>, <span class="number">0</span>] = <span class="number">157</span>  <span class="comment"># 仅修改蓝色像素</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 访问 RED 值</span></span><br><span class="line">print(img.item(<span class="number">10</span>, <span class="number">10</span>, <span class="number">2</span>))  <span class="comment"># 59</span></span><br><span class="line"><span class="comment"># 修改 RED 值</span></span><br><span class="line">img.itemset((<span class="number">10</span>, <span class="number">10</span>, <span class="number">2</span>), <span class="number">100</span>)  </span><br></pre></td></tr></table></figure><h4 id="访问图像属性"><a href="#访问图像属性" class="headerlink" title="访问图像属性"></a>访问图像属性</h4><ul><li><code>img.shape</code>：图像的形状<code>[行数(高height), 列数(宽width), [蓝, 绿, 红]]</code></li><li>如果图像是灰度的，则返回的元组仅包含行数和列数</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">print(img.shape)</span><br><span class="line">(<span class="number">342</span>, <span class="number">548</span>, <span class="number">3</span>)</span><br></pre></td></tr></table></figure><ul><li><code>img.size</code>：像素总数</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">print(img.size)</span><br><span class="line"><span class="comment"># 562248</span></span><br></pre></td></tr></table></figure><ul><li><code>img.dtype</code>：图像数据类型</li><li>img.dtype在调试时非常重要，因为OpenCV-Python代码中的大量错误是由无效的数据类型引起的。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">print( img.dtype )</span><br><span class="line"><span class="comment"># uint8</span></span><br></pre></td></tr></table></figure><h4 id="图像区域切片"><a href="#图像区域切片" class="headerlink" title="图像区域切片"></a>图像区域切片</h4><ul><li>注意，索引顺序是<code>[行数, 列数, 通道]</code>，即<code>[高, 宽, [蓝, 绿, 红]]</code></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将球复制到图像中的另一个区域</span></span><br><span class="line">ball = img[<span class="number">280</span>:<span class="number">340</span>, <span class="number">330</span>:<span class="number">390</span>]</span><br><span class="line">img[<span class="number">273</span>:<span class="number">333</span>, <span class="number">100</span>:<span class="number">160</span>] = ball </span><br></pre></td></tr></table></figure><h4 id="拆分和合并图像通道"><a href="#拆分和合并图像通道" class="headerlink" title="拆分和合并图像通道"></a>拆分和合并图像通道</h4><ul><li><code>cv2.split(img)</code>：切分三个通道</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># split()比较耗时，可以考虑使用np切片</span></span><br><span class="line">b, g, r = cv2.split(img)</span><br><span class="line">b, g, r = img [:, :]</span><br><span class="line"><span class="comment"># 只获取蓝通道，使用numpy更快</span></span><br><span class="line">b = img [:, :, <span class="number">0</span>]</span><br><span class="line"><span class="comment"># 将所有红色像素都设置为零，则无需拆分通道</span></span><br><span class="line">img [:, :, <span class="number">2</span>] = <span class="number">0</span></span><br></pre></td></tr></table></figure><ul><li><code>cv2.merge((b,g,r))</code>：合并三个通道</li><li>可以将灰度图扩展成三通道</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">img = cv2.merge((b,g,r))</span><br></pre></td></tr></table></figure><h4 id="填充边框"><a href="#填充边框" class="headerlink" title="填充边框"></a>填充边框</h4><ul><li><code>cv2.copyMakeBorder()</code>：padding经常使用。<ul><li><code>src</code>：输入图像</li><li><code>top</code>，<code>bottom</code>，<code>left</code>，<code>right</code>：边界宽度</li><li><code>borderType</code>：定义要添加哪种边框的标志。它可以是以下类型：<ul><li><code>cv2.BORDER_CONSTANT</code>：添加恒定的彩色边框。该值应作为下一个参数给出。</li><li><code>cv2.BORDER_REFLECT</code> 或 <code>cv2.BORDER_REFLECT_101</code>或 <code>cv2.BORDER_DEFAULT</code>：边框将是边框元素的镜像</li><li><code>cv2.BORDER_REPLICATE</code>：重复边界最后一个元素被复制</li><li><code>cv2.BORDER_WRAP</code>：将图片复制平铺</li></ul></li><li><code>value</code>：边框的颜色，如果边框类型为 cv.BORDER_CONSTANT</li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">img = cv2.imread(<span class="string">&quot;test.jpg&quot;</span>, cv2.IMREAD_COLOR)</span><br><span class="line"><span class="comment"># 在右边接一张原图</span></span><br><span class="line">img = cv2.copyMakeBorder(img, top=<span class="number">0</span>, bottom=<span class="number">0</span>, left=<span class="number">0</span>, right=img.shape[<span class="number">1</span>], borderType=cv2.BORDER_WRAP)</span><br><span class="line"><span class="comment"># 底部加一条绿边</span></span><br><span class="line">img = cv2.copyMakeBorder(img, top=<span class="number">0</span>, bottom=<span class="number">10</span>, left=<span class="number">0</span>, right=<span class="number">0</span>, borderType=cv2.BORDER_CONSTANT, value=[<span class="number">0</span>, <span class="number">255</span>, <span class="number">0</span>])</span><br><span class="line">cv2.imshow(<span class="string">&quot;img&quot;</span>, img)</span><br><span class="line">cv2.waitKey(<span class="number">0</span>)</span><br></pre></td></tr></table></figure><p><img src="/2021/08/OpenCV-Part1/image-20210818232157400.png" alt="image-20210818232157400"></p><h3 id="图像加法"><a href="#图像加法" class="headerlink" title="图像加法"></a>图像加法</h3><ul><li>可以通过OpenCV函数<code>cv2.add()</code>或numpy操作<code>res = img1 + img2</code>相加两个图像。</li><li>OpenCV加法和Numpy加法之间有区别。OpenCV加法是饱和运算，而Numpy加法是模运算。</li><li>两个图像需要有相同的深度和类型，或者第二个图像可以只是一个标量值。</li><li>一般会使用OpenCV的方法，或直接使用图像融合。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">x = np.uint8([<span class="number">250</span>])</span><br><span class="line">y = np.uint8([<span class="number">10</span>])</span><br><span class="line">print(cv2.add(x, y))  <span class="comment"># 250 + 10 = 260 =&gt; 255</span></span><br><span class="line"><span class="comment"># [[255]]</span></span><br><span class="line">print( x + y )  <span class="comment"># (250 + 10) % 256 = 260 % 256 = 4</span></span><br><span class="line"><span class="comment"># [4]</span></span><br></pre></td></tr></table></figure><h4 id="图像反色"><a href="#图像反色" class="headerlink" title="图像反色"></a>图像反色</h4><ul><li>千万不要用循环！</li><li>需要在指定区域反色的话，就加入mask参数。比如，将黑色背景反转为白色背景。</li><li>因为两者范围都在0-255，所以直接做np减法。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">img = np.full(img.shape, (<span class="number">255</span>, <span class="number">255</span>, <span class="number">255</span>), dtype=np.uint8) - img</span><br></pre></td></tr></table></figure><h3 id="图像融合"><a href="#图像融合" class="headerlink" title="图像融合"></a>图像融合</h3><ul><li><code>cv2.addWeighted()</code>：对图像赋予不同的权重，并相加。</li><li>通过动态更改两张的图像权重<code>0-&gt;1, 1-&gt;0</code>，可以完成一个图像到另一个图像之间的视觉过渡。</li><li>并不要求两者权重相加为1</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">img1 = cv.imread(<span class="string">&#x27;ml.png&#x27;</span>)</span><br><span class="line">img2 = cv.imread(<span class="string">&#x27;opencv-logo.png&#x27;</span>)</span><br><span class="line">dst = cv.addWeighted(img1, <span class="number">0.7</span>, img2, <span class="number">0.3</span>, <span class="number">0</span>)</span><br><span class="line">cv.imshow(<span class="string">&#x27;dst&#x27;</span>, dst)</span><br><span class="line">cv.waitKey(<span class="number">0</span>)</span><br></pre></td></tr></table></figure><p> <img src="http://qiniu.aihubs.net/blending.jpg" alt="img"></p><h3 id="按位运算"><a href="#按位运算" class="headerlink" title="按位运算"></a>按位运算</h3><ul><li><p> <code>AND</code>、 <code>OR</code>、<code>NOT</code>、<code>XOR</code> ：用于提取图像的任意部分、定义和处理非矩形ROI。</p></li><li><p>当需要将A图像覆盖在B图像上时。如果将两个图像相加，则改变颜色。如果将两个图像混合，则获得透明效果。</p><p>如果是矩形区域，则可以像上一章一样使用ROI切片，重置区域数值。A图像不是矩形。因此，可以进行按位操作。、</p></li><li><p>mask需要为np.uint8类型，否则<code>.astype(np.uint8)</code>；mask需要通道数为1，否则<code>mask = mask[:, :, 0]</code></p></li><li><p>前景图片大小不能超过背景，否则会报错</p></li><li><p>mask的含义是：仅mask中的白色区域会进行运算，其他部分全部为黑色</p></li><li><p>最后相加时，要确保相加部分是 0 + img_mask = img_mask；否则依然会出现融合效果</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 加载两张图片</span></span><br><span class="line">img1 = cv2.imread(<span class="string">&#x27;test.jpg&#x27;</span>)</span><br><span class="line">img2 = cv2.imread(<span class="string">&#x27;test2.png&#x27;</span>)</span><br><span class="line">img2 = cv2.resize(img2, (img2.shape[<span class="number">0</span>]//<span class="number">2</span>, img2.shape[<span class="number">1</span>]//<span class="number">2</span>))  <span class="comment"># 控制前景大小</span></span><br><span class="line"><span class="comment"># 想把logo放在左上角，所以在左上角创建了ROI</span></span><br><span class="line">rows, cols, channels = img2.shape</span><br><span class="line">roi = img1[<span class="number">0</span>:rows, <span class="number">0</span>:cols]</span><br><span class="line"><span class="comment"># 现在创建logo的掩码，并同时创建其相反掩码</span></span><br><span class="line">mask_inv = extract_red(img2, cfg=&#123;<span class="string">&quot;debug&quot;</span>: <span class="literal">False</span>&#125;)[:, :, <span class="number">0</span>]  <span class="comment"># mask为单通道</span></span><br><span class="line">mask = cv2.bitwise_not(mask_inv)</span><br><span class="line"><span class="comment"># 现在将ROI中logo的区域涂黑</span></span><br><span class="line">print(roi.dtype, mask_inv.dtype, roi.shape, mask_inv.shape)  <span class="comment"># uint8 uint8 (533, 548, 3) (533, 548)</span></span><br><span class="line">img1_bg = cv2.bitwise_and(roi, roi, mask=mask_inv)</span><br><span class="line"><span class="comment"># 仅从logo图像中提取logo区域</span></span><br><span class="line">img2_fg = cv2.bitwise_and(img2, img2, mask=mask)  <span class="comment"># 仅白色区域会从原图中保留，其他部分全部为黑色</span></span><br><span class="line"><span class="comment"># 将logo放入ROI并修改主图像</span></span><br><span class="line">dst = cv2.add(img1_bg, img2_fg)  <span class="comment"># 要确保相加部分是 0 + img_mask = img_mask；否则依然会出现融合效果</span></span><br><span class="line">img1[<span class="number">0</span>:rows, <span class="number">0</span>:cols] = dst</span><br><span class="line">cv2.imshow(<span class="string">&#x27;res&#x27;</span>, img1)</span><br><span class="line">cv2.waitKey(<span class="number">0</span>)</span><br></pre></td></tr></table></figure><img src="/2021/08/OpenCV-Part1/image-20210819112755771.png" alt="image-20210819112755771"><h2 id="性能衡量和提升技术"><a href="#性能衡量和提升技术" class="headerlink" title="性能衡量和提升技术"></a>性能衡量和提升技术</h2><h3 id="使用OpenCV衡量性能"><a href="#使用OpenCV衡量性能" class="headerlink" title="使用OpenCV衡量性能"></a>使用OpenCV衡量性能</h3><p><code>cv2.getTickCount</code>：函数返回从参考事件（如打开机器的那一刻）到调用此函数那一刻之间的时钟周期数。</p><p><code>cv2.getTickFrequency</code>：函数返回时钟周期的频率或每秒的时钟周期数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">e1 = cv2.getTickCount()</span><br><span class="line"><span class="comment"># 你的执行代码</span></span><br><span class="line">e2 = cv2.getTickCount()</span><br><span class="line">time = (e2 - e1) / cv.getTickFrequency()  <span class="comment"># 计算两次执行函数的时间差</span></span><br></pre></td></tr></table></figure><blockquote><p>使用time.time()函数，然后取两次相差，与上述方法是等价的。</p></blockquote><h3 id="OpenCV中的默认优化"><a href="#OpenCV中的默认优化" class="headerlink" title="OpenCV中的默认优化"></a>OpenCV中的默认优化</h3><p>许多OpenCV函数都默认使用了SSE2、AVX等进行优化。可以使用 <code>cv2.Useoptimized</code> 检查是否启用和 <code>cv2.Setuseoptimized</code> 以启用/禁用优化。</p><h3 id="性能优化技术"><a href="#性能优化技术" class="headerlink" title="性能优化技术"></a>性能优化技术</h3><p>首先尝试以一种简单的方式实现算法。然后，分析、找到瓶颈，再进行优化。</p><p>使用下面的技巧来充分利用 Python 和 Numpy 的最大性能。</p><ol><li>Python标量操作比Numpy标量操作快。因此，对于包含一两个元素的运算，Python标量比Numpy数组好。当数组大小稍大时，Numpy会占优势。</li><li>通常，OpenCV函数比Numpy函数要快。因此，对于相同的操作，首选OpenCV功能。但是，可能会有例外，尤其是当Numpy处理视图而不是副本时。</li><li>尽量避免在Python中使用循环，尤其是双/三重循环等。</li><li>由于Numpy和OpenCV已针对向量运算进行了优化，因此将算法/代码向量化到最大程度。</li><li>利用缓存一致性。</li><li>除非需要，否则切勿创建数组的副本。尝试改用视图。数组复制是一项昂贵的操作。</li></ol><p>执行了所有这些操作后，如果仍然很慢，或者不可避免地需要使用大循环，请使用Cython等其他库来使其更快。</p><h3 id="其他资源"><a href="#其他资源" class="headerlink" title="其他资源"></a>其他资源</h3><ol><li>Python优化技术：<a href="http://wiki.python.org/moin/PythonSpeed/PerformanceTips">http://wiki.python.org/moin/PythonSpeed/PerformanceTips</a></li><li>Scipy讲义- 高级Numpy：<a href="http://scipy-lectures.github.io/advanced/advanced_numpy/index.html#advanced-numpy">http://scipy-lectures.github.io/advanced/advanced_numpy/index.html#advanced-numpy</a></li><li>IPython中的时序和性能分析：<a href="http://pynash.org/2013/03/06/timing-and-profiling/">http://pynash.org/2013/03/06/timing-and-profiling/</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> OpenCV </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Django-完结目录</title>
      <link href="/2021/08/Django-%E5%AE%8C%E7%BB%93%E7%9B%AE%E5%BD%95/"/>
      <url>/2021/08/Django-%E5%AE%8C%E7%BB%93%E7%9B%AE%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<h1 id="Django——完结目录"><a href="#Django——完结目录" class="headerlink" title="Django——完结目录"></a>Django——完结目录</h1><p>教程视频传送门：</p><ol><li><a href="https://www.bilibili.com/video/BV1QE41147hU?p=704">老男孩Python全栈开发29期全套(2020年3月开班)-同步更新</a></li></ol><p>推荐资源：</p><ol><li><a href="https://www.runoob.com/django/django-tutorial.html">菜鸟教程</a></li><li><a href="https://code.ziqiangxuetang.com/django/django-tutorial.html">自强学堂</a></li><li><a href="https://www.cnblogs.com/Dominic-Ji/p/10881214.html">https://www.cnblogs.com/Dominic-Ji/p/10881214.html</a></li></ol><p>讲的非常好，但是重点偏向全栈，需要再模仿、学习前后端分离的项目架构。</p><p>讲法偏向循序渐进，做笔记的时候顺序不建议按照课程来，需要二次整理。</p><p>==DRF框架==：<a href="https://www.bilibili.com/video/BV1Sz4y1o7E8?p=3">https://www.bilibili.com/video/BV1Sz4y1o7E8?p=3</a></p><table><thead><tr><th align="center"><a href="/2021/08/Django-Part1/">Django-Part1——基础操作</a></th></tr></thead><tbody><tr><td align="center"><strong><a href="/2021/08/Django-Part2/">Django-Part2——路由层</a></strong></td></tr><tr><td align="center"><strong><a href="/2021/08/Django-Part3/">Django-Part3——视图层</a></strong></td></tr><tr><td align="center"><strong><a href="/2021/08/Django-Part4/">Django-Part4——模型层</a></strong></td></tr><tr><td align="center"><strong><a href="/2021/08/Django-Part5/">Django-Part5——数据交互</a></strong></td></tr><tr><td align="center"><a href="/2021/08/Django-Part6/"><strong>Django-Part6——中间件与Auth模块</strong></a></td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> Django </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Web </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Django-Part6</title>
      <link href="/2021/08/Django-Part6/"/>
      <url>/2021/08/Django-Part6/</url>
      
        <content type="html"><![CDATA[<h1 id="Django-Part6——中间件与Auth模块"><a href="#Django-Part6——中间件与Auth模块" class="headerlink" title="Django-Part6——中间件与Auth模块"></a>Django-Part6——中间件与Auth模块</h1><p>[TOC]</p><h2 id="Django中间件"><a href="#Django中间件" class="headerlink" title="Django中间件"></a>Django中间件</h2><h3 id="中间件简介"><a href="#中间件简介" class="headerlink" title="中间件简介"></a>中间件简介</h3><ul><li>django自带七个中间件，并且支持程序员自定义中间件</li><li>只要是涉及到全局相关的功能都可以使用中间件完成</li><li>全局用户身份、权限校验<ul><li>全局访问频率校验</li></ul></li><li>…</li><li>django中间件是django的门户<ul><li>请求需要先经过中间件才能到达django后端</li><li>响应也需要经过中间件才能发送出去</li></ul></li></ul><h3 id="自定义中间件"><a href="#自定义中间件" class="headerlink" title="自定义中间件"></a>自定义中间件</h3><ul><li><p>中间件可以在项目名或者应用名下任意名称的文件夹中定义</p></li><li><p>自定义中间件类必须继承于MiddlewareMixin类</p></li><li><p>需要将类的路径以字符串的形式注册到配置文件中才能生效</p></li><li><p>中间件将暴露五个可以自定义的方法，按需求重写</p><ul><li><p><code>process_request(self, request)</code>：</p><ol><li><p>请求来的时候需要经过每一个中间件里面的process_request方法</p></li><li><p>顺序是按照配置文件中注册的中间件从上往下的顺序依次执行</p></li><li><p>如果中间件里面没有定义该方法，则跳过</p></li><li><p>如果该方法返回了HttpResponse对象，则请求将不再继续往后执行，而是从同级别的process_reponse向上原路返回</p><p>flask中即使中途返回数据，但依然经过所有中间件</p></li></ol><p>process_request方法可以用来做全局相关的所有限制功能</p></li><li><p><code>process_response(self, request, response)</code>：</p><ol><li>响应走的时候需要经过每一个中间件里面的process_response方法</li><li>顺序是按照配置文件中注册了的中间件从下往上依次经过</li><li>如果中间件里面没有定义该方法，则跳过</li><li>该方法必须返回一个HttpResponse对象，默认返回的就是形参response</li></ol></li><li><p><code>process_view(self, request, view_func, view_args, view_kwargs)</code>：</p><ol><li>触发时间在路由匹配成功之后，执行视图函数之前</li><li>顺序是按照配置文件中注册的中间件从上往下的顺序依次执行</li></ol></li><li><p><code>process_template_response(self, request, response)</code>：</p><ol><li>返回的HttpResponse对象有render属性的时候才会触发</li><li>顺序是按照配置文件中注册了的中间件从下往上依次经过</li></ol></li><li><p><code>process_exception(self, request, exception)</code>：</p><ol><li>当视图函数中出现异常的情况下触发</li><li>顺序是按照配置文件中注册了的中间件从下往上依次经过</li></ol></li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.utils.deprecation <span class="keyword">import</span> MiddlewareMixin</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MD1</span>(<span class="params">MiddlewareMixin</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">process_request</span>(<span class="params">self, request</span>):</span></span><br><span class="line">        print(<span class="string">&quot;MD1里面的 process_request&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">process_response</span>(<span class="params">self, request, response</span>):</span></span><br><span class="line">        print(<span class="string">&quot;MD1里面的 process_response&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> response</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">process_view</span>(<span class="params">self, request, view_func, view_args, view_kwargs</span>):</span></span><br><span class="line">        print(<span class="string">&quot;-&quot;</span> * <span class="number">80</span>)</span><br><span class="line">        print(<span class="string">&quot;MD1 中的process_view&quot;</span>)</span><br><span class="line">        print(view_func, view_func.__name__)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">process_exception</span>(<span class="params">self, request, exception</span>):</span></span><br><span class="line">        print(exception)</span><br><span class="line">        print(<span class="string">&quot;MD1 中的process_exception&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> HttpResponse(<span class="built_in">str</span>(exception))</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">process_template_response</span>(<span class="params">self, request, response</span>):</span></span><br><span class="line">        print(<span class="string">&quot;MD1 中的process_template_response&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> response</span><br></pre></td></tr></table></figure><h3 id="csrf跨站请求伪造"><a href="#csrf跨站请求伪造" class="headerlink" title="csrf跨站请求伪造"></a>csrf跨站请求伪造</h3><h4 id="使用cookie完成csrf校验"><a href="#使用cookie完成csrf校验" class="headerlink" title="使用cookie完成csrf校验"></a>使用cookie完成csrf校验</h4><ul><li>为了确保请求来源是本服务器发送出去的</li><li>为每一次发出去的页面提供唯一标识，如果校验标识失败则直接拒绝(403 forbbiden)</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src=<span class="string">&quot;get请求url&quot;</span>&gt;&lt;/script&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Ajax CSRF in cookies start</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getCookie</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> cookieValue = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">document</span>.cookie &amp;&amp; <span class="built_in">document</span>.cookie !== <span class="string">&#x27;&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">var</span> cookies = <span class="built_in">document</span>.cookie.split(<span class="string">&#x27;;&#x27;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; cookies.length; i++) &#123;</span><br><span class="line">            <span class="keyword">var</span> cookie = jQuery.trim(cookies[i]);</span><br><span class="line">            <span class="comment">// Does this cookie string begin with the name we want?</span></span><br><span class="line">            <span class="keyword">if</span> (cookie.substring(<span class="number">0</span>, name.length + <span class="number">1</span>) === (name + <span class="string">&#x27;=&#x27;</span>)) &#123;</span><br><span class="line">                cookieValue = <span class="built_in">decodeURIComponent</span>(cookie.substring(name.length + <span class="number">1</span>));</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cookieValue;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> csrftoken = getCookie(<span class="string">&#x27;csrftoken&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">csrfSafeMethod</span>(<span class="params">method</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// these HTTP methods do not require CSRF protection</span></span><br><span class="line">  <span class="keyword">return</span> (<span class="regexp">/^(GET|HEAD|OPTIONS|TRACE)$/</span>.test(method));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$.ajaxSetup(&#123;</span><br><span class="line">  beforeSend: <span class="function"><span class="keyword">function</span> (<span class="params">xhr, settings</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!csrfSafeMethod(settings.type) &amp;&amp; !<span class="built_in">this</span>.crossDomain) &#123;</span><br><span class="line">      xhr.setRequestHeader(<span class="string">&quot;X-CSRFToken&quot;</span>, csrftoken);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// Ajax CSRF in cookies end</span></span><br></pre></td></tr></table></figure><ol><li>如果使用从cookie中取csrftoken的方式，需要确保cookie存在csrftoken值。</li><li> 如果你的视图渲染的HTML文件中没有包含 {% csrf_token %}，Django可能不会设置CSRFtoken的cookie。</li><li>这个时候需要使用ensure_csrf_cookie()装饰器强制设置Cookie。</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">django.views.decorators.csrf <span class="keyword">import</span> ensure_csrf_cookie</span><br><span class="line"> </span><br><span class="line"><span class="meta">@ensure_csrf_cookie</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">login</span>(<span class="params">request</span>):</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><h4 id="csrf相关装饰器"><a href="#csrf相关装饰器" class="headerlink" title="csrf相关装饰器"></a>csrf相关装饰器</h4><ul><li>@csrf_protect：需要校验</li><li>@csrf_exempt：忽视校验</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.views.decorators.csrf <span class="keyword">import</span> csrf_protect, csrf_exempt</span><br><span class="line"><span class="keyword">from</span> django.utils.decorators <span class="keyword">import</span> method_decorator</span><br><span class="line"></span><br><span class="line"><span class="comment"># @csrf_exempt</span></span><br><span class="line"><span class="comment"># @csrf_protect</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">transfer</span>(<span class="params">request</span>):</span></span><br><span class="line">    <span class="keyword">if</span> request.method == <span class="string">&#x27;POST&#x27;</span>:</span><br><span class="line">        username = request.POST.get(<span class="string">&#x27;username&#x27;</span>)</span><br><span class="line">        target_user = request.POST.get(<span class="string">&#x27;target_user&#x27;</span>)</span><br><span class="line">        money = request.POST.get(<span class="string">&#x27;money&#x27;</span>)</span><br><span class="line">        print(<span class="string">&#x27;%s给%s转了%s元&#x27;</span>%(username,target_user,money))</span><br><span class="line">    <span class="keyword">return</span> render(request,<span class="string">&#x27;transfer.html&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> django.views <span class="keyword">import</span> View</span><br><span class="line"></span><br><span class="line"><span class="comment"># @method_decorator(csrf_protect, name=&#x27;post&#x27;)  # 针对csrf_protect 第二种方式可以</span></span><br><span class="line"><span class="comment"># @method_decorator(csrf_exempt, name=&#x27;post&#x27;)  # 针对csrf_exempt 第二种方式不可以</span></span><br><span class="line"><span class="meta">@method_decorator(<span class="params">csrf_exempt, name=<span class="string">&#x27;dispatch&#x27;</span></span>)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyCsrfToken</span>(<span class="params">View</span>):</span></span><br><span class="line">    <span class="comment"># @method_decorator(csrf_protect)  # 针对csrf_protect 第三种方式可以</span></span><br><span class="line">    <span class="comment"># @method_decorator(csrf_exempt)  # 针对csrf_exempt 第三种方式可以</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dispatch</span>(<span class="params">self, request, *args, **kwargs</span>):</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>(MyCsrfToken, self).dispatch(request, *args, **kwargs)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span>(<span class="params">self,request</span>):</span></span><br><span class="line">        <span class="keyword">return</span> HttpResponse(<span class="string">&#x27;get&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># @method_decorator(csrf_protect)  # 针对csrf_protect 第一种方式可以</span></span><br><span class="line">    <span class="comment"># @method_decorator(csrf_exempt)  # 针对csrf_exempt 第一种方式不可以</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">post</span>(<span class="params">self,request</span>):</span></span><br><span class="line">        <span class="keyword">return</span> HttpResponse(<span class="string">&#x27;post&#x27;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="跨域请求"><a href="#跨域请求" class="headerlink" title="跨域请求"></a>跨域请求</h3><ul><li>对于前后端分离的报错：<code>has been blocked by CORS policy: NO &#39;Access-Control-Allow-Origin&#39; header is present on the reauested resource.</code></li></ul><h4 id="同源策略"><a href="#同源策略" class="headerlink" title="同源策略"></a>同源策略</h4><ul><li>浏览器的同源策略：浏览器发现ip或端口是不一样的，就会认为存在风险，会进行拦截。</li><li>推荐的方法是使用Nginx进行反向代理。</li></ul><h4 id="添加响应头解决跨域"><a href="#添加响应头解决跨域" class="headerlink" title="添加响应头解决跨域"></a>添加响应头解决跨域</h4><ul><li>解决思路就是告诉浏览器：不进行拦截。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -&gt; app01/middlewares/Mycors.py</span></span><br><span class="line"><span class="keyword">from</span> django.utils.deprecation <span class="keyword">import</span> MiddlewareMixin</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyCors</span>(<span class="params">MiddlewareMixin</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">process_response</span>(<span class="params">self, request, response</span>):</span></span><br><span class="line">        response[<span class="string">&quot;Access-Control-Allow-Origin&quot;</span>] = <span class="string">&quot;*&quot;</span></span><br><span class="line">        <span class="keyword">if</span> request.method == <span class="string">&quot;OPTIONS&quot;</span>:</span><br><span class="line">            response[<span class="string">&quot;Access-Control-Allow-Headers&quot;</span>] = <span class="string">&quot;Content-Type&quot;</span></span><br><span class="line">            response[<span class="string">&quot;Access-Control-Allow-Methods&quot;</span>] = <span class="string">&quot;DELETE, PUT, POST&quot;</span></span><br><span class="line">        <span class="keyword">return</span> response</span><br><span class="line"></span><br><span class="line"><span class="comment"># -&gt; DjangoProject/settings.py</span></span><br><span class="line">MIDDLEWARE = [</span><br><span class="line">    ...</span><br><span class="line">    <span class="string">&#x27;app01.middlewares.Mycors.MyCors&#x27;</span>,</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h2 id="配置文件与反射"><a href="#配置文件与反射" class="headerlink" title="配置文件与反射"></a>配置文件与反射</h2><h3 id="importlib模块"><a href="#importlib模块" class="headerlink" title="importlib模块"></a>importlib模块</h3><p>使用importlib，以字符串形式导入模块</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> myfile <span class="keyword">import</span> b</span><br><span class="line">print(b)</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> importlib</span><br><span class="line">res = <span class="string">&#x27;myfile.b&#x27;</span></span><br><span class="line">ret = importlib.import_module(res)  <span class="comment"># 该方法最小只能到py文件名</span></span><br><span class="line">print(ret)</span><br></pre></td></tr></table></figure><h3 id="实例展示"><a href="#实例展示" class="headerlink" title="实例展示"></a>实例展示</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> settings</span><br><span class="line"><span class="keyword">import</span> importlib</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">send_all</span>(<span class="params">content</span>):</span></span><br><span class="line">    <span class="keyword">for</span> path_str <span class="keyword">in</span> settings.NOTIFY_LIST:  <span class="comment"># &#x27;notify.email.Email&#x27;</span></span><br><span class="line">        module_path,class_name = path_str.rsplit(<span class="string">&#x27;.&#x27;</span>, maxsplit=<span class="number">1</span>)</span><br><span class="line">        <span class="comment"># module_path = &#x27;notify.email&#x27;  class_name = &#x27;Email&#x27;</span></span><br><span class="line">        <span class="comment"># 1 利用字符串导入模块</span></span><br><span class="line">        module = importlib.import_module(module_path)  <span class="comment"># from notify import email</span></span><br><span class="line">        <span class="comment"># 2 利用反射获取类名</span></span><br><span class="line">        cls = <span class="built_in">getattr</span>(module, class_name)  <span class="comment"># Email、QQ、Wechat</span></span><br><span class="line">        <span class="comment"># 3 生成类的对象</span></span><br><span class="line">        obj = cls()</span><br><span class="line">        <span class="comment"># 4 利用鸭子类型直接调用send方法</span></span><br><span class="line">        obj.send(content)</span><br></pre></td></tr></table></figure><h2 id="Auth模块"><a href="#Auth模块" class="headerlink" title="Auth模块"></a>Auth模块</h2><blockquote><p> 使用auth模块要用就用全套</p></blockquote><p>Django的admin路由对应的就是就是auth_user表，必须是管理员用户才能进入。</p><p>创建超级用户(管理员)：<code>python3 manage.py createsuperuser</code></p><h3 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h3><ul><li><code>auth.authenticate(request, username, password)</code>：根据用户名在表中查询加密后的密码，并将请求中的密码加密比对是否正确。返回用户对象，不匹配则返回None</li><li><code>auth.login(request, user_obj)</code>：保存用户状态，建立session。执行该方法后，可以在任何地方通过<code>request.user</code>获取到当前登陆的用户对象</li><li><code>request.user</code>：</li><li><code>request.user.is_authenticated()</code>：判断当前用户是否登陆</li><li><code>@login_required</code>：校验登录装饰器<ul><li>局部配置：<code>@login_required(login_url=&#39;/login/&#39;)</code></li><li>全局配置：<code>settings.py -&gt; LOGIN_URL = &#39;/login/&#39;</code></li></ul></li><li><code>request.user.check_password(old_password)</code>：将请求中的密码加密，并比对原密码</li><li><code>request.user.set_password(new_password)</code>：修改用户对象的密码</li><li><code>request.user.save()</code>：将修改密码后的用户对象写入数据库</li><li><code>auth.logout(request)</code> ：注销，清除双方session</li><li><code>User.objects.create_user(username=username,password=password)</code>：注册用户。注意不能使用<code>create</code>方法，该方法不对密码进行加密。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">login</span>(<span class="params">request</span>):</span></span><br><span class="line">    <span class="keyword">if</span> request.method == <span class="string">&#x27;POST&#x27;</span>:</span><br><span class="line">        username = request.POST.get(<span class="string">&#x27;username&#x27;</span>)</span><br><span class="line">        password = request.POST.get(<span class="string">&#x27;password&#x27;</span>)</span><br><span class="line">        user_obj = auth.authenticate(request, username=username, password=password)</span><br><span class="line">        print(user_obj)  <span class="comment"># 用户对象，不存在则返回None</span></span><br><span class="line">        print(user_obj.username)  <span class="comment"># jason</span></span><br><span class="line">        print(user_obj.password)  <span class="comment"># pbkdf2_sha256$36000$zeNDf8CkZj7y$b+e/CjzZoAnbBIpvUWgz25ybBDqDzRTmYAHPytxqRYQ=</span></span><br><span class="line">        <span class="comment"># 判断当前用户是否存在</span></span><br><span class="line">        <span class="keyword">if</span> user_obj:</span><br><span class="line">            auth.login(request, user_obj)  <span class="comment"># 保持用户状态，类似于request.session[key] = user_obj</span></span><br><span class="line">            <span class="comment"># 执行该方法后，可以在任何地方通过request.user获取到当前登陆的用户对象</span></span><br><span class="line">            <span class="keyword">return</span> redirect(<span class="string">&#x27;/home/&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> render(request, <span class="string">&#x27;login.html&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@login_required(<span class="params">login_url=<span class="string">&#x27;/login/&#x27;</span></span>)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">home</span>(<span class="params">request</span>):</span></span><br><span class="line">    print(request.user)  <span class="comment"># 在django_session中判断用户是否登陆，没有登录则为AnonymousUser匿名用户</span></span><br><span class="line">    print(request.user.is_authenticated())</span><br><span class="line">    <span class="keyword">return</span> HttpResponse(<span class="string">&#x27;home&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@login_required</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">set_password</span>(<span class="params">request</span>):</span></span><br><span class="line">    <span class="keyword">if</span> request.method == <span class="string">&#x27;POST&#x27;</span>:</span><br><span class="line">        old_password = request.POST.get(<span class="string">&#x27;old_password&#x27;</span>)</span><br><span class="line">        new_password = request.POST.get(<span class="string">&#x27;new_password&#x27;</span>)</span><br><span class="line">        confirm_password = request.POST.get(<span class="string">&#x27;confirm_password&#x27;</span>)</span><br><span class="line">        <span class="comment"># 校验两次密码是否一致、老密码是否正确</span></span><br><span class="line">        <span class="keyword">if</span> new_password == confirm_password <span class="keyword">and</span> request.user.check_password(old_password):</span><br><span class="line">            request.user.set_password(new_password)  <span class="comment"># 仅仅是在修改对象的密码属性</span></span><br><span class="line">            request.user.save()  <span class="comment"># 这一步才是真正的操作数据库</span></span><br><span class="line">        <span class="keyword">return</span> redirect(<span class="string">&#x27;/login/&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> render(request, <span class="string">&#x27;set_password.html&#x27;</span>, <span class="built_in">locals</span>())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@login_required</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">logout</span>(<span class="params">request</span>):</span></span><br><span class="line">    auth.logout(request)  <span class="comment"># 类似于request.session.flush()</span></span><br><span class="line">    <span class="keyword">return</span> redirect(<span class="string">&#x27;/login/&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">register</span>(<span class="params">request</span>):</span></span><br><span class="line">    <span class="keyword">if</span> request.method == <span class="string">&#x27;POST&#x27;</span>:</span><br><span class="line">        username = request.POST.get(<span class="string">&#x27;username&#x27;</span>)</span><br><span class="line">        password = request.POST.get(<span class="string">&#x27;password&#x27;</span>)</span><br><span class="line">        User.objects.create_user(username=username, password=password)  <span class="comment"># 创建普通用户</span></span><br><span class="line">    <span class="keyword">return</span> render(request, <span class="string">&#x27;register.html&#x27;</span>)</span><br></pre></td></tr></table></figure><h3 id="扩展auth-user表"><a href="#扩展auth-user表" class="headerlink" title="扩展auth_user表"></a>扩展auth_user表</h3><ul><li>面向对象继承，自由增加字段，对象可以直接访问字段</li><li>如果继承了<code>AbstractUser</code>，那么在执行数据库迁移命令的时候<code>auth_user</code>表就不会再创建出来了，而是替换成定义的子类</li><li>auth模块的功能还是照常使用</li><li>前提：<ol><li>在继承之前没有执行过数据库迁移命令、auth_user没有被创建</li><li>继承的类里面不要覆盖<code>AbstractUser</code>里面的字段名，只扩展额外字段</li><li>需要在配置文件中添加<code>AUTH_USER_MODEL = &#39;app01.UserInfo&#39;</code></li></ol></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserInfo</span>(<span class="params">AbstractUser</span>):</span></span><br><span class="line">    phone = models.BigIntegerField()</span><br></pre></td></tr></table></figure><h2 id="BBS实战"><a href="#BBS实战" class="headerlink" title="BBS实战"></a>BBS实战</h2><h3 id="表设计"><a href="#表设计" class="headerlink" title="表设计"></a>表设计</h3><ol><li><p>用户表(AbstractUser)</p><ul><li>phone：电话号码</li><li>avatar：用户头像</li><li>create_time：创建时间</li><li>一对一：个人站点表</li></ul></li><li><p>个人站点表</p><ul><li>site_name：站点名称</li><li>site_title：站点标题</li><li>site_theme：站点样式</li></ul></li><li><p>文章标签表</p><ul><li>name：标签名</li><li>一对多：个人站点</li></ul></li><li><p>文章分类表</p><ul><li>name：分类名</li><li>一对多：个人站点</li></ul></li><li><p>文章表</p><ul><li><p>title：文章标题</p></li><li><p>desc：文章简介</p></li><li><p>content：文章内容</p></li><li><p>create_time：发布时间</p><p>数据库字段设计优化：虽然下述的三个字段可以从其他表里面跨表查询计算得出，但是频繁跨表效率</p></li><li><p>up_num：点赞数</p></li><li><p>down_num：点踩数</p></li><li><p>comment_num：评论数</p></li><li><p>一对多个人站点</p></li><li><p>多对多文章标签</p></li><li><p>一对多文章分类</p></li></ul></li><li><p>点赞点踩表（记录哪个用户给哪篇文章点了赞还是点了踩）</p><ul><li>user：ForeignKey(to=”User”)</li><li>article：ForeignKey(to=”Article”)    </li><li>is_up：BooleanField()</li></ul></li><li><p>文章评论表</p><ul><li><p>user：ForeignKey(to=”User”)                </p></li><li><p>article：ForeignKey(to=”Article”)</p></li><li><p>content：CharField()</p></li><li><p>comment_time：DateField()</p></li><li><p>parent：ForeignKey(to=”self/Comment”,null=True)</p><p>根评论子评论，评论当前发布的内容，根评论与子评论是一对多的关系</p></li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> Django </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Django-Part5</title>
      <link href="/2021/08/Django-Part5/"/>
      <url>/2021/08/Django-Part5/</url>
      
        <content type="html"><![CDATA[<h1 id="Django-Part5——数据交互"><a href="#Django-Part5——数据交互" class="headerlink" title="Django-Part5——数据交互"></a>Django-Part5——数据交互</h1><p>[TOC]</p><h2 id="前后端交互"><a href="#前后端交互" class="headerlink" title="前后端交互"></a>前后端交互</h2><h3 id="发送请求的方式"><a href="#发送请求的方式" class="headerlink" title="发送请求的方式"></a>发送请求的方式</h3><ol><li>浏览器地址栏直接输入url回车 (GET)</li><li>a标签href属性 (GET)</li><li>form表单 (GET/POST)</li><li>ajax (GET/POST)    </li></ol><h2 id="Ajax"><a href="#Ajax" class="headerlink" title="Ajax"></a>Ajax</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><ul><li><p>Ajax 最大的优点是异步提交，局部刷新。</p></li><li><p>AJAX 不是新的编程语言，而是一种使用现有标准的新方法。</p></li><li><p>Ajax 在这里只学习jQuery封装之后的版本，而不是原生的。所以在前端页面使用ajax的时候需要确保导入了jQuery。</p></li><li><p>并不只有jQuery能够实现ajax，其他的框架也可以，原理是一样的。</p></li></ul><p>demo：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">href</span>=<span class="string">&quot;https://cdn.bootcss.com/twitter-bootstrap/3.4.1/css/bootstrap.min.css&quot;</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://cdn.bootcss.com/jquery/3.3.1/jquery.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://cdn.bootcss.com/twitter-bootstrap/3.4.1/js/bootstrap.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">id</span>=<span class="string">&quot;i1&quot;</span>&gt;</span> + <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">id</span>=<span class="string">&quot;i2&quot;</span>&gt;</span> = <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">id</span>=<span class="string">&quot;i3&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">&quot;btn&quot;</span>&gt;</span>点我<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    $(<span class="string">&#x27;#btn&#x27;</span>).click(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        $.ajax(&#123;</span></span><br><span class="line"><span class="javascript">            <span class="comment">// 1. 指定朝哪个地址发请求</span></span></span><br><span class="line"><span class="javascript">            url: <span class="string">&quot;&quot;</span>,  <span class="comment">// 不写就是朝当前页面发</span></span></span><br><span class="line"><span class="javascript">            <span class="comment">// 2. 请求方式</span></span></span><br><span class="line"><span class="javascript">            type: <span class="string">&#x27;post&#x27;</span>, <span class="comment">// 不指定，默认为get，都是小写</span></span></span><br><span class="line"><span class="javascript">            <span class="comment">// 3. 数据，post和get携带参数都是用data表示</span></span></span><br><span class="line">            &#123;#data:&#123;&#x27;username&#x27;: &#x27;jason&#x27;, &#x27;password&#x27;: 123&#125;,#&#125;</span><br><span class="line">            data: &#123;</span><br><span class="line"><span class="javascript">                <span class="string">&#x27;i1&#x27;</span>: $(<span class="string">&#x27;#i1&#x27;</span>).val(),</span></span><br><span class="line"><span class="javascript">                <span class="string">&#x27;i2&#x27;</span>: $(<span class="string">&#x27;#i2&#x27;</span>).val()</span></span><br><span class="line">            &#125;,</span><br><span class="line"><span class="javascript">            <span class="comment">// 4. 回调函数，异步回调机制，在接收到数据时自动触发</span></span></span><br><span class="line"><span class="javascript">            success: <span class="function"><span class="keyword">function</span> (<span class="params">args</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">                &#123;#alert(args)  <span class="comment">// 即使返回页面也全都由ajax来接收#&#125;</span></span></span><br><span class="line"><span class="javascript">                $(<span class="string">&quot;#i3&quot;</span>).val(args.i3)  <span class="comment">// 通过DOM操作动态渲染到第三个input里面</span></span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">ab_ajax</span>(<span class="params">request</span>):</span></span><br><span class="line">    <span class="keyword">if</span> request.method == <span class="string">&#x27;POST&#x27;</span>:</span><br><span class="line">        print(request.POST)</span><br><span class="line">        i1 = <span class="built_in">int</span>(request.POST.get(<span class="string">&#x27;i1&#x27;</span>))</span><br><span class="line">        i2 = <span class="built_in">int</span>(request.POST.get(<span class="string">&#x27;i2&#x27;</span>))</span><br><span class="line">        <span class="keyword">return</span> JsonResponse(&#123;<span class="string">&quot;i3&quot;</span>: i1 + i2&#125;)  <span class="comment"># 无法用 HttpResponse + json.dumps 代替</span></span><br><span class="line">    <span class="keyword">return</span> render(request, <span class="string">&#x27;index.html&#x27;</span>)</span><br></pre></td></tr></table></figure><ul><li>针对后端如果是用HttpResponse返回的数据，回调函数不会自动反序列化<ul><li>解决方式1：在前端JSON.parse()</li><li>解决方式2：在ajax里面配置一个参数</li></ul></li><li>如果后端直接用的是JsonResponse返回的数据，回调函数会自动反序列化</li></ul><h3 id="编码格式-Content-Type"><a href="#编码格式-Content-Type" class="headerlink" title="编码格式(Content-Type)"></a>编码格式(Content-Type)</h3><p>前后端传输数据的编码格式：</p><ol><li>urlencoded（例如：username=jason&amp;password=123）</li><li>formdata</li><li>json</li><li>……</li></ol><p>在form表单中：</p><ul><li>默认的数据编码格式是urlencoded，推荐都写成formdata。</li><li>django针对符合urlencoded编码格式的数据都解析封装到request.POST中。</li><li>编码格式设定为formdata时，普通的键值对还是解析到request.POST中，文件将解析到request.FILES中（文件在urlencoded格式下只会解析文件名）。</li><li>form表单是没有办法发送json格式数据的。</li></ul><p>Ajax：</p><ul><li>默认的编码格式也是urlencoded</li><li>对符合urlencoded编码格式的数据都解析封装到request.POST中</li></ul><h3 id="Ajax发送json"><a href="#Ajax发送json" class="headerlink" title="Ajax发送json"></a>Ajax发送json</h3><p>前后端传输数据的时候一定要确保编码格式跟数据真正的格式是一致的。</p><p>ajax传输json格式数据注意点：</p><ol><li>contentType参数指定成:application/json</li><li>数据是原始的json格式数据</li><li>django后端不会封装处理json格式数据，需要自己在request.body获取二进制数据并处理</li></ol><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    $(<span class="string">&#x27;#d1&#x27;</span>).click(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        $.ajax(&#123;</span></span><br><span class="line"><span class="javascript">            url: <span class="string">&quot;&quot;</span>,</span></span><br><span class="line"><span class="javascript">            type: <span class="string">&#x27;post&#x27;</span>,</span></span><br><span class="line"><span class="javascript">            data: <span class="built_in">JSON</span>.stringify(&#123;</span></span><br><span class="line"><span class="javascript">                <span class="string">&#x27;username&#x27;</span>: <span class="string">&#x27;jason&#x27;</span>,</span></span><br><span class="line"><span class="javascript">                <span class="string">&#x27;age&#x27;</span>: <span class="number">25</span></span></span><br><span class="line">            &#125;),</span><br><span class="line"><span class="javascript">            contentType: <span class="string">&#x27;application/json&#x27;</span>,</span></span><br><span class="line"><span class="javascript">            success: <span class="function"><span class="keyword">function</span> (<span class="params">args</span>) </span>&#123;&#125;</span></span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>request.is_ajax()：判断当前请求是否是ajax请求，返回布尔值</li><li>request.body：获取请求体，这里是未经处理的二进制数据</li><li>处理json文件：json.loads(request.body)</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">ab_ajax</span>(<span class="params">request</span>):</span></span><br><span class="line">    <span class="keyword">if</span> request.method == <span class="string">&#x27;POST&#x27;</span>:</span><br><span class="line">        print(request.is_ajax())  <span class="comment"># 判断当前请求是否是ajax请求</span></span><br><span class="line">        print(request.body)  <span class="comment"># 获取请求体</span></span><br><span class="line">        json_bytes = request.body</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 1. 手动处理二进制流</span></span><br><span class="line">        json_str = json_bytes.decode(<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">        json_dict = json.loads(json_str)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 2. json.loads如果传入二进制数据则自动解码再反序列化</span></span><br><span class="line">        json_dict = json.loads(json_bytes)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> JsonResponse(json_dict)</span><br><span class="line">    <span class="keyword">return</span> render(request, <span class="string">&#x27;index.html&#x27;</span>)</span><br></pre></td></tr></table></figure><h3 id="Ajax发送文件"><a href="#Ajax发送文件" class="headerlink" title="Ajax发送文件"></a>Ajax发送文件</h3><ol><li>ajax发送文件需要借助于js内置对象FormData</li><li>需要指定两个关键性的参数 contentType:false  processData:false</li><li>django能直接识别formdata对象，并将内部的普通键值对自动解析封装到request.POST中，文件数据自动解析封装到request.FILES中</li></ol><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="comment">// 点击按钮朝后端发送普通键值对和文件数据</span></span></span><br><span class="line"><span class="javascript">    $(<span class="string">&#x27;#d4&#x27;</span>).on(<span class="string">&#x27;click&#x27;</span>,<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="comment">// 1. 需要先利用FormData内置对象</span></span></span><br><span class="line"><span class="javascript">        <span class="keyword">let</span> formDateObj = <span class="keyword">new</span> FormData();</span></span><br><span class="line"><span class="javascript">        <span class="comment">// 2. 添加普通的键值对</span></span></span><br><span class="line"><span class="javascript">        formDateObj.append(<span class="string">&#x27;username&#x27;</span>,$(<span class="string">&#x27;#d1&#x27;</span>).val());</span></span><br><span class="line"><span class="javascript">        formDateObj.append(<span class="string">&#x27;password&#x27;</span>,$(<span class="string">&#x27;#d2&#x27;</span>).val());</span></span><br><span class="line"><span class="javascript">        <span class="comment">// 3. 添加文件对象</span></span></span><br><span class="line"><span class="javascript">        formDateObj.append(<span class="string">&#x27;myfile&#x27;</span>,$(<span class="string">&#x27;#d3&#x27;</span>)[<span class="number">0</span>].files[<span class="number">0</span>])</span></span><br><span class="line"><span class="javascript">        <span class="comment">// 4. 将对象基于ajax发送给后端</span></span></span><br><span class="line"><span class="javascript">        $.ajax(&#123;</span></span><br><span class="line"><span class="javascript">            url:<span class="string">&#x27;&#x27;</span>,</span></span><br><span class="line"><span class="javascript">            type:<span class="string">&#x27;post&#x27;</span>,</span></span><br><span class="line"><span class="javascript">            data:formDateObj,  <span class="comment">// 直接将对象放在data后面即可</span></span></span><br><span class="line"><span class="javascript">            <span class="comment">// ajax发送文件必须要指定的两个参数</span></span></span><br><span class="line"><span class="javascript">            contentType:<span class="literal">false</span>,  <span class="comment">// 不需使用任何编码 django后端能够自动识别formdata对象</span></span></span><br><span class="line"><span class="javascript">            processData:<span class="literal">false</span>,  <span class="comment">// 告诉你的浏览器不要对你的数据进行任何处理</span></span></span><br><span class="line"><span class="javascript">            success:<span class="function"><span class="keyword">function</span> (<span class="params">args</span>) </span>&#123;&#125;</span></span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">ab_file</span>(<span class="params">request</span>):</span></span><br><span class="line">    <span class="keyword">if</span> request.is_ajax():</span><br><span class="line">        <span class="keyword">if</span> request.method == <span class="string">&#x27;POST&#x27;</span>:</span><br><span class="line">            print(request.POST)</span><br><span class="line">            print(request.FILES)</span><br><span class="line">    <span class="keyword">return</span> render(request,<span class="string">&#x27;ab_file.html&#x27;</span>)</span><br></pre></td></tr></table></figure><h3 id="Django自带的序列化组件"><a href="#Django自带的序列化组件" class="headerlink" title="Django自带的序列化组件"></a>Django自带的序列化组件</h3><ul><li>使用<code>django.core.serializers.serialize(&#39;指定数据格式&#39;, 数据本体)</code>快速完成序列化</li><li>后续还有更多的序列化组件，例如：drf</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 需求:在前端获取后端用户表里面所有的数据，列表套字典</span></span><br><span class="line"><span class="keyword">from</span> django.http <span class="keyword">import</span> JsonResponse</span><br><span class="line"><span class="keyword">from</span> django.core <span class="keyword">import</span> serializers</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">ab_ser</span>(<span class="params">request</span>):</span></span><br><span class="line">    user_queryset = models.User.objects.<span class="built_in">all</span>()</span><br><span class="line">    <span class="comment"># user_list = []</span></span><br><span class="line">    <span class="comment"># for user_obj in user_queryset:</span></span><br><span class="line">    <span class="comment">#     tmp = &#123;</span></span><br><span class="line">    <span class="comment">#         &#x27;pk&#x27;:user_obj.pk,</span></span><br><span class="line">    <span class="comment">#         &#x27;username&#x27;:user_obj.username,</span></span><br><span class="line">    <span class="comment">#         &#x27;age&#x27;:user_obj.age,</span></span><br><span class="line">    <span class="comment">#         &#x27;gender&#x27;:user_obj.get_gender_display()</span></span><br><span class="line">    <span class="comment">#     &#125;</span></span><br><span class="line">    <span class="comment">#     user_list.append(tmp)</span></span><br><span class="line">    <span class="comment"># return JsonResponse(user_list, safe=False)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 序列化</span></span><br><span class="line">    res = serializers.serialize(<span class="string">&#x27;json&#x27;</span>, user_queryset)</span><br><span class="line">    <span class="keyword">return</span> HttpResponse(res)</span><br></pre></td></tr></table></figure><h3 id="Ajax结合SweetAlert"><a href="#Ajax结合SweetAlert" class="headerlink" title="Ajax结合SweetAlert"></a>Ajax结合SweetAlert</h3><ul><li>每个元素都可以自定义属性，可以用来传值</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    $(<span class="string">&#x27;.del&#x27;</span>).on(<span class="string">&#x27;click&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="comment">// 1. 先将当前标签对象存储起来</span></span></span><br><span class="line"><span class="javascript">        <span class="keyword">let</span> currentBtn = $(<span class="built_in">this</span>);</span></span><br><span class="line"><span class="javascript">        <span class="comment">// 2. 二次确认弹框</span></span></span><br><span class="line">        swal(&#123;</span><br><span class="line"><span class="javascript">            title: <span class="string">&quot;你确定要删吗?&quot;</span>,</span></span><br><span class="line"><span class="javascript">            text: <span class="string">&quot;你可要考虑清除哦，可能需要拎包跑路哦!&quot;</span>,</span></span><br><span class="line"><span class="javascript">            type: <span class="string">&quot;warning&quot;</span>,</span></span><br><span class="line"><span class="javascript">            showCancelButton: <span class="literal">true</span>,</span></span><br><span class="line"><span class="javascript">            confirmButtonClass: <span class="string">&quot;btn-danger&quot;</span>,</span></span><br><span class="line"><span class="javascript">            confirmButtonText: <span class="string">&quot;是的，老子就要删!&quot;</span>,</span></span><br><span class="line"><span class="javascript">            cancelButtonText: <span class="string">&quot;算了,算了!&quot;</span>,</span></span><br><span class="line"><span class="javascript">            closeOnConfirm: <span class="literal">false</span>,</span></span><br><span class="line"><span class="javascript">            closeOnCancel: <span class="literal">false</span>,</span></span><br><span class="line"><span class="javascript">            showLoaderOnConfirm: <span class="literal">true</span></span></span><br><span class="line"><span class="javascript">        &#125;, <span class="function"><span class="keyword">function</span> (<span class="params">isConfirm</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">            <span class="keyword">if</span> (isConfirm) &#123;</span></span><br><span class="line"><span class="javascript">                <span class="comment">// 3. 朝后端发送ajax请求删除数据，之后弹完成情况的提示框</span></span></span><br><span class="line"><span class="javascript">                $.ajax(&#123;</span></span><br><span class="line"><span class="javascript">                    url: <span class="string">&#x27;/delete/user/&#x27;</span>,  <span class="comment">// 传递主键值可以放在url中，也可以放在请求体里面</span></span></span><br><span class="line"><span class="javascript">                    type: <span class="string">&#x27;post&#x27;</span>,</span></span><br><span class="line"><span class="javascript">                    data: &#123;<span class="string">&#x27;delete_id&#x27;</span>: currentBtn.attr(<span class="string">&#x27;delete_id&#x27;</span>)&#125;,</span></span><br><span class="line"><span class="javascript">                    success: <span class="function"><span class="keyword">function</span> (<span class="params">args</span>) </span>&#123;  <span class="comment">// args = &#123;&#x27;code&#x27;: &#x27;&#x27;, &#x27;msg&#x27;: &#x27;&#x27;&#125;</span></span></span><br><span class="line"><span class="javascript">                        <span class="comment">// 4. 判断响应状态码，然后做不同的处理</span></span></span><br><span class="line"><span class="javascript">                        <span class="keyword">if</span> (args.code === <span class="number">1000</span>) &#123;</span></span><br><span class="line"><span class="javascript">                            swal(<span class="string">&quot;删了!&quot;</span>, args.msg, <span class="string">&quot;success&quot;</span>);</span></span><br><span class="line"><span class="javascript">                            <span class="comment">// (1) lowb版本 直接刷新当前页面</span></span></span><br><span class="line">                            &#123;#window.location.reload()#&#125;</span><br><span class="line"><span class="javascript">                            <span class="comment">// (2) 利用DOM操作 动态刷新</span></span></span><br><span class="line">                            currentBtn.parent().parent().remove()</span><br><span class="line"><span class="javascript">                        &#125; <span class="keyword">else</span> &#123;</span></span><br><span class="line"><span class="javascript">                            swal(<span class="string">&#x27;完了&#x27;</span>, <span class="string">&#x27;出现了位置的错误&#x27;</span>, <span class="string">&#x27;info&#x27;</span>)</span></span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;)</span><br><span class="line"><span class="javascript">            &#125; <span class="keyword">else</span> &#123;</span></span><br><span class="line"><span class="javascript">                swal(<span class="string">&quot;怂逼&quot;</span>, <span class="string">&quot;不要说我认识你&quot;</span>, <span class="string">&quot;error&quot;</span>);</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="forms组件"><a href="#forms组件" class="headerlink" title="forms组件"></a>forms组件</h2><p>forms组件能够完成的事情：</p><ol><li>渲染html代码</li><li>校验数据</li><li>展示提示信息</li></ol><p>数据校验前端可有可无，但是后端必须要有！</p><p>因为前端的校验是弱不禁风的，可以直接修改，或者利用爬虫绕过前端页面直接朝后端提交数据。</p><h3 id="定义forms组件"><a href="#定义forms组件" class="headerlink" title="定义forms组件"></a>定义forms组件</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django <span class="keyword">import</span> forms</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyForm</span>(<span class="params">forms.Form</span>):</span></span><br><span class="line">    <span class="comment"># username字符串类型最小3位最大8位</span></span><br><span class="line">    username = forms.CharField(min_length=<span class="number">3</span>, max_length=<span class="number">8</span>, label=<span class="string">&#x27;用户名&#x27;</span>)</span><br><span class="line">    <span class="comment"># password字符串类型最小3位最大8位</span></span><br><span class="line">    password = forms.CharField(min_length=<span class="number">3</span>, max_length=<span class="number">8</span>)</span><br><span class="line">    <span class="comment"># email字段必须符合邮箱格式  xxx@xx.com</span></span><br><span class="line">    email = forms.EmailField()</span><br></pre></td></tr></table></figure><h3 id="校验数据"><a href="#校验数据" class="headerlink" title="校验数据"></a>校验数据</h3><ul><li>可以直接在 python console 中测试</li><li>默认情况下数据可以多传但是绝不可能少传</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> app01 <span class="keyword">import</span> views</span><br><span class="line"><span class="comment"># 1 将带校验的数据组织成字典的形式传入即可</span></span><br><span class="line">form_obj = views.MyForm(&#123;<span class="string">&#x27;username&#x27;</span>:<span class="string">&#x27;jason&#x27;</span>,<span class="string">&#x27;password&#x27;</span>:<span class="string">&#x27;123&#x27;</span>,<span class="string">&#x27;email&#x27;</span>:<span class="string">&#x27;123&#x27;</span>&#125;)</span><br><span class="line"><span class="comment"># 2 判断数据是否合法：注意该方法只有在所有的数据全部合法的情况下才会返回True</span></span><br><span class="line">form_obj.is_valid()  <span class="comment"># False</span></span><br><span class="line"><span class="comment"># 3 查看所有校验通过的数据</span></span><br><span class="line">form_obj.cleaned_data <span class="comment"># &#123;&#x27;username&#x27;: &#x27;jason&#x27;, &#x27;password&#x27;: &#x27;123&#x27;&#125;</span></span><br><span class="line"><span class="comment"># 4 查看所有不符合校验规则以及不符合的原因</span></span><br><span class="line">form_obj.errors  <span class="comment"># &#123;&#x27;email&#x27;: [&#x27;Enter a valid email address.&#x27;]&#125;</span></span><br><span class="line"><span class="comment"># 5 只校验类中出现的字段，多传的字段直接忽略</span></span><br><span class="line">form_obj = views.MyForm(&#123;<span class="string">&#x27;username&#x27;</span>:<span class="string">&#x27;jason&#x27;</span>,<span class="string">&#x27;password&#x27;</span>:<span class="string">&#x27;123&#x27;</span>,<span class="string">&#x27;email&#x27;</span>:<span class="string">&#x27;123@qq.com&#x27;</span>,<span class="string">&#x27;hobby&#x27;</span>:<span class="string">&#x27;study&#x27;</span>&#125;)</span><br><span class="line">form_obj.is_valid()  <span class="comment"># True</span></span><br><span class="line"><span class="comment"># 6 默认情况下，类里面所有的字段都必须传值</span></span><br><span class="line">form_obj = views.MyForm(&#123;<span class="string">&#x27;username&#x27;</span>:<span class="string">&#x27;jason&#x27;</span>,<span class="string">&#x27;password&#x27;</span>:<span class="string">&#x27;123&#x27;</span>&#125;)</span><br><span class="line">form_obj.is_valid()  <span class="comment"># False</span></span><br></pre></td></tr></table></figure><h3 id="渲染标签"><a href="#渲染标签" class="headerlink" title="渲染标签"></a>渲染标签</h3><ul><li>forms组件只会自动渲染获取用户输入的标签(input select radio checkbox)，不能渲染提交按钮</li><li>设置form表单让浏览器不做校验<code>&lt;form action=&quot;&quot; method=&quot;post&quot; novalidate&gt;</code></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span>(<span class="params">request</span>):</span></span><br><span class="line">    <span class="comment"># 1. 先生成一个空对象</span></span><br><span class="line">    form_obj = MyForm()</span><br><span class="line">    <span class="keyword">if</span> request.method == <span class="string">&#x27;POST&#x27;</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        1. 多个字段的数据获取繁琐</span></span><br><span class="line"><span class="string">        2. 校验数据需要构造成字典的格式传入</span></span><br><span class="line"><span class="string">        3. request.POST就是一个字典</span></span><br><span class="line"><span class="string">        4. 对于提供多余的字段不在意</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="comment"># 3. 校验数据</span></span><br><span class="line">        form_obj = MyForm(request.POST)</span><br><span class="line">        <span class="comment"># 4. 判断数据是否合法</span></span><br><span class="line">        <span class="keyword">if</span> form_obj.is_valid():</span><br><span class="line">            <span class="comment"># 5. 合法，操作数据库存储数据</span></span><br><span class="line">            <span class="keyword">return</span> HttpResponse(<span class="string">&#x27;OK&#x27;</span>)</span><br><span class="line">        <span class="comment"># 5. 不合法，有错误。此时可以基于上一次结果进行修改</span></span><br><span class="line">    <span class="comment"># 2. 直接将该空对象传递给html页面</span></span><br><span class="line">    <span class="keyword">return</span> render(request, <span class="string">&#x27;index.html&#x27;</span>, <span class="built_in">locals</span>())</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>第一种渲染方式:代码书写极少，封装程度太高，不便于后续的扩展，一般情况下只在本地测试使用<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  &#123;&#123; form_obj.as_p &#125;&#125;</span><br><span class="line">  &#123;&#123; form_obj.as_ul &#125;&#125;</span><br><span class="line">  &#123;&#123; form_obj.as_table &#125;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>第二种渲染方式:可扩展性很强 但是需要书写的代码太多，一般情况下不用<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123; form_obj.username.label &#125;&#125;:&#123;&#123; form_obj.username &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123; form_obj.password.label &#125;&#125;:&#123;&#123; form_obj.password &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123; form_obj.email.label &#125;&#125;:&#123;&#123; form_obj.email &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>第三种渲染方式(推荐使用):代码书写简单 并且扩展性也高<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  &#123;% for form in form_obj %&#125;</span><br><span class="line">      <span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">          &#123;&#123; form.label &#125;&#125;:&#123;&#123; form &#125;&#125;</span><br><span class="line">          <span class="tag">&lt;<span class="name">span</span> <span class="attr">style</span>=<span class="string">&quot;color: red&quot;</span>&gt;</span>&#123;&#123; form.errors.0 &#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  &#123;% endfor %&#125;</span><br></pre></td></tr></table></figure><h3 id="自定义错误信息"><a href="#自定义错误信息" class="headerlink" title="自定义错误信息"></a>自定义错误信息</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyForm</span>(<span class="params">forms.Form</span>):</span></span><br><span class="line">    <span class="comment"># username字符串类型最小3位最大8位</span></span><br><span class="line">    username = forms.CharField(min_length=<span class="number">3</span>, max_length=<span class="number">8</span>, label=<span class="string">&#x27;用户名&#x27;</span>,</span><br><span class="line">                               error_messages=&#123;</span><br><span class="line">                                   <span class="string">&#x27;min_length&#x27;</span>: <span class="string">&#x27;用户名最少3位&#x27;</span>,</span><br><span class="line">                                   <span class="string">&#x27;max_length&#x27;</span>: <span class="string">&#x27;用户名最大8位&#x27;</span>,</span><br><span class="line">                                   <span class="string">&#x27;required&#x27;</span>: <span class="string">&quot;用户名不能为空&quot;</span></span><br><span class="line">                               &#125;)</span><br><span class="line">    <span class="comment"># password字符串类型最小3位最大8位</span></span><br><span class="line">    password = forms.CharField(min_length=<span class="number">3</span>, max_length=<span class="number">8</span>, label=<span class="string">&#x27;密码&#x27;</span>,</span><br><span class="line">                               error_messages=&#123;</span><br><span class="line">                                   <span class="string">&#x27;min_length&#x27;</span>: <span class="string">&#x27;密码最少3位&#x27;</span>,</span><br><span class="line">                                   <span class="string">&#x27;max_length&#x27;</span>: <span class="string">&#x27;密码最大8位&#x27;</span>,</span><br><span class="line">                                   <span class="string">&#x27;required&#x27;</span>: <span class="string">&quot;密码不能为空&quot;</span></span><br><span class="line">                               &#125;)</span><br><span class="line">    <span class="comment"># email字段必须符合邮箱格式  xxx@xx.com</span></span><br><span class="line">    email = forms.EmailField(label=<span class="string">&#x27;邮箱&#x27;</span>,</span><br><span class="line">                             error_messages=&#123;</span><br><span class="line">                                 <span class="string">&#x27;invalid&#x27;</span>: <span class="string">&#x27;邮箱格式不正确&#x27;</span>,</span><br><span class="line">                                 <span class="string">&#x27;required&#x27;</span>: <span class="string">&quot;邮箱不能为空&quot;</span></span><br><span class="line">                             &#125;)</span><br></pre></td></tr></table></figure><h3 id="钩子函数-HOOK"><a href="#钩子函数-HOOK" class="headerlink" title="钩子函数(HOOK)"></a>钩子函数(HOOK)</h3><ul><li>钩子函数将书写在Form类中，能够让我们自定义校验规则</li><li>在forms组件中有两类钩子<ol><li>局部钩子：给单个字段增加校验规则</li><li>全局钩子：给多个字段增加校验规则</li></ol></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyForm</span>(<span class="params">forms.Form</span>):</span></span><br><span class="line">    ......</span><br><span class="line">    <span class="comment"># 局部钩子</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">clean_username</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="comment"># 获取用户名</span></span><br><span class="line">        username = self.cleaned_data.get(<span class="string">&#x27;username&#x27;</span>)</span><br><span class="line">        <span class="keyword">if</span> <span class="string">&#x27;666&#x27;</span> <span class="keyword">in</span> username:</span><br><span class="line">            <span class="comment"># 1. 校验用户名中不能含有666，添加错误信息</span></span><br><span class="line">            self.add_error(<span class="string">&#x27;username&#x27;</span>, <span class="string">&#x27;光喊666是不行滴～&#x27;</span>)</span><br><span class="line">        <span class="comment"># 将钩子函数钩去出来得特定数据放回去</span></span><br><span class="line">        <span class="keyword">return</span> username</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 全局钩子</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">clean</span>(<span class="params">self</span>):</span></span><br><span class="line">        password = self.cleaned_data.get(<span class="string">&#x27;password&#x27;</span>)</span><br><span class="line">        confirm_password = self.cleaned_data.get(<span class="string">&#x27;confirm_password&#x27;</span>)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> confirm_password == password:</span><br><span class="line">            <span class="comment"># 2. 校验密码和确认密码是否一致</span></span><br><span class="line">            self.add_error(<span class="string">&#x27;confirm_password&#x27;</span>, <span class="string">&#x27;两次密码不一致&#x27;</span>)</span><br><span class="line">        <span class="comment"># 将钩子函数钩出来的所有数据放回去</span></span><br><span class="line">        <span class="keyword">return</span> self.cleaned_data</span><br></pre></td></tr></table></figure><h3 id="forms字段其他参数与样式渲染"><a href="#forms字段其他参数与样式渲染" class="headerlink" title="forms字段其他参数与样式渲染"></a>forms字段其他参数与样式渲染</h3><ul><li>label：字段名</li><li>error_messages：自定义报错信息</li><li>initial：默认值</li><li>required：控制字段是否必填</li><li>widget：type类型<ul><li>attrs：以字典类型定义属性</li></ul></li><li>validators：可以使用<code>RegexValidator</code>添加正则表达式校验</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyForm</span>(<span class="params">forms.Form</span>):</span></span><br><span class="line">    username = forms.CharField(min_length=<span class="number">3</span>, max_length=<span class="number">8</span>, label=<span class="string">&#x27;用户名&#x27;</span>, initial=<span class="string">&#x27;jason&#x27;</span>, required=<span class="literal">False</span>,</span><br><span class="line">                               widget=forms.widgets.TextInput(attrs=&#123;<span class="string">&#x27;class&#x27;</span>: <span class="string">&#x27;form-control&#x27;</span>&#125;),</span><br><span class="line">                               error_messages=&#123;</span><br><span class="line">                                   <span class="string">&#x27;min_length&#x27;</span>: <span class="string">&#x27;用户名最少3位&#x27;</span>,</span><br><span class="line">                                   <span class="string">&#x27;max_length&#x27;</span>: <span class="string">&#x27;用户名最大8位&#x27;</span>,</span><br><span class="line">                                   <span class="string">&#x27;required&#x27;</span>: <span class="string">&quot;用户名不能为空&quot;</span></span><br><span class="line">                               &#125;)</span><br><span class="line">    password = forms.CharField(min_length=<span class="number">3</span>, max_length=<span class="number">8</span>, label=<span class="string">&#x27;密码&#x27;</span>,</span><br><span class="line">                               widget=forms.widgets.PasswordInput(attrs=&#123;<span class="string">&#x27;class&#x27;</span>: <span class="string">&#x27;form-control c1 c2&#x27;</span>&#125;),</span><br><span class="line">                               error_messages=&#123;</span><br><span class="line">                                   <span class="string">&#x27;min_length&#x27;</span>: <span class="string">&#x27;密码最少3位&#x27;</span>,</span><br><span class="line">                                   <span class="string">&#x27;max_length&#x27;</span>: <span class="string">&#x27;密码最大8位&#x27;</span>,</span><br><span class="line">                                   <span class="string">&#x27;required&#x27;</span>: <span class="string">&quot;密码不能为空&quot;</span></span><br><span class="line">                               &#125;)</span><br><span class="line">    confirm_password = forms.CharField(min_length=<span class="number">3</span>, max_length=<span class="number">8</span>, label=<span class="string">&#x27;确认密码&#x27;</span>,</span><br><span class="line">                                       widget=forms.widgets.PasswordInput(attrs=&#123;<span class="string">&#x27;class&#x27;</span>: <span class="string">&#x27;form-control&#x27;</span>&#125;),</span><br><span class="line">                                       error_messages=&#123;</span><br><span class="line">                                           <span class="string">&#x27;min_length&#x27;</span>: <span class="string">&#x27;确认密码最少3位&#x27;</span>,</span><br><span class="line">                                           <span class="string">&#x27;max_length&#x27;</span>: <span class="string">&#x27;确认密码最大8位&#x27;</span>,</span><br><span class="line">                                           <span class="string">&#x27;required&#x27;</span>: <span class="string">&quot;确认密码不能为空&quot;</span></span><br><span class="line">                                       &#125;)</span><br><span class="line">    email = forms.EmailField(label=<span class="string">&#x27;邮箱&#x27;</span>, widget=forms.widgets.EmailInput(attrs=&#123;<span class="string">&#x27;class&#x27;</span>: <span class="string">&#x27;form-control&#x27;</span>&#125;),</span><br><span class="line">                             error_messages=&#123;</span><br><span class="line">                                 <span class="string">&#x27;invalid&#x27;</span>: <span class="string">&#x27;邮箱格式不正确&#x27;</span>,</span><br><span class="line">                                 <span class="string">&#x27;required&#x27;</span>: <span class="string">&quot;邮箱不能为空&quot;</span></span><br><span class="line">                             &#125;)</span><br><span class="line">    phone = forms.CharField(validators=[</span><br><span class="line">        RegexValidator(<span class="string">r&#x27;^[0-9]+$&#x27;</span>, <span class="string">&#x27;请输入数字&#x27;</span>),</span><br><span class="line">        RegexValidator(<span class="string">r&#x27;^159[0-9]+$&#x27;</span>, <span class="string">&#x27;数字必须以159开头&#x27;</span>)</span><br><span class="line">    ])</span><br><span class="line"></span><br><span class="line">    <span class="comment"># radio</span></span><br><span class="line">    gender = forms.ChoiceField(</span><br><span class="line">        choices=((<span class="number">1</span>, <span class="string">&quot;男&quot;</span>), (<span class="number">2</span>, <span class="string">&quot;女&quot;</span>), (<span class="number">3</span>, <span class="string">&quot;保密&quot;</span>)),</span><br><span class="line">        label=<span class="string">&quot;性别&quot;</span>,</span><br><span class="line">        initial=<span class="number">3</span>,</span><br><span class="line">        widget=forms.widgets.RadioSelect()</span><br><span class="line">    )</span><br><span class="line">    <span class="comment"># 单选select</span></span><br><span class="line">    hobby = forms.ChoiceField(</span><br><span class="line">        choices=((<span class="number">1</span>, <span class="string">&quot;篮球&quot;</span>), (<span class="number">2</span>, <span class="string">&quot;足球&quot;</span>), (<span class="number">3</span>, <span class="string">&quot;双色球&quot;</span>),),</span><br><span class="line">        label=<span class="string">&quot;爱好&quot;</span>,</span><br><span class="line">        initial=<span class="number">3</span>,</span><br><span class="line">        widget=forms.widgets.Select()</span><br><span class="line">    )</span><br><span class="line">    <span class="comment"># 多选select</span></span><br><span class="line">    hobby1 = forms.MultipleChoiceField(</span><br><span class="line">        choices=((<span class="number">1</span>, <span class="string">&quot;篮球&quot;</span>), (<span class="number">2</span>, <span class="string">&quot;足球&quot;</span>), (<span class="number">3</span>, <span class="string">&quot;双色球&quot;</span>),),</span><br><span class="line">        label=<span class="string">&quot;爱好&quot;</span>,</span><br><span class="line">        initial=[<span class="number">1</span>, <span class="number">3</span>],</span><br><span class="line">        widget=forms.widgets.SelectMultiple()</span><br><span class="line">    )</span><br><span class="line">    <span class="comment"># 单选checkbox</span></span><br><span class="line">    keep = forms.ChoiceField(</span><br><span class="line">        label=<span class="string">&quot;是否记住密码&quot;</span>,</span><br><span class="line">        initial=<span class="string">&quot;checked&quot;</span>,</span><br><span class="line">        widget=forms.widgets.CheckboxInput()</span><br><span class="line">    )</span><br><span class="line">    <span class="comment"># 多选checkbox</span></span><br><span class="line">    hobby2 = forms.MultipleChoiceField(</span><br><span class="line">        choices=((<span class="number">1</span>, <span class="string">&quot;篮球&quot;</span>), (<span class="number">2</span>, <span class="string">&quot;足球&quot;</span>), (<span class="number">3</span>, <span class="string">&quot;双色球&quot;</span>),),</span><br><span class="line">        label=<span class="string">&quot;爱好&quot;</span>,</span><br><span class="line">        initial=[<span class="number">1</span>, <span class="number">3</span>],</span><br><span class="line">        widget=forms.widgets.CheckboxSelectMultiple()</span><br><span class="line">    )</span><br></pre></td></tr></table></figure><h3 id="choice字段实时更新"><a href="#choice字段实时更新" class="headerlink" title="choice字段实时更新"></a>choice字段实时更新</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.forms <span class="keyword">import</span> Form</span><br><span class="line"><span class="keyword">from</span> django.forms <span class="keyword">import</span> widgets</span><br><span class="line"><span class="keyword">from</span> django.forms <span class="keyword">import</span> fields</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyForm</span>(<span class="params">Form</span>):</span></span><br><span class="line">    <span class="comment"># 方式一</span></span><br><span class="line">    user = fields.ChoiceField(</span><br><span class="line">        <span class="comment"># choices=((1, &#x27;上海&#x27;), (2, &#x27;北京&#x27;),),</span></span><br><span class="line">        initial=<span class="number">2</span>,</span><br><span class="line">        widget=widgets.Select</span><br><span class="line">    )</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, *args, **kwargs</span>):</span></span><br><span class="line">        <span class="built_in">super</span>(MyForm,self).__init__(*args, **kwargs)</span><br><span class="line">        <span class="comment"># self.fields[&#x27;user&#x27;].choices = ((1, &#x27;上海&#x27;), (2, &#x27;北京&#x27;),)</span></span><br><span class="line">        <span class="comment"># 或</span></span><br><span class="line">        self.fields[<span class="string">&#x27;user&#x27;</span>].choices = models.Classes.objects.<span class="built_in">all</span>().values_list(<span class="string">&#x27;id&#x27;</span>, <span class="string">&#x27;caption&#x27;</span>)</span><br><span class="line">        </span><br><span class="line">    <span class="comment"># 方式二</span></span><br><span class="line">    authors = form_model.ModelMultipleChoiceField(queryset=models.NNewType.objects.<span class="built_in">all</span>())  <span class="comment"># 多选</span></span><br><span class="line">    <span class="comment"># authors = form_model.ModelChoiceField(queryset=models.NNewType.objects.all())  # 单选</span></span><br></pre></td></tr></table></figure><h2 id="Cookie与Session"><a href="#Cookie与Session" class="headerlink" title="Cookie与Session"></a>Cookie与Session</h2><p>目标：</p><ul><li>为了保持用户登陆状态。</li></ul><p>Cookie：</p><ul><li>登陆之后，将用户的信息返回给用户浏览器，保存在本地，之后访问网站的时候携带保存在浏览器上的用户信息发送给服务端，自动验证。</li><li>服务端保存在客户端浏览器上的信息都可以称之为cookie。</li><li>它的表现形式一般都是k:v键值对(可以有多个)。</li></ul><p>Session：</p><ul><li>登陆之后，服务端保存kv键值对形式的数据。k为随机字符串，交由客户端浏览器保存，v为用户信息。</li><li>数据保存在服务端，并且表现形式一般也是k:v键值对。</li><li>Session是基于Cookie工作的(包括其他保存用户操作的状态都需要使用到cookie)。</li></ul><p>Token：</p><ul><li>为了减轻Session给服务端带来的压力：随着连接数增多，服务端保存的数据量越大。</li><li>登陆之后，将用户信息进行公司内独有的加密处理，并将多段数据拼接(jwt认证)，整体返回给浏览器保存。</li><li>浏览器之后访问的时候带着密文，服务端自动解密并比对。</li></ul><h3 id="Cookie操作"><a href="#Cookie操作" class="headerlink" title="Cookie操作"></a>Cookie操作</h3><ul><li>虽然cookie是服务端要求客户端需要保存内容，但是客户端可以选择拒绝保存，如果禁止，那么只要是需要记录用户状态的网站功能都无法使用了。</li><li>如果想要操作cookie，就不得不使用HttpResponse对象。</li></ul><p>Cookie方法：</p><ol><li><code>HttpResponseObject.set_cookie(key,value)</code>：设置cookie</li><li><code>request.COOKIES.get(key)</code>：获取cookie</li><li><code>HttpResponseObject.set_cookie(key, value, max_age, expires)</code>：在设置cookie的时候可以添加一个超时时间<ul><li>max_age、expires 都是设置超时时间的，并且都是以秒为单位，针对IE浏览器需要使用expires。</li></ul></li><li><code>HttpResponseObject.delete_cookie(key)</code>：清除Cookie</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 校验用户是否登陆的装饰器</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">login_auth</span>(<span class="params">func</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inner</span>(<span class="params">request, *args, **kwargs</span>):</span></span><br><span class="line">        target_url = request.get_full_path()  <span class="comment"># 能够获取到用户上一次想要访问的url</span></span><br><span class="line">        <span class="keyword">if</span> request.COOKIES.get(<span class="string">&#x27;username&#x27;</span>):</span><br><span class="line">            <span class="keyword">return</span> func(request, *args, **kwargs)</span><br><span class="line">        <span class="keyword">return</span> redirect(<span class="string">&#x27;/login/?next=%s&#x27;</span> % target_url)</span><br><span class="line">    <span class="keyword">return</span> inner</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">login</span>(<span class="params">request</span>):</span></span><br><span class="line">    <span class="keyword">if</span> request.method == <span class="string">&#x27;POST&#x27;</span>:</span><br><span class="line">        username = request.POST.get(<span class="string">&#x27;username&#x27;</span>)</span><br><span class="line">        password = request.POST.get(<span class="string">&#x27;password&#x27;</span>)</span><br><span class="line">        <span class="keyword">if</span> username == <span class="string">&#x27;jason&#x27;</span> <span class="keyword">and</span> password == <span class="string">&#x27;123&#x27;</span>:</span><br><span class="line">            <span class="comment"># 获取用户上一次想要访问的url</span></span><br><span class="line">            target_url = request.GET.get(<span class="string">&#x27;next&#x27;</span>)  <span class="comment"># 这个结果可能是None</span></span><br><span class="line">            <span class="keyword">if</span> target_url:</span><br><span class="line">                obj = redirect(target_url)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                obj = redirect(<span class="string">&#x27;/home/&#x27;</span>)</span><br><span class="line">            <span class="comment"># 让浏览器记录cookie数据，保存用户登陆状态，超时时间3秒到期</span></span><br><span class="line">            obj.set_cookie(<span class="string">&#x27;username&#x27;</span>, <span class="string">&#x27;jason666&#x27;</span>, max_age=<span class="number">3</span>)</span><br><span class="line">            <span class="comment"># 跳转到一个需要用户登陆之后才能看的页面</span></span><br><span class="line">            <span class="keyword">return</span> obj</span><br><span class="line">    <span class="keyword">return</span> render(request, <span class="string">&#x27;login.html&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@login_auth</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">home</span>(<span class="params">request</span>):</span></span><br><span class="line">    <span class="keyword">return</span> HttpResponse(<span class="string">&quot;我是home页面，只有登陆的用户才能进来哟~&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@login_auth</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">logout</span>(<span class="params">request</span>):</span></span><br><span class="line">    obj = redirect(<span class="string">&#x27;/login/&#x27;</span>)</span><br><span class="line">    obj.delete_cookie(<span class="string">&#x27;username&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> obj</span><br></pre></td></tr></table></figure><blockquote><p>对装饰器的详细解释：<a href="https://www.runoob.com/w3cnote/python-func-decorators.html">https://www.runoob.com/w3cnote/python-func-decorators.html</a></p></blockquote><h3 id="Session操作"><a href="#Session操作" class="headerlink" title="Session操作"></a>Session操作</h3><ul><li><p>Session数据是保存在服务端的，给客户端返回的是一个key为sessionid、value为随机字符串的键值对。</p></li><li><p>在使用Session之前要使用数据库迁移命令，因为Session的数据是存储在django_session表中的。</p></li><li><p>Django默认session的过期时间是14天。</p></li><li><p>django_session表中的数据条数是取决于 user-agent ，同一个浏览器在期限内只会有一条数据被写入在表中。</p><p>当session过期时，可能会出现多条数据对应一个IP地址，但是该现象不会持续很久，内部会自动清除过期的数据，也可以通过代码手动清除。</p></li><li><p>session保存位置可以有多种选择：1. MySQL  2. 文件  3. redis  4. memcache</p></li></ul><p>Session方法：</p><ol><li><code>request.session[&#39;key&#39;] = value</code>：设置session</li><li><code>request.session.get(&#39;key&#39;)</code>：获取session</li><li><code>request.session.set_expiry()</code>：设置过期时间<ul><li>非零正数：持续的秒数</li><li>datetime或timedelta日期对象：指定日期失效</li><li>0：一旦浏览器窗口关闭则失效</li><li>None：session会依赖全局session失效策略</li></ul></li><li><code>request.session.delete()</code>：清除session，只删服务端的，客户端的不删</li><li><code>request.session.flush()</code>：清除session，浏览器和服务端都清空(推荐使用)</li><li><code>request.session.session_key</code>：会话session的key</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">set_session</span>(<span class="params">request</span>):</span></span><br><span class="line">    request.session[<span class="string">&#x27;hobby&#x27;</span>] = <span class="string">&#x27;girl&#x27;</span></span><br><span class="line">    request.session.set_expiry(<span class="number">5</span>)</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    1. django内部自动生成一个随机字符串</span></span><br><span class="line"><span class="string">    2. django内部自动将随机字符串和对应的数据存储到django_session表中</span></span><br><span class="line"><span class="string">        2.1 先在内存中产生操作数据的缓存</span></span><br><span class="line"><span class="string">        2.2 在响应结果经过django中间件时才真正地操作数据库</span></span><br><span class="line"><span class="string">            django.contrib.sessions.middleware.SessionMiddleware</span></span><br><span class="line"><span class="string">    3. 将产生的随机字符串返回给客户端浏览器保存</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">return</span> HttpResponse(<span class="string">&#x27;嘿嘿嘿&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_session</span>(<span class="params">request</span>):</span></span><br><span class="line">    <span class="keyword">if</span> request.session.get(<span class="string">&#x27;hobby&#x27;</span>):</span><br><span class="line">        print(request.session)</span><br><span class="line">        print(request.session.get(<span class="string">&quot;hobby&quot;</span>))</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        1. 先从请求中获取sessionid对应的随机字符串</span></span><br><span class="line"><span class="string">        2. 拿着该随机字符串去django_session表中查找对应的数据</span></span><br><span class="line"><span class="string">            2.1 如果比对上了，则将对应的数据取出并以字典的形式封装到request.session中</span></span><br><span class="line"><span class="string">            2.2 如果比对不上，则request.session.get()返回None</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> HttpResponse(<span class="string">&quot;哈哈哈&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> HttpResponse(<span class="string">&quot;大爷 关门了 明晚再来吧&quot;</span>)</span><br></pre></td></tr></table></figure><h4 id="利用session实现登陆验证"><a href="#利用session实现登陆验证" class="headerlink" title="利用session实现登陆验证"></a>利用session实现登陆验证</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> wraps</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">check_login</span>(<span class="params">func</span>):</span></span><br><span class="line"><span class="meta">    @wraps(<span class="params">func</span>)</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inner</span>(<span class="params">request, *args, **kwargs</span>):</span></span><br><span class="line">        next_url = request.get_full_path()</span><br><span class="line">        <span class="keyword">if</span> request.session.get(<span class="string">&quot;user&quot;</span>):</span><br><span class="line">            <span class="keyword">return</span> func(request, *args, **kwargs)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> redirect(<span class="string">&quot;/login/?next=&#123;&#125;&quot;</span>.<span class="built_in">format</span>(next_url))</span><br><span class="line">    <span class="keyword">return</span> inner</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">login</span>(<span class="params">request</span>):</span></span><br><span class="line">    <span class="keyword">if</span> request.method == <span class="string">&quot;POST&quot;</span>:</span><br><span class="line">        user = request.POST.get(<span class="string">&quot;user&quot;</span>)</span><br><span class="line">        pwd = request.POST.get(<span class="string">&quot;pwd&quot;</span>)</span><br><span class="line">        <span class="keyword">if</span> user == <span class="string">&quot;alex&quot;</span> <span class="keyword">and</span> pwd == <span class="string">&quot;alex1234&quot;</span>:</span><br><span class="line">            <span class="comment"># 设置session</span></span><br><span class="line">            request.session[<span class="string">&quot;user&quot;</span>] = user</span><br><span class="line">            <span class="comment"># 获取跳到登陆页面之前的URL</span></span><br><span class="line">            next_url = request.GET.get(<span class="string">&quot;next&quot;</span>)</span><br><span class="line">            <span class="comment"># 如果有，就跳转回登陆之前的URL</span></span><br><span class="line">            <span class="keyword">if</span> next_url:</span><br><span class="line">                <span class="keyword">return</span> redirect(next_url)</span><br><span class="line">            <span class="comment"># 否则默认跳转到index页面</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> redirect(<span class="string">&quot;/index/&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> render(request, <span class="string">&quot;login.html&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@check_login</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">logout</span>(<span class="params">request</span>):</span></span><br><span class="line">    <span class="comment"># 删除所有当前请求相关的session</span></span><br><span class="line">    request.session.flush()</span><br><span class="line">    <span class="keyword">return</span> redirect(<span class="string">&quot;/login/&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@check_login</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span>(<span class="params">request</span>):</span></span><br><span class="line">    current_user = request.session.get(<span class="string">&quot;user&quot;</span>, <span class="literal">None</span>)</span><br><span class="line">    <span class="keyword">return</span> render(request, <span class="string">&quot;index.html&quot;</span>, &#123;<span class="string">&quot;user&quot;</span>: current_user&#125;)</span><br></pre></td></tr></table></figure><h3 id="CBV添加装饰器"><a href="#CBV添加装饰器" class="headerlink" title="CBV添加装饰器"></a>CBV添加装饰器</h3><h4 id="加在CBV的get或post方法上"><a href="#加在CBV的get或post方法上" class="headerlink" title="加在CBV的get或post方法上"></a>加在CBV的get或post方法上</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.utils.decorators <span class="keyword">import</span> method_decorator</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HomeView</span>(<span class="params">View</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span>(<span class="params">self, request</span>):</span></span><br><span class="line">        <span class="keyword">return</span> render(request, <span class="string">&quot;home.html&quot;</span>)</span><br><span class="line">    </span><br><span class="line"><span class="meta">    @method_decorator(<span class="params">check_login</span>)</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">post</span>(<span class="params">self, request</span>):</span></span><br><span class="line">        print(<span class="string">&quot;Home View POST method...&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> redirect(<span class="string">&quot;/index/&quot;</span>)</span><br></pre></td></tr></table></figure><h4 id="加在dispatch方法上"><a href="#加在dispatch方法上" class="headerlink" title="加在dispatch方法上"></a>加在dispatch方法上</h4><p>因为CBV中首先执行的就是dispatch方法，所以直接作用于当前类里面的所有的方法</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.utils.decorators <span class="keyword">import</span> method_decorator</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HomeView</span>(<span class="params">View</span>):</span></span><br><span class="line"><span class="meta">    @method_decorator(<span class="params">check_login</span>)</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dispatch</span>(<span class="params">self, request, *args, **kwargs</span>):</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>(HomeView, self).dispatch(request, *args, **kwargs)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span>(<span class="params">self, request</span>):</span></span><br><span class="line">        <span class="keyword">return</span> render(request, <span class="string">&quot;home.html&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">post</span>(<span class="params">self, request</span>):</span></span><br><span class="line">        print(<span class="string">&quot;Home View POST method...&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> redirect(<span class="string">&quot;/index/&quot;</span>)</span><br></pre></td></tr></table></figure><h4 id="加在视图类上"><a href="#加在视图类上" class="headerlink" title="加在视图类上"></a>加在视图类上</h4><p>如果get方法和post方法都需要登录校验的话就写两个装饰器。</p><p>但method_decorator必须传 name 关键字参数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.utils.decorators <span class="keyword">import</span> method_decorator</span><br><span class="line"></span><br><span class="line"><span class="meta">@method_decorator(<span class="params">check_login, name=<span class="string">&quot;get&quot;</span></span>)</span></span><br><span class="line"><span class="meta">@method_decorator(<span class="params">check_login, name=<span class="string">&quot;post&quot;</span></span>)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HomeView</span>(<span class="params">View</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span>(<span class="params">self, request</span>):</span></span><br><span class="line">        <span class="keyword">return</span> render(request, <span class="string">&quot;home.html&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">post</span>(<span class="params">self, request</span>):</span></span><br><span class="line">        print(<span class="string">&quot;Home View POST method...&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> redirect(<span class="string">&quot;/index/&quot;</span>)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Django </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Django-Part4</title>
      <link href="/2021/08/Django-Part4/"/>
      <url>/2021/08/Django-Part4/</url>
      
        <content type="html"><![CDATA[<h1 id="Django-Part4——模型层"><a href="#Django-Part4——模型层" class="headerlink" title="Django-Part4——模型层"></a>Django-Part4——模型层</h1><p>[TOC]</p><h2 id="测试脚本"><a href="#测试脚本" class="headerlink" title="测试脚本"></a>测试脚本</h2><ul><li>当只是想测试django项目中的某一个.py文件内容，那么可以不用书写前后端交互的形式，而是直接写一个测试脚本即可。</li><li>脚本代码无论是写在应用下的tests.py，还是单独开设.py文件都可以。</li><li>django中的文件默认不会暴露出来，需要准备测试环境才能进行测试。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 测试环境的准备：1. 在manage.py中拷贝前四行代码；2. 额外增加两行代码</span></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    os.environ.setdefault(<span class="string">&quot;DJANGO_SETTINGS_MODULE&quot;</span>, <span class="string">&quot;djangoProject.settings&quot;</span>)  <span class="comment"># 这里要改成相应的项目名</span></span><br><span class="line">    <span class="keyword">import</span> django</span><br><span class="line">    django.setup()</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 测试代码</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li><p>当<code>from app01 import models</code>写在main之外时，可以通过勾选”使用Python控制台运行”来解决 <a href="https://blog.csdn.net/weixin_44393803/article/details/89739066">https://blog.csdn.net/weixin_44393803/article/details/89739066</a></p></li><li><p>当不准备环境配置时，可以在运行配置中勾选 Python控制台启动 。这样会忽略脚本中的配置环境代码。（推荐）</p></li></ul><h2 id="Django-ORM"><a href="#Django-ORM" class="headerlink" title="Django ORM"></a>Django ORM</h2><h3 id="创建模型表"><a href="#创建模型表" class="headerlink" title="创建模型表"></a>创建模型表</h3><ul><li>对象关系映射（ORM），能够以面向对象的方式简便快捷地操作数据库。但是封装程度太高，有时候还是需要自己写SQL语句。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -&gt; app -&gt; models.py</span></span><br><span class="line"><span class="comment"># 1. 首先在models.py中书写一个类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span>(<span class="params">models.Model</span>):</span></span><br><span class="line">    <span class="comment"># id int primary_key auto_increment</span></span><br><span class="line">    <span class="built_in">id</span> = models.AutoField(primary_key=<span class="literal">True</span>, verbose_name=<span class="string">&#x27;主键&#x27;</span>)  <span class="comment"># verbose_name用来对字段解释</span></span><br><span class="line">    <span class="comment"># username varchar(32)</span></span><br><span class="line">    username = models.CharField(max_length=<span class="number">32</span>, verbose_name=<span class="string">&#x27;用户名&#x27;</span>)  <span class="comment"># CharField必须要指定max_length参数，否则报错</span></span><br><span class="line">    <span class="comment"># password int</span></span><br><span class="line">    password = models.IntegerField(verbose_name=<span class="string">&#x27;密码&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Author</span>(<span class="params">models.Model</span>):</span></span><br><span class="line">    <span class="comment"># 由于一张表中必须要有一个主键字段，并且一般情况下都叫id字段</span></span><br><span class="line">    <span class="comment"># 所以当不定义主键字段时，orm会自动创建一个名为id主键字段</span></span><br><span class="line">    <span class="comment"># 也就意味着：后续在创建表时，如果主键字段名没有额外的叫法，那么主键字段可以省略不写</span></span><br><span class="line">    <span class="comment"># username varchar(32)</span></span><br><span class="line">    username = models.CharField(max_length=<span class="number">32</span>)</span><br><span class="line">    <span class="comment"># password int</span></span><br><span class="line">    password = models.IntegerField()</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>每次只要修改了models.py中跟数据库相关的代码，就必须重新执行以下两条命令。</li><li>如果发现执行之后没有发生变化，则检查app是否已经注册</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -&gt; 控制台</span></span><br><span class="line"><span class="comment"># 2. 数据库迁移命令</span></span><br><span class="line">python manage.py makemigrations  <span class="comment"># 将操作记录记录migrations文件夹中</span></span><br><span class="line">python manage.py migrate  <span class="comment"># 将操作真正的同步到数据库中</span></span><br></pre></td></tr></table></figure><ul><li>除自建表之外，还有Django需要使用的表</li></ul><p><img src="/2021/08/Django-Part4/image-20210616153539184.png" alt="image-20210616153539184"></p><h3 id="字段的增-删-改"><a href="#字段的增-删-改" class="headerlink" title="字段的增/删/改"></a>字段的增/删/改</h3><ul><li><p>当数据表拥有记录时，不能增加非空字段：</p><ol><li>在终端内直接给出默认值</li><li>退出终端程序，并修改代码为可以为空<code>xxx = models.CharField(max_length=32, null=True)</code></li><li>退出终端程序，并修改代码设置默认值<code>xxx = models.CharField(max_length=32, default=&#39;xxx&#39;)</code></li></ol></li><li><p>修改字段则是修改对应代码</p></li><li><p>删除字段则是注释/删除对应代码</p></li></ul><p>修改model文件之后，不要忘了执行数据库迁移的两条命令</p><blockquote><p>不要轻易地删除/注释字段，删除也最好使用软删除！</p><p>在对于数据库操作时一定要注意隐私安全，一定要锁屏！</p></blockquote><h3 id="创建表关系"><a href="#创建表关系" class="headerlink" title="创建表关系"></a>创建表关系</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.db <span class="keyword">import</span> models</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Create your models here.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建表关系。先将基表创建出来，然后再添加外键字段</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Book</span>(<span class="params">models.Model</span>):</span></span><br><span class="line">    title = models.CharField(max_length=<span class="number">32</span>, verbose_name=<span class="string">&quot;书名&quot;</span>)</span><br><span class="line">    price = models.DecimalField(max_digits=<span class="number">8</span>, decimal_places=<span class="number">2</span>)  <span class="comment"># 总共八位 小数点后面占两位</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 图书和出版社是一对多，并且书是多的一方，所以外键字段放在书表里面</span></span><br><span class="line">    publish = models.ForeignKey(to=<span class="string">&#x27;Publish&#x27;</span>, on_delete=models.CASCADE)</span><br><span class="line">    <span class="comment"># to_field=默认与出版社表的主键字段做外键关联</span></span><br><span class="line">    <span class="comment"># 如果该字段是ForeignKey，则orm会自动在字段的后面加 _id -&gt; publish_id</span></span><br><span class="line">    <span class="comment"># 因此在定义ForeignKey的时候就不要加 _id</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 图书和作者是多对多的关系，外键字段建在任意一方均可，但是推荐建在查询频率较高的一方</span></span><br><span class="line">    authors = models.ManyToManyField(to=<span class="string">&#x27;Author&#x27;</span>)</span><br><span class="line">    <span class="comment"># authors是一个虚拟字段 主要是用来告诉orm 书籍表和作者表是多对多关系</span></span><br><span class="line">    <span class="comment"># orm将自动创建第三张关系表</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Publish</span>(<span class="params">models.Model</span>):</span></span><br><span class="line">    name = models.CharField(max_length=<span class="number">32</span>)</span><br><span class="line">    addr = models.CharField(max_length=<span class="number">32</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Author</span>(<span class="params">models.Model</span>):</span></span><br><span class="line">    name = models.CharField(max_length=<span class="number">32</span>)</span><br><span class="line">    age = models.IntegerField()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 作者与作者详情是一对一的关系 外键字段建在任意一方都可以 但是推荐你建在查询频率较高的表中</span></span><br><span class="line">    author_detail = models.OneToOneField(to=<span class="string">&#x27;AuthorDetail&#x27;</span>, on_delete=models.CASCADE)  <span class="comment"># django2.x之后要手动添加级联删除</span></span><br><span class="line">    <span class="comment"># OneToOneField()也会自动给字段 author_detail 加 _id 后缀</span></span><br><span class="line">    <span class="comment"># on_delete有CASCADE、PROTECT、SET_NULL、SET_DEFAULT、SET(value)五个可选择的值</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AuthorDetail</span>(<span class="params">models.Model</span>):</span></span><br><span class="line">    phone = models.BigIntegerField()  <span class="comment"># 直接用字符类型更好</span></span><br><span class="line">    addr = models.CharField(max_length=<span class="number">32</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li><code>A表外键字段 = models.ForeignKey(to=B表)</code> </li><li><code>关系表外键字段 = models.ManyToManyField(to=B表)</code> </li><li><code>A表外键字段 = models.OneToOneField(to=B表)</code> </li></ul><blockquote><p>外键都会自动加_id后缀</p></blockquote><h2 id="单表操作"><a href="#单表操作" class="headerlink" title="单表操作"></a>单表操作</h2><h3 id="增删改查"><a href="#增删改查" class="headerlink" title="增删改查"></a>增删改查</h3><ul><li>在视图函数中，<code>from app01 import models</code>首先导入对应的app下的model</li><li>django自带的sqlite3数据库对日期格式不是很敏感，处理的时候容易出错。</li><li>pk会自动查找到当前表的主键字段，指代的就是当前表的主键字段，避免区分当前表的主键字段名uid/pid/sid</li></ul><h4 id="增"><a href="#增" class="headerlink" title="增"></a>增</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">reg</span>(<span class="params">request</span>):</span></span><br><span class="line">    <span class="keyword">if</span> request.method == <span class="string">&quot;POST&quot;</span>:</span><br><span class="line">        username = request.POST.get(<span class="string">&#x27;username&#x27;</span>)</span><br><span class="line">        password = request.POST.get(<span class="string">&#x27;password&#x27;</span>)</span><br><span class="line">        <span class="keyword">from</span> app01 <span class="keyword">import</span> models</span><br><span class="line">        <span class="comment"># 第一种方式(推荐使用)</span></span><br><span class="line">reslt = models.User.objects.create(username=username, password=password)  </span><br><span class="line">        print(res, res.username, res.password)  <span class="comment"># 返回值就是当前被创建的对象本身</span></span><br><span class="line">        <span class="comment"># 第二种方式</span></span><br><span class="line">user_obj = models.User(username=username, password=password)</span><br><span class="line">user_obj.save()  <span class="comment"># 保存数据</span></span><br><span class="line">        </span><br><span class="line">    <span class="comment"># 先给用户返回一个注册页面</span></span><br><span class="line">    <span class="keyword">return</span> render(request, <span class="string">&#x27;reg.html&#x27;</span>)</span><br></pre></td></tr></table></figure><h4 id="查"><a href="#查" class="headerlink" title="查"></a>查</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">login</span>(<span class="params">request</span>):</span></span><br><span class="line">    <span class="keyword">if</span> request.method == <span class="string">&#x27;POST&#x27;</span>:</span><br><span class="line">        <span class="comment"># 获取用户的用户名和密码 然后利用orm操作数据 校验数据是否正确</span></span><br><span class="line">        username = request.POST.get(<span class="string">&#x27;username&#x27;</span>)</span><br><span class="line">        password = request.POST.get(<span class="string">&#x27;password&#x27;</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 去数据库中查询数据</span></span><br><span class="line">        <span class="keyword">from</span> app01 <span class="keyword">import</span> models</span><br><span class="line">        <span class="comment"># select * from user where username=&#x27;jason&#x27;;</span></span><br><span class="line">        <span class="comment"># filter相当于where，括号内可以携带多个参数，参数与参数之间是and关系</span></span><br><span class="line">        result = models.User.objects.<span class="built_in">filter</span>(username=username)</span><br><span class="line">        print(<span class="built_in">type</span>(result))  <span class="comment"># &lt;QuerySet [&lt;User: User object&gt;]&gt;</span></span><br><span class="line"><span class="comment"># 支持索引取值、切片操作，但是不支持负数索引</span></span><br><span class="line">user_obj = reslt.first()  <span class="comment"># 从queryset拿出一个个数据对象</span></span><br><span class="line">print(user_obj.username)  <span class="comment"># 直接调用字段</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 比对密码是否一致</span></span><br><span class="line">        <span class="keyword">if</span> user_obj:</span><br><span class="line">            <span class="keyword">if</span> password == user_obj.password:</span><br><span class="line">                <span class="keyword">return</span> HttpResponse(<span class="string">&quot;登陆成功&quot;</span>)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> HttpResponse(<span class="string">&quot;密码错误&quot;</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> HttpResponse(<span class="string">&quot;用户不存在&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> render(request, <span class="string">&#x27;login.html&#x27;</span>)</span><br></pre></td></tr></table></figure><ul><li><code>models.User.objects.filter()</code>等效于<code>models.User.objects.all()</code></li><li><code>.first()</code>等效于<code>[0]</code></li></ul><p>数据展示：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -&gt; views.py</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">userlist</span>(<span class="params">request</span>):</span></span><br><span class="line">    <span class="comment"># 查询出用户表里面所有的数据</span></span><br><span class="line">    user_queryset = models.User.objects.<span class="built_in">all</span>()</span><br><span class="line">    <span class="comment"># return render(request,&#x27;userlist.html&#x27;,&#123;&#x27;user_queryset&#x27;:user_queryset&#125;)</span></span><br><span class="line">    <span class="keyword">return</span> render(request,<span class="string">&#x27;userlist.html&#x27;</span>, <span class="built_in">locals</span>())  <span class="comment"># 返回当前的命名空间</span></span><br></pre></td></tr></table></figure><p>模板语法for：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#123;% for user_obj in user_queryset %&#125;</span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span>&#123;&#123; user_obj.id &#125;&#125;<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span>&#123;&#123; user_obj.username &#125;&#125;<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span>&#123;&#123; user_obj.password &#125;&#125;<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span></span><br><span class="line">&#123;#            利用url问号后面携带参数的方式，将编辑按钮所在行的主键值发送给后端#&#125;</span><br><span class="line">            <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;/edit_user/?user_id=&#123;&#123; user_obj.id &#125;&#125;&quot;</span> <span class="attr">class</span>=<span class="string">&quot;btn btn-primary btn-xs&quot;</span>&gt;</span>编辑<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;/delete_user/?user_id=&#123;&#123; user_obj.id &#125;&#125;&quot;</span> <span class="attr">class</span>=<span class="string">&quot;btn btn-danger btn-xs&quot;</span>&gt;</span>删除<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">&#123;% endfor %&#125;</span><br></pre></td></tr></table></figure><h4 id="改"><a href="#改" class="headerlink" title="改"></a>改</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">edit_user</span>(<span class="params">request</span>):</span></span><br><span class="line">    <span class="comment"># 获取url问号后面的参数</span></span><br><span class="line">    edit_id = request.GET.get(<span class="string">&#x27;user_id&#x27;</span>)</span><br><span class="line">    <span class="comment"># 查询当前用户想要编辑的数据对象</span></span><br><span class="line">    edit_list = models.User.objects.<span class="built_in">filter</span>(<span class="built_in">id</span>=edit_id)</span><br><span class="line">    edit_obj = edit_list.first()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> request.method == <span class="string">&quot;POST&quot;</span>:</span><br><span class="line">        username = request.POST.get(<span class="string">&#x27;username&#x27;</span>)</span><br><span class="line">        password = request.POST.get(<span class="string">&#x27;password&#x27;</span>)</span><br><span class="line">        <span class="comment"># 改 1 批量更新filter查询出来的列表中所有对象。只修改被修改的字段</span></span><br><span class="line">        edit_list.update(username=username, password=password)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 改 2 单条数据更新。无论该字段是否被修改，重写所有字段(当字段特别多时，效率很低)</span></span><br><span class="line">        edit_obj.username = username</span><br><span class="line">        edit_obj.password = password</span><br><span class="line">        edit_obj.save()</span><br><span class="line">      </span><br><span class="line">        <span class="keyword">return</span> redirect(<span class="string">&#x27;/userlist/&#x27;</span>)  <span class="comment"># 跳转到数据的展示页面</span></span><br><span class="line">    <span class="keyword">return</span> render(request, <span class="string">&#x27;edit_user.html&#x27;</span>, <span class="built_in">locals</span>())  <span class="comment"># 将数据对象展示到页面上</span></span><br></pre></td></tr></table></figure><h4 id="删"><a href="#删" class="headerlink" title="删"></a>删</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">delete_user</span>(<span class="params">request</span>):</span></span><br><span class="line">    <span class="comment"># 获取用户想要删除的数据id值</span></span><br><span class="line">    delete_id = request.GET.get(<span class="string">&#x27;user_id&#x27;</span>)</span><br><span class="line">    <span class="comment"># 删 1 批量删除数据库中找到对应的数据</span></span><br><span class="line">    res = models.User.objects.<span class="built_in">filter</span>(<span class="built_in">id</span>=delete_id).delete()</span><br><span class="line">    print(res)  <span class="comment"># (1, &#123;&#x27;app01.User&#x27;: 1&#125;)</span></span><br><span class="line">    <span class="comment"># 删 2</span></span><br><span class="line">    user_obj = models.User.objects.<span class="built_in">filter</span>(pk=delete_id).first()</span><br><span class="line">    user_obj.delete()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> redirect(<span class="string">&#x27;/userlist/&#x27;</span>)</span><br></pre></td></tr></table></figure><blockquote><p>一般都会添加一个is_delete字段做软删除，而不会直接删除。</p></blockquote><h3 id="必知必会13条"><a href="#必知必会13条" class="headerlink" title="必知必会13条"></a>必知必会13条</h3><ol><li><p>all()：查询所有数据</p></li><li><p>filter()：带有过滤条件的查询</p></li><li><p>get()：直接拿数据对象，但是条件不存在直接报错</p></li><li><p>first()：拿queryset里面第一个元素</p></li><li><p>last()：拿queryset里面最后一个元素</p></li><li><p>values()：可以指定获取的数据字段，相当于select name,age from …     </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">res = models.User.objects.values(<span class="string">&#x27;name&#x27;</span>,<span class="string">&#x27;age&#x27;</span>)</span><br><span class="line">print(res)  <span class="comment"># 列表套字典 &lt;QuerySet [&#123;&#x27;name&#x27;: &#x27;jason&#x27;, &#x27;age&#x27;: 18&#125;, &#123;&#x27;name&#x27;: &#x27;egonPPP&#x27;, &#x27;age&#x27;: 84&#125;]&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>values_list()：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">res = models.User.objects.values_list(<span class="string">&#x27;name&#x27;</span>,<span class="string">&#x27;age&#x27;</span>)</span><br><span class="line">print(res)  <span class="comment"># 列表套元组 &lt;QuerySet [(&#x27;jason&#x27;, 18), (&#x27;egonPPP&#x27;, 84)]&gt;</span></span><br></pre></td></tr></table></figure><p>和values()仅仅只是封装格式不一样，sql查询语句是一样的。</p></li><li><p>distinct()：去重</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">res = models.User.objects.values(<span class="string">&#x27;name&#x27;</span>,<span class="string">&#x27;age&#x27;</span>).distinct()</span><br><span class="line">print(res)</span><br></pre></td></tr></table></figure><ul><li><p>去重一定要是（在虚表中）一模一样的数据。</p><p>例如：.all()的数据带有主键，因此无法去重</p></li></ul></li><li><p>order_by()：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">res = models.User.objects.order_by(<span class="string">&#x27;age&#x27;</span>)  <span class="comment"># 默认升序</span></span><br><span class="line">res = models.User.objects.order_by(<span class="string">&#x27;-age&#x27;</span>)  <span class="comment"># 降序</span></span><br><span class="line">print(res)</span><br></pre></td></tr></table></figure></li><li><p>reverse()：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">res = models.User.objects.<span class="built_in">all</span>()  <span class="comment"># 反转</span></span><br><span class="line">res1 = models.User.objects.order_by(<span class="string">&#x27;age&#x27;</span>).reverse()  <span class="comment"># 必须先排序</span></span><br><span class="line">print(res, res1)</span><br></pre></td></tr></table></figure></li><li><p>count()：统计当前数据的个数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">res = models.User.objects.count()  <span class="comment"># 统计当前数据的个数</span></span><br><span class="line">print(res)</span><br></pre></td></tr></table></figure></li><li><p>exclude()：排除在外</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">res = models.User.objects.exclude(name=<span class="string">&#x27;jason&#x27;</span>)</span><br><span class="line">print(res)</span><br></pre></td></tr></table></figure></li><li><p>exists()：基本用不到因为数据本身就自带布尔值  返回的是布尔值</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">res = models.User.objects.<span class="built_in">filter</span>(pk=<span class="number">10</span>).exists()</span><br><span class="line">print(res)</span><br></pre></td></tr></table></figure><h3 id="查看内部sql语句的方式"><a href="#查看内部sql语句的方式" class="headerlink" title="查看内部sql语句的方式"></a>查看内部sql语句的方式</h3></li><li><p>只有QuerySet类对象可以使用.query查看内部封装的sql语句</p></li><li><p>在配置文件中配置logging，查看所有的sql语句</p></li><li><p>需要在Python控制台中运行才能看见</p></li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 方式1</span></span><br><span class="line">res = models.User.objects.values_list(<span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;age&#x27;</span>)</span><br><span class="line">print(res.query)  <span class="comment"># SELECT `app01_user`.`name`, `app01_user`.`age` FROM `app01_user`</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 方式2</span></span><br><span class="line"><span class="comment"># -&gt; settings.py</span></span><br><span class="line">LOGGING = &#123;</span><br><span class="line">    <span class="string">&#x27;version&#x27;</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="string">&#x27;disable_existing_loggers&#x27;</span>: <span class="literal">False</span>,</span><br><span class="line">    <span class="string">&#x27;handlers&#x27;</span>: &#123;</span><br><span class="line">        <span class="string">&#x27;console&#x27;</span>:&#123;</span><br><span class="line">            <span class="string">&#x27;level&#x27;</span>:<span class="string">&#x27;DEBUG&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;class&#x27;</span>:<span class="string">&#x27;logging.StreamHandler&#x27;</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">&#x27;loggers&#x27;</span>: &#123;</span><br><span class="line">        <span class="string">&#x27;django.db.backends&#x27;</span>: &#123;</span><br><span class="line">            <span class="string">&#x27;handlers&#x27;</span>: [<span class="string">&#x27;console&#x27;</span>],</span><br><span class="line">            <span class="string">&#x27;propagate&#x27;</span>: <span class="literal">True</span>,</span><br><span class="line">            <span class="string">&#x27;level&#x27;</span>:<span class="string">&#x27;DEBUG&#x27;</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="双下划线查询"><a href="#双下划线查询" class="headerlink" title="双下划线查询"></a>双下划线查询</h3><ul><li>__gt: 大于</li><li>__gte: 大于等于</li><li>__lt: 小于</li><li>__lte: 小于等于</li><li>__in: 在目标集合中，左右闭区间</li><li>__range: 在目标范围中</li><li>__contains: 模糊查询，包含（区分大小写）</li><li>__icontains: 包含（不区分大小写）</li><li>__startswith: 以某字符开头</li><li>__endswith: 以某字符结尾</li><li>__month: 在目标月份</li><li>__year: 在目标年份</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 年龄大于35岁的数据</span></span><br><span class="line">res = models.User.objects.<span class="built_in">filter</span>(age__gt=<span class="number">35</span>)</span><br><span class="line">print(res)</span><br><span class="line"><span class="comment"># 年龄小于35岁的数据</span></span><br><span class="line">res = models.User.objects.<span class="built_in">filter</span>(age__lt=<span class="number">35</span>)</span><br><span class="line">print(res)</span><br><span class="line"><span class="comment"># 大于等于 小于等于</span></span><br><span class="line">res = models.User.objects.<span class="built_in">filter</span>(age__gte=<span class="number">32</span>)</span><br><span class="line">print(res)</span><br><span class="line">res = models.User.objects.<span class="built_in">filter</span>(age__lte=<span class="number">32</span>)</span><br><span class="line">print(res)</span><br><span class="line"><span class="comment"># 年龄是 18 或者 32 或者 40</span></span><br><span class="line">res = models.User.objects.<span class="built_in">filter</span>(age__in=[<span class="number">18</span>, <span class="number">32</span>, <span class="number">40</span>])</span><br><span class="line">print(res)</span><br><span class="line"><span class="comment"># 年龄在18到40岁之间的  首尾都要</span></span><br><span class="line">res = models.User.objects.<span class="built_in">filter</span>(age__range=[<span class="number">18</span>, <span class="number">40</span>])</span><br><span class="line">print(res)</span><br><span class="line"><span class="comment"># 查询出名字里面含有s的数据  模糊查询</span></span><br><span class="line">res = models.User.objects.<span class="built_in">filter</span>(name__contains=<span class="string">&#x27;s&#x27;</span>)</span><br><span class="line">print(res)</span><br><span class="line"><span class="comment"># 是否区分大小写  查询出名字里面含有p的数据  区分大小写</span></span><br><span class="line">res = models.User.objects.<span class="built_in">filter</span>(name__contains=<span class="string">&#x27;p&#x27;</span>)</span><br><span class="line">print(res)</span><br><span class="line"><span class="comment"># 忽略大小写</span></span><br><span class="line">res = models.User.objects.<span class="built_in">filter</span>(name__icontains=<span class="string">&#x27;p&#x27;</span>)</span><br><span class="line">print(res)</span><br><span class="line"><span class="comment"># 开头结尾 </span></span><br><span class="line">res = models.User.objects.<span class="built_in">filter</span>(name__startswith=<span class="string">&#x27;j&#x27;</span>)</span><br><span class="line">res1 = models.User.objects.<span class="built_in">filter</span>(name__endswith=<span class="string">&#x27;j&#x27;</span>)</span><br><span class="line">print(res, res1)</span><br><span class="line"><span class="comment"># 查询出注册时间是 2020 1月</span></span><br><span class="line">res = models.User.objects.<span class="built_in">filter</span>(register_time__month=<span class="string">&#x27;1&#x27;</span>, register_time__year=<span class="string">&#x27;2020&#x27;</span>)</span><br><span class="line">res = res.<span class="built_in">filter</span>(register_time__year=<span class="string">&#x27;2020&#x27;</span>)</span><br></pre></td></tr></table></figure><h3 id="一对多外键增删改查"><a href="#一对多外键增删改查" class="headerlink" title="一对多外键增删改查"></a>一对多外键增删改查</h3><ul><li><p>增 create(): publish_id=num或者publish=publish_obj</p></li><li><p>删 filter(pk=pk).delete(): 会按照on_delete处理对应外键</p></li><li><p>改 filter(pk=pk).update(): publish_id=num或者publish=publish_obj</p><p>这是批量修改，在first()返回的对象中没有update这个方法</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 一对多增删改查</span></span><br><span class="line"><span class="comment"># 1. 增</span></span><br><span class="line"><span class="comment"># 直接写实际字段 id</span></span><br><span class="line">models.Book.objects.create(title=<span class="string">&#x27;三国演义&#x27;</span>, price=<span class="number">123.23</span>, publish_id=<span class="number">1</span>)</span><br><span class="line"><span class="comment"># 投放虚拟字段 对象</span></span><br><span class="line">publish_obj = models.Publish.objects.<span class="built_in">filter</span>(pk=<span class="number">2</span>).first()</span><br><span class="line">models.Book.objects.create(title=<span class="string">&quot;红楼梦&quot;</span>, price=<span class="number">666.23</span>, publish=publish_obj)</span><br><span class="line"><span class="comment"># 2. 删</span></span><br><span class="line">models.Publish.objects.<span class="built_in">filter</span>(pk=<span class="number">1</span>).delete()  <span class="comment"># 会按照on_delete处理对应外键</span></span><br><span class="line"><span class="comment"># 3. 改</span></span><br><span class="line">models.Book.objects.<span class="built_in">filter</span>(pk=<span class="number">1</span>).update(publish_id=<span class="number">2</span>)</span><br><span class="line">publish_obj = models.Publish.objects.<span class="built_in">filter</span>(pk=<span class="number">1</span>).first()</span><br><span class="line">models.Book.objects.<span class="built_in">filter</span>(pk=<span class="number">1</span>).update(publish=publish_obj)</span><br></pre></td></tr></table></figure><h3 id="多对多外键增删改查"><a href="#多对多外键增删改查" class="headerlink" title="多对多外键增删改查"></a>多对多外键增删改查</h3><ul><li><p>models.表名.objects.filter(pk=条件).first().多对多关系.add()</p><p>方法支持传递主键，也可以传递对象</p></li><li><p>models.表名.objects.filter(pk=条件).first().多对多关系.remove()</p><p>这只是在第三张关系表中删除记录</p></li><li><p>models.表名.objects.filter(pk=条件).first().多对多关系.set()</p><p>括号内必须给一个可迭代对象</p><p>如果不符合要求，则先删除，后新增</p></li><li><p>models.表名.objects.filter(pk=条件).first().多对多关系.clear()</p><p>在第三张关系表中清空某个书籍与作者的绑定关系</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1. 增加关系</span></span><br><span class="line">   <span class="comment"># 给书籍添加作者</span></span><br><span class="line">   book_obj = models.Book.objects.<span class="built_in">filter</span>(pk=<span class="number">1</span>).first()</span><br><span class="line">   print(book_obj.authors)  <span class="comment"># 就类似于你已经到了Book和Authors的多对多关系表了</span></span><br><span class="line">   book_obj.authors.add(<span class="number">1</span>)  <span class="comment"># 书籍id为1的书籍绑定一个主键为1的作者</span></span><br><span class="line">   book_obj.authors.add(<span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">   author_obj = models.Author.objects.<span class="built_in">filter</span>(pk=<span class="number">1</span>).first()</span><br><span class="line">   author_obj1 = models.Author.objects.<span class="built_in">filter</span>(pk=<span class="number">2</span>).first()</span><br><span class="line">   author_obj2 = models.Author.objects.<span class="built_in">filter</span>(pk=<span class="number">3</span>).first()</span><br><span class="line">   book_obj.authors.add(author_obj)</span><br><span class="line">   book_obj.authors.add(author_obj1, author_obj2)</span><br><span class="line"></span><br><span class="line">   <span class="comment"># 2. 删</span></span><br><span class="line">   book_obj.authors.remove(<span class="number">2</span>)</span><br><span class="line">   book_obj.authors.remove(<span class="number">1</span>, <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">   author_obj = models.Author.objects.<span class="built_in">filter</span>(pk=<span class="number">2</span>).first()</span><br><span class="line">   author_obj1 = models.Author.objects.<span class="built_in">filter</span>(pk=<span class="number">3</span>).first()</span><br><span class="line">   book_obj.authors.remove(author_obj, author_obj1)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. 改</span></span><br><span class="line">   book_obj.authors.<span class="built_in">set</span>([<span class="number">1</span>, <span class="number">2</span>])</span><br><span class="line">   book_obj.authors.<span class="built_in">set</span>([<span class="number">3</span>])  <span class="comment"># 括号内必须给一个可迭代对象</span></span><br><span class="line"></span><br><span class="line">   author_obj = models.Author.objects.<span class="built_in">filter</span>(pk=<span class="number">2</span>).first()</span><br><span class="line">   author_obj1 = models.Author.objects.<span class="built_in">filter</span>(pk=<span class="number">3</span>).first()</span><br><span class="line">   book_obj.authors.<span class="built_in">set</span>([author_obj, author_obj1])  <span class="comment"># 支持多个</span></span><br><span class="line"></span><br><span class="line">   <span class="comment"># 4. 清空</span></span><br><span class="line">   book_obj.authors.clear()</span><br><span class="line">   book_obj.authors.<span class="built_in">set</span>([])</span><br></pre></td></tr></table></figure><h2 id="多表查询"><a href="#多表查询" class="headerlink" title="多表查询"></a>多表查询</h2><h3 id="正反向"><a href="#正反向" class="headerlink" title="正反向"></a>正反向</h3><ul><li>当a表中拥有b表的外键字段，则a查b为正向，否则反向。</li><li>一对一和多对多正反向的判断也是如此</li></ul><p>外键字段要放在查询频率高的表中。</p><blockquote><ul><li>正向查询按 <code>字段</code> </li><li>反向查询<ul><li>查询一对多、多对多时按 <code>表名小写+_set</code> </li><li>查询一对一时按 <code>表名小写</code></li></ul></li></ul></blockquote><h3 id="子查询-基于对象的跨表查询"><a href="#子查询-基于对象的跨表查询" class="headerlink" title="子查询(基于对象的跨表查询)"></a>子查询(基于对象的跨表查询)</h3><p>在书写orm语句的时候跟写sql语句一样的：</p><ul><li>不要企图一次性将orm语句写完，如果比较复杂，就写一点看一点</li></ul><blockquote><p>正向什么时候需要加.all()：</p><ul><li>查询 多对多 和 一对多 关系时需要加</li><li>查询 一对一 和 多对一 关系时不需要</li><li>当为需要all()的情况时，即使结果只有一个，也会返回集合</li></ul></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1. 查询主键为1的书籍的出版社</span></span><br><span class="line">   <span class="comment"># 有字段 -&gt; 正向；查询多对一关系中一的一方 -&gt; 不用.all()</span></span><br><span class="line">   book_obj = models.Book.objects.<span class="built_in">filter</span>(pk=<span class="number">1</span>).first()</span><br><span class="line">   res = book_obj.publish</span><br><span class="line">   print(res.name)</span><br><span class="line"></span><br><span class="line">   <span class="comment"># 2. 查询主键为2的书籍的作者</span></span><br><span class="line">   <span class="comment"># 有字段 -&gt; 正向；多对多关系 -&gt; 要.all()</span></span><br><span class="line">   book_obj = models.Book.objects.<span class="built_in">filter</span>(pk=<span class="number">1</span>).first()</span><br><span class="line">   res = book_obj.authors</span><br><span class="line">   print(res)</span><br><span class="line">   <span class="comment"># app01.Author.None</span></span><br><span class="line">   print(res.<span class="built_in">all</span>())</span><br><span class="line">   <span class="comment"># &lt;QuerySet [&lt;Author: Author object (1)&gt;, &lt;Author: Author object (3)&gt;]&gt;</span></span><br><span class="line">   print(models.Book.objects.<span class="built_in">filter</span>(pk=<span class="number">3</span>).first().authors.<span class="built_in">all</span>())</span><br><span class="line">   <span class="comment"># &lt;QuerySet [&lt;Author: Author object (1)&gt;]&gt;</span></span><br><span class="line">   </span><br><span class="line">   <span class="comment"># 3. 查询作者jason的电话号码</span></span><br><span class="line">   <span class="comment"># 有字段 -&gt; 正向；一对一关系 -&gt; 不用.all()</span></span><br><span class="line">   author_obj = models.Author.objects.<span class="built_in">filter</span>(name=<span class="string">&quot;jason&quot;</span>).first()</span><br><span class="line">   res = author_obj.author_detail</span><br><span class="line">   print(res.phone, res.addr)</span><br><span class="line"></span><br><span class="line">   <span class="comment"># 4. 查询出版社是东方出版社出版的书</span></span><br><span class="line">   <span class="comment"># 无字段 -&gt; 反向；查询一对多关系中多的一方 -&gt; 要.all()</span></span><br><span class="line">   publish_obj = models.Publish.objects.<span class="built_in">filter</span>(name=<span class="string">&#x27;东方出版社&#x27;</span>).first()</span><br><span class="line">   res = publish_obj.book_set  <span class="comment"># app01.Book.None</span></span><br><span class="line">   res = publish_obj.book_set.<span class="built_in">all</span>()</span><br><span class="line">   print(res)</span><br><span class="line"></span><br><span class="line">   <span class="comment"># 5. 查询作者jason写过的书</span></span><br><span class="line">   <span class="comment"># 无字段 -&gt; 反向；多对多关系 -&gt; 要.all()</span></span><br><span class="line">   author_obj = models.Author.objects.<span class="built_in">filter</span>(name=<span class="string">&#x27;jason&#x27;</span>).first()</span><br><span class="line">   res = author_obj.book_set  <span class="comment"># app01.Book.None</span></span><br><span class="line">   res = author_obj.book_set.<span class="built_in">all</span>()</span><br><span class="line">   print(res)</span><br><span class="line"></span><br><span class="line">   <span class="comment"># 6.查询手机号是110的作者姓名</span></span><br><span class="line">   <span class="comment"># 无字段 -&gt; 反向；一对一关系 -&gt; 不用.all()，不用_set</span></span><br><span class="line">   author_detail_obj = models.AuthorDetail.objects.<span class="built_in">filter</span>(phone=<span class="number">110</span>).first()</span><br><span class="line">   res = author_detail_obj.author</span><br><span class="line">   print(res.name)</span><br></pre></td></tr></table></figure><h3 id="联表查询-基于双下划线的跨表查询"><a href="#联表查询-基于双下划线的跨表查询" class="headerlink" title="联表查询(基于双下划线的跨表查询)"></a>联表查询(基于双下划线的跨表查询)</h3><ul><li>QuerySet要先用int取字典，再用key取对应的数据</li><li>可以放多个查询的键</li><li>__就是用来获得表下的一个字段</li><li>而写到__之前则表示已经进入了另外一个表</li><li>这里非对象时都不需要_set</li><li>可以 __ id 或者 __pk，是等价的</li><li>可以无限制的跨表，正向、反向</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1. 查询jason的手机号和作者姓名</span></span><br><span class="line"><span class="comment"># 有字段 -&gt; 正向；</span></span><br><span class="line">res = models.Author.objects.<span class="built_in">filter</span>(name=<span class="string">&#x27;jason&#x27;</span>).values(<span class="string">&quot;author_detail__phone&quot;</span>, <span class="string">&quot;name&quot;</span>)</span><br><span class="line">print(res[<span class="number">0</span>][<span class="string">&quot;author_detail__phone&quot;</span>])</span><br><span class="line"><span class="comment"># 反向</span></span><br><span class="line">res = models.AuthorDetail.objects.<span class="built_in">filter</span>(author__name=<span class="string">&#x27;jason&#x27;</span>)  <span class="comment"># 拿作者姓名是jason的作者详情</span></span><br><span class="line">res = models.AuthorDetail.objects.<span class="built_in">filter</span>(author__name=<span class="string">&#x27;jason&#x27;</span>).values(<span class="string">&#x27;phone&#x27;</span>, <span class="string">&#x27;author__name&#x27;</span>)</span><br><span class="line">print(res)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2.查询书籍主键为1的出版社名称和书的名称</span></span><br><span class="line"><span class="comment"># 正向，写到publish时就已经到了publish表，主需要__来取这个表下的任意字段</span></span><br><span class="line">res = models.Book.objects.<span class="built_in">filter</span>(pk=<span class="number">1</span>).values(<span class="string">&#x27;title&#x27;</span>, <span class="string">&#x27;publish__name&#x27;</span>)</span><br><span class="line">print(res)</span><br><span class="line"><span class="comment"># 反向</span></span><br><span class="line">res = models.Publish.objects.<span class="built_in">filter</span>(book__pk=<span class="number">1</span>).values(<span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;book__title&#x27;</span>)</span><br><span class="line">print(res)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3.查询书籍主键为1的作者姓名</span></span><br><span class="line"><span class="comment"># 正向</span></span><br><span class="line">res = models.Book.objects.<span class="built_in">filter</span>(pk=<span class="number">1</span>).values(<span class="string">&#x27;authors__name&#x27;</span>)</span><br><span class="line">print(res)</span><br><span class="line"><span class="comment"># 反向</span></span><br><span class="line">res = models.Author.objects.<span class="built_in">filter</span>(book__id=<span class="number">1</span>).values(<span class="string">&#x27;name&#x27;</span>)</span><br><span class="line">print(res)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 4. 查询书籍主键是1的作者的手机号</span></span><br><span class="line">res = models.Book.objects.<span class="built_in">filter</span>(pk=<span class="number">1</span>).values(<span class="string">&quot;authors__author_detail__phone&quot;</span>)</span><br><span class="line">print(res)</span><br></pre></td></tr></table></figure><h3 id="聚合查询-aggregate"><a href="#聚合查询-aggregate" class="headerlink" title="聚合查询(aggregate)"></a>聚合查询(aggregate)</h3><ul><li>只要是跟数据库相关的模块，基本上都在django.db.models里面，如果没有则应该在django.db里面。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> app01 <span class="keyword">import</span> models</span><br><span class="line"><span class="keyword">from</span> django.db.models <span class="keyword">import</span> Max,Min,Sum,Count,Avg</span><br><span class="line">res = models.Book.objects.aggregate(Max(<span class="string">&#x27;price&#x27;</span>),Min(<span class="string">&#x27;price&#x27;</span>),Sum(<span class="string">&#x27;price&#x27;</span>),Count(<span class="string">&#x27;pk&#x27;</span>),Avg(<span class="string">&#x27;price&#x27;</span>))</span><br><span class="line">print(res)</span><br><span class="line"><span class="comment"># &#123;&#x27;price__max&#x27;: Decimal(&#x27;899.23&#x27;), &#x27;price__min&#x27;: Decimal(&#x27;123.23&#x27;), &#x27;price__sum&#x27;: Decimal(&#x27;2466.58&#x27;), &#x27;pk__count&#x27;: 5, &#x27;price__avg&#x27;: Decimal(&#x27;493.316000&#x27;)&#125;</span></span><br></pre></td></tr></table></figure><h3 id="分组查询-annotate"><a href="#分组查询-annotate" class="headerlink" title="分组查询(annotate)"></a>分组查询(annotate)</h3><ul><li>MySQL分组查询特点：分组之后默认只能获取到分组的依据，组内其他字段都无法直接获取了(严格模式，ONLY_FULL_GROUP_BY)</li><li>author和author__pk是等价的，个人认为写全更好</li><li>models后面点什么，就是按什么分组</li><li>author_num是自己定义的临时字段，用来存储统计出来的每本书对应的作者个数</li><li>在使用values创建虚表时，依然可以放入多个字段</li><li>只要orm语句得出的结果还是一个queryset对象，那么就可以继续无限制的点queryset对象封装的方法</li><li>queryset对象就代表一个虚表</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1. 统计每一本书的作者个数</span></span><br><span class="line">   <span class="comment"># 只需要写author就可以了</span></span><br><span class="line">   <span class="comment"># models后面点什么，就是按什么分组</span></span><br><span class="line">   <span class="comment"># author_num是我们自己定义的字段，用来存储统计出来的每本书对应的作者个数</span></span><br><span class="line">   <span class="comment"># 在使用values创建虚表时，依然可以放入多个字段 </span></span><br><span class="line">   res = models.Book.objects.annotate(author_num=Count(<span class="string">&quot;author__pk&quot;</span>)).values(<span class="string">&quot;author_num&quot;</span>, <span class="string">&#x27;title&#x27;</span>, <span class="string">&#x27;author_num&#x27;</span>)</span><br><span class="line">   print(res)</span><br><span class="line">   </span><br><span class="line">   <span class="comment"># 2. 统计每个出版社卖的最便宜的书的价格</span></span><br><span class="line">   <span class="comment"># 按publish分组，反向找book表中price的最小值，作为publish表的min_price临时字段</span></span><br><span class="line">   res = models.Publish.objects.annotate(min_price=Min(<span class="string">&#x27;book__price&#x27;</span>)).values(<span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;min_price&#x27;</span>)</span><br><span class="line">   print(res)</span><br><span class="line">   </span><br><span class="line">   <span class="comment"># 3. 统计不止一个作者的图书</span></span><br><span class="line">   <span class="comment"># 先按照图书分组，求每一本书对应的作者个数</span></span><br><span class="line">   <span class="comment"># 过滤出不止一个作者的图书</span></span><br><span class="line">   res = models.Book.objects.annotate(author_num=Count(<span class="string">&quot;author_id&quot;</span>)) \</span><br><span class="line">       .<span class="built_in">filter</span>(author__num__gt=<span class="number">1</span>) \</span><br><span class="line">       .values(<span class="string">&#x27;title&#x27;</span>, <span class="string">&#x27;author_num&#x27;</span>)</span><br><span class="line">   <span class="comment"># 只要orm语句得出的结果还是一个queryset对象，那么就可以继续无限制的点queryset对象封装的方法</span></span><br><span class="line">   <span class="comment"># queryset对象就代表一个虚表</span></span><br><span class="line">   print(res)</span><br><span class="line">   </span><br><span class="line">   <span class="comment"># 4. 查询每个作者出的书的总价格</span></span><br><span class="line">   res = models.Author.objects.annotate(sum_price=Sum(<span class="string">&#x27;book__price&#x27;</span>)).values(<span class="string">&#x27;name&#x27;</span>, <span class="string">&quot;sum_price&quot;</span>)</span><br><span class="line">   print(res)</span><br><span class="line">   </span><br><span class="line">   <span class="comment"># 5. 按照指定的字段分组，本质也是创造虚表</span></span><br><span class="line">   models.Book.objects.values(<span class="string">&#x27;price&#x27;</span>).annotate()</span><br></pre></td></tr></table></figure><h3 id="F与Q查询"><a href="#F与Q查询" class="headerlink" title="F与Q查询"></a>F与Q查询</h3><h4 id="F"><a href="#F" class="headerlink" title="F"></a>F</h4><ul><li>能够直接获取到表中某个字段对应的数据</li><li>F不能够直接操作字符串</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1. 查询卖出数大于库存数的书籍</span></span><br><span class="line">   <span class="keyword">from</span> django.db.models <span class="keyword">import</span> F</span><br><span class="line">   res = models.Book.objects.<span class="built_in">filter</span>(sale__gt=F(<span class="string">&#x27;store&#x27;</span>))</span><br><span class="line">   print(res)</span><br><span class="line"></span><br><span class="line">   <span class="comment"># 2. 将所有书籍的价格提升500块</span></span><br><span class="line">   models.Book.objects.update(price=F(<span class="string">&#x27;price&#x27;</span>) + <span class="number">500</span>)</span><br><span class="line"></span><br><span class="line">   <span class="comment"># 3. 将所有书的名称后面加上爆款两个字</span></span><br><span class="line">   <span class="comment"># 在操作字符类型的数据的时候，F不能够直接做到字符串的拼接</span></span><br><span class="line">   <span class="keyword">from</span> django.db.models.functions <span class="keyword">import</span> Concat</span><br><span class="line">   <span class="keyword">from</span> django.db.models <span class="keyword">import</span> Value</span><br><span class="line">   <span class="comment"># models.Book.objects.update(title=F(&#x27;title&#x27;) + &#x27;爆款&#x27;)  # 所有的名称会全部变成空白</span></span><br><span class="line">   models.Book.objects.update(title=Concat(F(<span class="string">&#x27;title&#x27;</span>), Value(<span class="string">&#x27;爆款&#x27;</span>)))</span><br></pre></td></tr></table></figure><h4 id="Q"><a href="#Q" class="headerlink" title="Q"></a>Q</h4><ul><li>扩展搜索表达式</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1.查询卖出数大于100或者价格小于600的书籍</span></span><br><span class="line"><span class="comment"># res = models.Book.objects.filter(maichu__gt=100,price__lt=600)  # filter括号内多个参数是and关系</span></span><br><span class="line"><span class="keyword">from</span> django.db.models <span class="keyword">import</span> Q</span><br><span class="line">res = models.Book.objects.<span class="built_in">filter</span>(Q(maichu__gt=<span class="number">100</span>), Q(price__lt=<span class="number">600</span>))  <span class="comment"># Q包裹逗号分割 还是and关系</span></span><br><span class="line">res = models.Book.objects.<span class="built_in">filter</span>(Q(maichu__gt=<span class="number">100</span>) | Q(price__lt=<span class="number">600</span>))  <span class="comment"># | or关系</span></span><br><span class="line">res = models.Book.objects.<span class="built_in">filter</span>(~Q(maichu__gt=<span class="number">100</span>) | Q(price__lt=<span class="number">600</span>))  <span class="comment"># ~ not关系</span></span><br><span class="line">print(res)  <span class="comment"># &lt;QuerySet []&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. Q的高阶用法，将查询条件的左边变成字符串形式</span></span><br><span class="line">q = Q()</span><br><span class="line">q.connector = <span class="string">&#x27;or&#x27;</span>  <span class="comment"># 默认是and关系</span></span><br><span class="line">q.children.append((<span class="string">&#x27;maichu__gt&#x27;</span>, <span class="number">100</span>))</span><br><span class="line">q.children.append((<span class="string">&#x27;price__lt&#x27;</span>, <span class="number">600</span>))</span><br><span class="line">res = models.Book.objects.<span class="built_in">filter</span>(q)</span><br><span class="line">print(res)</span><br></pre></td></tr></table></figure><h2 id="django中如何开启事务"><a href="#django中如何开启事务" class="headerlink" title="django中如何开启事务"></a>django中如何开启事务</h2><ul><li>ACID<ul><li>原子性<ul><li>不可分割的最小单位</li></ul></li><li>一致性<ul><li>跟原子性是相辅相成</li></ul></li><li>隔离性<ul><li>事务之间互相不干扰</li></ul></li><li>持久性<ul><li>事务一旦确认永久生效</li></ul></li></ul></li><li>事务的回滚 <ul><li>rollback</li></ul></li><li>事务的确认<ul><li>commit</li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Django中如何简单地开启事务</span></span><br><span class="line"><span class="keyword">from</span> django.db <span class="keyword">import</span> transaction</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="keyword">with</span> transaction.atomic():</span><br><span class="line">        <span class="comment"># sql1</span></span><br><span class="line">        <span class="comment"># sql2</span></span><br><span class="line">        ...</span><br><span class="line">        <span class="comment"># 在with代码快内书写的所有orm操作都是属于同一个事务</span></span><br><span class="line"><span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">    print(e)</span><br></pre></td></tr></table></figure><h2 id="orm字段及参数"><a href="#orm字段及参数" class="headerlink" title="orm字段及参数"></a>orm字段及参数</h2><h3 id="常用字段及参数"><a href="#常用字段及参数" class="headerlink" title="常用字段及参数"></a>常用字段及参数</h3><ol><li><p>AutoField：主键字段</p><ul><li>primary_key=True</li></ul><p>一般会自动创建，不需要手动设置</p></li><li><p>CharField：varchar</p><ul><li>verbose_name=字段的注释</li><li>max_length=长度</li><li>null=True可以为空</li><li>blank=True可以存空字符串（这两个有区别）</li><li>unique=True唯一</li></ul></li><li><p>IntegerField：int</p></li><li><p>BigIntegerField：bigint</p></li><li><p>DecimalField</p><ul><li>max_digits=允许的最大位数</li><li>decimal_places=小数的最大位数</li></ul></li><li><p>EmailFiled：varchar(254)</p></li><li><p>DateField：date</p><p>DateTimeField：datetime</p><ul><li>auto_now=每次修改数据时更新当前时间</li><li>auto_now_add=只在创建数据时记录当前时间</li></ul></li><li><p>BooleanField：Field</p><p>该字段传布尔值(False/True)，数据库里面存0/1</p></li><li><p>TextField：Field</p><p>该字段可以用来存大段内容(文章、博客…)，没有字数限制</p></li><li><p>FileField：Field</p><ul><li><p>upload_to = “/data/{file}”</p><p>给该字段传一个文件对象，会自动将文件保存到/data目录下，并将文件路径保存到数据库中</p></li></ul></li></ol><blockquote><p>更多字段，直接参考博客:<a href="https://www.cnblogs.com/Dominic-Ji/p/9203990.html%EF%BC%8C%E5%90%8E%E7%BB%AD%E8%A1%A5%E5%85%A8">https://www.cnblogs.com/Dominic-Ji/p/9203990.html，后续补全</a></p></blockquote><h3 id="自定义字段"><a href="#自定义字段" class="headerlink" title="自定义字段"></a>自定义字段</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 定义字段</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyCharField</span>(<span class="params">models.Field</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, max_length, *args, **kwargs</span>):</span></span><br><span class="line">        self.max_length = max_length</span><br><span class="line">        <span class="comment"># 调用父类的init方法</span></span><br><span class="line">        <span class="built_in">super</span>().__init__(max_length=max_length, *args, **kwargs)  <span class="comment"># 一定要是关键字的形式传入</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">db_type</span>(<span class="params">self, connection</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        返回真正的数据类型及各种约束条件</span></span><br><span class="line"><span class="string">        :param connection:</span></span><br><span class="line"><span class="string">        :return:</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;char(%s)&#x27;</span> % self.max_length</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 自定义字段使用</span></span><br><span class="line">myfield = MyCharField(max_length=<span class="number">16</span>, null=<span class="literal">True</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="外键字段及参数"><a href="#外键字段及参数" class="headerlink" title="外键字段及参数"></a>外键字段及参数</h3><ol><li><p>unique=True</p><p>ForeignKey(unique=True)等价于OneToOneField()</p></li><li><p>db_index=True</p><p>为此字段设置索引</p></li><li><p>to</p><p>设置要关联的表</p></li><li><p>to_field</p><p>设置要关联的表的字段，默认关联另外一张的主键字段，并且自动添加_id后缀</p></li><li><p>on_delete</p><p>当删除关联表中的数据时，当前表与其关联的行的行为。</p></li><li><p>related_name</p><p>反向查询使用的字段名，即代替 字段名__set</p></li><li><p>limit_choices_to</p><p>限制选择条件</p></li></ol><h2 id="数据库查询优化"><a href="#数据库查询优化" class="headerlink" title="数据库查询优化"></a>数据库查询优化</h2><h3 id="all"><a href="#all" class="headerlink" title="all()"></a>all()</h3><ul><li><p>orm语句的特点：惰性查询</p><p>如果仅仅只是书写了orm语句，在后面根本没有用到该语句所查询出来的参数，那么orm会自动识别，直接不执行。</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">res = models.Book.objects.<span class="built_in">all</span>()  <span class="comment"># 此时并没有查询数据库</span></span><br><span class="line">print(res)  <span class="comment"># 要用数据了才会走数据库</span></span><br></pre></td></tr></table></figure><h3 id="only"><a href="#only" class="headerlink" title="only()"></a>only()</h3><blockquote><p>只取目标字段</p></blockquote><ul><li>拿到数据对象，这些对象本身只有only中提到的字段参数</li><li>如果调用没有包含的字段，则会重新回到数据库查询</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 获取书籍表中所有书的名字</span></span><br><span class="line">res = models.Book.objects.values(<span class="string">&#x27;title&#x27;</span>)</span><br><span class="line"><span class="keyword">for</span> d <span class="keyword">in</span> res:</span><br><span class="line">    print(d.get(<span class="string">&#x27;title&#x27;</span>))</span><br><span class="line"><span class="comment"># 实现获取数据对象，点title就能够拿到书名，并且没有其他字段</span></span><br><span class="line">res = models.Book.objects.only(<span class="string">&#x27;title&#x27;</span>)</span><br><span class="line">print(res)  <span class="comment"># &lt;QuerySet [&lt;Book: 三国演义爆款&gt;, &lt;Book: 红楼梦爆款&gt;, &lt;Book: 论语爆款&gt;, &lt;Book: 聊斋爆款&gt;, &lt;Book: 老子爆款&gt;]&gt;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> res:</span><br><span class="line">    print(i.title)  <span class="comment"># 点only括号内的字段，不会走数据库</span></span><br><span class="line">    print(i.price)  <span class="comment"># 点only括号内没有的字段，会重新走数据库查询而all()不需要走了</span></span><br></pre></td></tr></table></figure><h3 id="defer"><a href="#defer" class="headerlink" title="defer()"></a>defer()</h3><ul><li>defer与only刚好相反</li><li>defer括号内放的字段不在查询出来的对象里面，查询该字段需要重新走数据库</li><li>而如果查询的是非括号内的字段，则不需要走数据库了</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">res = models.Book.objects.defer(<span class="string">&#x27;title&#x27;</span>)  <span class="comment"># 对象除了没有title属性之外其他的都有</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> res:</span><br><span class="line">    print(i.price)</span><br></pre></td></tr></table></figure><h3 id="select-related"><a href="#select-related" class="headerlink" title="select_related()"></a>select_related()</h3><blockquote><p>跨表操作</p></blockquote><ul><li><p>select_related内部先将book与publish连起来，然后一次性将大虚表的所有数据封装给查询出来的对象</p><p>这个时候对象无论是点击book表的数据还是publish表的数据都无需再走数据库查询了</p></li><li><p>select_related括号内只能放外键字段：一对多、一对一</p><p>不可以多对多</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">   res = models.Book.objects.<span class="built_in">all</span>()</span><br><span class="line">   <span class="keyword">for</span> i <span class="keyword">in</span> res:</span><br><span class="line">       print(i.publish.name)  <span class="comment"># 每循环一次就要走一次数据库查询</span></span><br><span class="line"></span><br><span class="line">   res = models.Book.objects.select_related(<span class="string">&#x27;authors&#x27;</span>)  <span class="comment"># INNER JOIN</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> res:</span><br><span class="line">       print(i.publish.name)  <span class="comment"># 每循环一次就要走一次数据库查询</span></span><br></pre></td></tr></table></figure><h3 id="prefetch-related"><a href="#prefetch-related" class="headerlink" title="prefetch_related()"></a>prefetch_related()</h3><ul><li><p>prefetch_related内部其实就是子查询</p><p>指把内部查询的结果作为外层查询的比较条件</p></li><li><p>两次查询，但不一定就比select_related差，要看实际情况</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">res = models.Book.objects.prefetch_related(<span class="string">&#x27;publish&#x27;</span>)  <span class="comment"># 子查询</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> res:</span><br><span class="line">    print(i.publish.name)</span><br></pre></td></tr></table></figure><h3 id="批量插入"><a href="#批量插入" class="headerlink" title="批量插入"></a>批量插入</h3><p>当批量插入数据的时候，使用orm的<code>bulk_create</code>方法能够大幅减少操作时间</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">ab_pl</span>(<span class="params">request</span>):</span></span><br><span class="line">    <span class="comment"># 1. 逐条插入</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10000</span>):</span><br><span class="line">        models.Book.objects.create(title=<span class="string">&#x27;第%s本书&#x27;</span> % i)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 2. 批量插入</span></span><br><span class="line">    book_list = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">100000</span>):</span><br><span class="line">        book_list.append(models.Book(title=<span class="string">&#x27;第%s本书&#x27;</span> % i))</span><br><span class="line">    models.Book.objects.bulk_create(book_list)</span><br><span class="line">    </span><br><span class="line">    book_queryset = models.Book.objects.<span class="built_in">all</span>()</span><br><span class="line">    <span class="keyword">return</span> render(request, <span class="string">&#x27;ab_pl.html&#x27;</span>, <span class="built_in">locals</span>())</span><br></pre></td></tr></table></figure><h3 id="分页器"><a href="#分页器" class="headerlink" title="分页器"></a>分页器</h3><p>减少同一时间的数据展示量</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">ab_pl</span>(<span class="params">request</span>):</span></span><br><span class="line">    <span class="comment"># 分页</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        cur_page = <span class="built_in">int</span>(request.GET.get(<span class="string">&#x27;cur_page&#x27;</span>, default=<span class="number">1</span>))  <span class="comment"># 如果获取不到当前页码，就展示第一页</span></span><br><span class="line">        per_page = <span class="built_in">int</span>(request.GET.get(<span class="string">&#x27;per_page&#x27;</span>, default=<span class="number">10</span>))  <span class="comment"># 每页展示多少条</span></span><br><span class="line">        start_page = <span class="built_in">int</span>((cur_page - <span class="number">1</span>) * per_page)  <span class="comment"># 起始位置</span></span><br><span class="line">        end_page = <span class="built_in">int</span>(cur_page * per_page)  <span class="comment"># 终止位置</span></span><br><span class="line">    <span class="keyword">except</span> Exception:</span><br><span class="line">        start_page = <span class="number">0</span></span><br><span class="line">        end_page = <span class="number">10</span></span><br><span class="line"></span><br><span class="line">    book_list = models.Book.objects.<span class="built_in">all</span>()</span><br><span class="line"></span><br><span class="line">    page_queryset = book_list[start_page:end_page]</span><br><span class="line">    response = serializers.serialize(<span class="string">&#x27;json&#x27;</span>, page_queryset)</span><br><span class="line">    <span class="keyword">return</span> HttpResponse(response)</span><br></pre></td></tr></table></figure><h2 id="choices参数"><a href="#choices参数" class="headerlink" title="choices参数"></a>choices参数</h2><ul><li>只要某个字段的内容是可以枚举完全的，则可以采用choices参数：<ul><li>学历</li><li>客户来源</li><li>……</li></ul></li><li>元组套元组</li><li>需要保证数据库表中字段类型跟key的数据类型一致</li><li>在数据库中存的是key，value在orm中</li><li>不存在的key直接输出key，存在的key可以通过<code>get_字段_display()</code>转换成value输出</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -&gt; models.py</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span>(<span class="params">models.Model</span>):</span></span><br><span class="line">    username = models.CharField(max_length=<span class="number">32</span>)</span><br><span class="line">    age = models.IntegerField()</span><br><span class="line">    <span class="comment"># 性别</span></span><br><span class="line">    gender_choices = ((<span class="number">1</span>, <span class="string">&#x27;男&#x27;</span>), (<span class="number">2</span>, <span class="string">&#x27;女&#x27;</span>))</span><br><span class="line">    gender = models.SmallIntegerField(choices=gender_choices)</span><br><span class="line"></span><br><span class="line">    score = models.CharField(choices=(</span><br><span class="line">        (<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;优秀&#x27;</span>),</span><br><span class="line">        (<span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;良好&#x27;</span>),</span><br><span class="line">        (<span class="string">&#x27;C&#x27;</span>, <span class="string">&#x27;及格&#x27;</span>),</span><br><span class="line">        (<span class="string">&#x27;D&#x27;</span>, <span class="string">&#x27;不合格&#x27;</span>),</span><br><span class="line">    ), null=<span class="literal">True</span>)  <span class="comment"># 保证字段类型跟列举出来的元组第一个数据类型一致</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># -&gt; test.py</span></span><br><span class="line">    <span class="comment"># 存的时候，没有列举出来的数字也能存，范围还是按照字段类型决定</span></span><br><span class="line">    models.User.objects.create(username=<span class="string">&#x27;jason&#x27;</span>, age=<span class="number">18</span>, gender=<span class="number">1</span>)</span><br><span class="line">    models.User.objects.create(username=<span class="string">&#x27;egon&#x27;</span>, age=<span class="number">85</span>, gender=<span class="number">2</span>)</span><br><span class="line">    models.User.objects.create(username=<span class="string">&#x27;tank&#x27;</span>, age=<span class="number">40</span>, gender=<span class="number">3</span>)</span><br><span class="line">    models.User.objects.create(username=<span class="string">&#x27;tony&#x27;</span>, age=<span class="number">45</span>, gender=<span class="number">4</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 取</span></span><br><span class="line">    user_obj = models.User.objects.<span class="built_in">filter</span>(pk=<span class="number">1</span>).first()</span><br><span class="line">    print(user_obj.gender)  <span class="comment"># 数据库中存储的key</span></span><br><span class="line">    print(user_obj.get_gender_display())  <span class="comment"># 对于choices参数的字段，通过get_字段名_display()获取对应的值</span></span><br><span class="line">    user_obj = models.User.objects.<span class="built_in">filter</span>(pk=<span class="number">4</span>).first()</span><br><span class="line">    print(user_obj.get_gender_display())  <span class="comment"># 如果没有对应关系，那么返回字段存储的原key</span></span><br></pre></td></tr></table></figure><h2 id="MTV与MVC模型"><a href="#MTV与MVC模型" class="headerlink" title="MTV与MVC模型"></a>MTV与MVC模型</h2><ul><li>MTV：Django号称是MTV模型<ul><li>M：models</li><li>T：templates</li><li>V：views</li></ul></li><li>MVC：其实django本质也是MVC<ul><li>M：models</li><li>V：views</li><li>C：controller</li></ul></li><li>vue框架：MVVM模型</li></ul><h2 id="多对多三种创建方式"><a href="#多对多三种创建方式" class="headerlink" title="多对多三种创建方式"></a>多对多三种创建方式</h2><h3 id="全自动"><a href="#全自动" class="headerlink" title="全自动"></a>全自动</h3><ul><li>利用orm自动帮我们创建第三张关系表</li><li>优点：<ul><li>不需要写代码，非常方便</li><li>支持orm提供操作第三张关系表的方法</li></ul></li><li>不足之处：<ul><li>第三张关系表的扩展性极差：没有办法额外添加字段</li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Book</span>(<span class="params">models.Model</span>):</span></span><br><span class="line">    name = models.CharField(max_length=<span class="number">32</span>)</span><br><span class="line">    authors = models.ManyToManyField(to=<span class="string">&#x27;Author&#x27;</span>)</span><br><span class="line">    </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Author</span>(<span class="params">models.Model</span>):</span></span><br><span class="line">    name = models.CharField(max_length=<span class="number">32</span>)</span><br><span class="line">    </span><br></pre></td></tr></table></figure><h3 id="纯手动"><a href="#纯手动" class="headerlink" title="纯手动"></a>纯手动</h3><ul><li>优点：<ul><li>第三张表完全取决于你自己进行额外的扩展</li></ul></li><li>不足之处：<ul><li>需要写的代码较多</li><li>不能够使用orm提供的简单方法</li></ul></li></ul><p>不建议使用该方式。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Book</span>(<span class="params">models.Model</span>):</span></span><br><span class="line">    name = models.CharField(max_length=<span class="number">32</span>)</span><br><span class="line">    </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Author</span>(<span class="params">models.Model</span>):</span></span><br><span class="line">    name = models.CharField(max_length=<span class="number">32</span>)</span><br><span class="line">  </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Book2Author</span>(<span class="params">models.Model</span>):</span></span><br><span class="line">    book_id = models.ForeignKey(to=<span class="string">&#x27;Book&#x27;</span>)</span><br><span class="line">    author_id = models.ForeignKey(to=<span class="string">&#x27;Author&#x27;</span>)</span><br><span class="line">    </span><br></pre></td></tr></table></figure><h3 id="半自动"><a href="#半自动" class="headerlink" title="半自动"></a>半自动</h3><ul><li>可以使用orm的正反向查询</li><li>但是没法使用add、set、remove、clear这四个方法</li><li>多对多表关系可以放在任何一方</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Book</span>(<span class="params">models.Model</span>):</span></span><br><span class="line">    name = models.CharField(max_length=<span class="number">32</span>)</span><br><span class="line">    authors = models.ManyToManyField(to=<span class="string">&#x27;Author&#x27;</span>,</span><br><span class="line">                                     through=<span class="string">&#x27;Book2Author&#x27;</span>,</span><br><span class="line">                                     through_fields=(<span class="string">&#x27;book&#x27;</span>,<span class="string">&#x27;author&#x27;</span>)</span><br><span class="line">                                     )  <span class="comment"># 将当前表名放在元组第一位</span></span><br><span class="line">    </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Author</span>(<span class="params">models.Model</span>):</span></span><br><span class="line">    name = models.CharField(max_length=<span class="number">32</span>)</span><br><span class="line">    <span class="comment"># books = models.ManyToManyField(to=&#x27;Book&#x27;,</span></span><br><span class="line">    <span class="comment">#                                  through=&#x27;Book2Author&#x27;,</span></span><br><span class="line">    <span class="comment">#                                  through_fields=(&#x27;author&#x27;, &#x27;book&#x27;)</span></span><br><span class="line">    <span class="comment">#                                  )</span></span><br><span class="line">    </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Book2Author</span>(<span class="params">models.Model</span>):</span></span><br><span class="line">    book = models.ForeignKey(to=<span class="string">&#x27;Book&#x27;</span>)  <span class="comment"># 外键默认加id，这里不要加，包括through_fields</span></span><br><span class="line">    author = models.ForeignKey(to=<span class="string">&#x27;Author&#x27;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Django </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Django-Part3</title>
      <link href="/2021/08/Django-Part3/"/>
      <url>/2021/08/Django-Part3/</url>
      
        <content type="html"><![CDATA[<h1 id="Django-Part3——视图层"><a href="#Django-Part3——视图层" class="headerlink" title="Django-Part3——视图层"></a>Django-Part3——视图层</h1><p>[TOC]</p><h2 id="三板斧"><a href="#三板斧" class="headerlink" title="三板斧"></a>三板斧</h2><h3 id="HttpResponse"><a href="#HttpResponse" class="headerlink" title="HttpResponse"></a>HttpResponse</h3><ul><li>HttpResponse：返回字符串类型</li><li>render：返回html页面，并且在返回给浏览器之前还可以给html文件传值</li><li>redirect：重定向</li></ul><blockquote><p>视图函数必须要返回一个HttpResponse对象</p></blockquote><h3 id="render"><a href="#render" class="headerlink" title="render"></a>render</h3><ul><li>返回html文件</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test</span>(<span class="params">request</span>):</span></span><br><span class="line">    <span class="keyword">from</span> django.template <span class="keyword">import</span> Template, Context</span><br><span class="line">    res = Template(<span class="string">&#x27;&lt;h1&gt;&#123;&#123; user &#125;&#125;&lt;/h1&gt;&#x27;</span>)  <span class="comment"># 模板对象</span></span><br><span class="line">    con = Context(&#123;<span class="string">&#x27;user&#x27;</span>: &#123;<span class="string">&#x27;username&#x27;</span>: <span class="string">&#x27;jason&#x27;</span>, <span class="string">&#x27;password&#x27;</span>: <span class="number">123</span>&#125;&#125;)  <span class="comment"># 动态确定模板变量的内容，此处是&#123;&#x27;username&#x27;:&#x27;jason&#x27;, &#x27;password&#x27;:123&#125;</span></span><br><span class="line">    ret = res.render(con)  <span class="comment"># 将模板和动态内容组装</span></span><br><span class="line">    print(ret)  <span class="comment"># &lt;h1&gt;&#123;&amp;#x27;username&amp;#x27;: &amp;#x27;jason&amp;#x27;, &amp;#x27;password&amp;#x27;: 123&#125;&lt;/h1&gt;</span></span><br><span class="line">    print(<span class="built_in">type</span>(ret))  <span class="comment"># &lt;class &#x27;django.utils.safestring.SafeString&#x27;&gt;</span></span><br><span class="line">    <span class="keyword">return</span> HttpResponse(ret)</span><br></pre></td></tr></table></figure><h3 id="redirect"><a href="#redirect" class="headerlink" title="redirect"></a>redirect</h3><ul><li><p>重定向至任意网站<br><code>return redirect(&#39;https://www.mzitu.com/&#39;)</code></p></li><li><p>跳转本站不需要加https</p><p><code>return redirect(&#39;/home/&#39;)</code> </p></li></ul><h2 id="JsonResponse"><a href="#JsonResponse" class="headerlink" title="JsonResponse"></a>JsonResponse</h2><ul><li>前后端数据交互需要使用json作为过渡，实现跨语言传输数据。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">ab_json</span>(<span class="params">request</span>):</span></span><br><span class="line">    user_dict = &#123;<span class="string">&#x27;username&#x27;</span>: <span class="string">&#x27;jason好帅哦,我好喜欢!&#x27;</span>, <span class="string">&#x27;password&#x27;</span>: <span class="string">&#x27;123&#x27;</span>, <span class="string">&#x27;hobby&#x27;</span>: <span class="string">&#x27;girl&#x27;</span>&#125;</span><br><span class="line">    l = [<span class="number">111</span>,<span class="number">222</span>,<span class="number">333</span>,<span class="number">444</span>,<span class="number">555</span>]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># import json  # 先转成json格式字符串</span></span><br><span class="line">    <span class="comment"># json_str = json.dumps(user_dict, ensure_ascii=False)  # 禁止内部转码</span></span><br><span class="line">    <span class="comment"># return HttpResponse(json_str)  # 将该字符串作为参数，返回HttpResponse对象</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">from</span> django.http <span class="keyword">import</span> JsonResponse</span><br><span class="line">    <span class="keyword">return</span> JsonResponse(user_dict, json_dumps_params=&#123;<span class="string">&quot;ensure_ascii&quot;</span>: <span class="literal">False</span>&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 报错：In order to allow non-dict objects to be serialized set the safe parameter to False.</span></span><br><span class="line">    <span class="comment"># return JsonResponse(l, safe=False)  </span></span><br></pre></td></tr></table></figure><ul><li>指将字典打散成关键字的形式</li><li>默认只能序列化字典，序列化其他需要加safe参数</li></ul><blockquote><p>很多时候都可以通过读源码来掌握用法</p></blockquote><h2 id="上传文件与后端操作"><a href="#上传文件与后端操作" class="headerlink" title="上传文件与后端操作"></a>上传文件与后端操作</h2><h3 id="使用form表单上传"><a href="#使用form表单上传" class="headerlink" title="使用form表单上传"></a>使用form表单上传</h3><p>在 .html 中：</p><ol><li>method 必须指定成 post</li><li>enctype 必须换成 multipart/formdata</li></ol><h3 id="使用requests模块上传"><a href="#使用requests模块上传" class="headerlink" title="使用requests模块上传"></a>使用requests模块上传</h3><ul><li>Requests 使得上传多部分编码文件变得很简单 </li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>url = <span class="string">&#x27;http://httpbin.org/post&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>files = &#123;<span class="string">&#x27;file&#x27;</span>: <span class="built_in">open</span>(<span class="string">&#x27;report.xls&#x27;</span>, <span class="string">&#x27;rb&#x27;</span>)&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>r = requests.post(url, files=files)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>r.text</span><br><span class="line">&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="string">&quot;files&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;file&quot;</span>: <span class="string">&quot;&lt;censored...binary...data&gt;&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>你可以显式地设置文件名，文件类型和请求头</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>url = <span class="string">&#x27;http://httpbin.org/post&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>files = &#123;<span class="string">&#x27;file&#x27;</span>: (<span class="string">&#x27;report.xls&#x27;</span>, <span class="built_in">open</span>(<span class="string">&#x27;report.xls&#x27;</span>, <span class="string">&#x27;rb&#x27;</span>), <span class="string">&#x27;application/vnd.ms-excel&#x27;</span>, &#123;<span class="string">&#x27;Expires&#x27;</span>: <span class="string">&#x27;0&#x27;</span>&#125;)&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>r = requests.post(url, files=files)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>r.text</span><br><span class="line">&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="string">&quot;files&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;file&quot;</span>: <span class="string">&quot;&lt;censored...binary...data&gt;&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>也可以发送作为文件来接收的字符串</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>url = <span class="string">&#x27;http://httpbin.org/post&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>files = &#123;<span class="string">&#x27;file&#x27;</span>: (<span class="string">&#x27;report.csv&#x27;</span>, <span class="string">&#x27;some,data,to,send\nanother,row,to,send\n&#x27;</span>)&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>r = requests.post(url, files=files)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>r.text</span><br><span class="line">&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="string">&quot;files&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;file&quot;</span>: <span class="string">&quot;some,data,to,send\\nanother,row,to,send\\n&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>把多个文件组织到一个元组的列表中，其中元组结构为 (form_field_name, file_info)</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">data = &#123;<span class="string">&#x27;ts_id&#x27;</span>: tsid&#125;</span><br><span class="line">files = [(<span class="string">&#x27;images&#x27;</span>, (<span class="string">&#x27;1.png&#x27;</span>, <span class="built_in">open</span>(<span class="string">&#x27;/home/1.png&#x27;</span>, <span class="string">&#x27;rb&#x27;</span>), <span class="string">&#x27;image/png&#x27;</span>)),</span><br><span class="line">         (<span class="string">&#x27;images&#x27;</span>, (<span class="string">&#x27;2.png&#x27;</span>, <span class="built_in">open</span>(<span class="string">&#x27;/home/2.png&#x27;</span>, <span class="string">&#x27;rb&#x27;</span>), <span class="string">&#x27;image/png&#x27;</span>))]</span><br><span class="line">r = requests.post(url, data=data, files=files)</span><br><span class="line"><span class="built_in">print</span> r.text</span><br></pre></td></tr></table></figure><h3 id="使用request接收文件"><a href="#使用request接收文件" class="headerlink" title="使用request接收文件"></a>使用request接收文件</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">ab_file</span>(<span class="params">request</span>):</span></span><br><span class="line">    <span class="keyword">if</span> request.method == <span class="string">&#x27;POST&#x27;</span>:</span><br><span class="line">        print(request.POST)  <span class="comment"># 只能获取普通的键值对数据，文件不行 &lt;QueryDict: &#123;&#x27;username&#x27;: [&#x27;&#x27;]&#125;&gt;</span></span><br><span class="line">        print(request.FILES)  <span class="comment"># 获取文件数据 &lt;MultiValueDict: &#123;&#x27;file&#x27;: [&lt;InMemoryUploadedFile: 4101021694766.jpg (image/jpeg)&gt;]&#125;&gt;</span></span><br><span class="line">        file_obj = request.FILES.get(<span class="string">&#x27;file&#x27;</span>)  <span class="comment"># 获取文件对象</span></span><br><span class="line">        print(file_obj.name)  <span class="comment"># 4101021694766.jpg</span></span><br><span class="line">        <span class="keyword">with</span> <span class="built_in">open</span>(file_obj.name, <span class="string">&#x27;wb&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">            <span class="keyword">for</span> line <span class="keyword">in</span> file_obj.chunks():  <span class="comment"># 推荐加上chunks方法，两者几乎等效</span></span><br><span class="line">                f.write(line)</span><br><span class="line">    <span class="keyword">return</span> render(request,<span class="string">&#x27;form.html&#x27;</span>)</span><br></pre></td></tr></table></figure><ul><li>接收保存多个文件</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> werkzeug.utils <span class="keyword">import</span> secure_filename</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">upload_file</span>(<span class="params">request</span>):</span></span><br><span class="line">    <span class="keyword">if</span> request.method == <span class="string">&#x27;POST&#x27;</span>:</span><br><span class="line">        uploaded_files = request.FILES.getlist(<span class="string">&quot;images&quot;</span>)  <span class="comment"># 获取相同标签</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="keyword">for</span> file_obj <span class="keyword">in</span> uploaded_files:</span><br><span class="line">                file_name = secure_filename(file_obj.name)</span><br><span class="line">                handle_uploaded_file(os.path.join(file_name), file_obj)</span><br><span class="line">            result_json = &#123;<span class="string">&quot;msg&quot;</span>: <span class="string">&quot;success&quot;</span>&#125;</span><br><span class="line">        <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">            result_json = &#123;<span class="string">&quot;msg&quot;</span>: <span class="built_in">str</span>(e)&#125;</span><br><span class="line">        <span class="keyword">return</span> JsonResponse(result_json, safe=<span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">handle_uploaded_file</span>(<span class="params">file_name, file_obj</span>):</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">with</span> <span class="built_in">open</span>(file_name, <span class="string">&#x27;wb&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">            <span class="keyword">for</span> chunk <span class="keyword">in</span> file_obj.chunks():</span><br><span class="line">                f.write(chunk)</span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">        <span class="keyword">raise</span> Exception(<span class="string">&#x27;save %s failed: %s&#x27;</span> % (file_name, <span class="built_in">str</span>(e)))</span><br></pre></td></tr></table></figure><h2 id="request对象方法"><a href="#request对象方法" class="headerlink" title="request对象方法"></a>request对象方法</h2><ul><li><code>get</code>请求携带的数据是有大小限制的，而<code>post</code>请求则没有限制。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">login</span>(<span class="params">request</span>):</span></span><br><span class="line">    <span class="comment"># 视图函数必须要接受一个形参request</span></span><br><span class="line">    <span class="keyword">if</span> request.method == <span class="string">&#x27;POST&#x27;</span>:  <span class="comment"># 返回请求方式 并且是全大写的字符串形式  &lt;class &#x27;str&#x27;&gt;</span></span><br><span class="line">        <span class="keyword">return</span> HttpResponse(<span class="string">&quot;收到了 宝贝&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> render(request, <span class="string">&#x27;login.html&#x27;</span>)</span><br></pre></td></tr></table></figure><blockquote><ul><li>对于<code>get</code>请求和<code>post</code>请求应该有不同的处理机制</li><li>对<code>post</code>做特殊处理，而将<code>request</code>放置在<code>if</code>围绕之外，提高可阅读性</li></ul></blockquote><ol><li><code>request.method</code>：返回请求方式，并且是全大写的字符串形式  &lt;class ‘str’&gt;</li><li><code>request.POST</code>：获取用户post请求提交的普通数据不包含文件</li><li><code>request.POST.get()</code>：只获取列表最后一个元素</li><li><code>request.POST.getlist()</code>：直接将列表取出</li><li><code>request.GET</code>：获取用户提交的get请求数据</li><li><code>request.GET.get()</code>：只获取列表最后一个元素</li><li><code>request.GET.getlist()</code>：直接将列表取出</li><li><code>request.FILES.get()</code>：用键取出对应的文件，是以字典形式封装好的</li><li><code>request.body</code>：发过来的原生二进制数据</li><li><code>request.path_info</code>：获取url(例如<code>/app01/ab_file/</code>)，和request.path是等效的</li><li><code>request.get_full_path()</code>：获取完整的url及问号后面的参数 </li></ol><blockquote><p>可以使用以下装饰器来指定请求类型：</p><ol><li>@require_http_methods([“GET”])</li><li>@require_http_methods([“POST”])</li></ol></blockquote><h2 id="FBV与CBV"><a href="#FBV与CBV" class="headerlink" title="FBV与CBV"></a>FBV与CBV</h2><p>视图函数既可以是 函数 FBV（function base views），也可以是 类 CBV（class base views）。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># FBV</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span>(<span class="params">request</span>):</span></span><br><span class="line"><span class="keyword">return</span> HttpResponse(<span class="string">&#x27;index&#x27;</span>)</span><br><span class="line"><span class="comment"># FBV路由</span></span><br><span class="line">path(<span class="string">&quot;login/&quot;</span>, views.login)</span><br><span class="line"></span><br><span class="line"><span class="comment"># CBV</span></span><br><span class="line"><span class="keyword">from</span> django.views <span class="keyword">import</span> View</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyLogin</span>(<span class="params">View</span>):</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get</span>(<span class="params">self,request</span>):</span></span><br><span class="line"><span class="keyword">return</span> render(request, <span class="string">&#x27;form.html&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">post</span>(<span class="params">self,request</span>):</span></span><br><span class="line">        <span class="keyword">return</span> HttpResponse(<span class="string">&#x27;post方法&#x27;</span>)</span><br><span class="line"><span class="comment"># CBV路由</span></span><br><span class="line">url(<span class="string">r&#x27;^login/&#x27;</span>, views.MyLogin.as_view())</span><br></pre></td></tr></table></figure><h3 id="CBV源码剖析"><a href="#CBV源码剖析" class="headerlink" title="CBV源码剖析"></a>CBV源码剖析</h3><ul><li>首先，不建议自己修改源码</li><li>函数名/方法名，加括号执行优先级最高，例如views.MyLogin.as_view()会立刻执行as_view()方法</li><li>CBV与FBV在路由匹配上本质是一样的，都是路由对应函数内存地址。</li><li>在没有实例的情况下使用函数，则只可能使用@staicmethod或者@classmethod</li><li>在看python源码的时候，一定要时刻提醒自己面向对象属性方法查找顺序：<ul><li>先从对象自己找</li><li>再去产生对象的类里面找</li><li>之后再去父类找</li><li>…</li></ul></li><li>反射 getattr()</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 突破口在urls.py</span></span><br><span class="line">url(<span class="string">r&#x27;^login/&#x27;</span>, views.MyLogin.as_view())</span><br><span class="line">url(<span class="string">r&#x27;^login/&#x27;</span>, views.view)</span><br><span class="line"><span class="comment"># CBV与FBV在路由匹配上本质是一样的，都是路由对应函数内存地址</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">函数名/方法名 加括号执行优先级最高</span></span><br><span class="line"><span class="string">猜测：</span></span><br><span class="line"><span class="string">    as_view()</span></span><br><span class="line"><span class="string">        要么是被@staicmethod修饰的静态方法</span></span><br><span class="line"><span class="string">        要么是被@classmethod修饰的类方法  正确</span></span><br><span class="line"><span class="string">        </span></span><br><span class="line"><span class="string">    @classonlymethod</span></span><br><span class="line"><span class="string">    def as_view(cls, **initkwargs):</span></span><br><span class="line"><span class="string">        pass</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @classonlymethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">as_view</span>(<span class="params">cls, **initkwargs</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        cls就是我们自己写的类   MyCBV</span></span><br><span class="line"><span class="string">        Main entry point for a request-response process.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">view</span>(<span class="params">request, *args, **kwargs</span>):</span></span><br><span class="line">            self = cls(**initkwargs)  <span class="comment"># cls是我们自己写的类</span></span><br><span class="line">            <span class="comment"># self = MyLogin(**initkwargs)  产生一个我们自己写的类的对象</span></span><br><span class="line">            <span class="keyword">return</span> self.dispatch(request, *args, **kwargs)</span><br><span class="line">            <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">            以后你们会经常需要看源码 但是在看python源码的时候 一定要时刻提醒自己面向对象属性方法查找顺序</span></span><br><span class="line"><span class="string">                先从对象自己找</span></span><br><span class="line"><span class="string">                再去产生对象的类里面找</span></span><br><span class="line"><span class="string">                之后再去父类找</span></span><br><span class="line"><span class="string">                ...</span></span><br><span class="line"><span class="string">            总结:看源码只要看到了self点一个东西，一定要问你自己当前这个self到底是谁</span></span><br><span class="line"><span class="string">            &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> view</span><br><span class="line">      </span><br><span class="line"><span class="comment"># CBV的精髓</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dispatch</span>(<span class="params">self, request, *args, **kwargs</span>):</span></span><br><span class="line">        <span class="comment"># 获取当前请求的小写格式 然后比对当前请求方式是否合法</span></span><br><span class="line">        <span class="comment"># get请求为例</span></span><br><span class="line">        <span class="comment"># post请求</span></span><br><span class="line">        <span class="keyword">if</span> request.method.lower() <span class="keyword">in</span> self.http_method_names:</span><br><span class="line">            handler = <span class="built_in">getattr</span>(self, request.method.lower(), self.http_method_not_allowed)</span><br><span class="line">            <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">            反射:通过字符串来操作对象的属性或者方法</span></span><br><span class="line"><span class="string">                handler = getattr(自己写的类产生的对象, &#x27;get&#x27;,当找不到get属性或者方法的时候就会用第三个参数)</span></span><br><span class="line"><span class="string">                handler = 我们自己写的类里面的get方法</span></span><br><span class="line"><span class="string">            &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            handler = self.http_method_not_allowed</span><br><span class="line">        <span class="keyword">return</span> handler(request, *args, **kwargs)  <span class="comment"># 调用get方法</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 要求掌握到不看源码也能够描述出CBV的内部执行流程</span></span><br></pre></td></tr></table></figure><h2 id="模版语法"><a href="#模版语法" class="headerlink" title="模版语法"></a>模版语法</h2><p>Django 模板语法个人不打算使用，故不记录。</p>]]></content>
      
      
      <categories>
          
          <category> Django </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Django-Part2</title>
      <link href="/2021/08/Django-Part2/"/>
      <url>/2021/08/Django-Part2/</url>
      
        <content type="html"><![CDATA[<h1 id="Django-Part2——路由层"><a href="#Django-Part2——路由层" class="headerlink" title="Django-Part2——路由层"></a>Django-Part2——路由层</h1><p>[TOC]</p><h2 id="Django请求生命周期流程图-重点"><a href="#Django请求生命周期流程图-重点" class="headerlink" title="Django请求生命周期流程图(重点)"></a>Django请求生命周期流程图(重点)</h2><ul><li>wsgiref模块能够支持的并发量很小，上线之后换成uwsgi</li><li>wsgi、wsgiref、uwsgi之间的关系<ul><li>wsgi是协议</li><li>wsgiref和uwsgi是实现该协议的功能模块</li></ul></li></ul><p><img src="/2021/08/Django-Part2/202011130830231.png" alt="202011130830231.png"></p><h2 id="路由匹配"><a href="#路由匹配" class="headerlink" title="路由匹配"></a>路由匹配</h2><h3 id="path-re-path-与url"><a href="#path-re-path-与url" class="headerlink" title="path()/re_path()与url()"></a>path()/re_path()与url()</h3><ul><li>匹配顺序从上到下，只要能够匹配到内容，那么就会立刻停止往下匹配。</li><li>2.x之后的<code>re_path()</code>与1.x的<code>url()</code>是等价的，推荐使用新版本的方法，方法名更加容易辨别意思。</li><li><code>re_path()</code>的第一个参数是正则表达式，一旦匹配到了，则进入响应的视图函数并停止匹配。</li><li><code>path()</code>的第一个参数是路径，只有完全匹配时才会执行对应的视图函数。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.contrib <span class="keyword">import</span> admin</span><br><span class="line"><span class="keyword">from</span> django.urls <span class="keyword">import</span> path</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> app01 <span class="keyword">import</span> views</span><br><span class="line"></span><br><span class="line">urlpatterns = [</span><br><span class="line">    path(<span class="string">&#x27;admin/&#x27;</span>, admin.site.urls),</span><br><span class="line">    path(<span class="string">r&#x27;test/&#x27;</span>, views.test),</span><br><span class="line">    path(<span class="string">r&#x27;testadd/&#x27;</span>, views.testadd)</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> django.urls <span class="keyword">import</span> re_path</span><br><span class="line"></span><br><span class="line">urlpatterns = [</span><br><span class="line">    <span class="comment"># 首页</span></span><br><span class="line">    re_path(<span class="string">r&#x27;^$&#x27;</span>,views.home),</span><br><span class="line">    <span class="comment"># 路由匹配</span></span><br><span class="line">    re_path(<span class="string">r&#x27;^test/$&#x27;</span>,views.test),  <span class="comment"># 和path(r&#x27;test/&#x27;, views.test)等效</span></span><br><span class="line">    re_path(<span class="string">r&#x27;^testadd/$&#x27;</span>, views.testadd),</span><br><span class="line">    <span class="comment"># 尾页(但这种写法失去了重定向)</span></span><br><span class="line">    re_path(<span class="string">r&#x27;&#x27;</span>,views.error),</span><br><span class="line">]</span><br></pre></td></tr></table></figure><ul><li>在访问url时会以输入的原url进行一次匹配。当匹配失败时，会在原url上添加后缀<code>/</code>，再次进行一次匹配。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 取消自动加斜杠，默认为True</span></span><br><span class="line">APPEND_SLASH = <span class="literal">False</span></span><br></pre></td></tr></table></figure><h3 id="无名分组"><a href="#无名分组" class="headerlink" title="无名分组"></a>无名分组</h3><ul><li>无名分组就是将括号内正则表达式匹配到的内容当作位置参数传递给后面的视图函数</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -&gt; urls.py</span></span><br><span class="line">re_path(<span class="string">r&#x27;^test/(\d+)/&#x27;</span>, views.test)</span><br><span class="line"></span><br><span class="line"><span class="comment"># -&gt; views.py</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test</span>(<span class="params">request, xx</span>):</span></span><br><span class="line">    print(xx)</span><br><span class="line">    <span class="keyword">return</span> HttpResponse(<span class="string">&#x27;test&#x27;</span>)</span><br></pre></td></tr></table></figure><h3 id="有名分组"><a href="#有名分组" class="headerlink" title="有名分组"></a>有名分组</h3><ul><li>有名分组就是将括号内正则表达式匹配到的内容当作关键字参数传递给后面的视图函数</li><li>需要有一个对应的形参来接收</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -&gt; urls.py</span></span><br><span class="line">re_path(<span class="string">r&#x27;^testadd/(?P&lt;year&gt;\d+)&#x27;</span>, views.testadd)</span><br><span class="line"></span><br><span class="line"><span class="comment"># -&gt; views.py</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">testadd</span>(<span class="params">request, year</span>):</span></span><br><span class="line">    print(year)</span><br><span class="line">    <span class="keyword">return</span> HttpResponse(<span class="string">&#x27;testadd&#x27;</span>)</span><br></pre></td></tr></table></figure><h3 id="无名有名是否可以混合使用"><a href="#无名有名是否可以混合使用" class="headerlink" title="无名有名是否可以混合使用"></a>无名有名是否可以混合使用</h3><ul><li>不能混用无名、有名分组</li><li>但是只使用一种分组时可以使用多次/传多个形参</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -&gt; urls.py</span></span><br><span class="line">re_path(<span class="string">r&#x27;^index/(\d+)/(\d+)/(\d+)/&#x27;</span>, views.index),</span><br><span class="line">re_path(<span class="string">r&#x27;^index/(?P&lt;year&gt;\d+)/(?P&lt;age&gt;\d+)/(?P&lt;month&gt;\d+)/&#x27;</span>, views.index)</span><br><span class="line"></span><br><span class="line"><span class="comment"># -&gt; views.py</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">testadd</span>(<span class="params">request, *args, **kwargs</span>):</span></span><br><span class="line">    print(args, kwargs)</span><br><span class="line">    <span class="keyword">return</span> HttpResponse(<span class="string">&#x27;testadd&#x27;</span>)</span><br></pre></td></tr></table></figure><h2 id="反向解析"><a href="#反向解析" class="headerlink" title="反向解析"></a>反向解析</h2><h3 id="别名"><a href="#别名" class="headerlink" title="别名"></a>别名</h3><ul><li>通过一些方法得到一个结果 该结果可以直接访问对应的url触发视图函数</li></ul><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -&gt; urls.py</span></span><br><span class="line"><span class="comment"># 给路由与视图函数起一个别名</span></span><br><span class="line">re_path(<span class="string">r&#x27;^urls/&#x27;</span>, views.func, name=<span class="string">&#x27;name&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># -&gt; views.py</span></span><br><span class="line"><span class="comment"># 后端反向解析</span></span><br><span class="line"><span class="keyword">from</span> django.shortcuts <span class="keyword">import</span> reverse</span><br><span class="line">reverse(<span class="string">&#x27;name&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># -&gt; xxx.html</span></span><br><span class="line"><span class="comment"># 前端反向解析</span></span><br><span class="line">&lt;a href=&quot;&#123;% url &#x27;name&#x27; %&#125;&quot;&gt;string&lt;/a&gt;</span><br></pre></td></tr></table></figure><h3 id="无名分组反向解析"><a href="#无名分组反向解析" class="headerlink" title="无名分组反向解析"></a>无名分组反向解析</h3><blockquote><p>分组的解析值一般就是数据的主键值。</p></blockquote><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -&gt; urls.py</span></span><br><span class="line"><span class="comment"># 无名分组反向解析</span></span><br><span class="line">re_path(<span class="string">r&#x27;^edit/(\d+)/&#x27;</span>, views.edit, name=<span class="string">&#x27;xxx&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># -&gt; views.py</span></span><br><span class="line"><span class="comment"># 后端</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">edit</span>(<span class="params">request, edit_id</span>):</span></span><br><span class="line">    reverse(<span class="string">&#x27;xxx&#x27;</span>, args=(edit_id, ))</span><br><span class="line"></span><br><span class="line"><span class="comment"># -&gt; xxx.html   </span></span><br><span class="line"><span class="comment"># 前端</span></span><br><span class="line">&lt;a href=&quot;&#123;% url &#x27;xxx&#x27; user_obj.id %&#125;&quot;&gt;编辑&lt;/a&gt;</span><br></pre></td></tr></table></figure><h3 id="有名分组反向解析"><a href="#有名分组反向解析" class="headerlink" title="有名分组反向解析"></a>有名分组反向解析</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -&gt; urls.py</span></span><br><span class="line"><span class="comment"># 有名分组反向解析</span></span><br><span class="line">re_path(<span class="string">r&#x27;^func/(?P&lt;year&gt;\d+)/&#x27;</span>, views.func, name=<span class="string">&#x27;ooo&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># -&gt; views.py</span></span><br><span class="line"><span class="comment"># 后端</span></span><br><span class="line"><span class="comment"># 有名分组反向解析</span></span><br><span class="line">print(reverse(<span class="string">&#x27;ooo&#x27;</span>, kwargs=&#123;<span class="string">&#x27;year&#x27;</span>:<span class="number">123</span>&#125;))</span><br><span class="line"><span class="comment"># 简便的写法，和无名一样</span></span><br><span class="line">print(reverse(<span class="string">&#x27;ooo&#x27;</span>, args=(<span class="number">111</span>,)))</span><br><span class="line"></span><br><span class="line"><span class="comment"># -&gt; xxx.html   </span></span><br><span class="line"><span class="comment"># 前端</span></span><br><span class="line">&lt;a href=&quot;&#123;% url &#x27;ooo&#x27; year=123 %&#125;&quot;&gt;111&lt;/a&gt;  # 了解</span><br><span class="line">&lt;a href=&quot;&#123;% url &#x27;ooo&#x27; 123 %&#125;&quot;&gt;222&lt;/a&gt;  # 记忆</span><br></pre></td></tr></table></figure><h3 id="如何理解分组反向解析"><a href="#如何理解分组反向解析" class="headerlink" title="如何理解分组反向解析"></a>如何理解分组反向解析</h3><ul><li>分组是基于正则表达式匹配url，即不同的url能够进入相同的视图函数，多存在于 <code>https://xxx/id/</code> 类似，这部分会在id不同时发生变化。</li><li>反向解析基于别名，在.html和.py中动态获得 <code>https://xxx/id/</code> 的xxx部分，这部分可能会在重构url地址时发生变化。</li><li>分组反向解析则是通过上述两条结合，动态地获得 <code>https://xxx/id/</code> 这条有很多种可能的url，以方便进入相应的视图函数。</li><li>分组的解析值一般就是数据的主键值，相当于是在视图函数中增加形参，来代替在request中获取的部分数据。</li></ul><h2 id="路由分发"><a href="#路由分发" class="headerlink" title="路由分发"></a>路由分发</h2><h3 id="include"><a href="#include" class="headerlink" title="include()"></a>include()</h3><ul><li>django的每一个应用都可以有自己的templates、urls.py、static（需要自己新建）。这样能够很好地做到分组开发，最终利用路由分发进行整合。</li><li>当django项目中的url特别多的时候，总路由urls.py代码非常冗余不好维护，这时也可以利用路由分发来减轻总路由的压力。</li><li>使用路由分发之后，总路由不再将url与视图函数直接对应，而是识别分类当前url所属应用，并分发给对应的应用去处理。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 总路由</span></span><br><span class="line"><span class="keyword">from</span> django.urls <span class="keyword">import</span> include, re_path</span><br><span class="line"><span class="comment"># from app01 import urls as app01_urls</span></span><br><span class="line"><span class="comment"># from app02 import urls as app02_urls</span></span><br><span class="line"></span><br><span class="line">urlpatterns = [</span><br><span class="line">    re_path(<span class="string">r&#x27;^admin/&#x27;</span>, admin.site.urls),</span><br><span class="line">    <span class="comment"># 路由分发</span></span><br><span class="line">    <span class="comment"># url(r&#x27;^app01/&#x27;, include(app01_urls)),  # 只要url前缀是app01开头，全部交给app01处理</span></span><br><span class="line">    <span class="comment"># url(r&#x27;^app02/&#x27;, include(app02_urls))   # 只要url前缀是app02开头，全部交给app02处理</span></span><br><span class="line">    <span class="comment"># 推荐写法</span></span><br><span class="line">    re_path(<span class="string">r&#x27;^app01/&#x27;</span>, include(<span class="string">&#x27;app01.urls&#x27;</span>)),</span><br><span class="line">    re_path(<span class="string">r&#x27;^app02/&#x27;</span>, include(<span class="string">&#x27;app02.urls&#x27;</span>))</span><br><span class="line">    <span class="comment"># 注意事项: 总路由里面的url千万不能加$结尾</span></span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 子路由</span></span><br><span class="line"><span class="comment"># -&gt; app01 -&gt; urls.py</span></span><br><span class="line"><span class="keyword">from</span> django.urls <span class="keyword">import</span> include, re_path</span><br><span class="line"><span class="keyword">from</span> app01 <span class="keyword">import</span> views</span><br><span class="line"></span><br><span class="line">urlpatterns = [</span><br><span class="line">re_path(<span class="string">r&#x27;^reg/&#x27;</span>, views.reg)</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="comment"># -&gt; app02 -&gt; urls.py</span></span><br><span class="line"><span class="keyword">from</span> django.urls <span class="keyword">import</span> include, re_path</span><br><span class="line"><span class="keyword">from</span> app02 <span class="keyword">import</span> views</span><br><span class="line"></span><br><span class="line">urlpatterns = [</span><br><span class="line">re_path(<span class="string">r&#x27;^reg/&#x27;</span>, views.reg)</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h3 id="名称空间"><a href="#名称空间" class="headerlink" title="名称空间"></a>名称空间</h3><ul><li>当多个应用出现了相同的别名，反向解析只能识别后缀而不能识别前缀，例如 <code>https://app/xxx/</code> </li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 总路由 </span></span><br><span class="line"><span class="comment"># -&gt; urls.py</span></span><br><span class="line">urlpatterns = [</span><br><span class="line">    re_path(<span class="string">r&#x27;^app01/&#x27;</span>, include(<span class="string">&#x27;app01.urls&#x27;</span>, namespace=<span class="string">&#x27;app01&#x27;</span>))，</span><br><span class="line">re_path(<span class="string">r&#x27;^app02/&#x27;</span>, include(<span class="string">&#x27;app02.urls&#x27;</span>, namespace=<span class="string">&#x27;app02&#x27;</span>))</span><br><span class="line">]</span><br><span class="line"><span class="comment"># 子路由</span></span><br><span class="line"><span class="comment"># -&gt; app01 -&gt; urls.py</span></span><br><span class="line">urlpatterns = [</span><br><span class="line">    re_path(<span class="string">r&#x27;^reg/&#x27;</span>, views.reg, name=<span class="string">&#x27;reg&#x27;</span>)</span><br><span class="line">]</span><br><span class="line"><span class="comment"># -&gt; app02 -&gt; urls.py</span></span><br><span class="line">urlpatterns = [</span><br><span class="line">    re_path(<span class="string">r&#x27;^reg/&#x27;</span>, views.reg, name=<span class="string">&#x27;reg&#x27;</span>)</span><br><span class="line">]</span><br><span class="line">    </span><br><span class="line"><span class="comment"># 反向解析</span></span><br><span class="line"><span class="comment"># -&gt; views.py</span></span><br><span class="line">reverse(<span class="string">&#x27;app01:reg&#x27;</span>)</span><br><span class="line">reverse(<span class="string">&#x27;app02:reg&#x27;</span>)</span><br><span class="line"><span class="comment"># -&gt; .html</span></span><br><span class="line">&#123;% url <span class="string">&#x27;app01:reg&#x27;</span> %&#125;</span><br><span class="line">&#123;% url <span class="string">&#x27;app02:reg&#x27;</span> %&#125;</span><br></pre></td></tr></table></figure><ul><li>利用名称空间可以区分不同app的相同别名，但一般只需要在别名之前添加所属应用作为前缀，就大可不必使用名称空间。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -&gt; urls.py</span></span><br><span class="line">urlpatterns = [</span><br><span class="line">    re_path(<span class="string">r&#x27;^reg/&#x27;</span>, views.reg, name=<span class="string">&#x27;app01_reg&#x27;</span>)</span><br><span class="line">]</span><br><span class="line">urlpatterns = [</span><br><span class="line">    re_path(<span class="string">r&#x27;^reg/&#x27;</span>, views.reg, name=<span class="string">&#x27;app02_reg&#x27;</span>)</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h2 id="伪静态"><a href="#伪静态" class="headerlink" title="伪静态"></a>伪静态</h2><ul><li>静态网页：数据是写死的 万年不变</li><li>伪静态：将一个动态网页伪装成静态网页</li><li>伪装的目的：<ul><li>增大本网站的seo查询力度</li><li>增加搜索引擎收藏本网上的概率</li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 仅将url地址改为.html结尾，假装只是返回html文件，实际上还是经过视图函数，可以做动态处理</span></span><br><span class="line">urlpatterns = [</span><br><span class="line">    re_path(<span class="string">r&#x27;^reg.html&#x27;</span>, views.reg, name=<span class="string">&#x27;app02_reg&#x27;</span>)</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h2 id="虚拟环境"><a href="#虚拟环境" class="headerlink" title="虚拟环境"></a>虚拟环境</h2><ul><li>在正常开发中，通常每一个项目配备一个独有的解释器环境，只有该项目用到的模块，用不到一概不装。</li><li>但是较多的虚拟环境会消耗更多的硬盘空间。</li><li>一般通过requirement.txt来标识项目的虚拟环境需要的模块。</li></ul><h2 id="path-转换器"><a href="#path-转换器" class="headerlink" title="path()转换器"></a>path()转换器</h2><ol><li>str：匹配除了路径分隔符<code>/</code>之外的非空字符串，这是默认的形式</li><li>int：匹配正整数，包含0。</li><li>slug：匹配字母、数字以及横杠、下划线组成的字符串。</li><li>uuid：匹配格式化的uuid，如：075194d3-6885-417e-a8a8-6c931e272f00。</li><li>path：匹配任何非空字符串，包含了路径分隔符（/）</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -&gt; urls.py</span></span><br><span class="line"><span class="comment"># 将匹配内容转成相应类型，作为形参传递给后面的视图函数</span></span><br><span class="line">path(<span class="string">&#x27;index/&lt;int:id&gt;/&#x27;</span>, index)</span><br><span class="line"></span><br><span class="line"><span class="comment"># -&gt; views.py</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span>(<span class="params">request,<span class="built_in">id</span></span>):</span></span><br><span class="line">    print(<span class="built_in">id</span>, <span class="built_in">type</span>(<span class="built_in">id</span>))</span><br><span class="line">    <span class="keyword">return</span> HttpResponse(<span class="string">&#x27;index&#x27;</span>)</span><br></pre></td></tr></table></figure><ol start="6"><li>自定义转换器</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -&gt; path_converts.py</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MonthConverter</span>:</span></span><br><span class="line">    regex=<span class="string">&#x27;\d&#123;2&#125;&#x27;</span>  <span class="comment"># 属性名必须为regex</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">to_python</span>(<span class="params">self, value</span>):</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">int</span>(value)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">to_url</span>(<span class="params">self, value</span>):</span></span><br><span class="line">        <span class="keyword">return</span> value  <span class="comment"># 匹配的regex是两个数字，返回的结果也必须是两个数字</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># -&gt; urls.py</span></span><br><span class="line"><span class="keyword">from</span> django.urls <span class="keyword">import</span> path, register_converter</span><br><span class="line"><span class="keyword">from</span> path_converts <span class="keyword">import</span> MonthConverter</span><br><span class="line"><span class="keyword">from</span> app01 <span class="keyword">import</span> views</span><br><span class="line"></span><br><span class="line"><span class="comment"># 先注册转换器</span></span><br><span class="line">register_converter(MonthConverter, <span class="string">&#x27;mon&#x27;</span>)</span><br><span class="line"></span><br><span class="line">urlpatterns = [</span><br><span class="line">    path(<span class="string">&#x27;articles/&lt;int:year&gt;/&lt;mon:month&gt;/&lt;slug:other&gt;/&#x27;</span>, views.article_detail, name=<span class="string">&#x27;aaa&#x27;</span>),</span><br><span class="line">]</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Django </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Django-Part1</title>
      <link href="/2021/08/Django-Part1/"/>
      <url>/2021/08/Django-Part1/</url>
      
        <content type="html"><![CDATA[<h1 id="Django-Part1——基础操作"><a href="#Django-Part1——基础操作" class="headerlink" title="Django-Part1——基础操作"></a>Django-Part1——基础操作</h1><p>[TOC]</p><h2 id="后端"><a href="#后端" class="headerlink" title="后端"></a>后端</h2><blockquote><p>后端很重要，每个领域的知识都应该学，要做一个全能型人才</p></blockquote><h2 id="软件开发架构"><a href="#软件开发架构" class="headerlink" title="软件开发架构"></a>软件开发架构</h2><ul><li>cs架构(Client/Server)  建立在局域网的基础上</li><li>bs架构(Browser/Server)  建立在广域网的基础上</li></ul><p>bs本质也是cs</p><h2 id="HTTP协议"><a href="#HTTP协议" class="headerlink" title="HTTP协议"></a>HTTP协议</h2><h3 id="网络协议"><a href="#网络协议" class="headerlink" title="网络协议"></a>网络协议</h3><ol><li>HTTP协议              数据传输是明文</li><li>HTTPS协议             数据传输是密文</li><li>websocket协议      数据传输是密文</li></ol><h3 id="四大特性"><a href="#四大特性" class="headerlink" title="四大特性"></a>四大特性</h3><ol><li>基于请求响应</li><li>基于TCP、IP作用于应用层之上的协议</li><li>无状态</li><li>短/无链接</li></ol><h3 id="数据格式"><a href="#数据格式" class="headerlink" title="数据格式"></a>数据格式</h3><ol><li>请求首行</li><li>请求头</li><li>请求体</li></ol><h3 id="响应状态码"><a href="#响应状态码" class="headerlink" title="响应状态码"></a>响应状态码</h3><ul><li>1xx：指示信息–表示请求已接收，继续处理。</li><li>2xx：成功–表示请求已被成功接收、理解、接受。</li><li>3xx：重定向–要完成请求必须进行更进一步的操作。</li><li>4xx：客户端错误–请求有语法错误或请求无法实现。</li><li>5xx：服务器端错误–服务器未能实现合法的请求。</li></ul><p><a href="https://zhuanlan.zhihu.com/p/53165474">响应状态码大全</a></p><h2 id="wsgiref模块"><a href="#wsgiref模块" class="headerlink" title="wsgiref模块"></a>wsgiref模块</h2><h3 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h3><ol><li>urls.py                        路由与视图函数对应关系</li><li>views.py                    视图函数(后端业务逻辑)</li><li>templates文件夹        专门用来存储html文件</li></ol><p>按照功能的不同拆分之后，后续添加功能只需要在<code>urls.py</code>注册对应关系然后在<code>views.py</code>书写业务逻辑即可</p><h3 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h3><ol><li>请求来的时候解析http格式的数据，封装成大字典</li><li>响应走的时候给数据打包成符合http格式，再返回给浏览器</li></ol><h2 id="动静态网页"><a href="#动静态网页" class="headerlink" title="动静态网页"></a>动静态网页</h2><ul><li><p>静态网页</p><ul><li>页面上的数据是直接写死的，万年不变</li></ul></li><li><p>动态网页</p><ul><li>页面框架不变，而数据是实时获取的</li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 动态网页制作</span></span><br><span class="line"><span class="keyword">import</span> datetime</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_time</span>(<span class="params">env</span>):</span></span><br><span class="line">    <span class="comment"># 动态获取当前时间，即每次获取的都不固定</span></span><br><span class="line">    current_time = datetime.datetime.now().strftime(<span class="string">&#x27;%Y-%m-%d %X&#x27;</span>)</span><br><span class="line">    <span class="comment"># 将后端获取到的数据传递给html文件</span></span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">r&#x27;templates/03 mytime.html&#x27;</span>,<span class="string">&#x27;r&#x27;</span>,encoding=<span class="string">&#x27;utf-8&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        <span class="comment"># data就是一堆字符串</span></span><br><span class="line">        data = f.read()</span><br><span class="line">    <span class="comment"># 在后端将html页面处理好之后再返回给前端</span></span><br><span class="line">    data = data.replace(<span class="string">&#x27;dwadasdsadsadasdas&#x27;</span>,current_time)  </span><br><span class="line">    <span class="comment"># 返回带有动态数据的html页面</span></span><br><span class="line">    <span class="keyword">return</span> data</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将一个字典传递给html文件，更加方便快捷的操作字典数据</span></span><br><span class="line"><span class="keyword">from</span> jinja2 <span class="keyword">import</span> Template</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_dict</span>(<span class="params">env</span>):</span></span><br><span class="line">    user_dic = &#123;<span class="string">&#x27;username&#x27;</span>:<span class="string">&#x27;jason&#x27;</span>,<span class="string">&#x27;age&#x27;</span>:<span class="number">18</span>,<span class="string">&#x27;hobby&#x27;</span>:<span class="string">&#x27;read&#x27;</span>&#125;</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">r&#x27;templates/04 get_dict.html&#x27;</span>,<span class="string">&#x27;r&#x27;</span>,encoding=<span class="string">&#x27;utf-8&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        data = f.read()</span><br><span class="line">    tmp = Template(data)</span><br><span class="line">    res = tmp.render(user=user_dic)</span><br><span class="line">    <span class="comment"># 给get_dict.html传递了一个值 页面上通过变量名user就能够拿到user_dict</span></span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="模版语法之Jinja2模块"><a href="#模版语法之Jinja2模块" class="headerlink" title="模版语法之Jinja2模块"></a>模版语法之Jinja2模块</h3><blockquote><p>模版语法仅在后端服务器上起作用</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"># 模版语法(非常贴近python语法)</span><br><span class="line">&#123;&#123; user &#125;&#125;</span><br><span class="line">&#123;&#123; user.get(&#x27;username&#x27;)&#125;&#125;</span><br><span class="line">&#123;&#123; user.age &#125;&#125;</span><br><span class="line">&#123;&#123; user[&#x27;hobby&#x27;] &#125;&#125;</span><br><span class="line"></span><br><span class="line"># 循环</span><br><span class="line">&#123;% for user_dict in user_list %&#125;</span><br><span class="line">                        <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">td</span>&gt;</span>&#123;&#123; user_dict.id&#125;&#125;<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">td</span>&gt;</span>&#123;&#123; user_dict.username&#125;&#125;<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">td</span>&gt;</span>&#123;&#123; user_dict.password&#125;&#125;<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">td</span>&gt;</span>&#123;&#123; user_dict.hobby&#125;&#125;<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">&#123;% endfor%&#125;</span><br></pre></td></tr></table></figure><h2 id="Python三大主流web框架"><a href="#Python三大主流web框架" class="headerlink" title="Python三大主流web框架"></a>Python三大主流web框架</h2><ol><li><p>django</p><ul><li>特点：大而全，自带的功能特别多</li><li>不足之处：有时候过于笨重</li><li>组成：<ul><li>socket部分用的是别人的：wsgiref模块</li><li>路由匹配用的是自己的</li><li>模版语法用的是自己的(没有jinja2好用 但是也很方便)</li></ul></li></ul></li><li><p>flask</p><ul><li>特点：小而精，自带的功能特别少。但第三方的模块特别多，如果将flask第三方的模块加起来完全可以盖过django，并且也越来越像django</li><li>不足之处：比较依赖于第三方的开发者，可能不兼容        </li><li>组成：<ul><li>socket部分用的是别人的：werkzeug(内部还是wsgiref模块)</li><li>路由匹配用的是自己的</li><li>模版语法用的是别人的：jinja2</li></ul></li></ul></li><li><p>tornado</p><ul><li>特点：异步非阻塞，支持高并发，甚至可以开发游戏服务器</li><li>组成：<ul><li>socket部分用的是自己的</li><li>路由匹配用的是自己的</li><li>模版语法用的是自己的</li></ul></li></ul></li></ol><h2 id="开始Django"><a href="#开始Django" class="headerlink" title="开始Django"></a>开始Django</h2><h3 id="如何让你的计算机能够正常的启动django项目"><a href="#如何让你的计算机能够正常的启动django项目" class="headerlink" title="如何让你的计算机能够正常的启动django项目"></a>如何让你的计算机能够正常的启动django项目</h3><ol><li>计算机的名称不能是中文</li><li>一个pycharm窗口只开一个django项目</li><li>项目里面所有的文件也尽量不要出现中文</li><li>python解释器尽量使用3.4~3.6之间的版本(如果依然报错，点击最后一个报错信息，在源码中把逗号删掉)</li></ol><h3 id="django安装"><a href="#django安装" class="headerlink" title="django安装"></a>django安装</h3><ul><li>如果已经安装了其他版本，可以<code>pip install django==xx.xx.xx</code>自动卸载安装新的版本</li><li>在mac终端可以输入django-admin验证安装成功</li></ul><h2 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h2><h3 id="命令行操作"><a href="#命令行操作" class="headerlink" title="命令行操作"></a>命令行操作</h3><ol><li><p>切换到指定目录，创建django项目<br><code>django-admin startproject mysite</code></p></li><li><p>启动django项目</p><p><code>cd /mysite</code></p><p><code>python3 manage.py runserver</code></p></li><li><p>创建应用</p><p><code>python manage.py startapp app01</code></p></li></ol><blockquote><p>使用命令行创建项目时一定要记得配置templates路径，建议使用pycharm创建</p></blockquote><h3 id="pycharm操作"><a href="#pycharm操作" class="headerlink" title="pycharm操作"></a>pycharm操作</h3><ol><li><p>new project -&gt; django</p></li><li><p>启动django项目</p><p>命令行 或者 绿色箭头运行</p></li><li><p>创建应用</p><p>命令行 或者 tools -&gt; run manage.py task -&gt; start app02(有提示，前期不要用，背完整命令)</p></li><li><p>修改端口号以及创建server</p><p>edit -&gt; config</p></li></ol><h3 id="命令行与pycharm创建的区别"><a href="#命令行与pycharm创建的区别" class="headerlink" title="命令行与pycharm创建的区别"></a>命令行与pycharm创建的区别</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1 命令行创建django项目时,不仅要创建templates文件夹，还需要自己在setting.py中配置路径。</span></span><br><span class="line"><span class="comment"># -&gt; settings.py</span></span><br><span class="line"><span class="comment"># pycharm创建</span></span><br><span class="line">TEMPLATES = [</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">&#x27;BACKEND&#x27;</span>: <span class="string">&#x27;django.template.backends.django.DjangoTemplates&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;DIRS&#x27;</span>: [os.path.join(BASE_DIR, <span class="string">&#x27;templates&#x27;</span>)]</span><br><span class="line">]</span><br><span class="line"><span class="comment"># 命令行创建</span></span><br><span class="line">TEMPLATES = [</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">&#x27;BACKEND&#x27;</span>: <span class="string">&#x27;django.template.backends.django.DjangoTemplates&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;DIRS&#x27;</span>: [],</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h3 id="更快捷的Django命令"><a href="#更快捷的Django命令" class="headerlink" title="更快捷的Django命令"></a>更快捷的Django命令</h3><ul><li>这里的命令将拥有代码提示</li></ul><p><img src="/2021/08/Django-Part1/Django-Part1%5Cimage-20210615221710342.png?lastModify=1628778347" alt="image-20210615221710342"></p><h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><p>django是一款专门用来开发app的web框架。</p><p>而这里的app指的是一种具体的功能模块。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">INSTALLED_APPS = [</span><br><span class="line">    <span class="string">&#x27;django.contrib.admin&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;django.contrib.auth&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;django.contrib.contenttypes&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;django.contrib.sessions&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;django.contrib.messages&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;django.contrib.staticfiles&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;app01.apps.App01Config&#x27;</span>,<span class="comment"># 全写</span></span><br><span class="line">  <span class="string">&#x27;app01&#x27;</span>, <span class="comment"># 简写</span></span><br><span class="line">]</span><br></pre></td></tr></table></figure><blockquote><p>创建出来的的应用第一步一定要先去settings.py中注册</p></blockquote><h2 id="工程文件介绍"><a href="#工程文件介绍" class="headerlink" title="工程文件介绍"></a>工程文件介绍</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">-mysite项目文件夹</span><br><span class="line">  --manage.pydjango的入口文件</span><br><span class="line">  --db.sqlite3django自带的sqlite3数据库(不用)</span><br><span class="line">  --mysite文件夹</span><br><span class="line">  ---settings.py    配置文件</span><br><span class="line">    ---urls.py路由与视图函数对应关系(路由层)</span><br><span class="line">    ---wsgi.pywsgiref模块(不考虑)</span><br><span class="line">  --app01文件夹</span><br><span class="line">  ---admin.pydjango后台管理</span><br><span class="line">    ---apps.py注册使用</span><br><span class="line">    ---migrations文件夹  数据库迁移记录</span><br><span class="line">    ---models.py数据库相关的 模型类(orm)</span><br><span class="line">  ---tests.py测试文件</span><br><span class="line">    ---views.py视图函数(视图层)</span><br></pre></td></tr></table></figure><h2 id="静态文件配置"><a href="#静态文件配置" class="headerlink" title="静态文件配置"></a>静态文件配置</h2><h3 id="Templates"><a href="#Templates" class="headerlink" title="Templates"></a>Templates</h3><ul><li>将html文件默认都放在 Templates文件夹下</li></ul><h3 id="Static"><a href="#Static" class="headerlink" title="Static"></a>Static</h3><ul><li>将网站所使用的静态文件放在Static文件夹下</li></ul><p>这里的静态文件指前端已经写好了的，能够直接调用的文件。包括 js、css、.jpg、第三方前端框架等。</p><blockquote><p>Django不会自动创建static文件夹，需要手动创建</p></blockquote><h3 id="访问静态文件"><a href="#访问静态文件" class="headerlink" title="访问静态文件"></a>访问静态文件</h3><blockquote><p>如果访问不到资源，则一定说明后端没有开设该资源的接口。</p></blockquote><p>在写django项目的时候，可能会出现后端代码修改了，但是前端页面没有变化的情况。那么可能原因有：</p><ol><li><p>在同一个端口开了好几个django项目，而一直在跑的其实是第一个django项目</p></li><li><p>浏览器缓存的问题。勾选 settings -&gt; network -&gt; disable cache </p></li></ol><h3 id="静态文件访问令牌"><a href="#静态文件访问令牌" class="headerlink" title="静态文件访问令牌"></a>静态文件访问令牌</h3><p>想要调用静态文件，则文件地址必须以 令牌(<code>STATIC_URL</code>) + 文件名 形式。</p><p>然后将在 <code>STATICFILES_DIRS</code> 注册的文件夹列表中从上往下依次<strong>非递归</strong>查找。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -&gt; settings.py</span></span><br><span class="line">STATIC_URL = <span class="string">&#x27;/static/&#x27;</span>  <span class="comment"># 访问静态文件的令牌</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 需要自己创建STATICFILES_DIRS，配置静态文件所在文件夹</span></span><br><span class="line">STATICFILES_DIRS = [</span><br><span class="line">    os.path.join(BASE_DIR,<span class="string">&#x27;static&#x27;</span>),</span><br><span class="line">    os.path.join(BASE_DIR,<span class="string">&#x27;static1&#x27;</span>)</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>同时也可以动态解析令牌</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 静态文件动态解析</span></span><br><span class="line">    &#123;% load static %&#125;</span><br><span class="line">    &lt;link rel=<span class="string">&quot;stylesheet&quot;</span> href=<span class="string">&quot;&#123;% static &#x27;bootstrap-3.3.7-dist/css/bootstrap.min.css&#x27; %&#125;&quot;</span>&gt;</span><br><span class="line">    &lt;script src=&quot;&#123;% static &#x27;bootstrap-3.3.7-dist/js/bootstrap.min.js&#x27; %&#125;&quot;&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>在前期使用django提交post请求时，需要在settings中注释掉一行代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -&gt; settings.py</span></span><br><span class="line">MIDDLEWARE = [</span><br><span class="line">    <span class="string">&#x27;django.middleware.security.SecurityMiddleware&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;django.contrib.sessions.middleware.SessionMiddleware&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;django.middleware.common.CommonMiddleware&#x27;</span>,</span><br><span class="line">    <span class="comment"># &#x27;django.middleware.csrf.CsrfViewMiddleware&#x27;,  # 表示django全局发送post请求均需要字符串验证</span></span><br><span class="line">    <span class="string">&#x27;django.contrib.auth.middleware.AuthenticationMiddleware&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;django.contrib.messages.middleware.MessageMiddleware&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;django.middleware.clickjacking.XFrameOptionsMiddleware&#x27;</span>,</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h2 id="数据库链接"><a href="#数据库链接" class="headerlink" title="数据库链接"></a>数据库链接</h2><h3 id="Pycharm链接数据库"><a href="#Pycharm链接数据库" class="headerlink" title="Pycharm链接数据库"></a>Pycharm链接数据库</h3><ul><li>需要提前创建好对应使用的mysql数据库文件</li><li>pycharm右侧上方database</li></ul><h3 id="Django链接数据库"><a href="#Django链接数据库" class="headerlink" title="Django链接数据库"></a>Django链接数据库</h3><ol><li>Django默认使用sqlite3，首先改settings</li><li>Django默认使用mysqldb，需要改为pymysql</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -&gt; settings.py</span></span><br><span class="line">DATABASES = &#123;</span><br><span class="line">    <span class="string">&#x27;default&#x27;</span>: &#123;</span><br><span class="line">        <span class="string">&#x27;ENGINE&#x27;</span>: <span class="string">&#x27;django.db.backends.mysql&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;NAME&#x27;</span>: <span class="string">&#x27;day60&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;USER&#x27;</span>: <span class="string">&#x27;root&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;PASSWORD&#x27;</span>:<span class="string">&#x27;admin123&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;HOST&#x27;</span>:<span class="string">&#x27;127.0.0.1&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;PORT&#x27;</span>: <span class="number">3306</span>,</span><br><span class="line">        <span class="string">&#x27;CHARSET&#x27;</span>: <span class="string">&#x27;utf8&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># -&gt; 在项目名下或任意应用名下的init文件</span></span><br><span class="line"><span class="keyword">import</span> pymysql</span><br><span class="line"></span><br><span class="line">pymysql.install_as_MySQLdb()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Django </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>爬虫-完结目录</title>
      <link href="/2021/06/%E7%88%AC%E8%99%AB-%E5%AE%8C%E7%BB%93%E7%9B%AE%E5%BD%95/"/>
      <url>/2021/06/%E7%88%AC%E8%99%AB-%E5%AE%8C%E7%BB%93%E7%9B%AE%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<h1 id="爬虫——完结目录"><a href="#爬虫——完结目录" class="headerlink" title="爬虫——完结目录"></a>爬虫——完结目录</h1><p>教程视频传送门：</p><ol><li><a href="https://www.bilibili.com/video/BV1i54y1h75W?p=1">2021年最新Python爬虫教程+实战项目案例（最新录制）</a></li></ol><p>讲的非常好，只要跟着耐心做一遍就能整明白，很清晰。</p><table><thead><tr><th align="center"><a href="/2021/05/%E7%88%AC%E8%99%ABPart1/">爬虫Part1——原理与request入门</a></th></tr></thead><tbody><tr><td align="center"><strong><a href="/2021/05/%E7%88%AC%E8%99%ABPart2/">爬虫Part2——数据解析与提取</a></strong></td></tr><tr><td align="center"><strong><a href="/2021/06/%E7%88%AC%E8%99%ABPart3/">爬虫Part3——Requests进阶</a></strong></td></tr><tr><td align="center"><strong><a href="/2021/06/%E7%88%AC%E8%99%ABPart4/">爬虫Part4——异步爬虫</a></strong></td></tr><tr><td align="center"><strong><a href="/2021/06/%E7%88%AC%E8%99%ABPart5/">爬虫Part5——Selenuim</a></strong></td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 爬虫 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> crawler </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>爬虫Part5</title>
      <link href="/2021/06/%E7%88%AC%E8%99%ABPart5/"/>
      <url>/2021/06/%E7%88%AC%E8%99%ABPart5/</url>
      
        <content type="html"><![CDATA[<h1 id="爬虫Part5——Selenuim"><a href="#爬虫Part5——Selenuim" class="headerlink" title="爬虫Part5——Selenuim"></a>爬虫Part5——Selenuim</h1><p>[TOC]</p><h2 id="Selenuim简介"><a href="#Selenuim简介" class="headerlink" title="Selenuim简介"></a>Selenuim简介</h2><ul><li><p>有些网页的响应内容经过复杂的加密，通过手动调试解密已经非常地狱，所以可以尝试直接获取浏览器运行后的结果。</p></li><li><p>selenium本体是自动化测试工具，控制浏览器操作。</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"></span><br><span class="line">url = <span class="string">&quot;https://www.baidu.com&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 下载的文件名是msedgedriver.exe，默认启动为MicrosoftWebDriver.exe，修正一下文件名就可以不用给.Edge()传文件名参数了</span></span><br><span class="line">driver = webdriver.Edge()  <span class="comment"># 必须用已经在python路径中的driver启动</span></span><br><span class="line">driver.get(url)  <span class="comment"># 打开某个网址</span></span><br><span class="line"></span><br><span class="line">print(driver.title)  <span class="comment"># 百度一下，你就知道</span></span><br></pre></td></tr></table></figure><ul><li>使用selenium需要：1. <code>pip install selenium</code> 2. 下载对应版本的浏览器driver并放在python根目录下</li><li><code>.get()</code>打开某个网址</li></ul><h2 id="拉钩"><a href="#拉钩" class="headerlink" title="拉钩"></a>拉钩</h2><h3 id="元素获取与事件处理"><a href="#元素获取与事件处理" class="headerlink" title="元素获取与事件处理"></a>元素获取与事件处理</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium.webdriver <span class="keyword">import</span> Edge</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.common.keys <span class="keyword">import</span> Keys</span><br><span class="line"></span><br><span class="line">url = <span class="string">&quot;http://lagou.com&quot;</span></span><br><span class="line"></span><br><span class="line">driver = Edge()</span><br><span class="line">driver.get(url)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 用选择工具找到 &#x27;//*[@id=&quot;changeCityBox&quot;]/p[1]/a&#x27; 或者下面都是可以的</span></span><br><span class="line">ele = driver.find_element_by_xpath(<span class="string">&#x27;//*[@id=&quot;changeCityBox&quot;]/p[1]/a/i&#x27;</span>)</span><br><span class="line">ele.click()</span><br><span class="line"></span><br><span class="line">driver.find_element_by_xpath(<span class="string">&#x27;//*[@id=&quot;search_input&quot;]&#x27;</span>).send_keys(<span class="string">&quot;python&quot;</span>, Keys.ENTER)</span><br><span class="line"></span><br><span class="line">li_list = driver.find_elements_by_xpath(<span class="string">&#x27;//*[@id=&quot;s_position_list&quot;]/ul/li&#x27;</span>)</span><br><span class="line"><span class="keyword">for</span> li <span class="keyword">in</span> li_list:</span><br><span class="line">    job_name = li.find_element_by_tag_name(<span class="string">&quot;h3&quot;</span>).text</span><br><span class="line">    job_price = li.find_element_by_xpath(<span class="string">&quot;./div/div/div[2]/div/span&quot;</span>).text</span><br><span class="line">    company_name = li.find_element_by_xpath(<span class="string">&#x27;./div/div[2]/div/a&#x27;</span>).text</span><br><span class="line">    print(company_name, job_name, job_price)</span><br></pre></td></tr></table></figure><ul><li><code>find_element_by_xpath() </code>获取元素对象</li><li><code>.click()</code> 使元素对象产生点击事件</li><li><code>.send_keys() </code>使元素对象填入文本</li><li><code>.text </code>获取元素内的文本</li></ul><h3 id="切换窗口与跳转frame"><a href="#切换窗口与跳转frame" class="headerlink" title="切换窗口与跳转frame"></a>切换窗口与跳转frame</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium.webdriver <span class="keyword">import</span> Edge</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.common.keys <span class="keyword">import</span> Keys</span><br><span class="line"></span><br><span class="line">web = Edge()</span><br><span class="line"></span><br><span class="line">web.get(<span class="string">&quot;http://lagou.com&quot;</span>)</span><br><span class="line">web.find_element_by_xpath(<span class="string">&#x27;//*[@id=&quot;changeCityBox&quot;]/p[1]/a/i&#x27;</span>).click()</span><br><span class="line">web.find_element_by_xpath(<span class="string">&#x27;//*[@id=&quot;search_input&quot;]&#x27;</span>).send_keys(<span class="string">&quot;python&quot;</span>, Keys.ENTER)</span><br><span class="line">web.find_element_by_xpath(<span class="string">&#x27;//*[@id=&quot;s_position_list&quot;]/ul/li[1]/div[1]/div[1]/div[1]/a/h3&#x27;</span>).click()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 1. 在selenium的眼中，新窗口默认是不切换过来的，需要手动切换</span></span><br><span class="line">web.switch_to.window(web.window_handles[-<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在新窗口中提取内容</span></span><br><span class="line">job_detail = web.find_element_by_xpath(<span class="string">&#x27;//*[@id=&quot;job_detail&quot;]/dd[2]/div&#x27;</span>).text</span><br><span class="line">print(job_detail)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 关掉子窗口，或者返回上一页面</span></span><br><span class="line">web.close()</span><br><span class="line"><span class="comment"># web.back()</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 变更selenium的窗口视角，回到原来的窗口中</span></span><br><span class="line">web.switch_to.window(web.window_handles[<span class="number">0</span>])</span><br><span class="line">print(web.find_element_by_xpath(<span class="string">&#x27;//*[@id=&quot;s_position_list&quot;]/ul/li[1]/div[1]/div[1]/div[1]/a/h3&#x27;</span>).text)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 跳转进入iframe</span></span><br><span class="line">web.get(<span class="string">&quot;https://www.91kanju.com/vod-play/541-2-1.html&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 先拿到iframe</span></span><br><span class="line">iframe = web.find_element_by_xpath(<span class="string">&#x27;//*[@id=&quot;player_iframe&quot;]&#x27;</span>)</span><br><span class="line"><span class="comment"># 切换到iframe</span></span><br><span class="line">web.switch_to.frame(iframe)</span><br><span class="line"><span class="comment"># 拿到数据</span></span><br><span class="line">tx = web.find_element_by_xpath(<span class="string">&#x27;//*[@id=&quot;main&quot;]/h3[1]&#x27;</span>).text</span><br><span class="line">print(tx)</span><br><span class="line">web.switch_to.default_content()  <span class="comment"># 切换回原页面</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li><code>switch_to.window(web.window_handles[-1])</code> 切换到最后一个标签</li><li><code>.close()</code> 关闭标签</li><li><code>.back()</code> 返回当前标签的上一页面</li><li><code>switch_to.frame(iframe) </code>切换到内嵌的html中</li></ul><h2 id="艺恩"><a href="#艺恩" class="headerlink" title="艺恩"></a>艺恩</h2><h3 id="无头浏览器"><a href="#无头浏览器" class="headerlink" title="无头浏览器"></a>无头浏览器</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium.webdriver <span class="keyword">import</span> Edge</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="comment"># 准备好参数配置</span></span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.support.select <span class="keyword">import</span> Select</span><br><span class="line"></span><br><span class="line">opt = &#123;</span><br><span class="line">    <span class="comment"># 这里是默认的</span></span><br><span class="line">    <span class="string">&quot;browserName&quot;</span>: <span class="string">&quot;MicrosoftEdge&quot;</span>,</span><br><span class="line">    <span class="string">&quot;version&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">    <span class="string">&quot;platform&quot;</span>: <span class="string">&quot;WINDOWS&quot;</span>,</span><br><span class="line">    <span class="comment"># 设置无头</span></span><br><span class="line">    <span class="string">&quot;ms:edgeOptions&quot;</span>: &#123;</span><br><span class="line">        <span class="string">&#x27;extensions&#x27;</span>: [],</span><br><span class="line">        <span class="string">&#x27;args&#x27;</span>: [</span><br><span class="line">            <span class="string">&#x27;--headless&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;--disable-gpu&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;--remote-debugging-port=9222&#x27;</span>,</span><br><span class="line">        ]&#125;</span><br><span class="line">&#125;</span><br><span class="line">web = Edge(capabilities=opt)  <span class="comment"># 把参数配置设置到浏览器中</span></span><br><span class="line"></span><br><span class="line">web.get(<span class="string">&quot;https://www.endata.com.cn/BoxOffice/BO/Year/index.html&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 拿到经过数据加载以及js执行之后的结果的html内容!!!这样可以结合选择工具直接定位了</span></span><br><span class="line">print(web.page_source)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定位到下拉列表</span></span><br><span class="line">sel_el = web.find_element_by_xpath(<span class="string">&#x27;//*[@id=&quot;OptionDate&quot;]&#x27;</span>)</span><br><span class="line"><span class="comment"># 对元素进行包装, 包装成下拉菜单</span></span><br><span class="line">sel = Select(sel_el)</span><br><span class="line"><span class="comment"># 让浏览器进行调整选项</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(sel.options)):  <span class="comment"># i就是每一个下拉框选项的索引位置</span></span><br><span class="line">    sel.select_by_index(i)  <span class="comment"># 按照索引进行切换</span></span><br><span class="line">    time.sleep(<span class="number">2</span>)</span><br><span class="line">    table = web.find_element_by_xpath(<span class="string">&#x27;//*[@id=&quot;TableList&quot;]/table&#x27;</span>)</span><br><span class="line">    print(table.text)  <span class="comment"># 打印所有文本信息</span></span><br><span class="line">    print(<span class="string">&quot;===================================&quot;</span>)</span><br><span class="line"></span><br><span class="line">web.close()  <span class="comment"># 关闭页面</span></span><br><span class="line">web.quit()  <span class="comment"># 关闭浏览器</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li><code>.quit()</code> 关闭浏览器</li><li><code>web.page_source</code> 拿到经过数据加载以及js执行之后的结果的html内容！！！这样可以结合选择工具直接定位了</li><li><code>Select(sel_el).select_by_index(i)</code> 将元素包装成下拉菜单并按照索引进行切换</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># chrome设置无头</span></span><br><span class="line">chrome_options = webdriver.ChromeOptions()</span><br><span class="line">chrome_options.add_argument(<span class="string">&#x27;--headless&#x27;</span>)</span><br><span class="line">chrome_options.add_argument(<span class="string">&#x27;--disable-gpu&#x27;</span>)</span><br><span class="line"></span><br><span class="line">driver = webdriver.Chrome(options=chrome_options)</span><br></pre></td></tr></table></figure><h2 id="超级鹰"><a href="#超级鹰" class="headerlink" title="超级鹰"></a>超级鹰</h2><h3 id="验证码"><a href="#验证码" class="headerlink" title="验证码"></a>验证码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium.webdriver <span class="keyword">import</span> Edge</span><br><span class="line"><span class="keyword">from</span> chaojiying <span class="keyword">import</span> Chaojiying_Client</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">web = Edge()</span><br><span class="line">web.get(<span class="string">&quot;http://www.chaojiying.com/user/login/&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 处理验证码</span></span><br><span class="line">img = web.find_element_by_xpath(<span class="string">&#x27;/html/body/div[3]/div/div[3]/div[1]/form/div/img&#x27;</span>).screenshot_as_png  <span class="comment"># 将元素组件以图像形式存储在内存</span></span><br><span class="line">chaojiying = Chaojiying_Client(<span class="string">&#x27;18614075987&#x27;</span>, <span class="string">&#x27;6035945&#x27;</span>, <span class="string">&#x27;914467&#x27;</span>)</span><br><span class="line">dic = chaojiying.PostPic(img, <span class="number">1902</span>)</span><br><span class="line">verify_code = dic[<span class="string">&#x27;pic_str&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 向页面中填入用户名, 密码, 验证码</span></span><br><span class="line">web.find_element_by_xpath(<span class="string">&#x27;/html/body/div[3]/div/div[3]/div[1]/form/p[1]/input&#x27;</span>).send_keys(<span class="string">&quot;18614075987&quot;</span>)</span><br><span class="line">web.find_element_by_xpath(<span class="string">&#x27;/html/body/div[3]/div/div[3]/div[1]/form/p[2]/input&#x27;</span>).send_keys(<span class="string">&quot;6035945&quot;</span>)</span><br><span class="line">web.find_element_by_xpath(<span class="string">&#x27;/html/body/div[3]/div/div[3]/div[1]/form/p[3]/input&#x27;</span>).send_keys(verify_code)</span><br><span class="line"></span><br><span class="line">time.sleep(<span class="number">5</span>)</span><br><span class="line"><span class="comment"># 点击登录</span></span><br><span class="line">web.find_element_by_xpath(<span class="string">&#x27;/html/body/div[3]/div/div[3]/div[1]/form/p[4]/input&#x27;</span>).click()</span><br></pre></td></tr></table></figure><ul><li><code>.screenshot_as_png</code> 将元素组件以图像形式存储在内存</li></ul><h2 id="12306"><a href="#12306" class="headerlink" title="12306"></a>12306</h2><h3 id="反检测与滑块拖动"><a href="#反检测与滑块拖动" class="headerlink" title="反检测与滑块拖动"></a>反检测与滑块拖动</h3><ul><li><p><a href="https://blog.csdn.net/cqcre/article/details/110944075">chrome反检测driver</a></p></li><li><p><em>edge还没找到，暂时先不整了</em></p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium.webdriver <span class="keyword">import</span> Chrome</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver <span class="keyword">import</span> ActionChains</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.chrome.options <span class="keyword">import</span> Options</span><br><span class="line"><span class="keyword">from</span> chaojiying <span class="keyword">import</span> Chaojiying_Client</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">chaojiying = Chaojiying_Client(<span class="string">&#x27;18614075987&#x27;</span>, <span class="string">&#x27;6035945&#x27;</span>, <span class="string">&#x27;914467&#x27;</span>)</span><br><span class="line"></span><br><span class="line">option = Options()</span><br><span class="line">option.add_argument(<span class="string">&#x27;--disable-blink-features=AutomationControlled&#x27;</span>)</span><br><span class="line"></span><br><span class="line">web = Chrome(options=option)</span><br><span class="line">web.get(<span class="string">&quot;https://kyfw.12306.cn/otn/resources/login.html&quot;</span>)</span><br><span class="line">time.sleep(<span class="number">2</span>)</span><br><span class="line">web.find_element_by_xpath(<span class="string">&#x27;/html/body/div[2]/div[2]/ul/li[2]/a&#x27;</span>).click()</span><br><span class="line">time.sleep(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 先处理验证码</span></span><br><span class="line">verify_img_element = web.find_element_by_xpath(<span class="string">&#x27;//*[@id=&quot;J-loginImg&quot;]&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 用超级鹰去识别验证码</span></span><br><span class="line">dic = chaojiying.PostPic(verify_img_element.screenshot_as_png, <span class="number">9004</span>)</span><br><span class="line">result = dic[<span class="string">&#x27;pic_str&#x27;</span>]  <span class="comment"># x1,y1|x2,y2|x3,y3</span></span><br><span class="line">rs_list = result.split(<span class="string">&quot;|&quot;</span>)</span><br><span class="line"><span class="keyword">for</span> rs <span class="keyword">in</span> rs_list:  <span class="comment"># x1,y1</span></span><br><span class="line">    p_temp = rs.split(<span class="string">&quot;,&quot;</span>)</span><br><span class="line">    x = <span class="built_in">int</span>(p_temp[<span class="number">0</span>])</span><br><span class="line">    y = <span class="built_in">int</span>(p_temp[<span class="number">1</span>])</span><br><span class="line">    <span class="comment"># 鼠移动标 -&gt; 点击 -&gt; 执行.perform()</span></span><br><span class="line">    ActionChains(web).move_to_element_with_offset(verify_img_element, x, y).click().perform()</span><br><span class="line"><span class="comment"># time.sleep(5)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 输入用户名和密码</span></span><br><span class="line">web.find_element_by_xpath(<span class="string">&#x27;//*[@id=&quot;J-userName&quot;]&#x27;</span>).send_keys(<span class="string">&quot;userName&quot;</span>)</span><br><span class="line">web.find_element_by_xpath(<span class="string">&#x27;//*[@id=&quot;J-password&quot;]&#x27;</span>).send_keys(<span class="string">&quot;password&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 点击登录</span></span><br><span class="line">web.find_element_by_xpath(<span class="string">&#x27;//*[@id=&quot;J-login&quot;]&#x27;</span>).click()</span><br><span class="line">time.sleep(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 拖拽</span></span><br><span class="line">btn = web.find_element_by_xpath(<span class="string">&#x27;//*[@id=&quot;nc_1_n1z&quot;]&#x27;</span>)</span><br><span class="line">ActionChains(web).drag_and_drop_by_offset(btn, <span class="number">300</span>, <span class="number">0</span>).perform()</span><br></pre></td></tr></table></figure><ul><li>拖动时不能切换页面</li><li>适当使用 <code>time.sleep(3)</code> 防止过快</li><li>事件链 ActionChains 必须在末尾协商执行语句 <code>.perform()</code></li></ul>]]></content>
      
      
      <categories>
          
          <category> 爬虫 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>爬虫Part4</title>
      <link href="/2021/06/%E7%88%AC%E8%99%ABPart4/"/>
      <url>/2021/06/%E7%88%AC%E8%99%ABPart4/</url>
      
        <content type="html"><![CDATA[<h1 id="爬虫Part4——异步爬虫"><a href="#爬虫Part4——异步爬虫" class="headerlink" title="爬虫Part4——异步爬虫"></a>爬虫Part4——异步爬虫</h1><p>[TOC]</p><h2 id="多线程与多进程"><a href="#多线程与多进程" class="headerlink" title="多线程与多进程"></a>多线程与多进程</h2><h3 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h3><ol><li>进程是资源单位，开启一个程序则开启一个进程，为每个进程分配内存空间。</li><li>线程是执行单位，每一个进程至少要有一个线程，为每个线程分配计算资源。</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span>(<span class="params">name</span>):</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1000</span>):</span><br><span class="line">        print(name, i)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span>(<span class="params">Thread</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, name</span>):</span>  <span class="comment"># 传参做初始化</span></span><br><span class="line">        <span class="built_in">super</span>().__init__()</span><br><span class="line">        self.name = name</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span>(<span class="params">self</span>):</span>  <span class="comment"># 当线程被start时, 自动调用run()</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1000</span>):</span><br><span class="line">            print(self.name, i)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="comment"># 1. 通过函数启动线程</span></span><br><span class="line">    t = Thread(target=func, args=(<span class="string">&quot;t&quot;</span>,))  <span class="comment"># 传参必须是元组</span></span><br><span class="line">    t.start()</span><br><span class="line"></span><br><span class="line">    t0 = Thread(target=func, args=(<span class="string">&quot;t0&quot;</span>,))</span><br><span class="line">    t0.start()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 2. 通过类启动线程</span></span><br><span class="line">    t1 = MyThread(<span class="string">&quot;t1&quot;</span>)</span><br><span class="line">    <span class="comment"># t1.run()  # 直接run则为单线程</span></span><br><span class="line">    t1.start()  <span class="comment"># 开启多线程</span></span><br><span class="line"></span><br><span class="line">    t2 = MyThread(<span class="string">&quot;t2&quot;</span>)</span><br><span class="line">    t2.start()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 主线程</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1000</span>):</span><br><span class="line">        print(<span class="string">&quot;主线程&quot;</span>, i)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="多进程"><a href="#多进程" class="headerlink" title="多进程"></a>多进程</h3><ul><li>开进程太费资源，不建议使用</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span>():</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10000</span>):</span><br><span class="line">        print(<span class="string">&quot;子&quot;</span>, i)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    p = Process(target=func)</span><br><span class="line">    p.start()</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10000</span>):</span><br><span class="line">        print(<span class="string">&quot;主进程&quot;</span>, i)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="线程池和进程池"><a href="#线程池和进程池" class="headerlink" title="线程池和进程池"></a>线程池和进程池</h3><ul><li>线程池：一次性开辟多个线程，只需要考虑给线程池子编写任务，线程任务的调度交给线程池来完成。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> concurrent.futures <span class="keyword">import</span> ThreadPoolExecutor, ProcessPoolExecutor</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span>(<span class="params">name</span>):</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1000</span>):</span><br><span class="line">        print(name, i)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="keyword">with</span> ThreadPoolExecutor(<span class="number">50</span>) <span class="keyword">as</span> t:</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">100</span>):</span><br><span class="line">            t.submit(func, name=<span class="string">f&quot;线程<span class="subst">&#123;i&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="comment"># 等待线程池中的任务全部执行完毕. 才继续执行和后续操作</span></span><br><span class="line">    print(<span class="string">&quot;yes!&quot;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="批量新发地菜价"><a href="#批量新发地菜价" class="headerlink" title="批量新发地菜价"></a>批量新发地菜价</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> concurrent.futures <span class="keyword">import</span> ThreadPoolExecutor, ProcessPoolExecutor</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">from</span> lxml <span class="keyword">import</span> etree</span><br><span class="line"><span class="keyword">import</span> csv</span><br><span class="line"></span><br><span class="line">f = <span class="built_in">open</span>(<span class="string">&quot;source/菜价.csv&quot;</span>, encoding=<span class="string">&quot;utf-8&quot;</span>, newline=<span class="string">&quot;&quot;</span>, mode=<span class="string">&quot;w&quot;</span>)</span><br><span class="line">csv_writer = csv.writer(f)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">download</span>(<span class="params">url</span>):</span></span><br><span class="line">    resp = requests.get(url=url)</span><br><span class="line">    <span class="comment"># print(resp.text)</span></span><br><span class="line">    tree = etree.HTML(resp.text)</span><br><span class="line">    ts = tree.xpath(<span class="string">&quot;/html/body/div[2]/div[4]/div[1]/table&quot;</span>)[<span class="number">0</span>]  <span class="comment"># tbody是生成的，需要删去</span></span><br><span class="line">    <span class="comment"># print(len(ts))  # 即使结果只有一个，xpath()也永远返回list</span></span><br><span class="line">    trs = ts.xpath(<span class="string">&quot;./tr[position()&gt;1]&quot;</span>)  <span class="comment"># table下有多个tr，tr下有多个td</span></span><br><span class="line">    <span class="comment"># rows = t.xpath(&quot;./tr&quot;)[1:]</span></span><br><span class="line">    <span class="keyword">for</span> tr <span class="keyword">in</span> trs:</span><br><span class="line">        tds = tr.xpath(<span class="string">&quot;./td/text()&quot;</span>)</span><br><span class="line">        <span class="comment"># 对数据做简单处理</span></span><br><span class="line">        tds = <span class="built_in">list</span>(td.replace(<span class="string">&#x27;\\&#x27;</span>, <span class="string">&quot;&quot;</span>).replace(<span class="string">&quot;/&quot;</span>, <span class="string">&quot;&quot;</span>) <span class="keyword">for</span> td <span class="keyword">in</span> tds)  <span class="comment"># 将生成器转成list</span></span><br><span class="line">        <span class="comment"># print(tds)</span></span><br><span class="line">        csv_writer.writerow(tds)</span><br><span class="line">    print(url, <span class="string">&quot;have been downloaded!&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="keyword">with</span> ThreadPoolExecutor(<span class="number">50</span>) <span class="keyword">as</span> t:</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">200</span>):</span><br><span class="line">            u = <span class="string">f&quot;http://www.xinfadi.com.cn/marketanalysis/0/list%20/<span class="subst">&#123;i&#125;</span>.shtml&quot;</span></span><br><span class="line">            t.submit(download, url=u)</span><br><span class="line"></span><br><span class="line">f.close()</span><br></pre></td></tr></table></figure><h2 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h2><h3 id="asyncio"><a href="#asyncio" class="headerlink" title="asyncio"></a>asyncio</h3><ul><li><p>协程能够更加⾼效的利用CPU资源。</p></li><li><p><code>time.sleep()</code>、<code>input()</code>以及<code>request.get()</code>的等待过程中，该线程都处于阻塞状态，CPU资源浪费。</p><ul><li>一般情况下，遇到IO操作时，线程都会处于阻塞状态。</li></ul></li><li><p>协程：当程序遇到阻塞时，可以选择性地切换到其他任务上。(单线程多任务异步操作)</p><ul><li><p>在微观上，是一个个任务进行切换</p></li><li><p>在宏观上，能感受到的其实是多个任务一起在执行</p></li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">func</span>():</span></span><br><span class="line">    print(<span class="string">&quot;你好啊, 我叫赛利亚&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    g = func()  <span class="comment"># 此时的函数是异步协程函数，将返回一个协程对象</span></span><br><span class="line">    <span class="comment"># print(g)</span></span><br><span class="line">    asyncio.run(g)  <span class="comment"># 协程程序运行需要asyncio模块的支持(需要python3.7以上)</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">func1</span>():</span></span><br><span class="line">    print(<span class="string">&quot;你好啊, 我叫潘金莲&quot;</span>)</span><br><span class="line">    <span class="comment"># time.sleep(3)  # sleep、get属于同步操作。当程序出现了同步操作的时候. 异步就中断了</span></span><br><span class="line">    <span class="keyword">await</span> asyncio.sleep(<span class="number">3</span>)  <span class="comment"># asyncio.sleep才是异步睡眠。需要使用await挂起</span></span><br><span class="line">    print(<span class="string">&quot;你好啊, 我叫潘金莲&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">func2</span>():</span></span><br><span class="line">    print(<span class="string">&quot;你好啊, 我叫王建国&quot;</span>)</span><br><span class="line">    <span class="comment"># time.sleep(2)</span></span><br><span class="line">    <span class="keyword">await</span> asyncio.sleep(<span class="number">2</span>)</span><br><span class="line">    print(<span class="string">&quot;你好啊, 我叫王建国&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">func3</span>():</span></span><br><span class="line">    print(<span class="string">&quot;你好啊, 我叫李雪琴&quot;</span>)</span><br><span class="line">    <span class="keyword">await</span> asyncio.sleep(<span class="number">4</span>)</span><br><span class="line">    print(<span class="string">&quot;你好啊, 我叫李雪琴&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    f1 = func1()</span><br><span class="line">    f2 = func2()</span><br><span class="line">    f3 = func3()</span><br><span class="line">    tasks = [</span><br><span class="line">        f1, f2, f3</span><br><span class="line">    ]</span><br><span class="line"></span><br><span class="line">    t1 = time.time()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 一次性启动多个任务(协程)</span></span><br><span class="line">    <span class="comment"># asyncio.run(asyncio.wait(tasks))</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># python版本低于3.7时会有以下报错</span></span><br><span class="line">    <span class="comment"># AttributeError: module &#x27;asyncio&#x27; has no attribute &#x27;run&#x27;</span></span><br><span class="line">    <span class="comment"># 修正:</span></span><br><span class="line">    loop = asyncio.get_event_loop()</span><br><span class="line">    loop.run_until_complete(asyncio.wait(tasks))</span><br><span class="line"></span><br><span class="line">    t2 = time.time()</span><br><span class="line">    print(t2 - t1)</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">func1</span>():</span></span><br><span class="line">    print(<span class="string">&quot;你好啊, 我叫潘金莲&quot;</span>)</span><br><span class="line">    <span class="keyword">await</span> asyncio.sleep(<span class="number">3</span>)</span><br><span class="line">    print(<span class="string">&quot;你好啊, 我叫潘金莲&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">func2</span>():</span></span><br><span class="line">    print(<span class="string">&quot;你好啊, 我叫王建国&quot;</span>)</span><br><span class="line">    <span class="keyword">await</span> asyncio.sleep(<span class="number">2</span>)</span><br><span class="line">    print(<span class="string">&quot;你好啊, 我叫王建国&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">func3</span>():</span></span><br><span class="line">    print(<span class="string">&quot;你好啊, 我叫李雪琴&quot;</span>)</span><br><span class="line">    <span class="keyword">await</span> asyncio.sleep(<span class="number">4</span>)</span><br><span class="line">    print(<span class="string">&quot;你好啊, 我叫李雪琴&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    <span class="comment"># 第一种写法</span></span><br><span class="line">    <span class="comment"># f1 = func1()</span></span><br><span class="line">    <span class="comment"># await f1  # 一般await挂起操作放在协程对象前面</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 第二种写法(推荐)</span></span><br><span class="line">    tasks = [</span><br><span class="line">        func1(),  <span class="comment"># py3.8以后asyncio.create_task(func1())</span></span><br><span class="line">        func2(),</span><br><span class="line">        func3()</span><br><span class="line">    ]</span><br><span class="line">    <span class="keyword">await</span> asyncio.wait(tasks)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    t1 = time.time()</span><br><span class="line">    <span class="comment"># 一次性启动多个任务(协程)</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 定义协程对象</span></span><br><span class="line">    m = main()</span><br><span class="line">    <span class="comment"># 定义事件循环对象容器</span></span><br><span class="line">    loop = asyncio.get_event_loop()</span><br><span class="line">    <span class="comment"># task = asyncio.ensure_future(coroutine)</span></span><br><span class="line">    <span class="comment"># 将协程转为task任务</span></span><br><span class="line">    task = loop.create_task(m)</span><br><span class="line">    <span class="comment"># 将task任务扔进事件循环对象中并触发</span></span><br><span class="line">    loop.run_until_complete(task)</span><br><span class="line"></span><br><span class="line">    t2 = time.time()</span><br><span class="line">    print(t2 - t1)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="aiohttp异步请求"><a href="#aiohttp异步请求" class="headerlink" title="aiohttp异步请求"></a>aiohttp异步请求</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">import</span> aiohttp</span><br><span class="line"></span><br><span class="line">urls = [</span><br><span class="line">    <span class="string">&quot;http://kr.shanghai-jiuxin.com/file/2020/1031/191468637cab2f0206f7d1d9b175ac81.jpg&quot;</span>,</span><br><span class="line">    <span class="string">&quot;http://kr.shanghai-jiuxin.com/file/2020/1031/563337d07af599a9ea64e620729f367e.jpg&quot;</span>,</span><br><span class="line">    <span class="string">&quot;http://kr.shanghai-jiuxin.com/file/2020/1031/774218be86d832f359637ab120eba52d.jpg&quot;</span></span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">aio_download</span>(<span class="params">url</span>):</span></span><br><span class="line">    name = url.rsplit(<span class="string">&#x27;/&#x27;</span>, <span class="number">1</span>)[<span class="number">1</span>]  <span class="comment"># 从右往左按&#x27;/&#x27;切分一次，即[&#x27;http...&#x27;, &#x27;...jpg&#x27;]</span></span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">with</span> aiohttp.ClientSession() <span class="keyword">as</span> session:</span><br><span class="line">        <span class="keyword">async</span> <span class="keyword">with</span> session.get(url) <span class="keyword">as</span> resp:</span><br><span class="line">            <span class="comment">#  拿到请求</span></span><br><span class="line">            <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;source/&quot;</span> + name, mode=<span class="string">&quot;wb&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">                f.write(<span class="keyword">await</span> resp.content.read())  <span class="comment"># 读取内容为异步，需要挂起</span></span><br><span class="line">    print(name, <span class="string">&quot;downloaded!&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    task = []</span><br><span class="line">    <span class="keyword">for</span> url <span class="keyword">in</span> urls:</span><br><span class="line">        task.append(aio_download(url))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">await</span> asyncio.wait(task)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    loop = asyncio.get_event_loop()</span><br><span class="line">    task = loop.create_task(main())</span><br><span class="line">    loop.run_until_complete(task)</span><br></pre></td></tr></table></figure><h2 id="实战案例"><a href="#实战案例" class="headerlink" title="实战案例"></a>实战案例</h2><h3 id="纵横小说"><a href="#纵横小说" class="headerlink" title="纵横小说"></a>纵横小说</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">from</span> lxml <span class="keyword">import</span> etree</span><br><span class="line"><span class="keyword">import</span> aiohttp</span><br><span class="line"><span class="keyword">import</span> aiofiles  <span class="comment"># 异步文件读写</span></span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;http://book.zongheng.com/showchapter/1084237.html&quot;</span></span><br><span class="line"><span class="string">&quot;http://book.zongheng.com/chapter/1084237/63603883.html&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># resp = requests.get(&quot;http://book.zongheng.com/chapter/1084237/63603883.html&quot;)</span></span><br><span class="line"><span class="comment"># print(resp.text)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">aio_download</span>(<span class="params">path, href</span>):</span></span><br><span class="line">    url = href</span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">with</span> aiohttp.ClientSession() <span class="keyword">as</span> session:</span><br><span class="line">        <span class="keyword">async</span> <span class="keyword">with</span> session.get(url) <span class="keyword">as</span> resp:</span><br><span class="line">            dic = <span class="keyword">await</span> resp.text()</span><br><span class="line">            tree = etree.HTML(dic)</span><br><span class="line">            contents = tree.xpath(<span class="string">&quot;/html/body/div[2]/div[3]/div[3]/div/div[5]/p/text()&quot;</span>)</span><br><span class="line">            <span class="keyword">async</span> <span class="keyword">with</span> aiofiles.<span class="built_in">open</span>(path, mode=<span class="string">&quot;w&quot;</span>, encoding=<span class="string">&quot;utf-8&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">                <span class="keyword">for</span> content <span class="keyword">in</span> contents:</span><br><span class="line">                    <span class="keyword">await</span> f.write(content + <span class="string">&quot;\n&quot;</span>)  <span class="comment"># 把小说内容写出</span></span><br><span class="line">    print(path, <span class="string">&quot;ok!&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">get_catalog</span>(<span class="params">url</span>):</span></span><br><span class="line">    tasks = []</span><br><span class="line">    <span class="comment"># 获取书本主页面响应</span></span><br><span class="line">    resp = requests.get(url)</span><br><span class="line">    tree = etree.HTML(resp.text)</span><br><span class="line">    chs = tree.xpath(<span class="string">&quot;/html/body/div[3]/div[2]/div[2]/div/ul&quot;</span>)[<span class="number">1</span>:<span class="number">3</span>]  <span class="comment"># todo 初步爬取</span></span><br><span class="line">    <span class="comment"># print(len(chs))  # 有四卷</span></span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> chs:  <span class="comment"># 获取每一卷中，各章节的标题和链接</span></span><br><span class="line">        hrefs = item.xpath(<span class="string">&quot;./li/a/@href&quot;</span>)</span><br><span class="line">        titles = item.xpath(<span class="string">&quot;./li/a/text()&quot;</span>)</span><br><span class="line">        <span class="keyword">for</span> title, href <span class="keyword">in</span> <span class="built_in">zip</span>(titles, hrefs):</span><br><span class="line">            <span class="comment"># 准备异步任务</span></span><br><span class="line">            <span class="comment"># print(title, href)</span></span><br><span class="line">            path = <span class="string">&quot;source/&quot;</span> + title + <span class="string">&quot;.txt&quot;</span></span><br><span class="line">            tasks.append(aio_download(path, href))</span><br><span class="line">            <span class="comment"># break  # todo 初步爬取</span></span><br><span class="line">    <span class="keyword">await</span> asyncio.wait(tasks)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    b_id = <span class="string">&quot;1084237&quot;</span></span><br><span class="line">    url_book = <span class="string">f&quot;http://book.zongheng.com/showchapter/<span class="subst">&#123;b_id&#125;</span>.html&quot;</span></span><br><span class="line"></span><br><span class="line">    loop = asyncio.get_event_loop()</span><br><span class="line">    task = loop.create_task(get_catalog(url_book))</span><br><span class="line">    loop.run_until_complete(task)</span><br></pre></td></tr></table></figure><ul><li>教程原网页已炸，这里用其他网站做测试学习</li><li>主要还是需要自己去定位资源位置</li><li><em>有加密的是真的烦，还有些直接导向其他域名，离谱</em></li><li><em>幸好纵横的基本不反爬，比较容易</em></li></ul><h3 id="抓取视频"><a href="#抓取视频" class="headerlink" title="抓取视频"></a>抓取视频</h3><ul><li><p>一般在html中写入<code>&lt;video src=&quot;不能播的视频.mp4&quot;&gt;&lt;/video&gt;</code>即可播放视频，但是其需要加载完整个视频资源，效率极低。</p></li><li><p>网站上视频一般都需要：①转码成不同分辨率； ②切片处理以减少拉动进度条时的资源占用。</p></li><li><p>因此需要一个M3U8（本质就是utf-8文本）文件记录：1.视频切片播放顺序；2.视频切片存放的路径……</p></li><li><p>想要抓取一个视频:</p><ol><li>找到m3u8</li><li>通过m3u8下载到ts文件</li><li>把ts文件合并为一个mp4文件</li></ol></li></ul><h4 id="简单版"><a href="#简单版" class="headerlink" title="简单版"></a>简单版</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">流程:</span></span><br><span class="line"><span class="string">    1. 拿到548121-1-1.html的页面源代码</span></span><br><span class="line"><span class="string">    2. 从源代码中提取到m3u8的url。</span></span><br><span class="line"><span class="string">    3. 下载m3u8</span></span><br><span class="line"><span class="string">    4. 读取m3u8文件, 下载视频</span></span><br><span class="line"><span class="string">    5. 合并视频</span></span><br><span class="line"><span class="string">tips:</span></span><br><span class="line"><span class="string">    1. 第二部的url中?note=是从第一步中拿到的，即必须先第一步才能第二步</span></span><br><span class="line"><span class="string">    2. 这个note具备时效性，间隔太长则拒绝访问</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line"><span class="comment"># url在js中，所以用re而不是xpath来提取m3u8的url地址</span></span><br><span class="line"><span class="comment"># 复制并查找 url: &#x27; 和 &#x27;, 是否在文件中唯一</span></span><br><span class="line">obj = re.<span class="built_in">compile</span>(<span class="string">r&quot;url: &#x27;(?P&lt;url&gt;.*?)&#x27;,&quot;</span>, re.S)</span><br><span class="line"></span><br><span class="line">url_html = <span class="string">&quot;https://www.91kanju.com/vod-play/54812-1-1.html&quot;</span></span><br><span class="line"></span><br><span class="line">headers = &#123;</span><br><span class="line">    <span class="string">&quot;User-Agent&quot;</span>: <span class="string">&quot;User-Agent&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">resp = requests.get(url_html, headers=headers)</span><br><span class="line">url_m3u8 = obj.search(resp.text).group(<span class="string">&quot;url&quot;</span>)  <span class="comment"># 拿到m3u8的地址</span></span><br><span class="line">print(url_m3u8)</span><br><span class="line">resp.close()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 下载m3u8文件</span></span><br><span class="line">resp_m3u8 = requests.get(url_m3u8, headers=headers)</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;哲仁王后.m3u8&quot;</span>, mode=<span class="string">&quot;wb&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    f.write(resp_m3u8.content)  <span class="comment"># 直接以wb二进制形式写入，避免编码问题</span></span><br><span class="line"></span><br><span class="line">resp_m3u8.close()</span><br><span class="line">print(<span class="string">&quot;下载完毕&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 解析m3u8文件</span></span><br><span class="line">n = <span class="number">1</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;哲仁王后.m3u8&quot;</span>, mode=<span class="string">&quot;r&quot;</span>, encoding=<span class="string">&quot;utf-8&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> f:</span><br><span class="line">        line = line.strip()  <span class="comment"># 去除空格, 空白, 换行符</span></span><br><span class="line">        <span class="keyword">if</span> line.startswith(<span class="string">&quot;#&quot;</span>):  <span class="comment"># 如果以#开头. 则跳过</span></span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 下载视频片段</span></span><br><span class="line">        <span class="keyword">with</span> requests.get(line) <span class="keyword">as</span> resp3:</span><br><span class="line">            <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">f&quot;video/<span class="subst">&#123;n&#125;</span>.ts&quot;</span>, mode=<span class="string">&quot;wb&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">                f.write(resp3.content)</span><br><span class="line">        n += <span class="number">1</span></span><br><span class="line">        print(<span class="string">&quot;完成了1个&quot;</span>)</span><br></pre></td></tr></table></figure><h4 id="复杂版"><a href="#复杂版" class="headerlink" title="复杂版"></a>复杂版</h4><p><img src="/2021/06/%E7%88%AC%E8%99%ABPart4/image-20210605103918532.png" alt="image-20210605103918532"></p><ul><li>当遇到右键点不了的网页时，可以通过source-&gt;top/buding520.com/acg/19888/1.html找到页面源代码</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">思路:</span></span><br><span class="line"><span class="string">    1. 拿到主页面的页面源代码, 找到iframe</span></span><br><span class="line"><span class="string">    2. 从iframe的页面源代码中拿到m3u8文件的地址</span></span><br><span class="line"><span class="string">    3. 下载第一层m3u8文件 -&gt; 下载第二层m3u8文件(视频存放路径)</span></span><br><span class="line"><span class="string">    4. 下载ts切片视频(协程)</span></span><br><span class="line"><span class="string">    5. 下载秘钥, 进行解密操作(协程)</span></span><br><span class="line"><span class="string">    6. 合并所有ts文件为一个mp4文件</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">import</span> aiohttp</span><br><span class="line"><span class="keyword">import</span> aiofiles</span><br><span class="line"><span class="keyword">from</span> Crypto.Cipher <span class="keyword">import</span> AES  <span class="comment"># pip install pycryptodome + 文件夹改名crypto-&gt;Crypto</span></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_iframe_src</span>(<span class="params">url</span>):</span></span><br><span class="line">    resp = requests.get(url)</span><br><span class="line">    main_page = BeautifulSoup(resp.text, <span class="string">&quot;html.parser&quot;</span>)  <span class="comment"># 可以用bs/xpath</span></span><br><span class="line">    src = main_page.find(<span class="string">&quot;iframe&quot;</span>).get(<span class="string">&quot;src&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> src</span><br><span class="line">    <span class="comment"># return &quot;https://boba.52kuyun.com/share/xfPs9NPHvYGhNzFp&quot;  # 为了测试</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_first_m3u8_url</span>(<span class="params">url</span>):</span></span><br><span class="line">    resp = requests.get(url)</span><br><span class="line">    <span class="comment"># print(resp.text)</span></span><br><span class="line">    <span class="comment"># 从js中找，所以用re</span></span><br><span class="line">    obj = re.<span class="built_in">compile</span>(<span class="string">r&#x27;var main = &quot;(?P&lt;m3u8_url&gt;.*?)&quot;&#x27;</span>, re.S)</span><br><span class="line">    m3u8_url = obj.search(resp.text).group(<span class="string">&quot;m3u8_url&quot;</span>)</span><br><span class="line">    <span class="comment"># print(m3u8_url)</span></span><br><span class="line">    <span class="keyword">return</span> m3u8_url</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">download_m3u8_file</span>(<span class="params">url, name</span>):</span></span><br><span class="line">    resp = requests.get(url)</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(name, mode=<span class="string">&quot;wb&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        f.write(resp.content)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">download_ts</span>(<span class="params">url, name, session</span>):</span></span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">with</span> session.get(url) <span class="keyword">as</span> resp:</span><br><span class="line">        <span class="keyword">async</span> <span class="keyword">with</span> aiofiles.<span class="built_in">open</span>(<span class="string">f&quot;video2/<span class="subst">&#123;name&#125;</span>&quot;</span>, mode=<span class="string">&quot;wb&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">            <span class="keyword">await</span> f.write(<span class="keyword">await</span> resp.content.read())  <span class="comment"># 把下载到的内容写入到文件中</span></span><br><span class="line">    print(<span class="string">f&quot;<span class="subst">&#123;name&#125;</span>下载完毕&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">aio_download</span>(<span class="params">up_url</span>):</span>  <span class="comment"># https://boba.52kuyun.com/20170906/Moh2l9zV/hls/</span></span><br><span class="line">    tasks = []</span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">with</span> aiohttp.ClientSession() <span class="keyword">as</span> session:  <span class="comment"># 提前准备好session</span></span><br><span class="line">        <span class="keyword">async</span> <span class="keyword">with</span> aiofiles.<span class="built_in">open</span>(<span class="string">&quot;越狱第一季第一集_second_m3u8.txt&quot;</span>, mode=<span class="string">&quot;r&quot;</span>, encoding=<span class="string">&#x27;utf-8&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">            <span class="keyword">async</span> <span class="keyword">for</span> line <span class="keyword">in</span> f:</span><br><span class="line">                <span class="keyword">if</span> line.startswith(<span class="string">&quot;#&quot;</span>):</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                <span class="comment"># line就是xxxxx.ts</span></span><br><span class="line">                line = line.strip()  <span class="comment"># 去掉没用的空格和换行</span></span><br><span class="line">                <span class="comment"># 拼接真正的ts路径</span></span><br><span class="line">                ts_url = up_url + line</span><br><span class="line">                task = asyncio.create_task(download_ts(ts_url, line, session))  <span class="comment"># 创建任务</span></span><br><span class="line">                tasks.append(task)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">await</span> asyncio.wait(tasks)  <span class="comment"># 等待任务结束</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_key</span>(<span class="params">url</span>):</span></span><br><span class="line">    resp = requests.get(url)</span><br><span class="line">    <span class="keyword">return</span> resp.text</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">dec_ts</span>(<span class="params">name, key</span>):</span></span><br><span class="line">    aes = AES.new(key=key, IV=<span class="string">b&quot;0000000000000000&quot;</span>, mode=AES.MODE_CBC)</span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">with</span> aiofiles.<span class="built_in">open</span>(<span class="string">f&quot;video2/<span class="subst">&#123;name&#125;</span>&quot;</span>, mode=<span class="string">&quot;rb&quot;</span>) <span class="keyword">as</span> f1, \</span><br><span class="line">            aiofiles.<span class="built_in">open</span>(<span class="string">f&quot;video2/temp_<span class="subst">&#123;name&#125;</span>&quot;</span>, mode=<span class="string">&quot;wb&quot;</span>) <span class="keyword">as</span> f2:</span><br><span class="line">        bs = <span class="keyword">await</span> f1.read()  <span class="comment"># 从源文件读取内容</span></span><br><span class="line">        <span class="keyword">await</span> f2.write(aes.decrypt(bs))  <span class="comment"># 把解密好的内容写入文件</span></span><br><span class="line">    print(<span class="string">f&quot;<span class="subst">&#123;name&#125;</span>处理完毕&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">aio_dec</span>(<span class="params">key</span>):</span></span><br><span class="line">    <span class="comment"># 解密</span></span><br><span class="line">    tasks = []</span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">with</span> aiofiles.<span class="built_in">open</span>(<span class="string">&quot;越狱第一季第一集_second_m3u8.txt&quot;</span>, mode=<span class="string">&quot;r&quot;</span>, encoding=<span class="string">&quot;utf-8&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        <span class="keyword">async</span> <span class="keyword">for</span> line <span class="keyword">in</span> f:</span><br><span class="line">            <span class="keyword">if</span> line.startswith(<span class="string">&quot;#&quot;</span>):</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            line = line.strip()</span><br><span class="line">            <span class="comment"># 开始创建异步任务</span></span><br><span class="line">            task = asyncio.create_task(dec_ts(line, key))</span><br><span class="line">            tasks.append(task)</span><br><span class="line">        <span class="keyword">await</span> asyncio.wait(tasks)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">merge_ts</span>():</span>  <span class="comment"># 其实也可以用ab追加写入</span></span><br><span class="line">    <span class="comment"># mac: cat 1.ts 2.ts 3.ts &gt; xxx.mp4</span></span><br><span class="line">    <span class="comment"># windows: copy /b 1.ts+2.ts+3.ts xxx.mp4</span></span><br><span class="line">    lst = []</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;越狱第一季第一集_second_m3u8.txt&quot;</span>, mode=<span class="string">&quot;r&quot;</span>, encoding=<span class="string">&quot;utf-8&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        <span class="keyword">for</span> line <span class="keyword">in</span> f:</span><br><span class="line">            <span class="keyword">if</span> line.startswith(<span class="string">&quot;#&quot;</span>):</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            line = line.strip()</span><br><span class="line">            lst.append(<span class="string">f&quot;video2/temp_<span class="subst">&#123;line&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">    s = <span class="string">&quot;+&quot;</span>.join(lst)  <span class="comment"># 1.ts+2.ts+3.ts...</span></span><br><span class="line">    os.system(<span class="string">f&quot;copy /b <span class="subst">&#123;s&#125;</span> movie.mp4&quot;</span>)</span><br><span class="line">    print(<span class="string">&quot;done!&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>(<span class="params">url</span>):</span></span><br><span class="line">    <span class="comment"># 1. 拿到主页面的页面源代码, 找到iframe对应的url</span></span><br><span class="line">    iframe_src = get_iframe_src(url)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 2. 拿到第一层的m3u8文件的下载地址</span></span><br><span class="line">    first_m3u8_url = get_first_m3u8_url(iframe_src)</span><br><span class="line">    <span class="comment"># 拿到iframe的域名 &quot;https://boba.52kuyun.com/share/xfPs9NPHvYGhNzFp&quot;</span></span><br><span class="line">    iframe_domain = iframe_src.split(<span class="string">&quot;/share&quot;</span>)[<span class="number">0</span>]</span><br><span class="line">    <span class="comment"># 拼接出真正的m3u8的下载路径</span></span><br><span class="line">    first_m3u8_url = iframe_domain + first_m3u8_url</span><br><span class="line">    <span class="comment"># https://boba.52kuyun.com/20170906/Moh2l9zV/index.m3u8?sign=548ae366a075f0f9e7c76af215aa18e1</span></span><br><span class="line">    <span class="comment"># print(first_m3u8_url)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 3.1 下载第一层m3u8文件</span></span><br><span class="line">    download_m3u8_file(first_m3u8_url, <span class="string">&quot;越狱第一季第一集_first_m3u8.txt&quot;</span>)</span><br><span class="line">    <span class="comment"># 3.2 下载第二层m3u8文件</span></span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;越狱第一季第一集_first_m3u8.txt&quot;</span>, mode=<span class="string">&quot;r&quot;</span>, encoding=<span class="string">&quot;utf-8&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        <span class="keyword">for</span> line <span class="keyword">in</span> f:</span><br><span class="line">            <span class="keyword">if</span> line.startswith(<span class="string">&quot;#&quot;</span>):</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                line = line.strip()  <span class="comment"># 去掉空白或者换行符  hls/index.m3u8</span></span><br><span class="line">                <span class="comment"># 准备拼接第二层m3u8的下载路径</span></span><br><span class="line">                <span class="comment"># https://boba.52kuyun.com/20170906/Moh2l9zV/ + hls/index.m3u8</span></span><br><span class="line">                <span class="comment"># https://boba.52kuyun.com/20170906/Moh2l9zV/hls/index.m3u8</span></span><br><span class="line">                <span class="comment"># https://boba.52kuyun.com/20170906/Moh2l9zV/hls/cFN8o3436000.ts</span></span><br><span class="line">                second_m3u8_url = first_m3u8_url.split(<span class="string">&quot;index.m3u8&quot;</span>)[<span class="number">0</span>] + line</span><br><span class="line">                download_m3u8_file(second_m3u8_url, <span class="string">&quot;越狱第一季第一集_second_m3u8.txt&quot;</span>)</span><br><span class="line">                print(<span class="string">&quot;m3u8文件下载完毕&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 4. 下载视频</span></span><br><span class="line">    second_m3u8_url_up = second_m3u8_url.replace(<span class="string">&quot;index.m3u8&quot;</span>, <span class="string">&quot;&quot;</span>)</span><br><span class="line">    <span class="comment"># 异步协程</span></span><br><span class="line">    asyncio.run(aio_download(second_m3u8_url_up))  <span class="comment"># 测试的使用可以注释掉</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 5.1 拿到秘钥</span></span><br><span class="line">    key_url = second_m3u8_url_up + <span class="string">&quot;key.key&quot;</span>  <span class="comment"># 偷懒写法, 正常应该去m3u8文件里去找</span></span><br><span class="line">    key = get_key(key_url)</span><br><span class="line">    <span class="comment"># 5.2 解密</span></span><br><span class="line">    asyncio.run(aio_dec(key))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 6. 合并ts文件为mp4文件</span></span><br><span class="line">    merge_ts()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="comment"># ↓↓↓网站已挂↓↓↓</span></span><br><span class="line">    url = <span class="string">&quot;https://www.91kanju.com/vod-play/541-2-1.html&quot;</span></span><br><span class="line">    main(url)</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>寻找思路时：复杂问题简单化（逻辑化思路）</p><p>实现思路时：简单问题复杂化（思考更多可能性）</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 爬虫 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>爬虫Part3</title>
      <link href="/2021/06/%E7%88%AC%E8%99%ABPart3/"/>
      <url>/2021/06/%E7%88%AC%E8%99%ABPart3/</url>
      
        <content type="html"><![CDATA[<h1 id="爬虫Part3——Requests进阶"><a href="#爬虫Part3——Requests进阶" class="headerlink" title="爬虫Part3——Requests进阶"></a>爬虫Part3——Requests进阶</h1><p>[TOC]</p><h2 id="Requests进阶概述"><a href="#Requests进阶概述" class="headerlink" title="Requests进阶概述"></a>Requests进阶概述</h2><p>HTTP协议中的请求头header，⼀般会包含安全验证信息，比如常见的User-Agent, token, cookie等。</p><ol><li>模拟浏览器登录 -&gt; 处理cookie</li><li>防盗链处理 -&gt; 抓取梨视频数据</li><li>代理 -&gt; 防⽌被封IP</li></ol><h2 id="模拟浏览器登录"><a href="#模拟浏览器登录" class="headerlink" title="模拟浏览器登录"></a>模拟浏览器登录</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line"><span class="comment"># 初始化session</span></span><br><span class="line">session = requests.session()</span><br><span class="line"><span class="comment"># 准备帐密</span></span><br><span class="line">data = &#123;</span><br><span class="line">    <span class="string">&quot;loginName&quot;</span>: <span class="string">&quot;loginName&quot;</span>,</span><br><span class="line">    <span class="string">&quot;password&quot;</span>: <span class="string">&quot;password&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment"># 必须先登录，才能使session获得cookie</span></span><br><span class="line">url = <span class="string">&quot;https://passport.17k.com/ck/user/login&quot;</span></span><br><span class="line">resp_login = session.post(url=url, data=data)</span><br><span class="line">print(resp_login.text)</span><br><span class="line">print(resp_login.cookies)</span><br><span class="line"><span class="comment"># 使用包含cookie的session拿到书架数据</span></span><br><span class="line">resp_book = session.get(<span class="string">&quot;https://user.17k.com/ck/author/shelf?page=1&amp;appKey=2406394919&quot;</span>)</span><br><span class="line">print(resp_book.json())</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在header中添加cookie进行请求是等效的</span></span><br><span class="line">resp_req = requests.get(<span class="string">&quot;https://user.17k.com/ck/author/shelf?page=1&amp;appKey=2406394919&quot;</span>, headers=&#123;</span><br><span class="line">    <span class="string">&quot;Cookie&quot;</span>: <span class="string">&quot;cookie&quot;</span></span><br><span class="line">&#125;)</span><br><span class="line">print(resp_req.json())</span><br></pre></td></tr></table></figure><ul><li>使用错误的帐密登录，以抓取login信息</li></ul><p><img src="/2021/06/%E7%88%AC%E8%99%ABPart3/image-20210603110845823.png" alt="image-20210603110845823"></p><h2 id="防盗链处理"><a href="#防盗链处理" class="headerlink" title="防盗链处理"></a>防盗链处理</h2><ul><li>虽然在开发者工具中能看到<video>标签，但这是本地通过js脚本生成的。而在网页源代码中，<video>是不存在的，视频资源是二次加载的。</video></video></li><li>服务器返回页面源代码之后生成以下右边的文件，之后的操作与页面源代码就没有关系了。</li><li>浏览器的视图界面是由右边的文件实时渲染的。当删除右边的语句时，左边的相应组件也会同步消失。</li></ul><p><img src="/2021/06/%E7%88%AC%E8%99%ABPart3/image-20210603125745611.png" alt="image-20210603125745611"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line"><span class="comment"># 视频原网站</span></span><br><span class="line">url = <span class="string">&quot;https://www.pearvideo.com/video_1713901&quot;</span></span><br><span class="line">contId = url.split(<span class="string">&quot;_&quot;</span>)[<span class="number">1</span>]  <span class="comment"># 截取id</span></span><br><span class="line">videoStatus_url = <span class="string">f&quot;https://www.pearvideo.com/videoStatus.jsp?contId=<span class="subst">&#123;contId&#125;</span>&amp;mrd=0.8770894467476524&quot;</span></span><br><span class="line"></span><br><span class="line">headers = &#123;</span><br><span class="line">    <span class="string">&quot;User-Agent&quot;</span>: <span class="string">&quot;User-Agent&quot;</span>,</span><br><span class="line">    <span class="string">&quot;Referer&quot;</span>: url  <span class="comment"># 防盗链，溯源本次请求由哪个url产生</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 修正视频地址</span></span><br><span class="line">resp = requests.get(url=videoStatus_url, headers=headers)</span><br><span class="line">dic = resp.json()</span><br><span class="line">system_time = dic[<span class="string">&quot;systemTime&quot;</span>]</span><br><span class="line">video_url = dic[<span class="string">&quot;videoInfo&quot;</span>][<span class="string">&quot;videos&quot;</span>][<span class="string">&quot;srcUrl&quot;</span>].replace(system_time, <span class="string">f&quot;cont-<span class="subst">&#123;contId&#125;</span>&quot;</span>)</span><br><span class="line">print(video_url)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 下载视频</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">f&quot;<span class="subst">&#123;contId&#125;</span>.mp4&quot;</span>, mode=<span class="string">&quot;wb&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    f.write(requests.get(video_url).content)</span><br></pre></td></tr></table></figure><h2 id="代理"><a href="#代理" class="headerlink" title="代理"></a>代理</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line">headers = &#123;</span><br><span class="line">    <span class="string">&quot;User-Agent&quot;</span>: <span class="string">&quot;User-Agent&quot;</span></span><br><span class="line">&#125;</span><br><span class="line">proxies = &#123;</span><br><span class="line">    <span class="string">&quot;https&quot;</span>: <span class="string">&quot;115.219.2.82:3256&quot;</span></span><br><span class="line">&#125;</span><br><span class="line">resp = requests.get(<span class="string">&quot;https://www.baidu.com&quot;</span>, headers=headers, proxies=proxies)</span><br><span class="line">resp.encoding = <span class="string">&quot;utf-8&quot;</span></span><br><span class="line">print(resp.text)</span><br></pre></td></tr></table></figure><h2 id="网易云音乐评论"><a href="#网易云音乐评论" class="headerlink" title="网易云音乐评论"></a>网易云音乐评论</h2><p><img src="/2021/06/%E7%88%AC%E8%99%ABPart3/image-20210603164018457.png" alt="image-20210603164018457"></p><ul><li>使用定位工具可以发现评论在html文件中的位置，但是不要忘了这是经过脚本生成的，并不是通过get使服务器返还的初始的网页源代码。</li></ul><p><img src="/2021/06/%E7%88%AC%E8%99%ABPart3/image-20210603163736597.png" alt="image-20210603163736597"></p><ul><li>网易云音乐的网页页面是由多个html拼接而成，因此可以看见有<strong>框架源代码</strong>和<strong>网页源代码</strong>两个html文件。</li><li>但是在两个html中搜寻，均没有评论资源。由此可知，评论是通过二次请求得到的。</li></ul><p><img src="/2021/06/%E7%88%AC%E8%99%ABPart3/image-20210603163551436.png" alt="image-20210603163551436"></p><ul><li>使用Network抓包工具-&gt;筛选XHR二次请求-&gt;找到comment资源</li></ul><p><img src="/2021/06/%E7%88%AC%E8%99%ABPart3/image-20210603164605502.png" alt="image-20210603164605502"></p><ul><li>继续查看headers信息。可知：<ol><li>请求目标的URL：<code>https://music.163.com/weapi/comment/resource/comments/get</code></li><li><code>csrf_token=</code>后为登录信息，<code>?</code>后的参数可以忽略</li><li><code>Request Method: POST</code>请求方式为<strong>POST</strong>。</li><li>同时发送了两个加密data：<code>params</code>和<code>encSecKey</code></li></ol></li></ul><p><img src="/2021/06/%E7%88%AC%E8%99%ABPart3/image-20210603170549795.png" alt="image-20210603170549795"></p><ul><li>查看发起请求之前所调用过的栈、js脚本执行的过程。最开始执行的在最底部。点击最后调用的脚本。</li></ul><p><img src="/2021/06/%E7%88%AC%E8%99%ABPart3/image-20210603171043357.png" alt="image-20210603171043357"></p><ul><li>现在是压缩过后的代码，需要点击正下方的按钮，更换成优质打印。</li></ul><p><img src="/2021/06/%E7%88%AC%E8%99%ABPart3/image-20210603171817947.png" alt="image-20210603171817947"></p><ul><li>在语句<code>send()</code>处设置断点，刷新网页</li><li>观察变量<code>request-&gt;url</code>，恢复程序执行直到更新为<code>https://music.163.com/weapi/comment/resource/comments/get</code></li><li>数据处于加密状态，因此需要通过调用堆栈不断回调函数，直到找到未加密的data</li></ul><p><img src="/2021/06/%E7%88%AC%E8%99%ABPart3/image-20210603173446525.png" alt="image-20210603173446525"></p><ul><li>回调时发现data未加密，立刻定位到加密函数为<code>t8l.be8W</code></li><li>数据在变量<code>i8a</code>与变量<code>e8e</code>之间完成了加密</li></ul><p><img src="/2021/06/%E7%88%AC%E8%99%ABPart3/image-20210603174358762.png" alt="image-20210603174358762"></p><ul><li>需要在已定的小范围内进一步缩小范围，因此在函数开始处增加新断点，重新刷新页面</li><li>发现在<code>window.asrsea()</code>方法中<code>i8a</code>作为参数之一，返回变量<code>bMl1x</code></li><li>发现变量<code>bMl1x</code>已经被加密，拥有<code>encSecKey</code>和<code>encText</code></li><li><code>bMl1x</code>的数据又赋给<code>e8e.data</code>，由此加密data完成</li></ul><h3 id="简易实现版"><a href="#简易实现版" class="headerlink" title="简易实现版"></a>简易实现版</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line">api = <span class="string">&quot;https://music.163.com/api/comment/resource/comments/get&quot;</span></span><br><span class="line">data = &#123;</span><br><span class="line">    <span class="string">&quot;cursor&quot;</span>: <span class="string">&quot;-1&quot;</span>,</span><br><span class="line">    <span class="string">&quot;offset&quot;</span>: <span class="string">&quot;0&quot;</span>,</span><br><span class="line">    <span class="string">&quot;orderType&quot;</span>: <span class="string">&quot;1&quot;</span>,</span><br><span class="line">    <span class="string">&quot;pageNo&quot;</span>: <span class="string">&quot;1&quot;</span>,</span><br><span class="line">    <span class="string">&quot;pageSize&quot;</span>: <span class="string">&quot;20&quot;</span>,</span><br><span class="line">    <span class="string">&quot;rid&quot;</span>: <span class="string">&quot;R_SO_4_1841819403&quot;</span>,</span><br><span class="line">    <span class="string">&quot;threadId&quot;</span>: <span class="string">&quot;R_SO_4_1841819403&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">resp = requests.get(api, params=data)</span><br><span class="line">json = resp.json()</span><br><span class="line">print(resp.json())</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 爬虫 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>爬虫Part2</title>
      <link href="/2021/05/%E7%88%AC%E8%99%ABPart2/"/>
      <url>/2021/05/%E7%88%AC%E8%99%ABPart2/</url>
      
        <content type="html"><![CDATA[<h1 id="爬虫Part2——数据解析与提取"><a href="#爬虫Part2——数据解析与提取" class="headerlink" title="爬虫Part2——数据解析与提取"></a>爬虫Part2——数据解析与提取</h1><p>[TOC]</p><h2 id="数据解析概述"><a href="#数据解析概述" class="headerlink" title="数据解析概述"></a>数据解析概述</h2><p>当需要只是需要部分网页的内容而不是全部时，就要用到数据提取：</p><ol><li><p>Re解析</p></li><li><p>Bs4解析</p></li><li><p>Xpath解析</p></li></ol><h2 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h2><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><p>正则表达式（Regular Expression）是⼀种使用表达式的方式对字符串进行匹配的语法规则。</p><p>在线测试正则表达式：<a href="https://tool.oschina.net/regex/">https://tool.oschina.net/regex/</a></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">元字符: 具有固定含义的特殊符号</span><br><span class="line"></span><br><span class="line">. 匹配除换⾏符以外的任意字符</span><br><span class="line">\w 匹配字⺟或数字或下划线</span><br><span class="line">\s 匹配任意的空⽩符</span><br><span class="line">\d 匹配数字</span><br><span class="line">\n 匹配⼀个换⾏符</span><br><span class="line">\t 匹配⼀个制表符</span><br><span class="line"></span><br><span class="line">^ 匹配字符串的开始</span><br><span class="line">$ 匹配字符串的结尾</span><br><span class="line"></span><br><span class="line">\W 匹配⾮字⺟或数字或下划线</span><br><span class="line">\D 匹配⾮数字</span><br><span class="line">\S 匹配⾮空⽩符</span><br><span class="line">a|b 匹配字符a或字符b</span><br><span class="line">() 匹配括号内的表达式，也表示⼀个组</span><br><span class="line">[...] 匹配字符组中的字符  # 是否属于[a-zA-Z0-9]</span><br><span class="line">[^...] 匹配除了字符组中字符的所有字符  # 这里^表示非</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">量词: 控制前⾯的元字符出现的次数</span><br><span class="line"></span><br><span class="line">* 重复零次或更多次(尽可能多地去匹配)</span><br><span class="line">+ 重复⼀次或更多次</span><br><span class="line">? 重复零次或⼀次</span><br><span class="line">&#123;n&#125; 重复n次</span><br><span class="line">&#123;n,&#125; 重复n次或更多次</span><br><span class="line">&#123;n,m&#125; 重复n到m次</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">匹配:贪婪匹配和惰性匹配</span><br><span class="line"></span><br><span class="line">.* 贪婪匹配  # 尽可能长的匹配</span><br><span class="line">.*? 惰性匹配  # 回溯到最短的一次匹配</span><br></pre></td></tr></table></figure><h3 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">str: 玩⼉吃鸡游戏, 晚上⼀起上游戏, ⼲嘛呢? 打游戏啊</span><br><span class="line">reg: 玩⼉.*?游戏</span><br><span class="line">结果: 玩⼉吃鸡游戏</span><br><span class="line">reg: 玩⼉.*游戏</span><br><span class="line">结果: 玩⼉吃鸡游戏, 晚上⼀起上游戏, ⼲嘛呢? 打游戏 </span><br><span class="line"> </span><br><span class="line">str: &lt;div&gt;胡辣汤&lt;/div&gt;</span><br><span class="line">reg: &lt;.*&gt;</span><br><span class="line">结果: &lt;div&gt;胡辣汤&lt;/div&gt;</span><br><span class="line">str: &lt;div&gt;胡辣汤&lt;/div&gt;</span><br><span class="line">reg: &lt;.*?&gt;</span><br><span class="line">结果: &lt;div&gt;      &lt;/div&gt;</span><br><span class="line"></span><br><span class="line">str: &lt;div&gt;胡辣汤&lt;/div&gt;&lt;span&gt;饭团&lt;/span&gt;</span><br><span class="line">reg: &lt;div&gt;.*?&lt;/div&gt;</span><br><span class="line">结果: &lt;div&gt;胡辣汤&lt;/div&gt;</span><br></pre></td></tr></table></figure><h2 id="Re模块-Regular-Expression"><a href="#Re模块-Regular-Expression" class="headerlink" title="Re模块(Regular Expression)"></a>Re模块(Regular Expression)</h2><h3 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h3><h4 id="findall"><a href="#findall" class="headerlink" title="findall()"></a>findall()</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># findall: 匹配字符串中所有符合正则的内容，返回list</span></span><br><span class="line">lst = re.findall(<span class="string">r&quot;\d+&quot;</span>, <span class="string">&quot;5点之前. 你要给我5000万&quot;</span>)</span><br><span class="line">print(lst)  </span><br><span class="line"></span><br><span class="line"><span class="comment"># [&#x27;5&#x27;, &#x27;5000&#x27;]</span></span><br></pre></td></tr></table></figure><blockquote><p>字符串前加r防止转义，表示原生字符串（rawstring）。</p><p>不使用r，则匹配时候需要4个反斜杠：正则需要转化一次，python解释器需要转化。</p></blockquote><h4 id="finditer"><a href="#finditer" class="headerlink" title="finditer()"></a>finditer()</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># finditer: 匹配字符串中所有符合正则的内容，返回iter</span></span><br><span class="line">it = re.finditer(<span class="string">r&quot;\d+&quot;</span>, <span class="string">&quot;5点之前. 你要给我5000万&quot;</span>)  <span class="comment"># 字符串前加r防止转义</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> it:</span><br><span class="line">    print(i)</span><br><span class="line">    print(i.group())</span><br><span class="line"></span><br><span class="line"><span class="comment"># &lt;_sre.SRE_Match object; span=(0, 1), match=&#x27;5&#x27;&gt;</span></span><br><span class="line"><span class="comment"># 5</span></span><br><span class="line"><span class="comment"># &lt;_sre.SRE_Match object; span=(10, 14), match=&#x27;5000&#x27;&gt;</span></span><br><span class="line"><span class="comment"># 5000</span></span><br></pre></td></tr></table></figure><ul><li>要使用.group()提取match对象的value</li></ul><h4 id="search"><a href="#search" class="headerlink" title="search()"></a>search()</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># search: 找到第一个就返回，返回的是match，使用group()提取</span></span><br><span class="line">s = re.search(<span class="string">r&quot;\d+&quot;</span>, <span class="string">&quot;5点之前. 你要给我5000万&quot;</span>)</span><br><span class="line">print(s.group())</span><br><span class="line"></span><br><span class="line"><span class="comment"># 5</span></span><br></pre></td></tr></table></figure><h4 id="match"><a href="#match" class="headerlink" title="match()"></a>match()</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># match: 从第一个字符开始要求匹配，返回的是match</span></span><br><span class="line">m = re.match(<span class="string">r&quot;\d+&quot;</span>, <span class="string">&quot;5点之前. 你要给我5000万&quot;</span>)</span><br><span class="line">print(m.group())</span><br><span class="line"></span><br><span class="line"><span class="comment"># 5</span></span><br></pre></td></tr></table></figure><ul><li>如果字符串为<code>&quot;在5点之前. 你要给我5000万&quot;</code>则匹配失败</li><li>相当于自带<code>^</code></li></ul><h4 id="compile"><a href="#compile" class="headerlink" title="compile()"></a>compile()</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">rule = re.<span class="built_in">compile</span>(<span class="string">r&quot;\d+&quot;</span>)</span><br><span class="line">lst = rule.findall(<span class="string">&quot;5点之前. 你要给我5000万&quot;</span>)</span><br><span class="line">print(lst)</span><br><span class="line"></span><br><span class="line"><span class="comment"># [&#x27;5&#x27;, &#x27;5000&#x27;]</span></span><br><span class="line"></span><br><span class="line">m = rule.match(<span class="string">&quot;5点之前. 你要给我5000万&quot;</span>)</span><br><span class="line">print(m.group())</span><br><span class="line"></span><br><span class="line"><span class="comment"># 5</span></span><br></pre></td></tr></table></figure><ul><li>预加载正则表达式</li><li>可以反复使用</li></ul><h4 id="group"><a href="#group" class="headerlink" title="group()"></a>group()</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">s = <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">&lt;div class=&#x27;⻄游记&#x27;&gt;&lt;span id=&#x27;1&#x27;&gt;中国联通&lt;/span&gt;&lt;/div&gt;</span></span><br><span class="line"><span class="string">&lt;div class=&#x27;⻄&#x27;&gt;&lt;span id=&#x27;2&#x27;&gt;中国&lt;/span&gt;&lt;/div&gt;</span></span><br><span class="line"><span class="string">&lt;div class=&#x27;游&#x27;&gt;&lt;span id=&#x27;3&#x27;&gt;联通&lt;/span&gt;&lt;/div&gt;</span></span><br><span class="line"><span class="string">&lt;div class=&#x27;记&#x27;&gt;&lt;span id=&#x27;4&#x27;&gt;中通&lt;/span&gt;&lt;/div&gt;</span></span><br><span class="line"><span class="string">&lt;div class=&#x27;⻄记&#x27;&gt;&lt;span id=&#x27;5&#x27;&gt;国联&lt;/span&gt;&lt;/div&gt;</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line">obj = re.<span class="built_in">compile</span>(<span class="string">r&quot;&lt;div class=&#x27;(?P&lt;class&gt;.*?&#x27;&gt;&lt;span id)=&#x27;(?P&lt;id&gt;\d+)&#x27;&gt;(?P&lt;val&gt;.*?)&lt;/span&gt;&lt;/div&gt;&quot;</span>, re.S)  <span class="comment"># re.S表示使.能够匹配换行符</span></span><br><span class="line">result = obj.search(s)</span><br><span class="line">print(result.group())  <span class="comment"># &lt;div class=&#x27;⻄游记&#x27;&gt;&lt;span id=&#x27;1&#x27;&gt;中国联通&lt;/span&gt;&lt;/div&gt;</span></span><br><span class="line">print(result.group(<span class="string">&quot;id&quot;</span>))  <span class="comment"># 1</span></span><br><span class="line">print(result.group(<span class="string">&quot;val&quot;</span>))  <span class="comment"># 中国联通</span></span><br><span class="line">print(result.group(<span class="string">&quot;class&quot;</span>))  <span class="comment"># ⻄游记&#x27;&gt;&lt;span id</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>分组：使用<code>(?P&lt;变量名&gt;正则表达式)</code>进一步提取内容</li></ul><h3 id="实战案例"><a href="#实战案例" class="headerlink" title="实战案例"></a>实战案例</h3><h4 id="豆瓣top250电影排行"><a href="#豆瓣top250电影排行" class="headerlink" title="豆瓣top250电影排行"></a>豆瓣top250电影排行</h4><ul><li>首先要确认目标数据位置（源码or抓包）</li><li>抓不到的时候首先看<code>User-Agent</code></li><li>次数太频繁的时候记得<code>Keep-Alive</code></li><li>正则表达式写的越详细越容易匹配</li><li>①用<code>\n\s*</code>去匹配换行和空格；②用<code>.strip()</code>去除空格</li><li><code>match.groupdict()</code>转换成字典</li><li><code>newline=&quot;&quot;</code>不使用自动换行符</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> csv</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line"><span class="comment"># 预编译正则表达式: &quot;电影名称&quot;,&quot;上映年份&quot;,&quot;评分&quot;,&quot;评分⼈数&quot;</span></span><br><span class="line">rule = re.<span class="built_in">compile</span>(<span class="string">r&#x27;&lt;li&gt;.*?&lt;span class=&quot;title&quot;&gt;(?P&lt;name&gt;.*?)&lt;/span&gt;.*?&#x27;</span></span><br><span class="line">                  <span class="string">r&#x27;&lt;br&gt;\n\s*(?P&lt;year&gt;\d+)&amp;nbsp;/&amp;nbsp;.*?&#x27;</span></span><br><span class="line">                  <span class="string">r&#x27;property=&quot;v:average&quot;&gt;(?P&lt;score&gt;.*?)&lt;/span&gt;.*?&#x27;</span></span><br><span class="line">                  <span class="string">r&#x27;&lt;span&gt;(?P&lt;person&gt;.*?)人评价&lt;/span&gt;&#x27;</span>, re.S)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 准备文件写入</span></span><br><span class="line">f = <span class="built_in">open</span>(<span class="string">&quot;data.csv&quot;</span>, mode=<span class="string">&quot;w&quot;</span>, encoding=<span class="string">&quot;utf-8&quot;</span>, newline=<span class="string">&quot;&quot;</span>)  <span class="comment"># 设置newline=&quot;&quot;不使用多余换行符</span></span><br><span class="line">csv_writer = csv.writer(f)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取网页源码</span></span><br><span class="line">url = <span class="string">&quot;https://movie.douban.com/top250&quot;</span></span><br><span class="line">headers = &#123;</span><br><span class="line">    <span class="string">&quot;user-agent&quot;</span>: <span class="string">&quot;user-agent&quot;</span>,</span><br><span class="line">    <span class="string">&#x27;Keep-Alive&#x27;</span>: <span class="string">&#x27;timeout=15&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> p <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="number">250</span>, <span class="number">25</span>):</span><br><span class="line">    <span class="comment"># 跳转多个页面</span></span><br><span class="line">    params = &#123;</span><br><span class="line">        <span class="string">&#x27;start&#x27;</span>: p</span><br><span class="line">    &#125;</span><br><span class="line">    resp = requests.get(url=url, headers=headers, params=params)</span><br><span class="line">    <span class="comment"># print(resp.text)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 数据解析</span></span><br><span class="line">    result = rule.finditer(resp.text)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> result:</span><br><span class="line">        <span class="comment"># print(i.group(&quot;name&quot;))</span></span><br><span class="line">        <span class="comment"># print(i.group(&quot;year&quot;))  # 取出空白符也可以使用.strip()</span></span><br><span class="line">        <span class="comment"># print(i.group(&quot;score&quot;))</span></span><br><span class="line">        <span class="comment"># print(i.group(&quot;person&quot;))</span></span><br><span class="line">        dic = i.groupdict()  <span class="comment"># 转换成dict</span></span><br><span class="line">        print(dic)</span><br><span class="line">        csv_writer.writerow(dic.values())</span><br><span class="line"></span><br><span class="line">f.close()</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="电影天堂板块信息"><a href="#电影天堂板块信息" class="headerlink" title="电影天堂板块信息"></a>电影天堂板块信息</h4><ul><li>html中标签<code>&lt;a href=&#39;url&#39;&gt;xxx&lt;/a&gt;</code>表示超链接</li><li>当编码不一致时，根据网页源代码的标注信息<code>charset=gb2312</code>进行修正： <code>resp.encoding = &quot;gb2312&quot;</code></li><li><code>verify=False</code>去除安全认证</li><li>拼接域名时要注意<code>/</code>数量</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line"><span class="comment"># 1.获取主页源码</span></span><br><span class="line">domain = <span class="string">&quot;https://www.dytt89.com/&quot;</span></span><br><span class="line">resp = requests.get(domain, verify=<span class="literal">False</span>)  <span class="comment"># 去除安全认证</span></span><br><span class="line">resp.encoding = <span class="string">&quot;gb2312&quot;</span>  <span class="comment"># 修改成指定字符集</span></span><br><span class="line"><span class="comment"># print(resp.text)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 2.定位2021必看片板块</span></span><br><span class="line">rule1 = re.<span class="built_in">compile</span>(<span class="string">r&quot;2021必看热片.*?&lt;ul&gt;(?P&lt;ul&gt;.*?)&lt;/ul&gt;&quot;</span>, re.S)</span><br><span class="line">result1 = rule1.search(resp.text)</span><br><span class="line">ul = result1.group(<span class="string">&quot;ul&quot;</span>).strip()</span><br><span class="line"><span class="comment"># print(ul)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 3.从板块中提取子页面的链接地址</span></span><br><span class="line">rule2 = re.<span class="built_in">compile</span>(<span class="string">r&quot;href=&#x27;(?P&lt;href&gt;.*?)&#x27;&quot;</span>, re.S)</span><br><span class="line">result2 = rule2.finditer(ul)</span><br><span class="line">child_href_list = []</span><br><span class="line"><span class="keyword">for</span> h <span class="keyword">in</span> result2:</span><br><span class="line">    child_href = domain + h.group(<span class="string">&quot;href&quot;</span>).strip(<span class="string">&quot;/&quot;</span>)  <span class="comment"># domain中也有/，去掉一个</span></span><br><span class="line">    child_href_list.append(child_href)</span><br><span class="line">    <span class="comment"># print(child_href)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 4.请求子页面地址，拿到下载地址</span></span><br><span class="line">rule3 = re.<span class="built_in">compile</span>(<span class="string">r&#x27;&lt;meta name=keywords content=&quot;(?P&lt;name&gt;.*?)下载&quot;&gt;.*?&#x27;</span></span><br><span class="line">                   <span class="string">r&#x27;&lt;td style=&quot;WORD-WRAP: break-word&quot; bgcolor=&quot;#fdfddf&quot;&gt;&lt;a href=&quot;(?P&lt;download&gt;.*?)&quot;&gt;&#x27;</span>, re.S)</span><br><span class="line">download_list = &#123;&#125;</span><br><span class="line"><span class="keyword">for</span> c <span class="keyword">in</span> child_href_list:</span><br><span class="line">    child_resp = requests.get(c, verify=<span class="literal">False</span>)  <span class="comment"># 去除安全认证</span></span><br><span class="line">    child_resp.encoding = <span class="string">&quot;gb2312&quot;</span>  <span class="comment"># 修改成指定字符集</span></span><br><span class="line">    result3 = rule3.search(child_resp.text)</span><br><span class="line">    download_list[result3.group(<span class="string">&quot;name&quot;</span>)] = result3.group(<span class="string">&quot;download&quot;</span>)</span><br><span class="line">    </span><br><span class="line"><span class="keyword">for</span> d <span class="keyword">in</span> download_list.items():</span><br><span class="line">    print(d)</span><br></pre></td></tr></table></figure><h2 id="Bs4模块-Beautiful-Soup"><a href="#Bs4模块-Beautiful-Soup" class="headerlink" title="Bs4模块(Beautiful Soup)"></a>Bs4模块(Beautiful Soup)</h2><h3 id="html语法规则"><a href="#html语法规则" class="headerlink" title="html语法规则"></a>html语法规则</h3><p>HTML(Hyper Text Markup Language)超文本标记语言，是我们编写网页的最基本也是最核心的⼀种语⾔，其语法规则就是用不同的标签对网页上的内容进行标记，从⽽使网页显示出不同的展示效果。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--第一种标记--&gt;</span></span><br><span class="line">&lt;标签 </span><br><span class="line">    属性=&quot;值&quot; </span><br><span class="line">    属性=&quot;值&quot;&gt;</span><br><span class="line">    被标记的内容</span><br><span class="line">&lt;/标签&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--第二种标记--&gt;</span></span><br><span class="line">&lt;标签 属性=&quot;值&quot; </span><br><span class="line">    属性=&quot;值&quot;/&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="基本使用-1"><a href="#基本使用-1" class="headerlink" title="基本使用"></a>基本使用</h3><p>通过网页源码建立<code>BeautifulSoup</code>对象，来检索页面源代码中的html标签。</p><ul><li><code>find(标签, 属性=值)</code>  只找一个</li><li><code>find_all(标签, 属性=值)</code>  找出所有</li></ul><h3 id="实战案例-1"><a href="#实战案例-1" class="headerlink" title="实战案例"></a>实战案例</h3><h4 id="新发地菜价"><a href="#新发地菜价" class="headerlink" title="新发地菜价"></a>新发地菜价</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> csv</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup</span><br><span class="line"></span><br><span class="line">url = <span class="string">&quot;http://www.xinfadi.com.cn/marketanalysis/0/list/1.shtml&quot;</span></span><br><span class="line">resp = requests.get(url)</span><br><span class="line"></span><br><span class="line">f = <span class="built_in">open</span>(<span class="string">&quot;菜价.csv&quot;</span>, mode=<span class="string">&quot;w&quot;</span>, encoding=<span class="string">&quot;utf-8&quot;</span>, newline=<span class="string">&quot;&quot;</span>)</span><br><span class="line">csv_writer = csv.writer(f)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 1. 把页面源代码交给BeautifulSoup进行处理, 生成bs对象</span></span><br><span class="line">page = BeautifulSoup(resp.text, <span class="string">&quot;html.parser&quot;</span>)  <span class="comment"># 指定html解析器</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 从bs对象中查找数据，找到目标表格</span></span><br><span class="line">attrs = &#123;</span><br><span class="line">    <span class="string">&quot;class&quot;</span>: <span class="string">&quot;hq_table&quot;</span></span><br><span class="line">&#125;</span><br><span class="line">table = page.find(<span class="string">&quot;table&quot;</span>, attrs=attrs)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. 拿到有效的数据行</span></span><br><span class="line">trs = table.find_all(<span class="string">&quot;tr&quot;</span>)[<span class="number">1</span>:]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 4. 对每行数据分解属性</span></span><br><span class="line"><span class="keyword">for</span> tr <span class="keyword">in</span> trs:</span><br><span class="line">    tds = tr.find_all(<span class="string">&quot;td&quot;</span>)  <span class="comment"># 拿到每行中的td</span></span><br><span class="line">    name = tds[<span class="number">0</span>].text  <span class="comment"># .text 表示拿到被标签标记的内容</span></span><br><span class="line">    low = tds[<span class="number">1</span>].text</span><br><span class="line">    avg = tds[<span class="number">2</span>].text</span><br><span class="line">    high = tds[<span class="number">3</span>].text</span><br><span class="line">    spec = tds[<span class="number">4</span>].text  <span class="comment"># 规格</span></span><br><span class="line">    unit = tds[<span class="number">5</span>].text  <span class="comment"># 单位</span></span><br><span class="line">    day = tds[<span class="number">6</span>].text  <span class="comment"># 发布日期</span></span><br><span class="line">    print(name, low, avg, high, spec, unit, day)</span><br><span class="line">    csv_writer.writerow([name, low, avg, high, spec, unit, day])</span><br><span class="line"></span><br><span class="line">f.close()</span><br></pre></td></tr></table></figure><ul><li><p>这里通过URL可以发现</p></li><li><p>规避Python关键字属性的方法</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">table = page.find(<span class="string">&quot;table&quot;</span>, class_=<span class="string">&quot;hq_table&quot;</span>)</span><br><span class="line">table = page.find(<span class="string">&quot;table&quot;</span>, attrs=&#123;<span class="string">&quot;class&quot;</span>: <span class="string">&quot;hq_table&quot;</span>&#125;)</span><br></pre></td></tr></table></figure><h4 id="优美图库"><a href="#优美图库" class="headerlink" title="优美图库"></a>优美图库</h4></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup</span><br><span class="line"></span><br><span class="line">url = <span class="string">&quot;https://www.umei.cc/bizhitupian/weimeibizhi/&quot;</span></span><br><span class="line">resp = requests.get(url=url)</span><br><span class="line">resp.encoding = <span class="string">&quot;utf-8&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 解析主页面</span></span><br><span class="line">main_page = BeautifulSoup(resp.text, <span class="string">&quot;html.parser&quot;</span>)</span><br><span class="line">a_list = main_page.find(<span class="string">&quot;div&quot;</span>, class_=<span class="string">&quot;TypeList&quot;</span>).find_all(<span class="string">&quot;a&quot;</span>)</span><br><span class="line"><span class="keyword">for</span> a <span class="keyword">in</span> a_list:</span><br><span class="line">    href = url + a.get(<span class="string">&quot;href&quot;</span>).split(<span class="string">&quot;/&quot;</span>)[-<span class="number">1</span>]  <span class="comment"># 手动拼接url</span></span><br><span class="line">    <span class="comment"># print(href)</span></span><br><span class="line">    child_page_resp = requests.get(href)</span><br><span class="line">    child_page_resp.encoding = <span class="string">&quot;utf-8&quot;</span></span><br><span class="line">    <span class="comment"># 解析子界面</span></span><br><span class="line">    child_page = BeautifulSoup(child_page_resp.text, <span class="string">&quot;html.parser&quot;</span>)</span><br><span class="line">    p = child_page.find(<span class="string">&quot;p&quot;</span>, align=<span class="string">&quot;center&quot;</span>)  <span class="comment"># 找到标签为p、居中对齐的超文本</span></span><br><span class="line">    img = p.find(<span class="string">&quot;img&quot;</span>)  <span class="comment"># 找到标签为img的超文本</span></span><br><span class="line">    src = img.get(<span class="string">&quot;src&quot;</span>)  <span class="comment"># 取出src属性的值</span></span><br><span class="line">    <span class="comment"># 下载图片</span></span><br><span class="line">    img_resp = requests.get(src)  <span class="comment"># 该响应文件本身就是图片</span></span><br><span class="line">    img_name = src.split(<span class="string">&quot;/&quot;</span>)[-<span class="number">1</span>]  <span class="comment"># 设定文件名</span></span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;source/&quot;</span> + img_name, mode=<span class="string">&quot;wb&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        f.write(img_resp.content)  <span class="comment"># 将拿到的响应内容以字节流形式写入文件</span></span><br><span class="line">    print(img_name + <span class="string">&quot; has been downloaded!&quot;</span>)</span><br></pre></td></tr></table></figure><h2 id="Xpath"><a href="#Xpath" class="headerlink" title="Xpath"></a>Xpath</h2><h3 id="基本使用-2"><a href="#基本使用-2" class="headerlink" title="基本使用"></a>基本使用</h3><p>XPath是一门在 XML 文档中查找信息的语言。XPath可⽤来在 XML文档中对元素和属性进行遍历，而我们熟知的HTML恰巧属于XML的⼀个⼦集，所以完全可以用Xpath去查找html中的内容。</p><ul><li>demo1：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> lxml <span class="keyword">import</span> etree</span><br><span class="line"></span><br><span class="line">xml = <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">&lt;book&gt;</span></span><br><span class="line"><span class="string">    &lt;id&gt;1&lt;/id&gt;</span></span><br><span class="line"><span class="string">    &lt;name&gt;野花遍地⾹&lt;/name&gt;</span></span><br><span class="line"><span class="string">    &lt;price&gt;1.23&lt;/price&gt;</span></span><br><span class="line"><span class="string">    &lt;nick&gt;臭⾖腐&lt;/nick&gt;</span></span><br><span class="line"><span class="string">    &lt;author&gt;</span></span><br><span class="line"><span class="string">        &lt;nick id=&quot;10086&quot;&gt;周⼤强&lt;/nick&gt;</span></span><br><span class="line"><span class="string">        &lt;nick id=&quot;10010&quot;&gt;周芷若&lt;/nick&gt;</span></span><br><span class="line"><span class="string">        &lt;nick class=&quot;joy&quot;&gt;周杰伦&lt;/nick&gt;</span></span><br><span class="line"><span class="string">        &lt;nick class=&quot;jolin&quot;&gt;蔡依林&lt;/nick&gt;</span></span><br><span class="line"><span class="string">        &lt;div&gt;</span></span><br><span class="line"><span class="string">            &lt;nick&gt;惹了&lt;/nick&gt;</span></span><br><span class="line"><span class="string">        &lt;/div&gt;</span></span><br><span class="line"><span class="string">    &lt;/author&gt;</span></span><br><span class="line"><span class="string">    &lt;partner&gt;</span></span><br><span class="line"><span class="string">        &lt;nick id=&quot;ppc&quot;&gt;胖胖陈&lt;/nick&gt;</span></span><br><span class="line"><span class="string">        &lt;nick id=&quot;ppbc&quot;&gt;胖胖不陈&lt;/nick&gt;</span></span><br><span class="line"><span class="string">    &lt;/partner&gt;</span></span><br><span class="line"><span class="string">&lt;/book&gt;</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">tree = etree.XML(xml)</span><br><span class="line">result = tree.xpath(<span class="string">&quot;/book&quot;</span>)  <span class="comment"># [&lt;Element book at 0x26943009048&gt;]</span></span><br><span class="line">result = tree.xpath(<span class="string">&quot;/book/name&quot;</span>)  <span class="comment"># [&lt;Element name at 0x2403a5ffb48&gt;]</span></span><br><span class="line">result = tree.xpath(<span class="string">&quot;/book/name/text()&quot;</span>)  <span class="comment"># [&#x27;野花遍地⾹&#x27;]</span></span><br><span class="line">result = tree.xpath(<span class="string">&quot;/book/author/nick&quot;</span>)  <span class="comment"># [&lt;Element nick at 0x2702b1dfb08&gt;, ……, &lt;Element nick at 0x2702b3516c8&gt;]</span></span><br><span class="line">result = tree.xpath(<span class="string">&quot;/book/author/nick/text()&quot;</span>)  <span class="comment"># [&#x27;周⼤强&#x27;, &#x27;周芷若&#x27;, &#x27;周杰伦&#x27;, &#x27;蔡依林&#x27;]</span></span><br><span class="line">result = tree.xpath(<span class="string">&quot;/book/author/div/nick/text()&quot;</span>)  <span class="comment"># [&#x27;惹了&#x27;]</span></span><br><span class="line">result = tree.xpath(<span class="string">&quot;/book/author//nick/text()&quot;</span>)  <span class="comment"># 任意层后代 [&#x27;周⼤强&#x27;, &#x27;周芷若&#x27;, &#x27;周杰伦&#x27;, &#x27;蔡依林&#x27;, &#x27;惹了&#x27;]</span></span><br><span class="line">result = tree.xpath(<span class="string">&quot;/book/author/*/nick/text()&quot;</span>)  <span class="comment"># 单层通配符 [&#x27;惹了&#x27;]</span></span><br><span class="line"></span><br><span class="line">print(result)</span><br></pre></td></tr></table></figure><ul><li>demo2：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> lxml <span class="keyword">import</span> etree</span><br><span class="line"></span><br><span class="line">tree = etree.parse(<span class="string">&quot;my_html.html&quot;</span>)</span><br><span class="line">result = tree.xpath(<span class="string">&quot;/html/body/ul/li/a/text()&quot;</span>)  <span class="comment"># [&#x27;百度&#x27;, &#x27;⾕歌&#x27;, &#x27;搜狗&#x27;]  使用开发者工具快速定位xpath</span></span><br><span class="line">result = tree.xpath(<span class="string">&quot;/html/body/ul/li[1]/a/text()&quot;</span>)  <span class="comment"># [&#x27;百度&#x27;]  从1开始计数</span></span><br><span class="line">result = tree.xpath(<span class="string">&quot;/html/body/ol/li/a[@href=&#x27;dapao&#x27;]/text()&quot;</span>)  <span class="comment"># [&#x27;⼤炮&#x27;]  属性筛选</span></span><br><span class="line">result_list = tree.xpath(<span class="string">&quot;/html/body/ol/li&quot;</span>)</span><br><span class="line"><span class="keyword">for</span> result <span class="keyword">in</span> result_list:</span><br><span class="line">    r1 = result.xpath(<span class="string">&quot;./a/text()&quot;</span>)</span><br><span class="line">    print(r1)  <span class="comment"># ./ 当前位置</span></span><br><span class="line">    r2 = result.xpath(<span class="string">&quot;./a/@href&quot;</span>)</span><br><span class="line">    print(r2)  <span class="comment"># @ 提取属性值</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="开发者工具使用技巧"><a href="#开发者工具使用技巧" class="headerlink" title="开发者工具使用技巧"></a>开发者工具使用技巧</h3><ul><li>快速定位网页资源在HTML中的位置</li></ul><p><img src="/2021/05/%E7%88%AC%E8%99%ABPart2/image-20210602214418408.png" alt="image-20210602214418408"></p><ul><li>快速获取XPath，并做一些微调</li></ul><p><img src="/2021/05/%E7%88%AC%E8%99%ABPart2/image-20210602214849284.png" alt="image-20210602214849284"></p><h3 id="实战案例-2"><a href="#实战案例-2" class="headerlink" title="实战案例"></a>实战案例</h3><h4 id="猪八戒网"><a href="#猪八戒网" class="headerlink" title="猪八戒网"></a>猪八戒网</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">from</span> lxml <span class="keyword">import</span> etree</span><br><span class="line"><span class="keyword">import</span> csv</span><br><span class="line"></span><br><span class="line">f = <span class="built_in">open</span>(<span class="string">&quot;猪八戒.csv&quot;</span>, mode=<span class="string">&quot;w&quot;</span>, encoding=<span class="string">&quot;utf-8&quot;</span>, newline=<span class="string">&quot;&quot;</span>)</span><br><span class="line">csv_writer = csv.writer(f)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获得主页面</span></span><br><span class="line">url = <span class="string">&quot;https://beijing.zbj.com/search/f/?type=new&amp;kw=saas&quot;</span></span><br><span class="line">resp = requests.get(url=url)</span><br><span class="line">html = etree.HTML(resp.text)</span><br><span class="line">divs = html.xpath(<span class="string">&quot;/html/body/div[6]/div/div/div[2]/div[5]/div[1]/div&quot;</span>)  <span class="comment"># 先定位到div[1]，然后改成div</span></span><br><span class="line"><span class="comment"># 每一个服务商</span></span><br><span class="line"><span class="keyword">for</span> div <span class="keyword">in</span> divs:</span><br><span class="line">    price = div.xpath(<span class="string">&#x27;./div/div/a[1]/div[2]/div[1]/span[1]/text()&#x27;</span>)[<span class="number">0</span>].strip(<span class="string">&quot;¥&quot;</span>)  <span class="comment"># 使用工具定位完整xpath，然后将重复地址替换./</span></span><br><span class="line">    title = <span class="string">&quot;SAAS&quot;</span>.join(div.xpath(<span class="string">&#x27;./div/div/a[1]/div[2]/div[2]/p/text()&#x27;</span>))  <span class="comment"># join()通过指定字符连接序列中元素，生成新字符串</span></span><br><span class="line">    company_name = div.xpath(<span class="string">&#x27;./div/div/a[2]/div[1]/p/text()&#x27;</span>)[<span class="number">0</span>]</span><br><span class="line">    location = div.xpath(<span class="string">&quot;./div/div/a[2]/div[1]/div/span/text()&quot;</span>)[<span class="number">0</span>]</span><br><span class="line">    csv_writer.writerow([price, title, company_name, location])</span><br><span class="line">    print([price, title, company_name, location])</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 爬虫 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>爬虫Part1</title>
      <link href="/2021/05/%E7%88%AC%E8%99%ABPart1/"/>
      <url>/2021/05/%E7%88%AC%E8%99%ABPart1/</url>
      
        <content type="html"><![CDATA[<h1 id="爬虫Part1——原理与request入门"><a href="#爬虫Part1——原理与request入门" class="headerlink" title="爬虫Part1——原理与request入门"></a>爬虫Part1——原理与request入门</h1><p>[TOC]</p><h2 id="基本知识"><a href="#基本知识" class="headerlink" title="基本知识"></a>基本知识</h2><p>爬虫：模拟浏览器抓取网站资源。</p><p>爬⾍在法律上是不被禁⽌的，但是也具有违法⻛险。因此使用爬虫我们要做到：</p><ul><li>不能影响⽹站的正常运营</li><li>不能窃取⽤户隐私和商业机密等敏感内容</li><li>遵循 robots.txt 协议</li></ul><h2 id="第一个爬虫"><a href="#第一个爬虫" class="headerlink" title="第一个爬虫"></a>第一个爬虫</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> urllib.request <span class="keyword">import</span> urlopen</span><br><span class="line"></span><br><span class="line">url = <span class="string">&quot;https://www.baidu.com&quot;</span></span><br><span class="line">resp = urlopen(url)</span><br><span class="line"></span><br><span class="line">print(resp)  <span class="comment"># 响应地址 &lt;http.client.HTTPResponse object at 0x00000174ADF4F128&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;my_baidu.html&quot;</span>, mode=<span class="string">&quot;w&quot;</span>, encoding=<span class="string">&quot;utf-8&quot;</span>) <span class="keyword">as</span> f:  <span class="comment"># 写入保存网页源代码</span></span><br><span class="line">    f.write(resp.read().decode(<span class="string">&quot;utf-8&quot;</span>))  <span class="comment"># resp不能read()两次</span></span><br></pre></td></tr></table></figure><ul><li>在win10中必须加上 utf-8，否则使用环境默认值 gbk</li><li>网页本质就是html文件</li><li>在网页源码中有标记解码方式</li></ul><blockquote><p>使用edge要在 <a href="https://msedgewebdriverstorage.z22.web.core.windows.net/">官网</a> 下载对应版本的driver，pycharm中用浏览器打开地址都使用driver：</p><p>driver放在python根目录下：D:\Programming Kits\Python36\msedgedriver.exe</p><p>edge默认在：C:\Program Files (x86)\Microsoft\Edge\Application\msedge.exe</p></blockquote><h2 id="Web请求过程解析"><a href="#Web请求过程解析" class="headerlink" title="Web请求过程解析"></a>Web请求过程解析</h2><p>网页上所有的数据不一定全在页面源代码中，这关系到常⻅的两种⻚⾯渲染过程：</p><ol><li><p>服务器渲染</p><p>在请求到服务器的时候，服务器直接把数据全部写入到html中，因此我们能直接拿到带有数据的html内容，我们能看到的数据都在页面源代码中能找的到。</p></li><li><p>前端JS渲染</p><p>这种机制⼀般是第⼀次请求服务器返回基本的HTML框架结构，然后再次请求到数据库服务器，由这个服务器返回数据，最后在浏览器上对数据进⾏加载。</p><p>这便对应异步请求，在我们进行页面滚动时，浏览器向服务器发送数据请求。</p><p>这样做的好处是服务器缓解压力，而且分工明确，容易维护。</p></li></ol><p>两种渲染对于爬虫都各有利弊。</p><h2 id="Http协议"><a href="#Http协议" class="headerlink" title="Http协议"></a>Http协议</h2><p>协议：就是两个计算机之间为了能够流畅的进⾏沟通⽽设置的⼀个协定。常⻅的协议有TCP/IP、SOAP协议、HTTP协议、SMTP协议等等…..</p><ul><li>HTTP协议，超⽂本传输协议（Hyper Text Transfer Protocol）的缩写，是⽤于从万维⽹（WWW：World Wide Web）服务器传输超⽂本到本地浏览器的传送协议。</li><li>HTTP协议把⼀条消息分为三⼤块内容。</li></ul><p>请求：</p><ul><li>请求行 -&gt; 请求方式（method:get/post）、请求地址（authority:url）、协议（scheme:https）、浏览器接受数据的要求（accept:）</li><li>请求头 -&gt; 服务器要使用的附加信息（cookie），设备和浏览器信息（user-agent:）</li><li>请求体 -&gt; 请求参数</li></ul><p>响应：</p><ul><li>状态⾏ -&gt; 协议、状态码（200请求成功/404页面不存在/500服务器崩溃/302重定向）</li><li>响应头 -&gt; 客户端要使⽤的附加信息</li><li>响应体 -&gt; 服务器返回客户端真正要⽤的内容（HTML、json等）</li></ul><p>写爬⾍的时候要格外注意请求头和响应头，这两个地⽅⼀般都隐含着⼀些⽐较重要的内容。</p><p><img src="/2021/05/%E7%88%AC%E8%99%ABPart1/image-20210519182940008.png" alt="image-20210519182940008"></p><p>请求头中最常⻅的⼀些重要内容（爬⾍需要）:</p><ol><li><p>User-Agent：请求载体的身份标识（用啥发送的请求）</p></li><li><p>Referer：防盗链（这次请求是从哪个页面来的，反爬会⽤到）</p></li><li><p>cookie：本地字符串数据信息（用户登录信息，反爬的token）</p></li></ol><p>响应头中⼀些重要的内容:</p><ol><li><p>cookie</p></li><li><p>各种神奇的莫名其妙的字符串（⼀般都是token字样, 防止各种攻击和反爬）</p></li></ol><p>请求⽅式：</p><ol><li>GET：显式提交。主要从服务器获取数据</li><li>POST：隐式提交。主要向服务器传送数据</li></ol><blockquote><p>如果请求的方式是get或head，则只发送消息头到服务器；如果是post请求，那么消息体（网页表单内容）和消息头都将传送到服务器。因此，用get速度更快，但由于url暴露在用户面前，可能导致sql注入等非法攻击； 用post提交，速度会慢一些，但是由于url是隐藏在了表单中，所以安全性会好一点。这就是为什么，一般登录页面都用post提交而不用get提交。</p></blockquote><h2 id="request入门"><a href="#request入门" class="headerlink" title="request入门"></a>request入门</h2><h3 id="GET显式提交"><a href="#GET显式提交" class="headerlink" title="GET显式提交"></a>GET显式提交</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line">query = <span class="string">&quot;Python&quot;</span></span><br><span class="line">url = <span class="string">f&quot;https://www.baidu.com/s?wd=<span class="subst">&#123;query&#125;</span>&quot;</span></span><br><span class="line">headers = &#123;</span><br><span class="line">    <span class="string">&quot;user-agent&quot;</span>: <span class="string">&quot;your-user-agent&quot;</span></span><br><span class="line">&#125;  <span class="comment"># 设置user-agent以处理反爬</span></span><br><span class="line">reps = requests.get(url=url, headers=headers)</span><br><span class="line"></span><br><span class="line">print(reps)  <span class="comment"># &lt;Response [200]&gt;</span></span><br><span class="line"><span class="comment"># print(reps.text)  # 页面源代码</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;Python.html&quot;</span>, mode=<span class="string">&quot;w&quot;</span>, encoding=<span class="string">&quot;utf-8&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    f.write(reps.text)</span><br></pre></td></tr></table></figure><ul><li>地址栏链接统一都是GET方式</li></ul><h3 id="POST隐式提交"><a href="#POST隐式提交" class="headerlink" title="POST隐式提交"></a>POST隐式提交</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line">url = <span class="string">&quot;https://fanyi.baidu.com/sug&quot;</span></span><br><span class="line">kw = <span class="string">&quot;dog&quot;</span></span><br><span class="line">data = &#123;</span><br><span class="line">    <span class="string">&quot;kw&quot;</span>: kw</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">resp = requests.post(url, data=data)</span><br><span class="line">print(resp.json())</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">&#123;&#x27;errno&#x27;: 0,</span></span><br><span class="line"><span class="string"> &#x27;data&#x27;: [&#123;&#x27;k&#x27;: &#x27;dog&#x27;, &#x27;v&#x27;: &#x27;n. 狗; 蹩脚货; 丑女人; 卑鄙小人 v. 困扰; 跟踪&#x27;&#125;, </span></span><br><span class="line"><span class="string">          &#123;&#x27;k&#x27;: &#x27;DOG&#x27;, &#x27;v&#x27;: &#x27;abbr. Data Output Gate 数据输出门&#x27;&#125;,</span></span><br><span class="line"><span class="string">          &#123;&#x27;k&#x27;: &#x27;doge&#x27;, &#x27;v&#x27;: &#x27;n. 共和国总督&#x27;&#125;, </span></span><br><span class="line"><span class="string">          &#123;&#x27;k&#x27;: &#x27;dogm&#x27;, &#x27;v&#x27;: &#x27;abbr. dogmatic 教条的; 独断的; dogmatism 教条主义; dogmatist&#x27;&#125;,</span></span><br><span class="line"><span class="string">          &#123;&#x27;k&#x27;: &#x27;Dogo&#x27;, &#x27;v&#x27;: &#x27;[地名] [马里、尼日尔、乍得] 多戈; [地名] [韩国] 道高&#x27;&#125;]</span></span><br><span class="line"><span class="string"> &#125;</span></span><br><span class="line"><span class="string"> &quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure><ul><li>对于像翻译这种发送请求才能接收数据的使用post，并且要注意请求的url。</li><li>一般第二次请求都是Type：xhr</li></ul><h3 id="带参数的get请求"><a href="#带参数的get请求" class="headerlink" title="带参数的get请求"></a>带参数的get请求</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line">url = <span class="string">&quot;https://movie.douban.com/j/chart/top_list&quot;</span></span><br><span class="line"></span><br><span class="line">params = &#123;</span><br><span class="line">    <span class="string">&#x27;type&#x27;</span>: <span class="string">&#x27;16&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;interval_id&#x27;</span>: <span class="string">&#x27;100:90&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;action&#x27;</span>: <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;start&#x27;</span>: <span class="number">0</span>,</span><br><span class="line">    <span class="string">&#x27;limit&#x27;</span>: <span class="number">20</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">headers = &#123;</span><br><span class="line">    <span class="string">&#x27;user-agent&#x27;</span>: <span class="string">&quot;user-agent&quot;</span>, </span><br><span class="line">    <span class="string">&#x27;Keep-Alive&#x27;</span>: <span class="string">&#x27;timeout=30&#x27;</span>  <span class="comment"># 或者&#x27;false&#x27;用来关闭连接</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">resp = requests.get(url, params=params, headers=headers)</span><br><span class="line">print(resp.request.url)  <span class="comment"># 带参数的网址</span></span><br><span class="line">print(resp.request.headers[<span class="string">&quot;user-agent&quot;</span>])  <span class="comment"># python-requests/2.25.1  大小写不敏感</span></span><br><span class="line">print(resp.json())</span><br><span class="line"><span class="comment"># resp.close()  # 关闭连接</span></span><br></pre></td></tr></table></figure><ul><li>url地址的 ‘?’ 后面是get请求的参数（query string parameter）</li><li>python模拟的user-agent为：python-requests/2.25.1</li><li>一般出现问题，首先检查headers的user-agent</li></ul>]]></content>
      
      
      <categories>
          
          <category> 爬虫 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Docker基础-完结目录</title>
      <link href="/2021/04/Docker%E5%9F%BA%E7%A1%80-%E5%AE%8C%E7%BB%93%E7%9B%AE%E5%BD%95/"/>
      <url>/2021/04/Docker%E5%9F%BA%E7%A1%80-%E5%AE%8C%E7%BB%93%E7%9B%AE%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<h1 id="Docker基础——完结目录"><a href="#Docker基础——完结目录" class="headerlink" title="Docker基础——完结目录"></a>Docker基础——完结目录</h1><p>教程视频传送门：</p><ol><li><a href="https://www.bilibili.com/video/BV1og4y1q7M4?p=1">【狂神说Java】Docker最新超详细版教程通俗易懂</a></li></ol><p>讲的通俗易懂，循序渐进，但是需要自己过后再重新梳理一遍、详细总结。</p><p>==part2、part6还有Nginx、Tomcat、ES+Kibana、Redis、springboot部署==</p><table><thead><tr><th align="center"><a href="/2021/04/Docker%E5%9F%BA%E7%A1%80Part1/">DockerPart1——概述</a></th></tr></thead><tbody><tr><td align="center"><strong><a href="/2021/04/Docker%E5%9F%BA%E7%A1%80Part2/">DockerPart2——基本命令</a></strong></td></tr><tr><td align="center"><strong><a href="/2021/04/Docker%E5%9F%BA%E7%A1%80Part3/">Docker基础Part3——镜像讲解</a></strong></td></tr><tr><td align="center"><strong><a href="/2021/04/Docker%E5%9F%BA%E7%A1%80Part4/">Docker基础Part4——数据卷</a></strong></td></tr><tr><td align="center"><strong><a href="/2021/04/Docker%E5%9F%BA%E7%A1%80Part5/">Docker基础Part5——DockerFlie</a></strong></td></tr><tr><td align="center"><strong><a href="/2021/04/Docker%E5%9F%BA%E7%A1%80Part6/">Docker基础Part6——Docker网络</a></strong></td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> Docker基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker基础Part6</title>
      <link href="/2021/04/Docker%E5%9F%BA%E7%A1%80Part6/"/>
      <url>/2021/04/Docker%E5%9F%BA%E7%A1%80Part6/</url>
      
        <content type="html"><![CDATA[<h1 id="Docker基础Part6——Docker网络"><a href="#Docker基础Part6——Docker网络" class="headerlink" title="Docker基础Part6——Docker网络"></a>Docker基础Part6——Docker网络</h1><p>[TOC]</p><h2 id="Docker0"><a href="#Docker0" class="headerlink" title="Docker0"></a>Docker0</h2><h3 id="veth-pair"><a href="#veth-pair" class="headerlink" title="veth-pair"></a>veth-pair</h3><p><a href="https://www.cnblogs.com/bakari/p/10613710.html">https://www.cnblogs.com/bakari/p/10613710.html</a></p><ul><li>只要安装了docker，就会有docker0桥接模式，使用的是veth-pair技术。</li><li>veth-pair 就是一对的虚拟设备接口，他们都是成对出现的，一端连着协议，一端彼此相连。</li><li>OpenStac、Docker容器之间的连接、OVS的连接，都是使用evth-pair技术。</li></ul><h3 id="主机与容器的网络"><a href="#主机与容器的网络" class="headerlink" title="主机与容器的网络"></a>主机与容器的网络</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1.查看主机网络地址</span></span><br><span class="line">[root@VM-1-14-centos ~]<span class="comment"># ip addr</span></span><br><span class="line">1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000</span><br><span class="line">    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00</span><br><span class="line">    inet 127.0.0.1/8 scope host lo  <span class="comment"># lo 本机回环地址</span></span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">    inet6 ::1/128 scope host </span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">2: eth0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc mq state UP group default qlen 1000</span><br><span class="line">    link/ether 52:54:00:23:6f:89 brd ff:ff:ff:ff:ff:ff</span><br><span class="line">    inet 172.17.1.14/20 brd 172.17.15.255 scope global eth0 <span class="comment"># eth0 阿里云内网地址</span></span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">    inet6 fe80::5054:ff:fe23:6f89/64 scope link </span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">3: docker0: &lt;NO-CARRIER,BROADCAST,MULTICAST,UP&gt; mtu 1500 qdisc noqueue state DOWN group default </span><br><span class="line">    link/ether 02:42:76:5e:c5:42 brd ff:ff:ff:ff:ff:ff</span><br><span class="line">    inet 172.18.0.1/16 brd 172.18.255.255 scope global docker0  <span class="comment"># docker0 docker地址</span></span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">    inet6 fe80::42:76ff:fe5e:c542/64 scope link </span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">       </span><br><span class="line"><span class="comment"># 2.运行Tomcat</span></span><br><span class="line">[root@VM-1-14-centos ~]<span class="comment"># docker run -d -P --name tomcat01 tomcat</span></span><br><span class="line">......</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3.查看容器内网络地址</span></span><br><span class="line">[root@VM-1-14-centos ~]<span class="comment"># docker exec -it tomcat01 ip addr</span></span><br><span class="line">1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000</span><br><span class="line">    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00</span><br><span class="line">    inet 127.0.0.1/8 scope host lo</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">582: eth0@if583: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue state UP group default </span><br><span class="line">    link/ether 02:42:ac:12:00:02 brd ff:ff:ff:ff:ff:ff link-netnsid 0</span><br><span class="line">    inet 172.18.0.2/16 brd 172.18.255.255 scope global eth0</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">       </span><br><span class="line"><span class="comment"># 4.在Linux主机可以ping通容器</span></span><br><span class="line">[root@VM-1-14-centos ~]<span class="comment"># ping 172.18.0.2</span></span><br><span class="line">PING 172.18.0.2 (172.18.0.2) 56(84) bytes of data.</span><br><span class="line">64 bytes from 172.18.0.2: icmp_seq=1 ttl=64 time=0.062 ms</span><br><span class="line">64 bytes from 172.18.0.2: icmp_seq=2 ttl=64 time=0.049 ms</span><br><span class="line">64 bytes from 172.18.0.2: icmp_seq=3 ttl=64 time=0.049 ms</span><br><span class="line"></span><br><span class="line"><span class="comment"># 5.每次启动一个容器就会多一对网卡，给docker容器分配一个ip</span></span><br><span class="line">[root@VM-1-14-centos ~]<span class="comment"># docker run -d -P --name tomcat02 tomcat</span></span><br><span class="line">bb207d673d6b6a3b0898494d23850d87d852263b8c612b9788533fd3978bcdff</span><br><span class="line">[root@VM-1-14-centos ~]<span class="comment"># docker exec -it tomcat02 ip addr</span></span><br><span class="line">1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000</span><br><span class="line">    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00</span><br><span class="line">    inet 127.0.0.1/8 scope host lo</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">584: eth0@if585: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue state UP group default </span><br><span class="line">    link/ether 02:42:ac:12:00:03 brd ff:ff:ff:ff:ff:ff link-netnsid 0</span><br><span class="line">    inet 172.18.0.3/16 brd 172.18.255.255 scope global eth0</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">[root@VM-1-14-centos ~]<span class="comment"># ip addr</span></span><br><span class="line">1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000</span><br><span class="line">......</span><br><span class="line">2: eth0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc mq state UP group default qlen 1000</span><br><span class="line">......</span><br><span class="line">3: docker0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue state UP group default </span><br><span class="line">......</span><br><span class="line">583: veth10795dd@if582: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue master docker0 state UP group default </span><br><span class="line">    link/ether e6:83:7d:be:d2:57 brd ff:ff:ff:ff:ff:ff link-netnsid 0</span><br><span class="line">    inet6 fe80::e483:7dff:febe:d257/64 scope link </span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">585: veth3c80d43@if584: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue master docker0 state UP group default </span><br><span class="line">    link/ether 92:75:28:4c:a7:02 brd ff:ff:ff:ff:ff:ff link-netnsid 1</span><br><span class="line">    inet6 fe80::9075:28ff:fe4c:a702/64 scope link </span><br><span class="line">       valid_lft forever preferred_lft forever</span><br></pre></td></tr></table></figure><h3 id="容器之间的网络互通"><a href="#容器之间的网络互通" class="headerlink" title="容器之间的网络互通"></a>容器之间的网络互通</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1.获取tomcat01的ip 172.17.0.2   </span></span><br><span class="line">[root@VM-1-14-centos ~]<span class="comment"># docker exec -it tomcat01 ip addr  </span></span><br><span class="line">550: eth0@if551: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue state UP group default </span><br><span class="line">    link/ether 02:42:ac:11:00:02 brd ff:ff:ff:ff:ff:ff link-netnsid 0</span><br><span class="line">    inet 172.17.0.2/16 brd 172.17.255.255 scope global eth0</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2.用tomcat02 ping通 tomcat01</span></span><br><span class="line">[root@VM-1-14-centos ~]<span class="comment"># docker exec -it tomcat02 ping 172.18.0.2</span></span><br><span class="line">PING 172.18.0.2 (172.18.0.2) 56(84) bytes of data.</span><br><span class="line">64 bytes from 172.18.0.2: icmp_seq=1 ttl=64 time=0.074 ms</span><br><span class="line">64 bytes from 172.18.0.2: icmp_seq=2 ttl=64 time=0.051 ms</span><br></pre></td></tr></table></figure><h3 id="docker内网结构"><a href="#docker内网结构" class="headerlink" title="docker内网结构"></a>docker内网结构</h3><ul><li>所有的 docker 容器在不指定网络的情况下，都是由 docker0 使用Linux虚拟化技术、充当虚拟内网的路由/桥接，由 docker0 给容器分配一个可用ip，并由veth-pair连接，直到容器删除。</li><li>Docker中所有网络接口都是虚拟的，虚拟的转发效率高（内网传递文件）。</li><li>路由上发送信息可以通过两种方法：1.对每一个设备都进行注册；2.进行广播，看谁进行了回应。</li></ul><p><img src="/2021/04/Docker%E5%9F%BA%E7%A1%80Part6/image-20210427082646681.png" alt="image-20210427082646681"></p><h2 id="容器互联"><a href="#容器互联" class="headerlink" title="容器互联"></a>容器互联</h2><h3 id="–link-使用"><a href="#–link-使用" class="headerlink" title="–link 使用"></a>–link 使用</h3><p>为了保证数据ip更换时，项目不需要重启，并且通过名字来访问容器。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1.在未使用 --link 时，不能使用名字ping通</span></span><br><span class="line">[root@VM-1-14-centos ~]<span class="comment"># docker exec -it tomcat02 ping tomcat01</span></span><br><span class="line">ping: tomcat01: Name or service not known</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2.使用--link连接tomcat02、tomcat03</span></span><br><span class="line">[root@VM-1-14-centos ~]<span class="comment"># docker run -d -P --name tomcat03 --link tomcat02 tomcat</span></span><br><span class="line">16d977fe6d16ffd3e7e813e2487a55c9d52319a2c94c967fe3eed85f26078fd8</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3.可以单向ping通</span></span><br><span class="line">[root@VM-1-14-centos ~]<span class="comment"># docker exec -it tomcat03 ping tomcat02</span></span><br><span class="line">PING tomcat02 (172.18.0.3) 56(84) bytes of data.</span><br><span class="line">64 bytes from tomcat02 (172.18.0.3): icmp_seq=1 ttl=64 time=0.081 ms</span><br><span class="line">64 bytes from tomcat02 (172.18.0.3): icmp_seq=2 ttl=64 time=0.050 ms</span><br><span class="line">64 bytes from tomcat02 (172.18.0.3): icmp_seq=3 ttl=64 time=0.053 ms</span><br><span class="line"></span><br><span class="line"><span class="comment"># 4.对于没有进行配置的容器，不能与其他容器直接ping通</span></span><br><span class="line">[root@VM-1-14-centos ~]<span class="comment"># docker exec -it tomcat02 ping tomcat03</span></span><br><span class="line">ping: tomcat03: Name or service not known</span><br></pre></td></tr></table></figure><h3 id="–link-原理"><a href="#–link-原理" class="headerlink" title="–link 原理"></a>–link 原理</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看总体网络</span></span><br><span class="line">[root@VM-1-14-centos ~]<span class="comment"># docker network ls</span></span><br><span class="line">NETWORK ID     NAME      DRIVER    SCOPE</span><br><span class="line">c49bd3c9074e   bridge    bridge    <span class="built_in">local</span></span><br><span class="line">7137f78f9152   host      host      <span class="built_in">local</span></span><br><span class="line">830f9dcb1238   none      null      <span class="built_in">local</span></span><br><span class="line">[root@VM-1-14-centos ~]<span class="comment"># docker network inspect c49bd3c9074e</span></span><br><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">&quot;Name&quot;</span>: <span class="string">&quot;bridge&quot;</span>,</span><br><span class="line">        <span class="string">&quot;Id&quot;</span>: <span class="string">&quot;c49bd3c9074eccb131f580ae87a0f639459d8fbfb6106ff16d95de982f955cb6&quot;</span>,</span><br><span class="line">        <span class="string">&quot;Created&quot;</span>: <span class="string">&quot;2021-04-20T21:44:51.886039709+08:00&quot;</span>,</span><br><span class="line">        <span class="string">&quot;Scope&quot;</span>: <span class="string">&quot;local&quot;</span>,</span><br><span class="line">        <span class="string">&quot;Driver&quot;</span>: <span class="string">&quot;bridge&quot;</span>,</span><br><span class="line">        <span class="string">&quot;EnableIPv6&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">        <span class="string">&quot;IPAM&quot;</span>: &#123;</span><br><span class="line">            <span class="string">&quot;Driver&quot;</span>: <span class="string">&quot;default&quot;</span>,</span><br><span class="line">            <span class="string">&quot;Options&quot;</span>: null,</span><br><span class="line">            <span class="string">&quot;Config&quot;</span>: [</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="string">&quot;Subnet&quot;</span>: <span class="string">&quot;172.18.0.0/16&quot;</span>,  <span class="comment"># 局域网</span></span><br><span class="line">                    <span class="string">&quot;Gateway&quot;</span>: <span class="string">&quot;172.18.0.1&quot;</span>  <span class="comment"># docker0地址</span></span><br><span class="line">                &#125;</span><br><span class="line">            ]</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">&quot;Internal&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">        <span class="string">&quot;Attachable&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">        <span class="string">&quot;Ingress&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">        <span class="string">&quot;ConfigFrom&quot;</span>: &#123;</span><br><span class="line">            <span class="string">&quot;Network&quot;</span>: <span class="string">&quot;&quot;</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">&quot;ConfigOnly&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">        <span class="string">&quot;Containers&quot;</span>: &#123;  <span class="comment"># 三个tomcat地址</span></span><br><span class="line">            <span class="string">&quot;16d977fe6d16ffd3e7e813e2487a55c9d52319a2c94c967fe3eed85f26078fd8&quot;</span>: &#123;</span><br><span class="line">                <span class="string">&quot;Name&quot;</span>: <span class="string">&quot;tomcat03&quot;</span>,</span><br><span class="line">                <span class="string">&quot;EndpointID&quot;</span>: <span class="string">&quot;5a5630f2d5c897c1d9c36c9fef6df14885c381bdd5bd3bb38c1936335b65ccef&quot;</span>,</span><br><span class="line">                <span class="string">&quot;MacAddress&quot;</span>: <span class="string">&quot;02:42:ac:12:00:04&quot;</span>,</span><br><span class="line">                <span class="string">&quot;IPv4Address&quot;</span>: <span class="string">&quot;172.18.0.4/16&quot;</span>,</span><br><span class="line">                <span class="string">&quot;IPv6Address&quot;</span>: <span class="string">&quot;&quot;</span></span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="string">&quot;35806ff980cd8d16855934bceaacc02a6b99d50efeb9c9ff078ae43027c1ffbc&quot;</span>: &#123;</span><br><span class="line">                <span class="string">&quot;Name&quot;</span>: <span class="string">&quot;tomcat01&quot;</span>,</span><br><span class="line">                <span class="string">&quot;EndpointID&quot;</span>: <span class="string">&quot;fda00eb71c90561f15bdfd6c535411e7d38830c82315c747ac806b6369dcd623&quot;</span>,</span><br><span class="line">                <span class="string">&quot;MacAddress&quot;</span>: <span class="string">&quot;02:42:ac:12:00:02&quot;</span>,</span><br><span class="line">                <span class="string">&quot;IPv4Address&quot;</span>: <span class="string">&quot;172.18.0.2/16&quot;</span>,</span><br><span class="line">                <span class="string">&quot;IPv6Address&quot;</span>: <span class="string">&quot;&quot;</span></span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="string">&quot;bb207d673d6b6a3b0898494d23850d87d852263b8c612b9788533fd3978bcdff&quot;</span>: &#123;</span><br><span class="line">                <span class="string">&quot;Name&quot;</span>: <span class="string">&quot;tomcat02&quot;</span>,</span><br><span class="line">                <span class="string">&quot;EndpointID&quot;</span>: <span class="string">&quot;33d04884bfec102e7b8d1ac0985a60636c2766c4e4aebcc68bc8d766ec13c037&quot;</span>,</span><br><span class="line">                <span class="string">&quot;MacAddress&quot;</span>: <span class="string">&quot;02:42:ac:12:00:03&quot;</span>,</span><br><span class="line">                <span class="string">&quot;IPv4Address&quot;</span>: <span class="string">&quot;172.18.0.3/16&quot;</span>,</span><br><span class="line">                <span class="string">&quot;IPv6Address&quot;</span>: <span class="string">&quot;&quot;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">&quot;Options&quot;</span>: &#123;</span><br><span class="line">            <span class="string">&quot;com.docker.network.bridge.default_bridge&quot;</span>: <span class="string">&quot;true&quot;</span>,</span><br><span class="line">            <span class="string">&quot;com.docker.network.bridge.enable_icc&quot;</span>: <span class="string">&quot;true&quot;</span>,</span><br><span class="line">            <span class="string">&quot;com.docker.network.bridge.enable_ip_masquerade&quot;</span>: <span class="string">&quot;true&quot;</span>,</span><br><span class="line">            <span class="string">&quot;com.docker.network.bridge.host_binding_ipv4&quot;</span>: <span class="string">&quot;0.0.0.0&quot;</span>,</span><br><span class="line">            <span class="string">&quot;com.docker.network.bridge.name&quot;</span>: <span class="string">&quot;docker0&quot;</span>,</span><br><span class="line">            <span class="string">&quot;com.docker.network.driver.mtu&quot;</span>: <span class="string">&quot;1500&quot;</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">&quot;Labels&quot;</span>: &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看容器网络</span></span><br><span class="line">[root@VM-1-14-centos ~]<span class="comment"># docker ps</span></span><br><span class="line">CONTAINER ID   IMAGE     COMMAND             CREATED          STATUS          PORTS                                         NAMES</span><br><span class="line">16d977fe6d16   tomcat    <span class="string">&quot;catalina.sh run&quot;</span>   11 minutes ago   Up 11 minutes   0.0.0.0:49158-&gt;8080/tcp, :::49158-&gt;8080/tcp   tomcat03</span><br><span class="line">bb207d673d6b   tomcat    <span class="string">&quot;catalina.sh run&quot;</span>   16 hours ago     Up 16 hours     0.0.0.0:49156-&gt;8080/tcp, :::49156-&gt;8080/tcp   tomcat02</span><br><span class="line">35806ff980cd   tomcat    <span class="string">&quot;catalina.sh run&quot;</span>   17 hours ago     Up 17 hours     0.0.0.0:49155-&gt;8080/tcp, :::49155-&gt;8080/tcp   tomcat01</span><br><span class="line">[root@VM-1-14-centos ~]<span class="comment"># docker inspect 16d977fe6d16</span></span><br><span class="line">......</span><br><span class="line">        <span class="string">&quot;HostConfig&quot;</span>: &#123;</span><br><span class="line">            ......</span><br><span class="line">            <span class="string">&quot;Links&quot;</span>: [  <span class="comment"># 绑定的容器连接信息</span></span><br><span class="line">                <span class="string">&quot;/tomcat02:/tomcat03/tomcat02&quot;</span></span><br><span class="line">            ],</span><br><span class="line">            ......</span><br><span class="line">         &#125;</span><br><span class="line">......</span><br><span class="line"></span><br><span class="line">[root@VM-1-14-centos ~]<span class="comment"># docker exec -it tomcat03 cat /etc/hosts</span></span><br><span class="line">127.0.0.1localhost</span><br><span class="line">::1localhost ip6-localhost ip6-loopback</span><br><span class="line">fe00::0ip6-localnet</span><br><span class="line">ff00::0ip6-mcastprefix</span><br><span class="line">ff02::1ip6-allnodes</span><br><span class="line">ff02::2ip6-allrouters</span><br><span class="line">172.18.0.3tomcat02 bb207d673d6b  <span class="comment"># 添加了对tomcat02的解析映射</span></span><br><span class="line">172.18.0.416d977fe6d16</span><br></pre></td></tr></table></figure><blockquote><p>现在Docker不建议使用–link，以及官方提供的docker0，因为不支持容器名连接访问，较为局限，而是使用自定义网络。</p></blockquote><h2 id="自定义网络"><a href="#自定义网络" class="headerlink" title="自定义网络"></a>自定义网络</h2><h3 id="查看网络信息"><a href="#查看网络信息" class="headerlink" title="查看网络信息"></a>查看网络信息</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">docker network [ <span class="built_in">command</span> ]</span><br><span class="line"></span><br><span class="line">Commands:</span><br><span class="line">  connect     Connect a container to a network</span><br><span class="line">  create      Create a network</span><br><span class="line">  disconnect  Disconnect a container from a network</span><br><span class="line">  inspect     Display detailed information on one or more networks</span><br><span class="line">  ls          List networks</span><br><span class="line">  prune       Remove all unused networks</span><br><span class="line">  rm          Remove one or more networks</span><br></pre></td></tr></table></figure><h3 id="网络信息解释"><a href="#网络信息解释" class="headerlink" title="网络信息解释"></a>网络信息解释</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-1-14-centos ~]<span class="comment"># docker network ls</span></span><br><span class="line">NETWORK ID     NAME      DRIVER    SCOPE</span><br><span class="line">c49bd3c9074e   bridge    bridge    <span class="built_in">local</span></span><br><span class="line">7137f78f9152   host      host      <span class="built_in">local</span></span><br><span class="line">830f9dcb1238   none      null      <span class="built_in">local</span></span><br></pre></td></tr></table></figure><ul><li>bridge ：桥接 docker（默认，自定义也使用bridge）</li><li>none ：不配置网络，一般不用</li><li>host ：和主机共享网络</li><li>container ：容器网络连通（局限大，用得少）</li></ul><h3 id="创建自定义网络"><a href="#创建自定义网络" class="headerlink" title="创建自定义网络"></a>创建自定义网络</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1.默认--net bridge，bridge就是docker0。因此以下两者等效</span></span><br><span class="line">docker run -d -P --name tomcat01 tomcat</span><br><span class="line">docker run -d -P --name tomcat01 --net bridge tomcat</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2.自定义一个网络</span></span><br><span class="line">[root@VM-1-14-centos ~]<span class="comment"># docker network create --driver bridge --subnet 192.168.0.0/16 --gateway 192.168.0.1 mynet</span></span><br><span class="line">1144482c2ac35e85b348c18a0038fe93c9fd871bcb83612beea9c1a272589596</span><br><span class="line">[root@VM-1-14-centos ~]<span class="comment"># docker network ls</span></span><br><span class="line">NETWORK ID     NAME      DRIVER    SCOPE</span><br><span class="line">c49bd3c9074e   bridge    bridge    <span class="built_in">local</span></span><br><span class="line">7137f78f9152   host      host      <span class="built_in">local</span></span><br><span class="line">1144482c2ac3   mynet     bridge    <span class="built_in">local</span></span><br><span class="line">830f9dcb1238   none      null      <span class="built_in">local</span></span><br><span class="line">[root@VM-1-14-centos ~]<span class="comment"># docker network inspect mynet</span></span><br><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">&quot;Name&quot;</span>: <span class="string">&quot;mynet&quot;</span>,</span><br><span class="line">        <span class="string">&quot;Id&quot;</span>: <span class="string">&quot;1144482c2ac35e85b348c18a0038fe93c9fd871bcb83612beea9c1a272589596&quot;</span>,</span><br><span class="line">        <span class="string">&quot;Created&quot;</span>: <span class="string">&quot;2021-04-27T10:25:16.077076141+08:00&quot;</span>,</span><br><span class="line">        <span class="string">&quot;Scope&quot;</span>: <span class="string">&quot;local&quot;</span>,</span><br><span class="line">        <span class="string">&quot;Driver&quot;</span>: <span class="string">&quot;bridge&quot;</span>,</span><br><span class="line">        <span class="string">&quot;EnableIPv6&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">        <span class="string">&quot;IPAM&quot;</span>: &#123;</span><br><span class="line">            <span class="string">&quot;Driver&quot;</span>: <span class="string">&quot;default&quot;</span>,</span><br><span class="line">            <span class="string">&quot;Options&quot;</span>: &#123;&#125;,</span><br><span class="line">            <span class="string">&quot;Config&quot;</span>: [</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="string">&quot;Subnet&quot;</span>: <span class="string">&quot;192.168.0.0/16&quot;</span>,</span><br><span class="line">                    <span class="string">&quot;Gateway&quot;</span>: <span class="string">&quot;192.168.0.1&quot;</span></span><br><span class="line">                &#125;</span><br><span class="line">            ]</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">&quot;Internal&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">        <span class="string">&quot;Attachable&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">        <span class="string">&quot;Ingress&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">        <span class="string">&quot;ConfigFrom&quot;</span>: &#123;</span><br><span class="line">            <span class="string">&quot;Network&quot;</span>: <span class="string">&quot;&quot;</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">&quot;ConfigOnly&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">        <span class="string">&quot;Containers&quot;</span>: &#123;&#125;,</span><br><span class="line">        <span class="string">&quot;Options&quot;</span>: &#123;&#125;,</span><br><span class="line">        <span class="string">&quot;Labels&quot;</span>: &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3.在自定义网络下启动Tomcat</span></span><br><span class="line">[root@VM-1-14-centos ~]<span class="comment"># docker run -d -P --name tomcat-net-01 --net mynet tomcat</span></span><br><span class="line">8efc7a929482e82d74f723d2af17f77560b53561752fc1aab50d0189e06d7237</span><br><span class="line">[root@VM-1-14-centos ~]<span class="comment"># docker run -d -P --name tomcat-net-02 --net mynet tomcat</span></span><br><span class="line">6ccb4239abcfda10aa1b463d2f44d4a9ca4bc312735b56d08cad55266545ce2a</span><br><span class="line"></span><br><span class="line"><span class="comment"># 4.测试可以使用容器名直接ping通</span></span><br><span class="line">[root@VM-1-14-centos ~]<span class="comment"># docker exec -it tomcat-net-01 ping tomcat-net-02</span></span><br><span class="line">PING tomcat-net-02 (192.168.0.3) 56(84) bytes of data.</span><br><span class="line">64 bytes from tomcat-net-02.mynet (192.168.0.3): icmp_seq=1 ttl=64 time=0.069 ms</span><br><span class="line">64 bytes from tomcat-net-02.mynet (192.168.0.3): icmp_seq=2 ttl=64 time=0.061 ms</span><br><span class="line">64 bytes from tomcat-net-02.mynet (192.168.0.3): icmp_seq=3 ttl=64 time=0.056 ms</span><br></pre></td></tr></table></figure><p>好处：</p><ul><li>不同的集群使用不同的网络，保证集群是互相隔离并且安全的。</li></ul><h2 id="网络连通"><a href="#网络连通" class="headerlink" title="网络连通"></a>网络连通</h2><h3 id="connect"><a href="#connect" class="headerlink" title="connect"></a>connect</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">docker network connect --<span class="built_in">help</span></span><br><span class="line"></span><br><span class="line">Options:</span><br><span class="line">      --<span class="built_in">alias</span> strings           Add network-scoped <span class="built_in">alias</span> <span class="keyword">for</span> the container</span><br><span class="line">      --driver-opt strings      driver options <span class="keyword">for</span> the network</span><br><span class="line">      --ip string               IPv4 address (e.g., 172.30.100.104)</span><br><span class="line">      --ip6 string              IPv6 address (e.g., 2001:db8::33)</span><br><span class="line">      --link list               Add link to another container</span><br><span class="line">      --link-local-ip strings   Add a link-local address <span class="keyword">for</span> the container</span><br></pre></td></tr></table></figure><h3 id="容器与不同网段的连通"><a href="#容器与不同网段的连通" class="headerlink" title="容器与不同网段的连通"></a>容器与不同网段的连通</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1.测试两个不同的网络连通 ：再启动两个 tomcat 并使用默认网络 docker0</span></span><br><span class="line">[root@VM-1-14-centos ~]<span class="comment"># docker run -d -P --name tomcat01 tomcat</span></span><br><span class="line">0ad36e6d140040e1c6324695f6fe7102f8857b28b6251a6a21f8e4f8eb88839d</span><br><span class="line">[root@VM-1-14-centos ~]<span class="comment"># docker run -d -P --name tomcat02 tomcat</span></span><br><span class="line">aa8836b5fe93c9437490deb86796cc9d2d12d051df7ffc74b5b618b89c094a95</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2.此时tomcat01与tomcat-net-01不能ping通</span></span><br><span class="line">[root@VM-1-14-centos ~]<span class="comment"># docker exec tomcat01 ping tomcat-net-01</span></span><br><span class="line">ping: tomcat-net-01: Name or service not known</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3.连通容器与不同网段</span></span><br><span class="line">[root@VM-1-14-centos ~]<span class="comment"># docker network connect mynet tomcat01</span></span><br><span class="line">[root@VM-1-14-centos ~]<span class="comment"># docker network inspect mynet </span></span><br><span class="line">......</span><br><span class="line">        <span class="string">&quot;Containers&quot;</span>: &#123;</span><br><span class="line">            <span class="string">&quot;0ad36e6d140040e1c6324695f6fe7102f8857b28b6251a6a21f8e4f8eb88839d&quot;</span>: &#123;</span><br><span class="line">                <span class="string">&quot;Name&quot;</span>: <span class="string">&quot;tomcat01&quot;</span>,  <span class="comment"># 连通子网与不在此子网的容器，就是把容器加入到此子网的配置中</span></span><br><span class="line">                <span class="string">&quot;EndpointID&quot;</span>: <span class="string">&quot;a2f785c266adf679b186367e95cdcc48cc6c976b02b693de43100a625a6ca251&quot;</span>,</span><br><span class="line">                <span class="string">&quot;MacAddress&quot;</span>: <span class="string">&quot;02:42:c0:a8:00:04&quot;</span>,</span><br><span class="line">                <span class="string">&quot;IPv4Address&quot;</span>: <span class="string">&quot;192.168.0.4/16&quot;</span>,</span><br><span class="line">                <span class="string">&quot;IPv6Address&quot;</span>: <span class="string">&quot;&quot;</span></span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="string">&quot;6ccb4239abcfda10aa1b463d2f44d4a9ca4bc312735b56d08cad55266545ce2a&quot;</span>: &#123;</span><br><span class="line">                <span class="string">&quot;Name&quot;</span>: <span class="string">&quot;tomcat-net-02&quot;</span>,</span><br><span class="line">                <span class="string">&quot;EndpointID&quot;</span>: <span class="string">&quot;4e03b4f4fd3e11254ad5a5b3b1d1a6e4e8d5d9088eeb7be5e371875bb9885fa6&quot;</span>,</span><br><span class="line">                <span class="string">&quot;MacAddress&quot;</span>: <span class="string">&quot;02:42:c0:a8:00:03&quot;</span>,</span><br><span class="line">                <span class="string">&quot;IPv4Address&quot;</span>: <span class="string">&quot;192.168.0.3/16&quot;</span>,</span><br><span class="line">                <span class="string">&quot;IPv6Address&quot;</span>: <span class="string">&quot;&quot;</span></span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="string">&quot;8efc7a929482e82d74f723d2af17f77560b53561752fc1aab50d0189e06d7237&quot;</span>: &#123;</span><br><span class="line">                <span class="string">&quot;Name&quot;</span>: <span class="string">&quot;tomcat-net-01&quot;</span>,</span><br><span class="line">                <span class="string">&quot;EndpointID&quot;</span>: <span class="string">&quot;07427902cf0a5d5c1f72971ccf0615b0155eae830da1811b5e74e55226256d59&quot;</span>,</span><br><span class="line">                <span class="string">&quot;MacAddress&quot;</span>: <span class="string">&quot;02:42:c0:a8:00:02&quot;</span>,</span><br><span class="line">                <span class="string">&quot;IPv4Address&quot;</span>: <span class="string">&quot;192.168.0.2/16&quot;</span>,</span><br><span class="line">                <span class="string">&quot;IPv6Address&quot;</span>: <span class="string">&quot;&quot;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">......</span><br><span class="line"></span><br><span class="line"><span class="comment"># 4.测试连接成功</span></span><br><span class="line">[root@VM-1-14-centos ~]<span class="comment"># docker exec tomcat01 ping tomcat-net-01</span></span><br><span class="line">PING tomcat-net-01 (192.168.0.2) 56(84) bytes of data.</span><br><span class="line">64 bytes from tomcat-net-01.mynet (192.168.0.2): icmp_seq=1 ttl=64 time=0.065 ms</span><br><span class="line">64 bytes from tomcat-net-01.mynet (192.168.0.2): icmp_seq=2 ttl=64 time=0.069 ms</span><br><span class="line">64 bytes from tomcat-net-01.mynet (192.168.0.2): icmp_seq=3 ttl=64 time=0.054 ms</span><br></pre></td></tr></table></figure><ul><li>子网跟子网不能连通，但是容器和所在以外的子网能够连通。</li><li>一个容器具备多个ip，以访问不同网段。</li></ul><h2 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h2><p><a href="https://www.bilibili.com/video/BV1og4y1q7M4?p=38">Redis集群部署</a></p><p><a href="https://www.bilibili.com/video/BV1og4y1q7M4?p=39">springboot以服务打包镜像</a></p>]]></content>
      
      
      <categories>
          
          <category> Docker基础 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Docker基础Part5</title>
      <link href="/2021/04/Docker%E5%9F%BA%E7%A1%80Part5/"/>
      <url>/2021/04/Docker%E5%9F%BA%E7%A1%80Part5/</url>
      
        <content type="html"><![CDATA[<h1 id="Docker基础Part5——DockerFlie"><a href="#Docker基础Part5——DockerFlie" class="headerlink" title="Docker基础Part5——DockerFlie"></a>Docker基础Part5——DockerFlie</h1><p>[TOC]</p><h2 id="DockerFile介绍"><a href="#DockerFile介绍" class="headerlink" title="DockerFile介绍"></a>DockerFile介绍</h2><p>Dockerfile 是一个用来构建镜像的文本文件，文本内容包含了一条条构建镜像所需的指令和说明。</p><p>Dockerfile 是面向开发的，Docker镜像逐渐成为企业交付、发布项目的标准。</p><p>构建步骤：</p><ol><li>编写 dockerfile 文件</li><li>docker build 构建镜像</li><li>docker run 运行镜像</li><li>docker push 发布镜像（DockerHub 、阿里云仓库）</li></ol><blockquote><p>每一个指令都会创建一个新的镜像层并提交。</p></blockquote><h2 id="DockerFile指令"><a href="#DockerFile指令" class="headerlink" title="DockerFile指令"></a>DockerFile指令</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">FROM<span class="comment"># 基础镜像，一切从这里开始构建</span></span><br><span class="line">MAINTAINER<span class="comment"># 镜像是谁写的， 姓名+邮箱</span></span><br><span class="line">RUN<span class="comment"># 镜像构建的时候需要运行的命令</span></span><br><span class="line">ADD<span class="comment"># 步骤，tomcat镜像，这个tomcat压缩包！添加内容 添加同目录</span></span><br><span class="line">WORKDIR<span class="comment"># 镜像的工作目录</span></span><br><span class="line">VOLUME<span class="comment"># 挂载的目录</span></span><br><span class="line">EXPOSE<span class="comment"># 开放端口配置</span></span><br><span class="line">CMD<span class="comment"># 指定这个容器启动的时候要运行的命令，只有最后一个会生效，可被替代。</span></span><br><span class="line">ENTRYPOINT<span class="comment"># 指定这个容器启动的时候要运行的命令，可以追加命令</span></span><br><span class="line">ONBUILD<span class="comment"># 当构建一个被继承 DockerFile 这个时候就会运行ONBUILD的指令，触发指令。</span></span><br><span class="line">COPY<span class="comment"># 类似ADD，将我们文件拷贝到镜像中</span></span><br><span class="line">ENV<span class="comment"># 构建的时候设置环境变量</span></span><br></pre></td></tr></table></figure><h2 id="实战测试"><a href="#实战测试" class="headerlink" title="实战测试"></a>实战测试</h2><ul><li>DockerHub中大部分镜像都是从<code>FROM scratch</code>开始。</li><li>关键字不一定要大写，但是一般都是大写来和变量区分。</li></ul><p>官方的centos镜像没有<code>vim、ifconfig</code>命令，这里制作自己的centos镜像。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1.编写Dockerfile文件</span></span><br><span class="line">[root@VM-1-14-centos dockerfile]<span class="comment"># vim mydockerfile_centos </span></span><br><span class="line">[root@VM-1-14-centos dockerfile]<span class="comment"># cat mydockerfile_centos </span></span><br><span class="line">FROM centos</span><br><span class="line">MAINTAINER NephrenCake&lt;834957063@qq.com&gt;</span><br><span class="line"></span><br><span class="line">ENV MYPATH /usr/<span class="built_in">local</span></span><br><span class="line">WOKDIR <span class="variable">$MYPATH</span></span><br><span class="line"></span><br><span class="line">run yum -y install vim</span><br><span class="line">RUN yum -y install net-tools</span><br><span class="line"></span><br><span class="line">EXPOSE 80</span><br><span class="line"></span><br><span class="line">CMD <span class="built_in">echo</span> <span class="variable">$MYPATH</span></span><br><span class="line">CMD <span class="built_in">echo</span> <span class="string">&quot;-----end-----&quot;</span></span><br><span class="line">CMD /bin/bash</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2.构建镜像</span></span><br><span class="line"><span class="comment"># 命令 docker build -f 文件路径 -t 镜像名:[tag] 目标路径</span></span><br><span class="line">docker build -f mydockerfile_centos -t mycentos:0.1 .  <span class="comment"># &lt;-注意这里的一个“.”表示镜像文件生成在当前目录</span></span><br><span class="line">......</span><br><span class="line">Successfully built 0fb03cb15b56</span><br><span class="line">Successfully tagged mycentos:0.1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3.测试运行</span></span><br><span class="line">[root@VM-1-14-centos dockerfile]<span class="comment"># docker run -it mycentos:0.1 /bin/bash</span></span><br><span class="line">[root@6db4033677cd <span class="built_in">local</span>]<span class="comment"># pwd</span></span><br><span class="line">/usr/<span class="built_in">local</span>  <span class="comment"># 进入设置的工作目录</span></span><br><span class="line">[root@6db4033677cd <span class="built_in">local</span>]<span class="comment"># ifconfig</span></span><br><span class="line">......  <span class="comment"># ifconfig 可以正常使用</span></span><br><span class="line">[root@6db4033677cd <span class="built_in">local</span>]<span class="comment"># vim --version</span></span><br><span class="line">......  <span class="comment"># vim 可以正常使用</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 4.查看构建过程</span></span><br><span class="line">[root@VM-1-14-centos dockerfile]<span class="comment"># docker history mycentos:0.1</span></span><br><span class="line">IMAGE          CREATED          CREATED BY                                      SIZE      COMMENT</span><br><span class="line">0fb03cb15b56   25 minutes ago   /bin/sh -c <span class="comment">#(nop)  CMD [&quot;/bin/sh&quot; &quot;-c&quot; &quot;/bin…   0B        </span></span><br><span class="line">857a02979c6b   25 minutes ago   /bin/sh -c <span class="comment">#(nop)  CMD [&quot;/bin/sh&quot; &quot;-c&quot; &quot;echo…   0B        </span></span><br><span class="line">9b1d90e765f1   25 minutes ago   /bin/sh -c <span class="comment">#(nop)  CMD [&quot;/bin/sh&quot; &quot;-c&quot; &quot;echo…   0B        </span></span><br><span class="line">383a1fdc4420   25 minutes ago   /bin/sh -c <span class="comment">#(nop)  EXPOSE 80                    0B        </span></span><br><span class="line">315a1c8eafe2   25 minutes ago   /bin/sh -c yum -y install net-tools             23.3MB    </span><br><span class="line">1bd3533bf951   25 minutes ago   /bin/sh -c yum -y install vim                   58MB      </span><br><span class="line">e7468e6156a1   26 minutes ago   /bin/sh -c <span class="comment">#(nop) WORKDIR /usr/local            0B        </span></span><br><span class="line">02c89bb6f0d5   26 minutes ago   /bin/sh -c <span class="comment">#(nop)  ENV MYPATH=/usr/local        0B        </span></span><br><span class="line">1e2c46d0633d   26 minutes ago   /bin/sh -c <span class="comment">#(nop)  MAINTAINER NephrenCake&lt;83…   0B        </span></span><br><span class="line">300e315adb2f   4 months ago     /bin/sh -c <span class="comment">#(nop)  CMD [&quot;/bin/bash&quot;]            0B        </span></span><br><span class="line">&lt;missing&gt;      4 months ago     /bin/sh -c <span class="comment">#(nop)  LABEL org.label-schema.sc…   0B        </span></span><br><span class="line">&lt;missing&gt;      4 months ago     /bin/sh -c <span class="comment">#(nop) ADD file:bd7a2aed6ede423b7…   209MB</span></span><br></pre></td></tr></table></figure><ul><li>建议在dockerfile所在目录构建镜像。</li><li>对所有拿到的镜像都可以<code>docker history</code>来分析其构建过程。</li></ul><h2 id="CMD-和-ENTRYPOINT区别"><a href="#CMD-和-ENTRYPOINT区别" class="headerlink" title="CMD 和 ENTRYPOINT区别"></a>CMD 和 ENTRYPOINT区别</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CMD<span class="comment"># 指定这个容器启动的时候要运行的命令，只有最后一个会生效，可被替代。</span></span><br><span class="line">ENTRYPOINT<span class="comment"># 指定这个容器启动的时候要运行的命令，可以追加命令</span></span><br></pre></td></tr></table></figure><p>test CMD：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1.编写dockerfile文件</span></span><br><span class="line">[root@VM-1-14-centos dockerfile]<span class="comment"># vim dockerfile-test-cmd</span></span><br><span class="line">FROM centos</span><br><span class="line">CMD [<span class="string">&quot;ls&quot;</span>,<span class="string">&quot;-a&quot;</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2.构建镜像</span></span><br><span class="line">[root@VM-1-14-centos dockerfile]<span class="comment"># docker build  -f dockerfile-test-cmd -t cmd-test:0.1 .</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 3.运行镜像</span></span><br><span class="line">$ docker run cmd-test:0.1</span><br><span class="line">.</span><br><span class="line">..</span><br><span class="line">.dockerenv</span><br><span class="line">bin</span><br><span class="line">dev</span><br><span class="line">......  <span class="comment"># 成功执行设置的cmd指令</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 4.意图追加命令  -l 成为ls -al</span></span><br><span class="line">[root@VM-1-14-centos dockerfile]<span class="comment"># docker run cmd-test:0.1 -l</span></span><br><span class="line">docker: Error response from daemon: OCI runtime create failed: container_linux.go:349: starting container process caused <span class="string">&quot;exec: \&quot;-l\&quot;:</span></span><br><span class="line"><span class="string"> executable file not found in <span class="variable">$PATH</span>&quot;</span>: unknown.</span><br><span class="line">ERRO[0000] error waiting <span class="keyword">for</span> container: context canceled </span><br><span class="line"><span class="comment"># cmd的情况下 `-l` 替换了 `CMD[&quot;ls&quot;,&quot;-a&quot;]` ，而 `-l` 不是命令所以报错</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 5.修正：</span></span><br><span class="line">[root@VM-1-14-centos dockerfile]<span class="comment"># docker run cmd-test:0.1 ls -l</span></span><br><span class="line">total 48</span><br><span class="line">lrwxrwxrwx   1 root root    7 Nov  3 15:22 bin -&gt; usr/bin</span><br><span class="line">drwxr-xr-x   5 root root  340 Apr 25 03:10 dev</span><br><span class="line">drwxr-xr-x   1 root root 4096 Apr 25 03:09 etc</span><br><span class="line">drwxr-xr-x   2 root root 4096 Nov  3 15:22 home</span><br><span class="line">......</span><br><span class="line"></span><br><span class="line"><span class="comment"># 6.没有停留在容器的原因是执行完cmd指令自动退出了</span></span><br><span class="line">[root@VM-1-14-centos dockerfile]<span class="comment"># docker ps -a</span></span><br><span class="line">CONTAINER ID   IMAGE          COMMAND   CREATED          STATUS                      PORTS     NAMES</span><br><span class="line">9ce9877f6610   cmd-test:0.1   <span class="string">&quot;ls -l&quot;</span>   11 seconds ago   Exited (0) 10 seconds ago             interesting_knuth</span><br></pre></td></tr></table></figure><p>test ENTRYPOINT：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1.编写dockerfile文件</span></span><br><span class="line">[root@VM-1-14-centos dockerfile]<span class="comment"># vim dockerfile-test-entrypoint</span></span><br><span class="line">FROM centos</span><br><span class="line">ENTRYPOINT [<span class="string">&quot;ls&quot;</span>,<span class="string">&quot;-a&quot;</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2.构建镜像</span></span><br><span class="line">[root@VM-1-14-centos dockerfile]<span class="comment"># docker build  -f dockerfile-test-entrypoint -t entrypoint-test:0.1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 3.运行镜像</span></span><br><span class="line">[root@VM-1-14-centos dockerfile]<span class="comment"># docker run entrypoint-test:0.1</span></span><br><span class="line">.</span><br><span class="line">..</span><br><span class="line">.dockerenv</span><br><span class="line">bin</span><br><span class="line">dev</span><br><span class="line">......</span><br><span class="line"></span><br><span class="line"><span class="comment"># 4.追加命令</span></span><br><span class="line">[root@VM-1-14-centos dockerfile]<span class="comment"># docker run entrypoint-test:0.1 -l</span></span><br><span class="line">total 56</span><br><span class="line">drwxr-xr-x   1 root root 4096 May 16 06:32 .</span><br><span class="line">drwxr-xr-x   1 root root 4096 May 16 06:32 ..</span><br><span class="line">-rwxr-xr-x   1 root root    0 May 16 06:32 .dockerenv</span><br><span class="line">......</span><br></pre></td></tr></table></figure><h2 id="Tomcat实战"><a href="#Tomcat实战" class="headerlink" title="Tomcat实战"></a>Tomcat实战</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1.准备镜像文件</span></span><br><span class="line">Tomcat jdk dockerfile readme</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2.编写dockerfile</span></span><br><span class="line">FROM centos <span class="comment">#</span></span><br><span class="line">MAINTAINER cheng&lt;1204598429@qq.com&gt;</span><br><span class="line">COPY README /usr/<span class="built_in">local</span>/README <span class="comment">#复制文件</span></span><br><span class="line">ADD jdk-8u231-linux-x64.tar.gz /usr/<span class="built_in">local</span>/ <span class="comment">#复制解压</span></span><br><span class="line">ADD apache-tomcat-9.0.35.tar.gz /usr/<span class="built_in">local</span>/ <span class="comment">#复制解压</span></span><br><span class="line">RUN yum -y install vim</span><br><span class="line">ENV MYPATH /usr/<span class="built_in">local</span> <span class="comment">#设置环境变量</span></span><br><span class="line">WORKDIR <span class="variable">$MYPATH</span> <span class="comment">#设置工作目录</span></span><br><span class="line">ENV JAVA_HOME /usr/<span class="built_in">local</span>/jdk1.8.0_231 <span class="comment">#设置环境变量</span></span><br><span class="line">ENV CATALINA_HOME /usr/<span class="built_in">local</span>/apache-tomcat-9.0.35 <span class="comment">#设置环境变量</span></span><br><span class="line">ENV PATH <span class="variable">$PATH</span>:<span class="variable">$JAVA_HOME</span>/bin:<span class="variable">$CATALINA_HOME</span>/lib <span class="comment">#设置环境变量 分隔符是：</span></span><br><span class="line">EXPOSE 8080 <span class="comment">#设置暴露的端口</span></span><br><span class="line">CMD /usr/<span class="built_in">local</span>/apache-tomcat-9.0.35/bin/startup.sh &amp;&amp; tail -F /usr/<span class="built_in">local</span>/apache-tomcat-9.0.35/logs/catalina.out <span class="comment"># 设置默认命令</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 3.构建image  因为dockerfile命名使用默认命名 因此不用使用-f 指定文件</span></span><br><span class="line">$ docker build -t mytomcat:0.1 .</span><br><span class="line"></span><br><span class="line"><span class="comment"># 4.运行image</span></span><br><span class="line">$ docker run -d -p 8080:8080 --name tomcat01 -v /home/kuangshen/build/tomcat/<span class="built_in">test</span>:/usr/<span class="built_in">local</span>/apache-tomcat-9.0.35/webapps/<span class="built_in">test</span> -v /home/kuangshen/build/tomcat/tomcatlogs/:/usr/<span class="built_in">local</span>/apache-tomcat-9.0.35/logs mytomcat:0.1</span><br></pre></td></tr></table></figure><h2 id="发布镜像"><a href="#发布镜像" class="headerlink" title="发布镜像"></a>发布镜像</h2><h3 id="登录"><a href="#登录" class="headerlink" title="登录"></a>登录</h3><p>注册<a href="https://hub.docker.com/">DockerHub</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">docker login [OPTIONS] [SERVER]</span><br><span class="line"></span><br><span class="line">Options:</span><br><span class="line">  -p, --password string   Password</span><br><span class="line">      --password-stdin    Take the password from stdin</span><br><span class="line">  -u, --username string   Username</span><br></pre></td></tr></table></figure><h3 id="提交"><a href="#提交" class="headerlink" title="提交"></a>提交</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">docker push xxx/image:[镜像版本号]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 没有前缀默认push到官方的library</span></span><br><span class="line"><span class="comment"># 第一种 build的时候添加你的dockerhub用户名，然后在push就可以放到自己的仓库了</span></span><br><span class="line">$ docker build -t nephrencake/mytomcat:1.0 .</span><br><span class="line"><span class="comment"># 第二种 使用docker tag 然后再次push</span></span><br><span class="line">$ docker tag 容器id nephrencake/mytomcat:1.0</span><br></pre></td></tr></table></figure><h3 id="修改版本"><a href="#修改版本" class="headerlink" title="修改版本"></a>修改版本</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ docker tag [ImageId] registry.cn-xxx.aliyuncs.com/xxxx/image:[镜像版本号]</span><br><span class="line"><span class="comment"># 修改id 和 版本</span></span><br><span class="line">$ sudo docker tag a5ef1f32aaae registry.cn-xxx.aliyuncs.com/xxxx/image:1.0</span><br><span class="line"><span class="comment"># 修改仓库镜像版本</span></span><br><span class="line">$ docker push registry.cn-xxx.aliyuncs.com/xxxx/image:[镜像版本号]</span><br></pre></td></tr></table></figure><h3 id="打包镜像"><a href="#打包镜像" class="headerlink" title="打包镜像"></a>打包镜像</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker save [OPTIONS] IMAGE [IMAGE...]</span><br><span class="line"></span><br><span class="line">Options:</span><br><span class="line">  -o, --output string   Write to a file, instead of STDOUT</span><br></pre></td></tr></table></figure><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p><img src="/2021/04/Docker%E5%9F%BA%E7%A1%80Part5/image-20210427110036461.png" alt="image-20210427110036461"></p>]]></content>
      
      
      <categories>
          
          <category> Docker基础 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Docker基础Part4</title>
      <link href="/2021/04/Docker%E5%9F%BA%E7%A1%80Part4/"/>
      <url>/2021/04/Docker%E5%9F%BA%E7%A1%80Part4/</url>
      
        <content type="html"><![CDATA[<h1 id="Docker基础Part4——数据卷"><a href="#Docker基础Part4——数据卷" class="headerlink" title="Docker基础Part4——数据卷"></a>Docker基础Part4——数据卷</h1><p>[TOC]</p><h2 id="数据卷是什么"><a href="#数据卷是什么" class="headerlink" title="数据卷是什么"></a>数据卷是什么</h2><p>docker镜像是为了打包应用和环境。</p><ul><li>要防止容器的销毁造成数据的丢失。</li><li>减少不必要进入容器修改配置文件。</li></ul><p>docker容器中产生的数据不应当被存储在容器中，数据应当被同步共享到本机。</p><p>在docker容器中存放数据的文件目录（如：/usr/mysql/）可以挂载到本机的指定目录（如：/home/mysql/），实现数据同步共享。</p><p>多个容器之间依然可以通过上述相同的方式，实现多个容器的数据共享。</p><p><img src="/2021/04/Docker%E5%9F%BA%E7%A1%80Part4/image-20210424140857577.png" alt="image-20210424140857577"></p><h2 id="数据卷使用"><a href="#数据卷使用" class="headerlink" title="数据卷使用"></a>数据卷使用</h2><h3 id="指定路径挂载"><a href="#指定路径挂载" class="headerlink" title="指定路径挂载"></a>指定路径挂载</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -it -v 主机目录:容器内目录  -p 主机端口:容器内端口</span><br></pre></td></tr></table></figure><p>demo：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-1-14-centos ~]<span class="comment"># docker run -it -v /home/volume:/home centos</span></span><br><span class="line">[root@287b41b8e1eb /]<span class="comment"># cd home</span></span><br><span class="line">[root@287b41b8e1eb home]<span class="comment"># touch test.txt</span></span><br><span class="line">[root@287b41b8e1eb home]<span class="comment"># ls</span></span><br><span class="line">test.txt</span><br><span class="line">[root@VM-1-14-centos volume]<span class="comment"># ls</span></span><br><span class="line">test.txt</span><br></pre></td></tr></table></figure><p>容器内与主机内挂载的目录下，所有操作都相互等效。</p><p>即使容器停止、重启、删除，目录、数据依然同步。</p><h3 id="MySQL实战"><a href="#MySQL实战" class="headerlink" title="MySQL实战"></a>MySQL实战</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-1-14-centos ~]<span class="comment"># docker pull mysql:5.7</span></span><br><span class="line">[root@VM-1-14-centos ~]<span class="comment"># docker run -d -p 3310:3306 -v /home/mysql/conf:/etc/mysql/conf.d -v /home/mysql/data:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=123456 --name mysql01 mysql:5.7</span></span><br><span class="line">67a1b52b307b59d14029fee48ae553b9334c57037ad001d914e2e87ba96fa6cb</span><br><span class="line"><span class="comment"># -d 后台运行 -p 端口映射 -v 卷挂载 -e 环境配置 -- name 容器名字</span></span><br><span class="line">[root@VM-1-14-centos mysql]<span class="comment"># ls data/</span></span><br><span class="line">auto.cnf    ca.pem           client-key.pem  ibdata1      ib_logfile1  mysql               private_key.pem  server-cert.pem  sys</span><br><span class="line">ca-key.pem  client-cert.pem  ib_buffer_pool  ib_logfile0  ibtmp1       performance_schema  public_key.pem   server-key.pem</span><br><span class="line">[root@VM-1-14-centos ~]<span class="comment"># docker rm -f 67a1b52b307b</span></span><br><span class="line">67a1b52b307b</span><br><span class="line">[root@VM-1-14-centos mysql]<span class="comment"># ls data/</span></span><br><span class="line">auto.cnf    ca.pem           client-key.pem  ibdata1      ib_logfile1  mysql               private_key.pem  server-cert.pem  sys</span><br><span class="line">ca-key.pem  client-cert.pem  ib_buffer_pool  ib_logfile0  ibtmp1       performance_schema  public_key.pem   server-key.pem</span><br></pre></td></tr></table></figure><h3 id="具名和匿名挂载"><a href="#具名和匿名挂载" class="headerlink" title="具名和匿名挂载"></a>具名和匿名挂载</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 挂载方式</span></span><br><span class="line">docker run  -d -P --name xxx -v (str1:)str2 image</span><br><span class="line"><span class="comment"># str1 不加/为具名，加/为主机根目录下地址</span></span><br><span class="line"><span class="comment"># str2 容器内路径</span></span><br><span class="line"><span class="comment"># 匿名挂载：    -v 容器内路径</span></span><br><span class="line"><span class="comment"># 具名挂载：    -v 卷名:容器内路径</span></span><br><span class="line"><span class="comment"># 指定路径挂载: -v /宿主机路径:容器内路径</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 数据卷操作</span></span><br><span class="line">docker volume [ options ]</span><br><span class="line"></span><br><span class="line">Commands:</span><br><span class="line">  create      Create a volume</span><br><span class="line">  inspect     Display detailed information on one or more volumes</span><br><span class="line">  ls          List volumes</span><br><span class="line">  prune       Remove all unused <span class="built_in">local</span> volumes</span><br><span class="line">  rm          Remove one or more volumes</span><br></pre></td></tr></table></figure><p>demo：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 匿名挂载</span></span><br><span class="line">[root@VM-1-14-centos mysql]<span class="comment"># docker run -d -P --name nginx01 -v /etc/nginx nginx</span></span><br><span class="line"><span class="comment"># 查看所有的volume的情况</span></span><br><span class="line">[root@VM-1-14-centos mysql]<span class="comment"># docker volume ls</span></span><br><span class="line">DRIVER              VOLUME NAME</span><br><span class="line"><span class="built_in">local</span>               33ae588fae6d34f511a769948f0d3d123c9d45c442ac7728cb85599c2657e50d</span><br><span class="line">......</span><br><span class="line"><span class="comment"># 具名挂载</span></span><br><span class="line">[root@VM-1-14-centos mysql]<span class="comment"># docker run -d -P --name nginx02 -v juming-nginx:/etc/nginx nginx</span></span><br><span class="line">[root@VM-1-14-centos mysql]<span class="comment"># docker volume ls                  </span></span><br><span class="line">DRIVER              VOLUME NAME</span><br><span class="line"><span class="built_in">local</span>               juming-nginx</span><br><span class="line">......</span><br><span class="line"><span class="comment"># 查看详细信息</span></span><br><span class="line">[root@VM-1-14-centos mysql]<span class="comment"># docker volume inspect juming-nginx</span></span><br><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">&quot;CreatedAt&quot;</span>: <span class="string">&quot;2021-04-24T19:42:24+08:00&quot;</span>,</span><br><span class="line">        <span class="string">&quot;Driver&quot;</span>: <span class="string">&quot;local&quot;</span>,</span><br><span class="line">        <span class="string">&quot;Labels&quot;</span>: null,</span><br><span class="line">        <span class="string">&quot;Mountpoint&quot;</span>: <span class="string">&quot;/var/lib/docker/volumes/juming-nginx/_data&quot;</span>,</span><br><span class="line">        <span class="string">&quot;Name&quot;</span>: <span class="string">&quot;juming-nginx&quot;</span>,</span><br><span class="line">        <span class="string">&quot;Options&quot;</span>: null,</span><br><span class="line">        <span class="string">&quot;Scope&quot;</span>: <span class="string">&quot;local&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><ul><li>所有的docker容器内的卷，没有指定目录的情况下都是在<code>/var/lib/docker/volumes/xxxx/_data</code>下</li><li>如果指定了目录，docker volume ls 是查看不到的</li></ul><blockquote><p>通过具名挂载可以很容易地找到数据卷，因此通常使用具名挂载。</p></blockquote><h3 id="ro-rw"><a href="#ro-rw" class="headerlink" title="ro/rw"></a>ro/rw</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -v 容器内路径:ro/rw 改变读写权限</span></span><br><span class="line">ro <span class="comment">#readonly 只读（只能通过宿主机操作）</span></span><br><span class="line">rw <span class="comment">#readwrite 可读可写</span></span><br><span class="line">docker run -d -P --name nginx05 -v juming:/etc/nginx:ro nginx</span><br><span class="line">docker run -d -P --name nginx05 -v juming:/etc/nginx:rw nginx</span><br></pre></td></tr></table></figure><h3 id="Dockerfile中设置挂载"><a href="#Dockerfile中设置挂载" class="headerlink" title="Dockerfile中设置挂载"></a>Dockerfile中设置挂载</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-1-14-centos ~]<span class="comment"># mkdir docker_test</span></span><br><span class="line">[root@VM-1-14-centos ~]<span class="comment"># cd docker_test/</span></span><br><span class="line">[root@VM-1-14-centos docker_test]<span class="comment"># vim dockerfile1</span></span><br><span class="line">[root@VM-1-14-centos docker_test]<span class="comment"># cat dockerfile1 </span></span><br><span class="line">FROM centos  <span class="comment"># 设置基础镜像</span></span><br><span class="line">VOLUME [<span class="string">&quot;volume01&quot;</span>,<span class="string">&quot;volume02&quot;</span>]  <span class="comment"># 设置挂载，新建两个匿名卷</span></span><br><span class="line">CMD <span class="built_in">echo</span> <span class="string">&quot;----end----&quot;</span> <span class="comment"># 写出内部命令end</span></span><br><span class="line">CMD /bin/bash  <span class="comment"># 进入bin/bash</span></span><br><span class="line">[root@VM-1-14-centos docker_test]<span class="comment"># docker build -f /root/docker_test/dockerfile1 -t nephrencake/centos:1.0 .</span></span><br><span class="line">Sending build context to Docker daemon  2.048kB</span><br><span class="line">Step 1/4 : FROM centos</span><br><span class="line"> ---&gt; 300e315adb2f</span><br><span class="line">Step 2/4 : VOLUME [<span class="string">&quot;volume01&quot;</span>,<span class="string">&quot;volume02&quot;</span>]</span><br><span class="line"> ---&gt; Running <span class="keyword">in</span> 40898156bffb</span><br><span class="line">Removing intermediate container 40898156bffb</span><br><span class="line"> ---&gt; f7982a2145cb</span><br><span class="line">Step 3/4 : CMD <span class="built_in">echo</span> <span class="string">&quot;----end----&quot;</span> </span><br><span class="line"> ---&gt; Running <span class="keyword">in</span> cd21a00b4b6e</span><br><span class="line">Removing intermediate container cd21a00b4b6e</span><br><span class="line"> ---&gt; dc3c858b0b01</span><br><span class="line">Step 4/4 : CMD /bin/bash</span><br><span class="line"> ---&gt; Running <span class="keyword">in</span> d6937914df26</span><br><span class="line">Removing intermediate container d6937914df26</span><br><span class="line"> ---&gt; 706bb05073c4</span><br><span class="line">Successfully built 706bb05073c4</span><br><span class="line">Successfully tagged nephrencake/centos:1.0</span><br><span class="line">[root@VM-1-14-centos docker_test]<span class="comment"># docker images</span></span><br><span class="line">REPOSITORY            TAG       IMAGE ID       CREATED         SIZE</span><br><span class="line">nephrencake/centos    1.0       706bb05073c4   2 minutes ago   209MB</span><br><span class="line">[root@VM-1-14-centos docker_test]<span class="comment"># docker run -it 706bb05073c4</span></span><br><span class="line">[root@f42ba8b35f43 /]<span class="comment"># ls -l</span></span><br><span class="line">total 56</span><br><span class="line">......</span><br><span class="line">drwxr-xr-x   2 root root 4096 Apr 24 13:23 volume01  <span class="comment"># 发现设置的挂载数据卷</span></span><br><span class="line">drwxr-xr-x   2 root root 4096 Apr 24 13:23 volume02</span><br><span class="line">[root@VM-1-14-centos ~]<span class="comment"># docker inspect f42ba8b35f43</span></span><br><span class="line">......</span><br><span class="line">        <span class="string">&quot;Mounts&quot;</span>: [</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="string">&quot;Type&quot;</span>: <span class="string">&quot;volume&quot;</span>,</span><br><span class="line">                <span class="string">&quot;Name&quot;</span>: <span class="string">&quot;646d7481a3762934113020b27f86b43c980b3d76bddd15072b327785bc9672fc&quot;</span>,</span><br><span class="line">                <span class="string">&quot;Source&quot;</span>: <span class="string">&quot;/var/lib/docker/volumes/646d7481a3762934113020b27f86b43c980b3d76bddd15072b327785bc9672fc/_data&quot;</span>,</span><br><span class="line">                <span class="string">&quot;Destination&quot;</span>: <span class="string">&quot;volume02&quot;</span>,</span><br><span class="line">                <span class="string">&quot;Driver&quot;</span>: <span class="string">&quot;local&quot;</span>,</span><br><span class="line">                <span class="string">&quot;Mode&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">                <span class="string">&quot;RW&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">                <span class="string">&quot;Propagation&quot;</span>: <span class="string">&quot;&quot;</span></span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="string">&quot;Type&quot;</span>: <span class="string">&quot;volume&quot;</span>,</span><br><span class="line">                <span class="string">&quot;Name&quot;</span>: <span class="string">&quot;860d1d86119aca1e8f1022c5588542608ce116e0530a758b7ba5e590cc7545ce&quot;</span>,</span><br><span class="line">                <span class="string">&quot;Source&quot;</span>: <span class="string">&quot;/var/lib/docker/volumes/860d1d86119aca1e8f1022c5588542608ce116e0530a758b7ba5e590cc7545ce/_data&quot;</span>,</span><br><span class="line">                <span class="string">&quot;Destination&quot;</span>: <span class="string">&quot;volume01&quot;</span>,</span><br><span class="line">                <span class="string">&quot;Driver&quot;</span>: <span class="string">&quot;local&quot;</span>,</span><br><span class="line">                <span class="string">&quot;Mode&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">                <span class="string">&quot;RW&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">                <span class="string">&quot;Propagation&quot;</span>: <span class="string">&quot;&quot;</span></span><br><span class="line">            &#125;</span><br><span class="line">        ],</span><br><span class="line">......</span><br></pre></td></tr></table></figure><blockquote><p>docker run xxx 等效于 docker run xxx:latest</p><p>因此 docker run xxx:latest 是找不到 docker run xxx:1.0 的</p></blockquote><h3 id="多容器同步数据卷"><a href="#多容器同步数据卷" class="headerlink" title="多容器同步数据卷"></a>多容器同步数据卷</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -it --name container2 --volumes-from container1 image</span><br></pre></td></tr></table></figure><p>demo：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建docker01容器并在挂载数据卷中创建文件</span></span><br><span class="line">[root@VM-1-14-centos ~]<span class="comment"># docker run -it --name docker01 706bb05073c4</span></span><br><span class="line">[root@fc4ad8c3e129 /]<span class="comment"># ls -l</span></span><br><span class="line">total 56</span><br><span class="line">......</span><br><span class="line">drwxr-xr-x   2 root root 4096 Apr 25 00:22 volume01</span><br><span class="line">drwxr-xr-x   2 root root 4096 Apr 25 00:22 volume02</span><br><span class="line">[root@fc4ad8c3e129 /]<span class="comment"># cd volume01</span></span><br><span class="line">[root@fc4ad8c3e129 volume01]<span class="comment"># touch docker01.txt</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建docker02并查看同步的数据卷</span></span><br><span class="line">[root@VM-1-14-centos ~]<span class="comment"># docker run -it --name docker02 --volumes-from docker01 706bb05073c4</span></span><br><span class="line">[root@1f84a808b9bb /]<span class="comment"># ls -l</span></span><br><span class="line">total 56</span><br><span class="line">......</span><br><span class="line">drwxr-xr-x   2 root root 4096 Apr 25 00:22 volume01</span><br><span class="line">drwxr-xr-x   2 root root 4096 Apr 25 00:22 volume02</span><br><span class="line">[root@1f84a808b9bb /]<span class="comment"># cd volume01</span></span><br><span class="line">[root@1f84a808b9bb volume01]<span class="comment"># ls</span></span><br><span class="line">docker01.txt  <span class="comment"># docker01创建的文件在docker02中被同步</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除docker01并查看docker02的数据仍然存在</span></span><br><span class="line">[root@VM-1-14-centos ~]<span class="comment"># docker rm -f docker01</span></span><br><span class="line">docker01</span><br><span class="line">[root@1f84a808b9bb volume01]<span class="comment"># ls</span></span><br><span class="line">docker01.txt</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>container2和container1共享的数据卷<strong>互相共享但双向拷贝</strong>。</p></blockquote><h3 id="多个MySQL数据共享"><a href="#多个MySQL数据共享" class="headerlink" title="多个MySQL数据共享"></a>多个MySQL数据共享</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -p 3306:3306 -v /home/mysql/conf:/etc/mysql/conf.d -v /home/mysql/data:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=123456 --name mysql01 mysql:5.7</span><br><span class="line">docker run -d -p 3307:3306 -e MYSQL_ROOT_PASSWORD=123456 --name mysql02 --volumes-from mysql01  mysql:5.7</span><br><span class="line"><span class="comment"># -v 设置的挂载路径只需要设置一次，后来的继承即可</span></span><br></pre></td></tr></table></figure><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>便于集群建配置的同步共享。</p><p>数据卷的生命周期一直持续到所有容器被消灭为止（高可用）。</p><p>持久化到本地时，即使容器删除，本地数据依然保留。</p>]]></content>
      
      
      <categories>
          
          <category> Docker基础 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Docker基础Part3</title>
      <link href="/2021/04/Docker%E5%9F%BA%E7%A1%80Part3/"/>
      <url>/2021/04/Docker%E5%9F%BA%E7%A1%80Part3/</url>
      
        <content type="html"><![CDATA[<h1 id="Docker基础Part3——镜像讲解"><a href="#Docker基础Part3——镜像讲解" class="headerlink" title="Docker基础Part3——镜像讲解"></a>Docker基础Part3——镜像讲解</h1><p>[TOC]</p><h2 id="Docker镜像加载原理"><a href="#Docker镜像加载原理" class="headerlink" title="Docker镜像加载原理"></a>Docker镜像加载原理</h2><h3 id="镜像是什么"><a href="#镜像是什么" class="headerlink" title="镜像是什么"></a>镜像是什么</h3><p>镜像是一种轻量级、可执行的独立软件保，用来打包软件运行环境和基于运行环境开发的软件，他包含运行某个软件所需的所有内容，包括代码、运行时库、环境变量和配置文件。</p><blockquote><p>docker镜像文件 = (Linux的bootfs) + 基础镜像的rootfs + 镜像本身的依赖 + 镜像本身</p></blockquote><h3 id="UnionFs"><a href="#UnionFs" class="headerlink" title="UnionFs"></a>UnionFs</h3><p>Docker镜像实际上由一层一层的文件系统组成，这种层级的文件系统叫UnionFS。</p><p>UnionFs（联合文件系统）：Union文件系统是一种分层、轻量级并且高性能的文件系统，他支持对文件系统的修改（增加新的操作环境）作为一次提交来一层层的叠加，同时可以将不同目录挂载到同一个虚拟文件系统下。镜像可以通过分层来进行继承，基于基础镜像，可以制作各种具体的应用镜像。</p><blockquote><p>特性：一次同时加载多个文件系统，但从外面看起来，只能看到一个文件系统，联合加载会把各层需要文件系统叠加统合起来（<strong>不同的镜像可能会使用相同的部分层级文件</strong>），最终的文件系统会包含所有需要的底层文件和目录。</p></blockquote><h3 id="bootfs-amp-rootfs"><a href="#bootfs-amp-rootfs" class="headerlink" title="bootfs &amp; rootfs"></a>bootfs &amp; rootfs</h3><p>典型的Linux文件系统由<strong>bootfs</strong>和<strong>rootfs</strong>两部分组成，而 Docker 镜像的最底层就是 Linux 内核。</p><p>bootfs（boot file system）包含 bootloader和 kernel。bootloader主要负责引导加载内核 kernel。这一层与主机的Linux/Unix系统是一样的，用户不会修改这个文件系统 。在启动过程完成后，整个内核 kernel 都会被加载进内存，此时 bootfs 会被 umount 卸载从而释放出所占用的内存。</p><p>rootfs（root file system）在 bootfs之上。包括 /dev、/proc、/bin、/etc、/lib、/usr、/tmp 等再加上要运行用户应用所需要的所有配置文件，二进制文件和库文件。 各个版本的bootfs是一样的，区别就是rootfs。Linux 系统在启动时，rootfs 首先会被挂载为只读模式，然后在启动完成后被修改为读写模式，随后它们就可以被修改了。</p><blockquote><ul><li>所有 Docker 容器都共享主机系统的 bootfs 即 Linux 内核</li><li>每个容器有自己的 rootfs，它来自不同的 Linux 发行版的基础镜像，包括 Ubuntu，Debian 和 SUSE 等</li><li>所有基于一种基础镜像的容器都共享这种 rootfs</li></ul></blockquote><img src="/2021/04/Docker%E5%9F%BA%E7%A1%80Part3/20150825141358_122.png" alt="Docker" style="zoom:200%;"><h2 id="Docker分层理解"><a href="#Docker分层理解" class="headerlink" title="Docker分层理解"></a>Docker分层理解</h2><h3 id="分层共享"><a href="#分层共享" class="headerlink" title="分层共享"></a>分层共享</h3><p>Docker镜像采用分层结构最大的好处就是资源共享（镜像的每一层都可以被共享）。当多个镜像具备相同的一层镜像文件，则宿主机只需在磁盘上保留一份镜像文件（相同的镜像文件不会被重复下载），同时内存中也只需要加载一份镜像文件（相同的镜像文件不会被重复加载），就可以为所有的容器服务了。</p><ul><li>所有的 Docker镜像都起始于一个基础镜像层，当进行修改或添加新的内容时，就会在当前镜像层之上，创建新的镜像层。</li></ul><p><img src="/2021/04/Docker%E5%9F%BA%E7%A1%80Part3/image-20210424123316106.png" alt="image-20210424123316106"></p><ul><li>在添加额外的镜像层的同时，镜像始终保持是当前所有镜像的组合。</li></ul><p><img src="/2021/04/Docker%E5%9F%BA%E7%A1%80Part3/image-20210424123442809.png" alt="image-20210424123442809"></p><ul><li>对于版本更新的新文件，在打包合并镜像时会舍弃旧文件。</li></ul><p><img src="/2021/04/Docker%E5%9F%BA%E7%A1%80Part3/image-20210424123755365.png" alt="image-20210424123755365"></p><h3 id="存储引擎"><a href="#存储引擎" class="headerlink" title="存储引擎"></a>存储引擎</h3><p>Docker通过存储引擎（新版本采用快照机制）的方式来实现镜像层堆栈，并保证多镜像层对外展示为统一的文件系统。</p><p>Linux上可用的存储引撃有AUFS、 Overlay2、 Device Mapper、Btrfs以及ZFS。每种存储引擎都有其独有的性能特点。</p><p>Docker在 Windows上仅支持 windowsfilter 一种存储引擎，该引擎基于NTFS文件系统之上实现了分层和CoW。</p><h3 id="镜像层-amp-容器层"><a href="#镜像层-amp-容器层" class="headerlink" title="镜像层&amp;容器层"></a>镜像层&amp;容器层</h3><p>Docker 镜像都是只读的，当容器启动时，一个新的可写的容器层加载到镜像层的上方。</p><img src="/2021/04/Docker%E5%9F%BA%E7%A1%80Part3/1265713-20190402151517616-1614953387.png" alt="img" style="zoom: 150%;"><h2 id="提交镜像"><a href="#提交镜像" class="headerlink" title="提交镜像"></a>提交镜像</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker commit -m=<span class="string">&quot;描述信息&quot;</span> -a=<span class="string">&quot;作者&quot;</span> 容器id 镜像名:[TAG]</span><br></pre></td></tr></table></figure><p>demo:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1、启动一个默认的tomcat</span></span><br><span class="line">[root@VM-1-14-centos ~]<span class="comment"># docker run -d -p 8080:8080 tomcat</span></span><br><span class="line">[root@VM-1-14-centos ~]<span class="comment"># docker exec -it 容器id</span></span><br><span class="line"><span class="comment"># 2、默认的tomcat没有webapps应用，即/usr/local/tomcat/webapps下没有文件</span></span><br><span class="line">root@6043e496a1c0:/usr/<span class="built_in">local</span>/tomcat<span class="comment"># ls webapps</span></span><br><span class="line"><span class="comment"># 3、拷贝文件进去</span></span><br><span class="line">root@6043e496a1c0:/usr/<span class="built_in">local</span>/tomcat<span class="comment"># cp -r webapps.dist/* webapps</span></span><br><span class="line"><span class="comment"># 4、将操作过的容器通过commit提交为一个镜像</span></span><br><span class="line">[root@VM-1-14-centos ~]<span class="comment"># docker commit -a=&quot;NephrenCake&quot; -m=&quot;add webapps app&quot; 6043e496a1c0 tomcat02:1.0</span></span><br><span class="line">sha256:ad23de72c26b7b3fb360fd745734738a2be98043bff43938a7ee0b8d772e7708</span><br><span class="line">[root@VM-1-14-centos ~]<span class="comment"># docker images</span></span><br><span class="line">REPOSITORY            TAG       IMAGE ID       CREATED          SIZE</span><br><span class="line">tomcat02              1.0       ad23de72c26b   19 seconds ago   672MB</span><br><span class="line">tomcat                latest    c0e850d7b9bb   31 hours ago     667MB</span><br><span class="line">portainer/portainer   latest    580c0e4e98b0   5 weeks ago      79.1MB</span><br></pre></td></tr></table></figure><blockquote><p>刚开始学习时，可以对概念理解模糊，但一定要实践。最终通过实践和概念相结合，完全理解知识点。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Docker基础 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Docker基础Part2</title>
      <link href="/2021/04/Docker%E5%9F%BA%E7%A1%80Part2/"/>
      <url>/2021/04/Docker%E5%9F%BA%E7%A1%80Part2/</url>
      
        <content type="html"><![CDATA[<h1 id="Docker基础Part2——基本命令"><a href="#Docker基础Part2——基本命令" class="headerlink" title="Docker基础Part2——基本命令"></a>Docker基础Part2——基本命令</h1><p>[TOC]</p><h2 id="帮助命令"><a href="#帮助命令" class="headerlink" title="帮助命令"></a>帮助命令</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker version  <span class="comment"># 版本信息</span></span><br><span class="line">docker info  <span class="comment"># 系统信息，包括镜像、容器、运行状态、插件</span></span><br><span class="line">docker 命令 --<span class="built_in">help</span></span><br></pre></td></tr></table></figure><p>帮助文档 <a href="https://docs.docker.com/reference/">https://docs.docker.com/reference/</a></p><h2 id="镜像命令"><a href="#镜像命令" class="headerlink" title="镜像命令"></a>镜像命令</h2><blockquote><p>注意这里是镜像，不是容器。</p></blockquote><h3 id="docker-images"><a href="#docker-images" class="headerlink" title="docker images"></a>docker images</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-1-14-centos ~]<span class="comment"># docker images</span></span><br><span class="line">REPOSITORY    TAG       IMAGE ID       CREATED       SIZE</span><br><span class="line">hello-world   latest    d1165f221234   6 weeks ago   13.3kB</span><br><span class="line"></span><br><span class="line"><span class="comment"># 解释</span></span><br><span class="line">REPOSITORY：镜像的仓库源</span><br><span class="line">TAG：镜像的标签</span><br><span class="line">IMAGE ID：镜像ID</span><br><span class="line">CREATED：镜像创建时间</span><br><span class="line">SIZE：镜像大小</span><br><span class="line"></span><br><span class="line"><span class="comment"># 可选项</span></span><br><span class="line">  -a, --all             <span class="comment"># 列出所有镜像</span></span><br><span class="line">  -q, --quiet           <span class="comment"># 只显示镜像</span></span><br></pre></td></tr></table></figure><h3 id="docker-search"><a href="#docker-search" class="headerlink" title="docker search"></a>docker search</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-1-14-centos ~]<span class="comment"># docker search mysql</span></span><br><span class="line">NAME                              DESCRIPTION                                     STARS     OFFICIAL   AUTOMATED</span><br><span class="line">mysql                             MySQL is a widely used, open-source relation…   10777     [OK]       </span><br><span class="line">mariadb                           MariaDB Server is a high performing open sou…   4058      [OK]       </span><br><span class="line">......</span><br><span class="line"></span><br><span class="line"><span class="comment"># 可选项</span></span><br><span class="line">  -f, --filter filter   Filter output based on conditions provided</span><br><span class="line">      --format string   Pretty-print search using a Go template</span><br><span class="line">      --<span class="built_in">limit</span> int       Max number of search results (default 25)</span><br><span class="line">      --no-trunc        Don<span class="string">&#x27;t truncate output</span></span><br><span class="line"><span class="string">      </span></span><br><span class="line"><span class="string"># demo</span></span><br><span class="line"><span class="string">docker search mysql --filter=STARS=3000  # 只显示stars&gt;=3k的</span></span><br></pre></td></tr></table></figure><h3 id="docker-pull"><a href="#docker-pull" class="headerlink" title="docker pull"></a>docker pull</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-1-14-centos ~]<span class="comment"># docker pull mysql</span></span><br><span class="line">Using default tag: latest  <span class="comment"># 不指定tag则默认latest</span></span><br><span class="line">latest: Pulling from library/mysql</span><br><span class="line">f7ec5a41d630: Pull complete  <span class="comment"># 分层下载是docker的核心，联合文件系统</span></span><br><span class="line">9444bb562699: Pull complete </span><br><span class="line">6a4207b96940: Pull complete </span><br><span class="line">181cefd361ce: Pull complete </span><br><span class="line">8a2090759d8a: Pull complete </span><br><span class="line">15f235e0d7ee: Pull complete </span><br><span class="line">d870539cd9db: Pull complete </span><br><span class="line">493aaa84617a: Pull complete </span><br><span class="line">bfc0e534fc78: Pull complete </span><br><span class="line">fae20d253f9d: Pull complete </span><br><span class="line">9350664305b3: Pull complete </span><br><span class="line">e47da95a5aab: Pull complete </span><br><span class="line">Digest: sha256:04ee7141256e83797ea4a84a4d31b1f1bc10111c8d1bc1879d52729ccd19e20a  <span class="comment"># 签名</span></span><br><span class="line">Status: Downloaded newer image <span class="keyword">for</span> mysql:latest</span><br><span class="line">docker.io/library/mysql:latest  <span class="comment"># 真实地址 </span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 两者等价</span></span><br><span class="line">docker pull mysql</span><br><span class="line">docker pull docker.io/library/mysql:latest</span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定版本下载(一定要来源于官方支持的版本)</span></span><br><span class="line">[root@VM-1-14-centos ~]<span class="comment"># docker pull mysql:5.7</span></span><br><span class="line">5.7: Pulling from library/mysql</span><br><span class="line">f7ec5a41d630: Already exists  <span class="comment"># 已存在的部分分层文件可以共用，不需要重复下载</span></span><br><span class="line">9444bb562699: Already exists </span><br><span class="line">6a4207b96940: Already exists </span><br><span class="line">181cefd361ce: Already exists </span><br><span class="line">8a2090759d8a: Already exists </span><br><span class="line">15f235e0d7ee: Already exists </span><br><span class="line">d870539cd9db: Already exists </span><br><span class="line">cb7af63cbefa: Pull complete  <span class="comment"># 只需要更新不同的文件</span></span><br><span class="line">151f1721bdbf: Pull complete </span><br><span class="line">fcd19c3dd488: Pull complete </span><br><span class="line">415af2aa5ddc: Pull complete </span><br><span class="line">Digest: sha256:a655529fdfcbaf0ef28984d68a3e21778e061c886ff458b677391924f62fb457</span><br><span class="line">Status: Downloaded newer image <span class="keyword">for</span> mysql:5.7</span><br><span class="line">docker.io/library/mysql:5.7</span><br><span class="line"></span><br><span class="line"><span class="comment"># 可选项</span></span><br><span class="line">  -a, --all-tags                Download all tagged images <span class="keyword">in</span> the repository</span><br><span class="line">      --disable-content-trust   Skip image verification (default <span class="literal">true</span>)</span><br><span class="line">      --platform string         Set platform <span class="keyword">if</span> server is multi-platform capable</span><br><span class="line">  -q, --quiet                   Suppress verbose output</span><br></pre></td></tr></table></figure><h3 id="docker-rmi"><a href="#docker-rmi" class="headerlink" title="docker rmi"></a>docker rmi</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-1-14-centos ~]<span class="comment"># docker rmi -f 87eca374c0ed</span></span><br><span class="line">Untagged: mysql:5.7</span><br><span class="line">Untagged: mysql@sha256:a655529fdfcbaf0ef28984d68a3e21778e061c886ff458b677391924f62fb457</span><br><span class="line">Deleted: sha256:87eca374c0ed97f0f0b504174b0d22b0a0add454414c0dbf5ae43870369f6854  <span class="comment"># 只删除了5.7部分</span></span><br><span class="line">Deleted: sha256:3b035442a2f8d52d6c5c2d83a18c6c21a89b4dc6c89b481bcf40df89087655ce</span><br><span class="line">Deleted: sha256:a223f1762b2c619a59b81fc2304bf4c9b791c777c8bdb19760c09cbd1f061efc</span><br><span class="line">Deleted: sha256:92402939b3fd03bee3745eb90df9799bcb7d0ef92ca8ecf7ef37ad9c8a550084</span><br><span class="line">Deleted: sha256:028b21e33aa4cd9c88acdd194d5cbef25638ffbca8669bfc0da72ad1eb148997</span><br><span class="line"></span><br><span class="line"><span class="comment"># rmi中i表示image</span></span><br><span class="line"><span class="comment"># -f全部删除</span></span><br><span class="line"><span class="comment"># 可以通过镜像的名字或者id删</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除多个/所有镜像</span></span><br><span class="line">[root@VM-1-14-centos ~]<span class="comment"># docker rmi -f $(docker images -aq)</span></span><br></pre></td></tr></table></figure><h2 id="容器命令"><a href="#容器命令" class="headerlink" title="容器命令"></a>容器命令</h2><h3 id="启动容器"><a href="#启动容器" class="headerlink" title="启动容器"></a>启动容器</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">docker run [ option ] image</span><br><span class="line"></span><br><span class="line"><span class="comment"># 参数说明</span></span><br><span class="line">-name=<span class="string">&quot;Name&quot;</span>  <span class="comment"># 容器名字</span></span><br><span class="line">-d            <span class="comment"># 后台方式运行</span></span><br><span class="line">-it           <span class="comment"># 使用交互方式运行，进入容器查看内容</span></span><br><span class="line">-p            <span class="comment"># 指定容器端口 -p 8080:8080</span></span><br><span class="line">    -p ip:主机端口:容器端口</span><br><span class="line">    -p 主机端口:容器端口  <span class="comment"># 常用，将主机端口映射到容器端口</span></span><br><span class="line">    -p 容器端口  <span class="comment"># 内部使用</span></span><br><span class="line">    容器端口</span><br><span class="line">-P            <span class="comment"># 随机指定端口</span></span><br></pre></td></tr></table></figure><blockquote><p>每次run都是新建一个容器！</p></blockquote><p>demo</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在 linux 上下载 centos 镜像，启动并进入容器</span></span><br><span class="line"><span class="comment"># 使用 /bin/bash 或 /bin/sh 启用控制台命令交互</span></span><br><span class="line"><span class="comment"># 此处主机名 33a022c1918a 就是容器id</span></span><br><span class="line"><span class="comment"># 此时这个容器内部就是一个centos系统，但是很多地方不完善</span></span><br><span class="line"><span class="comment"># exit退出镜像回到主机</span></span><br><span class="line">[root@VM-1-14-centos ~]<span class="comment"># docker pull centos</span></span><br><span class="line">[root@VM-1-14-centos ~]<span class="comment"># docker run -it centos /bin/bash</span></span><br><span class="line">[root@33a022c1918a /]<span class="comment"># ls</span></span><br><span class="line">bin  dev  etc  home  lib  lib64  lost+found  media  mnt  opt  proc  root  run  sbin  srv  sys  tmp  usr  var</span><br><span class="line">[root@33a022c1918a /]<span class="comment"># exit</span></span><br><span class="line"><span class="built_in">exit</span></span><br><span class="line">[root@VM-1-14-centos ~]<span class="comment"># ls /</span></span><br><span class="line">bin  boot  data  dev  etc  home  lib  lib64  lost+found  media  mnt  opt  proc  root  run  sbin  srv  sys  tmp  usr  var</span><br></pre></td></tr></table></figure><h3 id="查看容器"><a href="#查看容器" class="headerlink" title="查看容器"></a>查看容器</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">docker ps [ options ]</span><br><span class="line"></span><br><span class="line">Options:</span><br><span class="line">  -a, --all             <span class="comment"># 列出当前正在运行(默认)+历史运行过的容器</span></span><br><span class="line">  -n, --last int        <span class="comment"># 最近n个创建过的容器</span></span><br><span class="line">  -q, --quiet           <span class="comment"># 只显示id</span></span><br></pre></td></tr></table></figure><p>demo</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-1-14-centos ~]<span class="comment"># docker ps</span></span><br><span class="line">CONTAINER ID   IMAGE     COMMAND   CREATED   STATUS    PORTS     NAMES</span><br><span class="line">[root@VM-1-14-centos ~]<span class="comment"># docker ps -all</span></span><br><span class="line">CONTAINER ID   IMAGE     COMMAND       CREATED          STATUS                       PORTS     NAMES</span><br><span class="line">33a022c1918a   centos    <span class="string">&quot;/bin/bash&quot;</span>   13 minutes ago   Exited (127) 9 minutes ago             nostalgic_hermann</span><br><span class="line">[root@VM-1-14-centos ~]<span class="comment"># docker ps -a</span></span><br><span class="line">CONTAINER ID   IMAGE          COMMAND       CREATED          STATUS                       PORTS     NAMES</span><br><span class="line">33a022c1918a   centos         <span class="string">&quot;/bin/bash&quot;</span>   14 minutes ago   Exited (127) 9 minutes ago             nostalgic_hermann</span><br><span class="line">d036353864f6   d1165f221234   <span class="string">&quot;/hello&quot;</span>      2 days ago       Exited (0) 2 days ago                  cranky_nash</span><br><span class="line">[root@VM-1-14-centos ~]<span class="comment"># docker ps -aq</span></span><br><span class="line">33a022c1918a</span><br><span class="line">d036353864f6</span><br></pre></td></tr></table></figure><h3 id="退出容器"><a href="#退出容器" class="headerlink" title="退出容器"></a>退出容器</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">exit</span>  <span class="comment"># 退出并停止容器运行</span></span><br><span class="line">ctrl+P+Q  <span class="comment"># 退出但不停止</span></span><br></pre></td></tr></table></figure><h3 id="删除容器"><a href="#删除容器" class="headerlink" title="删除容器"></a>删除容器</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker rm 容器id  <span class="comment"># 删除指定的容器，不能删除正在运行的容器，除非 rm -f</span></span><br><span class="line">docker rm -f $(docker ps -aq)  <span class="comment"># 删除所有容器</span></span><br><span class="line">docker ps -aq | xargs docker rm  <span class="comment"># 删除所有容器</span></span><br></pre></td></tr></table></figure><h3 id="启动-停止容器"><a href="#启动-停止容器" class="headerlink" title="启动/停止容器"></a>启动/停止容器</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker start 容器id  <span class="comment"># 启动</span></span><br><span class="line">docker restart 容器id  <span class="comment"># 重启</span></span><br><span class="line">docker stop 容器id  <span class="comment"># 停止</span></span><br><span class="line">docker <span class="built_in">kill</span> 容器id  <span class="comment"># 强制停止</span></span><br></pre></td></tr></table></figure><h2 id="其他命令"><a href="#其他命令" class="headerlink" title="其他命令"></a>其他命令</h2><h3 id="后台启动容器"><a href="#后台启动容器" class="headerlink" title="后台启动容器"></a>后台启动容器</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># docker run -d 镜像</span></span><br><span class="line">[root@VM-1-14-centos ~]<span class="comment"># docker run -d centos</span></span><br><span class="line">9dfce832258f344250b3ad0ddaed6e55a9e4ae711a558bb5083dcf9162dd551b</span><br><span class="line"></span><br><span class="line"><span class="comment"># 虽然创建了容器后台运行，但是没有检测到前台应用进程，所以自动停止了。</span></span><br><span class="line"><span class="comment"># 例如：Nginx容器启动之后，发现自己没有提供服务，就立刻停止</span></span><br></pre></td></tr></table></figure><h3 id="查看日志"><a href="#查看日志" class="headerlink" title="查看日志"></a>查看日志</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">docker logs</span><br><span class="line"></span><br><span class="line">Options:</span><br><span class="line">      --details        Show extra details provided to logs</span><br><span class="line">  -f, --follow         Follow <span class="built_in">log</span> output</span><br><span class="line">      --since string   Show logs since timestamp (e.g. 2013-01-02T13:23:37Z) or relative (e.g. 42m <span class="keyword">for</span> 42 minutes)</span><br><span class="line">  -n, --tail string    Number of lines to show from the end of the logs (default <span class="string">&quot;all&quot;</span>)</span><br><span class="line">  -t, --timestamps     Show timestamps</span><br><span class="line">      --until string   Show logs before a timestamp (e.g. 2013-01-02T13:23:37Z) or relative (e.g. 42m <span class="keyword">for</span> 42 minutes)</span><br></pre></td></tr></table></figure><p>demo</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-1-14-centos ~]<span class="comment"># docker run -d centos /bin/bash -c &quot;while true;do echo NephrenCake;sleep 1;done&quot;</span></span><br><span class="line">[root@VM-1-14-centos ~]<span class="comment"># docker ps</span></span><br><span class="line">CONTAINER ID   IMAGE     COMMAND                  CREATED         STATUS         PORTS     NAMES</span><br><span class="line">813d27116121   centos    <span class="string">&quot;/bin/bash -c &#x27;while…&quot;</span>   7 minutes ago   Up 7 minutes             peaceful_gag</span><br><span class="line">[root@VM-1-14-centos ~]<span class="comment"># docker logs -f -t --tail 5 813d27116121</span></span><br><span class="line">2021-04-23T06:18:08.137574755Z NephrenCake</span><br><span class="line">......  <span class="comment"># ctrl + c 退出</span></span><br><span class="line">[root@VM-1-14-centos ~]<span class="comment"># docker stop 813d27116121</span></span><br></pre></td></tr></table></figure><h3 id="查看容器中进程信息"><a href="#查看容器中进程信息" class="headerlink" title="查看容器中进程信息"></a>查看容器中进程信息</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker top 进程id</span><br></pre></td></tr></table></figure><p>demo</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-1-14-centos ~]<span class="comment"># docker restart 813d27116121</span></span><br><span class="line">813d27116121</span><br><span class="line">[root@VM-1-14-centos ~]<span class="comment"># docker logs -ft --tail 5 813d27116121</span></span><br><span class="line">2021-04-23T06:38:02.133138721Z NephrenCake</span><br><span class="line">......  <span class="comment"># restart重新启动，依然执行之前的命令</span></span><br><span class="line">[root@VM-1-14-centos ~]<span class="comment"># docker top 813d27116121</span></span><br><span class="line">UID                 PID                 PPID                C                   STIME               TTY                 TIME                CMD</span><br><span class="line">root                11818               11796               0                   14:38               ?                   00:00:00            /bin/bash -c <span class="keyword">while</span> <span class="literal">true</span>;<span class="keyword">do</span> <span class="built_in">echo</span> NephrenCake;sleep 1;<span class="keyword">done</span></span><br><span class="line">root                11935               11818               0                   14:38               ?                   00:00:00            /usr/bin/coreutils --coreutils-prog-shebang=sleep /usr/bin/sleep 1</span><br></pre></td></tr></table></figure><h3 id="查看镜像的元数据"><a href="#查看镜像的元数据" class="headerlink" title="查看镜像的元数据"></a>查看镜像的元数据</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">docker inspect [ options ] 容器id</span><br><span class="line"></span><br><span class="line">Options:</span><br><span class="line">  -f, --format string   Format the output using the given Go template</span><br><span class="line">  -s, --size            Display total file sizes <span class="keyword">if</span> the <span class="built_in">type</span> is container</span><br><span class="line">      --<span class="built_in">type</span> string     Return JSON <span class="keyword">for</span> specified <span class="built_in">type</span></span><br></pre></td></tr></table></figure><p>demo</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 容器的元数据================================================================================================</span></span><br><span class="line">[root@VM-1-14-centos ~]<span class="comment"># docker inspect 813d27116121</span></span><br><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">&quot;Id&quot;</span>: <span class="string">&quot;813d2711612126bdc63c81b30d29f11894f4d51a179749e33b1500e917b56b38&quot;</span>,  <span class="comment"># 使用的id只是全id的缩写</span></span><br><span class="line">        <span class="string">&quot;Created&quot;</span>: <span class="string">&quot;2021-04-23T06:09:40.625524708Z&quot;</span>,  <span class="comment"># 创建时间</span></span><br><span class="line">        <span class="string">&quot;Path&quot;</span>: <span class="string">&quot;/bin/bash&quot;</span>,  <span class="comment"># 控制台目录</span></span><br><span class="line">        <span class="string">&quot;Args&quot;</span>: [  <span class="comment"># 传递的参数</span></span><br><span class="line">            <span class="string">&quot;-c&quot;</span>,</span><br><span class="line">            <span class="string">&quot;while true;do echo NephrenCake;sleep 1;done&quot;</span></span><br><span class="line">        ],</span><br><span class="line">        <span class="string">&quot;State&quot;</span>: &#123;</span><br><span class="line">            <span class="string">&quot;Status&quot;</span>: <span class="string">&quot;running&quot;</span>,</span><br><span class="line">            <span class="string">&quot;Running&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">            <span class="string">&quot;Paused&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">            <span class="string">&quot;Restarting&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">            <span class="string">&quot;OOMKilled&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">            <span class="string">&quot;Dead&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">            <span class="string">&quot;Pid&quot;</span>: 11818,  <span class="comment"># 父进程id</span></span><br><span class="line">            <span class="string">&quot;ExitCode&quot;</span>: 0,</span><br><span class="line">            <span class="string">&quot;Error&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">            <span class="string">&quot;StartedAt&quot;</span>: <span class="string">&quot;2021-04-23T06:38:02.136315705Z&quot;</span>,</span><br><span class="line">            <span class="string">&quot;FinishedAt&quot;</span>: <span class="string">&quot;2021-04-23T06:23:18.602040203Z&quot;</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">&quot;Image&quot;</span>: <span class="string">&quot;sha256:300e315adb2f96afe5f0b2780b87f28ae95231fe3bdd1e16b9ba606307728f55&quot;</span>,  <span class="comment"># 镜像源</span></span><br><span class="line">        <span class="string">&quot;ResolvConfPath&quot;</span>: <span class="string">&quot;/var/lib/docker/containers/813d2711612126bdc63c81b30d29f11894f4d51a179749e33b1500e917b56b38/resolv.conf&quot;</span>,</span><br><span class="line">        <span class="string">&quot;HostnamePath&quot;</span>: <span class="string">&quot;/var/lib/docker/containers/813d2711612126bdc63c81b30d29f11894f4d51a179749e33b1500e917b56b38/hostname&quot;</span>,</span><br><span class="line">        <span class="string">&quot;HostsPath&quot;</span>: <span class="string">&quot;/var/lib/docker/containers/813d2711612126bdc63c81b30d29f11894f4d51a179749e33b1500e917b56b38/hosts&quot;</span>,</span><br><span class="line">        <span class="string">&quot;LogPath&quot;</span>: <span class="string">&quot;/var/lib/docker/containers/813d2711612126bdc63c81b30d29f11894f4d51a179749e33b1500e917b56b38/813d2711612126bdc63c81b30d29f11894f4d51a179749e33b1500e917b56b38-json.log&quot;</span>,</span><br><span class="line">        <span class="string">&quot;Name&quot;</span>: <span class="string">&quot;/peaceful_gagarin&quot;</span>,</span><br><span class="line">        <span class="string">&quot;RestartCount&quot;</span>: 0,</span><br><span class="line">        <span class="string">&quot;Driver&quot;</span>: <span class="string">&quot;overlay2&quot;</span>,</span><br><span class="line">        <span class="string">&quot;Platform&quot;</span>: <span class="string">&quot;linux&quot;</span>,</span><br><span class="line">        <span class="string">&quot;MountLabel&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">        <span class="string">&quot;ProcessLabel&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">        <span class="string">&quot;AppArmorProfile&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">        <span class="string">&quot;ExecIDs&quot;</span>: null,</span><br><span class="line">        <span class="string">&quot;HostConfig&quot;</span>: &#123;  <span class="comment"># 主机配置</span></span><br><span class="line">            <span class="string">&quot;Binds&quot;</span>: null,</span><br><span class="line">            <span class="string">&quot;ContainerIDFile&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">            <span class="string">&quot;LogConfig&quot;</span>: &#123;</span><br><span class="line">                <span class="string">&quot;Type&quot;</span>: <span class="string">&quot;json-file&quot;</span>,</span><br><span class="line">                <span class="string">&quot;Config&quot;</span>: &#123;&#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="string">&quot;NetworkMode&quot;</span>: <span class="string">&quot;default&quot;</span>,</span><br><span class="line">            <span class="string">&quot;PortBindings&quot;</span>: &#123;&#125;,</span><br><span class="line">            <span class="string">&quot;RestartPolicy&quot;</span>: &#123;</span><br><span class="line">                <span class="string">&quot;Name&quot;</span>: <span class="string">&quot;no&quot;</span>,</span><br><span class="line">                <span class="string">&quot;MaximumRetryCount&quot;</span>: 0</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="string">&quot;AutoRemove&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">            <span class="string">&quot;VolumeDriver&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">            <span class="string">&quot;VolumesFrom&quot;</span>: null,</span><br><span class="line">            <span class="string">&quot;CapAdd&quot;</span>: null,</span><br><span class="line">            <span class="string">&quot;CapDrop&quot;</span>: null,</span><br><span class="line">            <span class="string">&quot;CgroupnsMode&quot;</span>: <span class="string">&quot;host&quot;</span>,</span><br><span class="line">            <span class="string">&quot;Dns&quot;</span>: [],</span><br><span class="line">            <span class="string">&quot;DnsOptions&quot;</span>: [],</span><br><span class="line">            <span class="string">&quot;DnsSearch&quot;</span>: [],</span><br><span class="line">            <span class="string">&quot;ExtraHosts&quot;</span>: null,</span><br><span class="line">            <span class="string">&quot;GroupAdd&quot;</span>: null,</span><br><span class="line">            <span class="string">&quot;IpcMode&quot;</span>: <span class="string">&quot;private&quot;</span>,</span><br><span class="line">            <span class="string">&quot;Cgroup&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">            <span class="string">&quot;Links&quot;</span>: null,</span><br><span class="line">            <span class="string">&quot;OomScoreAdj&quot;</span>: 0,</span><br><span class="line">            <span class="string">&quot;PidMode&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">            <span class="string">&quot;Privileged&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">            <span class="string">&quot;PublishAllPorts&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">            <span class="string">&quot;ReadonlyRootfs&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">            <span class="string">&quot;SecurityOpt&quot;</span>: null,</span><br><span class="line">            <span class="string">&quot;UTSMode&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">            <span class="string">&quot;UsernsMode&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">            <span class="string">&quot;ShmSize&quot;</span>: 67108864,</span><br><span class="line">            <span class="string">&quot;Runtime&quot;</span>: <span class="string">&quot;runc&quot;</span>,</span><br><span class="line">            <span class="string">&quot;ConsoleSize&quot;</span>: [</span><br><span class="line">                0,</span><br><span class="line">                0</span><br><span class="line">            ],</span><br><span class="line">            <span class="string">&quot;Isolation&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">            <span class="string">&quot;CpuShares&quot;</span>: 0,</span><br><span class="line">            <span class="string">&quot;Memory&quot;</span>: 0,</span><br><span class="line">            <span class="string">&quot;NanoCpus&quot;</span>: 0,</span><br><span class="line">            <span class="string">&quot;CgroupParent&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">            <span class="string">&quot;BlkioWeight&quot;</span>: 0,</span><br><span class="line">            <span class="string">&quot;BlkioWeightDevice&quot;</span>: [],</span><br><span class="line">            <span class="string">&quot;BlkioDeviceReadBps&quot;</span>: null,</span><br><span class="line">            <span class="string">&quot;BlkioDeviceWriteBps&quot;</span>: null,</span><br><span class="line">            <span class="string">&quot;BlkioDeviceReadIOps&quot;</span>: null,</span><br><span class="line">            <span class="string">&quot;BlkioDeviceWriteIOps&quot;</span>: null,</span><br><span class="line">            <span class="string">&quot;CpuPeriod&quot;</span>: 0,</span><br><span class="line">            <span class="string">&quot;CpuQuota&quot;</span>: 0,</span><br><span class="line">            <span class="string">&quot;CpuRealtimePeriod&quot;</span>: 0,</span><br><span class="line">            <span class="string">&quot;CpuRealtimeRuntime&quot;</span>: 0,</span><br><span class="line">            <span class="string">&quot;CpusetCpus&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">            <span class="string">&quot;CpusetMems&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">            <span class="string">&quot;Devices&quot;</span>: [],</span><br><span class="line">            <span class="string">&quot;DeviceCgroupRules&quot;</span>: null,</span><br><span class="line">            <span class="string">&quot;DeviceRequests&quot;</span>: null,</span><br><span class="line">            <span class="string">&quot;KernelMemory&quot;</span>: 0,</span><br><span class="line">            <span class="string">&quot;KernelMemoryTCP&quot;</span>: 0,</span><br><span class="line">            <span class="string">&quot;MemoryReservation&quot;</span>: 0,</span><br><span class="line">            <span class="string">&quot;MemorySwap&quot;</span>: 0,</span><br><span class="line">            <span class="string">&quot;MemorySwappiness&quot;</span>: null,</span><br><span class="line">            <span class="string">&quot;OomKillDisable&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">            <span class="string">&quot;PidsLimit&quot;</span>: null,</span><br><span class="line">            <span class="string">&quot;Ulimits&quot;</span>: null,</span><br><span class="line">            <span class="string">&quot;CpuCount&quot;</span>: 0,</span><br><span class="line">            <span class="string">&quot;CpuPercent&quot;</span>: 0,</span><br><span class="line">            <span class="string">&quot;IOMaximumIOps&quot;</span>: 0,</span><br><span class="line">            <span class="string">&quot;IOMaximumBandwidth&quot;</span>: 0,</span><br><span class="line">            <span class="string">&quot;MaskedPaths&quot;</span>: [</span><br><span class="line">                <span class="string">&quot;/proc/asound&quot;</span>,</span><br><span class="line">                <span class="string">&quot;/proc/acpi&quot;</span>,</span><br><span class="line">                <span class="string">&quot;/proc/kcore&quot;</span>,</span><br><span class="line">                <span class="string">&quot;/proc/keys&quot;</span>,</span><br><span class="line">                <span class="string">&quot;/proc/latency_stats&quot;</span>,</span><br><span class="line">                <span class="string">&quot;/proc/timer_list&quot;</span>,</span><br><span class="line">                <span class="string">&quot;/proc/timer_stats&quot;</span>,</span><br><span class="line">                <span class="string">&quot;/proc/sched_debug&quot;</span>,</span><br><span class="line">                <span class="string">&quot;/proc/scsi&quot;</span>,</span><br><span class="line">                <span class="string">&quot;/sys/firmware&quot;</span></span><br><span class="line">            ],</span><br><span class="line">            <span class="string">&quot;ReadonlyPaths&quot;</span>: [</span><br><span class="line">                <span class="string">&quot;/proc/bus&quot;</span>,</span><br><span class="line">                <span class="string">&quot;/proc/fs&quot;</span>,</span><br><span class="line">                <span class="string">&quot;/proc/irq&quot;</span>,</span><br><span class="line">                <span class="string">&quot;/proc/sys&quot;</span>,</span><br><span class="line">                <span class="string">&quot;/proc/sysrq-trigger&quot;</span></span><br><span class="line">            ]</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">&quot;GraphDriver&quot;</span>: &#123;</span><br><span class="line">            <span class="string">&quot;Data&quot;</span>: &#123;</span><br><span class="line">                <span class="string">&quot;LowerDir&quot;</span>: <span class="string">&quot;/var/lib/docker/overlay2/b6d0d37faec7c071970c4880b019ff1d55f117ef18406c988b813f302bb227d0-init/diff:/var/lib/docker/overlay2/e7f999e147eaa9cc6658059fe0a66e6f6bca79957c99cf69bfe563b82bcbd2be/diff&quot;</span>,</span><br><span class="line">                <span class="string">&quot;MergedDir&quot;</span>: <span class="string">&quot;/var/lib/docker/overlay2/b6d0d37faec7c071970c4880b019ff1d55f117ef18406c988b813f302bb227d0/merged&quot;</span>,</span><br><span class="line">                <span class="string">&quot;UpperDir&quot;</span>: <span class="string">&quot;/var/lib/docker/overlay2/b6d0d37faec7c071970c4880b019ff1d55f117ef18406c988b813f302bb227d0/diff&quot;</span>,</span><br><span class="line">                <span class="string">&quot;WorkDir&quot;</span>: <span class="string">&quot;/var/lib/docker/overlay2/b6d0d37faec7c071970c4880b019ff1d55f117ef18406c988b813f302bb227d0/work&quot;</span></span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="string">&quot;Name&quot;</span>: <span class="string">&quot;overlay2&quot;</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">&quot;Mounts&quot;</span>: [  <span class="comment"># 挂载</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="string">&quot;Type&quot;</span>: <span class="string">&quot;bind&quot;</span>,</span><br><span class="line">                <span class="string">&quot;Source&quot;</span>: <span class="string">&quot;/home/volume&quot;</span>,  <span class="comment"># 主机内目录</span></span><br><span class="line">                <span class="string">&quot;Destination&quot;</span>: <span class="string">&quot;/home&quot;</span>,  <span class="comment"># 容器内目录，目标地址</span></span><br><span class="line">                <span class="string">&quot;Mode&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">                <span class="string">&quot;RW&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">                <span class="string">&quot;Propagation&quot;</span>: <span class="string">&quot;rprivate&quot;</span></span><br><span class="line">            &#125;</span><br><span class="line">        ],</span><br><span class="line">        <span class="string">&quot;Config&quot;</span>: &#123;</span><br><span class="line">            <span class="string">&quot;Hostname&quot;</span>: <span class="string">&quot;813d27116121&quot;</span>,  <span class="comment"># 容器名</span></span><br><span class="line">            <span class="string">&quot;Domainname&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">            <span class="string">&quot;User&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">            <span class="string">&quot;AttachStdin&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">            <span class="string">&quot;AttachStdout&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">            <span class="string">&quot;AttachStderr&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">            <span class="string">&quot;Tty&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">            <span class="string">&quot;OpenStdin&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">            <span class="string">&quot;StdinOnce&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">            <span class="string">&quot;Env&quot;</span>: [  <span class="comment"># 环境变量</span></span><br><span class="line">                <span class="string">&quot;PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin&quot;</span></span><br><span class="line">            ],</span><br><span class="line">            <span class="string">&quot;Cmd&quot;</span>: [  <span class="comment"># command命令行命令</span></span><br><span class="line">                <span class="string">&quot;/bin/bash&quot;</span>,</span><br><span class="line">                <span class="string">&quot;-c&quot;</span>,</span><br><span class="line">                <span class="string">&quot;while true;do echo NephrenCake;sleep 1;done&quot;</span></span><br><span class="line">            ],</span><br><span class="line">            <span class="string">&quot;Image&quot;</span>: <span class="string">&quot;centos&quot;</span>,</span><br><span class="line">            <span class="string">&quot;Volumes&quot;</span>: null,</span><br><span class="line">            <span class="string">&quot;WorkingDir&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">            <span class="string">&quot;Entrypoint&quot;</span>: null,</span><br><span class="line">            <span class="string">&quot;OnBuild&quot;</span>: null,</span><br><span class="line">            <span class="string">&quot;Labels&quot;</span>: &#123;</span><br><span class="line">                <span class="string">&quot;org.label-schema.build-date&quot;</span>: <span class="string">&quot;20201204&quot;</span>,</span><br><span class="line">                <span class="string">&quot;org.label-schema.license&quot;</span>: <span class="string">&quot;GPLv2&quot;</span>,</span><br><span class="line">                <span class="string">&quot;org.label-schema.name&quot;</span>: <span class="string">&quot;CentOS Base Image&quot;</span>,</span><br><span class="line">                <span class="string">&quot;org.label-schema.schema-version&quot;</span>: <span class="string">&quot;1.0&quot;</span>,</span><br><span class="line">                <span class="string">&quot;org.label-schema.vendor&quot;</span>: <span class="string">&quot;CentOS&quot;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">&quot;NetworkSettings&quot;</span>: &#123;</span><br><span class="line">            <span class="string">&quot;Bridge&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">            <span class="string">&quot;SandboxID&quot;</span>: <span class="string">&quot;a58ab6299e5a5cb4b40068484267752f8958795d9073e2bf70ad47478cfd76e3&quot;</span>,</span><br><span class="line">            <span class="string">&quot;HairpinMode&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">            <span class="string">&quot;LinkLocalIPv6Address&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">            <span class="string">&quot;LinkLocalIPv6PrefixLen&quot;</span>: 0,</span><br><span class="line">            <span class="string">&quot;Ports&quot;</span>: &#123;&#125;,</span><br><span class="line">            <span class="string">&quot;SandboxKey&quot;</span>: <span class="string">&quot;/var/run/docker/netns/a58ab6299e5a&quot;</span>,</span><br><span class="line">            <span class="string">&quot;SecondaryIPAddresses&quot;</span>: null,</span><br><span class="line">            <span class="string">&quot;SecondaryIPv6Addresses&quot;</span>: null,</span><br><span class="line">            <span class="string">&quot;EndpointID&quot;</span>: <span class="string">&quot;8b66ea3b5e36bc2599ef8f9f8423036daec31b9df332ba6a9a6924125c3770d9&quot;</span>,</span><br><span class="line">            <span class="string">&quot;Gateway&quot;</span>: <span class="string">&quot;172.18.0.1&quot;</span>,</span><br><span class="line">            <span class="string">&quot;GlobalIPv6Address&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">            <span class="string">&quot;GlobalIPv6PrefixLen&quot;</span>: 0,</span><br><span class="line">            <span class="string">&quot;IPAddress&quot;</span>: <span class="string">&quot;172.18.0.3&quot;</span>,</span><br><span class="line">            <span class="string">&quot;IPPrefixLen&quot;</span>: 16,</span><br><span class="line">            <span class="string">&quot;IPv6Gateway&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">            <span class="string">&quot;MacAddress&quot;</span>: <span class="string">&quot;02:42:ac:12:00:03&quot;</span>,</span><br><span class="line">            <span class="string">&quot;Networks&quot;</span>: &#123;  <span class="comment"># docker网络</span></span><br><span class="line">                <span class="string">&quot;bridge&quot;</span>: &#123;  <span class="comment"># 桥接网卡</span></span><br><span class="line">                    <span class="string">&quot;IPAMConfig&quot;</span>: null,</span><br><span class="line">                    <span class="string">&quot;Links&quot;</span>: null,</span><br><span class="line">                    <span class="string">&quot;Aliases&quot;</span>: null,</span><br><span class="line">                    <span class="string">&quot;NetworkID&quot;</span>: <span class="string">&quot;c49bd3c9074eccb131f580ae87a0f639459d8fbfb6106ff16d95de982f955cb6&quot;</span>,</span><br><span class="line">                    <span class="string">&quot;EndpointID&quot;</span>: <span class="string">&quot;8b66ea3b5e36bc2599ef8f9f8423036daec31b9df332ba6a9a6924125c3770d9&quot;</span>,</span><br><span class="line">                    <span class="string">&quot;Gateway&quot;</span>: <span class="string">&quot;172.18.0.1&quot;</span>,</span><br><span class="line">                    <span class="string">&quot;IPAddress&quot;</span>: <span class="string">&quot;172.18.0.3&quot;</span>,</span><br><span class="line">                    <span class="string">&quot;IPPrefixLen&quot;</span>: 16,</span><br><span class="line">                    <span class="string">&quot;IPv6Gateway&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">                    <span class="string">&quot;GlobalIPv6Address&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">                    <span class="string">&quot;GlobalIPv6PrefixLen&quot;</span>: 0,</span><br><span class="line">                    <span class="string">&quot;MacAddress&quot;</span>: <span class="string">&quot;02:42:ac:12:00:03&quot;</span>,</span><br><span class="line">                    <span class="string">&quot;DriverOpts&quot;</span>: null</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 镜像的元数据================================================================================================</span></span><br><span class="line">[root@VM-1-14-centos ~]<span class="comment"># docker image inspect centos</span></span><br><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">&quot;Id&quot;</span>: <span class="string">&quot;sha256:300e315adb2f96afe5f0b2780b87f28ae95231fe3bdd1e16b9ba606307728f55&quot;</span>,</span><br><span class="line">        <span class="string">&quot;RepoTags&quot;</span>: [</span><br><span class="line">            <span class="string">&quot;centos:latest&quot;</span></span><br><span class="line">        ],</span><br><span class="line">        <span class="string">&quot;RepoDigests&quot;</span>: [</span><br><span class="line">            <span class="string">&quot;centos@sha256:5528e8b1b1719d34604c87e11dcd1c0a20bedf46e83b5632cdeac91b8c04efc1&quot;</span></span><br><span class="line">        ],</span><br><span class="line">        <span class="string">&quot;Parent&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">        <span class="string">&quot;Comment&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">        <span class="string">&quot;Created&quot;</span>: <span class="string">&quot;2020-12-08T00:22:53.076477777Z&quot;</span>,</span><br><span class="line">        <span class="string">&quot;Container&quot;</span>: <span class="string">&quot;395e0bfa7301f73bc994efe15099ea56b8836c608dd32614ac5ae279976d33e4&quot;</span>,</span><br><span class="line">        <span class="string">&quot;ContainerConfig&quot;</span>: &#123;</span><br><span class="line">            <span class="string">&quot;Hostname&quot;</span>: <span class="string">&quot;395e0bfa7301&quot;</span>,</span><br><span class="line">            <span class="string">&quot;Domainname&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">            <span class="string">&quot;User&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">            <span class="string">&quot;AttachStdin&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">            <span class="string">&quot;AttachStdout&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">            <span class="string">&quot;AttachStderr&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">            <span class="string">&quot;Tty&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">            <span class="string">&quot;OpenStdin&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">            <span class="string">&quot;StdinOnce&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">            <span class="string">&quot;Env&quot;</span>: [</span><br><span class="line">                <span class="string">&quot;PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin&quot;</span></span><br><span class="line">            ],</span><br><span class="line">            <span class="string">&quot;Cmd&quot;</span>: [</span><br><span class="line">                <span class="string">&quot;/bin/sh&quot;</span>,</span><br><span class="line">                <span class="string">&quot;-c&quot;</span>,</span><br><span class="line">                <span class="string">&quot;#(nop) &quot;</span>,</span><br><span class="line">                <span class="string">&quot;CMD [\&quot;/bin/bash\&quot;]&quot;</span></span><br><span class="line">            ],</span><br><span class="line">            <span class="string">&quot;Image&quot;</span>: <span class="string">&quot;sha256:6de05bdfbf9a9d403458d10de9e088b6d93d971dd5d48d18b4b6758f4554f451&quot;</span>,</span><br><span class="line">            <span class="string">&quot;Volumes&quot;</span>: null,</span><br><span class="line">            <span class="string">&quot;WorkingDir&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">            <span class="string">&quot;Entrypoint&quot;</span>: null,</span><br><span class="line">            <span class="string">&quot;OnBuild&quot;</span>: null,</span><br><span class="line">            <span class="string">&quot;Labels&quot;</span>: &#123;</span><br><span class="line">                <span class="string">&quot;org.label-schema.build-date&quot;</span>: <span class="string">&quot;20201204&quot;</span>,</span><br><span class="line">                <span class="string">&quot;org.label-schema.license&quot;</span>: <span class="string">&quot;GPLv2&quot;</span>,</span><br><span class="line">                <span class="string">&quot;org.label-schema.name&quot;</span>: <span class="string">&quot;CentOS Base Image&quot;</span>,</span><br><span class="line">                <span class="string">&quot;org.label-schema.schema-version&quot;</span>: <span class="string">&quot;1.0&quot;</span>,</span><br><span class="line">                <span class="string">&quot;org.label-schema.vendor&quot;</span>: <span class="string">&quot;CentOS&quot;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">&quot;DockerVersion&quot;</span>: <span class="string">&quot;19.03.12&quot;</span>,</span><br><span class="line">        <span class="string">&quot;Author&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">        <span class="string">&quot;Config&quot;</span>: &#123;</span><br><span class="line">            <span class="string">&quot;Hostname&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">            <span class="string">&quot;Domainname&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">            <span class="string">&quot;User&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">            <span class="string">&quot;AttachStdin&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">            <span class="string">&quot;AttachStdout&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">            <span class="string">&quot;AttachStderr&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">            <span class="string">&quot;Tty&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">            <span class="string">&quot;OpenStdin&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">            <span class="string">&quot;StdinOnce&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">            <span class="string">&quot;Env&quot;</span>: [</span><br><span class="line">                <span class="string">&quot;PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin&quot;</span></span><br><span class="line">            ],</span><br><span class="line">            <span class="string">&quot;Cmd&quot;</span>: [</span><br><span class="line">                <span class="string">&quot;/bin/bash&quot;</span></span><br><span class="line">            ],</span><br><span class="line">            <span class="string">&quot;Image&quot;</span>: <span class="string">&quot;sha256:6de05bdfbf9a9d403458d10de9e088b6d93d971dd5d48d18b4b6758f4554f451&quot;</span>,</span><br><span class="line">            <span class="string">&quot;Volumes&quot;</span>: null,</span><br><span class="line">            <span class="string">&quot;WorkingDir&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">            <span class="string">&quot;Entrypoint&quot;</span>: null,</span><br><span class="line">            <span class="string">&quot;OnBuild&quot;</span>: null,</span><br><span class="line">            <span class="string">&quot;Labels&quot;</span>: &#123;</span><br><span class="line">                <span class="string">&quot;org.label-schema.build-date&quot;</span>: <span class="string">&quot;20201204&quot;</span>,</span><br><span class="line">                <span class="string">&quot;org.label-schema.license&quot;</span>: <span class="string">&quot;GPLv2&quot;</span>,</span><br><span class="line">                <span class="string">&quot;org.label-schema.name&quot;</span>: <span class="string">&quot;CentOS Base Image&quot;</span>,</span><br><span class="line">                <span class="string">&quot;org.label-schema.schema-version&quot;</span>: <span class="string">&quot;1.0&quot;</span>,</span><br><span class="line">                <span class="string">&quot;org.label-schema.vendor&quot;</span>: <span class="string">&quot;CentOS&quot;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">&quot;Architecture&quot;</span>: <span class="string">&quot;amd64&quot;</span>,</span><br><span class="line">        <span class="string">&quot;Os&quot;</span>: <span class="string">&quot;linux&quot;</span>,</span><br><span class="line">        <span class="string">&quot;Size&quot;</span>: 209348104,</span><br><span class="line">        <span class="string">&quot;VirtualSize&quot;</span>: 209348104,</span><br><span class="line">        <span class="string">&quot;GraphDriver&quot;</span>: &#123;</span><br><span class="line">            <span class="string">&quot;Data&quot;</span>: &#123;</span><br><span class="line">                <span class="string">&quot;MergedDir&quot;</span>: <span class="string">&quot;/var/lib/docker/overlay2/e7f999e147eaa9cc6658059fe0a66e6f6bca79957c99cf69bfe563b82bcbd2be/merged&quot;</span>,</span><br><span class="line">                <span class="string">&quot;UpperDir&quot;</span>: <span class="string">&quot;/var/lib/docker/overlay2/e7f999e147eaa9cc6658059fe0a66e6f6bca79957c99cf69bfe563b82bcbd2be/diff&quot;</span>,</span><br><span class="line">                <span class="string">&quot;WorkDir&quot;</span>: <span class="string">&quot;/var/lib/docker/overlay2/e7f999e147eaa9cc6658059fe0a66e6f6bca79957c99cf69bfe563b82bcbd2be/work&quot;</span></span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="string">&quot;Name&quot;</span>: <span class="string">&quot;overlay2&quot;</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">&quot;RootFS&quot;</span>: &#123;</span><br><span class="line">            <span class="string">&quot;Type&quot;</span>: <span class="string">&quot;layers&quot;</span>,</span><br><span class="line">            <span class="string">&quot;Layers&quot;</span>: [  <span class="comment"># 分层</span></span><br><span class="line">                <span class="string">&quot;sha256:2653d992f4ef2bfd27f94db643815aa567240c37732cae1405ad1c1309ee9859&quot;</span></span><br><span class="line">            ]</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">&quot;Metadata&quot;</span>: &#123;</span><br><span class="line">            <span class="string">&quot;LastTagTime&quot;</span>: <span class="string">&quot;0001-01-01T00:00:00Z&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="进入正在运行的容器"><a href="#进入正在运行的容器" class="headerlink" title="进入正在运行的容器"></a>进入正在运行的容器</h3><ul><li>方法1：execute</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="built_in">exec</span> -it 容器id /bin/bash  <span class="comment"># 根据id重新进入容器交互，交互的command为/bin/bash</span></span><br><span class="line"></span><br><span class="line">[root@VM-1-14-centos ~]<span class="comment"># docker exec -it 813d27116121 /bin/bash</span></span><br><span class="line">[root@813d27116121 /]<span class="comment">#</span></span><br></pre></td></tr></table></figure><ul><li>方法2：attach</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">docker attach 容器id  <span class="comment"># 根据id重新进入容器交互，交互的command为之前设置的内容</span></span><br><span class="line"></span><br><span class="line">[root@VM-1-14-centos ~]<span class="comment"># docker attach 813d27116121</span></span><br><span class="line">NephrenCake</span><br><span class="line">......</span><br></pre></td></tr></table></figure><h3 id="在容器和宿主机之间拷贝文件"><a href="#在容器和宿主机之间拷贝文件" class="headerlink" title="在容器和宿主机之间拷贝文件"></a>在容器和宿主机之间拷贝文件</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker cp 容器id:容器内路径 目的主机的路径</span><br><span class="line">docker cp 要拷贝的文件路径 容器名：要拷贝到容器里面对应的路径</span><br><span class="line"></span><br><span class="line">[root@VM-1-14-centos ~]<span class="comment"># docker cp 813d27116121:/home/test.java /home</span></span><br></pre></td></tr></table></figure><blockquote><p>这里拷贝是一个手动的过程，后面使用卷技术可以实现自动同步。</p></blockquote><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker commit -a <span class="string">&quot;liuyifei&quot;</span> fd9913dfe5ba  sealocr:v1 </span><br><span class="line">docker save -o my_ubuntu_v3.tar runoob/ubuntu:v3</span><br><span class="line">docker <span class="built_in">export</span> -o seal-ocr.tar fd9913dfe5ba</span><br></pre></td></tr></table></figure><p><img src="/2021/04/Docker%E5%9F%BA%E7%A1%80Part2/image-20210423164827183.png" alt="image-20210423164827183"></p><p><a href="https://www.bilibili.com/video/BV1og4y1q7M4?p=14">部署Nginx、Tomcat、ES+Kibana</a></p><h2 id="可视化"><a href="#可视化" class="headerlink" title="可视化"></a>可视化</h2><ul><li>portainer</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -p 8080:9000 \</span><br><span class="line">--restart=always -v /var/run/docker.sock:/var/run/docker.sock --privileged=<span class="literal">true</span> portainer/portainer</span><br><span class="line"></span><br><span class="line"><span class="comment"># 内网9000，外网8080</span></span><br><span class="line"><span class="comment"># --restart=always 启动方式</span></span><br><span class="line"><span class="comment"># -v 将数据挂载到本机</span></span><br><span class="line"><span class="comment"># --privileged=true 授权</span></span><br><span class="line"><span class="comment"># portainer/portainer 安装控制面板</span></span><br></pre></td></tr></table></figure><ul><li>Rancher</li></ul><p>在 持续集成/持续部署(CI/CD) 时使用。</p>]]></content>
      
      
      <categories>
          
          <category> Docker基础 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Docker基础Part1</title>
      <link href="/2021/04/Docker%E5%9F%BA%E7%A1%80Part1/"/>
      <url>/2021/04/Docker%E5%9F%BA%E7%A1%80Part1/</url>
      
        <content type="html"><![CDATA[<h1 id="Docker基础Part1——概述"><a href="#Docker基础Part1——概述" class="headerlink" title="Docker基础Part1——概述"></a>Docker基础Part1——概述</h1><p>[TOC]</p><h2 id="Docker简介"><a href="#Docker简介" class="headerlink" title="Docker简介"></a>Docker简介</h2><p>Docker 是一个开源的应用容器引擎，基于Go 语言。</p><p>Docker 可以让开发者打包他们的应用以及依赖包到一个轻量级、可移植的容器中，将应用程序与基础架构分开，然后发布到任何流行的 Linux 机器上，也可以实现虚拟化。</p><p>容器是完全使用沙箱机制，相互之间不会有任何接口，更重要的是容器性能开销极低。</p><h2 id="Docker的应用场景"><a href="#Docker的应用场景" class="headerlink" title="Docker的应用场景"></a>Docker的应用场景</h2><ul><li>Web 应用的自动化打包和发布。</li><li>自动化测试和持续集成、发布。</li><li>在服务型环境中部署和调整数据库或其他的后台应用。</li><li>从头编译或者扩展现有的 OpenShift 或 Cloud Foundry 平台来搭建自己的 PaaS 环境。</li></ul><h2 id="Docker-的优点"><a href="#Docker-的优点" class="headerlink" title="Docker 的优点"></a>Docker 的优点</h2><h3 id="快速，一致地交付应用程序"><a href="#快速，一致地交付应用程序" class="headerlink" title="快速，一致地交付应用程序"></a>快速，一致地交付应用程序</h3><p>Docker 允许开发人员使用您提供的应用程序或服务的本地容器在标准化环境中工作，能够快速交付软件，测试和部署代码，从而简化了开发的生命周期。</p><p>容器非常适合持续集成和持续交付（CI / CD）工作流程，请考虑以下示例方案：</p><ul><li>您的开发人员在本地编写代码，并使用 Docker 容器与同事共享他们的工作。</li><li>他们使用 Docker 将其应用程序推送到测试环境中，并执行自动或手动测试。</li><li>当开发人员发现错误时，他们可以在开发环境中对其进行修复，然后将其重新部署到测试环境中，以进行测试和验证。</li><li>测试完成后，将修补程序推送给生产环境，就像将更新的镜像推送到生产环境一样简单。</li></ul><h3 id="响应式部署和扩展"><a href="#响应式部署和扩展" class="headerlink" title="响应式部署和扩展"></a>响应式部署和扩展</h3><p>Docker 是基于容器的平台，允许高度可移植的工作负载。Docker 容器可以在开发人员的本机上，数据中心的物理或虚拟机上，云服务上或混合环境中运行。</p><p>Docker 的可移植性和轻量级的特性，还可以使您轻松地完成动态管理的工作负担，并根据业务需求指示，实时扩展或拆除应用程序和服务。</p><h3 id="在同一硬件上运行更多工作负载"><a href="#在同一硬件上运行更多工作负载" class="headerlink" title="在同一硬件上运行更多工作负载"></a>在同一硬件上运行更多工作负载</h3><p>Docker 轻巧快速。它为基于虚拟机管理程序的虚拟机提供了可行、经济、高效的替代方案，因此您可以利用更多的计算能力来实现业务目标。Docker 非常适合于高密度环境以及中小型部署，而您可以用更少的资源做更多的事情。</p><h2 id="Docker架构"><a href="#Docker架构" class="headerlink" title="Docker架构"></a>Docker架构</h2><ul><li><strong>镜像（Image）</strong>：Docker 镜像，就相当于是面向对象中静态定义的类class。</li><li><strong>容器（Container）</strong>：Docker 容器（Container），就相当于是面向对象中class的实例对象，是镜像运行时的实体，可以同时运行一个或多个。容器可以被创建、启动、停止、删除、暂停等。</li><li><strong>仓库（Repository）</strong>：仓库可看成一个代码控制中心，用来保存镜像（官方默认是DockerHub）。一个 Docker Registry 中可以包含多个仓库（Repository）；每个仓库可以包含多个标签（Tag）；每个标签对应一个镜像。通常，一个仓库会包含同一个软件不同版本的镜像，而标签就常用于对应该软件的各个版本。我们可以通过 <code>&lt;仓库名&gt;:&lt;标签&gt;</code> 的格式来指定具体是这个软件哪个版本的镜像。如果不给出标签，将以 <code>latest</code> 作为默认标签。</li><li>**客户端 (Client) **：Docker 客户端通过命令行或者其他工具使用 Docker SDK 与 Docker 的守护进程通信。</li><li>**Docker 主机 (Host) **：一个物理或者虚拟的机器用于执行 Docker 守护进程和容器。</li><li>**Docker Machine **：Docker Machine是一个简化Docker安装的命令行工具，通过一个简单的命令行即可在相应的平台上安装Docker，比如VirtualBox、 Digital Ocean、Microsoft Azure。</li></ul><p><img src="/2021/04/Docker%E5%9F%BA%E7%A1%80Part1/image-20210420204117374.png" alt="image-20210420204117374"></p><h2 id="Docker安装"><a href="#Docker安装" class="headerlink" title="Docker安装"></a>Docker安装</h2><h3 id="环境查看"><a href="#环境查看" class="headerlink" title="环境查看"></a>环境查看</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-1-14-centos /]<span class="comment"># uname -r</span></span><br><span class="line">3.10.0-1127.19.1.el7.x86_64</span><br><span class="line">[root@VM-1-14-centos /]<span class="comment"># cat /etc/os-release </span></span><br><span class="line">NAME=<span class="string">&quot;CentOS Linux&quot;</span></span><br><span class="line">VERSION=<span class="string">&quot;7 (Core)&quot;</span></span><br><span class="line">ID=<span class="string">&quot;centos&quot;</span></span><br><span class="line">ID_LIKE=<span class="string">&quot;rhel fedora&quot;</span></span><br><span class="line">VERSION_ID=<span class="string">&quot;7&quot;</span></span><br><span class="line">PRETTY_NAME=<span class="string">&quot;CentOS Linux 7 (Core)&quot;</span></span><br><span class="line">ANSI_COLOR=<span class="string">&quot;0;31&quot;</span></span><br><span class="line">CPE_NAME=<span class="string">&quot;cpe:/o:centos:centos:7&quot;</span></span><br><span class="line">HOME_URL=<span class="string">&quot;https://www.centos.org/&quot;</span></span><br><span class="line">BUG_REPORT_URL=<span class="string">&quot;https://bugs.centos.org/&quot;</span></span><br><span class="line"></span><br><span class="line">CENTOS_MANTISBT_PROJECT=<span class="string">&quot;CentOS-7&quot;</span></span><br><span class="line">CENTOS_MANTISBT_PROJECT_VERSION=<span class="string">&quot;7&quot;</span></span><br><span class="line">REDHAT_SUPPORT_PRODUCT=<span class="string">&quot;centos&quot;</span></span><br><span class="line">REDHAT_SUPPORT_PRODUCT_VERSION=<span class="string">&quot;7&quot;</span></span><br></pre></td></tr></table></figure><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><blockquote><p>建议阅读官方文档 <a href="https://docs.docker.com/">https://docs.docker.com/</a></p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1.卸载旧版本</span></span><br><span class="line">sudo yum remove docker \</span><br><span class="line">                  docker-client \</span><br><span class="line">                  docker-client-latest \</span><br><span class="line">                  docker-common \</span><br><span class="line">                  docker-latest \</span><br><span class="line">                  docker-latest-logrotate \</span><br><span class="line">                  docker-logrotate \</span><br><span class="line">                  docker-engine</span><br><span class="line">                  </span><br><span class="line"><span class="comment"># 2.依赖包</span></span><br><span class="line">sudo yum install -y yum-utils device-mapper-persistent-data lvm2</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3.设置yum源为阿里云</span></span><br><span class="line">sudo yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo</span><br><span class="line"></span><br><span class="line"><span class="comment"># 4.更新软件索引</span></span><br><span class="line">yum makecache fast</span><br><span class="line"></span><br><span class="line"><span class="comment"># 5.安装docker</span></span><br><span class="line">sudo yum install docker-ce</span><br><span class="line"></span><br><span class="line"><span class="comment"># 6.测试安装成功</span></span><br><span class="line">docker version</span><br><span class="line"></span><br><span class="line"><span class="comment"># 7.启动docker</span></span><br><span class="line">sudo systemctl start docker</span><br><span class="line"></span><br><span class="line"><span class="comment"># 8.启动镜像</span></span><br><span class="line">sudo docker run hello-world</span><br><span class="line"></span><br><span class="line"><span class="comment"># 9.查看镜像</span></span><br><span class="line">docker images</span><br></pre></td></tr></table></figure><h2 id="配置阿里云镜像"><a href="#配置阿里云镜像" class="headerlink" title="配置阿里云镜像"></a>配置阿里云镜像</h2><h3 id="登录阿里云"><a href="#登录阿里云" class="headerlink" title="登录阿里云"></a>登录阿里云</h3><p>阿里云 -&gt; 注册/登录 -&gt; 控制台 -&gt; 左上角:产品与服务 -&gt; 容器镜像服务 -&gt; 镜像中心:镜像加速器</p><h3 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1.第一次安装好docker的话，/etc目录下是没有docker目录的， 所以先创建docker目录：</span></span><br><span class="line">sudo mkdir -p /etc/docker</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2.创建并编写配置文件</span></span><br><span class="line">sudo tee /etc/docker/daemon.json &lt;&lt;-<span class="string">&#x27;EOF&#x27;</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;registry-mirrors&quot;</span>: [<span class="string">&quot;https://0uvt67mi.mirror.aliyuncs.com&quot;</span>]</span><br><span class="line">&#125;</span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3.重启docker</span></span><br><span class="line">sudo systemctl daemon-reload</span><br><span class="line">sudo systemctl restart docker</span><br><span class="line"></span><br><span class="line"><span class="comment"># 4.测试</span></span><br><span class="line">docker run hello-world</span><br></pre></td></tr></table></figure><h2 id="hello-world-简单原理"><a href="#hello-world-简单原理" class="headerlink" title="hello world 简单原理"></a>hello world 简单原理</h2><h3 id="运行镜像"><a href="#运行镜像" class="headerlink" title="运行镜像"></a>运行镜像</h3><p><img src="/2021/04/Docker%E5%9F%BA%E7%A1%80Part1/image-20210420215218606.png" alt="image-20210420215218606"></p><h3 id="更少的虚拟层"><a href="#更少的虚拟层" class="headerlink" title="更少的虚拟层"></a>更少的虚拟层</h3><p><img src="/2021/04/Docker%E5%9F%BA%E7%A1%80Part1/image-20210420222126606.png" alt="image-20210420222126606"></p><h3 id="不同虚拟化的区别"><a href="#不同虚拟化的区别" class="headerlink" title="不同虚拟化的区别"></a>不同虚拟化的区别</h3><p><img src="/2021/04/Docker%E5%9F%BA%E7%A1%80Part1/image-20210420222213286.png" alt="image-20210420222213286"></p>]]></content>
      
      
      <categories>
          
          <category> Docker基础 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Git基础-完结目录</title>
      <link href="/2021/03/Git%E5%9F%BA%E7%A1%80-%E5%AE%8C%E7%BB%93%E7%9B%AE%E5%BD%95/"/>
      <url>/2021/03/Git%E5%9F%BA%E7%A1%80-%E5%AE%8C%E7%BB%93%E7%9B%AE%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<h1 id="Git基础——完结目录"><a href="#Git基础——完结目录" class="headerlink" title="Git基础——完结目录"></a>Git基础——完结目录</h1><p>教程视频传送门：</p><ol><li><a href="https://www.bilibili.com/video/BV1FE411P7B3?from=search&seid=14741939341268860783">【狂神说Java】Git最新教程通俗易懂</a></li><li><a href="https://www.bilibili.com/video/BV1pW411A7a5?p=15">尚硅谷GitHub基础全套完整版教程</a></li></ol><p>和Linux的一样，狂神的很精简，尚硅谷的更全。</p><p>==回退版本、合并分支、解决冲突的测试==</p><table><thead><tr><th align="center"><a href="/2021/03/Git%E5%9F%BA%E7%A1%80Part1/">Part1——概述</a></th></tr></thead><tbody><tr><td align="center"><strong><a href="/2021/03/Git%E5%9F%BA%E7%A1%80Part2/">Part2——操作使用</a></strong></td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> Git基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git基础Part2</title>
      <link href="/2021/03/Git%E5%9F%BA%E7%A1%80Part2/"/>
      <url>/2021/03/Git%E5%9F%BA%E7%A1%80Part2/</url>
      
        <content type="html"><![CDATA[<h1 id="Git基础Part2——操作使用"><a href="#Git基础Part2——操作使用" class="headerlink" title="Git基础Part2——操作使用"></a>Git基础Part2——操作使用</h1><p>[TOC]</p><h2 id="打开命令行"><a href="#打开命令行" class="headerlink" title="打开命令行"></a>打开命令行</h2><p>在win上可以到指定位置使用Git Bash（在指定目录下-&gt;右键-&gt;Git Bash Here），个人认为比较方便。</p><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><h3 id="查看配置"><a href="#查看配置" class="headerlink" title="查看配置"></a>查看配置</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git config -l</span><br><span class="line">git config --system --list  <span class="comment">#查看系统config</span></span><br><span class="line">git config --global  --list  <span class="comment">#查看当前用户（global）配置</span></span><br></pre></td></tr></table></figure><ol><li>Git\etc\gitconfig  ：Git 安装目录下的 gitconfig   –system 系统级</li><li>C:\Users\Administrator\ .gitconfig   只适用于当前登录用户的配置  –global 全局</li></ol><h3 id="编辑配置"><a href="#编辑配置" class="headerlink" title="编辑配置"></a>编辑配置</h3><p>每次Git提交都会使用该信息。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config [ --global ] user.name <span class="string">&quot;你的用户名&quot;</span>  <span class="comment"># 设置用户名</span></span><br><span class="line">git config [ --global ] user.email <span class="string">&quot;你的邮箱&quot;</span>  <span class="comment"># 设置注册github的邮箱</span></span><br></pre></td></tr></table></figure><p>使用<code>--global</code>则为全局系统级别的设置，否则为仓库级别的设置。</p><h2 id="仓库与文件"><a href="#仓库与文件" class="headerlink" title="仓库与文件"></a>仓库与文件</h2><h3 id="本地仓库搭建"><a href="#本地仓库搭建" class="headerlink" title="本地仓库搭建"></a>本地仓库搭建</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git init  <span class="comment"># 在当前目录新建一个Git代码库</span></span><br></pre></td></tr></table></figure><p>此命令之后目录下生成.git隐藏文件。</p><h3 id="首次配置url"><a href="#首次配置url" class="headerlink" title="首次配置url"></a>首次配置url</h3><p>建议直接 clone 远端创建好的项目，在其基础上进行开发。</p><h3 id="克隆远程仓库"><a href="#克隆远程仓库" class="headerlink" title="克隆远程仓库"></a>克隆远程仓库</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> [ url ]  <span class="comment"># 克隆一个项目和它的整个代码历史(版本信息)</span></span><br></pre></td></tr></table></figure><h3 id="文件的四种状态"><a href="#文件的四种状态" class="headerlink" title="文件的四种状态"></a>文件的四种状态</h3><ul><li>Untracked: 未跟踪, 此文件在文件夹中, 但并没有加入到git库, 不参与版本控制. 通过git add 状态变为Staged.</li><li>Unmodify: 文件已经入库, 未修改, 即版本库中的文件快照内容与文件夹中完全一致. 这种类型的文件有两种去处, 如果它被修改, 而变为Modified. 如果使用git rm移出版本库, 则成为Untracked文件</li><li>Modified: 文件已修改, 仅仅是修改, 并没有进行其他的操作. 这个文件也有两个去处, 通过git add可进入暂存staged状态, 使用git checkout 则丢弃修改过, 返回到unmodify状态, 这个git checkout即从库中取出文件, 覆盖当前修改 !</li><li>Staged: 暂存状态. 执行git commit则将修改同步到库中, 这时库中的文件和本地文件又变为一致, 文件为Unmodify状态. 执行git reset HEAD filename取消暂存, 文件状态为Modified</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git status [filename]  <span class="comment">#查看指定文件状态</span></span><br><span class="line">git status  <span class="comment">#查看所有文件状态</span></span><br></pre></td></tr></table></figure><p>一般在IDE中查看即可。</p><h3 id="添加文件"><a href="#添加文件" class="headerlink" title="添加文件"></a>添加文件</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git add fileName  <span class="comment">#指定文件</span></span><br><span class="line">git add . <span class="comment">#所有</span></span><br></pre></td></tr></table></figure><p>将工作区的文件添加到暂存区</p><h3 id="提交文件"><a href="#提交文件" class="headerlink" title="提交文件"></a>提交文件</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit -m <span class="string">&#x27;commit message&#x27;</span> [ fileName ]</span><br></pre></td></tr></table></figure><p>将暂存区内容提交到本地库</p><h3 id="删除文件"><a href="#删除文件" class="headerlink" title="删除文件"></a>删除文件</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git rm 文件名  <span class="comment"># 删除缓存区的该文件</span></span><br><span class="line">git commit -m<span class="string">&quot;注释&quot;</span>  <span class="comment"># 将仓库文件删除</span></span><br></pre></td></tr></table></figure><h3 id="查看历史记录"><a href="#查看历史记录" class="headerlink" title="查看历史记录"></a>查看历史记录</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">log</span> </span><br><span class="line">git reflog  <span class="comment"># 常用</span></span><br><span class="line">git <span class="built_in">log</span> --greph <span class="comment"># 图形显示,更直观</span></span><br><span class="line">git <span class="built_in">log</span> --pretty=oneline <span class="comment"># 漂亮一行显示(建议)</span></span><br><span class="line">git <span class="built_in">log</span> --oneline <span class="comment"># 简洁显示</span></span><br></pre></td></tr></table></figure><p>HEAD@{移动到当前版本需要多少步}</p><h3 id="前进后退"><a href="#前进后退" class="headerlink" title="前进后退"></a>前进后退</h3><p>基于索引值（推荐）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git reset --hard [ commit id ]</span><br><span class="line">git reset --hard a6ace91 <span class="comment">#回到这个状态</span></span><br></pre></td></tr></table></figure><p>使用 <strong>^</strong> 符号（只能后退）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset --hard HEAD^  <span class="comment"># 几个 ^ 表示后退几步</span></span><br></pre></td></tr></table></figure><p>使用 <strong>~</strong> 符号（只能后退）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset --hard HEAD~n  <span class="comment"># 后退几步</span></span><br></pre></td></tr></table></figure><p>soft: </p><ul><li>仅本地库移动HEAD 指针 </li></ul><p>mixed:</p><ul><li>在本地库移动HEAD指针</li><li>重置暂存区</li></ul><p>hard:</p><ul><li>在本地库移动HEAD指针</li><li>重置暂存区</li><li>重置工作区</li></ul><h3 id="文件差异比较"><a href="#文件差异比较" class="headerlink" title="文件差异比较"></a>文件差异比较</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git diff 文件名</span><br><span class="line">git diff 哈希值 文件名  <span class="comment"># 和历史中的一个版本比较</span></span><br><span class="line">git diff  <span class="comment"># 不带文件名，则比较多个文件</span></span><br></pre></td></tr></table></figure><h3 id="忽略文件"><a href="#忽略文件" class="headerlink" title="忽略文件"></a>忽略文件</h3><p>不想把某些文件纳入版本控制中时，可以在主目录下建立”.gitignore”文件。</p><ol><li>忽略文件中的空行或以井号（#）开始的行将会被忽略。</li><li>可以使用Linux通配符。例如：星号（*）代表任意多个字符，问号（？）代表一个字符，方括号（[abc]）代表可选字符范围，大括号（{string1,string2,…}）代表可选的字符串等。</li><li>如果名称的最前面有一个感叹号（!），表示例外规则，将不被忽略。</li><li>如果名称的最前面是一个路径分隔符（/），表示要忽略的文件在此目录下，而子目录中的文件不忽略。</li><li>如果名称的最后面是一个路径分隔符（/），表示要忽略的是此目录下该名称的子目录，而非文件（默认文件或目录都忽略）。</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">*.txt        <span class="comment">#忽略所有 .txt结尾的文件,这样的话上传就不会被选中！</span></span><br><span class="line">!lib.txt     <span class="comment">#但lib.txt除外</span></span><br><span class="line">/temp        <span class="comment">#仅忽略项目根目录下的TODO文件,不包括其它目录temp</span></span><br><span class="line">build/       <span class="comment">#忽略build/目录下的所有文件</span></span><br><span class="line">doc/*.txt    <span class="comment">#会忽略 doc/notes.txt 但不包括 doc/server/arch.txt</span></span><br></pre></td></tr></table></figure><p>一般可以使用JetBrain中的插件.ignore来生成。</p><h2 id="分支管理"><a href="#分支管理" class="headerlink" title="分支管理"></a>分支管理</h2><h3 id="分支的好处"><a href="#分支的好处" class="headerlink" title="分支的好处"></a>分支的好处</h3><ul><li>同时并行推进多个功能开发，提高开发效率</li><li>某一分支开发失败，不会对其它分支有任何影响</li></ul><p>master主分支应该非常稳定，用来发布新版本，一般情况下不允许在上面工作，工作一般情况下在新建的dev分支上工作，工作完后，比如上要发布，或者说dev分支代码稳定后可以合并到主分支master上来。</p><h3 id="分支操作"><a href="#分支操作" class="headerlink" title="分支操作"></a>分支操作</h3><ul><li>创建分支</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch [branch]  <span class="comment"># 新建一个分支，但依然停留在当前分支</span></span><br></pre></td></tr></table></figure><ul><li>查看分支</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git branch  <span class="comment"># 列出所有本地分支</span></span><br><span class="line">git branch -v </span><br><span class="line">git branch -r  <span class="comment"># 列出所有远程分支</span></span><br></pre></td></tr></table></figure><ul><li>切换分支</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git checkout [branch]  <span class="comment"># 切换分支</span></span><br><span class="line">git checkout -b [branch]  <span class="comment"># 新建一个分支，并切换到该分支</span></span><br></pre></td></tr></table></figure><ul><li>合并分支<code>相当于把修改了的文件拉过来</code></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git merge [branch]  <span class="comment"># 合并指定分支到当前分支</span></span><br></pre></td></tr></table></figure><p>注意：在a分支里面修改后，要合并到master，就先切换到master，然后合并a。</p><ul><li>删除分支</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git branch -d [branch]  <span class="comment"># 删除分支，注意在删除分支时要退出该分支</span></span><br><span class="line"></span><br><span class="line">git push origin --delete [branch]</span><br><span class="line">git branch -dr [remote/branch]  <span class="comment"># 删除远程分支</span></span><br></pre></td></tr></table></figure><h3 id="解决冲突"><a href="#解决冲突" class="headerlink" title="解决冲突"></a>解决冲突</h3><ul><li>第一步：编辑，删除特殊标记<code>&lt;&lt;&lt;</code> <code>===</code></li><li>第二步：修改到满意为止，保存退出</li><li>第三步：添加到缓存区 <code>git add 文件名</code></li><li>第四步：提交到本地库 <code>git commit -m &#39;日志信息&#39;</code>  <code>注意：后面一定不能带文件名</code></li></ul><h2 id="Git-结合Github"><a href="#Git-结合Github" class="headerlink" title="Git 结合Github"></a>Git 结合Github</h2><h3 id="创建远程库地址别名"><a href="#创建远程库地址别名" class="headerlink" title="创建远程库地址别名"></a>创建远程库地址别名</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git remote -v  <span class="comment">#查看远程地址别名</span></span><br><span class="line">git remote add 别名 远程地址 </span><br><span class="line">demo：git remote add origin https://xx</span><br></pre></td></tr></table></figure><h3 id="推送"><a href="#推送" class="headerlink" title="推送"></a>推送</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git push 别名 分支名</span><br><span class="line">git push -u 别名 分支名    <span class="comment">#-u指定默认主机</span></span><br><span class="line">例子：git push origin master</span><br></pre></td></tr></table></figure><h3 id="克隆"><a href="#克隆" class="headerlink" title="克隆"></a>克隆</h3><p>完整的把远程库克隆到本地，克隆下来后不要在主分支里面做开发。clone进行一次，从无到有的过程，更新用pull。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span>  远程地址</span><br><span class="line">例子：git <span class="built_in">clone</span> https://xx</span><br></pre></td></tr></table></figure><h3 id="拉取"><a href="#拉取" class="headerlink" title="拉取"></a>拉取</h3><p>本地存在clone下来的文件 就用pull更新</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">pull = fetch + merge</span><br><span class="line">    git fetch 别名 分支名</span><br><span class="line">    git merge 别名 分支名</span><br><span class="line">git pull 别名 分支名</span><br></pre></td></tr></table></figure><h3 id="解决冲突-1"><a href="#解决冲突-1" class="headerlink" title="解决冲突"></a>解决冲突</h3><p>注意：解决冲突后的提交是不能带文件名的</p><p>如果不是基于远程库最新版做的修改不能推送，必须先pull下来安装冲突办法解决</p><h3 id="rebase"><a href="#rebase" class="headerlink" title="rebase"></a>rebase</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git rebase -i 索引号</span><br><span class="line">git rebase -i HEAD~3  <span class="comment">#合并最近三条记录</span></span><br><span class="line">说明：在vim编辑里面改成s</span><br></pre></td></tr></table></figure><h3 id="beyond-compare"><a href="#beyond-compare" class="headerlink" title="beyond compare"></a>beyond compare</h3><p>用软件解决冲突</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1.安装 ：</span><br><span class="line">    beyond compare </span><br><span class="line">2.配置：</span><br><span class="line">    git config --<span class="built_in">local</span> merge.tool bc3  <span class="comment">#合并名称</span></span><br><span class="line">    git config --<span class="built_in">local</span> mergetool.path <span class="string">&#x27;/usr/local/bin/bcomp&#x27;</span> <span class="comment">#软件路径</span></span><br><span class="line">    git config --<span class="built_in">local</span> mergetool.keepBackup <span class="literal">false</span>  <span class="comment">#False不用保存备份</span></span><br><span class="line">3.应用：</span><br><span class="line">    git mergetool</span><br><span class="line">说明：--<span class="built_in">local</span>指只在当前操作系统有效</span><br></pre></td></tr></table></figure><h3 id="跨团队合作"><a href="#跨团队合作" class="headerlink" title="跨团队合作"></a>跨团队合作</h3><p>代码review之后合并</p><ul><li><p><strong>适用于个人</strong></p><p><strong>邀请成员</strong>:<code>Settings</code> –&gt; <code>Collaborators</code> –&gt;<code>填写用户名</code> –&gt;<code>打开链接接受邀请</code></p></li><li><p><strong>企业</strong> <code>创建一个组织</code> <code>方便管理</code></p></li><li><p><strong>review</strong></p><p><code>组织做review</code> <code>通过Pull request</code></p></li><li><p><strong>给开源社区共享代码</strong></p><p><code>点击别人仓库的fork 到自己的仓库</code> – &gt; <code>然后clone下来 修改后推送到远程库</code> –&gt; <code>点击Pull Request请求</code> –&gt; <code>Create pull request发消息</code></p></li></ul><h3 id="Tag标签"><a href="#Tag标签" class="headerlink" title="Tag标签"></a>Tag标签</h3><p>为了清晰的版本管理，公司一般不会直接使用commit提交</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">git tag -a v1.0 -m <span class="string">&#x27;版本介绍&#x27;</span>   <span class="comment">#创建本地tag信息</span></span><br><span class="line">git tag -d v1.0         <span class="comment">#删除tag</span></span><br><span class="line">git push origin --tags   <span class="comment">#将本地tag信息推送到远程库</span></span><br><span class="line">git pull origin --tags    <span class="comment">#拉取到本地</span></span><br><span class="line"></span><br><span class="line">git checkout v.10    <span class="comment">#切换tag</span></span><br><span class="line">git <span class="built_in">clone</span> -b v0.1 地址   <span class="comment">#指定tag下载代码</span></span><br></pre></td></tr></table></figure><h3 id="SSH-免密登录"><a href="#SSH-免密登录" class="headerlink" title="SSH 免密登录"></a>SSH 免密登录</h3><ul><li>输入<code>ssh-keygen -t rsa -C GitHub邮箱地址</code></li><li>进入<code>.ssh</code>目录，复制<code>id_rsa.pub</code>文件内容</li><li>登录GitHub。<code>Settings</code>  –&gt; <code>SSH and GPG keys</code> –&gt; <code>New SSH Key</code></li><li>回到git通过ssh地址创建。<code>git remote add 别名 SSH地址</code></li></ul>]]></content>
      
      
      <categories>
          
          <category> Git基础 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Git基础Part1</title>
      <link href="/2021/03/Git%E5%9F%BA%E7%A1%80Part1/"/>
      <url>/2021/03/Git%E5%9F%BA%E7%A1%80Part1/</url>
      
        <content type="html"><![CDATA[<h1 id="Git基础Part1——概述"><a href="#Git基础Part1——概述" class="headerlink" title="Git基础Part1——概述"></a>Git基础Part1——概述</h1><p>[TOC]</p><h2 id="版本控制"><a href="#版本控制" class="headerlink" title="版本控制"></a>版本控制</h2><p>版本控制（Revision control）是一种在开发的过程中用于管理我们对文件、目录或工程等内容的修改历史，方便查看更改历史记录，备份以便恢复以前的版本的软件工程技术。</p><ul><li>实现跨区域多人协同开发</li><li>追踪和记载一个或者多个文件的历史记录</li><li>组织和保护你的源代码和文档</li><li>统计工作量</li><li>并行开发、提高开发效率</li><li>跟踪记录整个软件的开发过程</li><li>减轻开发人员的负担，节省时间，同时降低人为错误</li></ul><p>没有进行版本控制或者版本控制本身缺乏正确的流程管理，在软件开发过程中将会引入很多问题，如软件代码的一致性、软件内容的冗余、软件过程的事物性、软件开发过程中的并发性、软件源代码的安全性，以及软件的整合等问题。</p><h2 id="常见的版本控制工具"><a href="#常见的版本控制工具" class="headerlink" title="常见的版本控制工具"></a>常见的版本控制工具</h2><ul><li><strong>Git</strong></li><li><strong>SVN</strong>（Subversion）</li><li><strong>CVS</strong>（Concurrent Versions System）</li><li><strong>VSS</strong>（Micorosoft Visual SourceSafe）</li><li><strong>TFS</strong>（Team Foundation Server）</li></ul><p>现在影响力最大且使用最广泛的是Git与SVN。</p><h2 id="版本控制分类"><a href="#版本控制分类" class="headerlink" title="版本控制分类"></a>版本控制分类</h2><p><strong>1、本地版本控制</strong></p><p>记录文件每次的更新，可以对每个版本做一个快照，或是记录补丁文件，适合个人用，如RCS。</p><p><strong>2、集中版本控制 SVN</strong></p><p>所有的版本数据都保存在服务器上，协同开发者从服务器上同步更新或上传自己的修改。</p><p>所有的版本数据都存在服务器上，用户的本地只有自己以前所同步的版本，如果不连网的话，用户就看不到历史版本，也无法切换版本验证问题，或在不同分支工作。而且，所有数据都保存在单一的服务器上，有很大的风险这个服务器会损坏，这样就会丢失所有的数据，当然可以定期备份。代表产品：SVN、CVS、VSS</p><p><strong>3、分布式版本控制 Git</strong></p><p>所有版本信息仓库全部同步到本地的每个用户，这样就可以在本地查看所有版本历史，可以离线在本地提交，只需在连网时push到相应的服务器或其他用户那里。</p><p>每个人都拥有全部的代码，是安全隐患！由于每个用户那里保存的都是所有的版本数据，只要有一个用户的设备没有问题就可以恢复所有的数据，但这增加了本地存储空间的占用。</p><h2 id="Git工作流程"><a href="#Git工作流程" class="headerlink" title="Git工作流程"></a>Git工作流程</h2><ol><li>从远程仓库中克隆 Git 资源作为本地仓库。</li><li>从本地仓库中checkout代码然后进行代码修改</li><li>在提交前先将代码提交到暂存区。</li><li>提交修改。提交到本地仓库。本地仓库中保存修改的各个历史版本。</li><li>在修改完成后，需要和团队成员共享代码时，可以将代码push到远程仓库。</li></ol><img src="/2021/03/Git%E5%9F%BA%E7%A1%80Part1/image-20210314153241990.png" alt="image-20210314153241990" style="zoom:150%;"><h2 id="git原理"><a href="#git原理" class="headerlink" title="git原理"></a>git原理</h2><p>Git 底层采用的是 SHA-1 算法。 哈希算法可以被用来验证文件。</p><ol><li>不管输入数据的数据量有多大，输入同一个哈希算法，得到的加密结果长度固定。 </li><li>哈希算法确定，输入数据确定，输出数据能够保证不变 </li><li>哈希算法确定，输入数据有变化，输出数据一定有变化，而且通常变化很大 </li><li>哈希算法不可逆</li></ol><p>Git 把数据看作是小型文件系统的一组快照。每次提交更新时 Git 都会对当前的全部文件制作一个快照并保存这个快照的索引。为了高效，如果文件没有修改，Git 不再重新存储该文件，而是只保留一个链接指向之前存储的文件。所以 Git 的工作方式可以称之为快照流。</p><h2 id="fork与git-clone的区别"><a href="#fork与git-clone的区别" class="headerlink" title="fork与git clone的区别"></a>fork与git clone的区别</h2><p>1.区别</p><p>git clone 是在自己电脑直接敲命令，结果是将github仓库中的项目克隆到自己本地电脑中。</p><p>fork是直接访问github网站，在项目页面中点击fork，然后自己github项目中就会多出一个复制的项目。</p><p>2.用法</p><p>如果我们想要修改他人github项目的话，我们直接git clone代码到本地是不能pull的，所以我们使用fork，先把代码复制到自己的github仓库，然后git clone到本地修改，然后在提交pull（这里的pull是pull到自己github仓库了，我们自己的github仓库中的代码是fork源的一个分支），这时候我们想要把修改的代码提交给他人的话，就可以在自己github上pull，等其他人看到后就可以把代码做一个合并。</p>]]></content>
      
      
      <categories>
          
          <category> Git基础 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Linux基础-完结目录</title>
      <link href="/2021/03/Linux%E5%9F%BA%E7%A1%80-%E5%AE%8C%E7%BB%93%E7%9B%AE%E5%BD%95/"/>
      <url>/2021/03/Linux%E5%9F%BA%E7%A1%80-%E5%AE%8C%E7%BB%93%E7%9B%AE%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<h1 id="Linux基础-完结目录"><a href="#Linux基础-完结目录" class="headerlink" title="Linux基础-完结目录"></a>Linux基础-完结目录</h1><p>教程视频传送门：</p><ol><li><a href="https://www.bilibili.com/video/BV1dW411M7xL?from=search&seid=2409244161150482317">尚硅谷Linux教程(千万级学习人次，linux最新升级版)</a></li><li><a href="https://www.bilibili.com/video/BV187411y7hF?from=search&seid=7370772631947777047">【狂神说Java】Linux最通俗易懂的教程阿里云真实环境学习</a></li><li><a href="https://www.runoob.com/linux/linux-tutorial.html">Linux 教程</a></li></ol><p>狂神的比较精简，使用上差不多足够，与菜鸟教程的文本大多相同。尚硅谷的更全。</p><table><thead><tr><th align="center"><a href="/2021/03/Linux%E5%9F%BA%E7%A1%80Part1/">Part1——概述</a></th></tr></thead><tbody><tr><td align="center"><strong><a href="/2021/03/Linux%E5%9F%BA%E7%A1%80Part2/">Part2——基本命令</a></strong></td></tr><tr><td align="center"><strong><a href="/2021/03/Linux%E5%9F%BA%E7%A1%80Part3/">Part3——VIM使用</a></strong></td></tr><tr><td align="center"><strong><a href="/2021/03/Linux%E5%9F%BA%E7%A1%80Part4/">Part4——用户和用户组</a></strong></td></tr><tr><td align="center"><strong><a href="/2021/03/Linux%E5%9F%BA%E7%A1%80Part5/">Part5——系统管理</a></strong></td></tr><tr><td align="center"><strong><a href="/2021/03/Linux%E5%9F%BA%E7%A1%80Part6/">Part6——环境安装</a></strong></td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> Linux基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux基础Part6</title>
      <link href="/2021/03/Linux%E5%9F%BA%E7%A1%80Part6/"/>
      <url>/2021/03/Linux%E5%9F%BA%E7%A1%80Part6/</url>
      
        <content type="html"><![CDATA[<h1 id="Linux基础Part6——环境安装"><a href="#Linux基础Part6——环境安装" class="headerlink" title="Linux基础Part6——环境安装"></a>Linux基础Part6——环境安装</h1><p>[TOC]</p><h2 id="环境安装"><a href="#环境安装" class="headerlink" title="环境安装"></a>环境安装</h2><p>一般有三种方式：</p><ol><li>rpm</li><li>yum</li><li>解压缩</li></ol><h2 id="RPM-Redhat-Package-Manager"><a href="#RPM-Redhat-Package-Manager" class="headerlink" title="RPM(Redhat Package Manager)"></a>RPM(Redhat Package Manager)</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">rpm –qa | grep xx  <span class="comment"># 查询安装列表</span></span><br><span class="line">rpm -qi 软件包名  <span class="comment"># 查询软件包信息</span></span><br><span class="line">rpm -qf 文件全路径名  <span class="comment"># 查询文件所属的软件包</span></span><br><span class="line">rpm -e [ --nodeps ] 包名  <span class="comment"># rpm包卸载</span></span><br><span class="line">rpm -ivh RPM 包全路径名称</span><br><span class="line">rpm -ivh 包名  <span class="comment"># 安装</span></span><br></pre></td></tr></table></figure><blockquote><p>使用rpm安装jdk不需要配置环境变量，只需要重启就好了</p></blockquote><h2 id="YUM"><a href="#YUM" class="headerlink" title="YUM"></a>YUM</h2><p>Yum 是一个 Shell 前端软件包管理器。基于 RPM 包管理，能够从指定的服务器自动下载 RPM 包并且安装，可以自动处理依赖性关系，并且一次安装所有依赖的软件包。使用 yum 的前提是可以联网。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum [ options ] [ <span class="built_in">command</span> ] [ package ... ]</span><br></pre></td></tr></table></figure><ul><li>列出所有可更新的软件清单命令：<strong>yum check-update</strong> </li><li>更新所有软件命令：<strong>yum update</strong></li><li>仅安装指定的软件命令：<strong>yum install <package_name></package_name></strong></li><li>仅更新指定的软件命令：<strong>yum update <package_name></package_name></strong></li><li>列出所有可安裝的软件清单命令：<strong>yum list</strong></li><li>删除软件包命令：<strong>yum remove <package_name></package_name></strong></li><li>查找软件包命令：**yum search <key_word> **</key_word></li><li>清除缓存命令:<ul><li><strong>yum clean packages</strong>: 清除缓存目录下的软件包</li><li><strong>yum clean headers</strong>: 清除缓存目录下的 headers</li><li><strong>yum clean oldheaders</strong>: 清除缓存目录下旧的 headers</li><li><strong>yum clean, yum clean all (= yum clean packages; yum clean oldheaders)</strong> :清除缓存目录下的软件包及旧的 headers</li></ul></li><li>-y：自动确认所有提示</li></ul>]]></content>
      
      
      <categories>
          
          <category> Linux基础 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Linux基础Part5</title>
      <link href="/2021/03/Linux%E5%9F%BA%E7%A1%80Part5/"/>
      <url>/2021/03/Linux%E5%9F%BA%E7%A1%80Part5/</url>
      
        <content type="html"><![CDATA[<h1 id="Linux基础Part5——系统管理"><a href="#Linux基础Part5——系统管理" class="headerlink" title="Linux基础Part5——系统管理"></a>Linux基础Part5——系统管理</h1><p>[TOC]</p><h2 id="任务调度"><a href="#任务调度" class="headerlink" title="任务调度"></a>任务调度</h2><p>任务调度：是指系统在某个时间执行的特定的命令或程序。</p><ol><li><p>系统工作：有些重要的工作必须周而复始地执行。如病毒扫描等</p><p>设置任务调度文件：/etc/crontab</p></li><li><p>用户工作：个别用户可能希望执行某些程序，比如对 mysql 数据库的备份</p><p>执行 <code>crontab –e</code> 命令，输入任务到调度文件</p></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">crontab [ -erl ]</span><br><span class="line">service crond restart：[ 重启任务调度 ]</span><br></pre></td></tr></table></figure><ul><li>-e：编辑定时crontab任务</li><li>-l：查询crontab任务</li><li>-r：删除当前用户所有的crontab任务</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">*/1 * * * * ls –l /etc/ &gt; /tmp/to.txt  <span class="comment"># 每小时的每分钟执行 ls –l /etc/ &gt; /tmp/to.txt 命令</span></span><br></pre></td></tr></table></figure><ul><li>第1个*：一小时中的第几分钟。0~59。</li><li>第2个*：一天中的第几小时。0~23。</li><li>第3个*：一个月中的第几天。1~31。</li><li>第4个*：一年中的第几月。1~12。</li><li>第5个*：一周中的星期几。0~7。(0、7都表示周日)</li><li>*：代表任何时间</li><li>,：代表不连续的时间</li><li>-：代表连续的时间范围</li><li>*/n：代表每隔多久执行一次</li></ul><p>demo：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">先编写一个文件 /home/mytask1.sh</span><br><span class="line">date &gt;&gt; /tmp/mydate</span><br><span class="line">给 mytask1.sh 一个可以执行权限chmod 744 /home/mytask1.sh</span><br><span class="line">crontab -e</span><br><span class="line">*/1 * * * * /home/mytask1.sh</span><br><span class="line"></span><br><span class="line">[root@VM-1-14-centos ~]<span class="comment"># vim task1.sh  # 先编写一个shell脚本</span></span><br><span class="line">date &gt;&gt; /tmp/mydate</span><br><span class="line">[root@VM-1-14-centos ~]<span class="comment"># chmod 744 task1.sh  # 给脚本一个可执行权限</span></span><br><span class="line">[root@VM-1-14-centos ~]<span class="comment"># crontab -e  # 编辑任务</span></span><br><span class="line">*/1 * * * * /home/mytask1.sh</span><br><span class="line">[root@VM-1-14-centos ~]<span class="comment"># cd /tmp/</span></span><br><span class="line">[root@VM-1-14-centos tmp]<span class="comment"># cat mydate  # 查看输出</span></span><br><span class="line">Sat Mar 13 13:35:01 CST 2021</span><br><span class="line">Sat Mar 13 13:36:01 CST 2021</span><br><span class="line">Sat Mar 13 13:37:01 CST 2021</span><br></pre></td></tr></table></figure><h2 id="磁盘管理"><a href="#磁盘管理" class="headerlink" title="磁盘管理"></a>磁盘管理</h2><h3 id="分区基础知识"><a href="#分区基础知识" class="headerlink" title="分区基础知识"></a>分区基础知识</h3><p>分区的方式：</p><ol><li>mbr 分区:<ol><li>最多支持四个主分区</li><li>系统只能安装在主分区</li><li>扩展分区要占一个主分区</li><li>MBR 最大只支持 2TB，但拥有最好的兼容性</li></ol></li><li>gpt 分区:<ol><li>支持无限多个主分区（但操作系统可能限制，比如 windows 下最多 128 个分区）</li><li>最大支持 18EB 的大容量（1EB=1024 PB，1PB=1024 TB ）</li><li>windows7 64 位以后支持 gpt</li></ol></li></ol><h3 id="Linux分区"><a href="#Linux分区" class="headerlink" title="Linux分区"></a>Linux分区</h3><ol><li>原理：<ol><li>Linux 来说无论有几个分区，分给哪一目录使用，它归根结底就只有一个根目录，一个独立且唯一的文件结构 , Linux 中每个分区都是用来组成整个文件系统的一部分。</li><li>Linux 采用了一种叫“载入”的处理方法，它的整个文件系统中包含了一整套的文件和目录， 且将一个分区和一个目录联系起来。这时要载入的一个分区将使它的存储空间在一个目录下获得。</li></ol></li><li>硬盘说明：<ol><li>Linux 硬盘分 IDE 硬盘和 SCSI 硬盘，目前基本上是 SCSI 硬盘</li><li>对于 IDE 硬盘，驱动器标识符为“hdx<del>”,其中“hd”表明分区所在设备的类型，这里是指 IDE 硬盘了。“x”为盘号（a 为基本盘，b 为基本从属盘，c 为辅助主盘，d 为辅助从属盘）,“</del>”代表分区，前四个分区用数字 1 到 4 表示，它们是主分区或扩展分区，从 5 开始就是逻辑分区。例，hda3 表示为第一个 IDE 硬盘上的第三个主分区或扩展分区,hdb2 表示为第二个 IDE 硬盘上的第二个主分区或扩展分区。</li><li>对于 SCSI 硬盘则标识为“sdx~”，SCSI 硬盘是用“sd”来表示分区所在设备的类型的，其余则和 IDE 硬盘的表示方法一样</li></ol></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-1-14-centos tmp]<span class="comment"># lsblk  # 老色比裂开 查看系统分区和挂载情况</span></span><br><span class="line">NAME   MAJ:MIN RM  SIZE RO TYPE MOUNTPOINT</span><br><span class="line">sr0     11:0    1  111M  0 rom              <span class="comment"># 光驱</span></span><br><span class="line">vda    253:0    0   50G  0 disk             <span class="comment"># 硬盘</span></span><br><span class="line">└─vda1 253:1    0   50G  0 part /           <span class="comment"># 分区1</span></span><br><span class="line">[root@VM-1-14-centos tmp]<span class="comment"># lsblk -f</span></span><br><span class="line">NAME   FSTYPE  LABEL    UUID                                 MOUNTPOINT</span><br><span class="line">sr0    iso9660 config-2 2021-03-06-19-49-34-00               </span><br><span class="line">vda                                                          </span><br><span class="line">└─vda1 ext4             4b499d76-769a-40a0-93dc-4a31a59add28 /</span><br><span class="line"><span class="comment"># 分区名 分区类型          格式化产生的40位唯一标识分区id         挂载点</span></span><br></pre></td></tr></table></figure><h3 id="在虚拟机上挂载一块硬盘"><a href="#在虚拟机上挂载一块硬盘" class="headerlink" title="在虚拟机上挂载一块硬盘"></a>在虚拟机上挂载一块硬盘</h3><ol><li><p><strong>虚拟机添加硬盘</strong></p></li><li><p><strong>分区</strong> <code>fdisk /dev/sdb</code></p></li><li><p><strong>格式化</strong> <code>mkfs -t ext4 /dev/sdb1</code></p></li><li><p><strong>临时挂载</strong><br>先创建目录 <code>/home/newdisk</code><br>挂载指令：<code>mount /dev/sdb1 /home/newdisk</code><br>卸载指令：<code>umount 挂载目录或硬盘目录</code></p></li><li><p><strong>永久挂载</strong><br>修改设置：<code>vim /etc/fstab</code><br>添加一行：<code>/dev/sdb1 /home/newdisk ext4 defaults 0 0</code></p><p>生效：<code>mount -a</code></p></li></ol><h2 id="磁盘查询"><a href="#磁盘查询" class="headerlink" title="磁盘查询"></a>磁盘查询</h2><h3 id="df-：查询系统磁盘总体占用情况"><a href="#df-：查询系统磁盘总体占用情况" class="headerlink" title="df ：查询系统磁盘总体占用情况"></a>df ：查询系统磁盘总体占用情况</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df [ -ahikHTm ] [ 目录或文件名 ]</span><br></pre></td></tr></table></figure><ul><li>-a ：列出所有的文件系统，包括系统特有的 /proc 等文件系统</li><li>-h ：以人们较易阅读的 GBytes, MBytes, KBytes 等格式自行显示</li><li>-H ：以 M=1000K 取代 M=1024K 的进位方式</li><li>-T ：显示文件系统类型, 连同该 partition 的 filesystem 名称 (例如 ext3) 也列出</li><li>-i ：不用硬盘容量，而以 inode 的数量来显示</li><li>[ 目录或文件名 ]：指定挂载目录</li></ul><p>demo：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-1-14-centos tmp]<span class="comment"># df -h</span></span><br><span class="line">Filesystem      Size  Used Avail Use% Mounted on</span><br><span class="line">devtmpfs        3.9G     0  3.9G   0% /dev</span><br><span class="line">tmpfs           3.9G   24K  3.9G   1% /dev/shm</span><br><span class="line">tmpfs           3.9G  428K  3.9G   1% /run</span><br><span class="line">tmpfs           3.9G     0  3.9G   0% /sys/fs/cgroup</span><br><span class="line">/dev/vda1        50G  3.3G   44G   8% /</span><br><span class="line">tmpfs           783M     0  783M   0% /run/user/0</span><br></pre></td></tr></table></figure><h3 id="du：查询指定目录的磁盘占用情况"><a href="#du：查询指定目录的磁盘占用情况" class="headerlink" title="du：查询指定目录的磁盘占用情况"></a>du：查询指定目录的磁盘占用情况</h3><p>与 df 不一样的是，du 这个命令会直接到文件系统内去搜寻所有的文件数据。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">du [ -ahskm ] 文件或目录名称</span><br></pre></td></tr></table></figure><ul><li>-a ：列出所有的文件与目录容量，因为默认仅统计目录底下的文件夹而已</li><li>-h ：以人们较易读的容量格式 (G/M) 显示</li><li>-s ：列出总量而已，而不列出每个各别的目录占用容量</li><li>-S ：不包括子目录下的总计，与 -s 有点差别</li><li>–max-depth=1 子目录深度</li></ul><p>demo：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-1-14-centos tmp]<span class="comment"># du -h  # 默认为当前目录下文件夹(包含隐藏文件夹)的磁盘占用情况</span></span><br><span class="line">4.0K./.XIM-unix</span><br><span class="line">4.0K./.font-unix</span><br><span class="line">4.0K./.X11-unix</span><br><span class="line">4.0K./systemd-private-93e24fc7bc744033a007e9d37393f18d-ntpd.service-qBqeOq/tmp</span><br><span class="line">8.0K./systemd-private-93e24fc7bc744033a007e9d37393f18d-ntpd.service-qBqeOq</span><br><span class="line">4.0K./.ICE-unix</span><br><span class="line">13M./d0ba2854fb7784799d5cfe6838f4f3a6</span><br><span class="line">4.0K./.Test-unix</span><br><span class="line">13M.                              <span class="comment"># 当前目录下文件夹的总量</span></span><br><span class="line">[root@VM-1-14-centos tmp]<span class="comment"># du -ach</span></span><br><span class="line">4.0K./virtio_blk_affinity.log</span><br><span class="line">4.0K./.XIM-unix</span><br><span class="line">......</span><br><span class="line">4.0K./.Test-unix</span><br><span class="line">13M.</span><br><span class="line">13Mtotal</span><br></pre></td></tr></table></figure><h3 id="实用指令"><a href="#实用指令" class="headerlink" title="实用指令"></a>实用指令</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-1-14-centos ~]<span class="comment"># ls -l | grep &quot;^d&quot; | wc -l  # 统计当前目录下文件夹数量</span></span><br><span class="line">2</span><br><span class="line">[root@VM-1-14-centos ~]<span class="comment"># ls -l | grep &quot;^-&quot; | wc -l  # 统计当前目录下文件数量</span></span><br><span class="line">5</span><br><span class="line">[root@VM-1-14-centos ~]<span class="comment"># ls -lr | grep &quot;^-&quot; | wc -l  # 递归统计当前目录下文件数量</span></span><br><span class="line">5</span><br><span class="line">[root@VM-1-14-centos ~]<span class="comment"># yum install tree  # 安装tree</span></span><br><span class="line">[root@VM-1-14-centos ~]<span class="comment"># tree /  # 以树状显示目录结构</span></span><br></pre></td></tr></table></figure><h2 id="网络配置"><a href="#网络配置" class="headerlink" title="网络配置"></a>网络配置</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-1-14-centos ~]<span class="comment"># ifconfig  # 显示或设置网络设备</span></span><br><span class="line">[root@VM-1-14-centos ~]<span class="comment"># ping www.baidu.com  # 测试网络连通</span></span><br></pre></td></tr></table></figure><p><a href="https://www.bilibili.com/video/BV1dW411M7xL?p=46&spm_id_from=pageDriver">主要是虚拟机用</a></p><h2 id="线程管理"><a href="#线程管理" class="headerlink" title="线程管理"></a>线程管理</h2><h3 id="进程的基本介绍"><a href="#进程的基本介绍" class="headerlink" title="进程的基本介绍"></a>进程的基本介绍</h3><ol><li>在 LINUX 中，每个执行的程序（代码）都称为一个进程。每一个进程都分配一个 ID 号（进程号PID）。</li><li>每一个进程，都会对应一个父进程（父进程号PPID），而这个父进程可以复制多个子进程例如 www 服务器。</li><li>每个进程都可能以两种方式存在的。前台与后台，所谓前台进程就是用户目前的屏幕上可以进行操作的。后台进程（守护进程）则是实际在操作，但屏幕上无法看到的进程。</li><li>一般系统的服务都是以后台进程的方式存在，而且都会常驻在系统中，直到关机才才结束。</li></ol><h3 id="查看进程"><a href="#查看进程" class="headerlink" title="查看进程"></a>查看进程</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps [ -aux ]</span><br></pre></td></tr></table></figure><ul><li>-a：显示当前终端所有进程信息</li><li>-u：以用户的格式显示进程</li><li>-x：显示后台进程运行的参数</li><li>-e：显示所有进程</li><li>-f：全格式</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-1-14-centos ~]<span class="comment"># ps -aux | grep xxx  # 查看是否有xxx进程</span></span><br><span class="line">root     16906  0.0  0.0 112812   972 pts/0    S+   19:19   0:00 grep --color=auto xxx</span><br><span class="line">[root@VM-1-14-centos ~]<span class="comment"># ps -aux</span></span><br><span class="line">USER       PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND</span><br><span class="line">root         1  0.0  0.0 191036  4036 ?        Ss   Mar06   0:59 /usr/lib/systemd/systemd --switched-root --system --dese</span><br><span class="line">......</span><br><span class="line">[root@VM-1-14-centos ~]<span class="comment"># ps -ef</span></span><br><span class="line">UID        PID  PPID  C STIME TTY          TIME CMD</span><br><span class="line">root         1     0  0 Mar06 ?        00:01:00 /usr/lib/systemd/systemd --switched-root --system --deserialize 22</span><br><span class="line">......</span><br></pre></td></tr></table></figure><ul><li><p>USER：用户名称</p></li><li><p>PID：进程号</p></li><li><p>%CPU：进程占用 CPU 的百分比</p></li><li><p>%MEM：进程占用物理内存的百分比</p></li><li><p>VSZ：进程占用的虚拟内存大小（单位：KB）</p></li><li><p>RSS：进程占用的物理内存大小（单位：KB）</p></li><li><p>TTY：终端名称</p></li><li><p>STAT：进程状态，其中 S-睡眠，s-表示该进程是会话的先导进程，N-表示进程拥有比普通优先级更低的优先级，R-正在运行，D-短期等待，Z-僵死进程，T-被跟踪或者被停止等等</p></li><li><p>START：进程的启动时间</p></li><li><p>TIME：CPU 时间，即进程使用 CPU 的总时间</p></li><li><p>COMMAND：启动进程所用的命令和参数，如果过长会被截断显示</p></li><li><p>C：CPU 用于计算执行优先级的因子。数值越大，表明进程是 CPU 密集型运算，执行优先级会降低；数值越小，表明进程是 I/O 密集型运算，执行优先级会提高</p></li><li><p>STIME：进程启动的时间</p></li><li><p>TTY：完整的终端名称</p></li><li><p>TIME：CPU 时间</p></li><li><p>CMD：启动进程所用的命令和参数</p></li></ul><h3 id="结束进程"><a href="#结束进程" class="headerlink" title="结束进程"></a>结束进程</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">kill</span> [ -9 ] 进程号</span><br><span class="line">killall 进程名</span><br></pre></td></tr></table></figure><ul><li>9：强制终止</li></ul><p>demo：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-1-14-centos ~]<span class="comment"># kill 1590  # 结束/usr/sbin/sshd进程，终止远程登录服务</span></span><br><span class="line">[root@VM-1-14-centos ~]<span class="comment"># killall gedit  # 结束所有gedit进程</span></span><br></pre></td></tr></table></figure><h3 id="进程树"><a href="#进程树" class="headerlink" title="进程树"></a>进程树</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pstree [ -pu ]</span><br></pre></td></tr></table></figure><ul><li>-p :显示进程的 PID</li><li>-u :显示进程的所属用户</li></ul><h3 id="服务（守护进程）管理"><a href="#服务（守护进程）管理" class="headerlink" title="服务（守护进程）管理"></a>服务（守护进程）管理</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">service 服务名 [ start | stop | restart | reload | status ]</span><br></pre></td></tr></table></figure><h3 id="查看服务列表"><a href="#查看服务列表" class="headerlink" title="查看服务列表"></a>查看服务列表</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls -l /etc/init.d/</span><br></pre></td></tr></table></figure><h3 id="chkconfig指令"><a href="#chkconfig指令" class="headerlink" title="chkconfig指令"></a>chkconfig指令</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">chkconfig --list | grep 服务名</span><br><span class="line">chkconfig --level n 服务名 on/off</span><br></pre></td></tr></table></figure><p>demo：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#  案例 1： 请显示当前系统所有服务的各个运行级别的运行状态</span></span><br><span class="line">chkconfig --list</span><br><span class="line"><span class="comment">#  案例 2 ：请查看 sshd 服务的运行状态</span></span><br><span class="line">service sshd status</span><br><span class="line"><span class="comment">#  案例 3： 将 sshd 服务在运行级别 5 下设置为不自动启动</span></span><br><span class="line">chkconfig --level 5 sshd off</span><br><span class="line"><span class="comment">#  案例 4： 当运行级别为 5 时，关闭防火墙。</span></span><br><span class="line">chkconfig --level 5 iptables off</span><br><span class="line"><span class="comment">#  案例 5： 在所有运行级别下，关闭防火墙</span></span><br><span class="line">chkconfig iptables off</span><br><span class="line"><span class="comment">#  案例 6： 在所有运行级别下，开启防火墙</span></span><br><span class="line">chkconfig iptables on</span><br></pre></td></tr></table></figure><h3 id="动态监控进程"><a href="#动态监控进程" class="headerlink" title="动态监控进程"></a>动态监控进程</h3><p>top 与 ps 命令很相似，都用来显示正在执行的进程。但不同在于 top 在执行一段时间可以更新正在运行的的进程。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">top [ -dip ]</span><br></pre></td></tr></table></figure><ul><li>-d：秒数，指定top命令间隔多少秒更新，默认3秒</li><li>-i：使top不显示闲置或僵死进程</li><li>-p：通过指定进程PID来显示相应进程状态</li></ul><p>交互操作：</p><ul><li>P：以CPU使用率排序（默认此项）</li><li>M：以内存使用率来排序</li><li>N：以PID排序</li><li>q：退出top</li><li>k：杀死进程</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">top - 21:15:35 up 7 days,  1:25,  1 user,  load average: 0.00, 0.02, 0.05        <span class="comment"># 当前时间 运行时间 登录用户数 负载均衡</span></span><br><span class="line">Tasks:  93 total,   2 running,  91 sleeping,   0 stopped,   0 zombie</span><br><span class="line">%Cpu(s):  0.3 us,  0.2 sy,  0.0 ni, 99.5 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st  <span class="comment"># cpu使用情况</span></span><br><span class="line">KiB Mem :  8009084 total,  5870600 free,   217104 used,  1921380 buff/cache      <span class="comment"># 内存使用情况</span></span><br><span class="line">KiB Swap:        0 total,        0 free,        0 used.  7481244 avail Mem </span><br><span class="line"></span><br><span class="line">  PID USER      PR  NI    VIRT    RES    SHR S  %CPU %MEM     TIME+ COMMAND                                             </span><br><span class="line"> 7164 root      20   0  161996   2176   1552 R   0.3  0.0   0:00.16 top                                                 </span><br><span class="line">24146 root      20   0  160712   9412   2020 S   0.3  0.1   4:59.89 barad_agent                                         </span><br><span class="line">24147 root      20   0  607352  15888   2200 S   0.3  0.2  25:44.34 barad_agent  </span><br><span class="line">......</span><br></pre></td></tr></table></figure><h3 id="查看网络状态"><a href="#查看网络状态" class="headerlink" title="查看网络状态"></a>查看网络状态</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netstat [ -anp ]</span><br></pre></td></tr></table></figure><ul><li>-an 按一定顺序排列输出</li><li>-p 显示哪个进程在调用</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-1-14-centos ~]<span class="comment"># netstat -anp | grep sshd</span></span><br><span class="line">tcp        0      0 0.0.0.0:22              0.0.0.0:*               LISTEN      1590/sshd           </span><br><span class="line">tcp        0     52 172.17.1.14:22          114.222.3.200:9702      ESTABLISHED 4553/sshd: root@pts </span><br><span class="line">unix  3      [ ]         STREAM     CONNECTED     17005    1590/sshd            </span><br><span class="line">unix  2      [ ]         DGRAM                    11566495 4553/sshd: root@pts  </span><br></pre></td></tr></table></figure><h2 id="指定运行级别"><a href="#指定运行级别" class="headerlink" title="指定运行级别"></a>指定运行级别</h2><p>运行级别说明：</p><ol start="0"><li>关机</li><li>单用户(在实体机上开机时进入单用户模式，找回root密码)</li><li>多用户无网络</li><li>多用户有网络</li><li>保留级别</li><li>图形界面</li><li>系统重启</li></ol><p>修改默认运行级别可以修改文件 <code>/etc/inittab</code> 中的 <code>id:5:initdefault: </code></p><p>或者使用命令：<code>init [ 0123456 ]</code></p><p>开机流程：</p><ol><li>开机</li><li>BIOS</li><li>/boot</li><li>init进程1</li><li>运行级别</li><li>运行级别对应的服务</li></ol>]]></content>
      
      
      <categories>
          
          <category> Linux基础 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Linux基础Part4</title>
      <link href="/2021/03/Linux%E5%9F%BA%E7%A1%80Part4/"/>
      <url>/2021/03/Linux%E5%9F%BA%E7%A1%80Part4/</url>
      
        <content type="html"><![CDATA[<h1 id="Linux基础Part4——用户和用户组"><a href="#Linux基础Part4——用户和用户组" class="headerlink" title="Linux基础Part4——用户和用户组"></a>Linux基础Part4——用户和用户组</h1><p>[TOC]</p><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>Linux系统是一个多用户多任务的分时操作系统，任何一个要使用系统资源的用户，都必须首先向系统管理员申请一个账号，然后以这个账号的身份进入系统。</p><p>用户的账号一方面可以帮助系统管理员对使用系统的用户进行跟踪，并控制他们对系统资源的访问；另一方面也可以帮助用户组织文件，并为用户提供安全性保护。</p><p>每个用户账号都拥有一个唯一的用户名和各自的口令。</p><p>用户在登录时键入正确的用户名和口令后，就能够进入系统和自己的主目录。</p><p>实现用户账号的管理，要完成的工作主要有如下几个方面：</p><ul><li>用户账号的添加、删除与修改。</li><li>用户口令的管理。</li><li>用户组的管理。</li></ul><h2 id="用户管理"><a href="#用户管理" class="headerlink" title="用户管理"></a>用户管理</h2><h3 id="添加用户"><a href="#添加用户" class="headerlink" title="添加用户"></a>添加用户</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">useradd [ -cdgGsu ] 用户名</span><br></pre></td></tr></table></figure><ul><li>-c comment 指定一段注释性描述</li><li>-d 目录 指定用户主目录，如果此目录不存在，则一并创建</li><li>-g 用户组 指定用户所属的用户组 <code>useradd -g group user</code></li><li>-G 用户组，用户组 指定用户所属的附加组(SentOS每个用户只有一个附加组)</li><li>-s Shell文件 指定用户的登录Shell</li><li>-u 用户号 指定用户的用户号，如果同时有-o选项，则可以重复使用其他用户的标识号</li></ul><p>如果不使用参数，则默认在 /home 新建一个  /home/用户名 ，注意不要提前自己新建目录，因为还需要生成一系列隐藏文件。</p><h3 id="口令管理"><a href="#口令管理" class="headerlink" title="口令管理"></a>口令管理</h3><p>用户账号刚创建时没有口令，被系统锁定，无法使用，必须为其指定口令后才可以使用，即使是指定空口令。</p><p>指定和修改用户口令的Shell命令是<code>passwd</code>。超级用户可以为自己和其他用户指定口令，普通用户只能用它修改自己的口令。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">passwd [ -ludf ] 用户名</span><br></pre></td></tr></table></figure><ul><li>-l 锁定口令，即禁用账号</li><li>-u 口令解锁</li><li>-d 使账号无口令</li><li>-f 强迫用户下次登录时修改口令</li></ul><p>如果默认用户名，则修改当前用户的口令</p><p>普通用户修改自己的口令时，要求先输入原口令；而超级用户为用户指定口令时，就不需要原口令。</p><h3 id="删除用户"><a href="#删除用户" class="headerlink" title="删除用户"></a>删除用户</h3><p>如果一个用户的账号不再使用，可以从系统中删除。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">userdel [ -r ] 用户名</span><br></pre></td></tr></table></figure><ul><li> -r 把用户相关文件一起删除，包括用户在系统文件中（主要是/etc/passwd, /etc/shadow, /etc/group等）的记录，同时删除用户的主目录。</li></ul><p>一般公司员工离职会删除用户但保存家目录，因为其贡献的代码都在家目录中。</p><h3 id="修改用户"><a href="#修改用户" class="headerlink" title="修改用户"></a>修改用户</h3><p>修改用户账号就是根据实际情况更改用户的有关属性，如用户号、主目录、用户组、登录Shell等。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">usermod [ -cdgGsu ] 用户名</span><br></pre></td></tr></table></figure><p>常用的选项包括 -c, -d, -m, -g, -G, -s, -u, -o 等，这些选项的意义同 <code>useradd</code> ，可以为用户指定新的资源值。</p><p>另外，有些系统可以使用选项：-l 将原来的用户名改为新的用户名。</p><h3 id="查询用户"><a href="#查询用户" class="headerlink" title="查询用户"></a>查询用户</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">id 用户名</span><br></pre></td></tr></table></figure><p>demo：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-1-14-centos tt]<span class="comment"># id root</span></span><br><span class="line">uid=0(root) gid=0(root) groups=0(root)</span><br><span class="line">[root@VM-1-14-centos tt]<span class="comment"># id xu</span></span><br><span class="line">id: xu: no such user</span><br></pre></td></tr></table></figure><h3 id="切换用户"><a href="#切换用户" class="headerlink" title="切换用户"></a>切换用户</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">su 用户名</span><br></pre></td></tr></table></figure><p>高权限用户到低权限用户不需要输入密码，反之需要</p><p>可以通过 <code>exit</code> 返回原用户</p><h3 id="查看当前用户"><a href="#查看当前用户" class="headerlink" title="查看当前用户"></a>查看当前用户</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">whoami</span><br></pre></td></tr></table></figure><p>返回当前登录用户名</p><h2 id="用户组管理"><a href="#用户组管理" class="headerlink" title="用户组管理"></a>用户组管理</h2><p>每个用户都有一个用户组，系统可以对一个用户组中的所有用户进行集中管理。</p><p>组的增加、删除和修改实际上就是对/etc/group文件的更新。</p><h3 id="新增用户组"><a href="#新增用户组" class="headerlink" title="新增用户组"></a>新增用户组</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">groupadd [ -go ] 用户组</span><br></pre></td></tr></table></figure><ul><li>-g GID 指定新用户组的组标识号（GID）。</li><li>-o 一般与-g选项同时使用，表示新用户组的GID可以与系统已有用户组的GID相同。</li></ul><p>不指定GID则默认在当前已有的最大组标识号的基础上加1。</p><h3 id="删除用户组"><a href="#删除用户组" class="headerlink" title="删除用户组"></a>删除用户组</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">groupdel 用户组</span><br></pre></td></tr></table></figure><h3 id="修改用户组属性"><a href="#修改用户组属性" class="headerlink" title="修改用户组属性"></a>修改用户组属性</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">groupmod [ -gon ] 用户组</span><br></pre></td></tr></table></figure><ul><li>-g GID 为用户组指定新的组标识号。</li><li>-o 与-g选项同时使用，用户组的新GID可以与系统已有用户组的GID相同。</li><li>-n新用户组 将用户组的名字改为新名字</li></ul><p>demo；</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">groupmod –g 10000 -n group3 group2  <span class="comment"># 将组group2的标识号改为10000，组名修改为group3</span></span><br></pre></td></tr></table></figure><h3 id="切换用户组"><a href="#切换用户组" class="headerlink" title="切换用户组"></a>切换用户组</h3><p>如果一个用户同时属于多个用户组，那么用户可以在用户组之间切换，以便具有其他用户组的权限。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">newgrp 用户组</span><br></pre></td></tr></table></figure><h2 id="用户和用户组的系统文件"><a href="#用户和用户组的系统文件" class="headerlink" title="用户和用户组的系统文件"></a>用户和用户组的系统文件</h2><p>管理用户和用户组实际上都是对有关的系统文件进行修改，包括/etc/passwd, /etc/shadow, /etc/group等。</p><h3 id="etc-passwd"><a href="#etc-passwd" class="headerlink" title="/etc/passwd"></a>/etc/passwd</h3><p>Linux系统中的每个用户都在/etc/passwd文件中有一个对应的记录行，它记录了这个用户的一些基本属性。</p><p>这个文件对所有用户都是可读的。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-1-14-centos home]<span class="comment"># cat /etc/passwd</span></span><br><span class="line">root:x:0:0:root:/root:/bin/bash</span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line">用户名:口令:用户标识号:组标识号:注释性描述:主目录:登录Shell</span><br></pre></td></tr></table></figure><h4 id="用户名"><a href="#用户名" class="headerlink" title="用户名"></a>用户名</h4><p>“用户名”是代表用户账号的字符串。通常长度不超过8个字符，并且由大小写字母和/或数字组成。</p><p>登录名中不能有冒号(:)，因为冒号在这里是分隔符。为了兼容起见，登录名中最好不要包含点字符(.)，并且不使用连字符(-)和加号(+)打头。</p><h4 id="口令"><a href="#口令" class="headerlink" title="口令"></a>口令</h4><p>虽然这个字段存放的只是用户口令的加密串，不是明文，但是由于/etc/passwd文件对所有用户都可读，所以这仍是一个安全隐患。</p><p>因此，现在许多Linux 系统都使用了shadow技术，把真正的加密后的用户口令字存放到/etc/shadow文件中，而在/etc/passwd文件的口令字段中只存放一个特殊的字符，例如“x”或者“*”。</p><h4 id="用户标识号"><a href="#用户标识号" class="headerlink" title="用户标识号"></a>用户标识号</h4><p>一般情况下它与用户名是一一对应的。如果几个用户名对应的用户标识号是一样的，系统内部将把它们视为同一个用户，但是它们可以有不同的口令、不同的主目录以及不同的登录Shell等。</p><p>通常用户标识号的取值范围是0～65 535。0是超级用户root的标识号，1～99由系统保留，作为管理账号，普通用户的标识号从100开始。在Linux系统中，这个界限是500。</p><h4 id="组标识号"><a href="#组标识号" class="headerlink" title="组标识号"></a>组标识号</h4><p>它对应着/etc/group文件中的一条记录。</p><h4 id="注释性描述"><a href="#注释性描述" class="headerlink" title="注释性描述"></a>注释性描述</h4><p>例如用户的真实姓名、电话、地址等，这个字段并没有什么实际的用途。格式也没有统一。在许多Linux系统中，用做finger命令的输出。没有就为空。</p><h4 id="主目录"><a href="#主目录" class="headerlink" title="主目录"></a>主目录</h4><p>是用户在登录到系统之后所处的家目录。各用户的主目录都被放在 /home 下，通常来说用户主目录的名称就是该用户的登录名。</p><p>各用户对自己的主目录有读、写、执行权限，其他用户对此目录的访问权限则根据具体情况设置。</p><h4 id="登录Shell"><a href="#登录Shell" class="headerlink" title="登录Shell"></a>登录Shell</h4><p>Shell是用户与Linux系统之间的接口。Linux的Shell有许多种，每种都有不同的特点。常用的有sh(Bourne Shell), csh(C Shell), ksh(Korn Shell), tcsh(TENEX/TOPS-20 type C Shell), bash(Bourne Again Shell)等。</p><p>系统管理员可以根据系统情况和用户习惯为用户指定某个Shell。如果不指定Shell，那么系统使用sh为默认的登录Shell，即这个字段的值为/bin/sh。</p><p>用户的登录Shell也可以指定为某个特定的程序（此程序不是一个命令解释器）。</p><p>利用这一特点，我们可以限制用户只能运行指定的应用程序，在该应用程序运行结束后，用户就自动退出了系统。有些Linux 系统要求只有那些在系统中登记了的程序才能出现在这个字段中。</p><h4 id="伪用户-pseudo-users"><a href="#伪用户-pseudo-users" class="headerlink" title="伪用户(pseudo users)"></a>伪用户(pseudo users)</h4><p>这些用户在/etc/passwd文件中也占有一条记录，但是不能登录，因为它们的登录Shell为空。它们的存在主要是方便系统管理，满足相应的系统进程对文件属主的要求。</p><ul><li>bin 拥有可执行的用户命令文件 </li><li>sys 拥有系统文件 </li><li>adm 拥有帐户文件 </li><li>uucp UUCP使用 </li><li>lp lp或lpd子系统使用 </li><li>nobody NFS使用</li></ul><h3 id="etc-shadow"><a href="#etc-shadow" class="headerlink" title="/etc/shadow"></a>/etc/shadow</h3><p>与/etc/passwd记录一一对应，由pwconv命令根据/etc/passwd中的数据自动产生。但只有超级用户才拥有该文件读权限。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-1-14-centos home]<span class="comment"># cat /etc/shadow</span></span><br><span class="line">root:$1$ltOhBJKQ<span class="variable">$X</span>/KwY82TfyngQn/GVxk..1:18692:0:99999:7:::</span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line">登录名:加密口令:最后一次修改时间:最小时间间隔:最大时间间隔:警告时间:不活动时间:失效时间:标志</span><br></pre></td></tr></table></figure><ol><li>“登录名”是与/etc/passwd文件中的登录名相一致的用户账号</li><li>“口令”字段存放的是加密后的用户口令字，长度为13个字符。如果为空，则对应用户没有口令，登录时不需要口令；如果含有不属于集合 { ./0-9A-Za-z }中的字符，则对应的用户不能登录。</li><li>“最后一次修改时间”表示的是从某个时刻起，到用户最后一次修改口令时的天数。时间起点对不同的系统可能不一样。</li><li>“最小时间间隔”指的是两次修改口令之间所需的最小天数。</li><li>“最大时间间隔”指的是口令保持有效的最大天数。</li><li>“警告时间”字段表示的是从系统开始警告用户到用户密码正式失效之间的天数。</li><li>“不活动时间”表示的是用户没有登录活动但账号仍能保持有效的最大天数。</li><li>“失效时间”字段给出的是一个绝对的天数，如果使用了这个字段，那么就给出相应账号的生存期。期满后，该账号就不再是一个合法的账号，也就不能再用来登录了。</li></ol><h3 id="etc-group"><a href="#etc-group" class="headerlink" title="/etc/group"></a>/etc/group</h3><p>用户组的所有信息都存放在 /etc/group 文件中。</p><p>将用户分组是 Linux 系统中对用户进行管理及控制访问权限的一种手段。</p><p>每个用户都属于某个用户组；一个组中可以有多个用户，一个用户也可以属于不同的组。</p><p>当一个用户同时是多个组中的成员时，在 /etc/passwd 文件中记录的是用户所属的主组，也就是登录时所属的默认组，而其他组称为附加组。</p><p>用户要访问属于附加组的文件时，必须首先使用 <code>newgrp</code> 命令使自己成为所要访问的组中的成员。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-1-14-centos home]<span class="comment"># cat /etc/shadow</span></span><br><span class="line">root:$1$ltOhBJKQ<span class="variable">$X</span>/KwY82TfyngQn/GVxk..1:18692:0:99999:7:::</span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line">组名:口令:组标识号:组内用户列表</span><br></pre></td></tr></table></figure><ol><li>“组名”是用户组的名称，由字母或数字构成。与/etc/passwd中的登录名一样，组名不应重复。</li><li>“口令”字段存放的是用户组加密后的口令字。一般Linux 系统的用户组都没有口令，即这个字段一般为空，或者是*。</li><li>“组标识号”与用户标识号类似，也是一个整数，被系统内部用来标识组。</li><li>“组内用户列表”是属于这个组的所有用户的列表，不同用户之间用逗号(,)分隔。这个用户组可能是用户的主组，也可能是附加组。</li></ol><p>口令和主组内用户列表一般是看不到的</p><h2 id="添加批量用户"><a href="#添加批量用户" class="headerlink" title="添加批量用户"></a>添加批量用户</h2><h3 id="（1）先编辑一个文本用户文件"><a href="#（1）先编辑一个文本用户文件" class="headerlink" title="（1）先编辑一个文本用户文件"></a>（1）先编辑一个文本用户文件</h3><p>每一列按照<code>/etc/passwd</code>密码文件的格式书写，要注意每个用户的用户名、UID、宿主目录都不可以相同，其中密码栏可以留做空白或输入x号。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">user001::600:100:user:/home/user001:/bin/bash</span><br><span class="line">user002::601:100:user:/home/user002:/bin/bash</span><br><span class="line">user003::602:100:user:/home/user003:/bin/bash</span><br><span class="line">user004::603:100:user:/home/user004:/bin/bash</span><br><span class="line">user005::604:100:user:/home/user005:/bin/bash</span><br><span class="line">user006::605:100:user:/home/user006:/bin/bash</span><br></pre></td></tr></table></figure><h3 id="（2）以root身份执行-usr-sbin-newusers并导入user-txt"><a href="#（2）以root身份执行-usr-sbin-newusers并导入user-txt" class="headerlink" title="（2）以root身份执行 /usr/sbin/newusers并导入user.txt"></a>（2）以root身份执行 <code>/usr/sbin/newusers</code>并导入<code>user.txt</code></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># newusers &lt; user.txt</span><br></pre></td></tr></table></figure><p>然后可以执行命令 <code>vipw</code> 或 <code>vi /etc/passwd</code> 检查 <code>/etc/passwd</code> 文件是否已经出现这些用户的数据，并且用户的宿主目录是否已经创建。</p><h3 id="（3）执行命令-usr-sbin-pwunconv"><a href="#（3）执行命令-usr-sbin-pwunconv" class="headerlink" title="（3）执行命令/usr/sbin/pwunconv"></a>（3）执行命令/usr/sbin/pwunconv</h3><p>将 <code>/etc/shadow</code> 产生的 <code>shadow</code> 密码解码，然后回写到 <code>/etc/passwd</code> 中，并将<code>/etc/shadow</code>的<code>shadow</code>密码栏删掉。这是为了方便下一步的密码转换工作，即先取消 <code>shadow password</code> 功能。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># pwunconv</span></span><br></pre></td></tr></table></figure><h3 id="（4）编辑每个用户的密码对照文件"><a href="#（4）编辑每个用户的密码对照文件" class="headerlink" title="（4）编辑每个用户的密码对照文件"></a>（4）编辑每个用户的密码对照文件</h3><p>格式为：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">用户名:密码</span><br></pre></td></tr></table></figure><p>实例文件 <code>passwd.txt</code> 内容如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">user001:123456</span><br><span class="line">user002:123456</span><br><span class="line">user003:123456</span><br><span class="line">user004:123456</span><br><span class="line">user005:123456</span><br><span class="line">user006:123456</span><br></pre></td></tr></table></figure><h3 id="（5）以-root-身份执行命令-usr-sbin-chpasswd"><a href="#（5）以-root-身份执行命令-usr-sbin-chpasswd" class="headerlink" title="（5）以 root 身份执行命令 /usr/sbin/chpasswd"></a>（5）以 root 身份执行命令 <code>/usr/sbin/chpasswd</code></h3><p>创建用户密码，<code>chpasswd</code> 会将经过 <code>/usr/bin/passwd</code> 命令编码过的密码写入 <code>/etc/passwd</code> 的密码栏。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># chpasswd &lt; passwd.txt</span></span><br></pre></td></tr></table></figure><h3 id="（6）确定密码经编码写入-etc-passwd的密码栏后"><a href="#（6）确定密码经编码写入-etc-passwd的密码栏后" class="headerlink" title="（6）确定密码经编码写入/etc/passwd的密码栏后"></a>（6）确定密码经编码写入/etc/passwd的密码栏后</h3><p>执行命令 <code>/usr/sbin/pwconv</code> 将密码编码为 <code>shadow password</code>，并将结果写入 <code>/etc/shadow</code>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># pwconv</span></span><br></pre></td></tr></table></figure><p>这样就完成了大量用户的创建了，之后您可以到/home下检查这些用户宿主目录的权限设置是否都正确，并登录验证用户密码是否正确。</p>]]></content>
      
      
      <categories>
          
          <category> Linux基础 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Linux基础Part3</title>
      <link href="/2021/03/Linux%E5%9F%BA%E7%A1%80Part3/"/>
      <url>/2021/03/Linux%E5%9F%BA%E7%A1%80Part3/</url>
      
        <content type="html"><![CDATA[<h1 id="Linux基础Part3——VIM使用"><a href="#Linux基础Part3——VIM使用" class="headerlink" title="Linux基础Part3——VIM使用"></a>Linux基础Part3——VIM使用</h1><p>[TOC]</p><h2 id="VIM简介"><a href="#VIM简介" class="headerlink" title="VIM简介"></a>VIM简介</h2><p>Vim是从 vi 发展出来的一个文本编辑器。具有代码补完、编译及错误跳转等丰富的编程功能。</p><p><img src="/2021/03/Linux%E5%9F%BA%E7%A1%80Part3/vi-vim-cheat-sheet-sch.gif" alt="img"></p><h2 id="vi-vim-的使用"><a href="#vi-vim-的使用" class="headerlink" title="vi/vim 的使用"></a>vi/vim 的使用</h2><p>基本上 vi/vim 共分为三种模式，分别是<strong>命令模式（Command mode）</strong>、<strong>输入模式（Insert mode）</strong>、<strong>底线命令模式（Last line mode）</strong>。 </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim 文件名</span><br></pre></td></tr></table></figure><ul><li>这里的文件可以是存在的，也可以是不存在的</li></ul><h3 id="命令-一般模式"><a href="#命令-一般模式" class="headerlink" title="命令/一般模式"></a>命令/一般模式</h3><p>用户刚刚启动 vi/vim，便进入了命令模式。</p><p>此状态下敲击键盘动作会被Vim识别为命令，而非输入字符。比如我们此时按下i，并不会输入一个字符，i被当作了一个命令。</p><ul><li><strong>i</strong> 切换到输入模式，以输入字符。tip：用 i, I, o, O, a, A, r, R 都可以进入编辑模式。</li><li><strong>x</strong> 删除当前光标所在处的字符。</li><li><strong>:</strong> 切换到底线命令模式，以在最底一行输入命令。</li></ul><p>命令模式只有一些最基本的命令，因此仍要依靠底线命令模式输入更多命令。</p><h3 id="输入-编辑模式"><a href="#输入-编辑模式" class="headerlink" title="输入/编辑模式"></a>输入/编辑模式</h3><p>在命令模式下按下i就进入了输入模式。</p><p>在输入模式中，可以使用以下按键：</p><ul><li><strong>字符按键以及Shift组合</strong>，输入字符</li><li><strong>ENTER</strong>，回车键，换行</li><li><strong>BACK SPACE</strong>，退格键，删除光标前一个字符</li><li><strong>DEL</strong>，删除键，删除光标后一个字符</li><li><strong>方向键</strong>，在文本中移动光标</li><li><strong>HOME</strong>/<strong>END</strong>，移动光标到行首/行尾</li><li><strong>Page Up</strong>/<strong>Page Down</strong>，上/下翻页</li><li><strong>Insert</strong>，切换光标为输入/替换模式，光标将变成竖线/下划线</li><li><strong>ESC</strong>，退出输入模式，切换到命令模式</li></ul><h3 id="底线命令模式"><a href="#底线命令模式" class="headerlink" title="底线命令模式"></a>底线命令模式</h3><p>在命令模式下按下:（英文冒号）就进入了底线命令模式。</p><ul><li>q 不保存，退出程序</li><li>w 保存文件</li><li>qw 保存并退出</li><li>q! 强制退出</li><li>ESC 退出底线命令模式。</li></ul><p><img src="/2021/03/Linux%E5%9F%BA%E7%A1%80Part3/vim-vi-workmodel.png" alt="img"></p><h2 id="vi-vim-按键说明"><a href="#vi-vim-按键说明" class="headerlink" title="vi/vim 按键说明"></a>vi/vim 按键说明</h2><h3 id="第一部分：一般模式可用的光标移动、复制粘贴、搜索替换等"><a href="#第一部分：一般模式可用的光标移动、复制粘贴、搜索替换等" class="headerlink" title="第一部分：一般模式可用的光标移动、复制粘贴、搜索替换等"></a>第一部分：一般模式可用的光标移动、复制粘贴、搜索替换等</h3><table><thead><tr><th align="left">移动光标的方法</th><th></th></tr></thead><tbody><tr><td align="left">h 或 向左箭头键(←)</td><td>光标向左移动一个字符</td></tr><tr><td align="left">j 或 向下箭头键(↓)</td><td>光标向下移动一个字符</td></tr><tr><td align="left">k 或 向上箭头键(↑)</td><td>光标向上移动一个字符</td></tr><tr><td align="left">l 或 向右箭头键(→)</td><td>光标向右移动一个字符</td></tr><tr><td align="left">如果你将右手放在键盘上的话，你会发现 hjkl 是排列在一起的，因此可以使用这四个按钮来移动光标。 如果想要进行多次移动的话，例如向下移动 30 行，可以使用 “30j” 或 “30↓” 的组合按键， 亦即加上想要进行的次数(数字)后，按下动作即可！</td><td></td></tr><tr><td align="left">[Ctrl] + [f]</td><td>屏幕『向下』移动一页，相当于 [Page Down]按键 (常用)</td></tr><tr><td align="left">[Ctrl] + [b]</td><td>屏幕『向上』移动一页，相当于 [Page Up] 按键 (常用)</td></tr><tr><td align="left">[Ctrl] + [d]</td><td>屏幕『向下』移动半页</td></tr><tr><td align="left">[Ctrl] + [u]</td><td>屏幕『向上』移动半页</td></tr><tr><td align="left">+</td><td>光标移动到非空格符的下一行</td></tr><tr><td align="left">-</td><td>光标移动到非空格符的上一行</td></tr><tr><td align="left">n<space></space></td><td>那个 n 表示『数字』，例如 20 。按下数字后再按空格键，光标会向右移动这一行的 n 个字符。例如 20<space> 则光标会向后面移动 20 个字符距离。</space></td></tr><tr><td align="left">0 或功能键[Home]</td><td>这是数字『 0 』：移动到这一行的最前面字符处 (常用)</td></tr><tr><td align="left">$ 或功能键[End]</td><td>移动到这一行的最后面字符处(常用)</td></tr><tr><td align="left">H</td><td>光标移动到这个屏幕的最上方那一行的第一个字符</td></tr><tr><td align="left">M</td><td>光标移动到这个屏幕的中央那一行的第一个字符</td></tr><tr><td align="left">L</td><td>光标移动到这个屏幕的最下方那一行的第一个字符</td></tr><tr><td align="left">G</td><td>移动到这个档案的最后一行(常用)</td></tr><tr><td align="left">nG</td><td>n 为数字。移动到这个档案的第 n 行。例如 20G 则会移动到这个档案的第 20 行(可配合 :set nu)</td></tr><tr><td align="left">gg</td><td>移动到这个档案的第一行，相当于 1G 啊！ (常用)</td></tr><tr><td align="left">n<Enter></Enter></td><td>n 为数字。光标向下移动 n 行(常用)</td></tr><tr><td align="left">搜索替换</td><td></td></tr><tr><td align="left">/word</td><td>向光标之下寻找一个名称为 word 的字符串。例如要在档案内搜寻 vbird 这个字符串，就输入 /vbird 即可！ (常用)</td></tr><tr><td align="left">?word</td><td>向光标之上寻找一个字符串名称为 word 的字符串。</td></tr><tr><td align="left">n</td><td>这个 n 是英文按键。代表重复前一个搜寻的动作。举例来说， 如果刚刚我们执行 /vbird 去向下搜寻 vbird 这个字符串，则按下 n 后，会向下继续搜寻下一个名称为 vbird 的字符串。如果是执行 ?vbird 的话，那么按下 n 则会向上继续搜寻名称为 vbird 的字符串！</td></tr><tr><td align="left">N</td><td>这个 N 是英文按键。与 n 刚好相反，为『反向』进行前一个搜寻动作。 例如 /vbird 后，按下 N 则表示『向上』搜寻 vbird 。</td></tr><tr><td align="left">使用 /word 配合 n 及 N 是非常有帮助的！可以让你重复的找到一些你搜寻的关键词！</td><td></td></tr><tr><td align="left">:n1,n2s/word1/word2/g</td><td>n1 与 n2 为数字。在第 n1 与 n2 行之间寻找 word1 这个字符串，并将该字符串取代为 word2 ！举例来说，在 100 到 200 行之间搜寻 vbird 并取代为 VBIRD 则： 『:100,200s/vbird/VBIRD/g』。(常用)</td></tr><tr><td align="left"><strong>:1,$s/word1/word2/g</strong> 或 <strong>:%s/word1/word2/g</strong></td><td>从第一行到最后一行寻找 word1 字符串，并将该字符串取代为 word2 ！(常用)</td></tr><tr><td align="left"><strong>:1,$s/word1/word2/gc</strong> 或 <strong>:%s/word1/word2/gc</strong></td><td>从第一行到最后一行寻找 word1 字符串，并将该字符串取代为 word2 ！且在取代前显示提示字符给用户确认 (confirm) 是否需要取代！(常用)</td></tr><tr><td align="left">删除、复制与贴上</td><td></td></tr><tr><td align="left">x, X</td><td>在一行字当中，x 为向后删除一个字符 (相当于 [del] 按键)， X 为向前删除一个字符(相当于 [backspace] 亦即是退格键) (常用)</td></tr><tr><td align="left">nx</td><td>n 为数字，连续向后删除 n 个字符。举例来说，我要连续删除 10 个字符， 『10x』。</td></tr><tr><td align="left">dd</td><td>删除游标所在的那一整行(常用)</td></tr><tr><td align="left">ndd</td><td>n 为数字。删除光标所在的向下 n 行，例如 20dd 则是删除 20 行 (常用)</td></tr><tr><td align="left">d1G</td><td>删除光标所在到第一行的所有数据</td></tr><tr><td align="left">dG</td><td>删除光标所在到最后一行的所有数据</td></tr><tr><td align="left">d$</td><td>删除游标所在处，到该行的最后一个字符</td></tr><tr><td align="left">d0</td><td>那个是数字的 0 ，删除游标所在处，到该行的最前面一个字符</td></tr><tr><td align="left">yy</td><td>复制游标所在的那一行(常用)</td></tr><tr><td align="left">nyy</td><td>n 为数字。复制光标所在的向下 n 行，例如 20yy 则是复制 20 行(常用)</td></tr><tr><td align="left">y1G</td><td>复制游标所在行到第一行的所有数据</td></tr><tr><td align="left">yG</td><td>复制游标所在行到最后一行的所有数据</td></tr><tr><td align="left">y0</td><td>复制光标所在的那个字符到该行行首的所有数据</td></tr><tr><td align="left">y$</td><td>复制光标所在的那个字符到该行行尾的所有数据</td></tr><tr><td align="left">p, P</td><td>p 为将已复制的数据在光标下一行贴上，P 则为贴在游标上一行！ 举例来说，我目前光标在第 20 行，且已经复制了 10 行数据。则按下 p 后， 那 10 行数据会贴在原本的 20 行之后，亦即由 21 行开始贴。但如果是按下 P 呢？ 那么原本的第 20 行会被推到变成 30 行。 (常用)</td></tr><tr><td align="left">J</td><td>将光标所在行与下一行的数据结合成同一行</td></tr><tr><td align="left">c</td><td>重复删除多个数据，例如向下删除 10 行，[ 10cj ]</td></tr><tr><td align="left">u</td><td>复原前一个动作。(常用)</td></tr><tr><td align="left">[Ctrl]+r</td><td>重做上一个动作。(常用)</td></tr><tr><td align="left">这个 u 与 [Ctrl]+r 是很常用的指令！一个是复原，另一个则是重做一次～ 利用这两个功能按键，你的编辑，嘿嘿！很快乐的啦！</td><td></td></tr><tr><td align="left">.</td><td>不要怀疑！这就是小数点！意思是重复前一个动作的意思。 如果你想要重复删除、重复贴上等等动作，按下小数点『.』就好了！ (常用)</td></tr></tbody></table><h3 id="第二部分：一般模式切换到编辑模式的可用的按钮说明"><a href="#第二部分：一般模式切换到编辑模式的可用的按钮说明" class="headerlink" title="第二部分：一般模式切换到编辑模式的可用的按钮说明"></a>第二部分：一般模式切换到编辑模式的可用的按钮说明</h3><table><thead><tr><th align="left">进入输入或取代的编辑模式</th><th></th></tr></thead><tbody><tr><td align="left">i, I</td><td>进入输入模式(Insert mode)： i 为『从目前光标所在处输入』， I 为『在目前所在行的第一个非空格符处开始输入』。 (常用)</td></tr><tr><td align="left">a, A</td><td>进入输入模式(Insert mode)： a 为『从目前光标所在的下一个字符处开始输入』， A 为『从光标所在行的最后一个字符处开始输入』。(常用)</td></tr><tr><td align="left">o, O</td><td>进入输入模式(Insert mode)： 这是英文字母 o 的大小写。o 为在目前光标所在的下一行处输入新的一行； O 为在目前光标所在的上一行处输入新的一行！(常用)</td></tr><tr><td align="left">r, R</td><td>进入取代模式(Replace mode)： r 只会取代光标所在的那一个字符一次；R会一直取代光标所在的文字，直到按下 ESC 为止；(常用)</td></tr><tr><td align="left">上面这些按键中，在 vi 画面的左下角处会出现『–INSERT–』或『–REPLACE–』的字样。 由名称就知道该动作了吧！！特别注意的是，我们上面也提过了，你想要在档案里面输入字符时， 一定要在左下角处看到 INSERT 或 REPLACE 才能输入喔！</td><td></td></tr><tr><td align="left">[Esc]</td><td>退出编辑模式，回到一般模式中(常用)</td></tr></tbody></table><h3 id="第三部分：一般模式切换到指令行模式的可用的按钮说明"><a href="#第三部分：一般模式切换到指令行模式的可用的按钮说明" class="headerlink" title="第三部分：一般模式切换到指令行模式的可用的按钮说明"></a>第三部分：一般模式切换到指令行模式的可用的按钮说明</h3><table><thead><tr><th align="left">指令行的储存、离开等指令</th><th></th></tr></thead><tbody><tr><td align="left">:w</td><td>将编辑的数据写入硬盘档案中(常用)</td></tr><tr><td align="left">:w!</td><td>若文件属性为『只读』时，强制写入该档案。不过，到底能不能写入， 还是跟你对该档案的档案权限有关</td></tr><tr><td align="left">:q</td><td>离开 vi (常用)</td></tr><tr><td align="left">:q!</td><td>若曾修改过档案，又不想储存，使用 ! 为强制离开不储存档案。</td></tr><tr><td align="left">注意一下啊，那个惊叹号 (!) 在 vi 当中，常常具有『强制』的意思～</td><td></td></tr><tr><td align="left">:wq</td><td>储存后离开，若为 :wq! 则为强制储存后离开 (常用)</td></tr><tr><td align="left">ZZ</td><td>这是大写的 Z 喔！如果修改过，保存当前文件，然后退出！效果等同于(保存并退出)</td></tr><tr><td align="left">ZQ</td><td>不保存，强制退出。效果等同于 **:q!**。</td></tr><tr><td align="left">:w [filename]</td><td>将编辑的数据储存成另一个档案（类似另存新档）</td></tr><tr><td align="left">:r [filename]</td><td>在编辑的数据中，读入另一个档案的数据。亦即将 『filename』 这个档案内容加到游标所在行后面</td></tr><tr><td align="left">:n1,n2 w [filename]</td><td>将 n1 到 n2 的内容储存成 filename 这个档案。</td></tr><tr><td align="left">:! command</td><td>暂时离开 vi 到指令行模式下执行 command 的显示结果！例如 『:! ls /home』即可在 vi 当中察看 /home 底下以 ls 输出的档案信息！</td></tr><tr><td align="left">vim 环境的变更</td><td></td></tr><tr><td align="left">:set nu</td><td>显示行号，设定之后，会在每一行的前缀显示该行的行号</td></tr><tr><td align="left">:set nonu</td><td>与 set nu 相反，为取消行号！</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> Linux基础 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Linux基础Part2</title>
      <link href="/2021/03/Linux%E5%9F%BA%E7%A1%80Part2/"/>
      <url>/2021/03/Linux%E5%9F%BA%E7%A1%80Part2/</url>
      
        <content type="html"><![CDATA[<h1 id="Linux基础Part2——基本命令"><a href="#Linux基础Part2——基本命令" class="headerlink" title="Linux基础Part2——基本命令"></a>Linux基础Part2——基本命令</h1><p>[TOC]</p><h2 id="查看帮助"><a href="#查看帮助" class="headerlink" title="查看帮助"></a>查看帮助</h2><h3 id="help"><a href="#help" class="headerlink" title="help"></a>help</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">命令 --<span class="built_in">help</span></span><br></pre></td></tr></table></figure><h3 id="man"><a href="#man" class="headerlink" title="man"></a>man</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">man 命令</span><br></pre></td></tr></table></figure><ul><li>空格/→：下一页</li><li>回车/↓：下一行</li><li>b/←：上一页</li><li>f/↑：上一行</li><li>q：退出</li></ul><h2 id="目录管理"><a href="#目录管理" class="headerlink" title="目录管理"></a>目录管理</h2><h3 id="处理目录常用命令"><a href="#处理目录常用命令" class="headerlink" title="处理目录常用命令"></a>处理目录常用命令</h3><ul><li>ls: 列出目录</li><li>cd：切换目录</li><li>pwd：显示目前的目录</li><li>mkdir：创建一个新的目录</li><li>rmdir：删除一个空的目录</li><li>cp: 复制文件或目录</li><li>rm: 移除文件或目录</li><li>mv: 移动文件与目录，或修改文件与目录的名称</li></ul><h3 id="ls-列出目录"><a href="#ls-列出目录" class="headerlink" title="ls 列出目录"></a>ls 列出目录</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls [ -al ] [ 目录名称 ]</span><br></pre></td></tr></table></figure><ul><li>-a 列出全部文件，包括隐藏文件（开头为 . 的文件）</li><li>-l 列出长数据串，包括文件的属性和权限，不包括隐藏文件</li></ul><h3 id="cd-切换目录"><a href="#cd-切换目录" class="headerlink" title="cd 切换目录"></a>cd 切换目录</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> [ 相对路径或绝对路径 ]</span><br></pre></td></tr></table></figure><ul><li>绝对路径：由 根目录<code>/</code> 写起。</li><li>相对路径：由 父级目录<code>../</code> 或者 当前目录(可省略)<code>./</code> 写起。</li></ul><h3 id="pwd-显示当前目录"><a href="#pwd-显示当前目录" class="headerlink" title="pwd 显示当前目录"></a>pwd 显示当前目录</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">pwd</span> [ -P ]</span><br></pre></td></tr></table></figure><ul><li>-P 显示出真实路径，而非使用连接(link)路径。</li></ul><h3 id="mkdir-创建目录"><a href="#mkdir-创建目录" class="headerlink" title="mkdir 创建目录"></a>mkdir 创建目录</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir  [ -mp ] 目录名称</span><br></pre></td></tr></table></figure><ul><li>-m ：配置文件的权限</li><li>-p ：递归创建多级目录</li></ul><h3 id="rmdir-删除目录"><a href="#rmdir-删除目录" class="headerlink" title="rmdir 删除目录"></a>rmdir 删除目录</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rmdir [ -p ] 目录名称</span><br></pre></td></tr></table></figure><ul><li>-p ：递归删除上一级空白目录</li></ul><p>rmdir只能删除空白目录，rm删除非空目录。</p><h3 id="cp-复制文件-目录"><a href="#cp-复制文件-目录" class="headerlink" title="cp 复制文件/目录"></a>cp 复制文件/目录</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp [ -adfilprsu ] 来源(<span class="built_in">source</span>) [ source1 source2 source3 ] 目标(destination)</span><br></pre></td></tr></table></figure><ul><li>-a：等效于 -pdr </li><li>-p：连同文件的属性一起复制过去，而非使用默认属性</li><li>-d：若来源档为连结档的属性(link file)，则复制连结档属性而非文件本身</li><li>-r：多级目录的递归复制</li><li>-f：为强制(force)的意思，若目标文件已经存在且无法开启，则移除后再尝试一次</li><li>-i：若目标档(destination)已经存在时，在覆盖时会先询问动作的进行</li><li>-l：进行硬式连结(hard link)的连结档创建，而非复制文件本身</li><li>-s：复制成为符号连结档 (symbolic link)，即『捷径』文件</li><li>-u：若 destination 比 source 旧才升级 destination ！</li></ul><h3 id="rm-移除文件-目录"><a href="#rm-移除文件-目录" class="headerlink" title="rm 移除文件/目录"></a>rm 移除文件/目录</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rm [ -fir ] 文件/目录</span><br></pre></td></tr></table></figure><p>选项与参数：</p><ul><li>-f ：(force)忽略不存在的文件，不会出现警告信息，强制删除</li><li>-i ：互动模式，在删除前会询问使用者是否删除</li><li>-r ：递归删除目录</li></ul><h3 id="mv-移动文件-目录，或修改名称"><a href="#mv-移动文件-目录，或修改名称" class="headerlink" title="mv 移动文件/目录，或修改名称"></a>mv 移动文件/目录，或修改名称</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mv [ -fiu ] <span class="built_in">source</span> [ source2 source3 ] destination</span><br></pre></td></tr></table></figure><p>选项与参数：</p><ul><li>-f ：强制移动。若存在，则直接替换</li><li>-i ：若目标文件 (destination) 已经存在时，询问是否覆盖</li><li>-u ：若存在，则保留最后更新时间最新的文件</li></ul><h3 id="touch-创建文件"><a href="#touch-创建文件" class="headerlink" title="touch 创建文件"></a>touch 创建文件</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">touch 文件名1 文件名2</span><br></pre></td></tr></table></figure><p>可以一次创建多个文件</p><p>可以随意指定文件类型</p><h3 id="gt-输出重定向-和-gt-gt-追加"><a href="#gt-输出重定向-和-gt-gt-追加" class="headerlink" title="&gt;输出重定向 和 &gt;&gt;追加"></a>&gt;输出重定向 和 &gt;&gt;追加</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ls -l&gt;文件  <span class="comment"># 列表内容覆盖写入目标文件夹</span></span><br><span class="line">ls -al&gt;&gt;文件   <span class="comment"># 列表内容追加到文件末尾</span></span><br><span class="line">cat 文件1&gt;文件2  <span class="comment"># 用文件1覆盖文件2</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;内容&quot;</span>&gt;&gt;文件  <span class="comment"># 将内容追加到文件末尾</span></span><br></pre></td></tr></table></figure><p><code>&gt;</code>, <code>&gt;&gt;</code>左右可空格也可不空格</p><h2 id="基本属性"><a href="#基本属性" class="headerlink" title="基本属性"></a>基本属性</h2><p>Linux系统是一种典型的多用户系统，不同的用户处于不同的地位，拥有不同的权限。为了保护系统的安全性，Linux系统对不同的用户访问同一文件（包括目录文件）的权限做了不同的规定。</p><blockquote><p>每个文件都有自己的所有者、所有组。</p><p>对于这个文件的属主(所有者/创建者)、属组(所有组)、其他用户(除了属主和属组)，有不同的权限。</p><p>一个文件夹要有x的权限，用户才能进入这个目录；并且要有r的权限，才能查看；只有w的权限，才能修改文件夹。</p></blockquote><h3 id="权限"><a href="#权限" class="headerlink" title="权限"></a>权限</h3><p>使用<code>ll</code>或者<code>ls –l</code>来显示一个文件的属性以及文件所属的用户和组</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-1-14-centos /]<span class="comment"># ls -ll</span></span><br><span class="line">total 64</span><br><span class="line">lrwxrwxrwx.   1 root root     7 Mar  7  2019 bin -&gt; usr/bin</span><br><span class="line">dr-xr-xr-x.   5 root root  4096 Mar  6 19:50 boot</span><br><span class="line">drwxr-xr-x    2 root root  4096 Nov  5  2019 data</span><br><span class="line">drwxr-xr-x   20 root root  3020 Mar  6 19:49 dev</span><br><span class="line">drwxr-xr-x.  90 root root  4096 Mar  6 19:50 etc</span><br><span class="line">drwxr-xr-x.   2 root root  4096 Apr 11  2018 home</span><br><span class="line">lrwxrwxrwx.   1 root root     7 Mar  7  2019 lib -&gt; usr/lib</span><br><span class="line">lrwxrwxrwx.   1 root root     9 Mar  7  2019 lib64 -&gt; usr/lib64</span><br><span class="line">drwx------.   2 root root 16384 Mar  7  2019 lost+found</span><br><span class="line">drwxr-xr-x.   2 root root  4096 Apr 11  2018 media</span><br><span class="line">drwxr-xr-x.   2 root root  4096 Apr 11  2018 mnt</span><br><span class="line">drwxr-xr-x.   4 root root  4096 Aug  5  2020 opt</span><br><span class="line">dr-xr-xr-x  104 root root     0 Mar  6 19:49 proc</span><br><span class="line">dr-xr-x---.   7 root root  4096 Mar 10 19:45 root</span><br><span class="line">drwxr-xr-x   25 root root   900 Mar  8 16:10 run</span><br><span class="line">lrwxrwxrwx.   1 root root     8 Mar  7  2019 sbin -&gt; usr/sbin</span><br><span class="line">drwxr-xr-x.   2 root root  4096 Apr 11  2018 srv</span><br><span class="line">dr-xr-xr-x   13 root root     0 Mar  9 22:52 sys</span><br><span class="line">drwxrwxrwt.   9 root root  4096 Mar 10 19:46 tmp</span><br><span class="line">drwxr-xr-x.  13 root root  4096 Mar  7  2019 usr</span><br><span class="line">drwxr-xr-x.  19 root root  4096 Apr 22  2020 var</span><br><span class="line"><span class="comment"># 权限   文件个数 属主 属组   大小 修改日期 时间 文件名</span></span><br></pre></td></tr></table></figure><p>第1个字符代表这个文件的类型(目录、文件或链接文件等)：</p><ul><li>d：表示目录</li><li>-：表示文件</li><li>l：档 (link file)</li><li>b：件里面的可供储存的接口设备 ( 可随机存取装置 )</li><li>c：件里面的串行端口设备，例如键盘、鼠标 ( 一次性读取装置 )</li></ul><p>第2-10个字符中，以三个为一组，且均为『rwx』 的三个参数的组合。</p><ul><li>r：代表可读(read)</li><li>w：代表可写(write)</li><li>x：代表可执行(execute)</li><li>-：代表无权限</li></ul><p><img src="/2021/03/Linux%E5%9F%BA%E7%A1%80Part2/363003_1227493859FdXT.png" alt="363003_1227493859FdXT"></p><h3 id="属主和属组"><a href="#属主和属组" class="headerlink" title="属主和属组"></a>属主和属组</h3><p>对于文件来说，它都有一个特定的所有者，也就是对该文件具有所有权的用户。</p><p>同时，在Linux系统中，用户是按组分类的，一个用户属于一个或多个组。</p><p>文件所有者以外的用户又可以分为文件所有者的同组用户和其他用户。</p><p>因此，Linux系统按文件所有者、文件所有者同组用户和其他用户来规定了不同的文件访问权限。</p><p>对于 root 用户来说，一般情况下，文件的权限对其不起作用。</p><h3 id="数字修改文件属性"><a href="#数字修改文件属性" class="headerlink" title="数字修改文件属性"></a>数字修改文件属性</h3><p><strong>1、chgrp：更改文件属组</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chgrp [ -R ] 属组名 文件名</span><br></pre></td></tr></table></figure><ul><li>-R：递归更改文件属组，就是在更改某个目录文件的属组时，如果加上-R的参数，那么该目录下的所有文件的属组都会更改。</li></ul><p><strong>2、chown：更改文件属主，也可以同时更改文件属组</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">chown [ –R ] 属主名 文件名</span><br><span class="line">chown [ -R ] 属主名:属组名 文件名</span><br></pre></td></tr></table></figure><p><strong>3、chmod：更改文件9个属性</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod [ -R ] xyz 文件/目录</span><br></pre></td></tr></table></figure><ul><li>-R：连同目录下的所有文件都进行递归变更</li></ul><p>Linux文件的基本权限有九个，分别是owner/group/others三种身份各有自己的read/write/execute权限。</p><p>各权限的分数对照：</p><ul><li>r = 4</li><li>w = 2</li><li>x = 1</li></ul><p>举例：</p><ul><li>可读可写可执行：rwx = 4+2+1 = 7</li><li>可读可写不可执行：rw- = 4+2+0 = 6</li><li>不可读/写/执行：— = 0+0+0 = 0</li></ul><h3 id="符号修改文件属性"><a href="#符号修改文件属性" class="headerlink" title="符号修改文件属性"></a>符号修改文件属性</h3><p>使用 u、g、o、a 代表 user用户、group组、others其他、all全部 身份</p><p>使用 r、w、x 代表读写权限</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod [ u/g/o/a ] [ +(加入) -(除去) =(设定) ] [ r w x ] 文件或目录</span><br></pre></td></tr></table></figure><p>demo：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#  touch test1    // 创建 test1 文件</span></span><br><span class="line"><span class="comment"># ls -al test1    // 查看 test1 默认权限</span></span><br><span class="line">-rw-r--r-- 1 root root 0 Nov 15 10:32 test1</span><br><span class="line"><span class="comment"># chmod u=rwx,g=rx,o=r  test1    // 修改 test1 权限</span></span><br><span class="line"><span class="comment"># ls -al test1</span></span><br><span class="line">-rwxr-xr-- 1 root root 0 Nov 15 10:32 test1</span><br><span class="line"><span class="comment">#  chmod  a-x test1</span></span><br><span class="line"><span class="comment"># ls -al test1</span></span><br><span class="line">-rw-r--r-- 1 root root 0 Nov 15 10:32 test1</span><br></pre></td></tr></table></figure><h2 id="内容查看"><a href="#内容查看" class="headerlink" title="内容查看"></a>内容查看</h2><h3 id="查看文件内容"><a href="#查看文件内容" class="headerlink" title="查看文件内容"></a>查看文件内容</h3><ul><li>cat 由第一行开始显示文件内容</li><li>tac 从最后一行开始显示</li><li>nl  显示的时候同时输出行号</li><li>more 一页一页的显示文件内容</li><li>less 与 more 类似，但是比 more 更好的是，他可以往前翻页！</li><li>head 只看开头几行</li><li>tail 只看末尾几行</li></ul><h3 id="cat"><a href="#cat" class="headerlink" title="cat"></a>cat</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat [ -AbEnTv ]</span><br></pre></td></tr></table></figure><ul><li>-A：等价于 -vET ，可列出一些特殊字符而不是空白而已</li><li>-b：列出行号，仅针对非空白行做行号显示，空白行不标行号！</li><li>-E：将结尾的断行字节 $ 显示出来；</li><li>-n：列印出行号，连同空白行也会有行号，与 -b 的选项不同；</li><li>-T：将 [tab] 按键以 ^I 显示出来；</li><li>-v：列出一些看不出来的特殊字符</li></ul><p>demo：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-1-14-centos network-scripts]<span class="comment"># cat ifcfg-eth0 </span></span><br><span class="line"><span class="comment"># Created by cloud-init on instance boot automatically, do not edit.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line">BOOTPROTO=dhcp</span><br><span class="line">DEVICE=eth0</span><br><span class="line">HWADDR=52:54:00:23:6f:89</span><br><span class="line">ONBOOT=yes</span><br><span class="line">PERSISTENT_DHCLIENT=yes</span><br><span class="line">TYPE=Ethernet</span><br><span class="line">USERCTL=no</span><br></pre></td></tr></table></figure><h3 id="tac"><a href="#tac" class="headerlink" title="tac"></a>tac</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tac [ -AbEnTv ]</span><br></pre></td></tr></table></figure><p>demo：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-1-14-centos network-scripts]<span class="comment"># tac ifcfg-eth0 </span></span><br><span class="line">USERCTL=no</span><br><span class="line">TYPE=Ethernet</span><br><span class="line">PERSISTENT_DHCLIENT=yes</span><br><span class="line">ONBOOT=yes</span><br><span class="line">HWADDR=52:54:00:23:6f:89</span><br><span class="line">DEVICE=eth0</span><br><span class="line">BOOTPROTO=dhcp</span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Created by cloud-init on instance boot automatically, do not edit.</span></span><br></pre></td></tr></table></figure><h3 id="nl"><a href="#nl" class="headerlink" title="nl"></a>nl</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nl [ -bnw ] 文件</span><br></pre></td></tr></table></figure><ul><li>-b：指定行号指定的方式，主要有两种：-b a ：表示不论是否为空行，也同样列出行号(类似 cat -n)；-b t ：如果有空行，空的那一行不要列出行号(默认值)；</li><li>-n：列出行号表示的方法，主要有三种：-n ln ：行号在荧幕的最左方显示；-n rn ：行号在自己栏位的最右方显示，且不加 0 ；-n rz ：行号在自己栏位的最右方显示，且加 0 ；</li><li>-w：行号栏位的占用的位数。</li></ul><p>demo：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-1-14-centos network-scripts]<span class="comment"># nl ifcfg-eth0 </span></span><br><span class="line">     1<span class="comment"># Created by cloud-init on instance boot automatically, do not edit.</span></span><br><span class="line">     2<span class="comment">#</span></span><br><span class="line">     3BOOTPROTO=dhcp</span><br><span class="line">     4DEVICE=eth0</span><br><span class="line">     5HWADDR=52:54:00:23:6f:89</span><br><span class="line">     6ONBOOT=yes</span><br><span class="line">     7PERSISTENT_DHCLIENT=yes</span><br><span class="line">     8TYPE=Ethernet</span><br><span class="line">     9USERCTL=no</span><br></pre></td></tr></table></figure><h3 id="more"><a href="#more" class="headerlink" title="more"></a>more</h3><ul><li>空白键 (space)：代表向下翻一页；</li><li>Enter：代表向下翻『一行』；</li><li>/字串：代表在这个显示的内容当中，向下搜寻『字串』这个关键字；</li><li>:f：立刻显示出档名以及目前显示的行数；</li><li>q：代表立刻离开 more ，不再显示该文件内容。</li><li>b 或 [ctrl]-b：代表往回翻页，不过这动作只对文件有用，对管线无用。</li></ul><h3 id="less"><a href="#less" class="headerlink" title="less"></a>less</h3><ul><li>空白键：向下翻动一页；</li><li>[pagedown]↑：向下翻动一页；</li><li>[pageup]↓：向上翻动一页；</li><li>/字串：向下搜寻『字串』的功能；</li><li>?字串：向上搜寻『字串』的功能；</li><li>n：重复前一个搜寻 (与 / 或 ? 有关！)</li><li>N：反向的重复前一个搜寻 (与 / 或 ? 有关！)</li><li>q：离开 less 这个程序；</li></ul><h3 id="echo"><a href="#echo" class="headerlink" title="echo"></a>echo</h3><p>输出内容到控制台</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> [ 内容 ]</span><br></pre></td></tr></table></figure><p>demo：输出环境变量</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-1-14-centos ~]<span class="comment"># echo $PATH</span></span><br><span class="line">/usr/<span class="built_in">local</span>/sbin:/usr/<span class="built_in">local</span>/bin:/usr/sbin:/usr/bin:/root/bin</span><br></pre></td></tr></table></figure><h3 id="head"><a href="#head" class="headerlink" title="head"></a>head</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">head [ -n number ] 文件</span><br></pre></td></tr></table></figure><ul><li>-n：后面接数字，表示显示几行，默认为10行</li></ul><h3 id="tail"><a href="#tail" class="headerlink" title="tail"></a>tail</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tail [ -n number ] 文件</span><br></pre></td></tr></table></figure><ul><li>-n ：后面接数字，表示显示几行，默认为10行</li></ul><h2 id="日期指令"><a href="#日期指令" class="headerlink" title="日期指令"></a>日期指令</h2><h3 id="date"><a href="#date" class="headerlink" title="date"></a>date</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">date</span><br><span class="line">date +%Y</span><br><span class="line">date +<span class="string">&quot;%Y-%m-%d %H:%M:%S&quot;</span></span><br><span class="line">date -s <span class="string">&quot;2021-03-12 15:06:35&quot;</span></span><br></pre></td></tr></table></figure><ul><li>-s 设置当前系统时间</li></ul><p><code>+&quot;%Y-%m-%d %H:%M:%S&quot;</code>或<code>&quot;+%Y-%m-%d %H:%M:%S&quot;</code>是等效的，但必须要有一个 <code>+</code> ，多出来的+将会被当做字符输出。</p><p>输出单个数值不需要 <code>&quot;&quot;</code>。</p><h3 id="cal"><a href="#cal" class="headerlink" title="cal"></a>cal</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cal [ 选项 ]  <span class="comment"># 默认显示当前月份</span></span><br><span class="line">cal 2021  <span class="comment"># 显示2021年整年日历</span></span><br></pre></td></tr></table></figure><h2 id="查找指令"><a href="#查找指令" class="headerlink" title="查找指令"></a>查找指令</h2><h3 id="find"><a href="#find" class="headerlink" title="find"></a>find</h3><p>find 指令将从指定目录向下递归地遍历其各个子目录，将满足条件的文件或者目录显示在终端。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find [ 搜索范围 ] [ 选项 ]</span><br></pre></td></tr></table></figure><ul><li>-name 按指定文件名查找 <code>-name 文件名</code></li><li>-user 查找属于指定用户的所有文件 <code>-user 用户名</code></li><li>-size 查找指定大小的文件(+n 大于 -n 小于 n 等于) <code>-size +20M</code></li></ul><p>demo：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find / *.txt  <span class="comment"># 查找所有.txt文件</span></span><br></pre></td></tr></table></figure><h3 id="locate"><a href="#locate" class="headerlink" title="locate"></a>locate</h3><p>locate 指令无需遍历整个文件系统，利用事先建立的系统中所有文件名称及路径的 locate 数据库，实现快速定位给定的文件路径。</p><p>第一次运行前，必须使用 <code>updatedb</code> 指令创建 locate 数据库，同时也需要定期更新 locate 时刻，以保证查找准确性。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">locate 文件名</span><br></pre></td></tr></table></figure><h3 id="grep和管道符号"><a href="#grep和管道符号" class="headerlink" title="grep和管道符号|"></a>grep和管道符号|</h3><p>grep 过滤查找 。</p><p>管道符 <code>|</code> 表示将前一个命令的处理结果输出传递给后面的命令处理。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep [ 选项 ] 内容 文件</span><br></pre></td></tr></table></figure><ul><li>-n 显示匹配行和行号</li><li>-i 忽略大小写</li></ul><p>demo：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-1-14-centos ~]<span class="comment"># grep -n main hello.java </span></span><br><span class="line">2:public static void main(String args[])&#123;</span><br><span class="line">[root@VM-1-14-centos ~]<span class="comment"># cat hello.java | grep -n main</span></span><br><span class="line">2:public static void main(String args[])&#123;</span><br></pre></td></tr></table></figure><h2 id="压缩与解压"><a href="#压缩与解压" class="headerlink" title="压缩与解压"></a>压缩与解压</h2><h3 id="gzip-gunzip"><a href="#gzip-gunzip" class="headerlink" title="gzip/gunzip"></a>gzip/gunzip</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gzip 文件名  <span class="comment"># 将文件压缩成*.gz文件</span></span><br><span class="line">gunzip 文件名  <span class="comment"># 解压*.gz文件</span></span><br></pre></td></tr></table></figure><p>使用 <code>gzip/gunzip</code> 将不会保留源文件。</p><h3 id="zip-unzip"><a href="#zip-unzip" class="headerlink" title="zip/unzip"></a>zip/unzip</h3><p>经常使用于项目打包发布中。</p><p>会保留源文件。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">zip [ -r ] 文件名.zip 需要压缩的目录或文件</span><br><span class="line">unzip [ -d ] 文件名.zip</span><br></pre></td></tr></table></figure><ul><li>-r：递归压缩</li><li>-d &lt;目录&gt; ：指定解压后文件的存放目录</li></ul><h3 id="tar"><a href="#tar" class="headerlink" title="tar"></a>tar</h3><p>tar是打包指令，即可以压缩也可以解压，最后打包后的文件是 .tar.gz 。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar[ 选项 ] XXX.tar.gz 打包的内容</span><br></pre></td></tr></table></figure><ul><li>-c：产生.tar打包文件</li><li>-v：显示详细信息</li><li>-f：指定压缩后的文件名</li><li>-z：打包同时压缩</li><li>-x：解包.tar文件</li><li>-t：列出档案文件的内容，查看已经备份了哪些文件</li></ul><p>对于解压的选项，f必须放最后，其他的位置任意，但是建议按照规范</p><p>解压到指定某个目录必须加上-C选项，不然会出错。</p><p>demo：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">tar -zcvf txt.tar.gz t1.txt t2.txt  <span class="comment"># 这里将t1.txt和t2.txt打包压缩为txt.tar.gz文件</span></span><br><span class="line">tar -zcvf home.tar.gz /home/  <span class="comment"># 将/home/目录打包</span></span><br><span class="line">tar -zxvf num.tar.gz -C ~  <span class="comment"># 这里将num.tar.gz解压到~这个目录下，这个目录必须存在</span></span><br></pre></td></tr></table></figure><h2 id="软-硬链接"><a href="#软-硬链接" class="headerlink" title="软/硬链接"></a>软/硬链接</h2><p>Linux 链接分两种，一种被称为硬链接（Hard Link），另一种被称为符号链接（Symbolic Link）。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ln [ -s ] 源文件 目标文件</span><br></pre></td></tr></table></figure><h3 id="硬连接"><a href="#硬连接" class="headerlink" title="硬连接"></a>硬连接</h3><ul><li>硬连接指通过索引节点号(Inode Index)来进行连接。即可以有两个文件名A和B指向同一个索引节点号，一个文件拥有多个有效路径名，A和B对文件系统来说是完全平等的。</li><li>删除其中任何一个都不会影响另外一个的访问，只有两个都被删除才算是真正删除了文件数据。</li><li>通常用于备份以防误删。</li></ul><h3 id="软连接"><a href="#软连接" class="headerlink" title="软连接"></a>软连接</h3><ul><li>符号连接（Symbolic Link），也叫软连接。</li><li>软链接文件实际是一个特殊的文件。内容的是另一文件的位置信息，相当于快捷方式。</li><li>A 和 B 指向的是两个不同的 inode 节点，即他们本体在磁盘的存储是两个文件。</li><li>但是 A 的数据块中存放的只是 B 的路径名（可以根据这个找到 B 的目录项）。如果 B 被删除了，A 仍然存在（因为两个是不同的文件），但指向的是一个无效的地址。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Linux基础 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Linux基础Part1</title>
      <link href="/2021/03/Linux%E5%9F%BA%E7%A1%80Part1/"/>
      <url>/2021/03/Linux%E5%9F%BA%E7%A1%80Part1/</url>
      
        <content type="html"><![CDATA[<h1 id="Linux基础Part1——概述"><a href="#Linux基础Part1——概述" class="headerlink" title="Linux基础Part1——概述"></a>Linux基础Part1——概述</h1><p>[TOC]</p><h2 id="Linux概述"><a href="#Linux概述" class="headerlink" title="Linux概述"></a>Linux概述</h2><h3 id="起源"><a href="#起源" class="headerlink" title="起源"></a>起源</h3><p>Linux 内核最初只是由芬兰人林纳斯·托瓦兹（Linus Torvalds）在赫尔辛基大学上学时出于个人爱好而编写的。</p><p>Linux 是一套免费使用和自由传播的类 Unix 操作系统，是一个基于 POSIX（可移植操作系统接口） 和 UNIX 的多用户、多任务、支持多线程和多 CPU 的操作系统。</p><p>Linux 能运行主要的 UNIX 工具软件、应用程序和网络协议。它支持 32 位和 64 位硬件。Linux 继承了 Unix 以网络为核心的设计思想，是一个性能稳定的多用户网络操作系统。</p><h3 id="发行版"><a href="#发行版" class="headerlink" title="发行版"></a>发行版</h3><p>Linux 的发行版说简单点就是将 Linux 内核与应用软件做一个打包。</p><p>目前市面上较知名的发行版有：Ubuntu、RedHat、CentOS、Debian、Fedora、SuSE、OpenSUSE、Arch Linux、SolusOS 等。（Kali Linux安全渗透测试）</p><p>Mac无缝兼容Linux指令，mac也同时具备linux的优秀工具。</p><blockquote><p>作为一个优秀的程序员，应当重视安全性！</p></blockquote><h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><p>通常服务器使用 LAMP（Linux + Apache + MySQL + PHP）或 LNMP（Linux + Nginx+ MySQL + PHP）组合。</p><h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><p><a href="https://www.bilibili.com/video/BV187411y7hF?p=3">暂时不详细记录，本人使用服务器</a></p><h3 id="本地虚拟机"><a href="#本地虚拟机" class="headerlink" title="本地虚拟机"></a>本地虚拟机</h3><p>VMware+CentOS</p><p>ctrl+alt: 退出虚拟机</p><h3 id="云端服务器"><a href="#云端服务器" class="headerlink" title="云端服务器"></a>云端服务器</h3><p>CentOS 7.0</p><ol><li><p>服务器就是一个远程电脑</p></li><li><p>访问出错基本都是端口放行问题，包括Linux的防火墙和服务器安全组</p><p>21-ftp；22-ssh；443-https；80-http；8888-39000/40000-宝塔；3306-MySQL；8080-Tomcat；9000-测试；6379/6380-redis</p></li><li><p>安全组开放端口授权对象：0.0.0.0/0（允许所有人访问）</p></li></ol><h2 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h2><h3 id="开机"><a href="#开机" class="headerlink" title="开机"></a>开机</h3><p>开机会启动许多程序。它们在Windows叫做”服务”（service），在Linux就叫做”守护进程”（daemon）。</p><p>用户的登录方式有三种：1.命令行登录；2.ssh登录；3.图形界面登录</p><p>root是最高权限，其下有更多子用户</p><h3 id="关机"><a href="#关机" class="headerlink" title="关机"></a>关机</h3><p>服务器大多数情况不会关机。</p><p>不管是重启系统还是关闭系统，首先要运行 <code>sync</code>命令，把内存中的数据写到磁盘中。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">sync <span class="comment"># 将数据由内存同步到硬盘中。</span></span><br><span class="line"></span><br><span class="line">shutdown <span class="comment"># 关机</span></span><br><span class="line"></span><br><span class="line">shutdown –h 10 <span class="comment"># 这个命令告诉大家，计算机将在10分钟后关机</span></span><br><span class="line"></span><br><span class="line">shutdown –h now <span class="comment"># 立马关机</span></span><br><span class="line"></span><br><span class="line">shutdown –h 20:25 <span class="comment"># 系统会在今天20:25关机</span></span><br><span class="line"></span><br><span class="line">shutdown –h +10 <span class="comment"># 十分钟后关机</span></span><br><span class="line"></span><br><span class="line">shutdown –r now <span class="comment"># 系统立即重启</span></span><br><span class="line"></span><br><span class="line">shutdown –r +10 <span class="comment"># 系统十分钟后重启</span></span><br><span class="line"></span><br><span class="line">reboot <span class="comment"># 重启，等效于 shutdown –r now</span></span><br><span class="line"></span><br><span class="line">halt <span class="comment"># 关机，等效于 shutdown –h now 和 poweroff</span></span><br></pre></td></tr></table></figure><blockquote><p>Linux中，在输入指令过后，没有输出即代表指令执行成功</p></blockquote><h2 id="Linux系统目录结构"><a href="#Linux系统目录结构" class="headerlink" title="Linux系统目录结构"></a>Linux系统目录结构</h2><blockquote><ol><li>一切皆文件</li><li>所有文件都挂载在根目录 <code>/</code> 下</li></ol></blockquote><p><strong>系统启动必须：</strong></p><ul><li><p><strong>/boot：</strong>存放的启动Linux 时使用的内核文件，包括连接文件以及镜像文件。</p></li><li><p><strong>/etc：</strong>存放<strong>所有</strong>的系统需要的<strong>配置文件</strong>和<strong>子目录列表，</strong>更改目录下的文件可能会导致系统不能启动。</p></li><li><p><strong>/lib</strong>：存放基本代码库（比如c++库），其作用类似于Windows里的DLL文件。几乎所有的应用程序都需要用到这些共享库。</p></li><li><p><strong>/sys</strong>： 这是linux2.6内核的一个很大的变化。该目录下安装了2.6内核中新出现的一个文件系统 sysfs 。sysfs文件系统集成了下面3种文件系统的信息：针对进程信息的proc文件系统、针对设备的devfs文件系统以及针对伪终端的devpts文件系统。该文件系统是内核设备树的一个直观反映。当一个内核对象被创建的时候，对应的文件和目录也在内核对象子系统中</p></li></ul><p><strong>指令集合：</strong></p><ul><li><p><strong>/bin：</strong>存放着最常用的程序和指令</p></li><li><p><strong>/sbin：</strong>只有系统管理员能使用的程序和指令。</p></li></ul><p><strong>外部文件管理：</strong></p><ul><li><p><strong>/dev ：</strong>Device(设备)的缩写, 存放的是Linux的外部设备。<strong>注意：</strong>在Linux中访问设备和访问文件的方式是相同的。</p></li><li><p><strong>/media</strong>：类windows的<strong>其他设备，</strong>例如U盘、光驱等等，识别后linux会把设备放到这个目录下。</p></li><li><p><strong>/mnt</strong>：临时挂载别的文件系统的，我们可以将光驱挂载在/mnt/上，然后进入该目录就可以查看光驱里的内容了。</p></li></ul><p><strong>临时文件：</strong></p><ul><li><p><strong>/run</strong>：是一个临时文件系统，存储系统启动以来的信息。当系统重启时，这个目录下的文件应该被删掉或清除。如果你的系统上有 /var/run 目录，应该让它指向 run。</p></li><li><p><strong>/lost+found</strong>：一般情况下为空的，系统非法关机后，这里就存放一些文件。</p></li><li><p><strong>/tmp</strong>：这个目录是用来存放一些临时文件的。比如：安装包。</p></li></ul><p><strong>账户：</strong></p><ul><li><p><strong>/root</strong>：系统管理员的用户主目录。</p></li><li><p><strong>/home</strong>：目录下有各个用户以账号名命名的家目录。用户登录时，会自动进入自己的家目录。</p></li><li><p><strong>/usr</strong>： usr 是 unix shared resources(共享资源) 的缩写，这是一个非常重要的目录。用户的很多应用程序和文件都放在这个目录下，类似于windows下的program files目录。</p></li><li><p><strong>/usr/bin：</strong>系统用户使用的应用程序与指令。</p></li><li><p><strong>/usr/sbin：</strong>超级用户使用的比较高级的管理程序和系统守护程序。</p></li><li><p><strong>/usr/src：</strong>内核源代码默认的放置目录。</p></li></ul><p><strong>运行过程中要用：</strong></p><ul><li><p><strong>/var</strong>：存放经常修改的数据，比如程序运行的日志文件（/var/log 目录下）。</p></li><li><p><strong>/proc</strong>：管理<strong>内存空间！</strong>虚拟的目录，是系统内存的映射，我们可以直接访问这个目录来，获取系统信息。这个目录的内容不在硬盘上而是在内存里，我们也可以直接修改里面的某些文件来做修改。</p></li></ul><p><strong>扩展用的：</strong></p><ul><li><p><strong>/opt</strong>：默认是空的，我们安装额外软件可以放在这个里面。</p></li><li><p><strong>/srv</strong>：存放服务启动后需要提取的数据<strong>（不用服务器就是空）</strong></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Linux基础 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>浙江大学机器学习课程-完结目录</title>
      <link href="/2021/02/%E6%B5%99%E6%B1%9F%E5%A4%A7%E5%AD%A6%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E8%AF%BE%E7%A8%8B-%E5%AE%8C%E7%BB%93%E7%9B%AE%E5%BD%95/"/>
      <url>/2021/02/%E6%B5%99%E6%B1%9F%E5%A4%A7%E5%AD%A6%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E8%AF%BE%E7%A8%8B-%E5%AE%8C%E7%BB%93%E7%9B%AE%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<h1 id="浙江大学机器学习课程-完结目录"><a href="#浙江大学机器学习课程-完结目录" class="headerlink" title="浙江大学机器学习课程-完结目录"></a>浙江大学机器学习课程-完结目录</h1><p>教程视频传送门：<a href="https://www.bilibili.com/video/BV1dJ411B7gh?p=1">浙江大学研究生机器学习课程</a></p><p>对于本人来说是看完一些机器学习入门教程之后的理论补充。这个教程包含大量具体详细的理论推导，有一定难度，但是对于想要熟悉理论的还是比较推荐。</p><p>==本人在以后会把推导不足的部分补全。==</p><table><thead><tr><th align="center"><a href="/2021/02/%E6%B5%99%E6%B1%9F%E5%A4%A7%E5%AD%A6%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E8%AF%BE%E7%A8%8BPart1/">Part1——课程概论</a></th></tr></thead><tbody><tr><td align="center"><strong><a href="/2021/02/%E6%B5%99%E6%B1%9F%E5%A4%A7%E5%AD%A6%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E8%AF%BE%E7%A8%8BPart2/">Part2——支持向量机</a></strong></td></tr><tr><td align="center"><strong><a href="/2021/02/%E6%B5%99%E6%B1%9F%E5%A4%A7%E5%AD%A6%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E8%AF%BE%E7%A8%8BPart3/">Part3——人工神经网络</a></strong></td></tr><tr><td align="center"><strong><a href="/2021/02/%E6%B5%99%E6%B1%9F%E5%A4%A7%E5%AD%A6%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E8%AF%BE%E7%A8%8BPart4/">Part4——深度学习</a></strong></td></tr><tr><td align="center"><strong><a href="/2021/02/%E6%B5%99%E6%B1%9F%E5%A4%A7%E5%AD%A6%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E8%AF%BE%E7%A8%8BPart5/">Part5——强化学习</a></strong></td></tr><tr><td align="center"><strong><a href="/2021/02/%E6%B5%99%E6%B1%9F%E5%A4%A7%E5%AD%A6%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E8%AF%BE%E7%A8%8BPart6/">Part6——传统的机器学习</a></strong></td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 浙江大学机器学习课程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浙江大学机器学习课程Part6</title>
      <link href="/2021/02/%E6%B5%99%E6%B1%9F%E5%A4%A7%E5%AD%A6%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E8%AF%BE%E7%A8%8BPart6/"/>
      <url>/2021/02/%E6%B5%99%E6%B1%9F%E5%A4%A7%E5%AD%A6%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E8%AF%BE%E7%A8%8BPart6/</url>
      
        <content type="html"><![CDATA[<h1 id="浙江大学机器学习课程Part6——传统的机器学习"><a href="#浙江大学机器学习课程Part6——传统的机器学习" class="headerlink" title="浙江大学机器学习课程Part6——传统的机器学习"></a>浙江大学机器学习课程Part6——传统的机器学习</h1><p>[TOC]</p><h2 id="特征选择与特征提取"><a href="#特征选择与特征提取" class="headerlink" title="特征选择与特征提取"></a>特征选择与特征提取</h2><p>特征选择与特征提取(Feature Selection and Extraction)</p><p>特征选择是一个”物理”过程，不会产生新特征；特征提取是一个”化学”过程，会产生新特征。</p><ol><li>特征提取：主成分分析(Principle Component Analysis)</li><li>特征选择：自适应提升(AdaBoost)</li></ol><h2 id="主成分分析"><a href="#主成分分析" class="headerlink" title="主成分分析"></a>主成分分析</h2><h3 id="主成分分析与神经网络"><a href="#主成分分析与神经网络" class="headerlink" title="主成分分析与神经网络"></a>主成分分析与神经网络</h3><p>多层的神经网络，其本质也是一个特征提取器。但是，主成分分析主要目标是减少计算量。</p><p>主成分分析：构造一个A，b使：Y<del>(M*1)</del> = A<del>(M*N)</del> * X<del>(N*1)</del> + b<del>(M*1)</del></p><p>主成分分析可以看成是一个一层的，有m个神经元的神经网络。</p><h3 id="主成分分析的过程"><a href="#主成分分析的过程" class="headerlink" title="主成分分析的过程"></a>主成分分析的过程</h3><p>主成分分析：寻找方差最大的方向，并在该方向投影。在降维的同时保存最大的区分度。</p><p>这里方差最大方向指的是投影之后方差和最大，因为如果投影之后点都汇集在一起的话，那么可以近似成一个点，就区分不出来了。</p><p><a href="https://www.bilibili.com/video/BV1dJ411B7gh?p=38">主成分分析详细推导P38</a></p><ol><li><p>最大化寻找的特征方向上的方差和。</p><p>max： a<del>1</del>∑a<del>1</del>^T^=λ；s.t.：a<del>1</del>*a<del>1</del>^T^=||a<del>1</del>||^2^=1 (a<del>i</del>是A的行向量)</p></li><li><p>寻找下方差和最大化的特征方向，并且需要与刚才的方向正交。</p><p>max： a<del>2</del>∑a<del>2</del>^T^=λ；s.t.：a<del>2</del>*a<del>2</del>^T^=||a<del>2</del>||^2^=1、a<del>1</del>*a<del>2</del>^T^=a<del>2</del>*a<del>1</del>^T^=0</p></li><li><p>a<del>2</del>是∑的特征向量，λ是∑的第二大特征值</p></li><li><p>loop</p></li></ol><h3 id="PCA算法全程"><a href="#PCA算法全程" class="headerlink" title="PCA算法全程"></a>PCA算法全程</h3><ol><li><p>求 ∑=∑<del>i=1</del>^i^(X<del>i</del>-E(x))^T^</p></li><li><p>求∑的特征值并从大到小排序[λ<del>1</del>, λ<del>1</del>, λ<del>2</del>,…, λ<del>M</del>, λ<del>M+1</del>,… ]</p><p>对应特征向量[a<del>1</del>^T^, a<del>2</del>^T^, …, a<del>M</del>^T^, a<del>M+1</del>^T^, …]</p></li><li><p>归一化所有a<del>i</del>，使a<del>i</del>a<del>i</del>^T^=1</p></li><li><p>A=[[–a<del>1</del>–],[–a<del>2</del>–],…,[–a<del>m</del>–]]</p></li><li><p>Y<del>i</del>=A(X<del>i</del>-E(X))</p></li></ol><h3 id="其他算法"><a href="#其他算法" class="headerlink" title="其他算法"></a>其他算法</h3><p>奇异值分解SVD(Singular Value Decomposation)快速求出特征值来完成PCA算法。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>在特征数比较多，样本数又比较少的情况下，采用PCA，效果不会差。</p><h2 id="自适应提升-AdaBoost"><a href="#自适应提升-AdaBoost" class="headerlink" title="自适应提升(AdaBoost)"></a>自适应提升(AdaBoost)</h2><h3 id="特征选择"><a href="#特征选择" class="headerlink" title="特征选择"></a>特征选择</h3><p>从N个特征中选择M个使识别率更高。</p><p>（启发式方法，如模拟退火、基因算法）①递增法②递减法。不常用，因为神经网络已经做了这些事情，相关性不高的连线之间w会变得很小。</p><h3 id="自适应提升"><a href="#自适应提升" class="headerlink" title="自适应提升"></a>自适应提升</h3><p>针对大规模冗余的特征样本时，是一个非常好的算法。</p><p><a href="https://www.bilibili.com/video/BV1dJ411B7gh?p=39&spm_id_from=pageDriver">详细推导P39</a></p><ol><li>初始化采样权值</li><li>用D<del>m</del>采样N个样本（错的样本出现更多，对的样本出现更少），获得弱分类器</li><li>计算加权错误率</li><li>更新权值分布</li><li>-&gt; 2. loop </li><li>最终识别器</li></ol><p>定理：随着M增加，AdaBoost最终分类器在训练集上错误率越来越小。</p><p>AdaBoost过拟合速度不会上升太快。</p><h2 id="概率分类法-重点复习"><a href="#概率分类法-重点复习" class="headerlink" title="概率分类法==重点复习=="></a>概率分类法==重点复习==</h2><p>一定要特别注意先验概率！！！</p><h3 id="朴素贝叶斯"><a href="#朴素贝叶斯" class="headerlink" title="朴素贝叶斯"></a>朴素贝叶斯</h3><p><img src="/2021/02/%E6%B5%99%E6%B1%9F%E5%A4%A7%E5%AD%A6%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E8%AF%BE%E7%A8%8BPart6/image-20210213210453656.png" alt="image-20210213210453656"></p><p>限制条件：</p><ol><li>每个维度都是离散的</li><li>每个维度互相独立</li></ol><p>对于每个P(特征|类别)有：<br>$$<br>P(w|C_j)={count(w,C_j)+1\over{\sum\limits_{w∈V}cout(w,C_j)+|v|}}<br>$$<br>其中，C<del>j</del>指某个类别j，V指特征集合，|v|指特征数。</p><h3 id="高斯概率密度函数"><a href="#高斯概率密度函数" class="headerlink" title="高斯概率密度函数"></a>高斯概率密度函数</h3><p>正态分布（Normal distribution）又名高斯分布（Gaussian distribution）。</p><h4 id="多维高斯分布："><a href="#多维高斯分布：" class="headerlink" title="多维高斯分布："></a>多维高斯分布：</h4><p>$$<br>P(X|C)= {1\over{\sqrt[]{(1π)^d|∑|}}}exp[-{1\over2}(x-μ)^T∑^{-1}(x-μ)]<br>$$</p><p>已知{X<del>i</del>}<del>i={1-N}</del> ，求待求参数：∑(d×d矩阵)、μ(d×1向量)</p><p>构造目标函数（极大似然法Maximum Likedihood）<br>$$<br>E(μ,∑)=\sum\limits_{i=1}^NlnP(X_i|C)<br>$$<br>假设：①所有{X<del>i</del>}<del>i={1-N}</del>独立同分布 undependent and identical distribution ( i.i.d. )；②设定μ<del>1</del>、∑<del>1</del>使出现{X<del>i</del>}<del>i={1-N}</del>概率最大。</p><p>先是概率累乘作为似然函数，取对数方便运算，连乘就变成求和了</p><p><a href="https://www.bilibili.com/video/BV1dJ411B7gh?p=43">详细推导p43</a></p><h3 id="EM算法-Expectation-Maximization"><a href="#EM算法-Expectation-Maximization" class="headerlink" title="EM算法(Expectation-Maximization)"></a>EM算法(Expectation-Maximization)</h3><h4 id="混合高斯模型-Gaussian-Mixture-Model"><a href="#混合高斯模型-Gaussian-Mixture-Model" class="headerlink" title="混合高斯模型(Gaussian Mixture Model)"></a>混合高斯模型(Gaussian Mixture Model)</h4><p>叠加多个高斯分布拟合整个复杂的分布。</p><p>这是一个非凸问题，只能求局部极值，不能求全局极值。</p><p>求局部极值的一种方法，而且只对某一类局部极值问题可解。</p><p>优点：①不需要调任何参数，必定收敛②编程简单③理论优美</p><p>步骤：</p><ol><li>随机化，先假设类别</li><li>E-step 计算第n个样本在k个高斯的概率</li><li>M-step 更新所有N个样本中有多少个属于第k个高斯</li><li>-&gt;2 loop</li></ol><p><a href="https://www.bilibili.com/video/BV1dJ411B7gh?p=45">详细推导p45</a></p><p><a href="https://www.bilibili.com/video/BV1dJ411B7gh?p=48&spm_id_from=pageDriver">EM算法收敛性推导</a></p><h4 id="k-均值聚类-K-means-Clustering"><a href="#k-均值聚类-K-means-Clustering" class="headerlink" title="k-均值聚类(K-means Clustering)"></a>k-均值聚类(K-means Clustering)</h4><ol><li>随机化μ<del>1</del>、…、μ<del>k</del></li><li>E-step 离哪个类近，重新归属于哪一类</li><li>M-step n个样本中有多少个属于第k类，重新分配第k类的均值μ<del>k</del></li><li>-&gt;2 loop</li></ol><h2 id="GMM在说话人识别中的应用"><a href="#GMM在说话人识别中的应用" class="headerlink" title="GMM在说话人识别中的应用"></a>GMM在说话人识别中的应用</h2><ol><li>去除静音(将不说话的低能量片段去除，但保留同为低能量的辅音(使用过零率判别))</li><li>提取的特征：MEL倒谱系数 （Mel-frequency Cepstrum Coefficients, MFCC）</li></ol><p>缺点：对噪声要求严苛，因为加了噪声就相当于改变分布。</p>]]></content>
      
      
      <categories>
          
          <category> 浙江大学机器学习课程 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>浙江大学机器学习课程Part5</title>
      <link href="/2021/02/%E6%B5%99%E6%B1%9F%E5%A4%A7%E5%AD%A6%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E8%AF%BE%E7%A8%8BPart5/"/>
      <url>/2021/02/%E6%B5%99%E6%B1%9F%E5%A4%A7%E5%AD%A6%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E8%AF%BE%E7%A8%8BPart5/</url>
      
        <content type="html"><![CDATA[<h1 id="浙江大学机器学习课程Part5——强化学习"><a href="#浙江大学机器学习课程Part5——强化学习" class="headerlink" title="浙江大学机器学习课程Part5——强化学习"></a>浙江大学机器学习课程Part5——强化学习</h1><p>[TOC]</p><h2 id="增强学习与监督学习的区别"><a href="#增强学习与监督学习的区别" class="headerlink" title="增强学习与监督学习的区别"></a>增强学习与监督学习的区别</h2><ol><li>训练数据中没有标签，只有奖励函数（Reward Function）。</li><li>训练数据不是现成给定，而是由行为（Action）获得。</li><li>现在的行为（Action）不仅影响后续训练数据的获得，也影响奖励函数（Reward Function）的取值。</li><li>训练的目的是构建一个“<strong>状态-&gt;行为</strong>”*(内部状态和外部状态，外部状态不由我们的行为控制)*的函数，其中状态（State）描述了目前内部和外部的环境，在此情况下，要使一个智能体（Agent）在某个特定的状态下，通过这个函数，决定此时应该采取的行为。希望采取这些行为后，最终获得最大化的奖励函数值。</li></ol><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><ol><li>R<del>t</del>：t时刻的奖励函数</li><li>S<del>t</del>：t时刻的状态</li><li>A<del>t</del>：t时刻的行为</li></ol><h2 id="假设"><a href="#假设" class="headerlink" title="假设"></a>假设</h2><ol><li><p>马尔科夫假设：P[S<del>t+1</del>|S<del>t</del>]=P[S<del>t+1</del>|S1,…,S<del>t</del>]</p></li><li><p>下一个时刻的状态只与这一时刻的状态以及这一时刻的行为有关：</p><p>P<del>SS’</del>^a^=P[S<del>t+1</del>=s’|S<del>t</del>=s, A<del>t</del>=a]</p></li><li><p>下一时刻的奖励函数值值域这一时刻的状态以及这一时刻的行为有关：</p><p>P<del>S</del>^a^=E[R<del>t+1</del>|S<del>t</del>=s, A<del>t</del>=a]</p></li></ol><h2 id="Markov-decision-Process-MDP"><a href="#Markov-decision-Process-MDP" class="headerlink" title="Markov decision Process (MDP)"></a>Markov decision Process (MDP)</h2><ol><li>在t=0时候，环境给出一个初始状态 s ~ p(s<del>0</del>)</li><li>循环：<pre><code> -- 智能体选择行为：a~t~ -- 环境采样奖励函数：r~t~ ~ R( . |s~t~, a~t~) -- 环境产生下一个状态：s~t+1~ ~ R( . |s~t~, a~t~) -- 智能体获得奖励函数 r~t~ 和下一个状态 s~t+1~</code></pre></li><li>我们需要学习一个策略（Policy）π^*^(s<del>t</del>,a<del>t</del>)=P(a<del>t</del>|s<del>t</del>)   , 这是一个从状态到行为的映射函数，使得最大化累积的奖励。</li></ol><h2 id="Q-Learning"><a href="#Q-Learning" class="headerlink" title="Q-Learning"></a>Q-Learning</h2><h3 id="数学推导"><a href="#数学推导" class="headerlink" title="数学推导"></a>数学推导</h3><ol><li>增强学习中已经知道的的函数是：P<del>S</del>^a^=E[R<del>t+1</del>|S<del>t</del>=s, A<del>t</del>=a]</li><li>需要学习的函数是：P<del>SS’</del>^a^=P[S<del>t+1</del>=s’|S<del>t</del>=s, A<del>t</del>=a]</li><li>根据一个决策机制（Policy），我们可以获得一条路径：s<del>0</del> -&gt; a<del>0</del> -&gt; r<del>0</del> -&gt; s<del>1</del> -&gt; a<del>1</del> -&gt; r<del>1</del> …</li><li>定义1：估值函数（Value Function）是衡量某个状态最终能获得多少累积奖励的函数：<img src="/2021/02/%E6%B5%99%E6%B1%9F%E5%A4%A7%E5%AD%A6%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E8%AF%BE%E7%A8%8BPart5/image-20210210225702878.png" alt="image-20210210225702878"></li><li>定义2：Q函数是衡量某个状态下采取某个行为后，最终能获得多少累积奖励的函数：<img src="/2021/02/%E6%B5%99%E6%B1%9F%E5%A4%A7%E5%AD%A6%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E8%AF%BE%E7%A8%8BPart5/image-20210210225720116.png" alt="image-20210210225720116"></li><li>在s状态下做出行为a的概率，和这种情况下的奖励，得到估值 V^π^(s)=∑<del>a∈A</del>P(a|s)Q^π^(s,a)</li></ol><h3 id="劣势"><a href="#劣势" class="headerlink" title="劣势"></a>劣势</h3><ol><li>对于状态数和行为数很多时，使Q函数非常复杂，难以收敛。例如：①对一个ATARI游戏，状态数是相邻几帧所有像素的取值组合，这是一个天文数字；②图像方面的应用，状态数是(像素值取值范围数)^(像素个数)</li><li>很多程序，如下棋程序等，REWARD是最后获得（输或赢），不需要对每一个中间步骤都计算REWARD。</li></ol><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol><li><p>目前强化学习的发展状况：在一些特定的任务上达到人的水平或胜过人，但在一些相对复杂的任务上，例如自动驾驶等，和人存在差距。</p></li><li><p>和真人的差距，可能不完全归咎于算法。传感器、机械的物理限制等，也是决定性因素。</p></li><li><p>机器和人的另一差距是：人有一些基本的概念，依据这些概念，人能只需要很少的训练就能学会很多，但机器只有通过大规模数据，才能学会。</p></li><li><p>但是，机器速度快，机器永不疲倦，只要有源源不断的数据，在特定的任务上，机器做得比人好，是可以期待的。</p></li></ol><h2 id="Alpha-Go"><a href="#Alpha-Go" class="headerlink" title="Alpha Go"></a>Alpha Go</h2><p>围棋有必胜策略</p><p><img src="/2021/02/%E6%B5%99%E6%B1%9F%E5%A4%A7%E5%AD%A6%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E8%AF%BE%E7%A8%8BPart5/image-20210210235412124.png" alt="image-20210210235412124"></p><p><a href="https://github.com/Rochester-NRT/RocAlphaGo">Alpha Go 开源地址</a></p><p>每隔一定的轮次，训练过后的网络将和训练之前的网络对抗，已获得更多的样本数据继续训练。</p><p>另外有一个更加简单的深度策略网络(Rollout Policy Network)，牺牲准确率来换取速度，在对局后期通过不断演算，将赢的落子概率增加，输的概率减少。</p><p>蒙特卡洛树搜索 （Monte Carlo Tree Search）：多次模拟未来棋局，然后选择在模拟中选择次数最多的走法。</p><p>同时要采用多样化的步骤来增加随机性。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol><li><p>Reinforcement Learning an introduction. R. S. Sutton and A. G. Barto, 2005</p></li><li><p><a href="http://www0.cs.ucl.ac.uk/staff/d.silver/web/Teaching.html">UCL Course on RL</a></p></li><li><p>例程程序</p><p><a href="http://karpathy.github.io/2016/05/31/rl/?_utm_source=1-2-2">http://karpathy.github.io/2016/05/31/rl/?_utm_source=1-2-2</a><br><a href="https://gym.openai.com/https://github.com/openai/gym">https://gym.openai.com/https://github.com/openai/gym</a></p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 浙江大学机器学习课程 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>浙江大学机器学习课程Part4</title>
      <link href="/2021/02/%E6%B5%99%E6%B1%9F%E5%A4%A7%E5%AD%A6%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E8%AF%BE%E7%A8%8BPart4/"/>
      <url>/2021/02/%E6%B5%99%E6%B1%9F%E5%A4%A7%E5%AD%A6%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E8%AF%BE%E7%A8%8BPart4/</url>
      
        <content type="html"><![CDATA[<h1 id="浙江大学机器学习课程Part4——深度学习"><a href="#浙江大学机器学习课程Part4——深度学习" class="headerlink" title="浙江大学机器学习课程Part4——深度学习"></a>浙江大学机器学习课程Part4——深度学习</h1><p>[TOC]</p><h2 id="多层神经网络的优劣"><a href="#多层神经网络的优劣" class="headerlink" title="多层神经网络的优劣"></a>多层神经网络的优劣</h2><h3 id="多层神经网络的优势"><a href="#多层神经网络的优势" class="headerlink" title="多层神经网络的优势"></a>多层神经网络的优势</h3><ol><li>基本单元简单，多个基本单元可扩展为非常复杂的非线性函数。因此易于构建，同时模型有很强的表达能力。</li><li>训练和测试的计算并行性非常好，有利于在分布式系统上的应用。</li><li>模型构建来源于对人脑的仿生，话题丰富，各种领域的研究人员都有兴趣，都能做贡献。</li></ol><h3 id="多层神经网络的劣势"><a href="#多层神经网络的劣势" class="headerlink" title="多层神经网络的劣势"></a>多层神经网络的劣势</h3><ol><li>数学不漂亮，优化算法只能获得局部极值，算法性能与初始值有关。</li><li>不可解释。训练神经网络获得的参数与实际任务的关联性非常模糊。</li><li>模型可调整的参数很多 （网络层数、每层神经元个数、非线性函数、学习率、优化方法、终止条件等等），使得训练神经网络变成了一门“艺术”。</li><li>如果要训练相对复杂的网络，需要大量的训练样本。</li></ol><h2 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h2><ol><li>Mnist：手写数字数据库（LeCun 在1998年创造）</li><li>ImageNet：（Fei-fei Li等 2007年创造）</li></ol><h2 id="发展历史"><a href="#发展历史" class="headerlink" title="发展历史"></a>发展历史</h2><h3 id="现状"><a href="#现状" class="headerlink" title="现状"></a>现状</h3><p>神经网络是目前处理大数据最优的算法。</p><p>模拟退火和遗传算法还处于沉寂期。</p><h3 id="转机"><a href="#转机" class="headerlink" title="转机"></a>转机</h3><p>2006年是深度学习的起始年，Hinton在SCIENCE上发文，提出一种叫做自动编码机（Auto-encoder）的方法，部分解决了神经网络参数初始化的问题。</p><p>但是目前为止，自动编码机并没有什么用。</p><h2 id="卷积神经网络-CNN"><a href="#卷积神经网络-CNN" class="headerlink" title="卷积神经网络(CNN)"></a>卷积神经网络(CNN)</h2><h3 id="发展"><a href="#发展" class="headerlink" title="发展"></a>发展</h3><p>是深度学习神经网络流行起来最大的因素。</p><p>由手工设计卷积核变成自动学习卷积核。</p><h3 id="如何卷积"><a href="#如何卷积" class="headerlink" title="如何卷积"></a>如何卷积</h3><blockquote><p>一个讲解比较清晰的视频：<a href="https://www.bilibili.com/video/BV1JX4y1K7Dr">什么是卷积？</a></p></blockquote><p>详细图解原理在另一份笔记中，不重复记述：<a href="/2021/01/PyTorch%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%AE%9E%E8%B7%B5Part10/">PyTorch深度学习实践Part10</a></p><p><img src="/2021/02/%E6%B5%99%E6%B1%9F%E5%A4%A7%E5%AD%A6%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E8%AF%BE%E7%A8%8BPart4/image-20210210160012660.png" alt="image-20210210160012660"></p><p>卷积核的数量等于输出通道数。卷积核的长度等于输入通道数。</p><p>卷积过后得到的叫做特征图。</p><p>在边缘可能会丢失数据的时候，用padding补零。</p><h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><p><img src="/2021/02/%E6%B5%99%E6%B1%9F%E5%A4%A7%E5%AD%A6%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E8%AF%BE%E7%A8%8BPart4/image-20210210160114566.png" alt="image-20210210160114566"></p><p>卷积神经网络与全连接的区别。</p><ol><li>局部感受野</li><li>权值共享</li></ol><p>卷积虽然复杂，但是计算量更少。</p><h3 id="激活"><a href="#激活" class="headerlink" title="激活"></a>激活</h3><p>在卷积神经网络中，最常用的非线性函数为ReLu。</p><h3 id="后向传播"><a href="#后向传播" class="headerlink" title="后向传播"></a>后向传播</h3><p>导数会平均反向传播。</p><blockquote><p>整个网络的计算速度取决于卷积层，整个网络的参数个数取决于全连接层。</p><p>即：如果要加速神经网络，则在卷积层做文章；如果要让其内存占用更少的话，则在全连接层做文章。</p></blockquote><h2 id="AlexNet"><a href="#AlexNet" class="headerlink" title="AlexNet"></a>AlexNet</h2><h3 id="改进1——ReLU"><a href="#改进1——ReLU" class="headerlink" title="改进1——ReLU"></a>改进1——ReLU</h3><p>以ReLU函数代替sigmoid或tanh函数。</p><p><img src="/2021/02/%E6%B5%99%E6%B1%9F%E5%A4%A7%E5%AD%A6%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E8%AF%BE%E7%A8%8BPart4/image-20210210163727240.png" alt="image-20210210163727240"></p><p>实践证明，这样做能使网络训练以更快速度收敛。</p><blockquote><p>如果数据是靠近0的正态分布，则每次只激活一半的神经元。</p></blockquote><h3 id="改进2——MaxPooling"><a href="#改进2——MaxPooling" class="headerlink" title="改进2——MaxPooling"></a>改进2——MaxPooling</h3><p><img src="/2021/02/%E6%B5%99%E6%B1%9F%E5%A4%A7%E5%AD%A6%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E8%AF%BE%E7%A8%8BPart4/image-20210210163808698.png" alt="image-20210210163808698"></p><p>在AlexNet中，提出了最大池化(Max Pooling)的概念，即对每一个邻近像素组成的“池子”，选取像素最大值作为输出。在LeNet中，池化的像素是不重叠的；而在AlexNet中进行的是有重叠的池化。实践表明，有重叠的最大池化能够很好的克服过拟合问题，提升系统性能。</p><p>在反向传播时，只传播最大值，其他都为0。</p><blockquote><p>MaxPooling不仅是一个降采样的操作，同时还是一个非线性操作。只采用最大的神经元，有效降低了激活的神经元个数，从而加快了收敛的速率。</p></blockquote><h3 id="改进3——Dropout"><a href="#改进3——Dropout" class="headerlink" title="改进3——Dropout"></a>改进3——Dropout</h3><p>随机丢弃（Dropout）。为了避免系统参数更新过快导致过拟合，每次利用训练样本更新参数时候，随机的“丢弃”一定比例的神经元，被丢弃的神经元将不参加训练过程，输入和输出该神经元的权重系数也不做更新。这样每次训练时，训练的网络架构都不一样，而这些不同的网络架构却分享共同的权重系数。实验表明，随机丢弃技术减缓了网络收敛速度，也以大概率避免了过拟合的发生。</p><blockquote><p>道理和改进2一样，每次训练都只激活有限个神经元，而不要让整个网络同时改变所有的参数，导致整个网络不稳定。</p></blockquote><h3 id="改进4——增加训练样本"><a href="#改进4——增加训练样本" class="headerlink" title="改进4——增加训练样本"></a>改进4——增加训练样本</h3><p>增加训练样本。尽管ImageNet的训练样本数量有超过120万幅图片，但相对于6亿待估计参数来说，训练图像仍然不够。Alex等人采用了多种方法增加训练样本，包括：1. 将原图水平翻转；2. 将256×256的图像随机选取224×224的片段作为输入图像。运用上面两种方法的组合可以将一幅图像变为2048幅图像。还可以对每幅图片引入一定的噪声，构成新的图像。这样做可以较大规模增加训练样本，避免由于训练样本不够造成的性能损失。</p><h3 id="改进5——GPU加速"><a href="#改进5——GPU加速" class="headerlink" title="改进5——GPU加速"></a>改进5——GPU加速</h3><p>用GPU加速训练过程。采用2片GTX 580 GPU对训练过程进行加速，由于GPU强大的并行计算能力，使得训练过程的时间缩短数十倍，哪怕这样，训练时间仍然用了六天。</p><h2 id="近年来流行的网络结构"><a href="#近年来流行的网络结构" class="headerlink" title="近年来流行的网络结构"></a>近年来流行的网络结构</h2><h3 id="VGGNet-（Simonyan-and-Zisserman-2014）"><a href="#VGGNet-（Simonyan-and-Zisserman-2014）" class="headerlink" title="VGGNet: （Simonyan and Zisserman, 2014）"></a>VGGNet: （Simonyan and Zisserman, 2014）</h3><p>3个叠到一起的3 * 3卷积核，感受野（Receptive Field）是7 * 7,大致可以替代7 * 7卷积核的作用。但这样做可以使参数更少 ，参数比例大致为27:49。</p><p>但是，运算速度会因为卷积核数量的增加而大幅下降。</p><p><img src="/2021/02/%E6%B5%99%E6%B1%9F%E5%A4%A7%E5%AD%A6%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E8%AF%BE%E7%A8%8BPart4/image-20210210173031450.png" alt="image-20210210173031450"></p><h3 id="GoogLeNet-（Szegedy-2014）"><a href="#GoogLeNet-（Szegedy-2014）" class="headerlink" title="GoogLeNet: （Szegedy, 2014）"></a>GoogLeNet: （Szegedy, 2014）</h3><p>inception 结构，用一些1<em>1, 3</em>3和5*5的小卷积核用固定方式组合到一起，来代替大的卷积核，从而达到增加感受野和减少参数的目的。500万参数，比ALEXNET小了12倍。</p><p><img src="/2021/02/%E6%B5%99%E6%B1%9F%E5%A4%A7%E5%AD%A6%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E8%AF%BE%E7%A8%8BPart4/image-20210210173440780.png" alt="image-20210210173440780"></p><h3 id="残差网络Residual-Net-ResNet-（He-et-al-2015）"><a href="#残差网络Residual-Net-ResNet-（He-et-al-2015）" class="headerlink" title="残差网络Residual Net(ResNet): （He et al, 2015）"></a>残差网络Residual Net(ResNet): （He et al, 2015）</h3><p>加入了前向输入机制，将前面层获得的特征图作为监督项输入到后面层。用这样的方法使深层网络训练能够更好地收敛。</p><p><img src="/2021/02/%E6%B5%99%E6%B1%9F%E5%A4%A7%E5%AD%A6%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E8%AF%BE%E7%A8%8BPart4/image-20210210183347601.png" alt="image-20210210183347601"></p><h2 id="迁移学习-Transfer-Learning"><a href="#迁移学习-Transfer-Learning" class="headerlink" title="迁移学习(Transfer Learning )"></a>迁移学习(Transfer Learning )</h2><p>迁移学习是指，从一个domain训练好的神经网络，加入新的domain的样本进行调优，从而获得一个更好的识别效果。</p><p>例如，训练好的 Alex Net ，在最后的1k个分类后，外加一层全连接神经网络，输出十几种水果的分类，用十种水果进行调优。虽然这原本1k个分类中或许没有很明显的这十几种水果分类，但这样它能很容易排除除了这些水果以外的物品，同时经过调优之后会更容易贴合我们想要分出的十几种水果。</p><h2 id="目标检测与分割"><a href="#目标检测与分割" class="headerlink" title="目标检测与分割"></a>目标检测与分割</h2><p>这里其实算深度学习（</p><p><img src="/2021/02/%E6%B5%99%E6%B1%9F%E5%A4%A7%E5%AD%A6%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E8%AF%BE%E7%A8%8BPart4/image-20210211213322900.png" alt="image-20210211213322900"></p><h3 id="目标定位与识别"><a href="#目标定位与识别" class="headerlink" title="目标定位与识别"></a>目标定位与识别</h3><p><img src="/2021/02/%E6%B5%99%E6%B1%9F%E5%A4%A7%E5%AD%A6%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E8%AF%BE%E7%A8%8BPart4/image-20210211213742143.png" alt="image-20210211213742143"></p><h3 id="目标检测"><a href="#目标检测" class="headerlink" title="目标检测"></a>目标检测</h3><p>在一幅图片中可能有多种类别，不能确定数量。</p><p>现在这个问题基本解决，有三篇逐步递进的三篇论文。</p><h4 id="Regional-CNN-R-CNN"><a href="#Regional-CNN-R-CNN" class="headerlink" title="Regional CNN(R-CNN)"></a>Regional CNN(R-CNN)</h4><p>目标候选区域(Region Proposal)：先用传统方法或者图像处理的方法，确定可能有物体的地方候选项，再放在卷积神经网络检测。</p><h5 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h5><ol><li>Selective Search：产生RP</li><li>CNN：检测这些候选区域</li><li>SVM：分类</li></ol><p><img src="/2021/02/%E6%B5%99%E6%B1%9F%E5%A4%A7%E5%AD%A6%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E8%AF%BE%E7%A8%8BPart4/image-20210211222650735.png" alt="image-20210211222650735"></p><h5 id="缺陷"><a href="#缺陷" class="headerlink" title="缺陷"></a>缺陷</h5><ol><li>High cost to perform Selective Search (~5s per image)</li><li>Too many passes to CNN (~2000 proposals per image)</li><li>Lead to unacceptable test time (~50s per image)</li><li>High space cost to train SVM (millions of 1024-d features)</li></ol><h4 id="Fast-R-CNN"><a href="#Fast-R-CNN" class="headerlink" title="Fast R-CNN"></a>Fast R-CNN</h4><p>用 Regions of Interest(RoIs) 把不同长宽的候选区域，在Pooling层归一化成同一形状。最后依然是一路预测label，一路预测Bounding-box regressors。</p><p><img src="/2021/02/%E6%B5%99%E6%B1%9F%E5%A4%A7%E5%AD%A6%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E8%AF%BE%E7%A8%8BPart4/image-20210211224649852.png" alt="image-20210211224649852"></p><h5 id="Faster-R-CNN"><a href="#Faster-R-CNN" class="headerlink" title="Faster R-CNN"></a>Faster R-CNN</h5><p>主要通过小的Region Proposal Network产生粗略位置，来代替Selective Search</p><p><img src="/2021/02/%E6%B5%99%E6%B1%9F%E5%A4%A7%E5%AD%A6%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E8%AF%BE%E7%A8%8BPart4/image-20210211221620685.png" alt="image-20210211221620685"></p><h3 id="语义分割"><a href="#语义分割" class="headerlink" title="语义分割"></a>语义分割</h3><h4 id="全卷积网络FCN"><a href="#全卷积网络FCN" class="headerlink" title="全卷积网络FCN"></a>全卷积网络FCN</h4><p>全卷积网络(Fully Convolutional Networks)</p><p>先训练前面一半，再训练后一半。先降采样，后升采样。</p><p>卷积层的上采样（Upsampling）也叫反卷积（Deconvolution）或 转置卷积（Transpose Convolution）。</p><p>全卷积网络也可以用于边缘提取。</p><p><img src="/2021/02/%E6%B5%99%E6%B1%9F%E5%A4%A7%E5%AD%A6%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E8%AF%BE%E7%A8%8BPart4/image-20210211230604746.png" alt="image-20210211230604746"></p><h2 id="隐含马尔科夫过程-HMM-与递归神经网络-RNN"><a href="#隐含马尔科夫过程-HMM-与递归神经网络-RNN" class="headerlink" title="隐含马尔科夫过程(HMM)与递归神经网络(RNN)"></a>隐含马尔科夫过程(HMM)与递归神经网络(RNN)</h2><p>对连续信息的判断有几个问题：不知道如何划分每一个状态，因为①持续时间可能各不相同；②对于语音模型的建模是以一个音节而不是一个单词为基础。</p><h3 id="Hidden-Markov-Models-复习"><a href="#Hidden-Markov-Models-复习" class="headerlink" title="Hidden Markov Models==复习=="></a>Hidden Markov Models==复习==</h3><p>一个HMM模型是由三部分组成：λ = {A, B, π}。其中，A为状态转移矩阵，B为观测概率，π为状态先验概率。</p><ol><li>π(S<del>i</del>)表示一开始在S<del>i</del>状态的概率。</li><li>A是一个P×P的矩阵。马尔科夫链假设是强假设，后一个时刻状态和前一个(或者多个)时刻状态有关（注意这是固定假设 a<del>i,j</del>=P(q<del>t+1</del>=S<del>j</del>|q<del>t</del>=S<del>i</del>)。当t时刻的q样本是状态为S<del>i</del>类，则在t+1时刻q样本转变为状态为S<del>j</del>类的概率）</li><li>B={b<del>j</del>(0)} 若输入向量O属于S<del>j</del>，则它的概率分布用b<del>j</del>(0)表示。</li></ol><p><a href="https://www.bilibili.com/video/BV1dJ411B7gh?p=50">详细推导p50</a></p><h3 id="大词汇量连续语音识别（LVCSR）"><a href="#大词汇量连续语音识别（LVCSR）" class="headerlink" title="大词汇量连续语音识别（LVCSR）"></a>大词汇量连续语音识别（LVCSR）</h3><p>大词汇量连续语音识别（Large-scale Vocabulary Continuous Speech Recognition, LVCSR）</p><ol><li>每一个HMM模型所表达的“单词”是什么？英语中有效的Triphone个数大致在55000左右，模型过多而训练样本不足，所以需要多个Triphone 合并（Tying）、多个Triphone 联合训练（Tying）</li><li>在识别流程中如何对测试声音文件做时间轴的划分，使每一个分段（SEGMENT）对应一个“单词”？如何搜索最佳的“单词”组合？VITERBI搜索（有多种形式，如Two-Level Dynamic Programming）、A*搜索、随机搜索</li><li>如何构造语言模型 (Language Model)? 定义(N-gram): 一个单词出现的概率，只与它前面的N个单词相关。</li></ol><h3 id="结合深度网络模型的语音识别"><a href="#结合深度网络模型的语音识别" class="headerlink" title="结合深度网络模型的语音识别"></a>结合深度网络模型的语音识别</h3><p><img src="/2021/02/%E6%B5%99%E6%B1%9F%E5%A4%A7%E5%AD%A6%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E8%AF%BE%E7%A8%8BPart4/image-20210214220419460.png" alt="image-20210214220419460"></p><h3 id="Recurrent-Neural-Network"><a href="#Recurrent-Neural-Network" class="headerlink" title="Recurrent Neural Network"></a>Recurrent Neural Network</h3><h4 id="输入与输出多对多："><a href="#输入与输出多对多：" class="headerlink" title="输入与输出多对多："></a>输入与输出多对多：</h4><p>大词汇连续语音识别、机器翻译</p><p><img src="/2021/02/%E6%B5%99%E6%B1%9F%E5%A4%A7%E5%AD%A6%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E8%AF%BE%E7%A8%8BPart4/image-20210214215442390.png" alt="image-20210214215442390"></p><h4 id="输入与输出多对一："><a href="#输入与输出多对一：" class="headerlink" title="输入与输出多对一："></a>输入与输出多对一：</h4><p>动作识别、行为识别、单词量有限的语音识别</p><p><img src="/2021/02/%E6%B5%99%E6%B1%9F%E5%A4%A7%E5%AD%A6%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E8%AF%BE%E7%A8%8BPart4/image-20210214215758906.png" alt="image-20210214215758906"></p><h4 id="输入与输出一对多："><a href="#输入与输出一对多：" class="headerlink" title="输入与输出一对多："></a>输入与输出一对多：</h4><p>文本生成、图像文字标注</p><p><img src="/2021/02/%E6%B5%99%E6%B1%9F%E5%A4%A7%E5%AD%A6%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E8%AF%BE%E7%A8%8BPart4/image-20210214215916422.png" alt="image-20210214215916422"></p><h3 id="Long-Short-Term-Memory-LSTM"><a href="#Long-Short-Term-Memory-LSTM" class="headerlink" title="Long-Short Term Memory (LSTM)"></a>Long-Short Term Memory (LSTM)</h3><p>相比VANILLA RNN， LSTM的误差反向传播更方便和直接，梯度更新不存在RNN中的暴涨或消失现象。因此，建议涉及RNN的应用都用LSTM或LSTM相关的变种。</p><p><img src="/2021/02/%E6%B5%99%E6%B1%9F%E5%A4%A7%E5%AD%A6%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E8%AF%BE%E7%A8%8BPart4/image-20210214221615263.png" alt="image-20210214221615263"></p>]]></content>
      
      
      <categories>
          
          <category> 浙江大学机器学习课程 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>浙江大学机器学习课程Part3</title>
      <link href="/2021/02/%E6%B5%99%E6%B1%9F%E5%A4%A7%E5%AD%A6%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E8%AF%BE%E7%A8%8BPart3/"/>
      <url>/2021/02/%E6%B5%99%E6%B1%9F%E5%A4%A7%E5%AD%A6%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E8%AF%BE%E7%A8%8BPart3/</url>
      
        <content type="html"><![CDATA[<h1 id="浙江大学机器学习课程Part3——人工神经网络"><a href="#浙江大学机器学习课程Part3——人工神经网络" class="headerlink" title="浙江大学机器学习课程Part3——人工神经网络"></a>浙江大学机器学习课程Part3——人工神经网络</h1><p>[TOC]</p><h2 id="神经网络的生物及数学模型"><a href="#神经网络的生物及数学模型" class="headerlink" title="神经网络的生物及数学模型"></a>神经网络的生物及数学模型</h2><ol><li>硬件算力的提升</li><li>数据样本的增加</li><li>但是，<strong>其最基本的神经元模型至今没有重大改变</strong></li></ol><p><img src="/2021/02/%E6%B5%99%E6%B1%9F%E5%A4%A7%E5%AD%A6%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E8%AF%BE%E7%A8%8BPart3/image-20210209144613134.png" alt="image-20210209144613134"></p><h2 id="感知器算法-Perceptron-Algorithm"><a href="#感知器算法-Perceptron-Algorithm" class="headerlink" title="感知器算法(Perceptron Algorithm)"></a>感知器算法(Perceptron Algorithm)</h2><p><img src="/2021/02/%E6%B5%99%E6%B1%9F%E5%A4%A7%E5%AD%A6%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E8%AF%BE%E7%A8%8BPart3/image-20210209144950398.png" alt="image-20210209144950398"></p><ul><li>效果比SVM差得多，但是是机器学习最早提出的算法。</li><li>感知器每次只取单个样本，SVM从全局样本考虑。</li></ul><p><a href="https://www.bilibili.com/video/BV1dJ411B7gh?p=20">收敛性证明看p20</a></p><h2 id="多层神经网络-Multi-Layer-Neural-Networks"><a href="#多层神经网络-Multi-Layer-Neural-Networks" class="headerlink" title="多层神经网络(Multi-Layer Neural Networks)"></a>多层神经网络(Multi-Layer Neural Networks)</h2><p>线性不可分的数据集困扰了早期神经网络算法长达十年之久。</p><p>因此，我们需要用非线性的函数集合来分开非线性可分的数据集。</p><p><img src="/2021/02/%E6%B5%99%E6%B1%9F%E5%A4%A7%E5%AD%A6%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E8%AF%BE%E7%A8%8BPart3/image-20210209160042159.png" alt="image-20210209160042159"></p><p>二层神经网络模型举例。</p><h2 id="三层神经网络模拟任意决策面"><a href="#三层神经网络模拟任意决策面" class="headerlink" title="三层神经网络模拟任意决策面"></a>三层神经网络模拟任意决策面</h2><p>我个人认为：过了第一层，数据样本基本不会保持原貌，但是保留了特征，或者说特点。</p><p>在老师画的示例中，实际的数学意义为：①第一层是：坐标(x,y)进入多个函数输入相对位置，进入激活函数输出0-1；②第二层：根据上一层判断的0-1，进入函数判断是否为某一块图形内部，返回0-1；③第三层：根据上一层返回的是否在某图形内部的0-1，进入函数判断该图形是否为class1，通过或关系，输出最终结果0-1.</p><p>详情见<a href="https://www.bilibili.com/video/BV1dJ411B7gh?p=23">p23</a></p><h2 id="后向传播算法-Back-Propagation"><a href="#后向传播算法-Back-Propagation" class="headerlink" title="后向传播算法(Back Propagation)"></a>后向传播算法(Back Propagation)</h2><blockquote><p>在对于某种问题，我们究竟应该选择哪一种参数组合，如何搭建完美的网络结构。这依然是一个至今为止不完备的，对于一种问题，最好的方法还是不断试验。</p></blockquote><p>主要思想就是梯度向下法(Gradient Descent Method)来求局部极值。</p><p>常用的激活函数：sigmoid、tanh、ReLu(Rectified Linear Units)、LeakReLu</p><p><a href="https://www.bilibili.com/video/BV1dJ411B7gh?p=24">==BP推导P24==</a></p><h2 id="参数设置"><a href="#参数设置" class="headerlink" title="参数设置"></a>参数设置</h2><h3 id="随机梯度下降"><a href="#随机梯度下降" class="headerlink" title="随机梯度下降"></a>随机梯度下降</h3><ol><li>不用每输入一个样本就去变换参数，而是输入一批样本（叫做一个BATCH或MINI-BATCH），求出这些样本的梯度平均值后，根据这个平均值改变参数。</li><li>在神经网络训练中，BATCH的样本数大致设置为50-200不等。  </li></ol><h3 id="激活函数"><a href="#激活函数" class="headerlink" title="激活函数"></a>激活函数</h3><p><img src="/2021/02/%E6%B5%99%E6%B1%9F%E5%A4%A7%E5%AD%A6%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E8%AF%BE%E7%A8%8BPart3/image-20210210140226760.png" alt="image-20210210140226760"></p><h3 id="梯度消失与归一化"><a href="#梯度消失与归一化" class="headerlink" title="梯度消失与归一化"></a>梯度消失与归一化</h3><ol><li>当样本都非常大或者非常小，在sigmoid函数中就可以发现，他们的梯度将会非常小，这样意味着他们更加符合我们想要得到的预测结果，即二分类。但是这并不是我们在训练过程中想要的，因为梯度太小而导致参数无法更新以进行训练。</li><li>防止梯度消失，那么就需要使样本更加靠近在0附近，更加具有像线性模型一样的特性。因此我们经常对<strong>初</strong>始数据以及在<strong>训练过程中</strong>进行归一化Batch Normalization。</li></ol><h3 id="目标函数选择"><a href="#目标函数选择" class="headerlink" title="目标函数选择"></a>目标函数选择</h3><ol><li><p>SOFTMAX函数</p><p><img src="/2021/02/%E6%B5%99%E6%B1%9F%E5%A4%A7%E5%AD%A6%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E8%AF%BE%E7%A8%8BPart3/image-20210210131234229.png" alt="image-20210210131234229"> 处理多分类</p></li><li><p>交叉熵(Cross Entropy)</p><p><img src="/2021/02/%E6%B5%99%E6%B1%9F%E5%A4%A7%E5%AD%A6%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E8%AF%BE%E7%A8%8BPart3/image-20210210131306125.png" alt="image-20210210131306125"> 处理二分类</p></li></ol><h3 id="参数更新策略"><a href="#参数更新策略" class="headerlink" title="参数更新策略"></a>参数更新策略</h3><p>优化器不一定是MSE，因为MSE的更新通常容易出现z字路径，一般可以选择使用其他更加平滑的优化器，比如AdaGrad、RMSProp。</p>]]></content>
      
      
      <categories>
          
          <category> 浙江大学机器学习课程 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>浙江大学机器学习课程Part2</title>
      <link href="/2021/02/%E6%B5%99%E6%B1%9F%E5%A4%A7%E5%AD%A6%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E8%AF%BE%E7%A8%8BPart2/"/>
      <url>/2021/02/%E6%B5%99%E6%B1%9F%E5%A4%A7%E5%AD%A6%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E8%AF%BE%E7%A8%8BPart2/</url>
      
        <content type="html"><![CDATA[<h1 id="浙江大学机器学习课程Part2——支持向量机"><a href="#浙江大学机器学习课程Part2——支持向量机" class="headerlink" title="浙江大学机器学习课程Part2——支持向量机"></a>浙江大学机器学习课程Part2——支持向量机</h1><p>[TOC]</p><h2 id="Support-Vector-Machine"><a href="#Support-Vector-Machine" class="headerlink" title="Support Vector Machine"></a>Support Vector Machine</h2><h3 id="支持向量机"><a href="#支持向量机" class="headerlink" title="支持向量机"></a>支持向量机</h3><p>对样本数较少的时候，都会得到一个比较好的结果。</p><p>如何在两种训练集上画一条直线来分类：</p><ol><li>线性可分(Linear Separable)训练样本集</li><li>非线性可分(Non-Linear Separable)样本集</li></ol><p>将线(在多维特征下是超平面Hyperplane)向两边移动直到擦到样本点，其中间隔(Margin)最大，且线在d/2处。</p><h3 id="数学描述"><a href="#数学描述" class="headerlink" title="数学描述"></a>数学描述</h3><ol><li>将平行线擦到的向量称作支持向量(Support Vector)</li><li>训练数据及标签：(Xn, Yn)…… X为特征向量，Y为标签。Y取+1或-1来表示，方便推导。</li><li>线性模型：(W, b) 超平面：Wt * X + b = 0</li></ol><h3 id="机器学习过程"><a href="#机器学习过程" class="headerlink" title="机器学习过程"></a>机器学习过程</h3><ol><li>用复杂的函数来限定模型框架</li><li>留出待定参数</li><li>用训练样本来确定参数取值</li></ol><h3 id="线性可分的定义和条件"><a href="#线性可分的定义和条件" class="headerlink" title="线性可分的定义和条件"></a>线性可分的定义和条件</h3><p>{(Xi, Yi)}i = 1<del>N, 存在(W, b), 则对任意 i = 1</del>N. 有：</p><p>①若Yi = +1, 则 Wt * X + b &gt; 0</p><p>②若Yi = -1, 则 Wt * X + b &lt; 0</p><p>为什么要取Y=±1？因为可以得到①②等价于 Yi ( Wt * X + b ) &gt; 0</p><h2 id="优化问题-优化目标函数和限制条件"><a href="#优化问题-优化目标函数和限制条件" class="headerlink" title="优化问题(优化目标函数和限制条件)"></a>优化问题(优化目标函数和限制条件)</h2><h3 id="两个要点"><a href="#两个要点" class="headerlink" title="两个要点"></a>两个要点</h3><ol><li>点最小化(Minimize / min): 1 / 2 * ||W||² 。<strong>这里1/2只是为了求导方便</strong></li><li>限制条件(Subject to / s.t.): Y<del>i</del> ( W^T^ * X + b ) ≥ 1, (i=1~N)</li></ol><h3 id="两个事实"><a href="#两个事实" class="headerlink" title="两个事实"></a>两个事实</h3><p>事实1：W^T^ * X + b = 0 与 a * W^T^ * X + a * b = 0, (a∈R+) 是同一个平面。</p><p>​           即: 若 (W, b) 满足 W^T^ * X + b = 0 , 则 (a * W, a * b) 也满足 W^T^ * X + b = 0 </p><p>事实2：向量到超平面(点到平面)的距离公式。d = | Wt * X0 + b | / || W || *<em>1.这里的X0代表的是包含多个维度的坐标[x,y,z…]，而Y0是分类标签，不能与坐标混为一谈；2.Wt</em>X0结果是一个数而不是矩阵向量**</p><p>​           其中，模 || W || = √(W1²+W2²…+Wn²)</p><h3 id="推导"><a href="#推导" class="headerlink" title="推导"></a>推导</h3><ol><li>用a去缩放超平面参数：(W, b) &lt;=&gt; ( a * W, a * b )。根据事实1，这两组不同的参数代表的是同一个平面。</li><li>最终使在支持向量上：| W^T^ * X<del>0</del> + b | = 1。<strong>这里的W和b都是经过系数a缩放过后的，目的是为了凑出1(当然你可以凑出任意常数)，而a具体是多少，我们不需要关注。需要注意的是，这里只是带入支持向量的值，并不是指支持向量的那个点在超平面上，否则值为0。</strong></li><li>由<em>推导2</em>和<em>事实2</em>可得：d = | W^T^ * X<del>0</del> + b | / || W || = 1 / || W ||。可得<em>要点1</em>：最小化 ||W|| 即最大化 d 。</li><li>其他不是支持向量的点到超平面的距离，则大于 1 / || W || 。可得 | W^T^ * X<del>0</del> + b | &gt; 1 。可得<em>要点2</em>：限制条件 Y<del>i</del> * ( W^T^ * X + b ) ≥ 1</li></ol><p>举例：原来平面是 W^T^ * X + b = 0 , 假设带入X<del>0</del>后的值 | W^T^ * X<del>0</del> + b | = M , 现在把超平面缩放为 a * W^T^ * X + a * b = 0 , 其中a是1/M, 那么把X<del>0</del>带入则 | a * W^T^ * X<del>0</del> + a * b | = M/M = 1。与此同时，计算d的时候，因为分子分母同乘a=1/M，a不需要求出，所以我们不需要关心a的取值，只是为了凑一个 | W^T^ * X<del>0</del> + b | = 1 ，当然你可以凑出任意常数。</p><h3 id="二次优化问题-Quadratic-Programming"><a href="#二次优化问题-Quadratic-Programming" class="headerlink" title="二次优化问题(Quadratic Programming)"></a>二次优化问题(Quadratic Programming)</h3><p>二次优化问题属于凸优化问题</p><ol><li>目标函数(Obejective Function)是二次项</li><li>限制条件是一次项</li></ol><p>要么无解，要么只有唯一极值。即局部极值就是全局极值。</p><h3 id="SVM处理非线性"><a href="#SVM处理非线性" class="headerlink" title="SVM处理非线性"></a>SVM处理非线性</h3><img src="/2021/02/%E6%B5%99%E6%B1%9F%E5%A4%A7%E5%AD%A6%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E8%AF%BE%E7%A8%8BPart2/image-20210207133321372.png" alt="image-20210207133321372" style="zoom: 200%;"><p>处理这种问题的一种方案就是加上正则项(Regulation Term)（结构损失函数），在解集合中挑选出一组参数（解），使经验损失和结构损失都较低。</p><p>c是正则化的强度，是事先设定好的超参数。</p><p>ζ是松弛变量(Slack Variable)。</p><p>放到场景中就是，样本数小于参数量，在只优化经验误差函数的时候很容易发生过拟合。这个公式依然可以适用于处理线性Linear SVM。</p><h2 id="低维到高维映射"><a href="#低维到高维映射" class="headerlink" title="低维到高维映射"></a>低维到高维映射</h2><p>在低维空间中，一些线性不可分的数据集，在高维空间中，更有可能被分开。因此可以把Xi通过函数φ(x)变换映射到高维空间，通过泛函分析满足某种条件，把核函数W*φ(x)拆成两个高维向量的内积。</p><h3 id="核函数"><a href="#核函数" class="headerlink" title="核函数"></a>核函数</h3><p>我们可以不在意无限维映射φ(x)的显示表达，我们只要知道一个核函数(kernel Function)，<img src="/2021/02/%E6%B5%99%E6%B1%9F%E5%A4%A7%E5%AD%A6%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E8%AF%BE%E7%A8%8BPart2/image-20210207142313276.png" alt="image-20210207142313276">，则优化问题仍然可解。</p><p>线性内核相当于没有用核。多项式核的待定系数d取越大，则越复杂。高斯核是无限维度，分类效果最高，待定系数为σ。Tanh核的待定参数是β和b。这些待定参数的选取只能不停地试。</p><p><img src="/2021/02/%E6%B5%99%E6%B1%9F%E5%A4%A7%E5%AD%A6%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E8%AF%BE%E7%A8%8BPart2/image-20210206144627709.png" alt="image-20210206144627709"></p><h3 id="充要条件"><a href="#充要条件" class="headerlink" title="充要条件"></a>充要条件</h3><p><img src="/2021/02/%E6%B5%99%E6%B1%9F%E5%A4%A7%E5%AD%A6%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E8%AF%BE%E7%A8%8BPart2/image-20210207142313276.png" alt="image-20210207142313276">能够成立的充要条件：(Mercer’s Theorem)</p><ol><li>K(X<del>1</del>, X<del>2</del>) = K(X<del>2</del>, X<del>1</del>) <strong>(交换性)</strong></li><li>对任意 常数C<del>i</del>, 向量X<del>i</del> (i=1<del>N)，有 ∑(i=1</del>N) ∑(j=1<del>N) C</del>i~ * C<del>j</del> * K(X<del>i</del>, X<del>j</del>) ≥ 0 <strong>(半正定性)</strong></li></ol><h2 id="原问题和对偶问题-重点复习"><a href="#原问题和对偶问题-重点复习" class="headerlink" title="原问题和对偶问题==(重点复习)=="></a>原问题和对偶问题==(重点复习)==</h2><h3 id="优化理论"><a href="#优化理论" class="headerlink" title="优化理论"></a>优化理论</h3><p>优化理论(运筹学)是工程里最本质的问题</p><h4 id="推荐书籍"><a href="#推荐书籍" class="headerlink" title="推荐书籍"></a>推荐书籍</h4><ol><li>Convex optimization - Stephen Boyd - b站吴立德</li><li>Nonlinear Programming</li></ol><h3 id="原问题-Prime-Problem"><a href="#原问题-Prime-Problem" class="headerlink" title="原问题(Prime Problem)"></a>原问题(Prime Problem)</h3><p>min: f(w)</p><p>s.t. : g<del>i</del>(w)≤0 (i=1<del>K) , h</del>i<del>(w)=0 (i=1</del>M)</p><h3 id="对偶问题-Dual-Problem"><a href="#对偶问题-Dual-Problem" class="headerlink" title="对偶问题(Dual Problem)"></a>对偶问题(Dual Problem)</h3><ol><li><p>定义：<img src="/2021/02/%E6%B5%99%E6%B1%9F%E5%A4%A7%E5%AD%A6%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E8%AF%BE%E7%A8%8BPart2/image-20210207153808814.png" alt="image-20210207153808814"></p><p>x是前面的w，α是一个K维的向量，β是一个M维的向量。</p><p>拉格朗日对偶问题是运筹学基础知识。*(KKT条件求解、拉格朗日传乘数法、弱对偶性定理)*</p></li><li><p>对偶问题定义：</p><p>max: <img src="/2021/02/%E6%B5%99%E6%B1%9F%E5%A4%A7%E5%AD%A6%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E8%AF%BE%E7%A8%8BPart2/image-20210207154702680.png" alt="image-20210207154702680">(inf:求最小值)</p><p>s.t. : λ<del>i</del> ≥ 0 (i=1~K)</p></li></ol><p><img src="/2021/02/%E6%B5%99%E6%B1%9F%E5%A4%A7%E5%AD%A6%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E8%AF%BE%E7%A8%8BPart2/image-20210207161614446.png" alt="p11-19:17"></p><p><img src="/2021/02/%E6%B5%99%E6%B1%9F%E5%A4%A7%E5%AD%A6%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E8%AF%BE%E7%A8%8BPart2/image-20210207162438113.png" alt="p11-22:56"></p><p><img src="/2021/02/%E6%B5%99%E6%B1%9F%E5%A4%A7%E5%AD%A6%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E8%AF%BE%E7%A8%8BPart2/image-20210207162758286.png" alt="p11-26:14"></p><p>这里可以去看《Convex optimization》前150页内容，学习推导过程。</p><p>结论可推出：</p><p><img src="/2021/02/%E6%B5%99%E6%B1%9F%E5%A4%A7%E5%AD%A6%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E8%AF%BE%E7%A8%8BPart2/image-20210207163413689.png" alt="image-20210207163413689"></p><h2 id="支持向量机原问题转化为对偶问题-重点复习"><a href="#支持向量机原问题转化为对偶问题-重点复习" class="headerlink" title="支持向量机原问题转化为对偶问题==(重点复习)=="></a>支持向量机原问题转化为对偶问题==(重点复习)==</h2><p>凸函数的定义。w可能是高维向量，这个代数表达在高维依然适用。</p><p><img src="/2021/02/%E6%B5%99%E6%B1%9F%E5%A4%A7%E5%AD%A6%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E8%AF%BE%E7%A8%8BPart2/image-20210207164852602.png" alt="image-20210207164852602"></p><p>原问题证明建议重看<a href="https://www.bilibili.com/video/BV1dJ411B7gh?p=12">p12-23:37</a></p><h2 id="支持向量机的应用——兵王问题"><a href="#支持向量机的应用——兵王问题" class="headerlink" title="支持向量机的应用——兵王问题"></a>支持向量机的应用——兵王问题</h2><h3 id="n折交叉验证"><a href="#n折交叉验证" class="headerlink" title="n折交叉验证"></a>n折交叉验证</h3><p>对于<strong>每一组超参数</strong>，进行<strong>n折交叉验证</strong>求损失，最终选取的是损失最小的那一组超参数。</p><h3 id="测试结果中的支持向量"><a href="#测试结果中的支持向量" class="headerlink" title="测试结果中的支持向量"></a>测试结果中的支持向量</h3><p>当支持向量占比非常高，甚至是几乎等于训练样本。则表明这次训练失败，或者数据集本身没有规律，或者SVM 没法找到他的规律。</p><h3 id="评判模型好坏"><a href="#评判模型好坏" class="headerlink" title="评判模型好坏"></a>评判模型好坏</h3><h4 id="混淆矩阵"><a href="#混淆矩阵" class="headerlink" title="混淆矩阵"></a>混淆矩阵</h4><p><img src="/2021/02/%E6%B5%99%E6%B1%9F%E5%A4%A7%E5%AD%A6%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E8%AF%BE%E7%A8%8BPart2/image-20210208230203359.png" alt="image-20210208230203359"></p><p>TP: 将正样本识别为正样本的数量（或概率）</p><p>FN: 将正样本识别为负样本的数量（或概率）</p><p>FP: 将负样本识别为正样本的数量（或概率）</p><p>TN: 将负样本识别为负样本的数量（或概率）</p><p>FN减少 &lt;=&gt; TP增加 &lt;=&gt; FP增加 &lt;=&gt; TN减少</p><blockquote><p>mAP: mean Average Precision, 即各类别AP的平均值</p><p>AP: PR曲线下面积，后文会详细讲解</p><p>PR曲线: Precision-Recall曲线</p><p>Precision: TP / (TP + FP)</p><p>Recall: TP / (TP + FN)</p><p>TP: IoU&gt;0.5的检测框数量（同一Ground Truth只计算一次）</p><p>FP: IoU&lt;=0.5的检测框，或者是检测到同一个GT的多余检测框的数量</p><p>FN: 没有检测到的GT的数量</p></blockquote><h4 id="ROC曲线-Receiver-Operating-Character"><a href="#ROC曲线-Receiver-Operating-Character" class="headerlink" title="ROC曲线(Receiver Operating Character)"></a>ROC曲线(Receiver Operating Character)</h4><p><img src="/2021/02/%E6%B5%99%E6%B1%9F%E5%A4%A7%E5%AD%A6%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E8%AF%BE%E7%A8%8BPart2/image-20210209123230240.png" alt="image-20210209123230240"></p><p>四条线表示四个不同的系统</p><p>等错误率 (Equal Error Rate, EER)是两类错误FP和FN相等时候的错误率，这时错误率越小，表示系统性能约好。</p><p>AUC(Area Under Curve)曲线右下角的一块面积，面积的大小也能体现模型的好坏。</p><blockquote><p>判别模型的好坏要看具体的应用，并不是准确率越高，模型高就越好</p></blockquote><h3 id="兵王问题的Python实现-补充"><a href="#兵王问题的Python实现-补充" class="headerlink" title="兵王问题的Python实现==(补充)=="></a>兵王问题的Python实现==(补充)==</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h2 id="处理多分类问题"><a href="#处理多分类问题" class="headerlink" title="处理多分类问题"></a>处理多分类问题</h2><ol><li>改造优化的目标函数和限制条件，使之能处理多类<br>论文 SVM-Multiclass Multi-class Support Vector Machine</li><li>一类 VS 其他类</li><li>一类 VS 另一类</li></ol><p>其中，①方法通常不是很好，因为SVM是针对二分类问题开发的。</p><p>在n类问题分类中，②方法主要构造n个SVM，③方法要构造 n * (n-1) / 2 个SVM。</p><p>通常来说，③方法分类噢效果更好，但是也更复杂。</p>]]></content>
      
      
      <categories>
          
          <category> 浙江大学机器学习课程 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>浙江大学机器学习课程Part1</title>
      <link href="/2021/02/%E6%B5%99%E6%B1%9F%E5%A4%A7%E5%AD%A6%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E8%AF%BE%E7%A8%8BPart1/"/>
      <url>/2021/02/%E6%B5%99%E6%B1%9F%E5%A4%A7%E5%AD%A6%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E8%AF%BE%E7%A8%8BPart1/</url>
      
        <content type="html"><![CDATA[<h1 id="浙江大学机器学习课程Part1——课程概论"><a href="#浙江大学机器学习课程Part1——课程概论" class="headerlink" title="浙江大学机器学习课程Part1——课程概论"></a>浙江大学机器学习课程Part1——课程概论</h1><p>[TOC]</p><h2 id="推荐书籍-amp-课程"><a href="#推荐书籍-amp-课程" class="headerlink" title="推荐书籍&amp;课程"></a>推荐书籍&amp;课程</h2><ol><li>机器学习， 周志华，清华大学出版社，2016</li><li>统计学习方法，李航，清华大学出版社，2012</li><li>Machine Learning in Action, P. Harrington,人民邮电出版社</li><li>Pattern Recognition and Machine Learning (模式识别与机器学习)，Christopher M. Bishop, 2006</li><li>Machine Learning: A Probabilistic Perspective, K. P. Murphy, </li><li>Machine Learning (机器学习), Tom M. Mitchell, 机械工业出版社，2003年</li><li>Deep Learning, I. Goodfellow, Y. Bengio and A. Courville, 2016</li><li><a href="https://www.coursera.org/course/ml">Stanfrod Web course by Andrew Ng</a></li><li><a href="https://cs231n.stanford.edu/">Stanfrod Web course by Fei-fei Li</a></li></ol><h2 id="机器学习算法分类"><a href="#机器学习算法分类" class="headerlink" title="机器学习算法分类"></a>机器学习算法分类</h2><ol><li>Supervised learning 监督式学习 – SVM, NEURAL NETWORKS</li><li>Unsupervised learning 无监督式学习 – CLUSTERING, EM ALGORITHM, PCA</li><li>Semi-Supervised Learning 半监督式学习</li><li>Reinforcement learning 增强学习</li></ol><p>以预测标签为导向的分类：监督式学习、无监督式学习、半监督式学习。</p><p>不注重过程而关心结果的分类：增强学习。例如：智能驾驶（在不违反交通规则的情况下最快到达目的地）、下棋对战AI（为了最终的输赢有很多种不同的下法）</p><p>Supervised learning:  The machine learning task of inferring a function from labeled training data. Supervised learning can be further divided into </p><ol><li>classification 分类（二分类/多分类） - 离散值标签</li><li>regression 回归（单响应/多响应） - 连续值标签</li></ol><p>两者没有明确界限，以至于有些分类算法也能做回归算法。</p><h2 id="机器学习两大难点"><a href="#机器学习两大难点" class="headerlink" title="机器学习两大难点"></a>机器学习两大难点</h2><ol><li>维度</li><li>标准</li></ol><h2 id="没有免费午餐定理-No-Free-Lunch-Theorem"><a href="#没有免费午餐定理-No-Free-Lunch-Theorem" class="headerlink" title="没有免费午餐定理(No Free Lunch Theorem)"></a>没有免费午餐定理(No Free Lunch Theorem)</h2><p>任何一个预测函数，如果在一些训练样本上表现好，那么必然在另一些训练样本上表现不好，表现好与表现不好的情况一样多。</p><p>如果我们不对特征空间有先验假设，则所有算法的平均表现是一样的。</p><p>我们认为：特征差距小的样本更有可能是同一类。但是，在没有任何先前给定特征意义的情况下，我们都不能确定预测的下一个是什么。</p><p>在这个领域没有最好的算法，但是有公认的好方法。</p>]]></content>
      
      
      <categories>
          
          <category> 浙江大学机器学习课程 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>PyTorch深度学习实践-完结目录</title>
      <link href="/2021/01/PyTorch%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%AE%9E%E8%B7%B5-%E5%AE%8C%E7%BB%93%E7%9B%AE%E5%BD%95/"/>
      <url>/2021/01/PyTorch%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%AE%9E%E8%B7%B5-%E5%AE%8C%E7%BB%93%E7%9B%AE%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<h1 id="PyTorch深度学习实践-完结目录"><a href="#PyTorch深度学习实践-完结目录" class="headerlink" title="PyTorch深度学习实践-完结目录"></a>PyTorch深度学习实践-完结目录</h1><p>教程视频传送门：<a href="https://www.bilibili.com/video/BV1Y7411d7Ys?p=13">《PyTorch深度学习实践》完结合集</a></p><p>总之就是非常推荐，很适合新手入门，原理循序渐进，建议认真听，认真做。</p><table><thead><tr><th align="center"><a href="../PyTorch%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%AE%9E%E8%B7%B5Part1/">Part1——概论</a></th></tr></thead><tbody><tr><td align="center"><strong><a href="../PyTorch%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%AE%9E%E8%B7%B5Part2/">Part2——线性模型</a></strong></td></tr><tr><td align="center"><strong><a href="../PyTorch%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%AE%9E%E8%B7%B5Part3/">Part3——梯度下降算法</a></strong></td></tr><tr><td align="center"><strong><a href="../PyTorch%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%AE%9E%E8%B7%B5Part4/">Part4——反向传播</a></strong></td></tr><tr><td align="center"><strong><a href="../PyTorch%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%AE%9E%E8%B7%B5Part5/">Part5——线性回归</a></strong></td></tr><tr><td align="center"><strong><a href="../PyTorch%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%AE%9E%E8%B7%B5Part6/">Part6——逻辑斯蒂回归</a></strong></td></tr><tr><td align="center"><strong><a href="../PyTorch%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%AE%9E%E8%B7%B5Part7/">Part7——处理多维特征的输入</a></strong></td></tr><tr><td align="center"><strong><a href="../PyTorch%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%AE%9E%E8%B7%B5Part8/">Part8——加载数据集</a></strong></td></tr><tr><td align="center"><strong><a href="../PyTorch%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%AE%9E%E8%B7%B5Part9/">Part9——多分类问题</a></strong></td></tr><tr><td align="center"><strong><a href="../PyTorch%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%AE%9E%E8%B7%B5Part10/">Part10——卷积神经网络（基础篇）</a></strong></td></tr><tr><td align="center"><strong><a href="../PyTorch%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%AE%9E%E8%B7%B5Part11/">Part11——卷积神经网络（高级篇）</a></strong></td></tr><tr><td align="center"><strong><a href="../PyTorch%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%AE%9E%E8%B7%B5Part12/">Part12——循环神经网络（基础篇）</a></strong></td></tr><tr><td align="center"><strong><a href="../PyTorch%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%AE%9E%E8%B7%B5Part13/">Part13——循环神经网络（高级篇）</a></strong></td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> PyTorch深度学习实践 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PyTorch深度学习实践Part13</title>
      <link href="/2021/01/PyTorch%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%AE%9E%E8%B7%B5Part13/"/>
      <url>/2021/01/PyTorch%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%AE%9E%E8%B7%B5Part13/</url>
      
        <content type="html"><![CDATA[<h1 id="PyTorch深度学习实践Part13——循环神经网络（高级篇）"><a href="#PyTorch深度学习实践Part13——循环神经网络（高级篇）" class="headerlink" title="PyTorch深度学习实践Part13——循环神经网络（高级篇）"></a>PyTorch深度学习实践Part13——循环神经网络（高级篇）</h1><h2 id="RNN"><a href="#RNN" class="headerlink" title="RNN"></a>RNN</h2><p><img src="/2021/01/PyTorch%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%AE%9E%E8%B7%B5Part13/image-20210121201135070.png" alt="image-20210121201135070"></p><p>双向循环神经网络</p><p><img src="/2021/01/PyTorch%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%AE%9E%E8%B7%B5Part13/image-20210122101740766.png" alt="image-20210122101740766"></p><h2 id="人名处理"><a href="#人名处理" class="headerlink" title="人名处理"></a>人名处理</h2><ol><li>切分字符串</li><li>转ASCII码</li></ol><p><img src="/2021/01/PyTorch%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%AE%9E%E8%B7%B5Part13/image-20210122103511843.png" alt="image-20210122103511843"></p><ol start="3"><li>填充</li></ol><p><img src="/2021/01/PyTorch%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%AE%9E%E8%B7%B5Part13/image-20210122103548168.png" alt="image-20210122103548168"></p><ol start="4"><li>转置</li></ol><p><img src="/2021/01/PyTorch%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%AE%9E%E8%B7%B5Part13/image-20210122103627700.png" alt="image-20210122103627700"></p><ol start="5"><li>排序</li></ol><p><img src="/2021/01/PyTorch%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%AE%9E%E8%B7%B5Part13/image-20210122103701821.png" alt="image-20210122103701821"></p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> csv</span><br><span class="line"><span class="keyword">import</span> gzip</span><br><span class="line"><span class="keyword">import</span> math</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">from</span> torch.nn.utils.rnn <span class="keyword">import</span> pack_padded_sequence</span><br><span class="line"><span class="keyword">from</span> torch.utils.data <span class="keyword">import</span> DataLoader, Dataset</span><br><span class="line"></span><br><span class="line">HIDDEN_SIZE = <span class="number">100</span></span><br><span class="line">BATCH_SIZE = <span class="number">256</span></span><br><span class="line">N_LAYER = <span class="number">2</span></span><br><span class="line">N_EPOCHS = <span class="number">100</span></span><br><span class="line">N_CHARS = <span class="number">128</span></span><br><span class="line">USE_GPU = <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NameDataset</span>(<span class="params">Dataset</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, is_train_set=<span class="literal">True</span></span>):</span></span><br><span class="line">        filename = <span class="string">&#x27;../names_train.csv.gz&#x27;</span> <span class="keyword">if</span> is_train_set <span class="keyword">else</span> <span class="string">&#x27;../names_test.csv.gz&#x27;</span></span><br><span class="line">        <span class="keyword">with</span> gzip.<span class="built_in">open</span>(filename, <span class="string">&#x27;rt&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">            reader = csv.reader(f)</span><br><span class="line">            rows = <span class="built_in">list</span>(reader)</span><br><span class="line">        self.names = [row[<span class="number">0</span>] <span class="keyword">for</span> row <span class="keyword">in</span> rows]</span><br><span class="line">        self.<span class="built_in">len</span> = <span class="built_in">len</span>(self.names)</span><br><span class="line">        self.countries = [row[<span class="number">1</span>] <span class="keyword">for</span> row <span class="keyword">in</span> rows]</span><br><span class="line">        self.country_list = <span class="built_in">list</span>(<span class="built_in">sorted</span>(<span class="built_in">set</span>(self.countries)))</span><br><span class="line">        self.country_dict = self.getCountryDict()</span><br><span class="line">        self.country_num = <span class="built_in">len</span>(self.country_list)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getitem__</span>(<span class="params">self, index</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self.names[index], self.country_dict[self.countries[index]]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__len__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self.<span class="built_in">len</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getCountryDict</span>(<span class="params">self</span>):</span></span><br><span class="line">        country_dict = <span class="built_in">dict</span>()</span><br><span class="line">        <span class="keyword">for</span> idx, country_name <span class="keyword">in</span> <span class="built_in">enumerate</span>(self.country_list, <span class="number">0</span>):</span><br><span class="line">            country_dict[country_name] = idx</span><br><span class="line">        <span class="keyword">return</span> country_dict</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">idx2country</span>(<span class="params">self, index</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self.country_list[index]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getCountriesNum</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self.country_num</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">trainset = NameDataset(is_train_set=<span class="literal">True</span>)</span><br><span class="line">trainloader = DataLoader(trainset, batch_size=BATCH_SIZE, shuffle=<span class="literal">True</span>)</span><br><span class="line">testset = NameDataset(is_train_set=<span class="literal">False</span>)</span><br><span class="line">testloader = DataLoader(testset, batch_size=BATCH_SIZE, shuffle=<span class="literal">False</span>)</span><br><span class="line">N_COUNTRY = trainset.getCountriesNum()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RNNClassifier</span>(<span class="params">torch.nn.Module</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, input_size, hidden_size, output_size, n_layers=<span class="number">1</span>, bidirectional=<span class="literal">True</span></span>):</span></span><br><span class="line">        <span class="built_in">super</span>(RNNClassifier, self).__init__()</span><br><span class="line">        self.hidden_size = hidden_size</span><br><span class="line">        self.n_layers = n_layers</span><br><span class="line">        self.n_directions = <span class="number">2</span> <span class="keyword">if</span> bidirectional <span class="keyword">else</span> <span class="number">1</span></span><br><span class="line">        self.embedding = torch.nn.Embedding(input_size, hidden_size)</span><br><span class="line">        self.gru = torch.nn.GRU(hidden_size, hidden_size, n_layers,</span><br><span class="line">                                bidirectional=bidirectional)</span><br><span class="line">        self.fc = torch.nn.Linear(hidden_size * self.n_directions, output_size)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_init_hidden</span>(<span class="params">self, batch_size</span>):</span></span><br><span class="line">        hidden = torch.zeros(self.n_layers * self.n_directions,</span><br><span class="line">                             batch_size, self.hidden_size)</span><br><span class="line">        <span class="keyword">return</span> create_tensor(hidden)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span>(<span class="params">self, <span class="built_in">input</span>, seq_lengths</span>):</span></span><br><span class="line">        <span class="comment"># input shape : B x S -&gt; S x B</span></span><br><span class="line">        <span class="built_in">input</span> = <span class="built_in">input</span>.t()</span><br><span class="line">        batch_size = <span class="built_in">input</span>.size(<span class="number">1</span>)</span><br><span class="line">        hidden = self._init_hidden(batch_size)</span><br><span class="line">        embedding = self.embedding(<span class="built_in">input</span>)</span><br><span class="line">        <span class="comment"># pack them up</span></span><br><span class="line">        gru_input = pack_padded_sequence(embedding, seq_lengths)</span><br><span class="line">        output, hidden = self.gru(gru_input, hidden)</span><br><span class="line">        <span class="keyword">if</span> self.n_directions == <span class="number">2</span>:</span><br><span class="line">            hidden_cat = torch.cat([hidden[-<span class="number">1</span>], hidden[-<span class="number">2</span>]], dim=<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            hidden_cat = hidden[-<span class="number">1</span>]</span><br><span class="line">        fc_output = self.fc(hidden_cat)</span><br><span class="line">        <span class="keyword">return</span> fc_output</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">name2list</span>(<span class="params">name</span>):</span></span><br><span class="line">    arr = [<span class="built_in">ord</span>(c) <span class="keyword">for</span> c <span class="keyword">in</span> name]</span><br><span class="line">    <span class="keyword">return</span> arr, <span class="built_in">len</span>(arr)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">create_tensor</span>(<span class="params">tensor</span>):</span></span><br><span class="line">    <span class="keyword">if</span> USE_GPU:</span><br><span class="line">        device = torch.device(<span class="string">&quot;cuda:0&quot;</span>)</span><br><span class="line">        tensor = tensor.to(device)</span><br><span class="line">    <span class="keyword">return</span> tensor</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">make_tensors</span>(<span class="params">names, countries</span>):</span></span><br><span class="line">    sequences_and_lengths = [name2list(name) <span class="keyword">for</span> name <span class="keyword">in</span> names]</span><br><span class="line">    name_sequences = [sl[<span class="number">0</span>] <span class="keyword">for</span> sl <span class="keyword">in</span> sequences_and_lengths]</span><br><span class="line">    seq_lengths = torch.LongTensor([sl[<span class="number">1</span>] <span class="keyword">for</span> sl <span class="keyword">in</span> sequences_and_lengths])</span><br><span class="line">    countries = countries.long()</span><br><span class="line">    <span class="comment"># make tensor of name, BatchSize x SeqLen</span></span><br><span class="line">    seq_tensor = torch.zeros(<span class="built_in">len</span>(name_sequences), seq_lengths.<span class="built_in">max</span>()).long()</span><br><span class="line">    <span class="keyword">for</span> idx, (seq, seq_len) <span class="keyword">in</span> <span class="built_in">enumerate</span>(<span class="built_in">zip</span>(name_sequences, seq_lengths), <span class="number">0</span>):</span><br><span class="line">        seq_tensor[idx, :seq_len] = torch.LongTensor(seq)</span><br><span class="line">    <span class="comment"># sort by length to use pack_padded_sequence</span></span><br><span class="line">    seq_lengths, perm_idx = seq_lengths.sort(dim=<span class="number">0</span>, descending=<span class="literal">True</span>)</span><br><span class="line">    seq_tensor = seq_tensor[perm_idx]</span><br><span class="line">    countries = countries[perm_idx]</span><br><span class="line">    <span class="keyword">return</span> create_tensor(seq_tensor), create_tensor(seq_lengths), create_tensor(countries)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">time_since</span>(<span class="params">since</span>):</span></span><br><span class="line">    s = time.time() - since</span><br><span class="line">    m = math.floor(s / <span class="number">60</span>)</span><br><span class="line">    s -= m * <span class="number">60</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;%dm %ds&#x27;</span> % (m, s)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">trainModel</span>():</span></span><br><span class="line">    total_loss = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i, (names, countries) <span class="keyword">in</span> <span class="built_in">enumerate</span>(trainloader, <span class="number">1</span>):</span><br><span class="line">        inputs, seq_lengths, target = make_tensors(names, countries)</span><br><span class="line">        output = classifier(inputs, seq_lengths)</span><br><span class="line">        loss = criterion(output, target)</span><br><span class="line">        optimizer.zero_grad()</span><br><span class="line">        loss.backward()</span><br><span class="line">        optimizer.step()</span><br><span class="line">        total_loss += loss.item()</span><br><span class="line">        <span class="keyword">if</span> i % <span class="number">10</span> == <span class="number">0</span>:</span><br><span class="line">            print(<span class="string">f&#x27;[<span class="subst">&#123;time_since(start)&#125;</span>] Epoch <span class="subst">&#123;epoch&#125;</span> &#x27;</span>, end=<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">            print(<span class="string">f&#x27;[<span class="subst">&#123;i * <span class="built_in">len</span>(inputs)&#125;</span>/<span class="subst">&#123;<span class="built_in">len</span>(trainset)&#125;</span>] &#x27;</span>, end=<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">            print(<span class="string">f&#x27;loss=<span class="subst">&#123;total_loss / (i * <span class="built_in">len</span>(inputs))&#125;</span>&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> total_loss</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">testModel</span>():</span></span><br><span class="line">    correct = <span class="number">0</span></span><br><span class="line">    total = <span class="built_in">len</span>(testset)</span><br><span class="line">    print(<span class="string">&quot;evaluating trained model ...&quot;</span>)</span><br><span class="line">    <span class="keyword">with</span> torch.no_grad():</span><br><span class="line">        <span class="keyword">for</span> i, (names, countries) <span class="keyword">in</span> <span class="built_in">enumerate</span>(testloader, <span class="number">1</span>):</span><br><span class="line">            inputs, seq_lengths, target = make_tensors(names, countries)</span><br><span class="line">            output = classifier(inputs, seq_lengths)</span><br><span class="line">            pred = output.<span class="built_in">max</span>(dim=<span class="number">1</span>, keepdim=<span class="literal">True</span>)[<span class="number">1</span>]</span><br><span class="line">            correct += pred.eq(target.view_as(pred)).<span class="built_in">sum</span>().item()</span><br><span class="line">        percent = <span class="string">&#x27;%.2f&#x27;</span> % (<span class="number">100</span> * correct / total)</span><br><span class="line">        print(<span class="string">f&#x27;Test set: Accuracy <span class="subst">&#123;correct&#125;</span>/<span class="subst">&#123;total&#125;</span> <span class="subst">&#123;percent&#125;</span>%&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> correct / total</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    classifier = RNNClassifier(N_CHARS, HIDDEN_SIZE, N_COUNTRY, N_LAYER)</span><br><span class="line">    <span class="keyword">if</span> USE_GPU:</span><br><span class="line">        device = torch.device(<span class="string">&quot;cuda:0&quot;</span>)</span><br><span class="line">        classifier.to(device)</span><br><span class="line"></span><br><span class="line">    criterion = torch.nn.CrossEntropyLoss()  <span class="comment"># 做的是分类问题，用交叉熵</span></span><br><span class="line">    optimizer = torch.optim.Adam(classifier.parameters(), lr=<span class="number">0.001</span>)</span><br><span class="line"></span><br><span class="line">    start = time.time()</span><br><span class="line">    print(<span class="string">&quot;Training for %d epochs...&quot;</span> % N_EPOCHS)</span><br><span class="line">    acc_list = []</span><br><span class="line">    <span class="keyword">for</span> epoch <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, N_EPOCHS + <span class="number">1</span>):</span><br><span class="line">        <span class="comment"># Train cycle</span></span><br><span class="line">        trainModel()</span><br><span class="line">        acc = testModel()</span><br><span class="line">        acc_list.append(acc)</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> PyTorch深度学习实践 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>PyTorch深度学习实践Part12</title>
      <link href="/2021/01/PyTorch%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%AE%9E%E8%B7%B5Part12/"/>
      <url>/2021/01/PyTorch%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%AE%9E%E8%B7%B5Part12/</url>
      
        <content type="html"><![CDATA[<h1 id="PyTorch深度学习实践Part12——循环神经网络（基础篇）"><a href="#PyTorch深度学习实践Part12——循环神经网络（基础篇）" class="headerlink" title="PyTorch深度学习实践Part12——循环神经网络（基础篇）"></a>PyTorch深度学习实践Part12——循环神经网络（基础篇）</h1><h2 id="循环神经网络RNN"><a href="#循环神经网络RNN" class="headerlink" title="循环神经网络RNN"></a>循环神经网络RNN</h2><p>之前一开始用的是稠密网络DNN，因为是全连接，所以对每个元素都有相应的权重，因此其计算量是远大于看似复杂但是具有权重共享特性的CNN的。而RNN就是延续权重共享理念的网络。</p><p>RNN主要处理有序列连接的数据，比如自然语言、天气、股市、视频等。</p><p>RNN本质是一个线性层，与DNN不同是RNN Cell是共享的。</p><p>从图像到文本的转换：CNN+FC+RNN。</p><p>循环神经网络的激活函数更常用tanh。</p><p><img src="/2021/01/PyTorch%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%AE%9E%E8%B7%B5Part12/image-20210121142256148.png" alt="image-20210121142256148"></p><p>可以选择使用RNN Cell自己构建循环，也可以使用RNN。</p><p><img src="/2021/01/PyTorch%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%AE%9E%E8%B7%B5Part12/image-20210121145441952.png" alt="image-20210121145441952"></p><h2 id="独热编码"><a href="#独热编码" class="headerlink" title="独热编码"></a>独热编码</h2><p>处理文本使用独热编码</p><p><img src="/2021/01/PyTorch%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%AE%9E%E8%B7%B5Part12/image-20210121151229487.png" alt="image-20210121151229487"></p><p><img src="/2021/01/PyTorch%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%AE%9E%E8%B7%B5Part12/image-20210121151654777.png" alt="image-20210121151654777"></p><h2 id="嵌入层"><a href="#嵌入层" class="headerlink" title="嵌入层"></a>嵌入层</h2><p>独热编码的缺点：</p><ol><li>维度高</li><li>稀疏</li><li>硬编码</li></ol><p><img src="/2021/01/PyTorch%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%AE%9E%E8%B7%B5Part12/image-20210121153403068.png" alt="image-20210121153403068"></p><p>使用Embedding改善优化</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> torch.optim <span class="keyword">as</span> optim</span><br><span class="line"></span><br><span class="line"><span class="comment"># prepare dataset</span></span><br><span class="line">num_class = <span class="number">4</span></span><br><span class="line">input_size = <span class="number">4</span></span><br><span class="line">hidden_size = <span class="number">8</span></span><br><span class="line">embedding_size = <span class="number">10</span></span><br><span class="line">num_layers = <span class="number">2</span></span><br><span class="line">batch_size = <span class="number">1</span></span><br><span class="line">seq_len = <span class="number">5</span></span><br><span class="line"></span><br><span class="line">idx2char = [<span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;h&#x27;</span>, <span class="string">&#x27;l&#x27;</span>, <span class="string">&#x27;o&#x27;</span>]</span><br><span class="line">x_data = [[<span class="number">1</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>]]  <span class="comment"># (batch, seq_len)</span></span><br><span class="line">y_data = [<span class="number">3</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">2</span>]  <span class="comment"># (batch * seq_len)</span></span><br><span class="line">inputs = torch.LongTensor(x_data)</span><br><span class="line">labels = torch.LongTensor(y_data)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># design model using class</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Model</span>(<span class="params">torch.nn.Module</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="built_in">super</span>(Model, self).__init__()</span><br><span class="line">        self.emb = torch.nn.Embedding(input_size, embedding_size)  <span class="comment"># matrix of Embedding:[input_size, embedding_size]</span></span><br><span class="line">        self.rnn = torch.nn.RNN(input_size=embedding_size,</span><br><span class="line">                                hidden_size=hidden_size,</span><br><span class="line">                                num_layers=num_layers,</span><br><span class="line">                                batch_first=<span class="literal">True</span>)</span><br><span class="line">        self.fc = torch.nn.Linear(hidden_size, num_class)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span>(<span class="params">self, x</span>):</span></span><br><span class="line">        hidden = torch.zeros(num_layers, x.size(<span class="number">0</span>), hidden_size)</span><br><span class="line">        x = self.emb(</span><br><span class="line">            x)  <span class="comment"># 这里输入需要是长整型longtensor，输出为(𝒃𝒂𝒕𝒄𝒉𝑺𝒊𝒛𝒆, 𝒔𝒆𝒒𝑳𝒆𝒏, 𝒆𝒎𝒃𝒆𝒅𝒅𝒊𝒏𝒈𝑺𝒊𝒛𝒆)，注意batch_first=True</span></span><br><span class="line">        x, _ = self.rnn(x, hidden)  <span class="comment"># 输出(𝒃𝒂𝒕𝒄𝒉𝑺𝒊𝒛𝒆, 𝒔𝒆𝒒𝑳𝒆𝒏, 𝒉𝒊𝒅𝒅𝒆𝒏𝑺𝒊𝒛e)</span></span><br><span class="line">        x = self.fc(x)</span><br><span class="line">        <span class="keyword">return</span> x.view(-<span class="number">1</span>, num_class)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">net = Model()</span><br><span class="line"></span><br><span class="line"><span class="comment"># construct loss and optimizer</span></span><br><span class="line">criterion = torch.nn.CrossEntropyLoss()</span><br><span class="line">optimizer = optim.Adam(net.parameters(), lr=<span class="number">0.05</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># training cycle forward, backward, update</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">train</span>(<span class="params">epoch</span>):</span></span><br><span class="line">    <span class="keyword">for</span> epoch <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">15</span>):</span><br><span class="line">        optimizer.zero_grad()</span><br><span class="line">    outputs = net(inputs)</span><br><span class="line">    loss = criterion(outputs, labels)</span><br><span class="line">    loss.backward()</span><br><span class="line">    optimizer.step()</span><br><span class="line">    _, idx = outputs.<span class="built_in">max</span>(dim=<span class="number">1</span>)</span><br><span class="line">    idx = idx.data.numpy()</span><br><span class="line">    print(<span class="string">&#x27;Predicted: &#x27;</span>, <span class="string">&#x27;&#x27;</span>.join([idx2char[x] <span class="keyword">for</span> x <span class="keyword">in</span> idx]), end=<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">    print(<span class="string">&#x27;, Epoch [%d/15] loss = %.3f&#x27;</span> % (epoch + <span class="number">1</span>, loss.item()))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="keyword">for</span> epoch <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">        train(epoch)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="课后作业"><a href="#课后作业" class="headerlink" title="课后作业"></a>课后作业</h2><p>使用LSTM和GRU训练模型</p><p><img src="/2021/01/PyTorch%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%AE%9E%E8%B7%B5Part12/image-20210121192740594.png" alt="image-20210121192740594"></p><p><img src="/2021/01/PyTorch%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%AE%9E%E8%B7%B5Part12/image-20210121192834591.png" alt="image-20210121192834591"></p>]]></content>
      
      
      <categories>
          
          <category> PyTorch深度学习实践 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>PyTorch深度学习实践Part11</title>
      <link href="/2021/01/PyTorch%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%AE%9E%E8%B7%B5Part11/"/>
      <url>/2021/01/PyTorch%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%AE%9E%E8%B7%B5Part11/</url>
      
        <content type="html"><![CDATA[<h1 id="PyTorch深度学习实践Part10——卷积神经网络（高级篇）"><a href="#PyTorch深度学习实践Part10——卷积神经网络（高级篇）" class="headerlink" title="PyTorch深度学习实践Part10——卷积神经网络（高级篇）"></a>PyTorch深度学习实践Part10——卷积神经网络（高级篇）</h1><h2 id="Inception"><a href="#Inception" class="headerlink" title="Inception"></a>Inception</h2><p>寻找超参数是十分困难的，GoogleNet把不同的模型作成块Inception，在训练时优秀的超参数模块权重自然增加。</p><p>Concatenate拼接四个分支算出来的张量。</p><p>不同的分支，可以有不同的channel，但要有相同的width、height。</p><p>pooling也可以设置padding=1、stride=1来保证输出大小一样。</p><p>1*1卷积，其数量取决于输入张量的通道。</p><p>1*1卷积的信息融合，是在每一个像素点多通道方面的融合。</p><p>1*1卷积主要解决运算量过大的问题，可以减少下一层输入通道数量。</p><p><img src="/2021/01/PyTorch%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%AE%9E%E8%B7%B5Part11/image-20210119191134365.png" alt="GoogleNet"></p><p><img src="/2021/01/PyTorch%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%AE%9E%E8%B7%B5Part11/image-20210120113458095.png" alt="image-20210120113458095"></p><p>最后输出的大小一般会去掉线性层，先实例化跑一遍输出size。</p><p>在写网络时，要加上一个存盘功能，即每次准确率达到新高时做一次模型数据备份，防止意外。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> torch.nn <span class="keyword">as</span> nn</span><br><span class="line"><span class="keyword">from</span> torchvision <span class="keyword">import</span> transforms</span><br><span class="line"><span class="keyword">from</span> torchvision <span class="keyword">import</span> datasets</span><br><span class="line"><span class="keyword">from</span> torch.utils.data <span class="keyword">import</span> DataLoader</span><br><span class="line"><span class="keyword">import</span> torch.nn.functional <span class="keyword">as</span> F</span><br><span class="line"><span class="keyword">import</span> torch.optim <span class="keyword">as</span> optim</span><br><span class="line"></span><br><span class="line"><span class="comment"># prepare dataset</span></span><br><span class="line"></span><br><span class="line">batch_size = <span class="number">64</span></span><br><span class="line"><span class="comment"># Compose参数列表：转为张量；归一化,均值和方差</span></span><br><span class="line">transform = transforms.Compose([transforms.ToTensor(), transforms.Normalize((<span class="number">0.1307</span>,), (<span class="number">0.3081</span>,))])</span><br><span class="line"></span><br><span class="line">train_dataset = datasets.MNIST(root=<span class="string">&#x27;../dataset/mnist/&#x27;</span>, train=<span class="literal">True</span>, download=<span class="literal">False</span>, transform=transform)</span><br><span class="line">train_loader = DataLoader(train_dataset, shuffle=<span class="literal">True</span>, batch_size=batch_size)</span><br><span class="line">test_dataset = datasets.MNIST(root=<span class="string">&#x27;../dataset/mnist/&#x27;</span>, train=<span class="literal">False</span>, download=<span class="literal">False</span>, transform=transform)</span><br><span class="line">test_loader = DataLoader(test_dataset, shuffle=<span class="literal">False</span>, batch_size=batch_size)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># design model using class</span></span><br><span class="line"><span class="comment"># network in network</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">InceptionA</span>(<span class="params">nn.Module</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, in_channels</span>):</span></span><br><span class="line">        <span class="built_in">super</span>(InceptionA, self).__init__()</span><br><span class="line">        <span class="comment"># 4条分支</span></span><br><span class="line">        <span class="comment"># 1. 1*1卷积</span></span><br><span class="line">        self.branch1x1 = nn.Conv2d(in_channels, <span class="number">16</span>, kernel_size=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 2. 1*1卷积+5*5卷积</span></span><br><span class="line">        self.branch5x5_1 = nn.Conv2d(in_channels, <span class="number">16</span>, kernel_size=<span class="number">1</span>)</span><br><span class="line">        self.branch5x5_2 = nn.Conv2d(<span class="number">16</span>, <span class="number">24</span>, kernel_size=<span class="number">5</span>, padding=<span class="number">2</span>)  <span class="comment"># 保持图像大小不变，kernel=5，则padding=2</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 3. 1*1卷积+3*3卷积+3*3卷积</span></span><br><span class="line">        self.branch3x3_1 = nn.Conv2d(in_channels, <span class="number">16</span>, kernel_size=<span class="number">1</span>)</span><br><span class="line">        self.branch3x3_2 = nn.Conv2d(<span class="number">16</span>, <span class="number">24</span>, kernel_size=<span class="number">3</span>, padding=<span class="number">1</span>)  <span class="comment"># 保持图像大小不变，kernel=3，则padding=1</span></span><br><span class="line">        self.branch3x3_3 = nn.Conv2d(<span class="number">24</span>, <span class="number">24</span>, kernel_size=<span class="number">3</span>, padding=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 4, 池化(函数)+1*1卷积</span></span><br><span class="line">        self.branch_pool = nn.Conv2d(in_channels, <span class="number">24</span>, kernel_size=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span>(<span class="params">self, x</span>):</span></span><br><span class="line">        branch1x1 = self.branch1x1(x)</span><br><span class="line"></span><br><span class="line">        branch5x5 = self.branch5x5_1(x)</span><br><span class="line">        branch5x5 = self.branch5x5_2(branch5x5)</span><br><span class="line"></span><br><span class="line">        branch3x3 = self.branch3x3_1(x)</span><br><span class="line">        branch3x3 = self.branch3x3_2(branch3x3)</span><br><span class="line">        branch3x3 = self.branch3x3_3(branch3x3)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 池化是函数，不需要训练，只在forward中调用</span></span><br><span class="line">        <span class="comment"># 池化也可以使图像大小不变。1. kernel_size=3，则padding=1；2. stride=1</span></span><br><span class="line">        branch_pool = F.avg_pool2d(x, kernel_size=<span class="number">3</span>, stride=<span class="number">1</span>, padding=<span class="number">1</span>)</span><br><span class="line">        branch_pool = self.branch_pool(branch_pool)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Concatenate</span></span><br><span class="line">        outputs = [branch1x1, branch5x5, branch3x3, branch_pool]</span><br><span class="line">        <span class="keyword">return</span> torch.cat(outputs, dim=<span class="number">1</span>)  <span class="comment"># b,c,w,h  c对应的是dim=1，沿着channel的维度拼接</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Net</span>(<span class="params">nn.Module</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="built_in">super</span>(Net, self).__init__()</span><br><span class="line">        self.conv1 = nn.Conv2d(<span class="number">1</span>, <span class="number">10</span>, kernel_size=<span class="number">5</span>)</span><br><span class="line">        self.conv2 = nn.Conv2d(<span class="number">88</span>, <span class="number">20</span>, kernel_size=<span class="number">5</span>)  <span class="comment"># 88 = 24x3 + 16</span></span><br><span class="line"></span><br><span class="line">        self.incep1 = InceptionA(in_channels=<span class="number">10</span>)  <span class="comment"># 与conv1 中的10对应</span></span><br><span class="line">        self.incep2 = InceptionA(in_channels=<span class="number">20</span>)  <span class="comment"># 与conv2 中的20对应</span></span><br><span class="line"></span><br><span class="line">        self.mp = nn.MaxPool2d(<span class="number">2</span>)  <span class="comment"># MaxPooling</span></span><br><span class="line">        self.fc = nn.Linear(<span class="number">1408</span>, <span class="number">10</span>)  <span class="comment"># FullConnecting</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span>(<span class="params">self, x</span>):</span></span><br><span class="line">        in_size = x.size(<span class="number">0</span>)</span><br><span class="line">        x = F.relu(self.mp(self.conv1(x)))</span><br><span class="line">        x = self.incep1(x)</span><br><span class="line">        x = F.relu(self.mp(self.conv2(x)))</span><br><span class="line">        x = self.incep2(x)</span><br><span class="line">        x = x.view(in_size, -<span class="number">1</span>)  <span class="comment"># -1指在不告诉函数有多少列的情况下，根据原tensor数据和batch自动分配列数</span></span><br><span class="line">        x = self.fc(x)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">model = Net()</span><br><span class="line"></span><br><span class="line"><span class="comment"># construct loss and optimizer</span></span><br><span class="line">criterion = torch.nn.CrossEntropyLoss()</span><br><span class="line">optimizer = optim.SGD(model.parameters(), lr=<span class="number">0.01</span>, momentum=<span class="number">0.5</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># training cycle</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">train</span>(<span class="params">epoch</span>):</span></span><br><span class="line">    running_loss = <span class="number">0.0</span></span><br><span class="line">    <span class="comment"># enumerate()用于可迭代\可遍历的数据对象组合为一个索引序列，同时列出数据和数据下标</span></span><br><span class="line">    <span class="keyword">for</span> batch_idx, data <span class="keyword">in</span> <span class="built_in">enumerate</span>(train_loader, <span class="number">0</span>):</span><br><span class="line">        <span class="comment"># data里面包含图像数据inputs(tensor)和标签labels(tensor)</span></span><br><span class="line">        inputs, target = data</span><br><span class="line">        optimizer.zero_grad()</span><br><span class="line">        <span class="comment"># forward</span></span><br><span class="line">        outputs = model(inputs)</span><br><span class="line">        loss = criterion(outputs, target)</span><br><span class="line">        <span class="comment"># backward</span></span><br><span class="line">        loss.backward()</span><br><span class="line">        <span class="comment"># update</span></span><br><span class="line">        optimizer.step()</span><br><span class="line"></span><br><span class="line">        running_loss += loss.item()</span><br><span class="line">        <span class="keyword">if</span> batch_idx % <span class="number">300</span> == <span class="number">299</span>:</span><br><span class="line">            print(<span class="string">&#x27;[%d, %5d] loss: %.3f&#x27;</span> % (epoch + <span class="number">1</span>, batch_idx + <span class="number">1</span>, running_loss / <span class="number">300</span>))</span><br><span class="line">            running_loss = <span class="number">0.0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test</span>():</span></span><br><span class="line">    correct = <span class="number">0</span></span><br><span class="line">    total = <span class="number">0</span></span><br><span class="line">    <span class="keyword">with</span> torch.no_grad():  <span class="comment"># 不需要计算张量</span></span><br><span class="line">        <span class="keyword">for</span> data <span class="keyword">in</span> test_loader:</span><br><span class="line">            images, labels = data</span><br><span class="line">            outputs = model(images)</span><br><span class="line">            _, predicted = torch.<span class="built_in">max</span>(outputs.data, dim=<span class="number">1</span>)</span><br><span class="line">            total += labels.size(<span class="number">0</span>)</span><br><span class="line">            correct += (predicted == labels).<span class="built_in">sum</span>().item()</span><br><span class="line">    print(<span class="string">&#x27;accuracy on test set: %d %% &#x27;</span> % (<span class="number">100</span> * correct / total))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="keyword">for</span> epoch <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">        train(epoch)</span><br><span class="line">        test()</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>``torch.max()[0]` 只返回最大值的每个数</p><p><code>troch.max()[1]</code> 只返回最大值的每个索引</p><p><code>torch.max()[1].data</code> 只返回variable中的数据部分（去掉Variable containing:）</p><p><code>torch.max()[1].data.numpy()</code> 把数据转化成numpy ndarry</p><p><code>torch.max()[1].data.numpy().squeeze()</code> 把数据条目中维度为1 的删除掉`</p><h2 id="残差网络-Residual-Net"><a href="#残差网络-Residual-Net" class="headerlink" title="残差网络(Residual Net)"></a>残差网络(Residual Net)</h2><p>随着网络层数增加，越靠近输入模块的梯度更新就越慢，很可能导致<strong>梯度消失</strong>。</p><p>为了解决梯度消失，会在激活之前加入一个跳连接。</p><p>在使用Residual Block时要保持输入和输出通道相同。</p><p>Residual Block相当于把一串Weight Layer包裹起来。</p><p>写神经网络也要写测试方法，检验输出是否和预计相同，逐步增加网络规模（增量式开发）。</p><p><img src="/2021/01/PyTorch%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%AE%9E%E8%B7%B5Part11/image-20210120182501998.png" alt="image-20210120182501998"></p><blockquote><ol><li>从数学和工程学方面重新理解深度学习理论。《深度学习》花书。</li><li>通读PyTorch文档。</li><li>复现经典工作、论文。读代码→写代码</li><li>扩充视野</li></ol></blockquote><p>两篇论文：</p><ol><li>He K, Zhang X, Ren S, et al. Identity Mappings in Deep Residual Networks[C]</li><li>Huang G, Liu Z, Laurens V D M, et al. Densely Connected Convolutional Networks[J]. 2016:2261-2269.</li></ol>]]></content>
      
      
      <categories>
          
          <category> PyTorch深度学习实践 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>PyTorch深度学习实践Part10</title>
      <link href="/2021/01/PyTorch%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%AE%9E%E8%B7%B5Part10/"/>
      <url>/2021/01/PyTorch%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%AE%9E%E8%B7%B5Part10/</url>
      
        <content type="html"><![CDATA[<h1 id="PyTorch深度学习实践Part10——卷积神经网络（基础篇）"><a href="#PyTorch深度学习实践Part10——卷积神经网络（基础篇）" class="headerlink" title="PyTorch深度学习实践Part10——卷积神经网络（基础篇）"></a>PyTorch深度学习实践Part10——卷积神经网络（基础篇）</h1><h2 id="Basic-CNN"><a href="#Basic-CNN" class="headerlink" title="Basic CNN"></a>Basic CNN</h2><p>CNN(Convolutional Neural Network)结构：特征提取+分类。</p><p><img src="/2021/01/PyTorch%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%AE%9E%E8%B7%B5Part10/image-20210118185651529.png" alt="image-20210118185651529"></p><p>通道(Channel)×纵轴(Width)×横轴(Height)，起点为左上角。</p><p><img src="/2021/01/PyTorch%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%AE%9E%E8%B7%B5Part10/image-20210118194753606.png" alt="image-20210118194753606"></p><p>Patch逐Width扫描，矩阵作数乘(哈达玛积)。</p><p><img src="/2021/01/PyTorch%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%AE%9E%E8%B7%B5Part10/image-20210118195245850.png" alt="image-20210118195245850"></p><p>多通道的卷积中，每一个通道都要配一个卷积核，并相加。</p><p>深度学习里的卷积是数学中的互相关，但是惯例称为卷积，和数学中的卷积有点不同，但是不影响。</p><p>n*n的卷积核，上下各-(n-1)/2，原长宽-(n-1)。n一般采用奇数，卷积形状一般都是正方形，在pytorch中奇偶、长方形都行。</p><p><img src="/2021/01/PyTorch%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%AE%9E%E8%B7%B5Part10/image-20210118200458601.png" alt="image-20210118200458601"></p><p>每一组卷积核的通道数量要求和输入通道是一样的。这种卷积核组的总数和输出通道的数量是一样的。卷积过后，通道就与RGB没有关系了。</p><p>卷积(convolution)后，C(Channels)变，W(width)和H(Height)可变可不变，取决于是否填充边缘(padding)，不填充则会有边缘损失。</p><p>卷积层：保留图像的空间信息。卷积本质上也是线性计算，也是可以优化的权重。</p><p>卷积神经网络要求输入输出层是四维张量(Batch, Channel, Width, Height)，卷积层是(m输出通道数量, n输入通道数量, w卷积核宽, h卷积核长)，全连接层的输入与输出都是二维张量(B, Input_feature)。</p><p><img src="/2021/01/PyTorch%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%AE%9E%E8%B7%B5Part10/image-20210118200942877.png" alt="image-20210118200942877"></p><p>下采样(subsampling)或池化(pooling)后，C不变，W和H变成 原长度/池化长度。（MaxPool2d是下采样常用的一种，n*n最大池化默认步长为n）</p><p>池化层与sigmoid一样，没有权重。</p><p><img src="/2021/01/PyTorch%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%AE%9E%E8%B7%B5Part10/image-20210118222617886.png" alt="image-20210118222617886"></p><p>卷积(线性变换)，激活函数(非线性变换)，池化；这个过程若干次后，view打平，进入全连接层。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"></span><br><span class="line">in_channels, out_channels = <span class="number">1</span>, <span class="number">10</span></span><br><span class="line">width, height = <span class="number">10</span>, <span class="number">10</span></span><br><span class="line">kernel_size = <span class="number">3</span></span><br><span class="line">batch_size = <span class="number">1</span></span><br><span class="line"><span class="built_in">input</span> = [<span class="number">3</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">7</span>, <span class="number">2</span>, <span class="number">2</span>,</span><br><span class="line">         <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">6</span>, <span class="number">6</span>, <span class="number">1</span>, <span class="number">6</span>, <span class="number">6</span>,</span><br><span class="line">         <span class="number">7</span>, <span class="number">8</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">7</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">4</span>, <span class="number">6</span>,</span><br><span class="line">         <span class="number">6</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">7</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">6</span>,</span><br><span class="line">         <span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">6</span>,</span><br><span class="line">         <span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">6</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">6</span>,</span><br><span class="line">         <span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">6</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">6</span>,</span><br><span class="line">         <span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">6</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">6</span>,</span><br><span class="line">         <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">6</span>, <span class="number">6</span>, <span class="number">1</span>, <span class="number">6</span>, <span class="number">6</span>,</span><br><span class="line">         <span class="number">7</span>, <span class="number">8</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">7</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">4</span>, <span class="number">6</span>]</span><br><span class="line"><span class="comment"># view()将其转化成4维</span></span><br><span class="line"><span class="built_in">input</span> = torch.Tensor(<span class="built_in">input</span>).view(batch_size, </span><br><span class="line">                                 in_channels, </span><br><span class="line">                                 width, </span><br><span class="line">                                 height)</span><br><span class="line"><span class="comment"># 卷积模型的构造函数中，输入通道数量在前，输出通道数量在后；但是卷积的权重shape是先输出后输入</span></span><br><span class="line"><span class="comment"># padding边缘填充，bias一般卷积不用加偏置，stride步长，kernel_size核大小</span></span><br><span class="line">conv_layer = torch.nn.Conv2d(in_channels,</span><br><span class="line">                             out_channels,</span><br><span class="line">                             kernel_size=kernel_size)</span><br><span class="line">output = conv_layer(<span class="built_in">input</span>)</span><br><span class="line">print(<span class="built_in">input</span>.shape)  <span class="comment"># torch.Size([1, 1, 10, 10])</span></span><br><span class="line">print(output.shape)  <span class="comment"># torch.Size([1, 10, 8, 8])</span></span><br><span class="line">print(conv_layer.weight.shape)  <span class="comment"># torch.Size([10, 1, 3, 3])</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p><img src="/2021/01/PyTorch%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%AE%9E%E8%B7%B5Part10/image-20210119001547566.png" alt="image-20210119001547566"></p><p><img src="/2021/01/PyTorch%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%AE%9E%E8%B7%B5Part10/image-20210119002051268.png" alt="image-20210119002051268"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">from</span> torchvision <span class="keyword">import</span> transforms</span><br><span class="line"><span class="keyword">from</span> torchvision <span class="keyword">import</span> datasets</span><br><span class="line"><span class="keyword">from</span> torch.utils.data <span class="keyword">import</span> DataLoader</span><br><span class="line"><span class="keyword">import</span> torch.nn.functional <span class="keyword">as</span> F</span><br><span class="line"><span class="keyword">import</span> torch.optim <span class="keyword">as</span> optim</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"><span class="comment"># prepare dataset</span></span><br><span class="line"></span><br><span class="line">batch_size = <span class="number">64</span></span><br><span class="line">transform = transforms.Compose([transforms.ToTensor(), transforms.Normalize((<span class="number">0.1307</span>,), (<span class="number">0.3081</span>,))])</span><br><span class="line"></span><br><span class="line">train_dataset = datasets.MNIST(root=<span class="string">&#x27;../dataset/mnist/&#x27;</span>, train=<span class="literal">True</span>, download=<span class="literal">True</span>, transform=transform)</span><br><span class="line">train_loader = DataLoader(train_dataset, shuffle=<span class="literal">True</span>, batch_size=batch_size)</span><br><span class="line">test_dataset = datasets.MNIST(root=<span class="string">&#x27;../dataset/mnist/&#x27;</span>, train=<span class="literal">False</span>, download=<span class="literal">True</span>, transform=transform)</span><br><span class="line">test_loader = DataLoader(test_dataset, shuffle=<span class="literal">False</span>, batch_size=batch_size)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># design model using class</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Net</span>(<span class="params">torch.nn.Module</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="built_in">super</span>(Net, self).__init__()</span><br><span class="line">        self.conv1 = torch.nn.Conv2d(<span class="number">1</span>, <span class="number">10</span>, kernel_size=<span class="number">5</span>)  <span class="comment"># 卷积</span></span><br><span class="line">        self.conv2 = torch.nn.Conv2d(<span class="number">10</span>, <span class="number">20</span>, kernel_size=<span class="number">5</span>)</span><br><span class="line">        self.pooling = torch.nn.MaxPool2d(<span class="number">2</span>)  <span class="comment"># 池化</span></span><br><span class="line">        self.fc = torch.nn.Linear(<span class="number">320</span>, <span class="number">10</span>)  <span class="comment"># 线性</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span>(<span class="params">self, x</span>):</span></span><br><span class="line">        <span class="comment"># flatten data from (n,1,28,28) to (n, 784)</span></span><br><span class="line">        batch_size = x.size(<span class="number">0</span>)  <span class="comment"># 先求batch，多少条记录</span></span><br><span class="line">        x = self.pooling(F.relu(self.conv1(x)))</span><br><span class="line">        x = self.pooling(F.relu(self.conv2(x)))</span><br><span class="line">        x = x.view(batch_size, -<span class="number">1</span>)  <span class="comment"># -1 此处自动算出的是320</span></span><br><span class="line">        <span class="comment"># print(&quot;x.shape&quot;,x.shape)</span></span><br><span class="line">        x = self.fc(x)</span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">model = Net()</span><br><span class="line">device = torch.device(<span class="string">&quot;cuda&quot;</span> <span class="keyword">if</span> torch.cuda.is_available() <span class="keyword">else</span> <span class="string">&quot;cpu&quot;</span>)</span><br><span class="line">model.to(device)  <span class="comment"># GPU加速</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># construct loss and optimizer</span></span><br><span class="line">criterion = torch.nn.CrossEntropyLoss()</span><br><span class="line">optimizer = optim.SGD(model.parameters(), lr=<span class="number">0.01</span>, momentum=<span class="number">0.5</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># training cycle forward, backward, update</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">train</span>(<span class="params">epoch</span>):</span></span><br><span class="line">    running_loss = <span class="number">0.0</span></span><br><span class="line">    <span class="keyword">for</span> batch_idx, data <span class="keyword">in</span> <span class="built_in">enumerate</span>(train_loader, <span class="number">0</span>):</span><br><span class="line">        inputs, target = data</span><br><span class="line">        inputs, target = inputs.to(device), target.to(device)</span><br><span class="line">        optimizer.zero_grad()</span><br><span class="line"></span><br><span class="line">        outputs = model(inputs)</span><br><span class="line">        loss = criterion(outputs, target)</span><br><span class="line">        loss.backward()</span><br><span class="line">        optimizer.step()</span><br><span class="line"></span><br><span class="line">        running_loss += loss.item()</span><br><span class="line">        <span class="keyword">if</span> batch_idx % <span class="number">300</span> == <span class="number">299</span>:</span><br><span class="line">            print(<span class="string">&#x27;[%d, %5d] loss: %.3f&#x27;</span> % (epoch + <span class="number">1</span>, batch_idx + <span class="number">1</span>, running_loss / <span class="number">300</span>))</span><br><span class="line">            running_loss = <span class="number">0.0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test</span>():</span></span><br><span class="line">    correct = <span class="number">0</span></span><br><span class="line">    total = <span class="number">0</span></span><br><span class="line">    <span class="keyword">with</span> torch.no_grad():</span><br><span class="line">        <span class="keyword">for</span> data <span class="keyword">in</span> test_loader:</span><br><span class="line">            images, labels = data</span><br><span class="line">            images, labels = images.to(device), labels.to(device)</span><br><span class="line">            outputs = model(images)</span><br><span class="line">            _, predicted = torch.<span class="built_in">max</span>(outputs.data, dim=<span class="number">1</span>)</span><br><span class="line">            total += labels.size(<span class="number">0</span>)</span><br><span class="line">            correct += (predicted == labels).<span class="built_in">sum</span>().item()</span><br><span class="line">    print(<span class="string">&#x27;accuracy on test set: %d %% &#x27;</span> % (<span class="number">100</span> * correct / total))</span><br><span class="line">    <span class="keyword">return</span> correct / total</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    epoch_list = []</span><br><span class="line">    acc_list = []</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> epoch <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">        train(epoch)</span><br><span class="line">        acc = test()</span><br><span class="line">        epoch_list.append(epoch)</span><br><span class="line">        acc_list.append(acc)</span><br><span class="line"></span><br><span class="line">    plt.plot(epoch_list, acc_list)</span><br><span class="line">    plt.ylabel(<span class="string">&#x27;accuracy&#x27;</span>)</span><br><span class="line">    plt.xlabel(<span class="string">&#x27;epoch&#x27;</span>)</span><br><span class="line">    plt.show()</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> PyTorch深度学习实践 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>PyTorch深度学习实践Part9</title>
      <link href="/2021/01/PyTorch%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%AE%9E%E8%B7%B5Part9/"/>
      <url>/2021/01/PyTorch%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%AE%9E%E8%B7%B5Part9/</url>
      
        <content type="html"><![CDATA[<h1 id="PyTorch深度学习实践Part9——多分类问题"><a href="#PyTorch深度学习实践Part9——多分类问题" class="headerlink" title="PyTorch深度学习实践Part9——多分类问题"></a>PyTorch深度学习实践Part9——多分类问题</h1><h2 id="二分类与多分类"><a href="#二分类与多分类" class="headerlink" title="二分类与多分类"></a>二分类与多分类</h2><ol><li><p>多输出之间会有抑制关系，不能用二分类分别对n个目标输出n次。</p></li><li><p>二分类对0/1只需要求对一个的概率就行，但是多分类需要研究分布差异。</p></li><li><p>中间层用Sigmoid变换，最终输出层用Softmax输出一个分布，将每个最终输出z都变化成<strong>大于0且和为1</strong>(先转正，再归一)。</p><p><img src="/2021/01/PyTorch%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%AE%9E%E8%B7%B5Part9/image-20210118152538935.png" alt="image-20210118152538935"></p><p><img src="/2021/01/PyTorch%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%AE%9E%E8%B7%B5Part9/image-20210118152129056.png" alt="image-20210118152129056"></p><p><img src="/2021/01/PyTorch%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%AE%9E%E8%B7%B5Part9/image-20210118153734193.png" alt="image-20210118153734193"></p></li><li><p>在使用交叉熵损失时，最后一层线性输出不用做激活变换。</p><p><img src="/2021/01/PyTorch%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%AE%9E%E8%B7%B5Part9/image-20210118153824744.png" alt="image-20210118153824744"></p></li><li><p>要理解 CrossEntropyLoss 和 LogSoftmax + NLLLoss 之间的区别</p><p>• <a href="https://pytorch.org/docs/stable/nn.html#crossentropyloss">https://pytorch.org/docs/stable/nn.html#crossentropyloss</a></p><p>• <a href="https://pytorch.org/docs/stable/nn.html#nllloss">https://pytorch.org/docs/stable/nn.html#nllloss</a></p></li></ol><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">from</span> torchvision <span class="keyword">import</span> transforms  <span class="comment"># 针对图像进行的处理</span></span><br><span class="line"><span class="keyword">from</span> torchvision <span class="keyword">import</span> datasets</span><br><span class="line"><span class="keyword">from</span> torch.utils.data <span class="keyword">import</span> DataLoader</span><br><span class="line"><span class="keyword">import</span> torch.nn.functional <span class="keyword">as</span> F</span><br><span class="line"><span class="keyword">import</span> torch.optim <span class="keyword">as</span> optim</span><br><span class="line"></span><br><span class="line"><span class="comment"># prepare dataset</span></span><br><span class="line"></span><br><span class="line">batch_size = <span class="number">64</span></span><br><span class="line"><span class="comment"># 神经网络输入值在[-1,1]效果最好，服从正态分布</span></span><br><span class="line"><span class="comment"># 构建的是Compose类的对象，参数是列表[]</span></span><br><span class="line"><span class="comment"># transforms.ToTensor()：PIL Image =&gt; PyTorch Tensor，单通道变多通道</span></span><br><span class="line"><span class="comment"># transforms.Normalize((mean,), (std,)：归一化，正态分布需要的期望和标准差，映射到[0,1]分布。数据是算好的，换成标准之后可以解决梯度爆炸问题</span></span><br><span class="line">transform = transforms.Compose([transforms.ToTensor(), transforms.Normalize((<span class="number">0.1307</span>,), (<span class="number">0.3081</span>,))])</span><br><span class="line"></span><br><span class="line">train_dataset = datasets.MNIST(root=<span class="string">&#x27;../dataset/mnist/&#x27;</span>, train=<span class="literal">True</span>, download=<span class="literal">True</span>, transform=transform)</span><br><span class="line">train_loader = DataLoader(train_dataset, shuffle=<span class="literal">True</span>, batch_size=batch_size)</span><br><span class="line">test_dataset = datasets.MNIST(root=<span class="string">&#x27;../dataset/mnist/&#x27;</span>, train=<span class="literal">False</span>, download=<span class="literal">True</span>, transform=transform)</span><br><span class="line">test_loader = DataLoader(test_dataset, shuffle=<span class="literal">False</span>, batch_size=batch_size)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># design model using class</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Net</span>(<span class="params">torch.nn.Module</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="built_in">super</span>(Net, self).__init__()</span><br><span class="line">        self.linear1 = torch.nn.Linear(<span class="number">784</span>, <span class="number">512</span>)</span><br><span class="line">        self.linear2 = torch.nn.Linear(<span class="number">512</span>, <span class="number">256</span>)</span><br><span class="line">        self.linear3 = torch.nn.Linear(<span class="number">256</span>, <span class="number">128</span>)</span><br><span class="line">        self.linear4 = torch.nn.Linear(<span class="number">128</span>, <span class="number">64</span>)</span><br><span class="line">        self.linear5 = torch.nn.Linear(<span class="number">64</span>, <span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span>(<span class="params">self, x</span>):</span></span><br><span class="line">        x = x.view(-<span class="number">1</span>, <span class="number">784</span>)  <span class="comment"># -1自动获取mini-batch：N。把样本[N,1,28,28]转变成[N,784]</span></span><br><span class="line">        x = F.relu(self.linear1(x))</span><br><span class="line">        x = F.relu(self.linear2(x))</span><br><span class="line">        x = F.relu(self.linear3(x))</span><br><span class="line">        x = F.relu(self.linear4(x))</span><br><span class="line">        <span class="keyword">return</span> self.linear5(x)  <span class="comment"># 最后一层不做非线性变换</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">model = Net()</span><br><span class="line"></span><br><span class="line"><span class="comment"># construct loss and optimizer</span></span><br><span class="line">criterion = torch.nn.CrossEntropyLoss()</span><br><span class="line">optimizer = optim.SGD(model.parameters(), lr=<span class="number">0.01</span>, momentum=<span class="number">0.5</span>)  <span class="comment"># momentum冲量</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># training cycle</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">train</span>(<span class="params">epoch</span>):</span></span><br><span class="line">    running_loss = <span class="number">0.0</span></span><br><span class="line">    <span class="keyword">for</span> batch_idx, data <span class="keyword">in</span> <span class="built_in">enumerate</span>(train_loader, <span class="number">0</span>):</span><br><span class="line">        inputs, target = data</span><br><span class="line">        optimizer.zero_grad()</span><br><span class="line"></span><br><span class="line">        <span class="comment"># forward</span></span><br><span class="line">        outputs = model(inputs)</span><br><span class="line">        loss = criterion(outputs, target)</span><br><span class="line">        <span class="comment"># backward</span></span><br><span class="line">        loss.backward()</span><br><span class="line">        <span class="comment"># update</span></span><br><span class="line">        optimizer.step()</span><br><span class="line"></span><br><span class="line">        running_loss += loss.item()</span><br><span class="line">        <span class="keyword">if</span> batch_idx % <span class="number">300</span> == <span class="number">299</span>:</span><br><span class="line">            print(<span class="string">&#x27;[%d, %5d] loss: %.3f&#x27;</span> % (epoch + <span class="number">1</span>, batch_idx + <span class="number">1</span>, running_loss / <span class="number">300</span>))</span><br><span class="line">            running_loss = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test</span>():</span></span><br><span class="line">    correct = <span class="number">0</span></span><br><span class="line">    total = <span class="number">0</span></span><br><span class="line">    <span class="keyword">with</span> torch.no_grad():  <span class="comment"># 包裹的一部分不会构建计算图</span></span><br><span class="line">        <span class="keyword">for</span> data <span class="keyword">in</span> test_loader:</span><br><span class="line">            images, labels = data</span><br><span class="line">            outputs = model(images)</span><br><span class="line">            _, predicted = torch.<span class="built_in">max</span>(outputs.data, dim=<span class="number">1</span>)  <span class="comment"># 列是dim=0，行是dim=1。返回最大值和最大值的下标</span></span><br><span class="line">            total += labels.size(<span class="number">0</span>)</span><br><span class="line">            correct += (predicted == labels).<span class="built_in">sum</span>().item()  <span class="comment"># 序列求和，一共猜对的数量</span></span><br><span class="line">    print(<span class="string">&#x27;accuracy on test set: %d %% &#x27;</span> % (<span class="number">100</span> * correct / total))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="keyword">for</span> epoch <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">        train(epoch)</span><br><span class="line">        test()</span><br><span class="line"></span><br><span class="line"><span class="comment"># [1,   300] loss: 2.244</span></span><br><span class="line"><span class="comment"># [1,   600] loss: 1.005</span></span><br><span class="line"><span class="comment"># [1,   900] loss: 0.437</span></span><br><span class="line"><span class="comment"># ..........................</span></span><br><span class="line"><span class="comment"># [8,   300] loss: 0.045</span></span><br><span class="line"><span class="comment"># [8,   600] loss: 0.051</span></span><br><span class="line"><span class="comment"># [8,   900] loss: 0.048</span></span><br><span class="line"><span class="comment"># accuracy on test set: 97 % </span></span><br><span class="line"><span class="comment"># [9,   300] loss: 0.034</span></span><br><span class="line"><span class="comment"># [9,   600] loss: 0.039</span></span><br><span class="line"><span class="comment"># [9,   900] loss: 0.044</span></span><br><span class="line"><span class="comment"># accuracy on test set: 97 % </span></span><br><span class="line"><span class="comment"># [10,   300] loss: 0.030</span></span><br><span class="line"><span class="comment"># [10,   600] loss: 0.027</span></span><br><span class="line"><span class="comment"># [10,   900] loss: 0.036</span></span><br><span class="line"><span class="comment"># accuracy on test set: 96 %</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><ol><li><a href="https://blog.csdn.net/Answer3664/article/details/99460175">torch.no_grad()</a>  <a href="https://blog.csdn.net/ego_bai/article/details/80873242">Python中with的用法</a></li><li><a href="https://zhuanlan.zhihu.com/p/105783765?utm_source=com.miui.notes">Python中各种下划线的操作</a> </li><li><a href="https://blog.csdn.net/Z_lbj/article/details/79766690">torch.max( )的用法</a> <a href="https://blog.csdn.net/qq_40210586/article/details/103874000">torch.max( )使用讲解</a></li><li>用全连接神经网络训练图像会忽略局部信息的利用，在距离很远的两个点都会产生联系，而这个是没必要的。</li><li>图像的特征提取：傅里叶变换（缺点：都是正弦波）、Wavelet、小波。但是这些都是人工提取。自动提取的有：CNN</li></ol>]]></content>
      
      
      <categories>
          
          <category> PyTorch深度学习实践 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>PyTorch深度学习实践Part8</title>
      <link href="/2021/01/PyTorch%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%AE%9E%E8%B7%B5Part8/"/>
      <url>/2021/01/PyTorch%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%AE%9E%E8%B7%B5Part8/</url>
      
        <content type="html"><![CDATA[<h1 id="PyTorch深度学习实践Part8——加载数据集"><a href="#PyTorch深度学习实践Part8——加载数据集" class="headerlink" title="PyTorch深度学习实践Part8——加载数据集"></a>PyTorch深度学习实践Part8——加载数据集</h1><h2 id="Dataset-and-DataLoader"><a href="#Dataset-and-DataLoader" class="headerlink" title="Dataset and DataLoader"></a>Dataset and DataLoader</h2><ol><li><p>Dataset：主要构造数据集，支持索引。</p></li><li><p>DataLoader：主要能拿出mini-batch，拿出一组组数据以快速使用。</p><p>改成mini-batch之后，训练循环会变成一个二层的嵌套循环，第一层迭代epoch，第二层迭代mini-batch。</p></li><li><p>Epoch：将所有的样本都参与了一次正向传播、训练，是一次epoch。</p></li><li><p>Batch-Size：每次训练(前馈+反馈+更新)所用的样本数量。</p></li><li><p>Iteration：batch分了多少批，内层的迭代执行多少次。例如：1w个样本，1k个batch，iteration为10。</p></li></ol><p><img src="/2021/01/PyTorch%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%AE%9E%E8%B7%B5Part8/image-20210118100748425.png" alt="image-20210118100748425"></p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>处理数据方式</p><ol><li>全部读取到内存，适用于关系表或者小批量结构化的数据。</li><li>将数据文件分开，路径存放在列表中打包，适用于图像、音频等非结构化数据。</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">from</span> torch.utils.data <span class="keyword">import</span> DataLoader</span><br><span class="line"><span class="keyword">from</span> torch.utils.data <span class="keyword">import</span> Dataset  <span class="comment"># Dataset是抽象类，需要继承</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 处理数据</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DiabetesDataset</span>(<span class="params">Dataset</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, filepath</span>):</span>  <span class="comment"># 初始化，提供数据集路径加载</span></span><br><span class="line">        xy = np.loadtxt(filepath, delimiter=<span class="string">&#x27;,&#x27;</span>, dtype=np.float32)</span><br><span class="line">        self.<span class="built_in">len</span> = xy.shape[<span class="number">0</span>]  <span class="comment"># shape(行数,列数)是元组</span></span><br><span class="line">        self.x_data = torch.from_numpy(xy[:, :-<span class="number">1</span>])</span><br><span class="line">        self.y_data = torch.from_numpy(xy[:, [-<span class="number">1</span>]])</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getitem__</span>(<span class="params">self, index</span>):</span>  <span class="comment"># 获取数据索引</span></span><br><span class="line">        <span class="keyword">return</span> self.x_data[index], self.y_data[index]  <span class="comment"># 返回的是元组</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__len__</span>(<span class="params">self</span>):</span>  <span class="comment"># 获取数据总量</span></span><br><span class="line">        <span class="keyword">return</span> self.<span class="built_in">len</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">dataset = DiabetesDataset(<span class="string">&#x27;diabetes.csv.gz&#x27;</span>)</span><br><span class="line"><span class="comment"># shuffle=True打乱mini-batch保证随机，num_workers多线程</span></span><br><span class="line">train_loader = DataLoader(dataset=dataset, batch_size=<span class="number">32</span>, shuffle=<span class="literal">True</span>, num_workers=<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建模型</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Model</span>(<span class="params">torch.nn.Module</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="built_in">super</span>(Model, self).__init__()</span><br><span class="line">        self.linear1 = torch.nn.Linear(<span class="number">8</span>, <span class="number">6</span>)</span><br><span class="line">        self.linear2 = torch.nn.Linear(<span class="number">6</span>, <span class="number">4</span>)</span><br><span class="line">        self.linear3 = torch.nn.Linear(<span class="number">4</span>, <span class="number">1</span>)</span><br><span class="line">        self.activate = torch.nn.Sigmoid()  <span class="comment"># 是模块而不是函数，没有参数，没有需要训练的地方，只用来构建计算图</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span>(<span class="params">self, x</span>):</span></span><br><span class="line">        x = self.activate(self.linear1(x))</span><br><span class="line">        x = self.activate(self.linear2(x))</span><br><span class="line">        x = self.activate(self.linear3(x))</span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">model = Model()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 损失&amp;优化</span></span><br><span class="line">criterion = torch.nn.BCELoss(reduction=<span class="string">&#x27;mean&#x27;</span>)</span><br><span class="line"><span class="comment"># model.parameters()会扫描module中的所有成员，如果成员中有相应权重，那么都会将结果加到要训练的参数集合上</span></span><br><span class="line">optimizer = torch.optim.SGD(model.parameters(), lr=<span class="number">1</span>)</span><br><span class="line">loss_list = []</span><br><span class="line"></span><br><span class="line"><span class="comment"># 循环训练</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:  <span class="comment"># 在windows系统下要用if封装训练循环，否则会报错</span></span><br><span class="line">    <span class="keyword">for</span> epoch <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">100</span>):</span><br><span class="line">        loss_sum = <span class="number">0</span></span><br><span class="line">        num = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i, data <span class="keyword">in</span> <span class="built_in">enumerate</span>(train_loader, <span class="number">0</span>):</span><br><span class="line">            <span class="comment"># prepare data</span></span><br><span class="line">            inputs, labels = data  <span class="comment"># 此时两个已经转化成tensor</span></span><br><span class="line">            <span class="comment"># Forward</span></span><br><span class="line">            y_pred = model(inputs)</span><br><span class="line">            loss = criterion(y_pred, labels)</span><br><span class="line">            print(epoch, i, loss.item())</span><br><span class="line"></span><br><span class="line">            loss_sum += loss.item()</span><br><span class="line">            num += <span class="number">1</span></span><br><span class="line">            <span class="comment"># Backward</span></span><br><span class="line">            optimizer.zero_grad()</span><br><span class="line">            loss.backward()</span><br><span class="line">            <span class="comment"># Update</span></span><br><span class="line">            optimizer.step()</span><br><span class="line"></span><br><span class="line">        loss_list.append(loss_sum / num)</span><br><span class="line"></span><br><span class="line">    plt.plot(<span class="built_in">range</span>(<span class="number">100</span>), loss_list)</span><br><span class="line">    plt.ylabel(<span class="string">&#x27;loss&#x27;</span>)</span><br><span class="line">    plt.xlabel(<span class="string">&#x27;epoch&#x27;</span>)</span><br><span class="line">    plt.show()</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="/2021/01/PyTorch%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%AE%9E%E8%B7%B5Part8/image-20210118110538070.png" alt="image-20210118110538070"></p><p>二层循环速度反而变慢了，效率也没有很大提升？t</p>]]></content>
      
      
      <categories>
          
          <category> PyTorch深度学习实践 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>PyTorch深度学习实践Part7</title>
      <link href="/2021/01/PyTorch%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%AE%9E%E8%B7%B5Part7/"/>
      <url>/2021/01/PyTorch%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%AE%9E%E8%B7%B5Part7/</url>
      
        <content type="html"><![CDATA[<h1 id="PyTorch深度学习实践Part7——处理多维特征的输入"><a href="#PyTorch深度学习实践Part7——处理多维特征的输入" class="headerlink" title="PyTorch深度学习实践Part7——处理多维特征的输入"></a>PyTorch深度学习实践Part7——处理多维特征的输入</h1><h2 id="多维特征输入"><a href="#多维特征输入" class="headerlink" title="多维特征输入"></a>多维特征输入</h2><p>从单一特征的数据，转而输入多为特征的数据，模型发生以下改变：</p><ol><li><p>对于每一条(/第i条)有n个特征(x1…xn)的数据，则有n个不同的weight(w1…wn)和1个相同的bias(b将进行广播)，并通过非线性激活函数，得出一个y_hat（假设输出维度为1）。</p><p><img src="/2021/01/PyTorch%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%AE%9E%E8%B7%B5Part7/image-20210117203233443.png" alt="image-20210117203233443"></p></li><li><p>对于每个zn(=xn*wn+b)都要通过非线性激活函数，Sigmoid函数是对于每个元素的，类似于numpy。</p><p><img src="/2021/01/PyTorch%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%AE%9E%E8%B7%B5Part7/image-20210117203726634.png" alt="image-20210117203726634"></p></li><li><p>转换成矩阵运算可以发挥cpu/gpu并行运算的优势。</p></li><li><p>在之前的代码上，想要进行多维输入，只需要修改样本以及模型构造函数。</p></li></ol><h2 id="增加神经网络层数"><a href="#增加神经网络层数" class="headerlink" title="增加神经网络层数"></a>增加神经网络层数</h2><ol><li>如何增加神经网络层数？将多层模型输入和输出，<strong>头尾相连</strong>。例如：torch.nn.Linear(8, 6)、torch.nn.Linear(6, 4)、torch.nn.Linear(4, 1)。</li><li>什么是矩阵？矩阵是<strong>空间变换函数</strong>。例如：y=A*x，y是M×1的矩阵，x是N×1的矩阵，A是M×N的矩阵，则A就是将x从N维转换到y这个M维空间的空间变换函数。</li><li>矩阵是线性变换，但是很多实际情况都是复杂、非线性的。所以，需要用多个线性变换层，通过找到最优的权重组合起来，来模拟非线性的变换。<strong>寻找非线性变换函数</strong>，就是神经网络的本质。</li><li>多层神经网络可以降维也可以升维，至于如何达到最优，则是<strong>超参数的搜索</strong>。</li><li>神经元、网络层数越多，学习能力就越强，但是同时要小心过拟合的问题。要学习数据真值和具备泛化的能力。</li></ol><p><img src="/2021/01/PyTorch%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%AE%9E%E8%B7%B5Part7/image-20210117212227590.png" alt="image-20210117212227590"></p><blockquote><p><strong>能在编程道路上立稳脚跟的核心能力：</strong></p><ol><li>读文档</li><li>基本架构理念(cpu、操作系统、主机、编译原理)</li></ol></blockquote><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 处理数据</span></span><br><span class="line">xy = np.loadtxt(<span class="string">&#x27;diabetes.csv.gz&#x27;</span>, delimiter=<span class="string">&#x27;,&#x27;</span>, dtype=np.float32)  <span class="comment"># 分隔符&#x27;,&#x27;，大多数显卡只支持32位float</span></span><br><span class="line">x_data = torch.from_numpy(xy[:, :-<span class="number">1</span>])  <span class="comment"># 左闭右开，取所有行、第一列到最后第二列。torch.from_numpy返回tensor</span></span><br><span class="line">y_data = torch.from_numpy(xy[:, [-<span class="number">1</span>]])  <span class="comment"># 取所有行、最后一列。[-1]表示拿出来的是矩阵，-1表示拿出来的是向量</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建模型</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Model</span>(<span class="params">torch.nn.Module</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="built_in">super</span>(Model, self).__init__()</span><br><span class="line">        self.linear1 = torch.nn.Linear(<span class="number">8</span>, <span class="number">6</span>)</span><br><span class="line">        self.linear2 = torch.nn.Linear(<span class="number">6</span>, <span class="number">4</span>)</span><br><span class="line">        self.linear3 = torch.nn.Linear(<span class="number">4</span>, <span class="number">1</span>)</span><br><span class="line">        self.activate = torch.nn.Sigmoid()  <span class="comment"># 是模块而不是函数，没有参数，没有需要训练的地方，只用来构建计算图</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span>(<span class="params">self, x</span>):</span></span><br><span class="line">        x = self.activate(self.linear1(x))</span><br><span class="line">        x = self.activate(self.linear2(x))</span><br><span class="line">        x = self.activate(self.linear3(x))</span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">model = Model()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 损失&amp;优化</span></span><br><span class="line">criterion = torch.nn.BCELoss(reduction=<span class="string">&#x27;mean&#x27;</span>)</span><br><span class="line">optimizer = torch.optim.SGD(model.parameters(), lr=<span class="number">1.0</span>)</span><br><span class="line">loss_list = []</span><br><span class="line"></span><br><span class="line"><span class="comment"># 循环训练</span></span><br><span class="line"><span class="keyword">for</span> epoch <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">500000</span>):</span><br><span class="line">    <span class="comment"># Forward</span></span><br><span class="line">    y_pred = model(x_data)  <span class="comment"># 这里并没有用到mini-batch</span></span><br><span class="line">    loss = criterion(y_pred, y_data)</span><br><span class="line">    print(epoch, loss.item())</span><br><span class="line">    loss_list.append(loss.item())</span><br><span class="line">    <span class="comment"># Backward</span></span><br><span class="line">    optimizer.zero_grad()</span><br><span class="line">    loss.backward()</span><br><span class="line">    <span class="comment"># Update</span></span><br><span class="line">    optimizer.step()</span><br><span class="line"></span><br><span class="line">plt.plot(<span class="built_in">range</span>(<span class="number">500000</span>), loss_list)</span><br><span class="line">plt.ylabel(<span class="string">&#x27;loss&#x27;</span>)</span><br><span class="line">plt.xlabel(<span class="string">&#x27;epoch&#x27;</span>)</span><br><span class="line">plt.show()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看不同网络层参数</span></span><br><span class="line">layer1_weight = model.linear1.weight.data</span><br><span class="line">layer1_bias = model.linear1.bias.data</span><br><span class="line">print(<span class="string">&quot;layer1_weight&quot;</span>, layer1_weight)</span><br><span class="line">print(<span class="string">&quot;layer1_weight.shape&quot;</span>, layer1_weight.shape)</span><br><span class="line">print(<span class="string">&quot;layer1_bias&quot;</span>, layer1_bias)</span><br><span class="line">print(<span class="string">&quot;layer1_bias.shape&quot;</span>, layer1_bias.shape)</span><br><span class="line"></span><br></pre></td></tr></table></figure><ol><li>在100次训练时，损失卡在了0.65。</li><li>在1w次训练时，损失跨过0.65停在了0.45。</li><li>将学习率提升到10.0，1w次训练可以看出图像震荡，无法收敛，但是损失突破0.4以下。</li><li>将学习率调整到1.0，10w次训练，损失突破0.3以下</li><li>学习率1.0，50w次训练，损失达到0.28</li><li><a href="https://pytorch.org/docs/stable/nn.html#non-linear-activations-weighted-sum-nonlinearity">pytorch激活函数文档</a></li></ol><p><img src="/2021/01/PyTorch%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%AE%9E%E8%B7%B5Part7/image-20210117233025403.png" alt="image-20210117233025403"></p><p><img src="/2021/01/PyTorch%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%AE%9E%E8%B7%B5Part7/image-20210117235832948.png" alt="image-20210117235832948"></p>]]></content>
      
      
      <categories>
          
          <category> PyTorch深度学习实践 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>PyTorch深度学习实践Part6</title>
      <link href="/2021/01/PyTorch%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%AE%9E%E8%B7%B5Part6/"/>
      <url>/2021/01/PyTorch%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%AE%9E%E8%B7%B5Part6/</url>
      
        <content type="html"><![CDATA[<h1 id="PyTorch深度学习实践Part6——逻辑斯蒂回归"><a href="#PyTorch深度学习实践Part6——逻辑斯蒂回归" class="headerlink" title="PyTorch深度学习实践Part6——逻辑斯蒂回归"></a>PyTorch深度学习实践Part6——逻辑斯蒂回归</h1><h2 id="分类问题"><a href="#分类问题" class="headerlink" title="分类问题"></a>分类问题</h2><p>逻辑斯蒂回归是处理分类问题，而不是回归任务。</p><p>处理分类问题，不能使用回归的思想，即使输出可以为0或1。原因在于：若有一个0-9，10个手写数字的分类问题，在回归模型中，1和0距离很近，0和9离得很远，但是在分类模型中，7和9的相似度就比8与7或9的相似度要高。</p><p>分类问题本质上输出的是概率，例如P(0)、P(1)…。</p><h3 id="二分类问题"><a href="#二分类问题" class="headerlink" title="二分类问题"></a>二分类问题</h3><p>通过考试的概率是多少</p><h3 id="多分类问题"><a href="#多分类问题" class="headerlink" title="多分类问题"></a>多分类问题</h3><p>0-9手写数字检测分类</p><h2 id="torchvision工具包"><a href="#torchvision工具包" class="headerlink" title="torchvision工具包"></a>torchvision工具包</h2><p>指定目录，训练/测试，是否需要下载</p><p>MNIST、CIFAR10…</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torchvision</span><br><span class="line">train_set = torchvision.datasets.MNIST(root=<span class="string">&#x27;../dataset/mnist&#x27;</span>, train=<span class="literal">True</span>, download=<span class="literal">True</span>)</span><br><span class="line">test_set = torchvision.datasets.MNIST(root=<span class="string">&#x27;../dataset/mnist&#x27;</span>, train=<span class="literal">False</span>, download=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure><h2 id="饱和函数"><a href="#饱和函数" class="headerlink" title="饱和函数"></a>饱和函数</h2><h3 id="逻辑斯蒂函数"><a href="#逻辑斯蒂函数" class="headerlink" title="逻辑斯蒂函数"></a>逻辑斯蒂函数</h3><p><img src="/2021/01/PyTorch%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%AE%9E%E8%B7%B5Part6/image-20210117161720715.png" alt="image-20210117161720715"></p><h3 id="其他Sigmoid-functions"><a href="#其他Sigmoid-functions" class="headerlink" title="其他Sigmoid functions"></a>其他Sigmoid functions</h3><p><img src="/2021/01/PyTorch%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%AE%9E%E8%B7%B5Part6/image-20210117161834404.png" alt="image-20210117161834404"></p><h2 id="逻辑斯蒂回归"><a href="#逻辑斯蒂回归" class="headerlink" title="逻辑斯蒂回归"></a>逻辑斯蒂回归</h2><ol><li><p>Logistic Regression类似于正态分布。</p></li><li><p>Logistic Regression是Sigmoid functions中最著名的，所以有些地方用Sigmoid指代Logistic。</p></li><li><p>逻辑斯蒂回归和线性模型的明显区别是在线性模型的后面，添加了激活函数(非线性变换)，将y_hat代入逻辑斯蒂公式中的x。</p></li><li><p><a href="https://blog.csdn.net/C_chuxin/article/details/86174807">交叉熵损失函数的推导过程与直观理解</a></p></li><li><p>y_hat是预测的值[0,1]之间的概率，y是真实值，预测与标签越接近，BCE损失越小。</p></li></ol><p><img src="/2021/01/PyTorch%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%AE%9E%E8%B7%B5Part6/image-20210117164616620.png" alt="image-20210117164616620"></p><blockquote><p>要计算的是分布的差异，而不是数值上的距离</p></blockquote><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><ol><li><a href="https://blog.csdn.net/weixin_42621901/article/details/107664771">torch.sigmoid()、torch.nn.Sigmoid()和torch.nn.functional.sigmoid()三者之间的区别</a></li><li>BCELoss(Binary CrossEntropyLoss)是CrossEntropyLoss的一个特例，只用于二分类问题，而CrossEntropyLoss可以用于二分类，也可以用于多分类。</li><li><a href="https://www.cnblogs.com/samwoog/p/13857843.html">BCE和CE交叉熵损失函数的区别</a></li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"><span class="comment"># ---------------------------Prepare dataset----------------------------#</span></span><br><span class="line">x_data = torch.Tensor([[<span class="number">1.0</span>], [<span class="number">2.0</span>], [<span class="number">3.0</span>]])</span><br><span class="line">y_data = torch.Tensor([[<span class="number">0</span>], [<span class="number">0</span>], [<span class="number">1</span>]])  <span class="comment"># 二分类</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># ---------------------------Design model using Class----------------------------#</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LogisticRegressionModel</span>(<span class="params">torch.nn.Module</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="built_in">super</span>(LogisticRegressionModel, self).__init__()</span><br><span class="line">        self.linear = torch.nn.Linear(<span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># nn.functional.sigmoid is deprecated</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span>(<span class="params">self, x</span>):</span></span><br><span class="line">        <span class="keyword">return</span> torch.sigmoid(self.linear(x))  <span class="comment"># 激活函数sigmoid不需要参数训练，直接调用</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">model = LogisticRegressionModel()</span><br><span class="line"><span class="comment"># --------------------------Construct loss and optimizer-----------------------------#</span></span><br><span class="line">criterion = torch.nn.BCELoss(reduction=<span class="string">&#x27;sum&#x27;</span>)  <span class="comment"># 交叉熵，size_average=False已经被弃用</span></span><br><span class="line">optimizer = torch.optim.SGD(model.parameters(), lr=<span class="number">0.01</span>)</span><br><span class="line"><span class="comment"># --------------------------Training cycle-----------------------------#</span></span><br><span class="line">loss_list = []</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> epoch <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1000</span>):</span><br><span class="line">    y_pred = model(x_data)  <span class="comment"># 正向传播</span></span><br><span class="line">    loss = criterion(y_pred, y_data)  <span class="comment"># 计算损失</span></span><br><span class="line">    print(epoch, loss.item())</span><br><span class="line">    loss_list.append(loss.item())  <span class="comment"># 保存loss</span></span><br><span class="line"></span><br><span class="line">    optimizer.zero_grad()  <span class="comment"># 将梯度归零</span></span><br><span class="line">    loss.backward()  <span class="comment"># 反向传播</span></span><br><span class="line">    optimizer.step()  <span class="comment"># 进行更新</span></span><br><span class="line"></span><br><span class="line">print(<span class="string">&#x27;w = &#x27;</span>, model.linear.weight.item())</span><br><span class="line">print(<span class="string">&#x27;b = &#x27;</span>, model.linear.bias.item())</span><br><span class="line"></span><br><span class="line">x_test = torch.Tensor([[<span class="number">4.0</span>]])</span><br><span class="line">y_test = model(x_test)</span><br><span class="line">print(<span class="string">&#x27;y_pred = &#x27;</span>, y_test.item())</span><br><span class="line"></span><br><span class="line">plt.plot(<span class="built_in">range</span>(<span class="number">1000</span>), loss_list)</span><br><span class="line">plt.ylabel(<span class="string">&#x27;Loss&#x27;</span>)</span><br><span class="line">plt.xlabel(<span class="string">&#x27;Epoch&#x27;</span>)</span><br><span class="line">plt.show()</span><br><span class="line"><span class="comment"># y_pred =  0.8808996081352234</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="/2021/01/PyTorch%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%AE%9E%E8%B7%B5Part6/image-20210117172329760.png" alt="image-20210117172329760"></p>]]></content>
      
      
      <categories>
          
          <category> PyTorch深度学习实践 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>PyTorch深度学习实践Part5</title>
      <link href="/2021/01/PyTorch%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%AE%9E%E8%B7%B5Part5/"/>
      <url>/2021/01/PyTorch%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%AE%9E%E8%B7%B5Part5/</url>
      
        <content type="html"><![CDATA[<h1 id="PyTorch深度学习实践Part5——线性回归"><a href="#PyTorch深度学习实践Part5——线性回归" class="headerlink" title="PyTorch深度学习实践Part5——线性回归"></a>PyTorch深度学习实践Part5——线性回归</h1><h2 id="PyTorch周期"><a href="#PyTorch周期" class="headerlink" title="PyTorch周期"></a>PyTorch周期</h2><ol><li>prepare dataset</li><li>design model using Class 目的是为了前馈forward，即计算y hat(预测值)</li><li>Construct loss and optimizer (using PyTorch API) 其中，计算loss是为了进行反向传播，optimizer是为了更新梯度。</li><li>Training cycle (<u><strong><em>forward,backward,update</em></strong></u>)</li></ol><h2 id="广播"><a href="#广播" class="headerlink" title="广播"></a>广播</h2><p>原本w只是1×1的矩阵，比如tensor([0.], requires_grad=True)，很有可能行列数量与xy对不上，这个时候pytorch会进行<strong>广播</strong>，将w<strong>扩展成一个3×1矩阵</strong>。</p><p><img src="/2021/01/PyTorch%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%AE%9E%E8%B7%B5Part5/image-20210117122903497.png" alt="image-20210117122903497"></p><blockquote><p>pytorch直接写“*”表示矩阵<strong>对应位置元素相乘</strong>（哈达玛积），数学上的矩阵乘法有另外的函数torch.matmul</p></blockquote><p>这里x、y的维度都是1（有可能不是1），但是都应当看成一个<strong>矩阵</strong>，而不能是向量。</p><blockquote><p>x、y的列是维度/特征，行是记录/样本</p></blockquote><h2 id="模型"><a href="#模型" class="headerlink" title="模型"></a>模型</h2><ol><li>要把计算模型定义成一个类，<strong>继承于torch.nn.Model</strong>。（nn：neural network）</li><li>如果有pytorch没有提供的需求，或者其效率不够高，可以从Function中继承，构造自己的计算块。</li><li>Linear类包括成员变量weight和bias，默认bias=True，同样继承于torch.nn.Model，可以进行反向传播。</li><li>权重放在x右边，或者转置放在左边。（不管怎么放都是为了凑矩阵基本积）</li><li>父类实现了callable函数，让其能够被调用。在call中会调用前馈forward()，所以必须重写forward()。</li></ol><p><img src="/2021/01/PyTorch%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%AE%9E%E8%B7%B5Part5/image-20210117132843838.png" alt="image-20210117132843838"></p><p>*args, **kwargs的用法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fun</span>(<span class="params">*args, **kwargs</span>):</span></span><br><span class="line">    print(<span class="string">&#x27;args:&#x27;</span>, args)</span><br><span class="line">    print(<span class="string">&#x27;kwargs:&#x27;</span>, kwargs)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">fun(<span class="number">1</span>, <span class="number">2</span>, <span class="number">7</span>, x=<span class="number">6</span>, y=<span class="number">5</span>)</span><br><span class="line"><span class="comment"># args: (1, 2, 7)</span></span><br><span class="line"><span class="comment"># kwargs: &#123;&#x27;x&#x27;: 6&#125;</span></span><br></pre></td></tr></table></figure><h2 id="损失-amp-优化"><a href="#损失-amp-优化" class="headerlink" title="损失&amp;优化"></a>损失&amp;优化</h2><ol><li>计算损失使用现成的类 torch.nn.MSELoss 。</li><li>一般使用随机梯度下降算法，求和平均是没有必要的，torch.nn.MSELoss(size_average=<strong>False</strong>)</li><li>使用现成的优化器类torch.optim.SGD</li><li><a href="https://pytorch.org/docs/1.7.0/optim.html">不同的优化器，官方文档</a></li><li>控制训练次数，不能过少（训练不到位），也不能过多（过拟合）</li></ol><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 准备数据，要是矩阵</span></span><br><span class="line">x_data = torch.Tensor([[<span class="number">1.0</span>], [<span class="number">2.0</span>], [<span class="number">3.0</span>]])</span><br><span class="line">y_data = torch.Tensor([[<span class="number">2.0</span>], [<span class="number">4.0</span>], [<span class="number">6.0</span>]])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 构建模型，继承、重写</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LinearModel</span>(<span class="params">torch.nn.Module</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="built_in">super</span>(LinearModel, self).__init__()</span><br><span class="line">        self.linear = torch.nn.Linear(<span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span>(<span class="params">self, x</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self.linear(x)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成模型的对象</span></span><br><span class="line">model = LinearModel()</span><br><span class="line">criterion = torch.nn.MSELoss(reduction=<span class="string">&#x27;sum&#x27;</span>)  <span class="comment"># size_average=False已经被弃用</span></span><br><span class="line">optimizer = torch.optim.SGD(model.parameters(), lr=<span class="number">0.01</span>)  <span class="comment"># 这里要设置迭代器管理的权重</span></span><br><span class="line"></span><br><span class="line">loss_list = []</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> epoch <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">100</span>):</span><br><span class="line">    y_pred = model(x_data)  <span class="comment"># __call__()调用forward()正向传播计算预测值</span></span><br><span class="line">    loss = criterion(y_pred, y_data)  <span class="comment"># 计算损失</span></span><br><span class="line">    print(epoch, loss.item())  <span class="comment"># 可以直接打印loss，因为调用的是__str__()不会产生计算图</span></span><br><span class="line">    loss_list.append(loss.item())  <span class="comment"># 保存loss</span></span><br><span class="line"></span><br><span class="line">    optimizer.zero_grad()  <span class="comment"># 将梯度归零，这一步要在下一轮计算反向传播之前进行</span></span><br><span class="line">    loss.backward()  <span class="comment"># 反向传播，计算梯度</span></span><br><span class="line">    optimizer.step()  <span class="comment"># 进行更新</span></span><br><span class="line"></span><br><span class="line">print(<span class="string">&#x27;w = &#x27;</span>, model.linear.weight.item())</span><br><span class="line">print(<span class="string">&#x27;b = &#x27;</span>, model.linear.bias.item())</span><br><span class="line"></span><br><span class="line">x_test = torch.Tensor([[<span class="number">4.0</span>]])</span><br><span class="line">y_test = model(x_test)  <span class="comment"># 使用训练好的模型进行预测</span></span><br><span class="line">print(<span class="string">&#x27;y_pred = &#x27;</span>, y_test.item())</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打印图表</span></span><br><span class="line">plt.plot(<span class="built_in">range</span>(<span class="number">100</span>), loss_list)</span><br><span class="line">plt.ylabel(<span class="string">&#x27;Loss&#x27;</span>)</span><br><span class="line">plt.xlabel(<span class="string">&#x27;Epoch&#x27;</span>)</span><br><span class="line">plt.show()</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="课后作业"><a href="#课后作业" class="headerlink" title="课后作业"></a>课后作业</h2><p>测试不同的优化器。除了LBFGS，只需要修改调用对应优化器的构造器。</p><h3 id="Adagrad"><a href="#Adagrad" class="headerlink" title="Adagrad"></a>Adagrad</h3><p>w =  0.20570674538612366</p><p>b =  -0.5057424902915955</p><p>y_pred =  0.31708449125289917</p><p><img src="/2021/01/PyTorch%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%AE%9E%E8%B7%B5Part5/image-20210117152240566.png" alt="image-20210117152240566"></p><h3 id="Adam"><a href="#Adam" class="headerlink" title="Adam"></a>Adam</h3><p>w =  1.466607928276062</p><p>b =  0.14079217612743378</p><p>y_pred =  6.007224082946777</p><p><img src="/2021/01/PyTorch%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%AE%9E%E8%B7%B5Part5/image-20210117152322232.png" alt="image-20210117152322232"></p><h3 id="Adamax"><a href="#Adamax" class="headerlink" title="Adamax"></a>Adamax</h3><p>w =  -0.022818174213171005</p><p>b =  0.9245702028274536</p><p>y_pred =  0.8332974910736084</p><p><img src="/2021/01/PyTorch%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%AE%9E%E8%B7%B5Part5/image-20210117152149494.png" alt="image-20210117152149494"></p><h3 id="ASGD"><a href="#ASGD" class="headerlink" title="ASGD"></a>ASGD</h3><p>w =  1.6153326034545898</p><p>b =  0.87442547082901</p><p>y_pred =  7.335755825042725</p><p><img src="/2021/01/PyTorch%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%AE%9E%E8%B7%B5Part5/image-20210117151915659.png" alt="image-20210117151915659"></p><h3 id="LBFGS"><a href="#LBFGS" class="headerlink" title="LBFGS"></a>LBFGS</h3><p>由于LBFGS算法需要重复多次计算函数，因此需要传入一个闭包去允许它们重新计算模型。这个闭包应当清空梯度， 计算损失，然后返回。</p><p>参考<a href="https://blog.csdn.net/ys1305/article/details/94332643">一篇关于优化器的博文</a></p><p>训练模型部分代码应修改为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">closure</span>():</span></span><br><span class="line">    optimizer.zero_grad()  <span class="comment"># 将梯度归零</span></span><br><span class="line">    y_pred = model(x_data)  <span class="comment"># __call__()调用forward()正向传播计算预测值</span></span><br><span class="line">    loss = criterion(y_pred, y_data)  <span class="comment"># 计算损失</span></span><br><span class="line">    print(epoch, loss.item())  <span class="comment"># 可以直接打印loss，因为调用的是__str__()不会产生计算图</span></span><br><span class="line">    loss_list.append(loss.item())  <span class="comment"># 保存loss</span></span><br><span class="line">    loss.backward()  <span class="comment"># 反向传播</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> epoch <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">100</span>):</span><br><span class="line">    optimizer.step(closure())  <span class="comment"># 进行更新</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>w =  1.7660775184631348</p><p>b =  0.531760573387146</p><p>y_pred =  7.596070766448975</p><p><img src="/2021/01/PyTorch%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%AE%9E%E8%B7%B5Part5/image-20210117153648037.png" alt="image-20210117153648037"></p><h3 id="RMSprop"><a href="#RMSprop" class="headerlink" title="RMSprop"></a>RMSprop</h3><p>w =  1.734222650527954</p><p>b =  0.5857117176055908</p><p>y_pred =  7.522602081298828</p><p><img src="/2021/01/PyTorch%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%AE%9E%E8%B7%B5Part5/image-20210117150905304.png" alt="image-20210117150905304"></p><h3 id="Rprop"><a href="#Rprop" class="headerlink" title="Rprop"></a>Rprop</h3><p>w =  1.9997763633728027</p><p>b =  0.0004527860146481544</p><p>y_pred =  7.999558448791504</p><p><img src="/2021/01/PyTorch%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%AE%9E%E8%B7%B5Part5/Rprop.png" alt="image-20210117150540886"></p><h3 id="SGD"><a href="#SGD" class="headerlink" title="SGD"></a>SGD</h3><p>w =  1.8483222723007202</p><p>b =  0.3447989821434021</p><p>y_pred =  7.738088130950928</p><p><img src="/2021/01/PyTorch%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%AE%9E%E8%B7%B5Part5/SGD.png" alt="image-20210117150219223"></p>]]></content>
      
      
      <categories>
          
          <category> PyTorch深度学习实践 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>PyTorch深度学习实践Part4</title>
      <link href="/2021/01/PyTorch%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%AE%9E%E8%B7%B5Part4/"/>
      <url>/2021/01/PyTorch%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%AE%9E%E8%B7%B5Part4/</url>
      
        <content type="html"><![CDATA[<h1 id="PyTorch深度学习实践Part4——反向传播"><a href="#PyTorch深度学习实践Part4——反向传播" class="headerlink" title="PyTorch深度学习实践Part4——反向传播"></a>PyTorch深度学习实践Part4——反向传播</h1><p>对于简单模型可以手动求解析式，但是对于复杂模型求解析式几乎不可能。</p><h2 id="计算图"><a href="#计算图" class="headerlink" title="计算图"></a>计算图</h2><p>每一层神经网络包括一次矩阵乘法(Matrix Multiplication)、一次向量加法、非线性变化函数(为了防止展开函数而导致深层神经网络无意义)</p><p><img src="/2021/01/PyTorch%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%AE%9E%E8%B7%B5Part4/image-20210116225529823.png" alt="image-20210116225529823"></p><h2 id="链式法则"><a href="#链式法则" class="headerlink" title="链式法则"></a>链式法则</h2><p>在pytorch中，梯度存在变量而不是计算模块里。</p><p><img src="/2021/01/PyTorch%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%AE%9E%E8%B7%B5Part4/image-20210116230629292.png" alt="image-20210116230629292"></p><p><img src="/2021/01/PyTorch%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%AE%9E%E8%B7%B5Part4/image-20210117091957454.png" alt="image-20210117091957454"></p><p>在计算过程中中，虽然有些变量可以不求导，但是一样要具备能够求导的能力。比如x的值就有可能是前一层网络的y_hat传递下来的。</p><p>核心在于梯度，loss虽然不会作为变量参与计算过程，但是同样需要保留，作为图像数据来判断最终是否收敛。</p><h2 id="PyTorch实现反向传播"><a href="#PyTorch实现反向传播" class="headerlink" title="PyTorch实现反向传播"></a>PyTorch实现反向传播</h2><p>线性模型y=w*x，用pytorch实现反向传播</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"></span><br><span class="line">x_data = [<span class="number">1.0</span>, <span class="number">2.0</span>, <span class="number">3.0</span>]</span><br><span class="line">y_data = [<span class="number">2.0</span>, <span class="number">4.0</span>, <span class="number">6.0</span>]</span><br><span class="line"></span><br><span class="line">w = torch.Tensor([<span class="number">1.0</span>])  <span class="comment"># data必须是一个序列</span></span><br><span class="line">w.requires_grad = <span class="literal">True</span>  <span class="comment"># 需要计算梯度</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">forward</span>(<span class="params">x</span>):</span></span><br><span class="line">    <span class="keyword">return</span> x * w  <span class="comment"># w是Tensor，运算符重载，x也会转成tensor</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">loss</span>(<span class="params">x, y</span>):</span></span><br><span class="line">    y_pred = forward(x)</span><br><span class="line">    <span class="keyword">return</span> (y_pred - y) ** <span class="number">2</span>  <span class="comment"># 看到代码一定要有意识想到如何构建计算图</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">print(<span class="string">&quot;predict (before training)&quot;</span>, <span class="number">4</span>, forward(<span class="number">4</span>).item())</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> epoch <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">100</span>):</span><br><span class="line">    <span class="keyword">for</span> x, y <span class="keyword">in</span> <span class="built_in">zip</span>(x_data, y_data):</span><br><span class="line">        l = loss(x, y)  <span class="comment"># 前馈过程，正式构建计算图，计算损失更新l</span></span><br><span class="line">        l.backward()  <span class="comment"># 反向传播，计算梯度，释放计算图</span></span><br><span class="line">        print(<span class="string">&#x27;\tgrad:&#x27;</span>, x, y, w.grad.item())</span><br><span class="line">        w.data = w.data - <span class="number">0.01</span> * w.grad.data  <span class="comment"># 更新权重w，注意grad也是一个tensor，不使用.data的话相当于在构建计算图</span></span><br><span class="line"></span><br><span class="line">        w.grad.data.zero_()  <span class="comment"># 将梯度w.grad.data清零</span></span><br><span class="line"></span><br><span class="line">    print(<span class="string">&#x27;progress:&#x27;</span>, epoch, l.item())  <span class="comment"># 取出loss使用l.item，不要直接使用l（l是tensor会构建计算图）</span></span><br><span class="line"></span><br><span class="line">print(<span class="string">&quot;predict (after training)&quot;</span>, <span class="number">4</span>, forward(<span class="number">4</span>).item())</span><br><span class="line"><span class="comment"># predict (after training) 4 7.999998569488525</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="课后作业"><a href="#课后作业" class="headerlink" title="课后作业"></a>课后作业</h2><p>二次模型y=w1<em>x²+w2</em>x+b的反向传播</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"></span><br><span class="line"><span class="comment"># y = x ** 2 + 2 * x + 1</span></span><br><span class="line">x_data = [<span class="number">1.0</span>, <span class="number">2.0</span>, <span class="number">3.0</span>]</span><br><span class="line">y_data = [<span class="number">4.0</span>, <span class="number">9.0</span>, <span class="number">16.0</span>]</span><br><span class="line"></span><br><span class="line">w1 = torch.Tensor([<span class="number">1.0</span>])</span><br><span class="line">w2 = torch.Tensor([<span class="number">1.0</span>])</span><br><span class="line">b = torch.Tensor([<span class="number">1.0</span>])</span><br><span class="line">w1.requires_grad, w2.requires_grad, b.requires_grad = <span class="literal">True</span>, <span class="literal">True</span>, <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">forward</span>(<span class="params">x</span>):</span></span><br><span class="line">    <span class="keyword">return</span> w1 * x * x + w2 * x + b</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">loss</span>(<span class="params">x, y</span>):</span></span><br><span class="line">    y_pred = forward(x)</span><br><span class="line">    <span class="keyword">return</span> (y_pred - y) ** <span class="number">2</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">print(<span class="string">&quot;predict (before training)&quot;</span>, <span class="number">4</span>, forward(<span class="number">4</span>).item())</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> epoch <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">100</span>):</span><br><span class="line">    <span class="keyword">for</span> x, y <span class="keyword">in</span> <span class="built_in">zip</span>(x_data, y_data):</span><br><span class="line">        l = loss(x, y)  <span class="comment"># 前馈过程，正式构建计算图，计算损失更新l</span></span><br><span class="line">        l.backward()  <span class="comment"># 反向传播，计算梯度，释放计算图</span></span><br><span class="line">        print(<span class="string">&#x27;\tgrad:&#x27;</span>, x, y, w1.grad.item(), w2.grad.item(), b.grad.item())</span><br><span class="line">        w1.data = w1.data - <span class="number">0.01</span> * w1.grad.data</span><br><span class="line">        w2.data = w2.data - <span class="number">0.01</span> * w2.grad.data</span><br><span class="line">        b.data = b.data - <span class="number">0.01</span> * b.grad.data</span><br><span class="line">        w1.grad.data.zero_()</span><br><span class="line">        w2.grad.data.zero_()</span><br><span class="line">        b.grad.data.zero_()</span><br><span class="line">    print(<span class="string">&#x27;progress:&#x27;</span>, epoch, l.item())  <span class="comment"># 取出loss使用l.item，不要直接使用l（l是tensor会构建计算图）</span></span><br><span class="line"></span><br><span class="line">print(<span class="string">&quot;predict (after training)&quot;</span>, <span class="number">4</span>, forward(<span class="number">4</span>).item())</span><br><span class="line">print(w1.data, w2.data, b.data)</span><br><span class="line"><span class="comment"># predict (after training) 4 25.259323120117188</span></span><br><span class="line"><span class="comment"># tensor([1.1145]) tensor([1.4928]) tensor([1.4557])</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>改了一下原本的数据集，更符合二次函数，但是因为样本量过少，预测的权重并不是很好。</p>]]></content>
      
      
      <categories>
          
          <category> PyTorch深度学习实践 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>PyTorch深度学习实践Part3</title>
      <link href="/2021/01/PyTorch%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%AE%9E%E8%B7%B5Part3/"/>
      <url>/2021/01/PyTorch%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%AE%9E%E8%B7%B5Part3/</url>
      
        <content type="html"><![CDATA[<h1 id="PyTorch深度学习实践Part3——梯度下降算法"><a href="#PyTorch深度学习实践Part3——梯度下降算法" class="headerlink" title="PyTorch深度学习实践Part3——梯度下降算法"></a>PyTorch深度学习实践Part3——梯度下降算法</h1><h2 id="优化问题"><a href="#优化问题" class="headerlink" title="优化问题"></a>优化问题</h2><ol><li><p>上讲是穷举所有可能值并肉眼搜索损失最低点。</p></li><li><p>分治法可能错失关键，最终只找到局部最优</p><blockquote><p>穷举和分治都不能有效解决大数据</p></blockquote></li><li><p>梯度(gradient)决定权重w往哪个方向走，梯度即成本对权重求导，为了控制步伐需要设定一个较小的学习率。</p><p><img src="/2021/01/PyTorch%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%AE%9E%E8%B7%B5Part3/image-20210116203946162.png" alt="image-20210116203946162"></p></li><li><p>在大量的实验中发现，其实很多情况下，我们很难陷入到局部最优点。但是存在另外一个问题，鞍点。鞍点会导致无法继续迭代，可以选择通过引入动量解决。</p></li></ol><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">x_data = [<span class="number">1.0</span>, <span class="number">2.0</span>, <span class="number">3.0</span>]</span><br><span class="line">y_data = [<span class="number">2.0</span>, <span class="number">4.0</span>, <span class="number">6.0</span>]</span><br><span class="line">w = <span class="number">1.0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">forward</span>(<span class="params">x</span>):</span></span><br><span class="line">    <span class="keyword">return</span> x * w</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">cost</span>(<span class="params">xs, ys</span>):</span></span><br><span class="line">    cost = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> x, y <span class="keyword">in</span> <span class="built_in">zip</span>(xs, ys):  <span class="comment"># 3行数据</span></span><br><span class="line">        y_pred = forward(x)</span><br><span class="line">        cost += (y_pred - y) ** <span class="number">2</span>  <span class="comment"># 累加损失平方</span></span><br><span class="line">    <span class="keyword">return</span> cost / <span class="built_in">len</span>(xs)  <span class="comment"># 平均</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">gradient</span>(<span class="params">xs, ys</span>):</span></span><br><span class="line">    grad = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> x, y <span class="keyword">in</span> <span class="built_in">zip</span>(xs, ys):</span><br><span class="line">        grad += <span class="number">2</span> * x * (x * w - y)  <span class="comment"># 成本对权重求导</span></span><br><span class="line">    <span class="keyword">return</span> grad / <span class="built_in">len</span>(xs)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">print(<span class="string">&#x27;Predict(before training)&#x27;</span>, <span class="number">4</span>, forward(<span class="number">4</span>))</span><br><span class="line">mse_list = []  <span class="comment"># 保存损失的变化曲线</span></span><br><span class="line"><span class="keyword">for</span> epoch <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">100</span>):</span><br><span class="line">    cost_val = cost(x_data, y_data)  <span class="comment"># 计算损失</span></span><br><span class="line">    mse_list.append(cost_val)  <span class="comment"># 记录损失变化</span></span><br><span class="line">    grad_val = gradient(x_data, y_data)  <span class="comment"># 计算梯度</span></span><br><span class="line">    w -= <span class="number">0.01</span> * grad_val  <span class="comment"># 改善权重</span></span><br><span class="line">    print(<span class="string">&#x27;Epoch:&#x27;</span>, epoch, <span class="string">&#x27;w=&#x27;</span>, w, <span class="string">&#x27;loss=&#x27;</span>, cost_val)</span><br><span class="line">print(<span class="string">&#x27;Predict(after training)&#x27;</span>, <span class="number">4</span>, forward(<span class="number">4</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 图表打印</span></span><br><span class="line">plt.plot(<span class="built_in">range</span>(<span class="number">100</span>), mse_list)</span><br><span class="line">plt.ylabel(<span class="string">&#x27;Loss&#x27;</span>)</span><br><span class="line">plt.xlabel(<span class="string">&#x27;Epoch&#x27;</span>)</span><br><span class="line">plt.show()</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="/2021/01/PyTorch%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%AE%9E%E8%B7%B5Part3/image-20210116215632394.png" alt="image-20210116215632394"></p><ol><li>绘图时想要消除局部震荡，可以使用指数加权均值方法，使其变成更加平滑的曲线</li><li>如果训练的图像发散，则表明这次训练失败了。其原因有很多，比如，学习率取太大。</li></ol><h2 id="随机梯度下降"><a href="#随机梯度下降" class="headerlink" title="随机梯度下降"></a>随机梯度下降</h2><p>使用梯度下降方法时，更加常用随机梯度下降(Stochastic Gradient Descent)。</p><p>随机梯度下降也是跨越鞍点的一种方法，同时也可以大幅减少计算量。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line">x_data = [<span class="number">1.0</span>, <span class="number">2.0</span>, <span class="number">3.0</span>]</span><br><span class="line">y_data = [<span class="number">2.0</span>, <span class="number">4.0</span>, <span class="number">6.0</span>]</span><br><span class="line">w = <span class="number">1.0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">forward</span>(<span class="params">x</span>):</span></span><br><span class="line">    <span class="keyword">return</span> x * w</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">loss</span>(<span class="params">x, y</span>):</span></span><br><span class="line">    y_pred = forward(x)</span><br><span class="line">    <span class="keyword">return</span> (y_pred - y) ** <span class="number">2</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">gradient</span>(<span class="params">x, y</span>):</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span> * x * (x * w - y)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">print(<span class="string">&#x27;Predict(before training)&#x27;</span>, <span class="number">4</span>, forward(<span class="number">4</span>))</span><br><span class="line">mse_list = []  <span class="comment"># 保存损失的变化曲线</span></span><br><span class="line"><span class="keyword">for</span> epoch <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">100</span>):</span><br><span class="line">    x, y, i = <span class="number">0</span>, <span class="number">0</span>, random.randint(<span class="number">0</span>, <span class="number">2</span>)</span><br><span class="line">    <span class="comment"># 样本原本就是随机的，所以不需要打乱样本</span></span><br><span class="line">    <span class="keyword">for</span> m, n, j <span class="keyword">in</span> <span class="built_in">zip</span>(x_data, y_data, <span class="built_in">range</span>(<span class="number">0</span>, <span class="number">2</span>, <span class="number">1</span>)):</span><br><span class="line">        <span class="keyword">if</span> j == i:</span><br><span class="line">            x, y = m, n  <span class="comment"># 3组中随机选取一组</span></span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    grad = gradient(x, y)  <span class="comment"># 计算梯度</span></span><br><span class="line">    w -= <span class="number">0.01</span> * grad  <span class="comment"># 改善权重</span></span><br><span class="line">    cost_val = loss(x, y)  <span class="comment"># 计算损失</span></span><br><span class="line">    mse_list.append(cost_val)  <span class="comment"># 记录损失变化</span></span><br><span class="line">    print(<span class="string">&#x27;Epoch:&#x27;</span>, epoch, <span class="string">&#x27;w=&#x27;</span>, w, <span class="string">&#x27;loss=&#x27;</span>, cost_val)</span><br><span class="line">print(<span class="string">&#x27;Predict(after training)&#x27;</span>, <span class="number">4</span>, forward(<span class="number">4</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 图表打印</span></span><br><span class="line">plt.plot(<span class="built_in">range</span>(<span class="number">100</span>), mse_list)</span><br><span class="line">plt.ylabel(<span class="string">&#x27;Loss&#x27;</span>)</span><br><span class="line">plt.xlabel(<span class="string">&#x27;Epoch&#x27;</span>)</span><br><span class="line">plt.show()</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="/2021/01/PyTorch%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%AE%9E%E8%B7%B5Part3/image-20210116222847776.png" alt="image-20210116222847776"></p><p>随机梯度下降可能享受不到并行计算的效率加成，因此会使用折中方法，批量随机梯度下降(Mini-Batch/Batch)</p>]]></content>
      
      
      <categories>
          
          <category> PyTorch深度学习实践 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>PyTorch深度学习实践Part2</title>
      <link href="/2021/01/PyTorch%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%AE%9E%E8%B7%B5Part2/"/>
      <url>/2021/01/PyTorch%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%AE%9E%E8%B7%B5Part2/</url>
      
        <content type="html"><![CDATA[<h1 id="PyTorch深度学习实践Part2——线性模型"><a href="#PyTorch深度学习实践Part2——线性模型" class="headerlink" title="PyTorch深度学习实践Part2——线性模型"></a>PyTorch深度学习实践Part2——线性模型</h1><h2 id="一般过程"><a href="#一般过程" class="headerlink" title="一般过程"></a>一般过程</h2><ol><li>Data Set </li><li>Model（神经网络、决策树、朴素贝叶斯）</li><li>Trainning</li><li>Infering</li></ol><h2 id="训练-amp-测试"><a href="#训练-amp-测试" class="headerlink" title="训练&amp;测试"></a>训练&amp;测试</h2><h3 id="训练集拆分"><a href="#训练集拆分" class="headerlink" title="训练集拆分"></a>训练集拆分</h3><p>在竞赛中，训练集是可见的，测试集一般是不可见的。为了提高或验证模型的准确度，一般会把手中的训练集拆分，以及交叉验证。</p><h3 id="过拟合"><a href="#过拟合" class="headerlink" title="过拟合"></a>过拟合</h3><p>当模型对训练集的噪声也学习进去的时候，对训练集以外的数据可能会出现准确率下降的情况。因此一个好的模型需要有良好的泛化能力。</p><h2 id="损失函数"><a href="#损失函数" class="headerlink" title="损失函数"></a>损失函数</h2><p><img src="/2021/01/PyTorch%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%AE%9E%E8%B7%B5Part2/image-20210116101533492.png" alt="image-20210116101533492"></p><p>平均平方误差（MSE MeanSquareError）</p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">x_data = [<span class="number">1.0</span>, <span class="number">2.0</span>, <span class="number">3.0</span>]</span><br><span class="line">y_data = [<span class="number">2.0</span>, <span class="number">4.0</span>, <span class="number">6.0</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 前馈</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">forward</span>(<span class="params">x</span>):</span></span><br><span class="line">    <span class="keyword">return</span> x * w</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 损失</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">loss</span>(<span class="params">x, y</span>):</span></span><br><span class="line">    y_pred = forward(x)</span><br><span class="line">    <span class="keyword">return</span> (y_pred - y) * (y_pred - y)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 存放结果，所有权重和对应的均方差</span></span><br><span class="line">w_list = []</span><br><span class="line">mse_list = []</span><br><span class="line"><span class="comment"># 穷举所有权重0.0-4.1步长0.1</span></span><br><span class="line"><span class="keyword">for</span> w <span class="keyword">in</span> np.arange(<span class="number">0.0</span>, <span class="number">4.1</span>, <span class="number">0.1</span>):</span><br><span class="line">    print(<span class="string">&#x27;w=&#x27;</span>, w)</span><br><span class="line">    l_sum = <span class="number">0</span>  <span class="comment"># 损失的和</span></span><br><span class="line">    <span class="keyword">for</span> x_val, y_val <span class="keyword">in</span> <span class="built_in">zip</span>(x_data, y_data):  <span class="comment"># 打包，一共三行</span></span><br><span class="line">        y_pred_val = forward(x_val)  <span class="comment"># 前馈算出此权重和样本得出的预测值，其实已经包含在loss()中，只是为了打印</span></span><br><span class="line">        loss_val = loss(x_val, y_val)  <span class="comment"># 计算该权重预测值得损失</span></span><br><span class="line">        l_sum += loss_val  <span class="comment"># 求损失和</span></span><br><span class="line">        print(<span class="string">&#x27;\t&#x27;</span>, x_val, y_val, y_pred_val, loss_val)  <span class="comment"># 当前的x、y值、预测值、损失</span></span><br><span class="line">    print(<span class="string">&#x27;MSE=&#x27;</span>, l_sum / <span class="number">3</span>)  <span class="comment"># 求损失的平均</span></span><br><span class="line">    <span class="comment"># 保存记录</span></span><br><span class="line">    w_list.append(w)</span><br><span class="line">    mse_list.append(l_sum / <span class="number">3</span>)</span><br><span class="line"><span class="comment"># 图表打印</span></span><br><span class="line">plt.plot(w_list, mse_list)</span><br><span class="line">plt.ylabel(<span class="string">&#x27;Loss&#x27;</span>)</span><br><span class="line">plt.xlabel(<span class="string">&#x27;w&#x27;</span>)</span><br><span class="line">plt.show()</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="/2021/01/PyTorch%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%AE%9E%E8%B7%B5Part2/image-20210116155722125.png" alt="image-20210116155722125"></p><blockquote><p>做深度学习要定期存盘，防止意外导致数据丢失</p></blockquote><h2 id="课后作业"><a href="#课后作业" class="headerlink" title="课后作业"></a>课后作业</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 这里设函数为y=3x+2</span></span><br><span class="line">x_data = [<span class="number">1.0</span>, <span class="number">2.0</span>, <span class="number">3.0</span>]</span><br><span class="line">y_data = [<span class="number">5.0</span>, <span class="number">8.0</span>, <span class="number">11.0</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">forward</span>(<span class="params">x</span>):</span></span><br><span class="line">    <span class="keyword">return</span> x * w + b</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">loss</span>(<span class="params">x, y</span>):</span></span><br><span class="line">    y_pred = forward(x)</span><br><span class="line">    <span class="keyword">return</span> (y_pred - y) * (y_pred - y)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 1.arange()左闭右开；2.打印 0.0、1.0 时只会显示 0.、1.；3.meshgrid()之后w、b都是41*41矩阵</span></span><br><span class="line"><span class="comment"># 4.这里前馈中是矩阵点对点的运算，但注意并不是矩阵运算，好处是省去了n层for循环，举例：</span></span><br><span class="line"><span class="comment"># a=[[1 2 3][1 2 3]]</span></span><br><span class="line"><span class="comment"># b=[[7 7 7][8 8 8]]</span></span><br><span class="line"><span class="comment"># a*b=[[ 7 14 21][ 8 16 24]]</span></span><br><span class="line">w_list = np.arange(<span class="number">0.0</span>, <span class="number">4.1</span>, <span class="number">0.1</span>)</span><br><span class="line">b_list = np.arange(<span class="number">0.0</span>, <span class="number">4.1</span>, <span class="number">0.1</span>)</span><br><span class="line">w, b = np.meshgrid(w_list, b_list)</span><br><span class="line"></span><br><span class="line">l_sum = <span class="number">0</span>  <span class="comment"># 损失的和</span></span><br><span class="line"><span class="keyword">for</span> x_val, y_val <span class="keyword">in</span> <span class="built_in">zip</span>(x_data, y_data):  <span class="comment"># 遍历三次</span></span><br><span class="line">    <span class="comment"># y_pred_val、loss_val都是41*41的矩阵，即41个w和41个b组合的预测结果和损失</span></span><br><span class="line">    y_pred_val = forward(x_val)</span><br><span class="line">    loss_val = loss(x_val, y_val)</span><br><span class="line">    l_sum += loss_val</span><br><span class="line">    print(<span class="string">&#x27;\nx_val：&#x27;</span>, x_val,<span class="string">&#x27;\ny_val：&#x27;</span>, y_val, <span class="string">&#x27;\ny_pred_val：&#x27;</span>,y_pred_val, <span class="string">&#x27;\nloss_val：&#x27;</span>,loss_val)  <span class="comment"># 当前的x、y值、预测值、损失</span></span><br><span class="line">mse_list = l_sum / <span class="number">3</span></span><br><span class="line"><span class="comment"># mse_list也是一个ndarray类型的41*41矩阵</span></span><br><span class="line">print(<span class="string">&#x27;MSE=&#x27;</span>, mse_list)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3d图表</span></span><br><span class="line">fig = plt.figure()</span><br><span class="line">ax = fig.add_subplot(<span class="number">111</span>, projection=<span class="string">&#x27;3d&#x27;</span>)</span><br><span class="line">ax.plot_surface(w, b, mse_list)</span><br><span class="line">plt.show()</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 这里设函数为y=3x+2</span></span><br><span class="line">x_data = [<span class="number">1.0</span>, <span class="number">2.0</span>, <span class="number">3.0</span>]</span><br><span class="line">y_data = [<span class="number">5.0</span>, <span class="number">8.0</span>, <span class="number">11.0</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">forward</span>(<span class="params">x</span>):</span></span><br><span class="line">    <span class="keyword">return</span> x * w + b</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">loss</span>(<span class="params">x, y</span>):</span></span><br><span class="line">    y_pred = forward(x)</span><br><span class="line">    <span class="keyword">return</span> (y_pred - y) * (y_pred - y)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 这里都是矩阵的运算</span></span><br><span class="line"><span class="comment"># 1.arange()左闭右开；2.打印 0.0、1.0 时只会显示 0.、1.；3.meshgrid之后w、b都是41*41矩阵</span></span><br><span class="line">w_list = np.arange(<span class="number">0.0</span>, <span class="number">4.1</span>, <span class="number">0.1</span>)</span><br><span class="line">b_list = np.arange(<span class="number">0.0</span>, <span class="number">4.1</span>, <span class="number">0.1</span>)</span><br><span class="line">w, b = np.meshgrid(w_list, b_list)</span><br><span class="line"></span><br><span class="line">l_sum = <span class="number">0</span>  <span class="comment"># 损失的和</span></span><br><span class="line"><span class="keyword">for</span> x_val, y_val <span class="keyword">in</span> <span class="built_in">zip</span>(x_data, y_data):  <span class="comment"># 遍历三次</span></span><br><span class="line">    y_pred_val = forward(x_val)</span><br><span class="line">    loss_val = loss(x_val, y_val)</span><br><span class="line">    l_sum += loss_val</span><br><span class="line">    print(<span class="string">&#x27;\nx_val：&#x27;</span>, x_val,<span class="string">&#x27;\ny_val：&#x27;</span>, y_val, <span class="string">&#x27;\ny_pred_val：&#x27;</span>,y_pred_val, <span class="string">&#x27;\nloss_val：&#x27;</span>,loss_val)  <span class="comment"># 当前的x、y值、预测值、损失</span></span><br><span class="line">mse_list = l_sum / <span class="number">3</span></span><br><span class="line"><span class="comment"># mse_list也是一个ndarray类型的41*41矩阵</span></span><br><span class="line">print(<span class="string">&#x27;MSE=&#x27;</span>, mse_list)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3d图表</span></span><br><span class="line">fig = plt.figure()</span><br><span class="line">ax = fig.add_subplot(<span class="number">111</span>, projection=<span class="string">&#x27;3d&#x27;</span>)</span><br><span class="line">ax.plot_surface(w, b, mse_list)</span><br><span class="line">plt.show()</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="/2021/01/PyTorch%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%AE%9E%E8%B7%B5Part2/image-20210116155626917.png" alt="image-20210116155626917"></p>]]></content>
      
      
      <categories>
          
          <category> PyTorch深度学习实践 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>PyTorch深度学习实践Part1</title>
      <link href="/2021/01/PyTorch%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%AE%9E%E8%B7%B5Part1/"/>
      <url>/2021/01/PyTorch%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%AE%9E%E8%B7%B5Part1/</url>
      
        <content type="html"><![CDATA[<h1 id="PyTorch深度学习实践Part1——概论"><a href="#PyTorch深度学习实践Part1——概论" class="headerlink" title="PyTorch深度学习实践Part1——概论"></a>PyTorch深度学习实践Part1——概论</h1><h2 id="技术成熟度曲线"><a href="#技术成熟度曲线" class="headerlink" title="技术成熟度曲线"></a>技术成熟度曲线</h2><p><img src="/2021/01/PyTorch%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%AE%9E%E8%B7%B5Part1/3b87e950352ac65ca9eb5abaa5e3f21692138a21.jpeg" alt="技术成熟度曲线"></p><p><strong>科技诞生的促动期</strong> (Technology Trigger)：在此阶段，随着媒体大肆的报道过度，非理性的渲染，产品的知名度无所不在，然而随着这个科技的缺点、问题、限制出现，失败的案例大于成功的案例，例如:.com公司 1998~2000年之间的非理性疯狂飙升期。</p><p><strong>过高期望的峰值</strong>（Peak of Inflated Expectations）：早期公众的过分关注演绎出了一系列成功的故事——当然同时也有众多失败的例子。对于失败，有些公司采取了补救措施，而大部分却无动于衷。</p><p><strong>泡沫化的底谷期</strong> (Trough of Disillusionment)：在历经前面阶段所存活的科技经过多方扎实有重点的试验，而对此科技的适用范围及限制是以客观的并实际的了解，成功并能存活的经营模式逐渐成长。</p><p><strong>稳步爬升的光明期</strong> (Slope of Enlightenment)：在此阶段，有一新科技的诞生，在市面上受到主要媒体与业界高度的注意，例如:1996年的Internet ，Web。</p><p><strong>实质生产的高峰期</strong> (Plateau of Productivity)：在此阶段，新科技产生的利益与潜力被市场实际接受，实质支援此经营模式的工具、方法论经过数代的演进，进入了非常成熟的阶段。</p><blockquote><p>在使用pytorch或一系列新技术的时候，一定要学会看官方文档，这是一个非常重要的能力！</p></blockquote><h2 id="人工智能"><a href="#人工智能" class="headerlink" title="人工智能"></a>人工智能</h2><p><img src="/2021/01/PyTorch%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%AE%9E%E8%B7%B5Part1/image-20210115233930514.png" alt="AI技术"></p><p>AI除了machine learning之外还有机器视觉、自然语言处理nlp、因果推断等。</p><p>机器学习大部分都是监督学习，即用一组标签过的值进行模型训练。</p><p>机器学习中的算法区别于普通的算法（穷举、贪心等），是通过数据训练并验证得出一个好用的模型，其计算过程来自于数据而不是人工的设计。</p><p>深度学习从模型上看用的是神经网络，从目标上看属于表示学习的分支。方法有，多层感知机、卷积神经网络、循环神经网络等。</p><h2 id="维度诅咒"><a href="#维度诅咒" class="headerlink" title="维度诅咒"></a>维度诅咒</h2><p>随着feature上升，为了保持准确性，其所需的数据量将急速上升，然而获取打过标签的数据，工作量大、成本高。</p><p>n<em>1的向量采样点需要一个3</em>n的矩阵来映射到3*1的向量，实现降维（PCA主成成分分析）。但是降维的同时也要尽量保证高维空间的度量信息，这个过程叫做表示学习（Present）。这个数据分布是在高维空间里的低维流行（Manifold）。</p><h2 id="发展历史"><a href="#发展历史" class="headerlink" title="发展历史"></a>发展历史</h2><p><img src="/2021/01/PyTorch%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%AE%9E%E8%B7%B5Part1/image-20210116083615697.png" alt="image-20210116083615697"></p><h2 id="传统机器学习分类"><a href="#传统机器学习分类" class="headerlink" title="传统机器学习分类"></a>传统机器学习分类</h2><p><img src="/2021/01/PyTorch%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%AE%9E%E8%B7%B5Part1/image-20210116083809610.png" alt="image-20210116083809610"></p><h2 id="神经网络发展"><a href="#神经网络发展" class="headerlink" title="神经网络发展"></a>神经网络发展</h2><p>由生物实验得出，哺乳动物的视觉神经是分层的。浅层只检测物体的运动等，深层才开始识别物体的分类。由此出现了感知机。</p><p>现在神经网络早已不是生物的范畴，而是工程与数学方面。</p><p>真正让神经网络发展起来的是反向传播（Back Propagation），其核心在于计算图。</p><p><img src="/2021/01/PyTorch%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%AE%9E%E8%B7%B5Part1/image-20210116090403146.png" alt="image-20210116090403146"></p>]]></content>
      
      
      <categories>
          
          <category> PyTorch深度学习实践 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>个人博客建站教程-完结目录</title>
      <link href="/2021/01/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E5%BB%BA%E7%AB%99%E6%95%99%E7%A8%8B-%E5%AE%8C%E7%BB%93%E7%9B%AE%E5%BD%95/"/>
      <url>/2021/01/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E5%BB%BA%E7%AB%99%E6%95%99%E7%A8%8B-%E5%AE%8C%E7%BB%93%E7%9B%AE%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<h1 id="个人博客建站教程-完结目录"><a href="#个人博客建站教程-完结目录" class="headerlink" title="个人博客建站教程-完结目录"></a>个人博客建站教程-完结目录</h1><h2 id="个人博客网站教程"><a href="#个人博客网站教程" class="headerlink" title="个人博客网站教程"></a>个人博客网站教程</h2><p>其实不是一件很难的事，花个一点时间，祝每个人都能做出自己风格的博客小家。</p><p>之后的博客维护以发文章为主，一键三连~ <code>hexo clean &amp; hexo g &amp; hexo d</code></p><table><thead><tr><th align="center"><a href="2021/01/Hexo%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E5%92%8C%E9%83%A8%E7%BD%B2/">Part1——博客搭建与部署</a></th></tr></thead><tbody><tr><td align="center"><a href="2021/01/Butterfly%E4%B8%BB%E9%A2%98%E5%AE%89%E8%A3%85%E5%92%8C%E9%AD%94%E6%94%B9/"><strong>Part2——主题安装与魔改</strong></a></td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> Hexo博客搭建 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Butterfly主题安装和魔改</title>
      <link href="/2021/01/Butterfly%E4%B8%BB%E9%A2%98%E5%AE%89%E8%A3%85%E5%92%8C%E9%AD%94%E6%94%B9/"/>
      <url>/2021/01/Butterfly%E4%B8%BB%E9%A2%98%E5%AE%89%E8%A3%85%E5%92%8C%E9%AD%94%E6%94%B9/</url>
      
        <content type="html"><![CDATA[<h1 id="安装butterfly"><a href="#安装butterfly" class="headerlink" title="安装butterfly"></a>安装butterfly</h1><ol><li>运行<code>git clone https://github.com/jerryc127/hexo-theme-butterfly themes/butterfly</code></li><li>打开_config.yml找到这一行<code>theme: landspace</code>然后将landspace替换butterfly</li><li>安装插件<code>cnpm install hexo-renderer-pug hexo-renderer-stylus</code></li><li>安装插件<code>cnpm install --save hexo-renderer-jade hexo-generator-feed hexo-generator-sitemap hexo-browsersync hexo-generator-archive</code></li></ol><blockquote><p>为了以后升级方便，这里不推荐直接对主题的配置文件进行修改，而是复制配置文件进行修改。个人推荐把主題的配置文件_config.yml复制到 Hexo 工作目录下的source/_data/butterfly.yml，如果目录不存在那就创建一个。</p></blockquote><h1 id="butterfly主题魔改"><a href="#butterfly主题魔改" class="headerlink" title="butterfly主题魔改"></a>butterfly主题魔改</h1><p>自己一开始动手做的时候大部分都参考Dreamy.TZK的博客</p><p><a href="https://www.antmoe.com/posts/75a6347a/index.html">Hexo安装并使用Butterfly主题</a></p><p>但是改到后来就越来越觉得，版本问题导致的主题修改不兼容，问题实在很大。甚至到后来想要获得自己的预期效果时，已经不得不去在源代码上下手<del>，因为还没有学过前端，改的属实面目全非</del>。</p><h2 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h2><p>这里只能为想要自己动手改的小伙伴一些建议，比如想修改文章页，可以结合浏览器的开发者工具来找到相应的参数，来修改对应的值。</p><p><img src="/2021/01/Butterfly%E4%B8%BB%E9%A2%98%E5%AE%89%E8%A3%85%E5%92%8C%E9%AD%94%E6%94%B9/Untitled.png" alt="Butterfly主题安装和魔改/Untitled.png"></p><p><img src="/2021/01/Butterfly%E4%B8%BB%E9%A2%98%E5%AE%89%E8%A3%85%E5%92%8C%E9%AD%94%E6%94%B9/Untitled%201.png" alt="Butterfly主题安装和魔改/Untitled%201.png"></p><h2 id="相册的使用"><a href="#相册的使用" class="headerlink" title="相册的使用"></a>相册的使用</h2><p><a href="https://blog.ahzoo.cn/2020/07/20/b7201/">https://blog.ahzoo.cn/2020/07/20/b7201/</a></p><h2 id="关于文章中插入图片"><a href="#关于文章中插入图片" class="headerlink" title="关于文章中插入图片"></a>关于文章中插入图片</h2><p>先把hexo的配置文件中的 relative_link 参数确保为false。否则会导致butterfly各分页面的链接错乱</p><p><img src="/2021/01/Butterfly%E4%B8%BB%E9%A2%98%E5%AE%89%E8%A3%85%E5%92%8C%E9%AD%94%E6%94%B9/image-20201231210020980.png" alt="image-20201231210020980"></p><p>把每个文章开头部分加一个参数 relative_link: true。使每个文章部分遵从相对位置的引用，这样可以将文章的图片，不仅在typora或是在服务器上，都能够实时看到自己文章图片引用的效果。</p><p><img src="/2021/01/Butterfly%E4%B8%BB%E9%A2%98%E5%AE%89%E8%A3%85%E5%92%8C%E9%AD%94%E6%94%B9/image-20201231205840731.png" alt="image-20201231205840731"></p><p><img src="/2021/01/Butterfly%E4%B8%BB%E9%A2%98%E5%AE%89%E8%A3%85%E5%92%8C%E9%AD%94%E6%94%B9/image-20201231210339382.png" alt="image-20201231210339382"></p><h2 id="关于分类管理-post下的文章"><a href="#关于分类管理-post下的文章" class="headerlink" title="关于分类管理_post下的文章"></a>关于分类管理_post下的文章</h2><p>主要参考<a href="https://blog.csdn.net/maosidiaoxian/article/details/85220394">如何在Hexo中对文章md文件分类</a></p><p>现在文章中的permalink:参数会完全覆盖_config.yml中的设置，要注意。</p><h1 id="后面应该还会慢慢更新一些有用的东西"><a href="#后面应该还会慢慢更新一些有用的东西" class="headerlink" title="后面应该还会慢慢更新一些有用的东西~"></a>后面应该还会慢慢更新一些有用的东西~</h1>]]></content>
      
      
      <categories>
          
          <category> Hexo博客搭建 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Hexo静态博客搭建和部署</title>
      <link href="/2021/01/Hexo%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E5%92%8C%E9%83%A8%E7%BD%B2/"/>
      <url>/2021/01/Hexo%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E5%92%8C%E9%83%A8%E7%BD%B2/</url>
      
        <content type="html"><![CDATA[<h1 id="软件安装"><a href="#软件安装" class="headerlink" title="软件安装"></a>软件安装</h1><h2 id="Nodejs"><a href="#Nodejs" class="headerlink" title="Nodejs"></a>Nodejs</h2><p><a href="https://nodejs.org/en/">Node.js</a></p><ul><li><code>node -v</code>确认nodejs版本，安装成功</li></ul><h2 id="Git-Bash"><a href="#Git-Bash" class="headerlink" title="Git Bash"></a>Git Bash</h2><p><a href="https://www.git-scm.com/download/win">Downloading Git</a></p><ul><li><code>git --version</code>确认nodejs版本，安装成功</li></ul><blockquote><p>nodejs和git自己选好安装位置之后无脑下一步就行。以下都以我个人的安装目录（D:\ProgrammingKits\nodejs 和 D:\ProgrammingKits\Git）为前提，请大家各自修改为自己的路径。</p></blockquote><h1 id="Nodejs插件安装"><a href="#Nodejs插件安装" class="headerlink" title="Nodejs插件安装"></a>Nodejs插件安装</h1><ul><li><p>最新的Nodejs自带npm，但是默认安装和缓存地址不在Nodejs根目录下</p><p>  npm的默认全局模块的安装地址是 C:\Users\Administrator\AppData\Roaming\npm</p><p>  npm的默认缓存的地址是 C:\Users\Administrator\AppData\Roaming\npm_cache</p></li></ul><p>首先修改nodejs的prefix（全局）和cache（缓存）文件夹地址</p><ul><li>运行<code>npm config set cache &quot;D:\ProgrammingKits\nodejs\node_cache&quot;</code>设置缓存文件夹</li><li>运行<code>npm config set prefix &quot;D:\ProgrammingKits\nodejs\nodejs&quot;</code>设置全局模块存放路径。</li></ul><p><del>这种方法可以不用像<code>npm config set prefix &quot;D:\ProgrammingKits\nodejs\node_global&quot;</code>需要修改环境变量。</del></p><p>以后npm和cnpm安装的全局模块都会被放到 D:\ProgrammingKits\nodejs\node_modules 下，跟自带的npm模块本体在一个文件夹中。</p><h2 id="cnpm"><a href="#cnpm" class="headerlink" title="cnpm"></a>cnpm</h2><p>这里安装淘宝的cnpm包管理器，以提高下载速度。</p><ul><li>运行<code>npm install -g cnpm --registry=http://registry.npm.taobao.org</code></li><li><code>cnpm -v</code> 确认cnpm版本，安装成功</li></ul><h2 id="hexo"><a href="#hexo" class="headerlink" title="hexo"></a>hexo</h2><p>静态博客框架</p><ul><li>运行<code>cnpm install -g hexo-cli</code> 安装hexo框架</li><li><code>hexo -v</code>确认hexo版本，安装成功</li></ul><h1 id="Hexo框架的使用"><a href="#Hexo框架的使用" class="headerlink" title="Hexo框架的使用"></a>Hexo框架的使用</h1><ul><li>hexo常用命令<ul><li><code>hexo init</code>初始化博客</li><li><code>hexo clean</code>清理缓存文件</li><li><code>hexo g</code>生成文件</li><li><code>hexo s</code>运行本地服务器</li><li><code>hexo d</code>部署到服务器</li><li><code>hexo n &quot;MyBlog&quot;</code>创建新的文章</li></ul></li></ul><p>现在我们只需要在 D:\MyBlog\HexoBlog 下运行<code>hexo init &amp; hexo s</code>，在浏览器中输入 <a href="http://localhost:4000/">localhost:4000</a> 即为最初始的博客内容。</p><h1 id="部署博客"><a href="#部署博客" class="headerlink" title="部署博客"></a>部署博客</h1><h2 id="创建仓库"><a href="#创建仓库" class="headerlink" title="创建仓库"></a>创建仓库</h2><p>用来存放你的代码/网站供别人访问</p><p><img src="/2021/01/Hexo%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E5%92%8C%E9%83%A8%E7%BD%B2/Untitled.png" alt="Hexo静态博客搭建和部署/Untitled.png"></p><p><img src="/2021/01/Hexo%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E5%92%8C%E9%83%A8%E7%BD%B2/Untitled%201.png" alt="Hexo静态博客搭建和部署/Untitled%201.png"></p><h2 id="创建部署分支"><a href="#创建部署分支" class="headerlink" title="创建部署分支"></a>创建部署分支</h2><p>master用来放代码，ph-pages用来部署网站</p><p><img src="/2021/01/Hexo%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E5%92%8C%E9%83%A8%E7%BD%B2/Untitled%202.png" alt="Hexo静态博客搭建和部署/Untitled%202.png"></p><p><img src="/2021/01/Hexo%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E5%92%8C%E9%83%A8%E7%BD%B2/Untitled%203.png" alt="Hexo静态博客搭建和部署/Untitled%203.png"></p><h2 id="开启Gitee-Pages服务"><a href="#开启Gitee-Pages服务" class="headerlink" title="开启Gitee Pages服务"></a>开启Gitee Pages服务</h2><p><img src="/2021/01/Hexo%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E5%92%8C%E9%83%A8%E7%BD%B2/Untitled%204.png" alt="Hexo静态博客搭建和部署/Untitled%204.png"></p><h2 id="创建公钥"><a href="#创建公钥" class="headerlink" title="创建公钥"></a>创建公钥</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -C <span class="string">&quot;邮箱地址&quot;</span></span><br></pre></td></tr></table></figure><p>密钥对生成后默认的位置是在 C:\Users\Administrator.ssh 的目录下。</p><p>其中 id_rsa 是私钥，id_rsa.pub 是公钥。</p><p>用记事本打开并复制公钥。</p><h2 id="添加公钥"><a href="#添加公钥" class="headerlink" title="添加公钥"></a>添加公钥</h2><p><img src="/2021/01/Hexo%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E5%92%8C%E9%83%A8%E7%BD%B2/Untitled%205.png" alt="Hexo静态博客搭建和部署/Untitled%205.png"></p><p>将复制到的公钥粘贴进去并确定保存。</p><h2 id="安装hexo-deployer-git"><a href="#安装hexo-deployer-git" class="headerlink" title="安装hexo-deployer-git"></a>安装hexo-deployer-git</h2><ul><li>运行<code>npm install hexo-deployer-git --save</code></li></ul><h2 id="修改配置文件"><a href="#修改配置文件" class="headerlink" title="修改配置文件"></a>修改配置文件</h2><p>打开D:\MyBlog\HexoBlog_config.yml查找deploy，并行修改下面这段代码</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line"><span class="built_in">type</span>: git</span><br><span class="line">repo: https://gitee.com/NephrenCake/NephrenCake.git</span><br><span class="line">branch: ph-pages</span><br></pre></td></tr></table></figure><h2 id="部署至云端"><a href="#部署至云端" class="headerlink" title="部署至云端"></a>部署至云端</h2><ul><li>运行<code>hexo d</code></li></ul><blockquote><p><a href="https://nephrencake.gitee.io/">https://nephrencake.gitee.io/</a> 即静态博客的地址了。</p></blockquote><ul><li>如果有网页不同步的时候<ul><li>在Gitee Pages 服务中更新部署（每次deploy之后都要手动更新）</li><li>清理浏览器缓存</li></ul></li></ul><p><img src="/2021/01/Hexo%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E5%92%8C%E9%83%A8%E7%BD%B2/Untitled%206.png" alt="Hexo静态博客搭建和部署/Untitled%206.png"></p><h1 id="GitHub部署"><a href="#GitHub部署" class="headerlink" title="GitHub部署"></a>GitHub部署</h1><h2 id="创建博客仓库"><a href="#创建博客仓库" class="headerlink" title="创建博客仓库"></a>创建博客仓库</h2><ol><li>New repository</li><li>仓库名应该为：<code>用户名.github.io</code></li></ol><h2 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h2><ol><li>hexo clean &amp; hexo g &amp; hexo d</li><li>推上去就可以直接访问 <code>用户名.github.io</code> 了</li></ol>]]></content>
      
      
      <categories>
          
          <category> Hexo博客搭建 </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
</search>
