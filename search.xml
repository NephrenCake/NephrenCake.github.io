<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>计算机组成原理-完结目录</title>
      <link href="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E5%AE%8C%E7%BB%93%E7%9B%AE%E5%BD%95/"/>
      <url>/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E5%AE%8C%E7%BB%93%E7%9B%AE%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<h1 id="计算机组成原理-完结目录"><a href="#计算机组成原理-完结目录" class="headerlink" title="计算机组成原理-完结目录"></a>计算机组成原理-完结目录</h1><p>教程视频传送门：</p><ol><li><a href="https://www.bilibili.com/video/BV1BE411D7ii">王道计算机考研 计算机组成原理</a></li></ol><p>推荐资源：</p><ol><li>王道配套书</li></ol><p>不能只看视频，==要过一遍书，做一遍题==！</p><table><thead><tr><th align="center"><a href="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part1/">计算机组成原理-Part1——计算机系统概述</a></th></tr></thead><tbody><tr><td align="center"><strong><a href="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part2/">计算机组成原理-Part2——数据的表示和运算</a></strong></td></tr><tr><td align="center"><strong><a href="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part3/">计算机组成原理-Part3——存储系统</a></strong></td></tr><tr><td align="center"><strong><a href="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part4/">计算机组成原理-Part4——指令系统</a></strong></td></tr><tr><td align="center"><strong><a href="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part5/">计算机组成原理-Part5——中央处理器</a></strong></td></tr><tr><td align="center"><strong><a href="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part6/">计算机组成原理-Part6——总线</a></strong></td></tr><tr><td align="center"><strong><a href="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part7/">计算机组成原理-Part7——I/O 系统</a></strong></td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 计算机组成原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 408 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机组成原理-Part7</title>
      <link href="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part7/"/>
      <url>/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part7/</url>
      
        <content type="html"><![CDATA[<h1 id="计算机组成原理-Part7——I-O-系统"><a href="#计算机组成原理-Part7——I-O-系统" class="headerlink" title="计算机组成原理-Part7——I/O 系统"></a>计算机组成原理-Part7——I/O 系统</h1><p>[TOC]</p><h2 id="I-O-系统基本概念"><a href="#I-O-系统基本概念" class="headerlink" title="I/O 系统基本概念"></a>I/O 系统基本概念</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><ul><li>I/O 设备：可以将数据输入到计算机，或者可以接收计算机输出数据的外部设备，包括<strong>输入设备、输出设备、外存设备</strong>。</li><li>I/O 接口：又称 I/O 控制器（I/O Controller）、设备控制器，负责协调主机与外部设备之间的数据传输<ul><li>I/O 控制器就是一块芯片，常被集成在主板上</li><li>现在的 I/O 接口（芯片）也会被集成在南桥芯片内部</li></ul></li><li>数据流：键盘 -&gt; I/O 接口的数据寄存器 -&gt; 数据总线 -&gt; CPU某寄存器 -&gt; 主存（变量 i 的对应位置）</li></ul><h3 id="控制方式"><a href="#控制方式" class="headerlink" title="控制方式"></a>控制方式</h3><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part7/image-20211028202903178.png" alt="image-20211028202903178" style="zoom:80%;"><ul><li><strong>程序查询方式</strong>：CPU 不断轮询检查 I/O 控制器中的“状态寄存器”，<strong>直到检测到状态为“已完成”之后</strong>，才从数据寄存器取出输入数据（如程序中的输入等待）</li><li><strong>程序中断方式</strong>：等待键盘 I/O 时 CPU 可以先去执行其他程序，<strong>键盘 I/O 完成后 I/O 控制器向 CPU 发出中断请求，CPU 响应中断请求</strong>，并取走输入数据</li><li><strong>DMA 控制方式</strong>：主存与高速 I/O 设备之间有一条直接数据通路（DMA总线）。CPU 向 DMA 接口发出“读/写”命令，并指明主存地址、磁盘地址、读写数据量等参数。<ul><li>DMA 控制器自动控制磁盘与主存的数据读写，<strong>DMA 控制器与主存每次传送1个字</strong>，<strong>每当完成一整块数据读写</strong>（如 1KB 为一整块） ，才向 CPU 发出一次中断请求。</li><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part7/image-20211027224155076.png" alt="image-20211027224155076" style="zoom:80%;"></li></ul></li><li><strong>通道控制方式</strong>：相比 DMA 控制方式，不仅不与高速外设进行直接相连，包括低速外设都交由通道来管理，且通道程序保存在内存中。<ul><li>针对场景：I/O 密集型场景</li><li>通道：可以理解为是“弱鸡版的 CPU”。通道可以识别并执行一系列通道指令，通道指令种类、功能通常比较单一</li><li>步骤：<ol><li>CPU 向通道发出 I/O 指令。指明通道程序在内存中的位置，并指明要操作的是哪个 I/O 设备。CPU 就可以去做其他事情</li><li>通道执行内存中的通道程序，控制 I/O 设备完成一系列任务</li><li>通道执行完规定的任务后，向 CPU 发出中断请求，之后 CPU 对中断进行处理</li></ol></li><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part7/image-20211027224229248.png" alt="image-20211027224229248" style="zoom:80%;"></li></ul></li></ul><h3 id="系统基本组成"><a href="#系统基本组成" class="headerlink" title="系统基本组成"></a>系统基本组成</h3><ul><li>一般来说，I/O 系统由 I/O 软件和 I/O 硬件两部分构成。</li><li>I/O 硬件：包括外部<strong>设备、I/O 接口 、I/O 总线</strong>等。</li><li>I/O 软件：包括<strong>驱动程序、用户程序、管理程序、升级补丁</strong>等。通常采用 <strong>I/O 指令</strong>和<strong>通道指令</strong>实现信息交换。<ul><li>I/O 指令：CPU 指令的一部分<ul><li>操作码（CPU 对 IO 接口做什么）+ 命令码（IO 接口对设备做什么）+ 设备码（对哪个设备进行操作）</li></ul></li><li>通道指令：通道能识别的指令（提前编制好放在主存中）<ul><li>在含有通道的计算机中，CPU 执行 I/O 指令对通道发出命令，由通道执行一系列通道指令，代替 CPU 对 I/O 设备进行管理</li></ul></li></ul></li></ul><h2 id="外部设备"><a href="#外部设备" class="headerlink" title="外部设备"></a>外部设备</h2><h3 id="总览"><a href="#总览" class="headerlink" title="总览"></a>总览</h3><ul><li>外部设备<ul><li>输入设备<ul><li>用于向计算机系统输入命令和文本、数据等信息的部件。</li><li>键盘、鼠标</li></ul></li><li>输出设备<ul><li>用于将计算机系统中的信息输出到计算机外部进行显示、交换等的部件。</li><li>显示器、打印机</li></ul></li><li>外存储器（考点：磁盘存取时间的计算）<ul><li>指除计算机内存及CPU缓存等以外的存储器。</li><li>磁盘存储器、磁盘阵列、光盘存储器、SSD</li></ul></li></ul></li></ul><h3 id="显示器"><a href="#显示器" class="headerlink" title="显示器"></a>显示器</h3><h4 id="性能标准（考点：显存的计算）"><a href="#性能标准（考点：显存的计算）" class="headerlink" title="性能标准（考点：显存的计算）"></a>性能标准（考点：显存的计算）</h4><ul><li>屏幕大小：以对角线长度表示，常用的有 12～29 英寸等。</li><li>分辨率：所能表示的像素个数，<strong>宽、高的像素的乘积</strong>，如1920×1280。</li><li>灰度级：显示的像素点的亮暗差别，典型的有 8 位（256级）、16 位等。<strong>n 位可以表示 2^n^ 种不同的亮度或颜色</strong>。</li><li>刷新：单位时间内扫描整个屏幕内容的次数，通常显示器刷新频率在 60～120 Hz。</li><li>显示存储器（VRAM）：<ul><li>也称刷新存储器，<strong>显存</strong>。由图像分辨率和灰度级决定，分辨率越高，灰度级越多，刷新存储器容量越大。</li><li>显存除了作为当前显示帧的缓存，还会用于保存用于渲染的图像数据，如 3D 模型。</li><li>集成显卡计算机中，通常分配一片内存作为显存</li><li><strong>VRAM 容量 = 分辨率 × 灰度级位数</strong><ul><li>例：1440 × 900 × 3 B ≈ 3.7MB（最低工作要求，能够存储一帧图像的信息）</li></ul></li><li><strong>VRAM 带宽 = 分辨率 × 灰度级位数 × 帧频</strong><ul><li>例：3.7 × 60 Hz = 222MB/s</li></ul></li></ul></li><li>显示器分类<ul><li>阴极射线管（CRT）显示器</li><li>液晶（LCD）显示器</li><li>发光二极管（LED）显示器</li></ul></li></ul><h4 id="阴极射线管显示器（考点：字符点阵的存储）"><a href="#阴极射线管显示器（考点：字符点阵的存储）" class="headerlink" title="阴极射线管显示器（考点：字符点阵的存储）"></a>阴极射线管显示器（考点：字符点阵的存储）</h4><p>按显示信息内容不同可分为</p><ul><li><strong>字符显示器</strong>（计算器）</li><li>图形显示器（特别用途设备）<ul><li>优点：分辨率高且显示的曲线平滑。</li><li>缺点：当显示复杂图形时，会有闪烁感。</li></ul></li><li>图像显示器（用户友好界面）</li></ul><p>字符显示器：</p><ul><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part7/image-20211028115857070.png" alt="image-20211028115857070"></li><li>显示字符的方法以点阵为基础。<ul><li><strong>点阵是指由 m×n 个点组成的阵列</strong>。</li><li>点阵的多少取决于显示<strong>字符的质量</strong>和<strong>字符窗口</strong>的大小。<ul><li><strong>字符窗口是指每个字符在屏幕上所占的点数</strong>，包括字符显示点阵和字符间隔。</li></ul></li></ul></li><li>对应于每个字符窗口，所需显示<strong>字符的 ASCII 代码被存放在视频存储器 VRAM</strong> 中，以备刷新。</li><li>将<strong>点阵存入由 ROM 构成的字符发生器</strong>中，在 CRT 进行光栅扫描的过程中，从字符发生器中依次读出某个字符的点阵，按照点阵中 0 和 1 代码不同控制扫描电子束的开或关，从而在屏幕上显示出字符。<ul><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part7/image-20211028115930559.png" alt="image-20211028115930559" style="zoom:80%;"></li><li>按扫描方式不同可分为<ul><li>光栅扫描显示器</li><li>随机扫描显示器</li></ul></li></ul></li></ul><h3 id="打印机"><a href="#打印机" class="headerlink" title="打印机"></a>打印机</h3><ul><li>按印字原理不同可分为<ul><li><strong>击打式打印机</strong>：利用机械动作使印字机构与色带和纸相撞而打印字符<ul><li>优：设备成本低 、印字质量好、防伪性好</li><li>缺：噪声大、速度慢</li></ul></li><li><strong>非击打式打印机</strong>：采用电、磁、光、喷墨等物理、化学方法来印刷字符<ul><li>优：速度快、噪声小</li><li>缺：成本高</li></ul></li></ul></li><li>按打印机工作方式不同可分为<ul><li><strong>串行打印机</strong>：逐字打印、速度慢</li><li><strong>行式打印机</strong>：逐行打印、速度快</li></ul></li><li>按工作方式可分为<ul><li><strong>针式打印机</strong>：<ul><li>原理：在联机状态下，主机发出打印命令，经接口、检测和控制电路，间歇驱动纵向送纸和打印头横向移动，同时驱动打印机间歇冲击色带，在纸上打印出所需内容。</li><li>特点：擅长多层复写打印，实现各种票据或蜡纸等的打印。工作原理简单，造价低廉，耗材（色带）便宜，但打印分辨率和打印速度不够高。</li></ul></li><li><strong>喷墨式打印机</strong>：<ul><li>原理：带电的喷墨雾点经过电极偏转后，直接在纸上形成所需字形。彩色喷墨打印机基于三基色原理，即分别喷射 3 种颜色墨滴，按一定的比例混合出所要求的颜色。</li><li>特点：打印噪声小，可实现高质量彩色打印；通常打印速度比针式打印机快；但防水性差，高质量打印需要专用打印纸。</li></ul></li><li><strong>激光打印机</strong>：<ul><li>原理：计算机输出的二进制信息，经过调制后的激光束扫描，在感光鼓上形成潜像，再经过显影、转印和定影，便在纸上得到所需的字符或图像。</li><li>特点：打印质量高、速度快、噪声小、处理能力强；但耗材多、价格较贵、不能复写打印多份，且对纸张的要求高。感光鼓（也称为硒鼓）是激光打印机的核心部件。</li></ul></li></ul></li></ul><h3 id="外部存储器"><a href="#外部存储器" class="headerlink" title="外部存储器"></a>外部存储器</h3><h4 id="磁表面存储器简介"><a href="#磁表面存储器简介" class="headerlink" title="磁表面存储器简介"></a>磁表面存储器简介</h4><ul><li>磁表面存储器，是指把磁性材料薄薄地涂在金属铝或塑料表面上作为载磁体来存储信息。磁盘存储器、磁带存储器和磁鼓存储器均属于磁表面存储器。</li><li>磁表面存储器的优点：<ul><li>存储容量大，位价格低； </li><li>记录介质可以重复使用；</li><li>记录信息可以长期保存而不丢失，甚至可以脱机存档； </li><li>非破坏性读出，读出时不需要再生。</li></ul></li><li>磁表面存储器的缺点：<ul><li>存取速度慢；</li><li>机械结构复杂；</li><li>对工作环境要求较高。</li></ul></li><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part7/image-20211028122201199.png" alt="image-20211028122201199"></li><li>原理：当磁头和磁性记录介质有相对运动时，通过电磁转换（/切割磁感线）完成读/写操作。</li><li>编码方法：按某种方案，把一串二进制信息变换成存储介质磁层中一个磁化翻转状态的序列。</li><li>磁记录方式：通常采用调频制（FM）和改进型调频制（MFM）的记录方式。</li></ul><h4 id="磁盘设备"><a href="#磁盘设备" class="headerlink" title="磁盘设备"></a>磁盘设备</h4><h5 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h5><ul><li>硬盘存储器<ul><li>硬盘存储器由磁盘驱动器、磁盘控制器和盘片组成。</li><li>磁盘驱动器：核心部件是磁头组件（磁头移动臂）和盘片组件（驱动轴盘片），温彻斯特盘是一种可移动头固定盘片的硬盘存储器。</li><li>磁盘控制器：是硬盘存储器和主机的接口，主流的标准有IDE、SCSI、SATA等。</li></ul></li><li>存储区域：<ul><li><strong>一块硬盘</strong>含有<strong>若干个盘片</strong>；（即有好几个盘）</li><li><strong>每个盘片</strong>可以有 1 或 2 面<strong>盘面</strong>；（即磁盘的正反面都可以利用，每个盘面对应 1 个磁头）</li><li><strong>每个记录面</strong>划分为<strong>若干条磁道</strong>；（<strong>所有记录面上的同一条磁道组成一个柱面</strong>）</li><li>而<strong>每条磁道</strong>又划分为<strong>若干个扇区</strong>；（切蛋糕）</li><li><strong>扇区（也称块）是磁盘读写的最小单位</strong>，也就是说磁盘<strong>按块存取</strong>。</li><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part7/image-20211028124407864.png" alt="image-20211028124407864"></li></ul></li><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part7/image-20211028124733827.png" alt="image-20211028124733827"></li></ul><h5 id="性能指标"><a href="#性能指标" class="headerlink" title="性能指标"></a>性能指标</h5><ul><li>磁盘的容量：一个磁盘所能存储的字节总数称为磁盘容量。磁盘容量有非格式化容量和格式化容量之分。<ul><li>非格式化容量：指磁记录表面理论氪用的磁化单元总数。</li><li>格式化容量：指按照某种特定的记录格式后所能利用、存储的信息总量。</li></ul></li><li>记录密度：记录密度是指盘片单位面积上记录的二进制的信息量，通常以道密度、位密度和面密度表示。<ul><li>道密度：沿磁盘半径方向单位长度上的磁道数；</li><li>位密度：一条磁道单位长度上能记录的二进制代码位数；</li><li>面密度：位密度和道密度的乘积。</li><li>注意：磁盘所有磁道记录的信息量一定是相等的，并不是圆越大信息越多，故<strong>越内侧的磁道位密度越大</strong>。</li></ul></li><li>平均存取时间：<ul><li><code>平均存取时间 = 磁盘控制器延迟（可能会有）+ 寻道时间（磁头移动到目的磁道）+ 旋转延迟时间（磁头定位到所在扇区）+ 传输时间（传输数据所花费的时间）</code></li><li>一般寻道时间会在题中给出，旋转延迟时间可以按数学期望（即转半圈）来计算，同时通过转速也可以确定转一个扇区的时间</li><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part7/image-20211028130946542.png" alt="image-20211028130946542" style="zoom:80%;"></li></ul></li><li>数据传输率：磁盘存储器在单位时间内向主机传送数据的字节数，称为数据传输率。<ul><li>假设磁盘转数为 r（转/秒），每条磁道容量为 N 个字节，则数据传输率为 D<del>r</del>=r×N</li></ul></li></ul><h5 id="磁盘地址"><a href="#磁盘地址" class="headerlink" title="磁盘地址"></a>磁盘地址</h5><ul><li>主机向磁盘控制器发送寻址信息，包括<ul><li>驱动器号：一台电脑可能有多个硬盘</li><li>柱面（磁道）号：移动磁头臂（寻道）</li><li>盘面号：激活某个磁头</li><li>扇区号：通过旋转将特定扇区划过磁头下方</li></ul></li><li>例：若系统中有 4 个驱动器，每个驱动器带一个磁盘，每个磁盘 256 个磁道、16 个盘面，每个盘面划分为 16个扇区，则每个扇区地址要 18 位二进制代码<ul><li>驱动器号（2bit）+ 柱面（磁道）号（8bit）+ 盘面号（4bit）+ 扇区号（4bit） </li></ul></li></ul><h5 id="硬盘的工作过程"><a href="#硬盘的工作过程" class="headerlink" title="硬盘的工作过程"></a>硬盘的工作过程</h5><ul><li>硬盘的主要操作是<strong>寻址、读盘、写盘</strong>。每个操作都对应一个控制字，硬盘工作时，第一步是取控制字，第二步是执行控制字。</li><li>硬盘属于机械式部件，其读写操作是串行的，不可能在同一时刻既读又写，也不可能在同一时刻读两组数据或写两组数据。</li><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part7/image-20211028150614567.png" alt="image-20211028150614567" style="zoom:80%;"></li></ul><h4 id="磁盘阵列"><a href="#磁盘阵列" class="headerlink" title="磁盘阵列"></a>磁盘阵列</h4><ul><li>RAID（ Redundant Array of Inexpensive Disks，廉价冗余磁盘阵列）是将多个独立的物理磁盘组成一个独立的逻辑盘，数据在多个物理盘上分割交叉存储、并行访问，具有更好的存储性能、可靠性和安全性。</li><li>RAID 有 RAID1～RAID5 的几种方案，无论何时有磁盘损坏，都可以随时拔出受损的磁盘再插入好的磁盘，而数据不会损坏。（raid 数越高，冗余越少、越稳定）<ul><li>RAID0：无冗余和无校验的磁盘阵列。（条带化，提高存取速度，没有容错能力）</li><li>RAID1：镜像磁盘阵列。（镜像磁盘互为备份，容量减少一半）</li><li>RAID2：采用纠错的海明码的磁盘阵列。（开始通过数据校验提高容错能力）</li><li>RAID3：位交叉奇偶校验的磁盘阵列。</li><li>RAID4：块交叉奇偶校验的磁盘阵列。</li><li>RAID5：无独立校验的奇偶校验磁盘阵列。</li></ul></li><li>RAID 通过同时使用多个磁盘，提高传输率；通过在多个磁盘上并行存取来大幅提高存储系统的数据吞吐量；通过镜像功能，提高安全可靠性；通过数据校验，提供容错能力。</li></ul><h4 id="光盘存储器"><a href="#光盘存储器" class="headerlink" title="光盘存储器"></a>光盘存储器</h4><ul><li>利用光学原理读/写信息的存储装置，采用聚焦激光束对盘式介质以非接触的方式记录信息。</li><li>光盘的类型：<ul><li>CD-ROM：只读型光盘，只能读出其中内容，不能写入或修改。</li><li>CD-R：只可写入一次信息，之后不可修改。</li><li>CD-RW：可读可写光盘，可以重复读写。</li><li>DVD-ROM：高容量的 CD-ROM，DVD 表示通用数字化多功能光盘。</li></ul></li></ul><h4 id="固态硬盘"><a href="#固态硬盘" class="headerlink" title="固态硬盘"></a>固态硬盘</h4><ul><li>由 Flash Memory 组成，以及其他硬件和软件的支持。</li><li>闪存（Flash Memory）是在 E2PROM 的基础上发展起来的，<strong>本质上是只读存储器</strong>。</li></ul><h2 id="I-O-接口"><a href="#I-O-接口" class="headerlink" title="I/O 接口"></a>I/O 接口</h2><h3 id="主要功能"><a href="#主要功能" class="headerlink" title="主要功能"></a>主要功能</h3><ul><li><strong>数据缓冲</strong>：通过<strong>数据缓冲寄存器</strong>（DBR）达到主机和外设工作速度的匹配</li><li><strong>错误或状态监测</strong>：通过<strong>状态寄存器</strong>反馈设备的各种错误、状态信息，供 CPU 查用</li><li><strong>控制和定时</strong>：接收从控制总线发来的控制信号、时钟信号</li><li><strong>数据格式转换</strong>：“串-并”、“并-串”等格式转换</li><li><strong>与主机和设备通信</strong>：实现“主机—I/O接口—I/O设备”之间的通信</li></ul><h3 id="结构与原理"><a href="#结构与原理" class="headerlink" title="结构与原理"></a>结构与原理</h3><ul><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part7/image-20211028162350702.png" alt="image-20211028162350702" style="zoom: 67%;"><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part7/image-20211028202711609.png" alt="image-20211028202711609" style="zoom:67%;"></li><li><strong>内部接口</strong>：内部接口与系统总线相连，实质上是与内存、CPU 相连。</li><li><strong>外部接口</strong>：外部接口通过接口电缆与外设相连。外部接口的数据传输可能是串行方式，因此 I/O 接口需具有串/并转换功能。</li><li><strong>工作原理</strong>：<ul><li>发命令：发送<strong>命令字</strong>到 I/O 控制寄存器，向设备发送命令（需要驱动程序的协助）</li><li>读状态：从状态寄存器读取<strong>状态字</strong>，获得设备或 I/O 控制器的状态信息</li><li>读/写数据：从数据缓冲寄存器发送或读取数据，完成主机与外设的数据交换</li></ul></li><li>控制寄存器、状态寄存器在<strong>使用时间上错开</strong>，因此有的 I/O 接口中可将二者合二为一</li><li><strong>IO 控制器中的一个个寄存器也称为一个个 I/O 端口</strong></li></ul><h3 id="I-O-端口"><a href="#I-O-端口" class="headerlink" title="I/O 端口"></a>I/O 端口</h3><ul><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part7/image-20211028164339128.png" alt="image-20211028164339128" style="zoom: 67%;"><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part7/image-20211028163713330.png" alt="image-20211028163713330" style="zoom:80%;"></li><li><strong>统一编址</strong>：靠不同的<strong>地址码</strong>区分内存和 I/O 设备。<strong>访存类的指令都</strong>可以访问 I/O 端口。又称<strong>存储器映射方式</strong>。<ul><li>优点：1. 不需要专门的输入/输出指令，所有访存指令可直接访问端口，程序设计灵活性高；2. 端口有较大的编址空间；3. 读写控制逻辑电路简单</li><li>缺点：1. 端口占用了主存地址空间，使主存地址空间变小；2. 外设寻址时间长（地址位数多，地址译码速度慢）</li></ul></li><li><strong>独立编址</strong>：靠不同的<strong>指令</strong>区分内存和 I/O 设备。<strong>只能用专门的 I/O 指令</strong>可以访问 I/O 端口。<ul><li>优点：1. 使用专用 I/O 指令，程序编制清晰；2. I/O 端口地址位数少，<strong>地址译码速度快</strong>；3. I/O 端口的地址不占用主存地址空间</li><li>缺点：1. I/O 指令类型少，一般只能对端口进行传送操作；2. <strong>程序设计灵活性差</strong>；3. 需要 CPU 提供存储器读/写、I/O 设备读/写两组控制信号，增加了控制逻辑电路的复杂性</li></ul></li></ul><h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><ul><li>按数据传送方式可分为<ul><li><strong>并行接口</strong>：一个字节或一个字所有位同时传送。</li><li><strong>串行接口</strong>：一位一位地传送。</li><li>这里指的是<strong>外设和接口一侧</strong>的传送方式，为了传输到主机和接口一侧，接口要完成数据格式转换。</li></ul></li><li>按主机访问I/O设备的控制方式可分为<ul><li>程序查询接口</li><li>中断接口</li><li>DMA 接口</li></ul></li><li>按功能选择的灵活性可分为<ul><li>可编程接口</li><li>不可编程接口</li></ul></li></ul><h2 id="I-O-方式"><a href="#I-O-方式" class="headerlink" title="I/O 方式"></a>I/O 方式</h2><h3 id="程序查询方式"><a href="#程序查询方式" class="headerlink" title="程序查询方式"></a>程序查询方式</h3><ul><li>优点：接口<strong>设计简单</strong>、设备量少。</li><li>缺点：CPU 在信息传送过程中要<strong>花费很多时间用于查询和等待</strong>，而且在一段时间内只能和一台外设交换信息，效率大大降低。</li><li>例题<ul><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part7/image-20211028211418243.png" alt="image-20211028211418243"></li></ul></li><li><strong>独占查询</strong>：CPU 100%的时间都在查询I/O状态，完全串行</li><li><strong>定时查询</strong>：在保证数据不丢失的情况下，每隔一段时间 CPU 就查询一次 I/O 状态。查询的间隔内 CPU 可以执行其他程序</li></ul><h3 id="中断系统"><a href="#中断系统" class="headerlink" title="中断系统"></a>中断系统</h3><h4 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h4><ol><li>中断请求</li></ol><ul><li>中断源向 CPU 发送中断请求信号。</li></ul><ol start="2"><li>中断响应</li></ol><ul><li><strong>中断请求标记</strong>：<ul><li>为了区分不同的中断源，中断系统需对每个中断源设置<strong>中断请求标记触发器 INTR</strong>，当其状态为“1”时，表示中断源有请求。</li><li>这些触发器可组成<strong>中断请求标记寄存器</strong>，该寄存器可集中在CPU中，也可分散在各个中断源中。</li><li>对于<strong>外中断</strong>，CPU <strong>响应中断的时间</strong>是在每条<strong>指令执行阶段的结束前</strong>。</li><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part7/image-20211029131814925.png" alt="image-20211029131814925" style="zoom:80%;"></li></ul></li><li><strong>响应中断的条件</strong>：<ol><li>中断源有中断请求。</li><li>一条指令执行完毕，且没有更紧迫的任务。</li><li>允许中断：当前 PSW 的 IF（Interrupt Flag）为真<ul><li>IF=1 表示开中断（允许中断）；IF=0 表示关中断（不允许中断）</li><li>关中断的作用：实现<strong>原子操作</strong>（必须一次性做完的操作）</li><li>除非是不得不响应的非屏蔽中断（如掉电）</li></ul></li></ol></li><li><strong>中断判优</strong>：多个中断源同时提出请求时通过中断判优逻辑响应一个中断源。<ul><li>中断判优既可以用硬件实现，也可用软件实现：<ul><li>硬件实现是通过<strong>硬件排队器</strong>实现的，它既可以设置在 CPU 中，也可以分散在各个中断源中；</li><li>软件实现是通过<strong>查询程序</strong>实现的。（相比硬件更慢，通常使用硬件排队器）</li></ul></li><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part7/image-20211029132629325.png" alt="image-20211029132629325"></li><li><strong>优先级设置</strong>：<ol><li>硬件故障中断属于最高级，其次是软件中断；</li><li>非屏蔽中断优于可屏蔽中断；</li><li>DMA 请求优于 I/O 设备传送的中断请求</li><li>高速设备优于低速设备；</li><li>输入设备优于输出设备；</li><li>实时设备优于普通设备。</li></ol></li></ul></li></ul><ol start="3"><li>中断处理</li></ol><ul><li><strong>中断隐指令</strong>：CPU 在检测到中断请求时自动完成的一系列动作<ul><li><strong>关中断</strong>。为了在保护现场期间不被新的中断打断，必须关中断，从而保证被中断的程序在中断服务程序执行完毕之后能接着正确地执行下去。</li><li><strong>保存断点</strong>。为了保证在中断服务程序执行完毕后能正确地返回到原来的程序，必须将原来程序的断点（即程序计数器（PC）的内容）保存起来。可以存入堆栈或指定单元。</li><li><strong>引出中断服务程序</strong>。引出中断服务程序的实质就是取出中断服务程序的入口地址并传送给程序计数器（PC）。<ul><li>软件向量法</li><li>硬件向量法<ul><li>由<strong>硬件</strong>产生指向<strong>中断向量</strong>的<strong>向量地址</strong></li><li><strong>中断向量</strong>指向<strong>中断服务程序</strong>的<strong>入口地址</strong></li><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part7/image-20211029204003689.png" alt="image-20211029204003689" style="zoom:80%;"></li></ul></li></ul></li><li>以及其他任务……</li></ul></li><li><strong>中断服务程序</strong>。<ul><li><strong>保护现场</strong>：保存通用寄存器和状态寄存器的内容（eg：保存ACC寄存器的值），以便返回原程序后可以恢复 CPU 环境。可使用堆栈，也可以使用特定存储单元。</li><li><strong>中断服务</strong>（设备服务）：主体部分，如通过程序控制需打印的字符代码送入打印机的缓冲存储器中（eg：中断服务的过程中有可能修改 ACC 寄存器的值）</li><li><strong>恢复现场</strong>：通过出栈指令或取数指令把之前保存的信息送回寄存器中（eg：把原程序算到一般的 ACC 值恢复原样）</li><li><strong>中断返回</strong>：通过中断返回指令回到原程序断点处。</li></ul></li></ul><h4 id="多重中断"><a href="#多重中断" class="headerlink" title="多重中断"></a>多重中断</h4><ul><li><p><strong>单重中断</strong>：执行中断服务程序时不响应新的中断请求。</p><ul><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part7/image-20211029205105146.png" alt="image-20211029205105146" style="zoom: 67%;"></li></ul></li><li><p><strong>多重中断</strong>：又称<strong>中断嵌套</strong>，执行中断服务程序时可响应新的中断请求。</p><ul><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part7/image-20211029210138245.png" alt="image-20211029210138245" style="zoom:67%;"><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part7/image-20211029205642997.png" alt="image-20211029205642997"></li></ul></li><li><p>中断屏蔽技术：</p><ul><li><p>CPU 要具备多重中断的功能，须满足下列条件（主要用于多重中断）</p><ul><li>在中断服务程序中提前设置开中断指令。</li><li>优先级别高的中断源有权中断优先级别低的中断源。</li></ul></li><li><p>屏蔽字设置的规律：</p><ol><li><p>一般用“1”表示屏蔽，“0”表示正常申请。</p></li><li><p>每个中断源对应一个屏蔽字（在处理该中断源的中断服务程序时，屏蔽寄存器中的内容为该中断源对应的屏蔽字）。</p></li><li><p>屏蔽字中“1”越多，优先级越高。每个屏蔽字中至少有一个“1”（至少要能屏蔽自身的中断）。</p></li></ol></li><li><p>例题：</p><ul><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part7/image-20211029221003756.png" alt="image-20211029221003756"></li></ul></li></ul></li></ul><h3 id="程序中断方式"><a href="#程序中断方式" class="headerlink" title="程序中断方式"></a>程序中断方式</h3><ul><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part7/image-20211029220829035.png" alt="image-20211029220829035"></li><li>例题：<ul><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part7/image-20211029221803157.png" alt="image-20211029221803157"></li></ul></li></ul><h3 id="DMA-方式"><a href="#DMA-方式" class="headerlink" title="DMA 方式"></a>DMA 方式</h3><h4 id="DMA-传送过程"><a href="#DMA-传送过程" class="headerlink" title="DMA 传送过程"></a>DMA 传送过程</h4><ul><li><p><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part7/image-20211029232153701.png" alt="image-20211029232153701"></p></li><li><p>DMA 控制器工作流程：</p><ul><li>CPU 向 DMA 控制器指明要<strong>输入还是输出</strong>；要传送<strong>多少数据</strong>；数据在<strong>主存、外设中的地址</strong>。</li><li>接受外设发出的 DMA 请求（外设传送一个字的请求），并向 CPU 发出<strong>总线请求</strong>。</li><li>CPU 响应此总线请求，发出总线响应信号，接管总线控制权，进入 DMA 操作周期。</li><li>确定传送数据的<strong>主存单元地址及长度</strong>，并能自动修改<strong>主存地址计数</strong>和<strong>传送长度计数</strong>。</li><li>规定数据在主存和外设间的<strong>传送方向</strong>，发出读写等控制信号，执行数据传送操作。</li><li>向 CPU 报告 DMA 操作的结束。</li></ul></li><li><p>DMA 组成：</p><ul><li>主存地址计数器：简称 AR，存放要交换数据的主存地址。</li><li>传送长度计数器：简称 WC，用来记录传送数据的长度，计数溢出时，数据即传送完毕，自动发中断请求信号。</li><li>数据缓冲寄存器：用于暂存每次传送的数据。</li><li>DMA 请求触发器：每当 I/O 设备准备好数据后给出一个控制信号，使 DMA 请求触发器置位。</li><li>控制/状态逻辑：由控制和时序电路及状态标志组成，用于指定传送方向，修改传送参数，并对DMA请求信号和CPU响应信号进行协调和同步。</li><li>中断机构：当一个数据块传送完毕后触发中断机构，向CPU提出中断请求。</li></ul></li><li><p>注：在 DMA 传送过程中，DMA 控制器将接管 CPU 的地址总线、数据总线和控制总线，CPU 的主存控制信号被禁止使用。而当 DMA 传送结束后，将恢复 CPU 的一切权利并开始执行其操作。</p></li><li><p>CPU 和 DMA 控制器访问主存可能产生冲突</p><ul><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part7/image-20211030223325881.png" alt="image-20211030223325881"></li></ul></li></ul><h4 id="DMA-传送方式"><a href="#DMA-传送方式" class="headerlink" title="DMA 传送方式"></a>DMA 传送方式</h4><ul><li>主存和 DMA 控制器之间有一条数据通路，因此主存和 I/O 设备之间交换信息时，不通过 CPU。但当 I/O 设备和 CPU 同时访问主存时，可能发生冲突，为了有效地使用主存，DMA 控制器与 CPU 通常采用以下 3 种方法使用主存。<ol><li>停止 CPU 访问主存<ul><li>优点：控制简单</li><li>缺点：CPU 处于不工作状态或保持状态未充分发挥 CPU 对主存的利用率</li><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part7/image-20211031092120253.png" alt="image-20211031092120253"></li></ul></li><li>DMA 与 CPU 交替访存<ul><li>一个 CPU 周期，分为 C1 和 C2 两个周期。C1 专供 DMA 访存，C2 专供 CPU 访存</li><li>优点：不需要总线使用权的申请、建立和归还过程</li><li>缺点：硬件逻辑更为复杂</li><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part7/image-20211031092135200.png" alt="image-20211031092135200"></li></ul></li><li>周期挪用（周期窃取）<ul><li>周期指<strong>存取周期</strong>。</li><li>DMA 访问主存有三种可能：<ul><li>CPU 此时不访存（不冲突）</li><li>CPU 正在访存（存取周期结束让出总线）</li><li>CPU 与 DMA 同时请求访存（I/O 访存优先）</li></ul></li><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part7/image-20211031092208256.png" alt="image-20211031092208256"></li></ul></li></ol></li></ul><h4 id="DMA-方式的特点"><a href="#DMA-方式的特点" class="headerlink" title="DMA 方式的特点"></a>DMA 方式的特点</h4><ul><li>主存和 DMA 接口之间有一条直接数据通路。 由于 DMA 方式传送数据不需要经过 CPU，因此不必中断现行程序，<strong>I/O 与主机并行工作，程序和传送并行工作</strong>。</li><li>DMA 方式具有下列特点：<ul><li>它使主存与 CPU 的固定联系脱钩，主存既可被 CPU 访问，又可被外设访问。 </li><li>在数据块传送时，主存地址的确定、传送数据的计数等都由硬件电路直接实现。</li><li>主存中要开辟专用缓冲区，及时供给和接收外设的数据。</li><li>DMA 传送速度快，CPU 和外设并行工作，提高了系统效率。</li><li>DMA 在传送开始前要通过程序进行预处理，结束后要通过中断方式进行后处理。</li></ul></li></ul><table><thead><tr><th></th><th>中断</th><th>DMA</th></tr></thead><tbody><tr><td>数据传输</td><td>程序控制</td><td>硬件控制</td></tr><tr><td>中断请求</td><td>每次传送数据</td><td>只有后处理</td></tr><tr><td>响应时间</td><td>指令周期结束</td><td>总线空闲即可</td></tr><tr><td>场景</td><td>CPU 控制低速设备</td><td>MDA 控制器控制高速设备</td></tr><tr><td>优先级</td><td>低于 DMA</td><td>高于中断</td></tr><tr><td>异常处理</td><td>能处理异常事件</td><td>仅传送数据</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 计算机组成原理 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>计算机组成原理-Part6</title>
      <link href="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part6/"/>
      <url>/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part6/</url>
      
        <content type="html"><![CDATA[<h1 id="计算机组成原理-Part6——总线"><a href="#计算机组成原理-Part6——总线" class="headerlink" title="计算机组成原理-Part6——总线"></a>计算机组成原理-Part6——总线</h1><p>[TOC]</p><h2 id="总线概述"><a href="#总线概述" class="headerlink" title="总线概述"></a>总线概述</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><ul><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part6/image-20211025162259335.png" alt="image-20211025162259335"></li><li><strong>总线</strong>是一组能为多个部件<strong>分时共享</strong>的<strong>公共</strong>信息传送<strong>线路</strong>。</li><li>同一时刻只能有<strong>一个设备控制</strong>总线传输操作，可以有<strong>一个或多个设备</strong>从总线<strong>接收</strong>数据。</li><li>特点：<ul><li>共享：指总线上可以挂接多个部件，各个部件之间互相交换的信息都可以通过这组线路分时共享。</li><li>分时：指同一时刻只允许有一个部件向总线发送信息，如果系统中有多个部件，则它们只能分时地向总线发送信息。</li></ul></li><li>特性：<ul><li>机械特性：尺寸、形状、管脚数、排列顺序</li><li>电气特性：传输方向（数据双向、地址/控制单向）和有效的电平范围（高电平、低电平的定义范围）</li><li>功能特性：每根传输线的功能（地址、数据、控制）</li><li>时间特性：信号的时序关系</li></ul></li><li><strong>数据通路</strong>描述的是数据的路径，是逻辑上的概念。<strong>数据总线</strong>是承载数据的物理载体，<strong>地址总线</strong>一样可以成为数据通路的一部分。</li></ul><h3 id="总线分类（重点）"><a href="#总线分类（重点）" class="headerlink" title="总线分类（重点）"></a>总线分类（重点）</h3><ul><li>按数据传输格式：<ul><li>串行总线<ul><li>优点：1. 只需要一条传输线，成本低廉，广泛应用于长距离传输；2. 不容易发生跳变；3. 应用于计算机内部时，可以节省布线空间。</li><li>缺点：1. 在数据发送和接收的时候要进行拆卸和装配，要考虑串行-并行转换的问题。</li></ul></li><li>并行总线<ul><li>优点：1. 总线的逻辑时序比较简单，电路实现起来比较容易。</li><li>缺点：1. 信号线数量多，占用更多的布线空间；2. 远距离传输成本高昂；3. 由于工作频率较高时，并行的信号线之间会产生严重干扰，对每条线等长的要求也越高，所以无法持续提升工作频率。</li></ul></li><li>并行总线传输速度一定比串行总线快，是错误的。</li></ul></li><li>按总线功能（连接的部件）：<ul><li>片内总线<ul><li>片内总线是芯片内部的总线。</li><li>是 CPU 芯片内部<strong>寄存器与寄存器</strong>之间、<strong>寄存器与 ALU</strong> 之间的公共连接线。</li></ul></li><li>系统总线<ul><li>系统总线是计算机系统内各功能部件（CPU、主存、I/O接口）之间相互连接的总线。</li><li>按系统总线<strong>传输信息内容</strong>的不同，又可分为3类：<strong>数据总线</strong>（Data Bus）、<strong>地址总线</strong>（Address Bus）和<strong>控制总线</strong>（Control Bus）。</li><li>数据总线（双向）：用来传输各功能部件之间的数据信息，其位数与<strong>机器字长、存储字长有关</strong>。</li><li>地址总线（单向）：用来指出数据总线上的源数据或目的数据所在的主存单元或 I/O 端口的地址，地址总线的位数与<strong>主存地址空间大小</strong>和<strong>设备数量</strong>有关。</li><li>控制总线（单根单向，整体双向）：传输的是控制信息，包括 <strong>CPU 送出的控制命令</strong>和<strong>主存（或外设）返回 CPU 的反馈信号</strong>。</li></ul></li><li>通信总线<ul><li>通信总线是用于计算机系统之间或计算机系统与其他系统（如远程通信设备、测试设备）之间信息传送的总线，通信总线也称为外部总线。</li></ul></li></ul></li><li>按时序控制方式：<ul><li>同步总线</li><li>异步总线</li></ul></li></ul><h3 id="系统总线的结构（重点）"><a href="#系统总线的结构（重点）" class="headerlink" title="系统总线的结构（重点）"></a>系统总线的结构（重点）</h3><ul><li>单总线结构<ul><li>结构：CPU、主存、I/O设备（通过I/O接口）都连接在<strong>一组</strong>总线（而不是只有一根信号线）上，允许 I/O 设备之间、I/O 设备和 CPU 之间或 I/O 设备与主存之间直接交换信息。</li><li>优点：结构简单，成本低，易于接入新的设备。</li><li>缺点：带宽低、负载重，多个部件只能争用唯一的总线，且不支持并行传送操作。CPU、IO 的速度差异导致总线性能并不能完全发挥。</li><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part6/image-20211025190248221.png" alt="image-20211025190248221" style="zoom:80%;"></li></ul></li><li>双总线结构<ul><li>结构：双总线结构有两条总线，一条是主存总线，用于 CPU、主存和通道之间进行数据传送；另一条是 I/O 总线，用于多个外部设备与通道之间进行数据传送。</li><li>优点：将较低速的 I/O 设备从单总线上分离出来，实现存储器总线和 I/O 总线分离。</li><li>缺点：需要增加通道等硬件设备。</li><li>主存总线支持突发（猝发）传送：<strong>只需要送出一个首地址，就可以读写多个地址连续（超出一次数据总线的传输能力）的数据，而不需要每次都发送子地址</strong>。</li><li>通道是具有特殊功能的处理器，能对 I/O 设备进行统一管理。 通道程序放在主存中。</li><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part6/image-20211025190342462.png" alt="image-20211025190342462" style="zoom:80%;"></li></ul></li><li>三总线结构<ul><li>结构：三总线结构是在计算机系统各部件之间采用 3 条各自独立的总线来构成信息通路，这3条总线分别为主存总线、I/O 总线和直接内存访问 DMA 总线。</li><li>优点：<strong>提高了 I/O 设备的性能</strong>，使其更快地响应命令，提高系统吞吐量。</li><li>缺点：系统工作效率较低。（三条总线同时刻只有一个能工作）</li><li>DMA：Direct Memory Access，直接内存访问。</li><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part6/image-20211025190627701.png" alt="image-20211025190627701" style="zoom:80%;"></li></ul></li><li>四总线结构<ul><li>桥接器：用于连接不同的总线，具有数据缓冲、转换和控制功能。</li><li>靠近 CPU 的总线速度较快。</li><li>每级总线的设计遵循总线标准。</li></ul></li></ul><h3 id="总线的性能指标"><a href="#总线的性能指标" class="headerlink" title="总线的性能指标"></a>总线的性能指标</h3><ol><li><p>总线的传输周期（总线周期）</p><ul><li><strong>一次总线操作所需的时间</strong>（包括申请阶段、 寻址阶段、传输阶段和结束阶段），通常由若干个总线时钟周期构成。</li><li>总线周期与总线时钟周期的对应关系要具体按照题意，有可能会有多对一、一对一、一对多。</li></ul></li><li><p>总线时钟周期</p><ul><li>即<strong>机器的时钟周期</strong>。总线也要受 CPU 时钟的控制。</li><li>现在的计算机中，总线时钟周期也有可能由桥接器提供</li></ul></li><li><p>总线的工作频率</p><ul><li>总线上各种操作的频率，为<strong>总线周期的倒数</strong>。 </li><li>若总线周期=N个时钟周期，则总线的工作频率=时钟频率/N。 </li><li>实际上指<strong>一秒内传送几次数据</strong>。</li></ul></li><li><p>总线的时钟频率</p><ul><li>即机器的时钟频率，为<strong>时钟周期的倒数</strong>。 </li><li>若时钟周期为T，则时钟频率为1/T。 </li><li>实际上指<strong>一秒内有多少个时钟周期</strong>。</li></ul></li><li><p>总线宽度</p><ul><li>又称为<strong>总线位宽</strong>，它是总线上<strong>同时能够传输的数据位数</strong>，</li><li>一般说总线宽度，通常是指<strong>数据总线的根数</strong>，如 32 根数据信号线称为 32 位（bit）总线。</li></ul></li><li><p>总线带宽</p><ul><li>可理解为总线的<strong>数据传输速率</strong>，即<strong>单位时间内总线上可传输数据的位数</strong>，通常用每秒钟传送信息的字节数来衡量，单位可用字节/秒（B/s）表示。</li><li>总线带宽 = 总线工作频率 × 总线宽度（bit/s）= 总线工作频率 × (总线宽度/8)（B/s）= 总线宽度/总线周期（bit/s）= (总线宽度/8)/总线周期（B/s）</li><li>总线带宽是指总线本身所能达到的<strong>最高传输速率</strong>。在计算实际的<strong>有效数据传输率</strong>时，要用实际传输的数据量（<strong>去除冗余校验位之后</strong>）除以耗时。</li><li>注意，串行总线和并行总线之间的比较就需要用到：总线带宽 = 总线工作频率 × 总线宽度</li></ul></li><li><p>总线复用</p><ul><li><p>总线复用是指<strong>一种信号线在不同的时间传输不同的信息</strong>。</p><p>可以使用<strong>较少的线</strong>传输更多的信息，从而节省了空间和成本。</p></li></ul></li><li><p>信号线数</p><ul><li>地址总线、数据总线和控制总线 3 种总线数的总和称为信号线数。</li><li><strong>只传输一位 bit 数据的先叫做信号线</strong></li></ul></li></ol><ul><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part6/image-20211026092049020.png" alt="image-20211026092049020"></li></ul><h2 id="总线仲裁"><a href="#总线仲裁" class="headerlink" title="总线仲裁"></a>总线仲裁</h2><h3 id="基本概念-1"><a href="#基本概念-1" class="headerlink" title="基本概念"></a>基本概念</h3><ul><li>针对问题：总线作为一种共享设备，不可避免地会出现同一时刻有多个主设备竞争总线控制权的问题。</li><li><strong>主设备：</strong>获得总线控制权的设备。</li><li><strong>从设备：</strong>被主设备访问的设备，只能响应从主设备发来的各种总线命令。</li></ul><h3 id="总线仲裁分类"><a href="#总线仲裁分类" class="headerlink" title="总线仲裁分类"></a>总线仲裁分类</h3><h4 id="集中仲裁方式"><a href="#集中仲裁方式" class="headerlink" title="集中仲裁方式"></a>集中仲裁方式</h4><ul><li><p>主要工作流程：</p><ul><li>主设备发出请求信号；</li><li>若多个主设备同时要使用总线，则由总线控制器的判优、仲裁逻辑按一定的优先等级顺序确定哪个主设备能使用总线；</li><li>获得总线使用权的主设备开始传送数据。</li></ul></li><li><p>链式查询方式</p><ul><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part6/image-20211026094129115.png" alt="image-20211026094129115"></li><li>BS、BR、BG 都是一根信号线</li><li>优先级：<ul><li>离总线控制器越近的部件，其优先级越高；</li><li>离总线控制器越远的部件，其优先级越低。</li></ul></li><li>优点：链式查询方式优先级固定。只需很少几根控制线就能按一定优先次序实现总线控制，结构简单，扩充容易。</li><li>缺点：对硬件电路的故障敏感，并且优先级不能改变。当优先级高的部件频繁请求使用总线时，会使<strong>优先级较低的部件长期不能使用总线</strong>。</li></ul></li><li><p>计数器定时查询方式</p><ul><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part6/image-20211026111543103.png" alt="image-20211026111543103" style="zoom:80%;"></li><li>结构特点：用一个计数器控制总线使用权，相对链式查询方式多了一组设备地址线（设备地址线是一组线），少了一根总线响应线 BG；它仍共用一根总线请求线。</li><li>优点：<ul><li>计数初始值可以改变优先次序</li><li>对电路的故障没有链式敏感</li></ul></li><li>缺点：<ul><li>增加了控制线数。若设备有 n 个，则需 [log2n]+2 条控制线</li><li>控制相对比链式查询相对复杂</li></ul></li></ul></li><li><p>独立请求方式</p><ul><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part6/image-20211026112051799.png" alt="image-20211026112051799" style="zoom:80%;"></li><li>结构特点：每一个设备均有一对总线请求线 BRi 和总线允许线 BGi。</li><li>优点：<ul><li>响应速度快，总线允许信号 BG 直接从控制器发送到有关设备，不必在设备间传递或者查询。</li><li>对优先次序的控制相当灵活。</li></ul></li><li>缺点：<ul><li>控制线数量多。若设备有n个，则需要 2n+1 条控制线。</li><li>总线的控制逻辑更加复杂</li></ul></li></ul></li></ul><blockquote><p>“总线忙”信号的建立者是<strong>获得总线控制权的设备</strong>，而不是仲裁器发出。</p></blockquote><p><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part6/image-20211026112251788.png" alt="image-20211026112251788"></p><h4 id="分布仲裁方式"><a href="#分布仲裁方式" class="headerlink" title="分布仲裁方式"></a>分布仲裁方式</h4><ul><li>特点：不需要中央仲裁器，每个潜在的主模块都有自己的仲裁器和仲裁号，多个仲裁器竞争使用总线。</li><li>步骤<ul><li>当设备有总线请求时，它们就<strong>把各自唯一的仲裁号发送到共享的仲裁总线上</strong>；</li><li><strong>每个仲裁器</strong>将从仲裁<strong>总线上得到的仲裁号</strong>与自己的仲裁号进行<strong>比较</strong>；</li><li>如果仲裁总线上的号优先级高，则它的总线请求不予响应，并撤销它的仲裁号；</li><li>最后，获胜者的仲裁号保留在仲裁总线上。</li></ul></li></ul><h2 id="总线操作和定时"><a href="#总线操作和定时" class="headerlink" title="总线操作和定时"></a>总线操作和定时</h2><h3 id="基本概念-2"><a href="#基本概念-2" class="headerlink" title="基本概念"></a>基本概念</h3><ul><li>总线周期的四个阶段<ul><li>申请分配阶段：由需要使用总线的主模块（或主设备）提出申请，经总线仲裁机构决定将下一传输周期的总线使用权。也可将此阶段细分为<strong>传输请求</strong>和<strong>总线仲裁</strong>两个阶段。</li><li>寻址阶段：获得使用权的主模块通过总线发出本次要访问的从模块的地址及有关命令，<strong>启动参与本次传输的从模块</strong>。</li><li>传输阶段：主模块和从模块进行<strong>数据交换</strong>，可单向或双向进行数据传送。</li><li>结束阶段：主模块的<strong>有关信息</strong>均从系统总线上<strong>撤除</strong>，让出总线使用权。</li></ul></li><li>针对问题：占用总线的一对设备如何进行数据传输</li><li><strong>总线定时</strong>，指总线在双方交换数据的过程中需要时间上配合关系的控制，实质是一种协议或规则<ul><li>同步通信(同步定时方式)：由<strong>统一时钟</strong>控制数据传送</li><li>异步通信(异步定时方式)：采用<strong>应答方式</strong>，没有公共时钟标准</li><li>半同步通信：同步、异步结合</li><li>分离式通信：充分挖掘系统总线每瞬间的潜力</li></ul></li></ul><h3 id="同步定时方式"><a href="#同步定时方式" class="headerlink" title="同步定时方式"></a>同步定时方式</h3><ul><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part6/image-20211026141316738.png" alt="image-20211026141316738"></li><li>同步定时方式：总线控制器采用一个<strong>统一的时钟信号</strong>来协调发送和接收双方的传送定时关系。</li><li>假设：CPU 作为主设备，选择某个输入设备作为从设备<ol><li>CPU 在 T1 时刻的上升沿给出地址信息</li><li>在T2的上升沿给出读命令（低电平有效），与地址信息相符合的输入设备按命令进行一系列的内部操作，且必须在T3的上升沿来之前将CPU所需的数据送到数据总线上。</li><li>CPU在T3时钟周期内，将数据线上的信息传送到其内部寄存器中。</li><li>CPU在T4的上升沿撤销读命令，输入设备不再向数据总线上传送数据，撤销它对数据总线的驱动。</li></ol></li><li>优点：<strong>传送速度快</strong>，具有较高的传输速率；<strong>总线控制逻辑简单</strong>。</li><li>缺点：主从设备属于强制性同步；不能及时进行数据通信的有效性检验，<strong>可靠性较差</strong>。</li><li>同步通信适用于<strong>总线长度较短</strong>（总线长度短，传输更稳定）及总线<strong>所接部件的存取时间比较接近</strong>的系统。</li></ul><h3 id="异步定时方式"><a href="#异步定时方式" class="headerlink" title="异步定时方式"></a>异步定时方式</h3><ul><li>在异步定时方式中，没有统一的时钟，也没有固定的时间间隔，完全依靠传送双方相互制约的“握手”信号来实现定时控制。</li><li>主设备提出交换信息的“请求”信号（指明操作与地址），经接口传送到从设备；从设备接到主设备的请求后，通过接口向主设备发出“回答”信号。</li><li>根据“请求”和“回答”信号的撤销是否互锁，分为以下 3 种类型。<ul><li><strong>不互锁方式</strong>：速度最快，可靠性最差<ul><li>主设备发出“请求”信号后，<strong>不必等</strong>到接到从设备的“回答”信号，而是经过一段时间，便撤销“请求”信号。</li><li>而从设备在接到“请求”信号后，发出“回答”信号，并经过一段时间，<strong>自动撤销</strong>“回答”信号。双方不存在互锁关系。</li></ul></li><li><strong>半互锁方式</strong>：<ul><li>主设备发出“请求”信号后，<strong>必须等</strong>接到从设备的“回答”信号后，才撤销“请求”信号，有互锁的关系。</li><li>而从设备在接到“请求”信号后，发出“回答”信号，但不必等待获知主设备的“请求”信号已经撤销，而是隔一段时间后<strong>自动撤销</strong>“回答”信号，不存在互锁关系。</li></ul></li><li><strong>全互锁方式</strong>：最可靠，速度最慢<ul><li>主设备发出“请求”信号后，<strong>必须等</strong>从设备“回答”后，才撤销“请求”信号；</li><li>从设备发出“回答”信号，<strong>必须等</strong>获知主设备“请求”信号已撤销后，再撤销其“回答”信号。双方存在互锁关系。</li></ul></li></ul></li><li>优点：总线周期长度可变，能保证两个工作速度相差很大的部件或设备之间<strong>可靠</strong>地进行信息交换，自动适应时间的配合。</li><li>缺点：比同步控制方式稍复杂一些，速度比同步定时方式慢。</li><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part6/image-20211026144100498.png" alt="image-20211026144100498"></li></ul><h3 id="半同步通信（仅了解）"><a href="#半同步通信（仅了解）" class="headerlink" title="半同步通信（仅了解）"></a>半同步通信（仅了解）</h3><ul><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part6/image-20211026144310741.png" alt="image-20211026144310741"></li><li>半同步通信：统一时钟的基础上，增加一个“等待”响应信号 WAIT</li><li>当从设备跟不上主设备速度时，从设备通过 WAIT 信号线要求主设备等待</li></ul><h3 id="分离式通信（仅了解）"><a href="#分离式通信（仅了解）" class="headerlink" title="分离式通信（仅了解）"></a>分离式通信（仅了解）</h3><ul><li>上述三种通信的共同点<ul><li>主模块发地址 、命令 —— 使用总线</li><li>从模块准备数据 —— 不使用总线，<strong>总线空闲</strong></li><li>从模块向主模块发数据 —— 使用总线</li></ul></li><li>分离式通信的一个总线传输周期<ul><li>子周期 1：主模块申请占用总线，使用完后放弃总线的使用权</li><li>子周期 2：从模块申请占用总线，将各种信息送至总线上</li></ul></li><li>特点：<ul><li>各模块均有权申请占用总线</li><li>采用同步方式通信，不等对方回答</li><li>各模块准备数据时，不占用总线</li><li>总线利用率提高</li></ul></li></ul><h2 id="总线标准"><a href="#总线标准" class="headerlink" title="总线标准"></a>总线标准</h2><h3 id="基本概念-3"><a href="#基本概念-3" class="headerlink" title="基本概念"></a>基本概念</h3><ul><li>总线标准是国际上公布或推荐的互连各个模块的标准，是把各种不同的模块组成计算机系统时必须遵守的规范。</li><li><strong>系统总线</strong>：<strong>通常与 CPU 直接相连</strong>，用于连接 CPU 与北桥芯片、或 CPU 与主存等</li><li><strong>局部总线</strong>：<strong>没有直接与 CPU 连接</strong>，通常是连接高速的<strong>北桥芯片</strong>，用于连接了很多重要的硬件部件（如显卡、声卡等）</li><li><strong>设备总线</strong>、<strong>通信总线</strong>：通常由<strong>南桥芯片</strong>控制，用于连接计算机与计算机，或连接计算机与外部 I/O 设备</li></ul><h3 id="总线标准的发展"><a href="#总线标准的发展" class="headerlink" title="总线标准的发展"></a>总线标准的发展</h3><ul><li>系统总线<ul><li>ISA（Industry Standard Architecture）：<strong>并行总线</strong>，1984 年提出</li><li>EISA（Extended ISA）：<strong>并行总线</strong>，1988 年提出，在 ISA 基础上增加位宽</li><li>FBS、QPI：<strong>串行总线</strong>，Intel 提出的两种系统总线，用于连接 CPU 和北桥芯片；QPI 又称 multi-FSB</li></ul></li><li>局部总线<ul><li>VESA（Video Electronics Standard Architecture）：<strong>并行总线</strong>，1991 年提出，用于传输图像，但渐渐赶不上 CPU 的发展</li><li>PCI（Peripheral Component Interconnect）：<strong>并行总线</strong>，1992 年提出，速度和 VESA 差不多，但工作频率可以独立于 CPU 主频，用于连接显卡、声卡、网卡等，支持即插即用</li><li>AGP（Accelerated Graphics Port）：<strong>并行总线</strong>，1996 年提出，从 PCI2.1 基础上扩展而来，用于连接显存和主存</li><li>PCI-E（PCI-Express（3GIO））：<strong>串行总线</strong>，2001 年提出，工作频率很高，支持全双工通信</li></ul></li><li>设备/通信总线<ul><li>连接各种外设<ul><li>RS-232C（Recommended Standard）：<strong>串行总线</strong>，1970 年提出，用于极慢速的电传打印机</li><li>SCSI（Small Computer System Interface）：<strong>并行总线</strong>，1986 年提出，用于连接硬盘、打印机、扫描仪等</li><li>PCMCIA（Personal Computer Memory Card International Association）：<strong>并行总线</strong>，1991 年提出，用于连接外部存储卡，目的是增强个人电脑的信息互换</li><li>USB（Universal Serial Bus）：<strong>串行总线</strong>，1996 年提出，采用差模信号，每次只能传输 1 bit，工作频率可以很高</li></ul></li><li>连接硬盘<ul><li>IDE（Integrated Drive Electronics）：<strong>并行总线</strong>，19986 年提出，又称 Parallel ATA，主要用于连接硬盘、光驱等</li><li>SATA（Serial Advanced Technology Attachment）：<strong>串行总线</strong>，2001 年提出，Serial ATA，主要用于连接硬盘、光驱等</li></ul></li></ul></li></ul><h3 id="串行总线取代并行总线的原因"><a href="#串行总线取代并行总线的原因" class="headerlink" title="串行总线取代并行总线的原因"></a>串行总线取代并行总线的原因</h3><ul><li>并行总线：<ul><li>用 m 根线每次传送 m 个比特，用高/低电平表示 1/0，通常采用同步定时方式。</li><li>由于线间信号干扰，因此总线工作频率不能太高。</li><li>另外，各条线不能有长度差，长距离并行传输时工艺难度大。</li></ul></li><li>串行总线：<ul><li>用两根线每次传送一个比特，采用“差模信号”表示 1/0，通常采用异步定时方式，总线工作频率可以很高。</li><li>现在的串行总线通常基于包传输，如 80bit 为一个数据包，包与包之间有先后关系，因此可以用多个数据通路分别串行传输多个数据包，某种程度上现在的串行总线也有“并行”的特点</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机组成原理 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>计算机组成原理-Part5</title>
      <link href="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part5/"/>
      <url>/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part5/</url>
      
        <content type="html"><![CDATA[<h1 id="计算机组成原理-Part5——中央处理器"><a href="#计算机组成原理-Part5——中央处理器" class="headerlink" title="计算机组成原理-Part5——中央处理器"></a>计算机组成原理-Part5——中央处理器</h1><p>[TOC]</p><h2 id="CPU-的功能和结构"><a href="#CPU-的功能和结构" class="headerlink" title="CPU 的功能和结构"></a>CPU 的功能和结构</h2><h3 id="CPU-的功能"><a href="#CPU-的功能" class="headerlink" title="CPU 的功能"></a>CPU 的功能</h3><ol><li><strong>指令控制</strong>：完成<strong>取指令</strong>、<strong>分析指令</strong>和<strong>执行指令</strong>的操作，即程序的顺序控制。</li><li><strong>操作控制</strong>：CPU 产生并管理一条指令中的若干操作信号，从而<strong>控制相应的部件</strong>按指令要求进行动作。</li><li><strong>时间控制</strong>：为<strong>每条指令按时间顺序</strong>提供应有的控制信号。</li><li><strong>数据加工</strong>：对数据进行<strong>算术和逻辑运算</strong>。</li><li><strong>中断处理</strong>：管理<strong>总线</strong>及<strong>输入输出</strong>；处理<strong>异常情况</strong>和<strong>特殊请求</strong>。</li></ol><ul><li>运算器：<strong>数据加工</strong></li><li>控制器：<strong>操作控制</strong>、<strong>时间控制</strong>、<strong>指令控制</strong>、<strong>中断处理</strong></li></ul><h3 id="运算器的基本结构"><a href="#运算器的基本结构" class="headerlink" title="运算器的基本结构"></a>运算器的基本结构</h3><ul><li>运算器结构：<ul><li>算术逻辑单元：进行算术/逻辑运算。</li><li>通用寄存器组：如 AX、BX、CX、DX、SP 等。用于存放操作数（包括源操作数、目的操作数及中间结果）和各种地址信息等。</li><li>暂存寄存器：用于暂存<strong>从主存读来的数据</strong>，这个数据不能立即存放在通用寄存器中，否则会破坏其原有内容。</li><li>累加寄存器：是一个通用寄存器，用于暂时存放 ALU 运算的结果信息，用于实现加法运算。</li><li>程序状态字寄存器（PSW）：保留由算术逻辑运算指令或测试指令的结果的各种状态信息，如溢出标志（OP）、符号标志（SF）、零标志（ZF）、进位标志（CF）等。<strong>这些位参与并决定微操作的形成</strong>。</li><li>移位器：对运算结果进行移位运算。</li><li>计数器：控制乘除运算的操作步数。</li></ul></li></ul><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part5/image-20211023104243472.png" alt="image-20211023104243472" style="zoom:80%;"><ul><li><strong>专用数据通路方式</strong>：根据指令执行过程中的数据和地址的流动方向安排连接线路。<ul><li>特点：<strong>性能较高</strong>，基本不存在数据冲突现象，但<strong>结构复杂</strong>，硬件量大，不易实现。</li></ul></li><li>针对问题：<ul><li>如果 ALU 与寄存器组直接用导线连接，相当于多个寄存器同时并且一直向 ALU 传输数据</li></ul></li><li>改进方向：<ul><li>解决方法1：使用<strong>多路选择器</strong>根据控制信号选择一路输出</li><li>解决方法2：使用<strong>三态门</strong>可以控制每一路是否输出</li></ul></li></ul><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part5/image-20211023105644925.png" alt="image-20211023105644925" style="zoom:80%;"><ul><li><strong>CPU 内部单总线方式</strong>：将所有寄存器的输入端和输出端都连接到一条公共的通路上。<ul><li>特点：结构简单，容易实现，但数据传输存在较多冲突的现象，性能较低。</li></ul></li><li>针对问题：<ul><li>ALU 的计算结果会在电流不稳定时直接传回 CPU 内部总线，破坏寄存器信息</li></ul></li><li>改进方向：<ul><li>在 ALU 后加入<strong>暂存寄存器</strong>和<strong>三态门</strong>来等待稳定之后再将结果写入寄存器</li><li>通常会把 ALU 后的寄存器添加移位功能</li></ul></li></ul><h3 id="控制器的基本结构"><a href="#控制器的基本结构" class="headerlink" title="控制器的基本结构"></a>控制器的基本结构</h3><p><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part5/image-20211023121447512.png" alt="image-20211023121447512"></p><ol><li>程序计数器：存放下一条指令在主存中的地址。CPU 会根据 PC 的内容去主存中取指令。通常 PC 有自增功能，有的也会交给 ALU 进行加一。</li><li>指令寄存器：用于保存当前正在执行的指令。</li><li>指令译码器：仅<strong>对操作码字段进行译码</strong>，向控制器提供特定的操作信号。</li><li>微操作信号发生器：根据 <strong>IR 的内容</strong>（指令）、<strong>PSW 的内容</strong>（状态信息）及<strong>时序信号</strong>（时序脉冲），产生控制整个计算机系统所需的各种控制信号，其结构有<strong>组合逻辑型</strong>和<strong>存储逻辑型</strong>两种。</li><li>时序系统：用于产生各种时序信号，它们都是由统一时钟（CLOCK）分频得到。</li><li>存储器地址寄存器：用于存放所要访问的主存单元地址。</li><li>存储器数据寄存器：用于存放向主存写入的信息或从主存中读出的信息。</li></ol><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part5/image-20211023122455417.png" alt="image-20211023122455417"></p><ul><li>用户可见寄存器：通用寄存器组、程序状态字寄存器 PSW、程序计数器 PC</li><li>用户不可见寄存器：MAR、MDR、IR、暂存寄存器</li></ul><h2 id="指令执行过程"><a href="#指令执行过程" class="headerlink" title="指令执行过程"></a>指令执行过程</h2><h3 id="指令周期"><a href="#指令周期" class="headerlink" title="指令周期"></a>指令周期</h3><ul><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part5/image-20211023123259434.png" alt="image-20211023123259434" style="zoom:80%;"><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part5/image-20211023123229871.png" alt="image-20211023123229871" style="zoom:80%;"></li><li><strong>指令周期</strong>：CPU 从主存中每<strong>取出并执行</strong>一条指令所需的全部时间。<ul><li>指令周期常常用若干<strong>机器周期</strong>（<strong>CPU 周期</strong>）来表示。</li><li>一个机器周期又包含若干<strong>时钟周期</strong>（也称为<strong>节拍</strong>、<strong>T 周期</strong>、<strong>主频的倒数</strong>或 <strong>CPU 时钟周期</strong>，它是 CPU 操作的<strong>最基本单位</strong>）。</li></ul></li><li>每个指令周期内机器周期数可以<strong>不等</strong>，每个机器周期内的节拍数也可以<strong>不等</strong>。<ul><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part5/image-20211023124356581.png" alt="image-20211023124356581" style="zoom:80%;"></li></ul></li></ul><h3 id="指令周期数据流"><a href="#指令周期数据流" class="headerlink" title="指令周期数据流"></a>指令周期数据流</h3><ul><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part5/image-20211023130107891.png" alt="image-20211023130107891" style="zoom:80%;"></li><li><p>四个工作周期都有CPU访存操作，只是访存的目的不同。</p><ul><li><strong>取指周期</strong>是为了<strong>取指令</strong></li><li><strong>间址周期</strong>是为了<strong>取有效地址</strong></li><li><strong>执行周期</strong>是为了<strong>取操作数</strong></li><li><strong>中断周期</strong>是为了<strong>保存程序断点</strong></li></ul></li><li><p name="取指周期">取指周期（所有指令都一样）</p><ul><li>(PC) → MAR：当前指令地址送至存储器地址寄存器</li><li>1 → R：CU 发出控制信号，经控制总线传到主存，这里是给<strong>读信号接口</strong>输送一个高电平</li><li>M(MAR) → MDR：将 MAR 所指主存中的内容经数据总线送入 MDR</li><li>(MDR) → IR：将 MDR 中的内容（此时是指令）送入 IR</li><li>OP(IR) → ID：将指令（IR 中的操作码部分）传入指令译码器（Instruction Decoder，ID）</li><li>(PC)+1 → PC：CU 发出控制信号，形成下一条指令地址</li></ul></li><li><p>间址周期（所有指令都一样）</p><ul><li>Ad(IR/MDR) → MAR：将指令的地址码送入 MAR</li><li>1 → R：CU 发出控制信号，启动主存做<strong>读操作</strong></li><li>M(MAR) → MDR：将 MAR 所指主存中的内容经数据总线送入 MDR</li><li>(MDR) → Ad(IR)：将最终的有效地址（IR 中的地址码部分）送至指令的地址码字段</li></ul></li><li><p>执行周期（各不相同）</p><ul><li>执行周期的任务是根据 IR 中的指令字的操作码和操作数通过 ALU 操作产生执行结果。不同指令的执行周期操作不同，因此没有统一的数据流向。</li><li>CLA：clear ACC（ACC清零）<ul><li>0 → AC</li></ul></li><li>LDA X：load ACC（把X所指内容取到ACC）<ul><li>Ad ( IR ) → MAR</li><li>1 → R</li><li>M ( MAR ) → MDR</li><li>MDR → AC</li></ul></li><li>JMP X：（无条件转移)<ul><li>Ad(IR) → PC</li></ul></li><li>BAN X：Branch ACC Negative（当ACC为负时转移）<ul><li>A<del>0</del> • Ad (IR) + (!A<del>0</del>) • (PC) → PC</li></ul></li></ul></li><li><p>中断周期</p><ul><li>中断：暂停当前任务去完成其他任务。为了能够恢复当前任务，需要保存断点。一般使用堆栈来保存断点，假设 SP 指向栈顶元素（低地址部分）。进栈操作是先修改指针，后存入数据。</li><li>中断周期三个任务：<ul><li>保存断点</li><li>形成中断服务程序的入口地址</li><li>关中断</li></ul></li><li>(SP)-1 → SP，(SP) → MAR：CU 控制 SP 减1，修改后的地址送入 MAR</li><li>1 → W：CU 发出控制信号，启动主存做<strong>写操作</strong></li><li>(PC) → MDR：将断点（PC 内容）送入 MDR</li><li>向量地址 → PC：CU 控制将中断服务程序的入口地址（由向量地址形成部件产生）送入 PC</li></ul></li></ul><h3 id="指令执行方案"><a href="#指令执行方案" class="headerlink" title="指令执行方案"></a>指令执行方案</h3><ul><li>一个指令周期通常要包括几个时间段（执行步骤），每个步骤完成指令的一部分功能，几个依次执行的步骤完成这条指令的全部功能。</li><li>单指令周期<ul><li>所有指令都选用相同的执行时间来完成，指令之间串行执行。</li><li>指令周期取决于执行时间最长的指令的执行时间。对于可以在更短时间内完成的指令，要使用等待至最长的周期，会降低系统的运行速度。</li></ul></li><li>多指令周期<ul><li>对不同类型的指令选用不同的执行步骤来完成 ，指令之间串行执行。</li><li>可选用不同个数的时钟周期来完成不同指令的执行过程 。需要更复杂的硬件设计。</li></ul></li><li>流水线方案<ul><li>在每一个时钟周期启动一条指令，让多条指令处在<strong>不同的执行步骤</strong>中<strong>同时运行</strong>，指令之间并行执行。</li></ul></li></ul><h2 id="数据通路（大题高频）"><a href="#数据通路（大题高频）" class="headerlink" title="数据通路（大题高频）"></a>数据通路（大题高频）</h2><ul><li>数据通路：数据在功能部件之间传送的路径。<ul><li>寄存器-寄存器</li><li>寄存器-主存</li><li>寄存器-ALU</li></ul></li><li>数据通路的基本结构：<ul><li>CPU 内部单总线方式（ALU 必须配合暂存寄存器使用）</li><li>CPU 内部多总线方式（相比单总线成本更高，但是数据传输更有效率）</li><li>专用数据通路方式</li></ul></li></ul><h3 id="单总线结构"><a href="#单总线结构" class="headerlink" title="单总线结构"></a>单总线结构</h3><ul><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part5/image-20211023141239720.png" alt="image-20211023141239720" style="zoom:80%;"></li><li>寄存器之间数据传送<ul><li>(PC)→Bus：PCout 有效（PC 内容送总线）</li><li>Bus→MAR：MARin 有效（总线内容送 MAR）</li></ul></li><li>主存与CPU之间的数据传送<ul><li>(PC)→Bus→MAR：PCout 和 MARin 有效（现行指令地址→MAR）</li><li>1→R：CU 发读命令</li><li>MEM(MAR)→MDR：MDRinE 有效</li><li>MDR→Bus→IR：MDRout 和 IRin 有效（现行指令→IR）</li></ul></li><li>执行算术或逻辑运算<ul><li>Ad(IR/MDR)→Bus→MAR：MDRout 和 MARin 有效</li><li>1→R：CU 发读命令</li><li>MEM(MAR)→数据线→MDR：MDRin 有效</li><li>MDR→Bus→Y：MDRout 和 Yin 有效（操作数→Y）</li><li>(ACC)+(Y)→Z：ACCout 和 ALUin 有效（CU 向 ALU 发送加命令）</li><li>Z→ACC：Zout 和 ACCin 有效（结果→ACC）</li></ul></li></ul><h3 id="专用通路结构"><a href="#专用通路结构" class="headerlink" title="专用通路结构"></a>专用通路结构</h3><ul><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part5/image-20211023145547590.png" alt="image-20211023145547590" style="zoom:80%;"></li><li>取指周期<ul><li>(PC)→MAR：C0有效</li><li>(MAR)→主存：C1有效</li><li>1→R：控制单元向主存发送读命令</li><li>M(MAR)→MDR：C2有效</li><li>(MDR)→IR：C3有效</li><li>(PC)+1→PC</li><li>Op(IR)→CU：C4有效</li></ul></li></ul><blockquote><p>数据通路是计组大题高频考点！一定要做题巩固！</p></blockquote><h2 id="控制器的功能和工作原理"><a href="#控制器的功能和工作原理" class="headerlink" title="控制器的功能和工作原理"></a>控制器的功能和工作原理</h2><h3 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h3><ul><li>硬布线控制器：使用<strong>纯硬件</strong>的方式来实现控制器的功能</li><li>微程序控制器：使用<strong>软硬件结合</strong>的方式来实现控制器的功能</li><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part5/image-20211023185221891.png" alt="image-20211023185221891"></li><li>CPU 会在每个时钟周期内发出一个<strong>微命令</strong>，即完成一个对应<strong>微操作</strong>的控制信号。<ul><li>如，微命令1 使得 PCout、MARin 有效，从而完成对应的微操作1 (PC)-&gt;MAR。</li><li>微命令与微操作是相互对应的</li><li>特点：<ol><li>多个<strong>相容</strong>的微操作是可以<strong>在一个节拍内并行</strong>的。比如使用专用通路结构就可以提高微命令的并行数量</li><li>同一个微操作可能在不同的指令阶段中重复使用</li><li>在定长机器周期中，通常以<strong>访存所需节拍数</strong>作为参考</li><li>若实际所需节拍数较少，可将微操作安排在机器周期末尾进行</li></ol></li></ul></li><li>根据<strong>指令操作码</strong>、<strong>当前的机器周期</strong>、<strong>节拍信号</strong>、<strong>机器状态条件</strong>，即可确定现在这个节拍下应该发出哪些“微命令”</li><li>CPU 所处的周期由四个不同的触发器确定。</li></ul><h3 id="硬布线控制器"><a href="#硬布线控制器" class="headerlink" title="硬布线控制器"></a>硬布线控制器</h3><ul><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part5/image-20211023190651176.png" alt="image-20211023190651176"></li><li>设计步骤<ol><li><a href="#取指周期">分析每个阶段的微操作序列</a>（哪些指令在<strong>什么阶段</strong>、<strong>什么条件</strong>下会使用到<strong>什么微操作</strong>）</li><li>选择 CPU 的控制方式（定长/不定长周期，每个周期的节拍数）</li><li>安排微操作时序</li><li>电路设计（逻辑表达式与电路设计）<ul><li>列出操作时间表</li><li>写出微操作的最简表达式</li><li>画出逻辑图</li></ul></li></ol></li><li>安排微操作时序的原则<ol><li>微操作的<strong>先后顺序</strong>不得随意更改</li><li><strong>被控对象不同</strong>的微操作尽量安排在<strong>一个节拍</strong>内完成</li><li>占用<strong>时间较短</strong>的微操作尽量安排在<strong>一个节拍</strong>内完成，允许有先后顺序</li></ol></li><li>取指周期：<ul><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part5/image-20211023194220430.png" alt="image-20211023194220430" style="zoom:80%;"></li><li>M ( MAR ) -&gt; MDR：从主存取数据，用时较长，因此必须一个时钟周期才能保证微操作的完成</li><li>MDR -&gt; IR：是 CPU 内部寄存器之间的数据传送，速度很快，因此在一个时钟周期内可以紧接着完成第二个微命令 OP ( IR ) -&gt; ID。</li></ul></li><li>间址周期：<ul><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part5/image-20211023194429655.png" alt="image-20211023194429655" style="zoom:80%;"></li></ul></li><li>执行周期：<ul><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part5/image-20211023194744913.png" alt="image-20211023194744913" style="zoom:80%;"></li></ul></li><li>缺点：<ul><li>指令越多，设计、实现就越复杂，因此<strong>一般用于 RISC</strong>（精简指令集系统） </li><li>如果扩充一条新的指令，则控制器的设计就需要大改，因此<strong>扩充指令较困难</strong>。</li></ul></li><li>优点：<ul><li>由于使用纯硬件实现控制，因此执行<strong>速度很快</strong>。</li><li><strong>微操作控制信号</strong>由组合逻辑电路根据当前的指令码、状态和时序，<strong>即时产生</strong>。</li></ul></li></ul><h3 id="微程序控制器（考点）"><a href="#微程序控制器（考点）" class="headerlink" title="微程序控制器（考点）"></a>微程序控制器（考点）</h3><h4 id="基本原理-1"><a href="#基本原理-1" class="headerlink" title="基本原理"></a>基本原理</h4><h5 id="微程序的概念"><a href="#微程序的概念" class="headerlink" title="微程序的概念"></a>微程序的概念</h5><ul><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part5/image-20211024094522115.png" alt="image-20211024094522115"></li><li>基本思想：采用“存储程序”的思想，CPU 出厂前将所有指令的“微程序”存入“控制器存储器”中</li><li>层次结构：<ul><li>程序：由<strong>指令序列</strong>组成</li><li><strong>微程序</strong>：<ul><li>由<strong>微指令序列</strong>组成，<strong>每一种指令对应一个微程序</strong></li><li><strong>取指、间指、执行、中断周期微程序段</strong>，共同<strong>组成一个微程序</strong></li></ul></li><li><strong>指令</strong>：是对程序执行步骤的描述<ul><li>指令/微程序是对微指令功能的“封装”</li><li>是一个微指令序列</li></ul></li><li><strong>微指令</strong>：是对指令执行步骤的描述<ul><li>微指令中可能包含多个<strong>微命令</strong></li><li><strong>每一个微命令对应一个微操作</strong>，<strong>每一个微命令对应一条输出控制线</strong></li></ul></li></ul></li></ul><h5 id="微程序控制器基本结构"><a href="#微程序控制器基本结构" class="headerlink" title="微程序控制器基本结构"></a>微程序控制器基本结构</h5><ul><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part5/image-20211024180509785.png" alt="image-20211024180509785"></li><li><strong>微地址形成部件</strong>：产生初始微地址和后继微地址，以保证微指令的连续执行。</li><li><strong>CMAR</strong>：又称 <strong>μPC</strong>，微地址寄存器，接收微地址形成部件送来的微地址，为在 CM 中读取微指令作准备。</li><li><strong>地址译码</strong>：将地址码转化为存储单元控制信号。</li><li><strong>控制存储器 CM</strong>：简称<strong>控存</strong>，用于存放各指令对应的微程序，控制存储器是由<strong>只读存储器 ROM</strong> 构成。</li><li><strong>CMDR</strong>：别名：<strong>μIR</strong>，用于存放从 CM 中取出的微指令，它的位数同微指令字长相等。</li><li><strong>顺序逻辑</strong>：<ul><li>根据<strong>指令地址码的寻址特征位</strong>判断是否要跳过间址周期</li><li>根据<strong>中断信号</strong>判断是否进入中断周期</li></ul></li><li>所有指令的<strong>取指周期</strong>、<strong>间址周期</strong>、<strong>中断周期</strong>所对应的微指令序列都一样，<strong>可以共享使用</strong>。</li><li>取指周期微程序：（常考）<ul><li>通常是公用的，故如果某指令系统中有 n 条机器指令，则 CM 中微程序（段）的个数至少是 <strong>n+1</strong> 个</li><li>一些早期的 CPU、物联网设备的 CPU <strong>可以不提供间接寻址和中断功能</strong>，因此这类 CPU 可以不包含间址周期、中断周期的微程序段</li></ul></li><li>有的选择题中，虽然取指周期、执行周期<strong>在物理上</strong>是两个微程序，但<strong>逻辑上</strong>应该把它们看作一个整体。即，<strong>一条指令对应一个微程序</strong>。</li></ul><h4 id="微指令的设计"><a href="#微指令的设计" class="headerlink" title="微指令的设计"></a>微指令的设计</h4><h5 id="微指令的格式"><a href="#微指令的格式" class="headerlink" title="微指令的格式"></a>微指令的格式</h5><ul><li>水平型微指令：一条微指令能定义多个可并行的微命令。<ul><li>优点：微程序短，执行速度快；</li><li>缺点：微指令长，编写微程序较麻烦。</li><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part5/image-20211024182849406.png" alt="image-20211024182849406"></li></ul></li><li>垂直型微指令：一条微指令只能定义<strong>一个</strong>微命令<strong>，</strong>由微操作码字段规定具体功能<ul><li>优点：微指令短、简单、规整，便于编写微程序；</li><li>缺点：微程序长，执行速度慢，工作效率低。 </li><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part5/image-20211024182907683.png" alt="image-20211024182907683"></li></ul></li><li>混合型微指令：<ul><li>在垂直型的基础上增加一些不太复杂的并行操作。</li><li>微指令较短，仍便于编写；微程序也不长，执行速度加快。</li></ul></li></ul><blockquote><ul><li><strong>相容性</strong>微命令：可以并行完成的微命令。</li><li><strong>互斥性</strong>微命令：不允许并行完成的微命令。</li></ul></blockquote><h5 id="微指令的编码方式（高频）"><a href="#微指令的编码方式（高频）" class="headerlink" title="微指令的编码方式（高频）"></a>微指令的编码方式（高频）</h5><p><strong>微指令的编码方式</strong>，又称<strong>微指令的控制方式</strong>，指如何对微指令的控制字段进行编码，以形成控制信号。目标是在保证速度的情况下，尽量缩短微指令字长。</p><ol><li>直接编码（直接控制）方式<ul><li>在微指令的操作控制字段中，<strong>每一位代表一个微操作命令</strong>，某位为 1 表示该控制信号有效</li><li>优点：简单、直观，执行速度快，操作并行性好。</li><li>缺点：微指令字长过长，n 个微命令就要求微指令的操作字段有 n 位，造成控存容量极大。</li><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part5/image-20211024205924843.png" alt="image-20211024205924843"></li></ul></li><li>字段直接编码方式<ul><li>将微指令的控制字段分成若干“段”，<strong>每段经译码后发出控制信号</strong>微命令字段分段的原则：<ul><li><strong>互斥性</strong>微命令分在<strong>同一段内</strong>，<strong>相容性</strong>微命令分在<strong>不同段内</strong>。不同段/不同互斥类/相容的微命令可以并行</li><li><strong>每个小段</strong>中包含的<strong>信息位不能太多</strong>，否则将增加译码线路的复杂性和译码时间。</li><li>一般<strong>每个小段还要留出一个状态</strong>，表示本字段不发出任何微命令。因此，当某字段的长度为 3 位时，最多只能表示 7 个互斥的微命令，<strong>通常用 000 表示不操作</strong>。</li></ul></li><li>优点：可以缩短微指令字长。</li><li>缺点：要通过译码电路后再发出微命令，因此比直接编码方式慢 。</li><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part5/image-20211024210134498.png" alt="image-20211024210134498"></li></ul></li><li>字段间接编码方式<ul><li>一个字段的某些微命令需由另一个字段中的某些微命令来解释，由于不是靠字段直接译码发出的微命令，故称为字段间接编码，又称隐式编码。</li><li>优点：可进一步缩短微指令字长。</li><li>缺点：削弱了微指令的并行控制能力。通常作为字段直接编码方式的一种辅助手段。</li><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part5/image-20211024210333131.png" alt="image-20211024210333131"></li></ul></li></ol><h5 id="微指令的地址形成方式"><a href="#微指令的地址形成方式" class="headerlink" title="微指令的地址形成方式"></a>微指令的地址形成方式</h5><ol><li><strong>断定方式</strong>（常考）：微指令的下地址字段直接指出后继微指令的地址。</li><li>根据机器指令的<strong>操作码</strong>形成：当机器指令取至指令寄存器后，微指令的地址由操作码经微地址形成部件形成。（不常考）</li><li>增量<strong>计数器法</strong>（常考）：(CMAR) + 1 -&gt; CMAR/μPC</li><li>分支转移：操作控制字段+转移方式+转移地址。转移方式，指明判别条件；转移地址，指明转移成功后的去向。（不常考）</li><li>通过测试网络（不常考）</li><li>由<strong>硬件</strong>产生微程序入口地址：<ul><li>第一条微指令地址：由<strong>硬件</strong>产生（用专门的硬件记录取指周期微程序首地址）</li><li>中断周期：由<strong>硬件</strong>产生中断周期微程序首地址（用专门的硬件记录）</li></ul></li></ol><h4 id="微程序控制单元的设计"><a href="#微程序控制单元的设计" class="headerlink" title="微程序控制单元的设计"></a>微程序控制单元的设计</h4><ul><li><p><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part5/image-20211024232747714.png" alt="image-20211024232747714"></p></li><li><p>设计步骤：</p><ol><li><p>分析每个阶段的微操作序列</p></li><li><p>写出对应机器指令的微操作命令及节拍安排</p><ul><li><p> 写出每个周期所需要的微操作（参照硬布线）</p></li><li><p>补充微程序控制器特有的微操作：</p><p>a. 取指周期：</p><ul><li>Ad ( CMDR ) -&gt; CMAR（每条微指令结束都要进行）</li><li>OP ( IR ) -&gt; 微地址形成部件 -&gt; CMAR（取指周期结束，根据指令操作码确定其执行周期的微程序首地址）</li></ul><p>b. 执行周期：</p><ul><li>Ad(CMDR) -&gt; CMAR（每条微指令结束都要进行，最后一条微指令的下地址是 0）</li></ul></li></ul></li><li><p>确定微指令格式</p><ul><li>根据<strong>微操作个数</strong>决定采用何种<strong>编码方式</strong>，以确定微指令的<strong>操作控制字段的位数</strong>。</li><li>根据 CM 中存储的<strong>微指令总数</strong>，确定微指令的<strong>顺序控制字段的位数</strong>。</li><li>最后按操作控制字段位数和顺序控制字段位数就可确定<strong>微指令字长</strong>。</li></ul></li><li><p>编写微指令码点</p><ul><li>根据操作控制字段每一位代表的微操作命令，编写每一条微指令的码点。</li></ul></li></ol></li><li><p>读出微指令：</p><ul><li>取指周期的<strong>第一条微指令地址由硬件自动给出</strong></li><li>用微指令 a 的下地址表示 b 的地址。上一条微指令的下地址部分转到下一条微指令的译码，同样需要消耗一个节拍</li></ul></li></ul><h4 id="微程序设计分类"><a href="#微程序设计分类" class="headerlink" title="微程序设计分类"></a>微程序设计分类</h4><ol><li>静态微程序设计和动态微程序设计<ul><li>静态：微程序无需改变，采用 ROM</li><li>动态：通过改变<strong>微指令</strong>和<strong>微程序</strong>改变机器指令。有利于仿真，采用 EPROM</li></ul></li><li>毫微程序设计<ul><li>微程序设计：用微程序解释机器指令</li><li>毫微程序设计：用毫微程序解释微程序</li><li><strong>毫微指令与微指令</strong>的关系好比<strong>微指令与机器指令</strong>的关系</li></ul></li></ol><h3 id="硬布线与微程序的比较"><a href="#硬布线与微程序的比较" class="headerlink" title="硬布线与微程序的比较"></a>硬布线与微程序的比较</h3><table><thead><tr><th>对比项目</th><th>微程序控制器</th><th>硬布线控制器</th></tr></thead><tbody><tr><td>工作原理</td><td>读出微程序</td><td>电路即时产生</td></tr><tr><td>执行速度</td><td>慢</td><td>快</td></tr><tr><td>规整性</td><td>较规整</td><td>繁琐，不规整</td></tr><tr><td>应用场合</td><td>CISC CPU</td><td>RISC CPU</td></tr><tr><td>易扩充性</td><td>易扩充修改</td><td>困难</td></tr></tbody></table><h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part5/image-20211024235150778.png" alt="image-20211024235150778"></p><h2 id="指令流水线（大题考察）"><a href="#指令流水线（大题考察）" class="headerlink" title="指令流水线（大题考察）"></a>指令流水线（大题考察）</h2><h3 id="指令流水线的基本概念"><a href="#指令流水线的基本概念" class="headerlink" title="指令流水线的基本概念"></a>指令流水线的基本概念</h3><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><ul><li>指令流水：一条指令的执行过程可以分成多个阶段（或过程）。根据计算机的不同，具体的分法、数量也不同。<ul><li>取指（Instruction Fetch，IF）、分析（Instruction Decode，ID）、执行（Execute）、Memory、Writeback</li><li>分成 5 个阶段的 RISC 是比较常见的考法。</li></ul></li></ul><h4 id="执行方式"><a href="#执行方式" class="headerlink" title="执行方式"></a>执行方式</h4><ul><li>顺序执行方式：<ul><li>总耗时T = n×3t = 3nt</li><li>传统冯·诺依曼机采用顺序执行方式，又称串行执行方式。</li><li>优点：控制简单，硬件代价小。</li><li>缺点：执行指令的速度较慢，在任何时刻，处理机中只有一条指令在执行，各功能部件的利用率很低。</li></ul></li><li>一次重叠执行方式：<ul><li>总耗时T = 3t + (n-1)×2t = (1+2n)t</li><li>优点：程序的执行时间缩短了1/3，各功能部件的利用率明显提高。</li><li>缺点：需要付出硬件上较大开销的代价，控制过程也比顺序执行复杂了。</li></ul></li><li>二次重叠执行方式：<ul><li>总耗时T = 3t + (n-1)×t = (2+n)t</li><li>与顺序执行方式相比，指令的执行时间缩短近2/3。这是一种理想的指令执行方式，在正常情况下，处理机中同时有3条指令在执行。</li></ul></li></ul><h4 id="表示方法（重要）"><a href="#表示方法（重要）" class="headerlink" title="表示方法（重要）"></a>表示方法（重要）</h4><ul><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part5/image-20211025092552132.png" alt="image-20211025092552132"></li><li>指令执行过程图：主要用于分析指令执行过程以及影响流水线的因素</li><li>时空图：主要用于分析流水线的性能</li></ul><h4 id="性能指标（重要）"><a href="#性能指标（重要）" class="headerlink" title="性能指标（重要）"></a>性能指标（重要）</h4><p><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part5/image-20211025093530754.png" alt="image-20211025093530754"></p><p>一条指令的执行分为 k 个阶段，每个阶段耗时 Δt ，一般取 Δt=一个时钟周期（应该是机器周期，在理想情况下可以当做时钟周期）</p><ul><li>吞吐率：在单位时间内流水线所完成的任务数量。<ul><li>吞吐率计算公式：$TP = \frac{n}{T_{k}}$</li><li>实际吞吐率为：$TP = \frac{n}{(k+n-1)Δt}$</li><li>当连续输入的任务 n→∞ 时，最大吞吐率为 TPmax=1/Δt。</li></ul></li><li>加速比：完成同样一批任务，<strong>不使用流水线所用的时间</strong>与<strong>使用流水线所用的时间</strong>之比。<ul><li>加速比公式：$S = \frac{T_{0}}{T_{k}}$</li><li>实际加速比：$S = \frac{knΔt}{(k+n-1)Δt} = \frac{kn}{(k+n-1)}$</li><li>当连续输入的任务 n→∞ 时，最大加速比为 Smax=k。</li></ul></li><li>效率：流水线的设备利用率称为流水线的效率。<ul><li>在时空图上，流水线的效率定义为完成<strong>n个任务占用的时空区有效面积</strong>与<strong>n个任务所用的时间与k个流水段所围成的时空区总面积</strong>之比。</li><li>效率公式：$E = \frac{n个任务占用k时空区有效面积}{n个任务所用的时间与k个流水段所围成的时空区总面积}=\frac{T_{0}}{kT_{k}}$</li><li>当连续输入的任务 n→∞ 时，最高效率为 Emax=1。</li><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part5/image-20211025095147120.png" alt="image-20211025095147120"></li></ul></li></ul><h3 id="指令流水线的影响因素和分类"><a href="#指令流水线的影响因素和分类" class="headerlink" title="指令流水线的影响因素和分类"></a>指令流水线的影响因素和分类</h3><h4 id="影响流水线的因素（重要）"><a href="#影响流水线的因素（重要）" class="headerlink" title="影响流水线的因素（重要）"></a>影响流水线的因素（重要）</h4><ul><li>结构相关（资源冲突）<ul><li>由于多条指令在同一时刻争用同一资源而形成的冲突称为结构相关。</li><li>解决办法：<ul><li>后一相关指令暂停一周期</li><li>资源重复配置：数据存储器+指令存储器</li></ul></li><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part5/image-20211025102708962.png" alt="image-20211025102708962"></li></ul></li><li>数据相关（数据冲突）<ul><li>数据相关指在一个程序中，存在必须等前一条指令执行完才能执行后一条指令的情况，则这两条指令即为数据相关。</li><li>解决办法：<ul><li>把遇到数据相关的指令及其后续指令都暂停一至几个时钟周期，直到数据相关问题消失后再继续执行。可分为<strong>硬件阻塞（stall）</strong>和<strong>软件插 入（NOP）</strong>两种方法。</li><li>数据旁路技术（转发机制）：通过增加电路（数据旁路），将上一步的 ALU 结果直接送入下一步的 ALU</li><li>编译优化：通过编译器调整指令顺序来解决数据相关。</li></ul></li><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part5/image-20211025102758077.png" alt="image-20211025102758077"></li></ul></li><li>控制相关（控制冲突）<ul><li>当流水线遇到改变 PC 值的指令（如转移指令、CALL、中断）而造成断流时，会引起控制相关。</li><li>解决办法：（由转移指令发生）<ul><li>转移指令预测。简单预测（永远猜true或false）动态预测（根据历史情况动态调整）</li><li>预取转移成功和不成功两个控制流方向上的目标指令（需要增加至能够支持两个方向的寄存器数量）</li><li>加快和提前形成条件码（类似于全加器并行）</li><li>提高转移方向的猜准率</li></ul></li><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part5/image-20211025103223036.png" alt="image-20211025103223036"></li></ul></li></ul><p><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part5/image-20211025103334530.png" alt="image-20211025103334530"></p><h4 id="流水线的分类"><a href="#流水线的分类" class="headerlink" title="流水线的分类"></a>流水线的分类</h4><ul><li>部件功能级、处理机级和处理机间级流水线（流水线使用的级别）<ul><li><strong>部件功能级流水</strong>就是将复杂的算术逻辑运算组成流水线工作方式。例如，可将浮点加法操作分成求阶差、对阶、尾数相加以及结果规格化等4个子过程。</li><li><strong>处理机级流水</strong>是把一条指令解释过程分成多个子过程，如前面提到的取指、译码、执行、访存及写回 5 个子过程。</li><li><strong>处理机间流水</strong>是一种宏流水，其中每一个处理机完成某一专门任务，各个处理机所得到的结果需存放在与下一个处理机所共享的存储器中。</li></ul></li><li>单功能流水线和多功能流水线（流水线可以完成的功能）<ul><li><strong>单功能流水线</strong>指只能实现一种固定的专门功能的流水线</li><li><strong>多功能流水线</strong>指通过各段间的不同连接方式可以同时或不同时地实现多种功能的流水线</li></ul></li><li>动态流水线和静态流水线（同一时间内各段之间的连接方式）<ul><li><strong>静态流水线</strong>指在同一时间内，流水线的各段只能按同一种功能的连接方式工作。</li><li><strong>动态流水线</strong>指在同一时间内，当某些段正在实现某种运算时，另一些段却正在进行另一种运算。这样对提高流水线的效率很有好处，但会使流水线控制变得很复杂。</li></ul></li><li>线性流水线和非线性流水线（各个功能段之间是否有反馈信号）<ul><li><strong>线性流水线</strong>中，从输入到输出，每个功能段只允许经过一次，不存在反馈回路。</li><li><strong>非线性流水线</strong>存在反馈回路，从输入到输出过程中，某些功能段将数次通过流水线，这种流水线适合进行线性递归的运算。</li></ul></li></ul><h4 id="流水线的多发技术"><a href="#流水线的多发技术" class="headerlink" title="流水线的多发技术"></a>流水线的多发技术</h4><ul><li><strong>超标量技术</strong>（空分复用）<ul><li>每个时钟周期内可<strong>并发多条独立指令</strong></li><li>要配置<strong>多个功能部件</strong>（多个 ALU、寄存器组）</li><li><strong>不能调整</strong>指令的<strong>执行顺序</strong>（乱序发射 CPU 可以调整顺序）</li><li>通过编译优化技术，把可并行执行的指令搭配起来</li><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part5/image-20211025105329051.png" alt="image-20211025105329051"></li></ul></li><li><strong>超流水技术</strong>（时分复用）<ul><li>在<strong>一个时钟周期内再分段</strong>（3段）</li><li>在一个时钟周期（机器周期，理想情况下min机器周期-&gt;时钟周期）内<strong>一个功能部件使用多次</strong>（ 3 次）</li><li><strong>不能调整</strong>指令的<strong>执行顺序</strong></li><li>靠编译程序解决优化问题</li><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part5/image-20211025105518773.png" alt="image-20211025105518773"></li></ul></li><li><strong>超长指令字</strong><ul><li>由<strong>编译程序</strong>挖掘出指令间<strong>潜在的并行性</strong></li><li>将<strong>多条能并行操作的指令组合</strong>成 一条</li><li>具有<strong>多个操作码字段</strong>的超长指令字（可达几百位）</li><li>采用<strong>多个处理部件</strong></li></ul></li></ul><h3 id="五段式指令流水线"><a href="#五段式指令流水线" class="headerlink" title="五段式指令流水线"></a>五段式指令流水线</h3><h4 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h4><ul><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part5/image-20211025100227733.png" alt="image-20211025100227733"></li><li>为方便流水线的设计，将每个阶段的耗时取成一样，以最长耗时为准。即此处应将机器周期设置为 100ns。</li><li>流水线<strong>每一个功能段</strong>部件后面都要有一个<strong>缓冲寄存器</strong>，或称为<strong>锁存器</strong>，其作用是<strong>保存本流水段的执行结果</strong>，提供给下一流水段使用。</li><li><strong>① IF 取指 -&gt; ② ID 译码&amp;取数 -&gt; ③ EX 执行 -&gt; ④ M 访存 -&gt; ⑤ WB 写回寄存器</strong></li><li>考试中常见的五类指令：<ul><li><strong>运算类指令</strong>、<strong>LOAD 指令</strong>、<strong>STORE 指令</strong>、<strong>条件转移指令</strong>、<strong>无条件转移指令</strong></li></ul></li></ul><h4 id="运算类指令的执行过程"><a href="#运算类指令的执行过程" class="headerlink" title="运算类指令的执行过程"></a>运算类指令的执行过程</h4><ul><li>IF：根据 PC 从指令 Cache 取指令至 IF 段的锁存器</li><li>ID：取出操作数至 ID 段锁存器</li><li>EX：运算，将结果存入 EX 段锁存器</li><li>M：空段（RISC 指令集不会在运算指令中访问主存，但是这段时间周期是需要消耗的）</li><li>WB：将运算结果写回指定寄存器</li></ul><table><thead><tr><th>运算类指令举例</th><th>指令的汇编格式</th><th>功能</th></tr></thead><tbody><tr><td>加法指令（两个寄存器相加）</td><td>ADD Rs, Rd</td><td>(Rs)+(Rd) -&gt; Rd</td></tr><tr><td>加法指令（寄存器与立即数相加）</td><td>ADD #996, Rd</td><td>996+(Rd) -&gt; Rd</td></tr><tr><td>算数左移指令</td><td>SHL Rd</td><td>(Rd)&lt;&lt;&lt;2 -&gt; Rd</td></tr></tbody></table><blockquote><ul><li>Rs 指源操作数（source）</li><li>Rd 指目的操作数（destination）</li></ul></blockquote><h4 id="LOAD-指令的执行过程"><a href="#LOAD-指令的执行过程" class="headerlink" title="LOAD 指令的执行过程"></a>LOAD 指令的执行过程</h4><ul><li>IF：根据 PC 从指令 Cache 取指令至 IF 段的锁存器</li><li>ID：将基址寄存器的值放到锁存器 A，将偏移量的值放到 Imm</li><li>EX：运算，得到有效地址</li><li>M：从数据 Cache 中取数并放入锁存器</li><li>WB：将取出的数写回寄存器</li><li>LOAD 也需要经过运算，才能得到有效地址</li></ul><table><thead><tr><th>指令的汇编格式</th><th>功能</th></tr></thead><tbody><tr><td>LOAD Rd, 996(Rs) 或 LOAD Rd, mem</td><td>(996+(Rs)) -&gt; Rd 或 (mem) -&gt; Rd</td></tr></tbody></table><blockquote><p>通常，RISC 处理器<strong>只有“取数 LOAD”和“存数 STORE”指令才能访问主存</strong></p></blockquote><h4 id="STORE-指令的执行过程"><a href="#STORE-指令的执行过程" class="headerlink" title="STORE 指令的执行过程"></a>STORE 指令的执行过程</h4><ul><li>IF：根据 PC 从指令 Cache 取指令至 IF 段的锁存器</li><li>ID：将基址寄存器的值放到锁存器 A，将偏移量的值放到 Imm。<strong>将要存的数放到 B</strong></li><li>EX：运算，得到有效地址。并将锁存器 B 的内容放到锁存器 Store。</li><li>M：写入数据 Cache</li><li>WB：空段</li></ul><table><thead><tr><th>指令的汇编格式</th><th>功能</th></tr></thead><tbody><tr><td>STORE Rs, 996(Rd) 或 STORE Rs, mem</td><td>Rs -&gt; (996+(Rd)) 或 Rs -&gt; (mem)</td></tr></tbody></table><h4 id="条件转移指令的执行过程"><a href="#条件转移指令的执行过程" class="headerlink" title="条件转移指令的执行过程"></a>条件转移指令的执行过程</h4><ul><li><p>IF：根据 PC 从指令 Cache 取指令至 IF 段的锁存器</p></li><li><p>ID：进行比较的两个数放入锁存器 A、B；偏移量放入 Imm</p></li><li><p>EX：运算，比较两个数</p></li><li><p>M：将目标 PC 值写回 PC（<strong>修改 PC 值不在写回阶段而是访存阶段</strong>）</p></li><li><p>WB：空段（<strong>写回阶段通常是修改通用寄存器</strong>）</p></li><li><p>转移类指令常采用<strong>相对寻址</strong></p></li><li><p>很多教材把写回 PC 的功能段称为“WrPC 段”，其耗时比 M 段更短，可安排在 M 段时间内完成。</p></li><li><p>通常在 IF 段结束止之后 PC 就会自动 +“1”</p></li></ul><table><thead><tr><th>指令的汇编格式</th><th>功能</th></tr></thead><tbody><tr><td>beq Rs, Rt, #偏移量</td><td>若(Rs)==(Rt)，则**(PC)+指令字长+(偏移量×指令字长) -&gt; PC<strong>；否则</strong>(PC)+指令字长 -&gt; PC**</td></tr><tr><td>bne Rs, Rt, #偏移量</td><td>若(Rs)!=(Rt)，则**(PC)+指令字长+(偏移量×指令字长) -&gt; PC<strong>；否则</strong>(PC)+指令字长 -&gt; PC**</td></tr></tbody></table><h4 id="无条件转移指令的执行过程"><a href="#无条件转移指令的执行过程" class="headerlink" title="无条件转移指令的执行过程"></a>无条件转移指令的执行过程</h4><ul><li>IF：根据 PC 从指令 Cache 取指令至IF段的锁存器</li><li>ID：偏移量放入 Imm</li><li>EX：将目标 PC 值写回 PC（<strong>这里修改 PC 值不在写回阶段而又是在执行阶段</strong>）</li><li>M：空段</li><li>WB：空段</li><li>“WrPC段”耗时比 EX 段更短，可安排在 EX 段时间内完成。<strong>尽早完成 WrPC 段、修改 PC 值，就越能避免控制冲突</strong>。当然，也有的地方会在 WB 段时间内才修改 PC 的值</li><li>偏移量通常采用补码表示</li></ul><table><thead><tr><th>指令的汇编格式</th><th>功能</th></tr></thead><tbody><tr><td>jmp #偏移量</td><td>(PC)+指令字长+(偏移量×指令字长) -&gt; PC</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 计算机组成原理 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>计算机组成原理-Part4</title>
      <link href="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part4/"/>
      <url>/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part4/</url>
      
        <content type="html"><![CDATA[<h1 id="计算机组成原理-Part4——指令系统"><a href="#计算机组成原理-Part4——指令系统" class="headerlink" title="计算机组成原理-Part4——指令系统"></a>计算机组成原理-Part4——指令系统</h1><p>[TOC]</p><h2 id="指令格式"><a href="#指令格式" class="headerlink" title="指令格式"></a>指令格式</h2><h3 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h3><ul><li>指令（机器指令）：一台计算机的所有指令的集合构成该机的<strong>指令系统</strong>，也称为<strong>指令集</strong>。</li><li>一台计算机只能执行自己指令系统中的指令，不能执行其他系统的指令。Eg：x86 架构、ARM架构</li><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part4/image-20211021233141411.png" alt="image-20211021233141411"></li></ul><h3 id="根据地址码数目不同分类"><a href="#根据地址码数目不同分类" class="headerlink" title="根据地址码数目不同分类"></a>根据地址码数目不同分类</h3><ul><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part4/image-20211021235538544.png" alt="image-20211021235538544"></li><li>一条指令可能包含不同数量的地址码</li><li>零地址指令<ul><li>不需要操作数，如空操作、停机、关中断等指令</li><li>堆栈计算机，两个操作数隐含存放在栈顶和次栈顶，计算结果压回栈顶（后缀表达式）</li></ul></li><li>一地址指令<ul><li>只需要单操作数，如加1、减1、取反、求补等<ul><li>指令含义：OP(A1) -&gt; A1 ，完成一条指令需要 3 次访存：<strong>取指 -&gt; 读A1 -&gt; 写A1</strong></li></ul></li><li>需要两个操作数，但其中一个操作数隐含在某个寄存器（如隐含在ACC）<ul><li>指令含义： (ACC)OP(A1) -&gt; ACC，完成一条指令需要2次访存：<strong>取指 -&gt; 读A1</strong></li></ul></li><li>注：A1 指某个主存地址， (A1)表示 A1 所指向的地址中的内容</li></ul></li><li>二地址指令<ul><li>常用于需要两个操作数的算术运算、逻辑运算相关指令</li><li>指令含义：(A1)OP(A2) -&gt; A1</li><li>完成一条指令需要访存 4 次，<strong>取指 -&gt; 读A1 -&gt; 读A2 -&gt; 写A1</strong></li></ul></li><li>三地址指令<ul><li>常用于需要两个操作数的算术运算、逻辑运算相关指令</li><li>指令含义：(A1)OP(A2) -&gt; A3</li><li>完成一条指令需要访存 4 次，<strong>取指 -&gt; 读A1 -&gt; 读A2 -&gt; 写A3</strong></li></ul></li><li>四地址指令<ul><li>指令含义：(A1)OP(A2) -&gt; A3，A4=下一条将要执行指令的地址</li><li>完成一条指令需要访存 4 次，<strong>取指 -&gt; 读A1 -&gt; 读A2 -&gt; 写A3</strong></li></ul></li><li><strong>若指令总长度固定不变，则地址码数量越多，寻址能力越差</strong></li></ul><h3 id="根据指令长度分类"><a href="#根据指令长度分类" class="headerlink" title="根据指令长度分类"></a>根据指令长度分类</h3><ul><li><strong>指令字长</strong>：一条指令的总长度（可能会变）<ul><li>机器字长：CPU进行一次整数运算所能处理的二进制数据的位数（通常和ALU直接相关）</li><li>存储字长：一个存储单元中的二进制代码位数（通常和MDR位数相同）</li><li>半字长指令、单字长指令、双字长指令——指令长度是机器字长的 n 倍</li><li>指令字长会影响取指令所需时间。如：机器字长=存储字长=16bit，则取一条双字长指令需要两次访存</li></ul></li><li><strong>定长指令字结构</strong>：指令系统中所有指令的长度都相等</li><li><strong>变长指令字结构</strong>：指令系统中各种指令的长度不等</li></ul><h3 id="根据操作码长度分类"><a href="#根据操作码长度分类" class="headerlink" title="根据操作码长度分类"></a>根据操作码长度分类</h3><ul><li><strong>定长操作码</strong>：指令系统中所有指令的操作码长度都相同<ul><li>控制器的译码电路设计简单，但灵活性较低</li><li>n 位 -&gt; 2^n^ 条指令</li><li>优：定长操作码对于简化计算机硬件设计，提高指令译码和识别速度很有利；</li><li>缺：指令数量增加时会占用更多固定位，留给表示操作数地址的位数受限。</li></ul></li><li><strong>可变长操作码</strong>：指令系统中各指令的操作码长度可变<ul><li>控制器的译码电路设计复杂， 但灵活性较高</li><li>不同地址数的指令可以具有不同长度的操作码，从而在满足需要的前提下，有效地缩短指令字长。</li><li>优： 在指令字长有限的前提下仍保持比较丰富的指令种类；</li><li>缺 ：增加了指令译码和分析的难度，使控制器的设计复杂化。</li></ul></li><li><strong>定长指令字结构+可变长操作码</strong> -&gt; <strong>扩展操作码指令格式</strong><ul><li>不同地址数的指令使用不同长度的操作码</li></ul></li></ul><h3 id="根据操作类型分类"><a href="#根据操作类型分类" class="headerlink" title="根据操作类型分类"></a>根据操作类型分类</h3><ul><li>数据传送类：进行主存与CPU之间的数据传送<ol><li>数据传送<ul><li>LOAD：把<strong>存储器</strong>中的数据放到<strong>寄存器</strong>中</li><li>STORE：把<strong>寄存器</strong>中的数据放到<strong>存储器</strong>中</li></ul></li></ol></li><li>运算类<ol start="2"><li>算术逻辑操作<ul><li>算术：加、减、乘、除、增 1、减 1、求补、浮点运算、十进制运算</li><li>逻辑：与、或、非、异或、位操作、位测试、位清除、位求反</li></ul></li><li>移位操作<ul><li>算术移位、逻辑移位、循环移位(带进位和不带进位)</li></ul></li></ol></li><li>程序控制类：改变程序执行的顺序<ol start="4"><li>转移操作<ul><li>无条件转移 JMP</li><li>条件转移 JZ：结果为 0；JO：结果溢出；JC：结果有进位</li><li>调用和返回 CALL 和 RETURN</li><li>陷阱(Trap)与陷阱指令</li></ul></li></ol></li><li>输入输出类（I/O）：进行CPU和I/O设备之间的数据传送<ol start="5"><li>输入输出操作<ul><li>CPU 寄存器与 IO 端口之间的数据传送（端口即 IO 接口中的寄存器）</li></ul></li></ol></li></ul><h2 id="扩展操作码指令格式"><a href="#扩展操作码指令格式" class="headerlink" title="扩展操作码指令格式"></a>扩展操作码指令格式</h2><ul><li>扩展操作码：定长指令字结构+可变长操作码</li><li>设计扩展操作码指令格式的注意点：<ul><li>不允许短码是长码的前缀。</li><li>各指令的操作码一定不能重复。</li></ul></li><li>通常情况下，对使用频率较高的指令，分配较短的操作码；对使用频率较低的指令，分配较长的操作码。从而尽可能减少指令译码和分析的时间。</li><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part4/image-20211022102529044.png" alt="image-20211022102529044"></li><li>设地址长度为 n，上一层留出 m 种状态，则下一层可扩展出 m×2^n^ 种状态</li></ul><h2 id="指令寻址"><a href="#指令寻址" class="headerlink" title="指令寻址"></a>指令寻址</h2><h3 id="顺序寻址"><a href="#顺序寻址" class="headerlink" title="顺序寻址"></a>顺序寻址</h3><ul><li>指令寻址：下一条欲执行指令的地址（<strong>始终由程序计数器PC给出</strong>）</li><li>顺序寻址：( PC ) + “1” -&gt; PC</li><li><strong>这里的“1”理解为 1 个指令的字长</strong>，实际加的值会因<strong>指令长度</strong>、<strong>编址方式</strong>而不同<ul><li><strong>定长</strong>指令字结构 + 按<strong>字</strong>编址 + 指令字长=存储字长=16bit=2B：每次 PC + 1 </li><li><strong>定长</strong>指令字结构 + 按<strong>字节</strong>编址 + 指令字长=存储字长=16bit=2B：每次 PC + 2</li><li><strong>变长</strong>指令字结构 + 按<strong>字节</strong>编址 + 指令字长!=存储字长=16bit=2B：每次 PC + n<ul><li>根据指令的类型，CPU 可能还要进行多次访存，<strong>每次读入一个字</strong></li><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part4/image-20211022130853433.png" alt="image-20211022130853433" style="zoom:80%;"></li></ul></li></ul></li></ul><h3 id="跳跃寻址"><a href="#跳跃寻址" class="headerlink" title="跳跃寻址"></a>跳跃寻址</h3><ul><li>跳跃寻址：由转移指令指出</li><li>CPU 与 PC 之间的顺序：<ul><li>CPU 取出 PC 中存储的指令</li><li>PC += 1</li><li>CPU 执行取出的指令<ul><li>如果是执行转移指令，则修改 PC 内容</li></ul></li><li>CPU 取出 PC 中存储的指令。Loop</li></ul></li><li>每一条指令的执行都分为 “取指令”、“执行指令” 两个阶段</li><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part4/image-20211022131031340.png" alt="image-20211022131031340"></li></ul><h2 id="数据寻址"><a href="#数据寻址" class="headerlink" title="数据寻址"></a>数据寻址</h2><h3 id="指令寻址-v-s-数据寻址"><a href="#指令寻址-v-s-数据寻址" class="headerlink" title="指令寻址 v.s. 数据寻址"></a>指令寻址 v.s. 数据寻址</h3><ul><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part4/image-20211022132436880.png" alt="image-20211022132436880"></li><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part4/image-20211022132520543.png" alt="image-20211022132520543"></li><li>求出操作数的真实地址，称为有效地址（EA）。</li></ul><h3 id="直接与间接寻址"><a href="#直接与间接寻址" class="headerlink" title="直接与间接寻址"></a>直接与间接寻址</h3><h4 id="直接寻址"><a href="#直接寻址" class="headerlink" title="直接寻址"></a>直接寻址</h4><ul><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part4/image-20211022133342005.png" alt="image-20211022133342005" style="zoom:80%;"></li><li>直接寻址：指令字中的<strong>形式地址 A 就是操作数的真实地址 EA(effective address)**，即 **EA=A</strong> 。</li><li>共访存 <strong>2</strong> 次：取指令访存1次；执行指令访存 1 次。</li><li>优点：<ul><li>简单，指令执行阶段仅访问一次主存，不需专门计算操作数的地址。</li></ul></li><li>缺点：<ul><li>A 的位数决定了该指令操作数的寻址范围。</li><li>操作数的地址不易修改。</li></ul></li></ul><h4 id="间接寻址"><a href="#间接寻址" class="headerlink" title="间接寻址"></a>间接寻址</h4><ul><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part4/image-20211022134527227.png" alt="image-20211022134527227" style="zoom:80%;"></li><li>间接寻址：指令的地址字段给出的形式地址是<strong>操作数有效地址所在的存储单元的地址</strong>，也就是操作数地址的地址，即 <strong>EA=(A)</strong> 。</li><li>共访存 <strong>3</strong> 次：取指令访存 1 次；执行指令访存 2 次。</li><li>优点：<ul><li>可扩大寻址范围（有效地址 EA 的位数大于形式地址 A 的位数）。</li><li>便于编制程序（用间接寻址可以方便地完成子程序返回）。</li></ul></li><li>缺点：<ul><li>指令在执行阶段要多次访存（一次间址需两次访存，多次寻址需根据存储字的最高位确定几次访存）。</li></ul></li></ul><h4 id="寄存器寻址"><a href="#寄存器寻址" class="headerlink" title="寄存器寻址"></a>寄存器寻址</h4><ul><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part4/image-20211022135027732.png" alt="image-20211022135027732" style="zoom:80%;"></li><li>寄存器寻址：在指令字中直接给出操作数所在的寄存器编号，即 **EA=R<del>i</del>**，其操作数在由 R<del>i</del> 所指的寄存器内。</li><li>共访存 <strong>1</strong> 次：取指令访存 1 次；执行指令访存 0 次。</li><li>优点：<ul><li>指令在<strong>执行阶段</strong>不访问主存，<strong>只访问寄存器</strong></li><li>指令字短且执行速度快，支持<strong>向量/矩阵运算</strong>。</li></ul></li><li>缺点：<ul><li>寄存器价格昂贵，计算机中寄存器个数有限 。</li></ul></li></ul><h4 id="寄存器间接寻址"><a href="#寄存器间接寻址" class="headerlink" title="寄存器间接寻址"></a>寄存器间接寻址</h4><ul><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part4/image-20211022135538548.png" alt="image-20211022135538548" style="zoom:80%;"></li><li>寄存器间接寻址：寄存器 R<del>i</del> 中给出的不是一个操作数，而是<strong>操作数所在主存单元的地址</strong>，即 <strong>EA=(R<del>i</del>)</strong> 。</li><li>共访存 <strong>2</strong> 次：取指令访存 1 次；执行指令访存 1 次。</li><li>特点：<ul><li>与一般间接寻址相比速度更快，但指令的执行阶段需要访问主存（因为操作数在主存中）。</li></ul></li></ul><h4 id="隐含寻址"><a href="#隐含寻址" class="headerlink" title="隐含寻址"></a>隐含寻址</h4><ul><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part4/image-20211022135948636.png" alt="image-20211022135948636" style="zoom:80%;"></li><li>隐含寻址：不是明显地给出操作数的地址，而是在指令中隐含着操作数的地址。</li><li>共访存 <strong>1</strong> 次：取指令访存 1 次；执行指令访存 0 次。</li><li>优点：有利于缩短指令字长。</li><li>缺点：需增加存储操作数或隐含地址的硬件。</li></ul><h4 id="立即寻址"><a href="#立即寻址" class="headerlink" title="立即寻址"></a>立即寻址</h4><ul><li>立即寻址：形式地址 A 就是<strong>操作数本身</strong>，又称为立即数，一般采用补码形式。“#”表示立即寻址特征。</li><li>共访存 <strong>1</strong> 次：取指令访存 1 次；执行指令访存 0 次。</li><li>优点：指令执行阶段不访问主存，<strong>指令执行时间最短</strong></li><li>缺点：A 的位数限制了立即数的范围。<ul><li>如 A 的位数为 n，且立即数采用补码时，可表示的数据范围为：−2^n-1^ ～ 2^n-1^−1</li></ul></li></ul><h3 id="偏移寻址"><a href="#偏移寻址" class="headerlink" title="偏移寻址"></a>偏移寻址</h3><h4 id="基址寻址（多道程序）"><a href="#基址寻址（多道程序）" class="headerlink" title="基址寻址（多道程序）"></a>基址寻址（多道程序）</h4><ul><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part4/image-20211022142356006.png" alt="image-20211022142356006"></li><li>基址寻址：将 CPU 中基址寄存器（base address register，BR）的内容加上指令格式中的形式地址 A，而形成操作数的有效地址，即 <strong>EA=(BR)+A</strong>。<ul><li>操作系统第三章第一节学习，OS 课中的“重定位寄存器”就是“基址寄存器”</li><li>程序运行前，CPU 将 BR 的值修改为该程序的起始地址（存在操作系统 PCB 中）</li></ul></li><li>基址寄存器是<strong>面向操作系统</strong>的，<strong>其内容仅由操作系统或管理程序确定，对于程序员是透明的</strong>。<ul><li>基址寄存器的内容不变（作为基地址），形式地址可变（作为偏移量）。</li><li>当采用通用寄存器作为基址寄存器时，可由<strong>用户决定哪个寄存器作为基址寄存器</strong>，但其<strong>内容仍由操作系统确定</strong>。</li></ul></li><li>优点：<ul><li>便于程序在内存里的地址浮动，方便实现<strong>多道程序</strong>并发运行</li><li>可扩大寻址范围（基址寄存器的位数大于形式地址的位数）</li><li>用户<strong>不必考虑自己的程序存于主存的哪一空间区域</strong>，故<strong>有利于多道程序设计</strong></li></ul></li></ul><h4 id="变址寻址（循环程序）"><a href="#变址寻址（循环程序）" class="headerlink" title="变址寻址（循环程序）"></a>变址寻址（循环程序）</h4><ul><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part4/image-20211022181842393.png" alt="image-20211022181842393"></li><li>变址寻址：有效地址 EA 等于指令字中的形式地址 A 与变址寄存器 IX 的内容相加之和，即 <strong>EA=(IX)+A</strong>。其中 <strong>IX 可为变址寄存器（专用）</strong>，也<strong>可用通用寄存器作为变址寄存器</strong>。</li><li>变址寄存器是<strong>面向用户</strong>的，<strong>变址寄存器的内容可由用户改变</strong><ul><li>基址寄存器的内容不变（作为偏移量），形式地址可变（作为基地址）。</li></ul></li><li>优点：<ul><li>在数组处理过程中，可设定 A 为数组的首地址，不断改变变址寄存器 IX(index register) 的内容，便可很容易地表示数组中任一数据的地址，<strong>适合编制循环程序</strong>。</li></ul></li><li>两者同样可以一起使用——基址&amp;变址复合寻址</li></ul><h4 id="相对寻址（转移指令）"><a href="#相对寻址（转移指令）" class="headerlink" title="相对寻址（转移指令）"></a>相对寻址（转移指令）</h4><ul><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part4/image-20211022185157913.png" alt="image-20211022185157913"></li><li>相对寻址：把程序计数器 PC 的内容加上指令格式中的形式地址 A 而形成操作数的有效地址，即 <strong>EA=(PC)+A</strong>。<ul><li><strong>A 是相对于下一条指令（PC 所指地址）的偏移量</strong>，可正可负，<strong>补码表示</strong> 。因为 PC 会在取出指令后立刻加一。</li></ul></li><li>优点：<ul><li>便于一段代码在程序内部的浮动。</li></ul></li><li>相对寻址广泛应<strong>用于转移指令</strong>。</li></ul><h3 id="堆栈寻址"><a href="#堆栈寻址" class="headerlink" title="堆栈寻址"></a>堆栈寻址</h3><h4 id="堆栈寻址-1"><a href="#堆栈寻址-1" class="headerlink" title="堆栈寻址"></a>堆栈寻址</h4><ul><li>堆栈寻址：操作数存放在堆栈中，隐含使用堆栈指针（Stack Pointer, SP）作为操作数地址。</li><li>堆栈是一块按“后进先出（LIFO）”原则管理的存储区，该存储区中被读/写单元的地址是用堆栈指针给出的。</li><li>堆栈可以由寄存器组（硬堆栈，成本高）或者主存中划分一块区域（软堆栈，成本低）实现。</li><li>有堆栈才可以方便地实现保护现场、调用函数。</li></ul><h3 id="数据寻址总结"><a href="#数据寻址总结" class="headerlink" title="数据寻址总结"></a>数据寻址总结</h3><table><thead><tr><th>寻址方式</th><th>有效地址</th><th>访存次数（指令执行期间）</th></tr></thead><tbody><tr><td>直接寻址</td><td>EA=A</td><td>1</td></tr><tr><td>一次间接寻址</td><td>EA=(A)</td><td>2</td></tr><tr><td>寄存器寻址</td><td>EA=R<del>i</del></td><td>0</td></tr><tr><td>寄存器间接一次寻址</td><td>EA=(R<del>i</del>)</td><td>1</td></tr><tr><td>隐含寻址</td><td>程序指定</td><td>0</td></tr><tr><td>立即寻址</td><td>A 即是操作数</td><td>0</td></tr><tr><td>基址寻址</td><td>EA=(BR)+A</td><td>1</td></tr><tr><td>变址寻址</td><td>EA=(IX)+A</td><td>1</td></tr><tr><td>相对寻址</td><td>EA=(PC)+A</td><td>1</td></tr><tr><td>堆栈寻址</td><td>入栈/出栈时 EA 的确定方式不同</td><td>硬堆栈不访存，软堆栈访存1次</td></tr></tbody></table><h2 id="CISC-和-RISC"><a href="#CISC-和-RISC" class="headerlink" title="CISC 和 RISC"></a>CISC 和 RISC</h2><ul><li>CISC：Complex Instruction Set Computer<ul><li>设计思路：一条指令完成一个复杂的基本功能。</li></ul></li><li>RISC：Reduced Instruction Set Computer<ul><li>设计思路：一条指令完成一个基本“动作”；多条指令组合完成一个复杂的基本功能。</li></ul></li></ul><table><thead><tr><th>对比项目</th><th>CISC</th><th>RISC</th></tr></thead><tbody><tr><td>指令系统</td><td>复杂</td><td>简单</td></tr><tr><td>代表</td><td>x86 架构</td><td>ARM 架构</td></tr><tr><td>指令数目</td><td>一般大于 200 条</td><td>一般小于 100 条</td></tr><tr><td>指令字长</td><td>不固定</td><td>定长</td></tr><tr><td>可访存指令</td><td>不加限制</td><td>有 Load/Store 指令</td></tr><tr><td>各指令执行时间</td><td>相差较大</td><td>大部分在一个周期内</td></tr><tr><td>各指令执行频率</td><td>相差较大</td><td>都比较常用</td></tr><tr><td>通用寄存器数量</td><td>较少</td><td>多</td></tr><tr><td>目标代码</td><td>难以用优化编译提高程序效率</td><td>可以用优化编译提高程序效率</td></tr><tr><td>控制方式</td><td>大部分为微程序控制（更慢）</td><td>大部分为组合逻辑控制（更快）</td></tr><tr><td>指令流水线</td><td>可以实现</td><td>必须实现</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 计算机组成原理 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>计算机组成原理-Part3</title>
      <link href="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part3/"/>
      <url>/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part3/</url>
      
        <content type="html"><![CDATA[<h1 id="计算机组成原理-Part3——存储系统"><a href="#计算机组成原理-Part3——存储系统" class="headerlink" title="计算机组成原理-Part3——存储系统"></a>计算机组成原理-Part3——存储系统</h1><p>[TOC]</p><h2 id="存储系统基本概念"><a href="#存储系统基本概念" class="headerlink" title="存储系统基本概念"></a>存储系统基本概念</h2><h3 id="存储器的层次结构"><a href="#存储器的层次结构" class="headerlink" title="存储器的层次结构"></a>存储器的层次结构</h3><ul><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part3/image-20211018200033029.png" alt="image-20211018200033029"></li><li>辅存中的数据要调入主存后才能被 CPU 访问</li><li>主存—辅存：实现虚拟存储系统，<strong>解决了主存容量不够的问题</strong></li><li>Cache—主存：<strong>解决了主存与 CPU 速度不匹配的问题</strong></li></ul><h3 id="存储器的分类"><a href="#存储器的分类" class="headerlink" title="存储器的分类"></a>存储器的分类</h3><ol><li>层次：<ul><li>高速缓存（Cache）</li><li>主存储器（主存、内存）</li><li>辅助存储器（辅存、外存）</li></ul></li><li>存储介质：<ul><li>半导体存储器（主存、Cache）</li><li>磁表面存储器（磁盘、磁带）</li><li>光存储器（光盘）</li></ul></li><li>存取方式：<ul><li><strong>随机存取存储器</strong>（Random Access Memory，RAM）（内存）</li><li>串行访问存储器：读写某个存储单元所需时间与存储单元的物理位置有关<ul><li>顺序存取存储器（Sequential Access Memory，SAM）（磁带）：读写一个存储单元所需时间取决于存储单元所在的物理位置</li><li>直接存取存储器（Direct Access Memory，DAM）（磁盘）：既有随机存取特性，也有顺序存取特性。先直接选取信息所在区域，然后按顺序方式存取。</li></ul></li><li>相联存储器（Associative Memory），即可按内容访问的存储器（Content Addressed Memory，CAM）：可以按照内容检索到存储位置进行读写，“快表”就是一种相联存储器。</li></ul></li><li>信息的可更改性：<ul><li>读写存储器（Read/Write Memory）：即可读、也可写（磁盘、内存、Cache）</li><li>只读存储器（Read Only Memory）：只能读，不能写（实体音乐专辑通常采用 CD-ROM、实体电影采用蓝光光碟、BIOS 通常写在 ROM 中）</li></ul></li><li>信息的可保存性：<ul><li>断电后，存储信息消失的存储器——易失性存储器（主存、Cache）</li><li>断电后，存储信息依然保持的存储器——非易失性存储器（磁盘、光盘）</li><li>信息读出后，原存储信息被破坏——破坏性读出（如 DRAM 芯片，读出数据后要进行重写）</li><li>信息读出后，原存储信息不被破坏——非破坏性读出（如 SRAM 芯片、磁盘、光盘）</li></ul></li></ol><h3 id="存储器的性能指标"><a href="#存储器的性能指标" class="headerlink" title="存储器的性能指标"></a>存储器的性能指标</h3><ol><li>存储容量：存储字数（MDR）×字长（MAR）。</li><li>单位成本：每位价格=总成本/总容量。（每个 bit 位的成本）</li><li>存储速度：数据传输率=数据的宽度/存储周期。<ul><li>数据的宽度=存储字长</li><li>数据传输率=主存带宽</li></ul></li></ol><p><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part3/image-20211018202338820.png" alt="image-20211018202338820"></p><ul><li><strong>存取时间</strong>（T<del>a</del>）：指从启动一次存储器操作到完成该操作所经历的时间，分为读出时间和写入时间。</li><li><strong>存取周期</strong>（T<del>m</del>）：又称<strong>读写周期</strong>或<strong>访问周期</strong>。它是指存储器进行一次完整的读写操作所需的全部时间，即连续两次独立地访问存储器操作（读或写操作）之间所需的最小时间间隔。<ul><li><strong>存取周期=存取时间+恢复时间</strong></li></ul></li><li><strong>主存带宽</strong>（B<del>m</del>）：又称<strong>数据传输率</strong>，表示每秒从主存进出信息的最大数量，单位为字/秒、字节/秒（B/s）或位/秒（b/s）。</li></ul><h2 id="主存储器的基本组成"><a href="#主存储器的基本组成" class="headerlink" title="主存储器的基本组成"></a>主存储器的基本组成</h2><h3 id="半导体元件的原理"><a href="#半导体元件的原理" class="headerlink" title="半导体元件的原理"></a>半导体元件的原理</h3><ul><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part3/image-20211018203602384.png" alt="image-20211018203602384"></li><li>MOS 管相当于一种电控开关，输入电压达到某个阈值时，MOS 管就可以接通</li><li>之所以是<strong>按存储字读写</strong>，是因为<strong>一个存储单元共用一条线来控制 MOS 管</strong>，只能同时读取或同时写入一个字</li></ul><h3 id="存储芯片的基本原理"><a href="#存储芯片的基本原理" class="headerlink" title="存储芯片的基本原理"></a>存储芯片的基本原理</h3><ul><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part3/image-20211018204801463.png" alt="image-20211018204801463"></li><li>头上划线表示该信号低电平有效</li><li>引脚与数据线<ul><li>地址线</li><li>数据线</li><li>片选线：一块内存条可能有多块存储芯片<ul><li>CS：Chip-Select；CE：Chip-Enable（两种表示方式皆可，当有上划线则表示低电平有效）</li><li>对选中存储芯片的片选线给予低电平，对未选中的给予高电平</li></ul></li><li>读写线<ul><li>当使用不同数量的读写线，则对外暴露的引脚是不一样的</li><li>使用 WE(Write Enable)、OE，则两根读写线</li><li>使用 WE或WR 则一根读写线（低电平写，高电平读）</li></ul></li></ul></li><li>译码器驱动电路：将地址信号转化成字选通线的高低电平</li><li>存储矩阵（存储体）：由多个存储单元构成，每个存储单元又由多个存储元构成</li></ul><h3 id="如何实现不同的寻址方式"><a href="#如何实现不同的寻址方式" class="headerlink" title="如何实现不同的寻址方式"></a>如何实现不同的寻址方式</h3><ul><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part3/image-20211018223923446.png" alt="image-20211018223923446"></li><li>一般以<strong>字节</strong>编址，即每个字节对应一个地址。同时也能够支持按半字、字、双字寻址</li><li>存储单元的长度并不影响按何种方式寻址，但是一次读写数据必须按字为单位</li><li>n 根地址线能够寻 2^n^ 个存储单元</li></ul><h2 id="SRAM-和-DRAM"><a href="#SRAM-和-DRAM" class="headerlink" title="SRAM 和 DRAM"></a>SRAM 和 DRAM</h2><ul><li>随机存取存储器（Random Access Memory，RAM）<ul><li>Dynamic Random Access Memory，即动态RAM</li><li>Static Random Access Memory，即静态RAM</li><li><strong>DRAM</strong> 用于<strong>主存</strong>；<strong>SRAM</strong> 用于 <strong>Cache</strong></li></ul></li><li>核心区别：<strong>存储元不一样</strong><ul><li>DRAM芯片：使用<strong>栅极电容</strong>存储信息</li><li>SRAM芯片：使用<strong>双稳态触发器</strong>存储信息</li></ul></li></ul><h3 id="存储元件不同导致的特性差异"><a href="#存储元件不同导致的特性差异" class="headerlink" title="存储元件不同导致的特性差异"></a>存储元件不同导致的特性差异</h3><h4 id="栅极电容"><a href="#栅极电容" class="headerlink" title="栅极电容"></a>栅极电容</h4><p><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part3/image-20211019205541116.png" alt="image-20211019205541116"></p><ul><li>存储状态<ul><li>1：电容内存储了电荷</li><li>0：电容内未存储电荷</li></ul></li><li>读出状态<ul><li>读出 1：MOS 管接通，电容放电，数据线上产生电流</li><li>读出 0：MOS 管接通后，数据线上无电流</li></ul></li><li>特点<ul><li>电容放电信息被破坏，是<strong>破坏性读出</strong>。所以，读出后应有<strong>重写</strong>操作，也称“再生”</li><li>读写速度<strong>更慢</strong></li><li><strong>制造成本更低，集成度高，功耗低</strong></li></ul></li></ul><h4 id="双稳态触发器"><a href="#双稳态触发器" class="headerlink" title="双稳态触发器"></a>双稳态触发器</h4><p><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part3/image-20211019205912531.png" alt="image-20211019205912531"></p><ul><li>存储状态<ul><li>1：A 高电平 B 低电平</li><li>0：A 低电平 B 高电平</li></ul></li><li>读出状态<ul><li>读出 0：BL 为低电平，BLX 无信号</li><li>读出 1：BLX 为低电平，BL 无信号</li></ul></li><li>特点<ul><li>读出数据，触发器状态保持稳定，是<strong>非破坏性读出</strong>，<strong>无需重写</strong></li><li>读写速度<strong>更快</strong></li><li><strong>制造成本更高，集成度低，功耗大</strong></li></ul></li></ul><h4 id="DRAM-和-SRAM-对比（高频）"><a href="#DRAM-和-SRAM-对比（高频）" class="headerlink" title="DRAM 和 SRAM 对比（高频）"></a>DRAM 和 SRAM 对比（高频）</h4><table><thead><tr><th>类型特点</th><th>SRAM（静态 RAM）</th><th>DRAM（动态 RAM）</th></tr></thead><tbody><tr><td>存储信息</td><td>触发器</td><td>电容</td></tr><tr><td>破坏性读出</td><td>否</td><td>是</td></tr><tr><td>读出后需要重写</td><td>否</td><td>是</td></tr><tr><td>运行速度</td><td>快</td><td>man</td></tr><tr><td>集成度</td><td>低</td><td>高</td></tr><tr><td>发热量</td><td>大</td><td>小</td></tr><tr><td>存储成本</td><td>高</td><td>低</td></tr><tr><td>易失/非易失性存储器</td><td>易失（断电后丢失信息）</td><td>易失（断电后丢失信息）</td></tr><tr><td>需要刷新</td><td>不需要</td><td>需要</td></tr><tr><td>送行列地址</td><td>同时送</td><td>分两次送</td></tr><tr><td>常用与制作</td><td>Cache</td><td>主存</td></tr></tbody></table><h3 id="DRAM-的刷新"><a href="#DRAM-的刷新" class="headerlink" title="DRAM 的刷新"></a>DRAM 的刷新</h3><p><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part3/image-20211019220838787.png" alt="image-20211019220838787"></p><ul><li><p>为什么刷新？</p><ul><li>双稳态（静态RAM，SRAM）只要不断电，触发器的状态就不会改变。所以<strong>不需要刷新</strong>。</li><li>栅极电容（动态RAM，DRAM）电容内的电荷只能维持 2ms。即便不断电，2ms 后信息也会消失。所以，2ms 之内必须“刷新”一次（给电容充电）</li></ul></li><li><p>多久需要刷新一次？刷新周期：若题目没有指明，则一般为 <strong>2ms</strong></p></li><li><p>每次刷新多少存储单元？以行为单位，<strong>每次刷新一行存储单元</strong></p><ul><li>为什么要用行列地址？<strong>减少选通线的数量</strong>。拆分为行列地址（<strong>DRAM行、列地址等长</strong>）</li></ul></li><li><p>如何刷新？有硬件支持，读出一行的信息后重新写入，<strong>占用1个读/写周期（存取周期）</strong></p></li><li><p>在什么时刻刷新？</p><ul><li>假设 DRAM 内部结构排列成 128×128 的形式，读/写周期 0.5us。2ms 共 <code>2ms / 0.5us = 4000</code> 个周期</li></ul></li><li><p><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part3/image-20211019215622587.png" alt="image-20211019215622587"></p></li><li><p>“刷新”由存储器独立完成，不需要 CPU 控制。</p></li></ul><h3 id="DRAM-的地址线复用技术"><a href="#DRAM-的地址线复用技术" class="headerlink" title="DRAM 的地址线复用技术"></a>DRAM 的地址线复用技术</h3><ul><li>SRAM 同时送行列地址；DRAM 分两次送行列地址。</li><li>同时送指的是将地址的前后两部分同时送给行地址译码器和列地址译码器。这样的话，<strong>地址有 n 位，就要设计 n 根地址线</strong></li><li>但是 DRAM 的存储容量较大。所以将<strong>地址线、引脚减半</strong>，先将<strong>前半部分送入行地址缓冲器</strong>，再将<strong>后半部分送入列地址缓冲器</strong></li></ul><h2 id="只读存储器ROM"><a href="#只读存储器ROM" class="headerlink" title="只读存储器ROM"></a>只读存储器ROM</h2><h3 id="各种-ROM"><a href="#各种-ROM" class="headerlink" title="各种 ROM"></a>各种 ROM</h3><ol><li><strong>MROM（Mask Read-Only Memory）</strong>——掩模式只读存储器<ul><li>厂家按照客户需求，在芯片生产过程中直接写入信息，之后<strong>任何人不可重写</strong>（只能读出）</li><li>可靠性高、灵活性差、生产周期长、只适合批量定制</li></ul></li><li><strong>PROM（Programmable Read-Only Memory）</strong>——可编程只读存储器<ul><li>用户可用专门的PROM写入器写入信息，<strong>写一次之后就不可更改</strong></li></ul></li><li><strong>EPROM（Erasable Programmable Read-Only Memory）</strong>——可擦除可编程只读存储器<ul><li>允许用户写入信息，之后用某种方法擦除数据，<strong>修改次数有限，写入时间很长</strong></li><li>UVEPROM（ultraviolet rays）——用紫外线照射8~20分钟，<strong>擦除所有信息</strong></li><li>EEPROM（也常记为E2 PROM，第一个E是Electrically）——可用“电擦除”的方式，<strong>擦除特定的字</strong></li></ul></li><li><strong>Flash Memory</strong> ——闪速存储器（注：U盘、SD卡就是闪存）<ul><li>在EEPROM 基础上发展而来，断电后也能保存信息，且<strong>可进行多次快速擦除重写</strong></li><li>注意：由于闪存需要先擦除在写入，因此<strong>闪存的“写”速度要比“读”速度更慢</strong>。</li><li>每个存储元只需单个MOS管，位密度比RAM高</li></ul></li><li><strong>SSD（Solid State Drives）</strong>—— 固态硬盘<ul><li>由控制单元+存储单元（Flash 芯片）构成，与闪速存储器的核心区别在于控制单元不一样，但存储介质都类似，<strong>可进行多次快速擦除重写</strong>。</li><li>SSD速度快、功耗低、价格高。</li><li>手机辅存也使用Flash 芯片，但相比SSD使用的芯片集成度高、功耗低、价格贵</li></ul></li></ol><ul><li>很多 ROM 芯片虽然名字是“Read-Only”，但<strong>很多 ROM 也可以“写”</strong></li><li>RAM（Random Access Memory）芯片是易失性的，ROM（Read-Only Memory）芯片是非易失性的。<strong>很多 ROM 也具有“随机存取”的特性</strong></li></ul><h3 id="计算机内的重要-ROM"><a href="#计算机内的重要-ROM" class="headerlink" title="计算机内的重要 ROM"></a>计算机内的重要 ROM</h3><ul><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part3/image-20211019223754947.png" alt="image-20211019223754947"></li><li>针对问题<ul><li>断电后，RAM内数据全部丢失</li><li>操作系统安装在辅存</li></ul></li><li><strong>主板上的</strong> BIOS 芯片（ROM），存储了“自举装入程序”，负责引导装入操作系统（开机）</li><li>逻辑上，<strong>主存由 RAM+ROM 组成</strong>，且二者常统一编址</li><li>我们常说“内存条”就是“主存”，但事实上，主板上的 ROM 芯片也是“主存”的一部分</li></ul><h2 id="主存储器与-CPU-的连接"><a href="#主存储器与-CPU-的连接" class="headerlink" title="主存储器与 CPU 的连接"></a>主存储器与 CPU 的连接</h2><h3 id="单块存储芯片与-CPU-的连接"><a href="#单块存储芯片与-CPU-的连接" class="headerlink" title="单块存储芯片与 CPU 的连接"></a>单块存储芯片与 CPU 的连接</h3><ul><li><p>针对问题：想要扩展主存<strong>字数</strong></p><ul><li>改进方向：<strong>字扩展</strong></li><li>连接多块存储芯片来扩展主存字数</li></ul></li><li><p>针对问题：想要扩展<strong>存储字长</strong></p><ul><li>改进方向：<strong>位扩展</strong></li><li>一个存储字长是 8bit，而数据总线一般有 64bit</li><li>为了尽可能发挥数据总线的性能，要保持<strong>数据总线宽度=存储字长</strong>，提高一次读写的数据量</li></ul></li><li><p>现在 MDR 和 MAR 常集成于 CPU 内部，存储芯片内只需要一个普通的寄存器（暂存输入输出数据）</p><ul><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part3/image-20211020121325377.png" alt="image-20211020121325377" style="zoom:80%;"></li><li>CPU 和主存之间通过<strong>数据总线</strong>、<strong>地址总线</strong>、<strong>控制总线</strong>连接</li><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part3/image-20211020123151574.png" alt="image-20211020123151574" style="zoom:80%;"></li><li>对外暴露的引脚：地址线+数据线+片选线+读写控制线</li></ul></li></ul><h3 id="多块存储芯片与-CPU-的连接"><a href="#多块存储芯片与-CPU-的连接" class="headerlink" title="多块存储芯片与 CPU 的连接"></a>多块存储芯片与 CPU 的连接</h3><h4 id="位扩展法"><a href="#位扩展法" class="headerlink" title="位扩展法"></a>位扩展法</h4><ul><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part3/image-20211020130901005.png" alt="image-20211020130901005" style="zoom:80%;"></li><li>将 <strong>n</strong> 片 <strong>k×m</strong> 位的存储芯片，集合成 <strong>k×(m×n)</strong> 的芯片</li></ul><h4 id="字扩展法"><a href="#字扩展法" class="headerlink" title="字扩展法"></a>字扩展法</h4><h5 id="线选法"><a href="#线选法" class="headerlink" title="线选法"></a>线选法</h5><ul><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part3/image-20211020131651225.png" alt="image-20211020131651225" style="zoom:80%;"></li><li><strong>n</strong> 条线可提供 <strong>n</strong> 个片选信号</li><li>将 <strong>n</strong> 片 <strong>k×m</strong> 位的存储芯片，集合成 <strong>(n×k)×m</strong> 的芯片</li></ul><h5 id="片选法"><a href="#片选法" class="headerlink" title="片选法"></a>片选法</h5><ul><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part3/image-20211020131755343.png" alt="image-20211020131755343"></li><li><strong>n</strong> 条线可提供 <strong>2^n^</strong> 个片选信号</li><li>将 <strong>n</strong> 片 <strong>k×m</strong> 位的存储芯片，集合成 <strong>(n^2^×k)×m</strong> 的芯片</li><li>要注意译码器的接线，若 A<del>15</del> 无接线，则 A<del>15</del> 取值与地址无关</li></ul><table><thead><tr><th>线选法</th><th>译码片选法</th></tr></thead><tbody><tr><td>n 条线 -&gt; n 个片选信号</td><td>n 条线 -&gt; 2^n^ 个片选信号</td></tr><tr><td>电路简单</td><td>电路复杂</td></tr><tr><td>地址空间不连续</td><td>地址空间连续</td></tr></tbody></table><h4 id="字位扩展法"><a href="#字位扩展法" class="headerlink" title="字位扩展法"></a>字位扩展法</h4><ul><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part3/image-20211020133531141.png" alt="image-20211020133531141"></li><li>同时扩展字位</li></ul><h3 id="译码器知识补充"><a href="#译码器知识补充" class="headerlink" title="译码器知识补充"></a>译码器知识补充</h3><ul><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part3/image-20211020135655208.png" alt="image-20211020135655208" style="zoom:80%;"></li><li>低电平有效还是高电平有效，在译码器与存储芯片之间是相互协调同步的，<strong>都带圈或都不带圈</strong>。带圈则低电平，否则高电平。</li><li>译码器会有<strong>一个或者多个</strong>使能端，带圈则低电平，否则高电平。<ul><li>CPU 可使用译码器的使能端控制片选信号的生效时间</li><li>保证地址的信号稳定之后，再由 MREQ 发出存储器请求信号，然后译码器发出片选信号</li></ul></li><li>RAM的读周期<ul><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part3/image-20211020135621066.png" alt="image-20211020135621066"></li></ul></li></ul><h2 id="双端口-RAM-和多模块存储器"><a href="#双端口-RAM-和多模块存储器" class="headerlink" title="双端口 RAM 和多模块存储器"></a>双端口 RAM 和多模块存储器</h2><h3 id="存取周期"><a href="#存取周期" class="headerlink" title="存取周期"></a>存取周期</h3><ul><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part3/image-20211020140333261.png" alt="image-20211020140333261"></li><li>存取周期：可以连续读/写的最短时间间隔<ul><li><strong>存取周期T = 存取时间r + 恢复时间</strong></li></ul></li><li>DRAM 芯片的恢复时间比较长，有可能是存取时间的几倍（SRAM的恢复时间较短）<ul><li>如：存取时间为 r，存取周期为 T，T=4r</li><li>针对问题：多核CPU都要访存；CPU 读写速度比主存快很多，而主存恢复时间太长</li></ul></li></ul><h3 id="双端口-RAM"><a href="#双端口-RAM" class="headerlink" title="双端口 RAM"></a>双端口 RAM</h3><ul><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part3/image-20211020140651218.png" alt="image-20211020140651218"></li><li>作用：<strong>优化多核 CPU 访问一根内存条的速度</strong></li><li><strong>需要有两组完全独立的数据线、地址线、控制线</strong>。</li><li><strong>CPU、RAM 中控制电路也更复杂</strong>。</li><li>两个端口对同一主存操作有以下 4 种情况：<ol><li>两个端口同时对不同的地址单元存取数据。 </li><li>两个端口同时对同一地址单元读出数据。 </li><li>两个端口同时对同一地址单元写入数据。 （禁止）</li><li>两个端口同时对同一地址单元，一个写入数据，另一个读出数据。（禁止）</li></ol></li><li>置“busy”信号为 0，由判断逻辑决定暂时关闭一个端口（即被延时）</li></ul><h3 id="多模块存储器"><a href="#多模块存储器" class="headerlink" title="多模块存储器"></a>多模块存储器</h3><h4 id="多体并行存储器"><a href="#多体并行存储器" class="headerlink" title="多体并行存储器"></a>多体并行存储器</h4><ul><li><p><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part3/image-20211020151139894.png" alt="image-20211020151139894"></p></li><li><p><strong>高位交叉编址</strong>：<strong>更慢</strong>；<strong>低位交叉编址</strong>：<strong>更快</strong></p></li><li><p>为什么要探讨“连续访问”的情况？诸如数组、程序代码，都是在连续空间中存储的。</p></li><li><p>低位交叉编址</p><ul><li>采用“流水线”的方式并行存取（宏观上并行访问 m 个模块，微观上串行访问 m 个模块）</li><li>宏观上，一个存储周期内，m 体交叉存储器可以提供的数据量为单个模块的 m 倍。</li></ul></li><li><p>应该取多少个存储体？</p><ul><li>存取周期为 T，<strong>存取时间</strong>（<strong>总线传输周期</strong>）为 r，为了使流水线不间断，应保证模块数 <strong>m≥T/r</strong></li><li>存取时间：<strong>存储体的性能瓶颈</strong>。总线传输周期：<strong>将数据传给 CPU 所需要的时间</strong>。<ul><li>虽然意义不同，但<strong>都代表了 CPU 存取一次的时间都不可能低于 r</strong></li></ul></li><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part3/image-20211020151753136.png" alt="image-20211020151753136"></li></ul></li><li><p>通过地址 x，确定为第几个存储体</p><ul><li>通过二进制 体内地址+体号 中的<strong>体号</strong>确定</li><li>通过十进制对地址取余 <strong>x%m</strong></li></ul></li></ul><h4 id="单体多字存储器"><a href="#单体多字存储器" class="headerlink" title="单体多字存储器"></a>单体多字存储器</h4><ul><li>每次并行读出 m 个连续的<strong>字</strong></li><li>总线宽度也要扩展成 m</li><li>速度效率因为是一次读出 m 个字，所以跟多体并行存储器是差不多的<ul><li>但是相比多体并行存储器，单体多字存储器更加不灵活</li></ul></li></ul><h2 id="Cache-的基本概念和原理（高频）"><a href="#Cache-的基本概念和原理（高频）" class="headerlink" title="Cache 的基本概念和原理（高频）"></a>Cache 的基本概念和原理（高频）</h2><h3 id="高速缓冲存储器-Cache"><a href="#高速缓冲存储器-Cache" class="headerlink" title="高速缓冲存储器 Cache"></a>高速缓冲存储器 Cache</h3><ul><li>针对问题：双端口 RAM、多模块存储器<strong>提高存储器的工作速度</strong>，但<strong>与 CPU 差距依然很大</strong></li><li>改进方向：更高速的存储单元 <strong>Cache</strong> 和存储体系的改善“<strong>Cache-主存</strong>”层次</li><li>依据：程序访问的<strong>局部性原理</strong></li><li>Cache 的工作原理：<ul><li><strong>Cache 被集成在CPU内部</strong>，Cache <strong>用 SRAM 实现</strong>，速度快，成本高。</li><li>将可能会被经常用到的代码/数据<strong>复制</strong>一份到 Cache</li></ul></li></ul><h3 id="局部性原理"><a href="#局部性原理" class="headerlink" title="局部性原理"></a>局部性原理</h3><ul><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part3/image-20211020221430934.png" alt="image-20211020221430934"></li><li>空间局部性：在最近的未来要用到的信息(指令和数据)，很可能与现在正在使用的信息在<strong>存储空间</strong>上是邻近的<ul><li>Eg：数组元素、顺序执行的指令代码</li></ul></li><li>时间局部性：在最近的未来要用到的信息，很可能是现在<strong>正在使用的信息</strong><ul><li>Eg：循环结构的指令代码</li></ul></li><li>基于局部性原理，可以把 CPU 目前访问的地址“周围”的部分数据放到 Cache 中</li><li>程序 B 按“列优先”访问二维数组，空间局部性更差，更难利用 Cache 的优势</li></ul><h3 id="性能分析"><a href="#性能分析" class="headerlink" title="性能分析"></a>性能分析</h3><ul><li>设 t<del>c</del> 为访问一次 Cache 所需时间，t<del>m</del> 为访问一次主存所需时间</li><li><strong>命中率</strong> H：CPU 欲访问的信息已在 Cache 中存在的比率</li><li><strong>缺失（未命中）率</strong> M：1 - H</li><li>“Cache—主存”系统的<strong>平均访问时间</strong> t 为：<ul><li>先访问 Cache，若 Cache 未命中再访问主存：t = H * t<del>c</del> + (1 - H) * (t<del>c</del> + t<del>m</del>)</li><li>同时访问 Cache 和主存，若 Cache 命中则立即停止访问主存：t = H * t<del>c</del> + (1 - H) * t<del>m</del> </li></ul></li></ul><h3 id="存储空间分块"><a href="#存储空间分块" class="headerlink" title="存储空间分块"></a>存储空间分块</h3><ul><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part3/image-20211020223722710.png" alt="image-20211020223722710"></li><li>主存与 Cache 之间<strong>以“块”为单位</strong>进行数据交换。</li><li>主存地址可以看作为：<strong>块号 + 块内地址</strong></li><li><strong>操作系统</strong>中，通常将主存中的“一个<strong>块</strong>”也称为“一个<strong>页/页面/页框</strong>”</li><li>Cache 中的“<strong>块</strong>”也称为“<strong>行</strong>” </li><li><strong>每次被访问的主存块，一定会被立即调入 Cache</strong>。</li><li><strong>Cache 的块和主存的块大小相等</strong>。</li></ul><h2 id="Cache-和主存的映射方式"><a href="#Cache-和主存的映射方式" class="headerlink" title="Cache 和主存的映射方式"></a>Cache 和主存的映射方式</h2><h3 id="Cache-中存储的信息"><a href="#Cache-中存储的信息" class="headerlink" title="Cache 中存储的信息"></a>Cache 中存储的信息</h3><ul><li>针对问题：<strong>如何确定 Cache 与主存的数据块对应关系</strong></li><li>Cache 中存储的信息：<strong>有效位（0/1标记是否有效）</strong>+ <strong>标记（来自主存的块号）</strong>+ 块数据</li><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part3/image-20211021090740397.png" alt="image-20211021090740397"></li></ul><h3 id="全相联映射"><a href="#全相联映射" class="headerlink" title="全相联映射"></a>全相联映射</h3><ul><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part3/image-20211021092031684.png" alt="image-20211021092031684"></li><li>映射规则：主存块可以放在 Cache 的<strong>任意位置</strong> </li><li>优点：<strong>Cache 存储空间利用充分，命中率高</strong></li><li>缺点：<strong>查找标记慢，可能要遍历所有行</strong></li><li>CPU 访存：<ul><li>将想要访问的主存地址的<strong>前 22 位</strong>主存块号，对比 Cache 中所有块的<strong>标记</strong>；</li><li>若标记匹配且有效位=1，则 Cache 命中，访问块内地址为 001110 的单元。</li><li>若未命中或有效位=0，则正常访问主存</li></ul></li></ul><h3 id="直接映射"><a href="#直接映射" class="headerlink" title="直接映射"></a>直接映射</h3><ul><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part3/image-20211021093735633.png" alt="image-20211021093735633"></li><li>映射规则：每个主存块只能放到一个特定的位置：<strong>Cache块号 = 主存块号 % Cache总块数</strong> </li><li>优点：对于任意地址<strong>只需要比对一遍标记，速度最快</strong></li><li>缺点：即使其他地方有空闲 Cache 块，但是不一定能使用。存储空间利用不充分，命中率低</li><li>优化标记：<ul><li>若 <strong>Cache总块数=2^n^</strong> 则主存块号末尾 n 位<strong>直接反映它在 Cache 中的位置</strong></li><li>其主存块号的其余位即为标记</li></ul></li><li>CPU 访存：<ul><li>根据主存块号的<strong>后 3 位确定 Cache 行</strong></li><li>若主存块号的<strong>前 19 位与 Cache 标记匹配</strong>且有效位=1，则 Cache 命中，访问块内地址为 001110 的单元。</li><li>若未命中或有效位=0，则正常访问主存</li></ul></li></ul><h3 id="组相连映射"><a href="#组相连映射" class="headerlink" title="组相连映射"></a>组相连映射</h3><ul><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part3/image-20211021094545290.png" alt="image-20211021094545290"></li><li>映射规则：Cache 块分为若干组，每个主存块可放到特定分组中的任意一个位置：<strong>组号 = 主存块号 % 分组数</strong> </li><li>n 路组相联映射——每 n 个Cache 行为一组</li><li>优点：是前两种的折中方式</li><li>CPU 访存：<ul><li>根据主存块号的<strong>后 2 位确定所属分组号</strong></li><li>若主存块号的<strong>前 20 位与分组内的某个标记匹配</strong>且有效位=1， 则 Cache 命中，访问块内地址为 001110 的单元。</li><li>若未命中或有效位=0，则正常访问主存</li></ul></li></ul><h2 id="Cache-替换算法"><a href="#Cache-替换算法" class="headerlink" title="Cache 替换算法"></a>Cache 替换算法</h2><ul><li><p><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part3/image-20211021204805492.png" alt="image-20211021204805492"></p></li><li><p>针对问题：Cache 很小，主存很大。如何替换满 Cache 的块数据</p></li><li><p><strong>抖动现象</strong>：<strong>频繁的换入换出现象（刚被替换的块很快又被调入）</strong></p></li><li><p><strong>随机算法</strong>（<strong>RAND</strong>, Random）—— 若 Cache 已满，则随机选择一块替换。</p><ul><li>评价：：实现简单，但完全没考虑局部性原理，命中率低，实际效果很不稳定</li></ul></li><li><p><strong>先进先出算法</strong>（<strong>FIFO</strong>, First In First Out）—— 若 Cache 已满，则替换最先被调入 Cache 的块</p><ul><li>评价：：实现简单，依然没考虑局部性原理，最先被调入 Cache 的块也有可能是被频繁访问的</li></ul></li><li><p><strong>近期最少使用算法</strong>（<strong>LRU</strong>, Least Recently Used ）—— 为每一个 Cache 块设置一个“<strong>计数器</strong>”，用于记录每个 Cache 块已经有多久没被访问了。当 Cache 满后<strong>替换“计数器”最大的</strong></p><ul><li>机器实现：<ul><li>命中时，<strong>所命中的行的计数器清零</strong>，<strong>比其低的计数器加1，比其高的不变</strong>；</li><li>未命中且还有空闲行时，新装入的行的计数器置0，其余非空闲行全加1；</li><li>未命中且无空闲行时，计数值最大的行的信息块被淘汰，新装行的块的计数器置0，其余全加1。</li></ul></li><li><strong>刷题策略</strong>：当需要确定替换谁时，<strong>在“依次访问主存块”列表向前数 n 位，最后一个即为淘汰项</strong></li><li><strong>Cache 块的总数=2^n^，则计数器只需 n 位</strong>。且 Cache 装满后所有计数器的值一定不重复</li><li>评价：<ul><li>基于“局部性原理”，近期被访问过的主存块，在不久的将来也很有可能被再次访问，因此淘汰最久没被访问过的块是合理的。LRU 算法的<strong>实际运行效果优秀，Cache 命中率高</strong>。</li><li>但若<strong>被频繁访问的主存块数量 &gt; Cache 行的数量</strong>，则有可能发生“抖动”，如：{1,2,3,4,5,1,2,3,4,5,1,2…}</li></ul></li></ul></li><li><p><strong>最不经常使用算法</strong>（<strong>LFU</strong>, Least Frequently Used ）—— 为每一个 Cache 块设置一个“<strong>计数器</strong>”，用于记录每个 Cache 块被访问过几次。当 Cache 满后<strong>替换“计数器”最小的</strong></p><ul><li>若有多个计数器最小的行，可按行号递增、或 FIFO 策略进行选择</li><li>计数器范围可能会很大</li><li>评价：曾经被经常访问的主存块<strong>在未来不一定会用到</strong>（如：微信视频聊天相关的块），并没有很好地遵循局部性原理，因此<strong>实际运行效果不如 LRU</strong></li></ul></li><li><p>最常考察的是近期最少使用算法 LRU，同时也不太会考察计数器，掌握刷题策略即可</p></li></ul><h2 id="Cache-写策略"><a href="#Cache-写策略" class="headerlink" title="Cache 写策略"></a>Cache 写策略</h2><ul><li>针对问题：CPU 修改了 Cache 中的数据副本，如何确保主存中数据母本的一致性？</li><li>读操作不会导致数据不一致性，所以只需要讨论写操作</li></ul><h3 id="写命中"><a href="#写命中" class="headerlink" title="写命中"></a>写命中</h3><h4 id="全写法"><a href="#全写法" class="headerlink" title="全写法"></a>全写法</h4><ul><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part3/image-20211021212957934.png" alt="image-20211021212957934"></li><li>全写法(写直通法，write-through) —— 当CPU对Cache写命中时，必须把数据同时写入 Cache 和主存，一般使用写缓冲(write buffer)</li><li><strong>访存次数增加，速度变慢</strong>，但<strong>更能保证数据一致性</strong>。</li><li>使用写缓冲时：CPU 写的速度很快，若写操作不频繁，则效果很好。若写操作很频繁，可能会因为写缓冲饱和而发生阻塞。</li></ul><h4 id="写回法"><a href="#写回法" class="headerlink" title="写回法"></a>写回法</h4><ul><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part3/image-20211021212704830.png" alt="image-20211021212704830"></li><li>写回法(write-back) —— 当 CPU 对 Cache 写命中时，<strong>只修改 Cache 的内容，而不立即写入主存，只有当此块被换出时才写回主存</strong> </li><li>要新增一个<strong>脏位</strong>，表示是否经过修改</li><li><strong>减少了访存次数</strong>，但<strong>存在数据不一致的隐患</strong>。</li></ul><h3 id="写不命中"><a href="#写不命中" class="headerlink" title="写不命中"></a>写不命中</h3><h4 id="写分配法"><a href="#写分配法" class="headerlink" title="写分配法"></a>写分配法</h4><ul><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part3/image-20211021213711247.png" alt="image-20211021213711247"></li><li>写分配法(write-allocate)——当 CPU 对 Cache 写不命中时，把主存中的块调入 Cache，在 Cache 中修改。<strong>通常搭配写回法使用</strong>。</li></ul><h4 id="非写分配法"><a href="#非写分配法" class="headerlink" title="非写分配法"></a>非写分配法</h4><ul><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part3/image-20211021213515741.png" alt="image-20211021213515741"></li><li>非写分配法(not-write-allocate)——当 CPU 对 Cache <strong>写不命中时</strong>只写入主存，不调入Cache。<strong>搭配全写法使用</strong>。<ul><li>全写法—— 当 CPU 对 Cache <strong>写命中时</strong>，必须把数据同时写入Cache和主存，一般使用写缓冲</li><li>只有“读”未命中时才会调入 Cache</li></ul></li></ul><h3 id="多级-Cache"><a href="#多级-Cache" class="headerlink" title="多级 Cache"></a>多级 Cache</h3><ul><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part3/image-20211021213826421.png" alt="image-20211021213826421"></li><li>各级 Cache 之间常采用“全写法+非写分配法”。保证数据一致性。</li><li>Cache-主存 之间常采用“写回法+写分配法”。减少访存次数。</li></ul><h2 id="页式存储器"><a href="#页式存储器" class="headerlink" title="页式存储器"></a>页式存储器</h2><h3 id="页式存储"><a href="#页式存储" class="headerlink" title="页式存储"></a>页式存储</h3><ul><li>页式存储系统：<ul><li>一个程序(进程)<strong>在逻辑上被分为若干个大小相等的页面</strong>；</li><li><strong>页面大小与块的大小相同</strong>；</li><li><strong>每个页面可以离散地放入不同的主存块中</strong>，从而提高主存的利用率。</li></ul></li><li>CPU 执行的机器指令中，使用的是“逻辑地址”，因此<strong>需要通过“页表”将逻辑地址转为物理地址</strong>。<ul><li>逻辑地址（虚地址）：程序员视角看到的地址<ul><li>逻辑地址= 逻辑页号+页内地址（虚地址=虚页号+页内地址）</li></ul></li><li>物理地址（实地址）：实际在主存中的地址<ul><li>物理地址= 主存块号+页内地址（实地址=实页号+页内地址）</li></ul></li><li>页表的作用：记录了每个逻辑页面存放在哪个主存块中</li><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part3/image-20211021220933259.png" alt="image-20211021220933259"></li></ul></li></ul><h3 id="地址变换过程"><a href="#地址变换过程" class="headerlink" title="地址变换过程"></a>地址变换过程</h3><ul><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part3/image-20211021221504428.png" alt="image-20211021221504428"></li><li>快表是一种“相联存储器”，可以按内容寻访</li><li>快表中存储的是页表项的副本；Cache中存储的是主存块的副本。</li></ul><h2 id="虚拟存储器"><a href="#虚拟存储器" class="headerlink" title="虚拟存储器"></a>虚拟存储器</h2><h3 id="页式虚拟存储器"><a href="#页式虚拟存储器" class="headerlink" title="页式虚拟存储器"></a>页式虚拟存储器</h3><ul><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part3/image-20211021231033684.png" alt="image-20211021231033684"></li><li>有效位：这个页面是否已调入主存</li><li>脏位：这个页面是否被修改过</li><li>引用位：用于“页面置换算法”，比如，可以用来统计这个页面被访问过多少次</li><li>物理页：即主存块号</li><li>磁盘地址：即这个页面的数据在磁盘中的存放位置</li></ul><h3 id="段-页-式虚拟存储器"><a href="#段-页-式虚拟存储器" class="headerlink" title="段(页)式虚拟存储器"></a>段(页)式虚拟存储器</h3><ul><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part3/image-20211021231601239.png" alt="image-20211021231601239"></li><li>页式虚拟存储器——拆分成大小相等的页面</li><li>段式虚拟存储器——按照功能模块拆分。如：#0 段是自己的代码，#1 段是库函数代码，#2 段是变量</li><li>段页式虚拟存储器——把程序按逻辑结构分段，每段再划分为固定大小的页，主存空间也划分为大小相等的页。<ul><li>程序对主存的调入、调出仍以页为基本传送单位。</li><li><strong>每个程序对应一个段表</strong>，每段对应一个页表。</li><li>虚拟地址：段号+段内页号+页内地址</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机组成原理 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>计算机组成原理-Part2</title>
      <link href="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part2/"/>
      <url>/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part2/</url>
      
        <content type="html"><![CDATA[<h1 id="计算机组成原理-Part2——数据的表示和运算"><a href="#计算机组成原理-Part2——数据的表示和运算" class="headerlink" title="计算机组成原理-Part2——数据的表示和运算"></a>计算机组成原理-Part2——数据的表示和运算</h1><p>[TOC]</p><h2 id="数制与编码"><a href="#数制与编码" class="headerlink" title="数制与编码"></a>数制与编码</h2><h3 id="进位计数制及其相互转换"><a href="#进位计数制及其相互转换" class="headerlink" title="进位计数制及其相互转换"></a>进位计数制及其相互转换</h3><h4 id="r-进制计数法"><a href="#r-进制计数法" class="headerlink" title="r 进制计数法"></a>r 进制计数法</h4><ul><li><strong>基数</strong>：每个数码位所用到的不同符号的个数，r 进制的基数为 r</li><li><strong>位权</strong>：处于第 i 位的权重，值为 r^i^</li><li>每个位上的取值范围：0 ~ r-1</li></ul><h4 id="其他进制-gt-十进制"><a href="#其他进制-gt-十进制" class="headerlink" title="其他进制 -&gt; 十进制"></a>其他进制 -&gt; 十进制</h4><ul><li>r 进制数：K<del>n</del>K<del>n-1</del>……K<del>1</del>K<del>0</del>K<del>-1</del>……K<del>-m</del></li><li>十进制：  K<del>n</del> × r^n^ + K<del>n-1</del> × r^n-1^ + …… + K<del>1</del> × r^1^ + K<del>0</del> × r^0^ + K<del>-1</del> × r^-1^ + …… + K<del>-m</del> × r^m^ </li></ul><table><thead><tr><th>2^12^</th><th>2^11^</th><th>2^10^</th><th>2^9^</th><th>2^8^</th><th>2^7^</th><th>2^6^</th><th>2^5^</th><th>2^4^</th><th>2^3^</th><th>2^2^</th><th>2^1^</th><th>2^0^</th><th>2^-1^</th><th>2^-2^</th><th>2^-3^</th></tr></thead><tbody><tr><td>4096</td><td>2048</td><td>1024</td><td>512</td><td>256</td><td>128</td><td>64</td><td>32</td><td>16</td><td>8</td><td>4</td><td>2</td><td>1</td><td>0.5</td><td>0.25</td><td>0.125</td></tr></tbody></table><h4 id="二、八、十六进制之间相互转换"><a href="#二、八、十六进制之间相互转换" class="headerlink" title="二、八、十六进制之间相互转换"></a>二、八、十六进制之间相互转换</h4><ul><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part2/image-20211003084155324.png" alt="image-20211003084155324"></li><li>各种进制的常见书写方式<ul><li>二进制（Binary）：(1010001010010)<del>2</del>    或    1010001010010B</li><li>八进制：(1652)<del>8</del></li><li>十六进制（hex）：(1652)<del>16</del>    或     1652H    或    0x1652</li><li>十进制（dec）：(1652)<del>10</del>    或    1652D</li></ul></li><li>注意需要补位：整数向前补 0，小数向后补 0。</li></ul><h4 id="十进制-gt-其他进制"><a href="#十进制-gt-其他进制" class="headerlink" title="十进制 -&gt; 其他进制"></a>十进制 -&gt; 其他进制</h4><ul><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part2/image-20211003085557768.png" alt="image-20211003085557768"></li><li>整数部分除法：先除得的余数为低位（靠近0）</li><li>小数部分乘法：先进位的整数为高位（靠近0）</li><li>也可以使用拼凑法：枚举 r 进制数与十进制数的对应表</li><li>有的十进制小数无法使用二进制精确表示，如：0.3</li></ul><h4 id="真值和机器数"><a href="#真值和机器数" class="headerlink" title="真值和机器数"></a>真值和机器数</h4><ul><li><strong>真值</strong>：符合人类习惯的数字</li><li><strong>机器数</strong>：数字实际存到机器里的形式，正负号需要被“数字化”</li></ul><h3 id="BCD码（408大纲已删）"><a href="#BCD码（408大纲已删）" class="headerlink" title="BCD码（408大纲已删）"></a>BCD码（408大纲已删）</h3><ul><li>BCD ：Binary-Coded Decimal，用二进制编码的十进制<ul><li>8421 码（掌握加法）</li><li>余 3 码</li><li>2421 码</li></ul></li><li>针对问题：二进制方便计算机处理、十进制符合人类习惯，但是转换麻烦</li><li>改进方向：快速转换，一一对应</li><li><strong>以 4bit 二进制码表示 0~9</strong>。一共 16 种情况，6 种冗余。</li></ul><h4 id="8421-码"><a href="#8421-码" class="headerlink" title="8421 码"></a>8421 码</h4><ul><li>4 位二进制权值分别为：8 4 2 1</li><li>8421 码是有权码</li><li>8421 码的加法：<strong>先用十进制加法得出结果，再转 8421 码</strong></li><li>8421码中，1010～1111 没有定义</li><li>在机器的视角中，若发现结果<strong>非法定义</strong>（6+7）或<strong>出现进位</strong>（9+9），则需要继续 +6 进行修正。</li></ul><table><thead><tr><th>0</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th><th>7</th><th>8</th><th>9</th></tr></thead><tbody><tr><td>0000</td><td>0001</td><td>0010</td><td>0011</td><td>0100</td><td>0101</td><td>0110</td><td>0111</td><td>1000</td><td>1001</td></tr></tbody></table><h4 id="余-3-码"><a href="#余-3-码" class="headerlink" title="余 3 码"></a>余 3 码</h4><ul><li>余3码：8421码 + (0011)<del>2</del></li><li>余 3 码的每个权位不固定，所以是无权码</li></ul><table><thead><tr><th>0</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th><th>7</th><th>8</th><th>9</th></tr></thead><tbody><tr><td>0011</td><td>0100</td><td>0101</td><td>0110</td><td>0111</td><td>1000</td><td>1001</td><td>1010</td><td>1011</td><td>1100</td></tr></tbody></table><h4 id="2421-码"><a href="#2421-码" class="headerlink" title="2421 码"></a>2421 码</h4><ul><li>4 位二进制权值分别为：2 4 2 1</li><li>0<del>4 首位必须是 0，5</del>9 首位必须是 1</li></ul><table><thead><tr><th>0</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th><th>7</th><th>8</th><th>9</th></tr></thead><tbody><tr><td>0000</td><td>0001</td><td>0010</td><td>0011</td><td>0100</td><td>1011</td><td>1100</td><td>1101</td><td>1110</td><td>1111</td></tr></tbody></table><h3 id="字符与字符串"><a href="#字符与字符串" class="headerlink" title="字符与字符串"></a>字符与字符串</h3><h4 id="ASCII-码"><a href="#ASCII-码" class="headerlink" title="ASCII 码"></a>ASCII 码</h4><ul><li>键盘共 128 个字符，可以用 7 位二进制编码。<ul><li>为了存入计算机，通常在最高位补 0，凑足1B</li></ul></li><li>可印刷字符：32～126，其余为控制（如：127 DEL）、通信（如：6 ACK）字符</li><li>数字 0~9：<strong>48</strong>(0011 0000)～<strong>57</strong>(0011 1001)<ul><li>数字的 ASCII 码的<strong>前四位是 0011，后四位是 8421 码</strong></li></ul></li><li>大写字母 A~Z：<strong>65</strong>(0100 0001)～<strong>90</strong>(0101 1010)<ul><li>大写字母 ASCII 码<strong>前三位都是 010，后五位是 1~26</strong></li></ul></li><li>小写字母 a~z：<strong>97</strong>(0110 0001)～<strong>122</strong>(0111 1010)<ul><li>小写字母 ASCII 码<strong>前三位都是 011，后五位是 1~26</strong></li></ul></li><li>所有数字、大写字母、小写字母的编码都是连续的</li></ul><blockquote><p>求解某字符 ASCII 码时，要充分利用上述规律，避免十进制、二进制转换。</p></blockquote><h4 id="汉字的表示和编码"><a href="#汉字的表示和编码" class="headerlink" title="汉字的表示和编码"></a>汉字的表示和编码</h4><ul><li>GB 2312-100（19100年）：汉字+各种符号共7445个</li><li><strong>区位码：94 个区，每区 94 个位置</strong>。相当于把所有汉字存放在了 94*94 的方阵中，通过两个字节长度来定位汉字</li><li><strong>国标码：区位码 + 20H</strong>。防止信息交换时与“控制/通信字符”冲突</li><li><strong>汉字(机)内码：国标码 + 100H</strong>。保证高位为1，与ASCII码区分</li><li>输入法 -&gt; 国标码 -&gt; 汉字内码 -&gt;  (国标码 -&gt; )汉字字形码（像素方阵）</li></ul><h4 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h4><ul><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part2/image-20211003101235176.png" alt="image-20211003101235176"></li><li><strong>按字节编址：每个地址对应 1B/1字节（存储单元大小为 1B/8b）</strong></li><li>很多语言中，“\0”作为字符串结尾标志</li><li>在所有计算机中，多字节数据都被存放在连续的字节序列中。根据数据中各字节的排列顺序不同，可能有“大端模式”、“小端模式”<ul><li>大端模式：将数据的<strong>最高有效字节存放在低地址单元</strong>中（低位到高位顺序读取）</li><li>小端模式：将数据的<strong>最高有效字节存放在高地址单元</strong>中（遇到多字节数据需要倒着读）</li></ul></li></ul><h3 id="奇偶校验码（计网要考）"><a href="#奇偶校验码（计网要考）" class="headerlink" title="奇偶校验码（计网要考）"></a>奇偶校验码（计网要考）</h3><h4 id="校验原理"><a href="#校验原理" class="headerlink" title="校验原理"></a>校验原理</h4><ul><li>位错误：在 bit 位上发生的突变。0 变 1，1 变 0</li><li><strong>码字</strong>：由若干位代码组成的一个字</li><li><strong>两个码字间的距离</strong>：将两个码字逐位进行对比，<strong>具有不同的位的个数</strong></li><li><strong>码距</strong>：一种编码方案中，合法码字之间的最小距离。<strong>最少变动多少位可以在各合法码字之间转换</strong></li><li>当 d=1 时，无检错能力；当 d=2 时，有检错能力；当 d≥3 时，若设计合理，可能具有检错、纠错能力</li></ul><h4 id="奇偶校验码"><a href="#奇偶校验码" class="headerlink" title="奇偶校验码"></a>奇偶校验码</h4><ul><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part2/image-20211004142023267.png" alt="image-20211004142023267" style="zoom:100%;"></li><li><strong>奇校验码</strong>：在有效信息位之外添加一位校验位，使得整个校验码中“1”的个数为<strong>奇数</strong>。</li><li><strong>偶校验码</strong>：在有效信息位之外添加一位校验位，使得整个校验码中“1”的个数为<strong>偶数</strong>。</li><li>本质：如果出现<strong>奇数次的位错误，则可以检测出错误</strong>；如果出现<strong>偶数次位错误，则检不出错误</strong>。</li><li><strong>偶校验的硬件实现</strong>：取各位的信息依次进行异或（模2加）运算，得到的结果即为偶校验位。<ul><li>进行偶校验且结果为 0 时，则通过校验。</li><li>进行奇校验且结果为 1 时，则通过校验。</li></ul></li><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part2/image-20211004143356036.png" alt="image-20211004143356036" style="zoom:100%;"></li></ul><h3 id="海明校验码（计网要考）"><a href="#海明校验码（计网要考）" class="headerlink" title="海明校验码（计网要考）"></a>海明校验码（计网要考）</h3><h4 id="基本思想"><a href="#基本思想" class="headerlink" title="基本思想"></a>基本思想</h4><ul><li>针对问题：偶校验只能发现<strong>奇数位错误</strong>，且<strong>无法确定出错位置</strong>，想要获得正确信息则必须重新传输信息。</li><li>改进方向：将信息位分组进行偶校验 —&gt; 多个校验位 —&gt; 多个校验位标注出错位置<ul><li>1 个校验位之只能携带 2 种状态信息（对/错）</li><li>多个校验位能携带多种状态信息（对/错，错在哪）</li></ul></li><li>信息位 n 位 + 校验位 k 位 = 共 n+k 位<ul><li>k 位校验位代表最多能表示 2^k^ 种状态</li><li>校验位表示的状态应该要考虑到 n+k 的任何一位都有可能出错</li><li>重要公式：<strong>2^k^ ≥ n + k + 1</strong></li></ul></li><li>本质：分 k 组偶校验</li></ul><h4 id="海明码求解步骤（TODO）"><a href="#海明码求解步骤（TODO）" class="headerlink" title="海明码求解步骤（TODO）"></a>海明码求解步骤（TODO）</h4><p>Eg：信息位为 1010，求解海明码。</p><ol><li><p>确定海明码的位数：</p><ul><li>2^k^ ≥ n + k + 1</li><li>n=4 =&gt; k=3</li></ul></li><li><p>确定校验位的分布：</p><ul><li><p>设信息位 D<del>4</del>D<del>3</del>D<del>2</del>D<del>1</del>（1010），共4位；校验位 P<del>3</del>P<del>2</del>P<del>1</del>，共3位；对应的海明码为 H<del>7</del>H<del>6</del>H<del>5</del>H<del>4</del>H<del>3</del>H<del>2</del>H<del>1</del></p></li><li><p><strong>校验位 P<del>i</del> 放在海明位号为 2^i−1^ 的位置上</strong></p></li><li><p>校验位 P<del>i</del> 与位置序号第 i 位为 1 的信息位归为同一组，进行偶校验</p></li><li><table><thead><tr><th>H<del>7</del></th><th>H<del>6</del></th><th>H<del>5</del></th><th>H<del>4</del></th><th>H<del>3</del></th><th>H<del>2</del></th><th>H<del>1</del></th></tr></thead><tbody><tr><td>D<del>4</del></td><td>D<del>3</del></td><td>D<del>2</del></td><td>P<del>3</del></td><td>D<del>1</del></td><td>P<del>2</del></td><td>P<del>1</del></td></tr><tr><td>1</td><td>0</td><td>1</td><td>0</td><td>0</td><td>1</td><td>0</td></tr></tbody></table></li></ul></li><li><p>求校验位的值：</p><ul><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part2/image-20211004151532962.png" alt="image-20211004151532962" style="zoom:100%;"></li><li>将海明码信息位的下标转二进制矩阵，一列为一组，对应 1 的信息拿出来做偶校验，结果就是海明码校验位的值。</li></ul></li><li><p>纠错：</p><ul><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part2/image-20211004154938467.png" alt="image-20211004154938467" style="zoom:100%;"></li><li>题目的下标顺序不影响做题（TODO）</li></ul></li></ol><h4 id="海明码的检错、纠错能力"><a href="#海明码的检错、纠错能力" class="headerlink" title="海明码的检错、纠错能力"></a>海明码的检错、纠错能力</h4><ul><li>海明码的检错、纠错能力：<ul><li>纠错能力：1位（无法区分到底是 1 位错还是 2 位错）</li><li>检错能力：2位</li></ul></li><li>为了区分是 1 位错误还是 2 位错误，需加上“全校验位”，对整体进行偶校验。</li><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part2/image-20211004155557262.png" alt="image-20211004155557262"></li></ul><h3 id="循环冗余校验码（计网要考）"><a href="#循环冗余校验码（计网要考）" class="headerlink" title="循环冗余校验码（计网要考）"></a>循环冗余校验码（计网要考）</h3><h4 id="基本思想-1"><a href="#基本思想-1" class="headerlink" title="基本思想"></a>基本思想</h4><ul><li>循环冗余校验（Cyclic Redundancy Check，CRC）</li><li>数据发送、接受方<strong>共同约定一个“除数”</strong></li><li>K个信息位+R个校验位 作为“被除数”，<strong>添加校验位以保证除法的余数为 0</strong><ul><li>收到数据后，进行除法检查余数是否为0</li><li>若余数非 0 说明出错，则进行重传或纠错</li></ul></li></ul><h4 id="构造、检错、纠错"><a href="#构造、检错、纠错" class="headerlink" title="构造、检错、纠错"></a>构造、检错、纠错</h4><ul><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part2/image-20211004164514722.png" alt="image-20211004164514722" style="zoom:100%;"></li><li>流程：<ol><li>题目给出生成多项式、信息码</li><li>K = 信息码的长度 = 6，R = 生成多项式最高次幂 = 3 =&gt; 校验码位数 N = K + R = 9</li><li>信息码左移 R 位，低位补 0。利用生成多项式系数进行模2除法，得余数为校验码。</li><li>将接受到的码字用生成多项式进行模2除法，余数为000则代表没有出错，否则不然。</li></ol></li><li>循环冗余校验码的检错、纠错特性：<ul><li>可检测出所有奇数个错误</li><li>可检测出所有双比特的错误</li><li>可检测出所有小于等于校验位长度的连续错误</li><li>对于确定的生成多项式，出错位与余数是相对应的</li><li>当码字长度超出检错码可表示的能力时，出错位与余数的对应关系将进行循环</li><li>K个信息位，R个校验位，若生成多项式选择得当，且 2^R^≥K+R+1，则 CRC 码可纠正1位错</li></ul></li></ul><h2 id="定点数的表示与运算"><a href="#定点数的表示与运算" class="headerlink" title="定点数的表示与运算"></a>定点数的表示与运算</h2><blockquote><ul><li>定点数：小数点的位置固定（定点数也包含小数）<ul><li>常规计数</li><li>Eg：996.007</li></ul></li><li>浮点数：小数点的位置不固定<ul><li>科学计数法</li><li>Eg：9.96007*102</li></ul></li></ul></blockquote><h3 id="定点数的表示"><a href="#定点数的表示" class="headerlink" title="定点数的表示"></a>定点数的表示</h3><h4 id="无符号数的定点表示"><a href="#无符号数的定点表示" class="headerlink" title="无符号数的定点表示"></a>无符号数的定点表示</h4><ul><li>无符号数：<strong>整个机器字长的全部二进制位均为数值位</strong>，没有符号位，相当于数的绝对值。</li><li>通常只有无符号整数，而没有无符号小数（unsigned int/long）</li><li>表示范围：<strong>n 位 bit 的无符号数表示范围为：0 ～ 2n-1</strong><ul><li>Eg：8位二进制数： 2^8^ 种不同的状态，表示 0000 0000 ～ 1111 1111，即 0 ~ 255</li></ul></li></ul><h4 id="有符号数的定点表示"><a href="#有符号数的定点表示" class="headerlink" title="有符号数的定点表示"></a>有符号数的定点表示</h4><ul><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part2/image-20211007120237263.png" alt="image-20211007120237263" style="zoom:100%;"></li><li>可用 <strong>原码、反码、补码</strong> 三种方式来表示定点整数和定点小数。还可用 <strong>移码</strong> 表示定点整数。</li><li>若真值为 x，则用 <strong>[x]原、[x]反、[x]补、[x]移</strong> 分别表示真值所对应的原码、反码、补码、移码</li><li>若机器字长为 n+1 位，则符号位占 1 位，尾数占 n 位</li><li>表示定点整数，默认小数点隐含在尾数后；表示定点小数，默认小数点隐含在符号位后尾数前。</li></ul><h5 id="原码表示定点整数和定点小数"><a href="#原码表示定点整数和定点小数" class="headerlink" title="原码表示定点整数和定点小数"></a>原码表示定点整数和定点小数</h5><ul><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part2/image-20211007121910742.png" alt="image-20211007121910742" style="zoom:100%;"></li><li>未指明机器字长时，整数尾数前端的 0 可略去，小数尾数后端的 0 可略去。</li><li>要注意<strong>第一位是符号位</strong>，切不能当成数值。</li><li>整数原码常用 <strong>逗号</strong> 分割符号位和尾数，小数原码常用 <strong>小数点</strong> 分割符号位和尾数。</li><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part2/image-20211007123125347.png" alt="image-20211007123125347" style="zoom:100%;"></li><li>在整数和小数的原码表示中，<strong>真值 0 有 +0 和 -0 两种形式</strong>，即两种二进制状态对应了同一种真值。<ul><li>因此即使机器字长为 n+1 位，理论上能够表示 2^n+1^ 种情况，但实际上值表示了 <strong>2^n+1^-1</strong> 种。</li></ul></li><li>原码整数表示范围：**-(2^n^-1)≤x≤2^n^-1<strong>；源码小数表示范围：</strong>-(1-2^n^)≤x≤1-2^n^**。</li></ul><h5 id="反码表示定点整数和定点小数"><a href="#反码表示定点整数和定点小数" class="headerlink" title="反码表示定点整数和定点小数"></a>反码表示定点整数和定点小数</h5><ul><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part2/image-20211007124524338.png" alt="image-20211007124524338" style="zoom:100%;"></li><li>反码：<strong>若符号位为0，则反码与原码相同；若符号位为1，则数值位全部取反。</strong></li><li>表示范围和源码相同。</li></ul><blockquote><p>“反码”只是“原码”转变为“补码”的一个中间状态，实际中并没什么卵用——并没有解决“真值 0 有 +0 和 -0 两种形式”这个问题。</p></blockquote><h5 id="补码表示定点整数和定点小数"><a href="#补码表示定点整数和定点小数" class="headerlink" title="补码表示定点整数和定点小数"></a>补码表示定点整数和定点小数</h5><ul><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part2/image-20211007131951644.png" alt="image-20211007131951644" style="zoom:100%;"></li><li>补码：正数的补码=原码；负数的补码=反码末位+1（要考虑进位）</li><li>补码的真值 0 只有一种表示形式：[+0]补= [-0]补= 00000000<ul><li>定点整数<ul><li>[-2^7^]补 = **1,**0000000</li><li>表示范围：−2^n^ ≤ x ≤ 2^n^−1</li></ul></li><li>定点小数<ul><li>[-1]补 = **1.**0000000 </li><li>表示范围：-1 ≤ x ≤ 1-2^-n^</li></ul></li></ul></li><li><strong>由 [x]补 快速求 [-x]补 的方法：符号位、数值位全部取反，末位+1</strong></li></ul><h5 id="移码表示定点整数"><a href="#移码表示定点整数" class="headerlink" title="移码表示定点整数"></a>移码表示定点整数</h5><ul><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part2/image-20211007143059138.png" alt="image-20211007143059138" style="zoom:100%;"></li><li>移码：<strong>补码的基础上将符号位取反</strong>。注意：<strong>移码只能用于表示整数</strong>。</li><li>移码表示的整数很方便对比大小</li><li>在浮点数中将大量是使用源码</li></ul><h3 id="原码补码移码的作用"><a href="#原码补码移码的作用" class="headerlink" title="原码补码移码的作用"></a>原码补码移码的作用</h3><ul><li>无符号数：可以进行直接加减运算。</li><li>原码的加减运算：需要将符号位单独区分，但是这样将增加硬件成本、计算复杂度。<ul><li>因此需要用加法运算来代替减法运算 =&gt; 将减法操作转换成取模运算（例如：-3mod12=9）</li></ul></li><li>补码的本质：为了能够进行直接加运算，将系统设计成了循环。</li><li>反码的本质：将原码的负数部分进行了反转，是补码能够循环的铺垫。</li><li>移码的本质：使用偏置将补码的循环提前了半个周期。</li></ul><table><thead><tr><th>二进制机器数</th><th>二进制表示无符号数</th><th>二进制表示原码</th><th>二进制表示反码</th><th>二进制表示补码</th><th>二进制表示移码</th></tr></thead><tbody><tr><td>0000 0000</td><td><strong>0</strong></td><td><strong>+0</strong></td><td><strong>+0</strong></td><td><strong>±0</strong></td><td>-128</td></tr><tr><td>0000 0001</td><td>1</td><td>1</td><td>1</td><td>1</td><td>-127</td></tr><tr><td>……</td><td>……</td><td>……</td><td>……</td><td>……</td><td>……</td></tr><tr><td>0111 1111</td><td>127</td><td>127</td><td>127</td><td>127</td><td>-1</td></tr><tr><td>1000 0000</td><td>128</td><td><strong>-0</strong></td><td>-127</td><td>-128</td><td><strong>±0</strong></td></tr><tr><td>1000 0001</td><td>129</td><td>-1</td><td>-126</td><td>-127</td><td>1</td></tr><tr><td>……</td><td>……</td><td>……</td><td>……</td><td>……</td><td>……</td></tr><tr><td>1111 1111</td><td>255</td><td>-127</td><td><strong>-0</strong></td><td>-1</td><td>127</td></tr></tbody></table><ul><li>带余除法——设 x, m∈Z, m&gt;0 则存在唯一决定的整数 q 和 r，使得：x = q*m + r , 0 ≤ r &lt; m <ul><li>(mod 12) 把所有整数分为 12 类（余数为 0~11）</li><li>(mod 12) 余数相同的数，都是同一类，都是等价的</li><li>在 (mod m) 的条件下，若能<strong>找到负数的补数</strong>，就可以<strong>用正数的加法来等价替代减法</strong><ul><li>若二个数绝对值之和=模，则称这两个数互为补数</li></ul></li><li><strong>模 - a的绝对值 = a的补数</strong></li><li>↑ 这是补码的原生定义</li></ul></li><li>反码 + 原码 + 1 = 模</li><li>补码的作用： 使用补码可将减法操作转变为等价的加法，ALU 中无需集成减法器。执行加法操作时，符号位一起参与运算。</li></ul><h3 id="移位运算"><a href="#移位运算" class="headerlink" title="移位运算"></a>移位运算</h3><h4 id="算数移位"><a href="#算数移位" class="headerlink" title="算数移位"></a>算数移位</h4><ul><li><p>移位：通过改变各个数码位和小数点的相对位置，从而改变各数码位的位权。可用移位运算实现乘法、除法</p></li><li><p>原码的算数移位——<strong>符号位保持不变，仅对数值位进行移位</strong>。</p><ul><li>右移：高位补0，低位舍弃。若舍弃的位=0，<strong>则相当于÷2</strong>；若舍弃的位≠0，则会丢失<strong>精度</strong></li><li>左移：低位补0，高位舍弃。若舍弃的位=0，<strong>则相当于×2</strong>；若舍弃的位≠0，则会出现<strong>严重误差</strong></li></ul></li><li><p>反码的算数移位</p><ul><li>正数的反码与原码相同，因此对正数反码的移位运算也和原码相同。<ul><li>右移：<strong>高位补0</strong>，低位舍弃。</li><li>左移：<strong>低位补0</strong>，高位舍弃。</li></ul></li><li>负数的反码数值位与原码相反，因此负数反码的移位在补位上有所变化。<ul><li>右移：<strong>高位补1</strong>，低位舍弃。</li><li>左移：<strong>低位补1</strong>，高位舍弃。</li></ul></li></ul></li><li><p>补码的算数移位</p><ul><li>正数的补码与原码相同，因此对正数补码的移位运算也和原码相同。<ul><li>右移：<strong>高位补0</strong>，低位舍弃。</li><li>左移：<strong>低位补0</strong>，高位舍弃。</li></ul></li><li>负数补码=反码末位+1，导致反码最右边几个连续的1都因进位而变为0，直到进位碰到第一个0为止。<ul><li>负数补码中：最右边的1及其右边同原码；最右边的1的左边同反码负数补码。</li><li>右移（同反码）：<strong>高位补1</strong>，低位舍弃。</li><li>左移（同原码）：<strong>低位补0</strong>，高位舍弃。</li></ul></li></ul></li><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part2/image-20211008121454539.png" alt="image-20211008121454539" style="zoom:100%;"></li><li><p>Eg：-20×7 = -20×(2^0^+2^1^+2^2^) = (-20左移0位) + (-20左移1位) + (-20左移2位)</p></li></ul><h4 id="逻辑移位"><a href="#逻辑移位" class="headerlink" title="逻辑移位"></a>逻辑移位</h4><ul><li>逻辑右移：高位补0，低位舍弃。</li><li>逻辑左移：低位补0，高位舍弃。</li><li>可以把逻辑移位看作是对“无符号数”的算数移位</li><li>Eg：<img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part2/image-20211008122429002.png" alt="image-20211008122429002" style="zoom:100%;"></li></ul><h4 id="循环移位"><a href="#循环移位" class="headerlink" title="循环移位"></a>循环移位</h4><ul><li>不带进位位：用<strong>移出的位补上空缺</strong></li><li>带进位位：用<strong>进位位的值补上空缺</strong>，而<strong>移出的位放到进位位</strong></li><li>Eg：交换高低位字节时常用（大端存储&lt;=&gt;小端存储）</li></ul><h3 id="加减运算和溢出判断"><a href="#加减运算和溢出判断" class="headerlink" title="加减运算和溢出判断"></a>加减运算和溢出判断</h3><h4 id="原码的加减法"><a href="#原码的加减法" class="headerlink" title="原码的加减法"></a>原码的加减法</h4><ul><li>要考虑 2*2 种情况，并且同时实现加法器和减法器</li><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part2/image-20211008124354552.png" alt="image-20211008124354552"></li></ul><h4 id="补码的加减法"><a href="#补码的加减法" class="headerlink" title="补码的加减法"></a>补码的加减法</h4><ul><li><p>负数的补码转原码：</p><ul><li>数值位取反，+1</li><li>-1，数值位取反</li><li>负数补码中，最右边的1及其右边同原码，最右边的1的左边同反码</li></ul></li><li><p>[(负数)]补 &lt;=&gt; [(负数)]原：<strong>取负数补码最右边的一位1，其本身与其右侧不变，左侧数值位全部取反</strong>。（常用）</p></li><li><p>[x]补 =&gt; [-x]补：<strong>连同符号位一起取反加1</strong>。</p></li></ul><h4 id="溢出判断"><a href="#溢出判断" class="headerlink" title="溢出判断"></a>溢出判断</h4><ul><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part2/image-20211008151859101.png" alt="image-20211008151859101"></li><li>溢出情况：<ul><li>只有“正数+正数 ”才会上溢 —— 正+正=负</li><li>只有“负数+负数 ”才会下溢 —— 负+负=正</li></ul></li><li>判断方法：<ul><li>法一：采用一位符号位设 A 的符号为 A<del>S</del>，B 的符号为 B<del>S</del>，运算结果的符号为 S<del>S</del>，则溢出逻辑表达式为：<ul><li>$V = A_{s}B_{s}\overline{S_{s}} + \overline{A_{s}}\overline{B_{s}}S_{s}$</li><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part2/image-20211008163931615.png" alt="image-20211008163931615" style="zoom:100%;"></li><li>若 V=0，表示无溢出；若 V=1，表示有溢出。</li><li><strong>A<del>S</del> 为 1 且 B<del>S</del> 为 1 且 S<del>S</del> 为 0</strong> 或 <strong>A<del>S</del> 为 0 且 B<del>S</del> 为 0 且 S<del>S</del> 为 1</strong>。</li></ul></li><li>法二：采用一位符号位，根据数据位进位情况判断溢出符号位的进位 C<del>S</del>，最高数值位的进位 C<del>1</del><ul><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part2/image-20211008163814192.png" alt="image-20211008163814192" style="zoom:100%;"></li><li>$V=C_{S}⊕ C_{1}$</li><li>若 V=0，表示无溢出；若 V=1，表示有溢出。</li><li><strong>最高数值位进位且符号位不进位</strong> 或 <strong>符号位进位而最高数值位不进位</strong>。</li></ul></li><li>法三：<ul><li>采用双符号位：正数符号为 00，负数符号为 11</li><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part2/image-20211008163848872.png" alt="image-20211008163848872" style="zoom:100%;"></li><li>记两个符号位为 S<del>S1</del>S<del>S2</del> ，则 $V=S_{S1}\otimes S_{S2}$。若 V=0，表示无溢出；若 V=1，表示有溢出。</li><li><strong>第一个符号位表明应该得到的符号，第二个符号位表明实际得到的符号。</strong></li><li>双符号位补码又称：模 4 补码；单符号位补码又称：模 2 补码。</li><li>实际存储时只存储一个符号位，运算时会复制一个符号位</li></ul></li></ul></li><li>同+同=异  =&gt;  发生溢出</li></ul><h4 id="符号扩展"><a href="#符号扩展" class="headerlink" title="符号扩展"></a>符号扩展</h4><ul><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part2/image-20211008164330993.png" alt="image-20211008164330993" style="zoom:100%;"></li><li>定点整数的符号扩展：在原符号位和数值位<strong>中间</strong>添加新位，正数都添0；负数<strong>原码添0，反码、补码添1</strong></li><li>定点小数的符号扩展：在原符号位和数值位<strong>后面</strong>添加新位，正数都添0；负数<strong>原码、补码添0，反码添1</strong></li></ul><h3 id="乘法运算"><a href="#乘法运算" class="headerlink" title="乘法运算"></a>乘法运算</h3><h4 id="乘法运算的实现思想"><a href="#乘法运算的实现思想" class="headerlink" title="乘法运算的实现思想"></a>乘法运算的实现思想</h4><ul><li>用移位实现乘数累加</li><li>Eg：0.1101×0.1011 = (1101×1×2^-8^ ) + (1101×1×2^-7^) + (1101×0×2^-6^) + (1101×1×2^-5^)</li></ul><h4 id="原码的一位乘法"><a href="#原码的一位乘法" class="headerlink" title="原码的一位乘法"></a>原码的一位乘法</h4><ul><li><strong>符号单独处理</strong>：符号位 = x<del>s</del>⊕y<del>s</del></li><li><strong>数值位取绝对值进行乘法</strong>计算</li><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part2/image-20211009130101904.png" alt="image-20211009130101904" style="zoom:100%;"></li><li>在机器实现乘法中：<ul><li>ACC 存放<strong>乘积高位</strong>，MQ 存放<strong>乘数与乘积低位</strong>，X 存放<strong>被乘数</strong></li><li>在正式进行乘法之前，<strong>ACC 置零</strong></li><li>先将 X 中被乘数与 MQ 最低位的乘积结果<strong>加到 ACC 中</strong></li><li>再将 ACC、MQ 整体<strong>逻辑右移</strong>一位<ul><li>逻辑右移，高位补零</li><li>ACC 的低位移到 MQ 的高位</li><li>MQ 的低位用完之后直接丢弃</li><li>此时，AC、MQ 中运算得到的位上的结果称作<strong>部分积</strong></li></ul></li><li>数值位一共 n 位，则<strong>循环 n 次</strong><ul><li>乘数的符号位不用参与运算。ACC+MQ 是一个整体，而 MQ 由取绝对值，所以最多只有 4 为有效，原本的符号位不会对结果造成影响。</li><li>小数点隐含位置在 ACC 的第二位</li></ul></li><li><strong>修改 ACC 的符号位</strong>：x<del>s</del>⊕y<del>s</del>=1</li></ul></li><li>之所以称为“一位乘法”是因为每次都使用 MQ 的最后一位进行乘积相加，还有更快的“二位乘法”但不做要求。</li><li>Tips：<ul><li>乘数的符号位不参与运算，可以省略</li><li>原码一位乘可以只用单符号位，也可以用双符号位</li><li>答题时最终结果最好写为原码机器数</li></ul></li></ul><h4 id="补码的一位乘法（Booth算法）"><a href="#补码的一位乘法（Booth算法）" class="headerlink" title="补码的一位乘法（Booth算法）"></a>补码的一位乘法（Booth算法）</h4><ul><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part2/image-20211009134039359.png" alt="image-20211009134039359" style="zoom:100%;"></li><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part2/image-20211009143142389.png" alt="image-20211009143142389" style="zoom:100%;"></li><li>机器实现补码乘法时：<ul><li>MQ 相比原码乘法需要在最低位后面加一位辅助位。同时 CPU 中寄存器大小应当一致，所以<ul><li>ACC、X 使用<strong>双符号位</strong>，MQ 使用<strong>单符号位以及一位辅助位</strong>，部分积也是使用<strong>双符号位</strong></li></ul></li><li>与原码乘法不同，每次加法是：<code>ACC + [(辅助位-MQ最低位)x]补</code></li><li>与原码乘法不同，每次移位是：<strong>补码的算数移位</strong><ul><li>符号位不动，数值位右移，正数右移补0，负数右移补1（符号位是啥就补啥）</li></ul></li><li>加法与移位的循环分别是 n+1 和 n 次，即<strong>乘数的单符号位也会参与计算</strong></li><li>与原码乘法不同，最后的符号确定已在计算过程中完成，无需再次校验。</li></ul></li></ul><h3 id="除法运算"><a href="#除法运算" class="headerlink" title="除法运算"></a>除法运算</h3><h4 id="除法运算的实现思想"><a href="#除法运算的实现思想" class="headerlink" title="除法运算的实现思想"></a>除法运算的实现思想</h4><ul><li>被除数、余数本质相同，是我们还需要去拼凑的数</li><li>商是我们尽可能去接近需要拼凑的数但不能超过</li></ul><h4 id="原码的除法运算"><a href="#原码的除法运算" class="headerlink" title="原码的除法运算"></a>原码的除法运算</h4><h5 id="恢复余数法"><a href="#恢复余数法" class="headerlink" title="恢复余数法"></a>恢复余数法</h5><ul><li>ACC 放被除数和余数，MQ 放商，X 放除数</li><li><strong>符号单独处理</strong>：符号位 = x<del>s</del>⊕y<del>s</del></li><li><strong>数值位取绝对值进行除法</strong>计算</li><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part2/image-20211011153443169.png" alt="image-20211011153443169" style="zoom:100%;"></li><li>在机器实现除法中：<ul><li>在正式进行乘法之前，<strong>MQ 置零</strong></li><li>首先<strong>默认商/MQ最低位为 1</strong>，将除数的相反数的补码与被除数/余数（ ACC ）相加（将 ACC 减去除数）<ul><li>(ACC)+ [−|y|]补 -&gt; ACC</li><li><strong>若相减之后余数符号位为 1</strong>（小于 0），则表明商不应该为 1，而是 0</li><li><strong>则将 ACC 的值再次加上除数</strong>，恢复成原样</li><li>并<strong>将商改成 0</strong></li><li>若最后一步余数是负数，则一样要进行上面的纠正</li></ul></li><li>ACC、MQ 整体逻辑左移<ul><li>MQ 低位补零</li><li>ACC 高位丢弃</li></ul></li><li>机器字长有 n+1 位，就要算 n+1 位的商，左移 n 次</li><li><strong>修改 MQ 的符号位</strong>：x<del>s</del>⊕y<del>s</del>=0</li></ul></li></ul><h5 id="不恢复余数法（加减交替法）"><a href="#不恢复余数法（加减交替法）" class="headerlink" title="不恢复余数法（加减交替法）"></a>不恢复余数法（加减交替法）</h5><ul><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part2/image-20211011155159488.png" alt="image-20211011155159488" style="zoom:100%;"></li><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part2/image-20211011154706460.png" alt="image-20211011154706460" style="zoom:100%;"></li><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part2/image-20211011155635905.png" alt="image-20211011155635905" style="zoom:100%;"></li><li>当余数（ACC）为负时，商 0<ul><li>恢复余数法：+|除数（X）|，再左移，再-|除数（X）|</li><li>加减交替法：左移，再+|除数（X）|</li></ul></li><li>在加减交替法中<ul><li>余数（ACC）的正负性与商相同</li><li>符号位同样需要额外判定</li><li>若最后的余数（ACC）为负，需商0，并+[|y|]补得到正确余数</li></ul></li></ul><h4 id="补码的除法运算（加减交替法）"><a href="#补码的除法运算（加减交替法）" class="headerlink" title="补码的除法运算（加减交替法）"></a>补码的除法运算（加减交替法）</h4><ul><li>符号位参与运算</li><li>被除数/余数、除数采用双符号位</li><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part2/image-20211014133724204.png" alt="image-20211014133724204" style="zoom:100%;"></li><li>第一步，比较<strong>被除数</strong>（ACC）和除数（X）符号<ul><li>同号，则被除数-除数</li><li>异号，则被除数+除数</li></ul></li><li>然后，比较<strong>余数</strong>（ACC）和除数（X）符号（每次循环保证两者相加符号不同，结果与被除）<ul><li>同号，<strong>商1</strong>，余数左移，减去除数</li><li>异号，<strong>商0</strong>，余数左移，加上除数</li></ul></li><li>重复 n 次</li><li>MQ 的最后一位恒置 1（精度误差不超过 2^-n^）</li></ul><h4 id="除法运算总结"><a href="#除法运算总结" class="headerlink" title="除法运算总结"></a>除法运算总结</h4><table><thead><tr><th>除法类型</th><th>符号位参与运算</th><th>加减次数</th><th>移位方向</th><th>移位次数</th><th>上商、加减原则</th><th>说明</th></tr></thead><tbody><tr><td>原码加减交替法</td><td>否</td><td>N+1 或 N+2</td><td>左</td><td>N</td><td>余数的正负</td><td>若最终余数为负，则恢复余数</td></tr><tr><td>补码加减交替法</td><td>是</td><td>N+1</td><td>左</td><td>N</td><td>余数和除数是否同号</td><td>商末位恒置 1</td></tr></tbody></table><h3 id="强制类型转换"><a href="#强制类型转换" class="headerlink" title="强制类型转换"></a>强制类型转换</h3><ul><li>C 语言中定点整数（int、long、short）是用<strong>补码</strong>存储的。</li><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part2/image-20211015192650002.png" alt="image-20211015192650002" style="zoom:100%;"></li></ul><h3 id="数据的存储和排列"><a href="#数据的存储和排列" class="headerlink" title="数据的存储和排列"></a>数据的存储和排列</h3><ul><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part2/image-20211015195134394.png" alt="image-20211015195134394" style="zoom:100%;"></li><li>最高有效字节（<strong>MSB</strong>）最低有效字节（<strong>LSB</strong>）</li><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part2/image-20211015200927531.png" alt="image-20211015200927531"></li><li>现代计算机<strong>通常是按字节编址</strong>，即每个字节对应1个地址<ul><li>通常也支持按字、按半字、按字节寻址</li></ul></li><li>假设存储字长为32位，则1个字=32bit，半字=16bit<ul><li>要将按字寻址转成按字节寻址，则将值左移2位</li></ul></li><li><strong>每次访存只能读/写1个字</strong></li><li>c语言的数据类型长度<ul><li>char：1字节</li><li>short：2字节</li><li>int：4字节</li><li>long：8字节</li></ul></li><li>使用<strong>边界对齐方式</strong>可以<strong>提高读取效率</strong>，而使用<strong>边界不对齐方式</strong>可以<strong>减少存储开销</strong>。</li></ul><h2 id="浮点数的表示与运算"><a href="#浮点数的表示与运算" class="headerlink" title="浮点数的表示与运算"></a>浮点数的表示与运算</h2><h3 id="浮点数的表示"><a href="#浮点数的表示" class="headerlink" title="浮点数的表示"></a>浮点数的表示</h3><h4 id="浮点数的作用和基本原理"><a href="#浮点数的作用和基本原理" class="headerlink" title="浮点数的作用和基本原理"></a>浮点数的作用和基本原理</h4><ul><li>针对问题：定点数可表示的数字范围有限，但我们不能无限制地增加数据的长度</li><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part2/image-20211016153947660.png" alt="image-20211016153947660"></li><li>阶码：常用补码或移码表示的定点整数</li><li>尾数：常用原码或补码表示的定点小数</li><li>浮点数的真值：N=r^E^×M<ul><li>阶码的底 r，通常为 2</li><li>阶码 E 反映浮点数的<strong>表示范围</strong>及小数点的实际位置</li><li>尾数 M 的数值部分的位数 n 反映浮点数的<strong>精度</strong></li><li>尾数给出一个小数，阶码正负与数值指明了尾数左移/右移(小数点向后/向前移动)几位。</li></ul></li></ul><h4 id="浮点数规格化"><a href="#浮点数规格化" class="headerlink" title="浮点数规格化"></a>浮点数规格化</h4><ul><li>规格化浮点数：规定尾数的最高数值位必须是一个有效值 。</li><li>左规：当浮点数运算的结果为非规格化（尾数的最高数值位为 0）时，将尾数算数左移 1 位，阶码减 1。<ul><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part2/image-20211016194214228.png" alt="image-20211016194214228"></li></ul></li><li>右规：当浮点数运算的结果尾数出现溢出（双符号位为01或10）时，将尾数算数右移 1 位，阶码加 1。<ul><li>第一位符号位是正确的符号位</li><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part2/image-20211016194118837.png" alt="image-20211016194118837"></li></ul></li><li>规格化浮点数的特点：<ul><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part2/image-20211016204436786.png" alt="image-20211016204436786"></li><li>规格化的原码尾数，最高数值位一定是 1</li><li>规格化的补码尾数，符号位与最高数值位一定相反</li></ul></li></ul><h4 id="浮点数表示范围（大纲外）"><a href="#浮点数表示范围（大纲外）" class="headerlink" title="浮点数表示范围（大纲外）"></a>浮点数表示范围（大纲外）</h4><ul><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part2/image-20211016204413711.png" alt="image-20211016204413711"></li><li>对于下溢，只需要当做0处理</li><li>对于上溢，必须作为异常</li></ul><h3 id="浮点数标准IEEE75"><a href="#浮点数标准IEEE75" class="headerlink" title="浮点数标准IEEE75"></a>浮点数标准IEEE75</h3><ul><li><p>读音：I triple E——IEEE</p></li><li><p>移码的定义：<strong>移码 = 真值 + 偏置值</strong>（偏置值并不固定）</p><ul><li>在之前所学的移码中：偏置值为 128D=1000 0000B，即 2^n-1^</li><li>在 IEEE75 中，偏置值为 <strong>127D=0111 1111B</strong>，即 <strong>2^n-1^-1</strong></li></ul></li><li><p><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part2/image-20211018121445755.png" alt="image-20211018121445755"></p></li><li></li><li><p>阶码全1、全0时用作特殊用途。因此阶码的正常范围：**-126~127**</p><ul><li>规格化短浮点真值：(-1)^s^×1.M×2^E-127^</li><li>规格化长浮点真值：(-1)^s^×1.M×2^E-1023^</li><li>计算<strong>移码/阶码的真值</strong>时，不用在二进制上面计算，可以<strong>先把看见的移码当做无符号数计算值</strong>，然后<strong>减去偏置值127</strong></li></ul></li></ul><table><thead><tr><th>类型</th><th>数符</th><th>阶码</th><th>尾数</th><th>总位数</th><th>偏置值（十六进制）</th><th>偏置值（十进制）</th></tr></thead><tbody><tr><td>短浮点数(float)</td><td>1</td><td>8</td><td>23</td><td>32</td><td>7FH</td><td>127</td></tr><tr><td>长浮点数(double)</td><td>1</td><td>11</td><td>52</td><td>64</td><td>3FFH</td><td>1023</td></tr><tr><td>临时浮点数(long double)</td><td>1</td><td>15</td><td>64</td><td>80</td><td>3FFFH</td><td>16383</td></tr></tbody></table><ul><li><p><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part2/image-20211018115935229.png" alt="image-20211018115935229"></p></li><li><p>IEEE 754 单精度浮点型能表示的最小绝对值、最大绝对值</p><ul><li>最小绝对值：尾数全为0，阶码真值最小-126，对应移码机器数 0000 0001。此时整体的真值为 (1.0)<del>2</del>×2^-126^</li><li>最大绝对值：尾数全为1，阶码真值最大 127，对应移码机器数 1111 1110。此时整体的真值为 (1.111…11)<del>2</del>×2^127^</li></ul></li></ul><table><thead><tr><th>格式</th><th>格式化的最小绝对值</th><th>格式化的最大绝对值</th></tr></thead><tbody><tr><td>单精度</td><td>E=1，M=0：1.0×2^1−127^=2^-126^</td><td>E=254，M=.11…1：1.11…1×2^254−127^=2^127^×(2−2^−23^)</td></tr><tr><td>双精度</td><td>E=1，M=0：1.0×2^1−1023^=2^-1022^</td><td>E=254，M=.11…1：1.11…1×2^2046−1023^=2^1023^×(2−2^−52^)</td></tr></tbody></table><ul><li><strong>只有 1≤E≤254时，真值 = (−1)^s^×1.M×2^E−127^</strong></li><li>当阶码E全为0<ul><li>尾数M不全为0时，表示非规格化小数 ±(0.xx…x)<del>2</del>×2^-126^<ul><li>隐含最高位变为 0</li><li>阶码真值固定视为 -126</li></ul></li><li>尾数M全为0时，表示真值 ±0</li></ul></li><li>当阶码E全为1<ul><li>尾数M不全为0时，表示非数值 “NaN” (Not a Number)<ul><li>如：0/0、∞-∞ 等非法运算的结果就是 NaN</li></ul></li><li>尾数M全为0时，表示无穷大 ±∞</li></ul></li></ul><blockquote><p>由浮点数确定真值（阶码不是全0、也不是全1）：</p><ol><li>根据“某浮点数”确定数符、阶码、尾数的分布</li><li>确定尾数 1.M（注意补充最高的隐含位1）</li><li>确定阶码的真值 = 移码 - 偏置值 （可将移码看作无符号数，用无符号数的值减去偏置值）</li><li>(−1)^s^×1.M×2^E−偏置值^</li></ol></blockquote><h3 id="浮点数的运算"><a href="#浮点数的运算" class="headerlink" title="浮点数的运算"></a>浮点数的运算</h3><h4 id="浮点数的加减运算"><a href="#浮点数的加减运算" class="headerlink" title="浮点数的加减运算"></a>浮点数的加减运算</h4><ul><li>浮点数加减运算步骤<ul><li>转换格式（真值D-&gt;机器数B；注意审题：用补/移码表示阶码和尾数）</li><li>对阶（使两个数的阶码相等，小阶向大阶看齐，尾数毎右移一位，阶码加1）</li><li>尾数加减</li><li>规格化</li><li>舍入（可以有不同的舍入规则）<ul><li>0舍1入：移去为0则舍，为1则入（可能会使尾数又溢出，此时需再做一次右规。）</li><li>恒置1：无论移去0还是1，都使右移后的尾数末位置1（这种方法同样有使尾数变大和变小的两种可能。）</li></ul></li><li>判溢出（尾数溢出未必导致整体溢出，只有阶数溢出才是真正的溢出）</li></ul></li><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part2/image-20211018135039513.png" alt="image-20211018135039513"></li></ul><h4 id="强制类型转换-1"><a href="#强制类型转换-1" class="headerlink" title="强制类型转换"></a>强制类型转换</h4><table><thead><tr><th>类型</th><th>16位机器</th><th>32位机器</th><th>64位机器</th></tr></thead><tbody><tr><td>char</td><td>8</td><td>8</td><td>8</td></tr><tr><td>short</td><td>16</td><td>16</td><td>16</td></tr><tr><td>int</td><td>16</td><td>32</td><td>32</td></tr><tr><td>long</td><td>32</td><td>32</td><td>64</td></tr><tr><td>long long</td><td>64</td><td>64</td><td>64</td></tr><tr><td>float</td><td>16</td><td>32（23+1）</td><td>32</td></tr><tr><td>double</td><td>64</td><td>64（52+1）</td><td>64</td></tr></tbody></table><ul><li>没有特殊说明，则默认 32 位机器</li><li>无损转换：char -&gt; int -&gt; long -&gt; double；float -&gt; double。<ul><li>在 32 位中，这些转换过程没有损失</li><li>在 64 位中，long -&gt; double 会出现精度损失</li></ul></li><li>有损转换：int -&gt; float；float -&gt; int<ul><li>判断是否会有精度损失，要从有效数字方面考虑</li><li>int：表示整数，范围 -2^31^ ～ 2^31^-1 ，有效数字 <strong>32</strong> 位</li><li>float：表示整数及小数，范围 ±[2^-126^ ～ 2^127^×(2−2^−23^)]，有效数字 <strong>23+1=24</strong> 位</li><li>int -&gt; float：可能损失精度（如 2^24^~2^31^-1 中无法被 float 表示的）</li><li>float -&gt; int：可能溢出（范围过大）及损失精度（表示小数）</li></ul></li></ul><h2 id="算术逻辑单元（ALU）"><a href="#算术逻辑单元（ALU）" class="headerlink" title="算术逻辑单元（ALU）"></a>算术逻辑单元（ALU）</h2><h3 id="电路的基本原理、加法器设计"><a href="#电路的基本原理、加法器设计" class="headerlink" title="电路的基本原理、加法器设计"></a>电路的基本原理、加法器设计</h3><h4 id="作用与原理"><a href="#作用与原理" class="headerlink" title="作用与原理"></a>作用与原理</h4><ul><li>机器字长是 CPU（ALU）一次能够处理的长度，一般等于寄存器的长度。因为输入输出数据存放的寄存器也要和 CPU 处理长度一致。</li><li>ALU 的功能。由控制单元 CU 发出的控制信号决定<ul><li>算术运算：加、减、乘、除等</li><li>逻辑运算：与、或、非、异或等</li><li>辅助功能：移位、求补等</li></ul></li></ul><h4 id="电路基础知识"><a href="#电路基础知识" class="headerlink" title="电路基础知识"></a>电路基础知识</h4><p><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part2/image-20211018152119179.png" alt="image-20211018152119179"></p><h4 id="加法器的实现"><a href="#加法器的实现" class="headerlink" title="加法器的实现"></a>加法器的实现</h4><h5 id="一位全加器"><a href="#一位全加器" class="headerlink" title="一位全加器"></a>一位全加器</h5><p><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part2/image-20211018153352014.png" alt="image-20211018153352014">、</p><h5 id="串行加法器"><a href="#串行加法器" class="headerlink" title="串行加法器"></a>串行加法器</h5><p><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part2/image-20211018153857365.png" alt="image-20211018153857365"></p><ul><li>串行加法器：只有一个全加器，数据逐位串行送入加法器中进行运算。<ul><li>进位触发器用来寄存进位信号，以便参与下一次运算。</li></ul></li><li>如果操作数长 n 位，加法就要分 n 次进行，每次产生一位和，并且串行逐位地送回寄存器。</li></ul><h5 id="并行加法器"><a href="#并行加法器" class="headerlink" title="并行加法器"></a>并行加法器</h5><p><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part2/image-20211018153931233.png" alt="image-20211018153931233"></p><ul><li>串行进位的并行加法器：把 n 个全加器串接起来，就可进行两个 n 位数的相加。</li><li>串行进位又称为行波进位，每一级进位直接依赖于前一级的进位，即进位信号是逐级形成的。</li><li>其性能很大程度依赖于 <strong>FA 产生进位</strong>和<strong>传递进位</strong>的速度</li></ul><h3 id="加法器、ALU的改进"><a href="#加法器、ALU的改进" class="headerlink" title="加法器、ALU的改进"></a>加法器、ALU的改进</h3><ul><li>第 i 位向更高位的进位 C<del>i</del> 可根据 <strong>被加数、加数的第 1~i 位</strong>、<strong>C<del>0</del></strong> 即可确定</li><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part2/image-20211018171510387.png" alt="image-20211018171510387"></li><li>并行进位的<strong>并行加法器</strong>：各级进位信号同时形成，又称为<strong>先行进位</strong>、<strong>同时进位</strong></li><li>为了避免电路过于复杂，设计为 4 个 FA 为一组，组成一个 CLA</li><li>G<del>i</del>：进位产生函数。（由本位确定的是否进位）</li><li>P<del>i</del>：进位传递函数。（本位会控制/屏蔽前一位的进位信息）</li><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part2/image-20211018172125934.png" alt="image-20211018172125934"></li><li>完成组内并行之后，各组之间依然是串行的结构<ul><li><strong>单级先行进位方式</strong>，又称为<strong>组内并行、组间串行</strong>进位方式。</li></ul></li><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part2/image-20211018172358547.png" alt="image-20211018172358547"></li><li>通过 CLA 电路，同时产生各组之间的进位信息<ul><li><strong>多级先行进位</strong>方式，又称为<strong>组内并行、组间并行</strong>进位方式</li></ul></li><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part2/image-20211018173324132.png" alt="image-20211018173324132"></li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机组成原理 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>计算机组成原理-Part1</title>
      <link href="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part1/"/>
      <url>/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part1/</url>
      
        <content type="html"><![CDATA[<h1 id="计算机组成原理-Part1——计算机系统概述"><a href="#计算机组成原理-Part1——计算机系统概述" class="headerlink" title="计算机组成原理-Part1——计算机系统概述"></a>计算机组成原理-Part1——计算机系统概述</h1><p>[TOC]</p><h2 id="开篇"><a href="#开篇" class="headerlink" title="开篇"></a>开篇</h2><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part1/image-20211002105534456.png" alt="image-20211002105534456" style="zoom:80%;"><ul><li><p>CPU、内存、硬盘上都有针脚。这些针脚就是用来接收高低电平的电信号的。</p></li><li><p>传递电信号就需要电脑主板上的印刷电路，这是可以导电的。</p></li><li><p>计算机体系结构 vs 计算机组成原理</p><ul><li><p>计算机体系结构：机器语言程序员所见到的计算机系统的属性概念性的结构与功能特性（指令系统、数据类型、寻址技术、I/O机理）</p><p>如何设计硬件与软件之间的接口。如：有无乘法指令</p></li><li><p>计算机组成原理：实现计算机体系结构所体现的属性，对程序员“透明”（具体指令的实现）</p><p>如何用硬件实现所定义的接口。如：如何实现乘法指令</p></li></ul></li></ul><h2 id="计算机发展历程（408大纲已删）"><a href="#计算机发展历程（408大纲已删）" class="headerlink" title="计算机发展历程（408大纲已删）"></a>计算机发展历程（408大纲已删）</h2><ul><li><p>计算机系统</p><ul><li><p>软件</p><ul><li><p>系统软件：用来管理整个计算机系统。</p><p>例如：操作系统、数据库管理系统(DBMS)、标准程序库(编程使用库)、网络软件(实现网络协议的模块)、语言处理程序(将高级语言转换成低级语言)、服务程序(调试程序)等。</p></li><li><p>应用软件：按任务需要编织成的各种程序。</p></li></ul></li><li><p>硬件</p></li></ul><p>计算机性能的好坏取决于“软”、“硬”件功能的总和。</p></li><li><p>硬件发展历程</p></li></ul><table><thead><tr><th>发展阶段</th><th>时间</th><th>逻辑元件</th><th>速度(次/秒)</th><th>内存</th><th>外存</th></tr></thead><tbody><tr><td>第一代</td><td>1946-1957</td><td><strong>电子管</strong></td><td>几千-几万</td><td>汞延迟线、磁鼓</td><td>穿孔卡片、纸带</td></tr><tr><td>第二代</td><td>1958-1964</td><td><strong>晶体管</strong></td><td>几万-几十万</td><td>磁芯存储器</td><td>磁带</td></tr><tr><td>第三代</td><td>1964-1971</td><td>中小规模<strong>集成电路</strong></td><td>几十万-几百万</td><td>半导体存储器</td><td>磁带、磁盘</td></tr><tr><td>第四代</td><td>1972-现在</td><td>大规模、超大规模集成电路</td><td>上千万-万亿</td><td>半导体存储器</td><td>磁盘、磁带、光盘、半导体存储器</td></tr></tbody></table><ul><li>发展趋势<ul><li>更微型、多用途</li><li>更巨型、超高速</li></ul></li></ul><h2 id="计算机系统层次结构"><a href="#计算机系统层次结构" class="headerlink" title="计算机系统层次结构"></a>计算机系统层次结构</h2><h3 id="计算机硬件的基本组成"><a href="#计算机硬件的基本组成" class="headerlink" title="计算机硬件的基本组成"></a>计算机硬件的基本组成</h3><h4 id="早期冯诺依曼结构"><a href="#早期冯诺依曼结构" class="headerlink" title="早期冯诺依曼结构"></a>早期冯诺依曼结构</h4><ul><li><strong>存储程序</strong>：将指令以二进制代码的形式事先输入计算机的主存储器，从首地址开始顺序执行指令至结束。<ul><li>针对问题：虽然早期冯诺依曼机的计算速度很快，但是 ENIAC 需要手动接线来控制计算，因此速度并不理想。</li></ul></li><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part1/image-20211002184657874.png" alt="image-20211002184657874" style="zoom:80%;"></li><li>在计算机系统中，软件和硬件在逻辑上是等效的。</li><li>冯·诺依曼计算机的特点：<ul><li><strong>计算机由五大部件组成：输入设备、输出设备、主存储器、运算器、控制器</strong></li><li>指令和数据以<strong>同等地位</strong>存于存储器，可<strong>按地址寻访</strong></li><li>指令和数据用二进制表示</li><li><strong>指令由操作码和地址码组成</strong></li><li>存储程序被首次提出</li><li><strong>以运算器为中心</strong>（输入/输出设备与存储器之间的数据传送通过运算器完成）</li></ul></li></ul><h4 id="现代计算机结构"><a href="#现代计算机结构" class="headerlink" title="现代计算机结构"></a>现代计算机结构</h4><ul><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part1/image-20211002185341049.png" alt="image-20211002185341049" style="zoom: 80%;"></li><li>现代计算机：<strong>以存储器为中心</strong></li><li><strong>CPU=运算器+控制器</strong></li><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part1/image-20211002185424956.png" alt="image-20211002185424956" style="zoom: 80%;"></li><li>计组中的主机只包括：<strong>CPU 和主存</strong>。硬盘等不属于主机。</li></ul><h3 id="认识各个硬件部件"><a href="#认识各个硬件部件" class="headerlink" title="认识各个硬件部件"></a>认识各个硬件部件</h3><h4 id="主存储器"><a href="#主存储器" class="headerlink" title="主存储器"></a>主存储器</h4><ul><li>MAR（Memory Address Register）：<strong>存储地址寄存器</strong>，专门存放单次操作的数据地址</li><li>MDR（Memory Data Register）：<strong>存储数据寄存器</strong>，专门存放单次操作的数据内容</li><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part1/image-20211002191934325.png" alt="image-20211002191934325" style="zoom:80%;"></li><li>存储单元：每个存储单元用来存放一串二进制代码。每个存储单元对应一个地址信息（即 MAR 中应当指明的信息）</li><li>存储字(<strong>word</strong>)：每个存储单元中的一串二进制代码，就是一个存储字</li><li>存储字长：存储单元/每个存储字中，包含的二进制代码的位数。*<em>长度一般为：k * 8 bit*</em></li><li>存储元：即存储二进制的电子元件（电容），每个存储元可存 1bit</li><li><strong>数据在存储体内按地址存储</strong></li><li><strong>MAR 位数反映存储单元的个数</strong>：MAR=4位 -&gt; 总共有 24 个存储单元</li><li><strong>MDR 位数 = 存储字长</strong>：MDR = 16位 -&gt; 每个存储单元可存放 16bit，1个字(word) = 16bit</li><li>易混淆：<ul><li><strong>1个字节（Byte）= 8bit</strong></li><li>1B = 1个字节，1b = 1个bit</li><li><strong>字(word)的长度由机器本身决定</strong></li></ul></li></ul><h4 id="运算器"><a href="#运算器" class="headerlink" title="运算器"></a>运算器</h4><ul><li>运算器：用于实现算术运算（如：加减乘除）、逻辑运算（如：与或非）</li><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part1/image-20211002193854953.png" alt="image-20211002193854953" style="zoom:80%;"></li><li>ACC：累加器，用于存放操作数，或运算结果</li><li>MQ：乘商寄存器，在乘、除运算时，用于存放操作数或运算结果</li><li>X：通用的操作数寄存器/通用寄存器，用于存放操作数。通常有多个，不过只需要一个就可以完成大部分运算</li><li>ALU：（※核心元件）算术逻辑单元，通过内部复杂的电路实现算数运算、逻辑运算</li></ul><h4 id="控制器"><a href="#控制器" class="headerlink" title="控制器"></a>控制器</h4><ul><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part1/image-20211002194312723.png" alt="image-20211002194312723" style="zoom:80%;"></li><li>CU（Control Unit）：（※核心元件）控制单元，分析指令，给出控制信号</li><li>IR（Instruction Register）：指令寄存器，存放<strong>当前执行的指令</strong></li><li>PC（Program Counter）：程序计数器，存放<strong>下一条指令地址</strong>，有自动加1功能</li></ul><h4 id="计算机工作流程"><a href="#计算机工作流程" class="headerlink" title="计算机工作流程"></a>计算机工作流程</h4><ul><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part1/image-20211002200948818.png" alt="image-20211002200948818" style="zoom:80%;"></li><li>工作过程：<ul><li>初始状态：指令、数据存入主存，PC 指向第一条指令</li><li>PC -&gt; MAR -&gt; 从存储体中取指令放入 MDR -&gt; 由于处于取指令周期，将指令数据放入 IR -&gt; 由 CU 分析指令（前半段二进制码） -&gt; 变量地址（后半段二进制）放入 MAR -&gt; 从存储体中取指令放入 MDR -&gt; 由于执行指令周期，将变量数据放入运算器寄存器中 -&gt; 执行运算并将结果放入 ACC -&gt; …… </li></ul></li><li>注：现在的计算机通常把 MAR、MDR 也集成在 CPU 内</li></ul><h3 id="计算机系统的多级层次结构"><a href="#计算机系统的多级层次结构" class="headerlink" title="计算机系统的多级层次结构"></a>计算机系统的多级层次结构</h3><h4 id="五层机器结构"><a href="#五层机器结构" class="headerlink" title="五层机器结构"></a>五层机器结构</h4><ul><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part1/image-20211003001409155.png" alt="image-20211003001409155" style="zoom:80%;"></li><li>下层是上层的基础，上层是下层的扩展<ul><li>高级语言机器</li><li>汇编语言机器</li><li>操作系统机器</li><li>传统机器</li><li>微程序机器</li></ul></li></ul><h4 id="三个级别语言"><a href="#三个级别语言" class="headerlink" title="三个级别语言"></a>三个级别语言</h4><ul><li><img src="/2021/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-Part1/image-20211003002429374.png" alt="image-20211003002429374" style="zoom:80%;"></li><li>编译、汇编、解释程序，可统称“翻译程序”<ul><li>编译程序：将高级语言的源程序<strong>一次性</strong>翻译成汇编语言，或者直接翻译为机器语言的执行程序（只需翻译一次）</li><li>解释程序：将高级语言的源程序<strong>逐语句</strong>翻译成机器语言，并立即执行。（每次执行都要翻译）</li><li>汇编程序：将汇编语言翻译成机器语言。</li></ul></li></ul><h2 id="计算机的性能指标"><a href="#计算机的性能指标" class="headerlink" title="计算机的性能指标"></a>计算机的性能指标</h2><h3 id="存储器"><a href="#存储器" class="headerlink" title="存储器"></a>存储器</h3><ul><li><strong>MAR位数</strong>反映<strong>存储单元的个数</strong>（最多支持多少个）</li><li><strong>MDR位数</strong>=存储字长=<strong>每个存储单元的大小</strong></li><li><strong>总容量 = 存储单元个数×存储字长 bit = 存储单元个数×存储字长/8 Byte</strong> (1Byte=8bit)<ul><li>Eg：MAR为 32 位，MDR 为 8 位；总容量 = 2^32^ * 8 bit = 4 GB</li></ul></li></ul><blockquote><p>注：此处描述文件、容量大小等所用的 K、M、G、T </p><p>2^10^B：KB        2^20^B：MB        2^30^B：GB        2^40^B：TB</p></blockquote><h3 id="CPU"><a href="#CPU" class="headerlink" title="CPU"></a>CPU</h3><ul><li><strong>CPU 主频</strong>（时钟频率）：CPU内数字脉冲信号振荡的频率。<ul><li>1s 内进行的数字脉冲信号次数</li><li>CPU主频 = 1/CPU时钟周期</li><li>单位：赫兹，Hz</li></ul></li><li><strong>CPU 时钟周期</strong>：一次脉冲信号的周期。<ul><li>单位：微秒、纳秒</li></ul></li><li><strong>CPI</strong>（Clock cycle Per Instruction）：执行一条指令所需的时钟周期数<ul><li>不同的指令，CPI 有可能不同</li><li>相同的指令，根据不同 CPU 的实现方式不同、当前内存负载不同等等一系列状态，CPI 也可能不同</li><li>可以影响 CPI 的因素太多，一般只讨论平均 CPI</li></ul></li><li><strong>执行一条指令的耗时</strong> = CPI × CPU时钟周期</li><li><strong>CPU 执行时间</strong>（整个程序的耗时）= CPU时钟周期数 / 主频 =（指令条数 * CPI）/ 主频</li><li><strong>IPS</strong>（ Instructions Per Second ）：每秒执行多少条指令<ul><li>IPS =  主频 / 平均CPI</li><li>度量指标时经常使用 KIPS、MIPS</li></ul></li><li><strong>FLOPS</strong>（Floating-point Operations Per Second）：每秒执行多少次浮点运算<ul><li>度量指标时经常使用 KFLOPS、MFLOPS、GFLOPS、TFLOPS、PFLOPS、EFLOPS、ZFLOPS</li></ul></li></ul><blockquote><p>注：此处频率、速率常用的 K、M、G、T 为数量单位</p><p>K=Kilo=千=10^3^，M=Million=百万=10^6^，G=Giga=十亿=10^9^ ，T=Tera=万亿= 10^12^，P=10^3^T，E=10^3^P，Z=10^3^E</p></blockquote><h3 id="系统整体"><a href="#系统整体" class="headerlink" title="系统整体"></a>系统整体</h3><ul><li><p>数据通路带宽：数据总线一次所能并行传送信息的位数（各硬件部件通过数据总线传输数据）</p><ul><li>CPU &lt;=&gt; 主存储器 &lt;=&gt; I/O 设备。这之间的数据传输都需要依靠数据总线传输。</li></ul></li><li><p>吞吐量：指系统在单位时间内处理请求的数量。</p><ul><li>取决于信息能多快地输入内存，CPU能多快地取指令，数据能多快地从内存取出或存入，以及所得结果能多快地从内存送给一台外部设备。</li><li>这些步骤中的每一步都关系到主存，因此，系统吞吐量主要取决于主存的存取周期。</li></ul></li><li><p>响应时间：指从用户向计算机发送一个请求，到系统对该请求做出响应并获得它所需要的结果的等待时间。</p><ul><li>通常包括CPU时间（运行一个程序所花费的时间）与等待时间（用于磁盘访问、存储器访问、I/O操作、操作系统开销等时间）。</li></ul></li><li><p>基准程序：是用来测量计算机处理速度的一种实用程序，以便于被测量的计算机性能可以与运行相同程序的其它计算机性能进行比较。</p></li><li><p>思考：</p><ul><li>Q：主频高的 CPU 一定比主频低的CPU快吗？</li><li>A：不一定，如两个 CPU，A 的主频为 2GHz，平均 CPI=10；B 的主频 1GHz，平均 CPI=1…</li><li>Q：若 A、B 两个 CPU 的平均 CPI 相同，那么 A 一定更快吗？</li><li>A：也不一定，还要看指令系统。如：A 不支持乘法指令，只能用多次加法实现乘法；而 B 支持乘法指令。</li><li>Q：基准程序执行得越快说明机器性能越好吗？</li><li>A：基准程序中的语句存在频度差异，运行结果也不能完全说明问题，要看硬件具体的运用场景</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机组成原理 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>推荐系统-完结目录</title>
      <link href="/2021/09/%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F-%E5%AE%8C%E7%BB%93%E7%9B%AE%E5%BD%95/"/>
      <url>/2021/09/%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F-%E5%AE%8C%E7%BB%93%E7%9B%AE%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<h1 id="推荐系统——完结目录"><a href="#推荐系统——完结目录" class="headerlink" title="推荐系统——完结目录"></a>推荐系统——完结目录</h1><p>教程传送门：</p><ul><li><p>老弓的学习日记：<a href="https://space.bilibili.com/34230158/search/video?keyword=%E6%8E%A8%E8%8D%90">https://space.bilibili.com/34230158/search/video?keyword=%E6%8E%A8%E8%8D%90</a></p></li><li><p>CSDN博文：<a href="https://blog.csdn.net/wuzhongqiang/article/details/107891787">https://blog.csdn.net/wuzhongqiang/article/details/107891787</a></p></li><li><p>王喆 – 《深度学习推荐系统》 </p></li><li><p><a href="https://github.com/RUCAIBox/RecBole">https://github.com/RUCAIBox/RecBole</a></p></li></ul><p>RecBole 项目救命，快速复现，我愿称之为神。</p><table><thead><tr><th align="center"><a href="/2021/09/%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F-Part1/">推荐系统-Part1——概述</a></th></tr></thead><tbody><tr><td align="center"><strong><a href="/2021/09/%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F-Part2/">推荐系统-Part2——传统推荐模型</a></strong></td></tr><tr><td align="center"><strong><a href="/2021/09/%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F-Part3/">推荐系统-Part3——深度学习推荐模型</a></strong></td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 推荐系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>推荐系统-Part3</title>
      <link href="/2021/09/%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F-Part3/"/>
      <url>/2021/09/%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F-Part3/</url>
      
        <content type="html"><![CDATA[<h1 id="推荐系统-Part3——深度学习推荐模型"><a href="#推荐系统-Part3——深度学习推荐模型" class="headerlink" title="推荐系统-Part3——深度学习推荐模型"></a>推荐系统-Part3——深度学习推荐模型</h1><p>[TOC]</p><h2 id="AutoRec-模型"><a href="#AutoRec-模型" class="headerlink" title="AutoRec 模型"></a>AutoRec 模型</h2><ul><li>AutoRec 是将自编码器的思想和协同过滤结合起来的一种单隐层的神经网络推荐模型。</li><li>基本原理：利用协同过滤中的共现矩阵，完成物品向量或者用户向量的自编码，再利用自编码的结果得到用户对物品的预估评分。</li><li><img src="/2021/09/%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F-Part3/image-20210927202124750.png" alt="image-20210927202124750"></li><li>AutoRec 模型由于结构比较简单，表达能力不足，并且往往共现矩阵非常稀疏，更加加大了模型的预测难度。</li><li>所以，AutoRec 只是将深度学习思想应用于推荐系统的初步尝试，没有真正的投入到实践。</li></ul><h2 id="DeepCrossing-模型"><a href="#DeepCrossing-模型" class="headerlink" title="DeepCrossing 模型"></a>DeepCrossing 模型</h2><h3 id="基本思路"><a href="#基本思路" class="headerlink" title="基本思路"></a>基本思路</h3><p>输入一般会有类别型特征(如广告id)和数值型特征(如广告预算)两种情况。对于类别型特征，我们需要进行one-hot编码处理，而数值型特征，一般需要进行归一化处理，这样算是把数据进行了一个简单清洗。DeepCrossing 模型就是利用这些特征向量进行CRT预估。</p><p>为了完成端到端的训练，DeepCrossing 要在内部网络结构中解决如下问题：</p><ol><li>离散类特征编码后过于稀疏，不利于直接输入神经网络训练，需要解决稀疏特征向量稠密化的问题</li><li>如何解决特征自动交叉组合的问题</li><li>如何在输出层中达成问题设定的优化目标</li></ol><h3 id="网络结构"><a href="#网络结构" class="headerlink" title="网络结构"></a>网络结构</h3><ul><li>DeepCrossing 都是常规的结构，但具有革命意义，因为没有任何人工特征工程的参与。</li><li>相比于 FM、FFM 只具备二阶特征交叉能力的模型，DeepCrossing 可以通过调整神经网络的深度进行特征之间的深度交叉，这也是 Deep Crossing 名称的由来。</li></ul><p><img src="/2021/09/%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F-Part3/image-20210927223004876.png" alt="image-20210927223004876"></p><ol><li>Embedding 层：<ul><li>Embedding 的目的是将高维稀疏特征转化为低维稠密特征。</li><li>Feature#1 表示one-hot编码后非常稀疏的类别特征；Feature#2是数值型特征，不需要 embedding，直接进入 Stacking 层。</li><li>以字典形式存储每个类别特征域对应的 Embedding 矩阵，可以将 LabelEncoder 编码转化成一个数值型的特征向量。</li><li>每个类别特征域对应的 Embedding 矩阵的具体参数需要通过训练获得。</li></ul></li><li>Stacking 层：把不同的Embedding特征和数值型特征拼接在一起，形成新的包含全部特征的特征向量，该层通常也称为连接层</li><li>Multiple Residual Units 层：采用了多层残差网络的多层感知机。这样对特征向量各个维度进行充分的交叉组合，使得模型能够抓取更多的非线性特征和组合特征信息。</li><li>Scoring 层：输出层。对于 CTR 预估二分类问题，采用逻辑回归；对于多分类，采用 Softmax 模型。</li></ol><h2 id="NeuralCF-模型"><a href="#NeuralCF-模型" class="headerlink" title="NeuralCF 模型"></a>NeuralCF 模型</h2><h3 id="推荐算法中的两个根本性思路"><a href="#推荐算法中的两个根本性思路" class="headerlink" title="推荐算法中的两个根本性思路"></a>推荐算法中的两个根本性思路</h3><ul><li><p>用户和物品的表征：即如何更好地把用户特征和物品特征信息表示出来。隐语义模型(MF)，使用了 embedding 的思路去表示用户和物品，从而用向量的乘积表示用户对物品的喜好程度。</p></li><li><p>特征交叉：即考虑特征之间的交互信息以丰富数据的表达能力。因子分解机(FM)系列，就将特征两两交叉。</p></li></ul><p><img src="/2021/09/%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F-Part3/image-20210928101611434.png" alt="image-20210928101611434"></p><h3 id="存在问题"><a href="#存在问题" class="headerlink" title="存在问题"></a>存在问题</h3><ol><li>矩阵分解算法：试图在协同过滤共现矩阵的基础上，使用更稠密的隐向量表示用户和物品，挖掘用户和物品的隐含兴趣和隐含特征，在一定程度上弥补了协同过滤模型处理稀疏矩阵能力不足的问题。</li><li>隐向量的学习过程，在深度学习中就可以看成是一个简单的神经网络表示；用户向量和物品向量可以看成 embedding 方法。而最终的评分值(预测值)，就是用户向量和物品向量内积后的相似度。</li><li>而问题就在相似度计算上：相似度计算一般采用余弦相似度。其中必然包含两个向量做<strong>内积</strong>的过程，用向量之间的夹角大小来衡量相似度。</li><li>按理说相似用户，其隐向量也应该相似。但是研究表明单靠夹角衡量相似度不一定可靠。</li></ol><blockquote><p>这是因为，隐向量内积获得夹角关系，是降维至二维的操作。这一步造成了不可逆的信息损失。</p></blockquote><img src="/2021/09/%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F-Part3/image-20210928101521711.png" alt="image-20210928101521711" style="zoom:67%;"><h3 id="原始-NeuralCF"><a href="#原始-NeuralCF" class="headerlink" title="原始 NeuralCF"></a>原始 NeuralCF</h3><p>Neural CF 模型是从传统的协同过滤方法(MF)的基础上进行的改进：</p><ol><li>把MF里面用户向量和物品向量的点积操作换成了<strong>多层神经网络</strong>，使得两个向量可以做更充分的交叉，得到更多有价值的特征组合信息；</li><li>另外一个就是神经网络的激活函数可以引入更多的非线性，让模型的表达能力更强。</li></ol><p><img src="/2021/09/%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F-Part3/image-20210928102102351.png" alt="image-20210928102102351"></p><h3 id="GMF-广义矩阵分解"><a href="#GMF-广义矩阵分解" class="headerlink" title="GMF 广义矩阵分解"></a>GMF 广义矩阵分解</h3><ul><li><p>原始的矩阵分解：</p><ol><li>用户向量与物品向量进行内积。</li></ol></li><li><p>GMF 广义矩阵分解：</p><ol><li>用户向量与物品向量进行元素积。</li><li>神经网络拟合互操作结果。</li></ol></li><li><p>GMF 步骤：</p><ol><li>将 NeuralCF 的 Neural CF Layers 替换成 user 和 item 的 Embedding 做点积（对应元素相乘），得到一个和 Embedding 等长的向量</li><li>隐形量进行对应元素相乘之后，给每个元素分配权重（也就是各个隐向量维度的重要性不一定相同），等价于一个 Linear 层。（如果 h 是一个全1向量的话，那模型实际上就是 MF 了。）</li><li>使用 sigmoid 预测分数。</li></ol></li><li><p>GMF 评价：虽然赋予了权重，但依然没有摆脱降维带来的信息损失。</p></li></ul><h3 id="NeuralCF-混合模型-MLP-GMF"><a href="#NeuralCF-混合模型-MLP-GMF" class="headerlink" title="NeuralCF 混合模型(MLP + GMF)"></a>NeuralCF 混合模型(MLP + GMF)</h3><p><img src="/2021/09/%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F-Part3/image-20210928111455990.png" alt="image-20210928111455990"></p><ul><li>混合了 MLP 和 GMF，需要注意的是两个墨西哥的 embedding 是分开的。</li><li>无论是 MLP 还是 GMF，都采用 Embedding 的方式生成隐向量，而不是传统的矩阵分解 MF。</li><li>根据评分矩阵生成的隐向量（User 和 Item 的 Embedding 向量），其中每一个维度都可以看做是一种抽象特征，而特征交叉就是针对 Embedding 向量的每个维度进行交叉。</li><li>特征交叉的方式：<ol><li>GMF：线性方式——向量点积</li><li>MLP：非线性方式——多层神经网络</li><li>NeuralCF ：混合上述两种方式</li></ol></li></ul><h2 id="PNN-模型"><a href="#PNN-模型" class="headerlink" title="PNN 模型"></a>PNN 模型</h2><h3 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h3><ul><li>NeuralCF 不足：只用到了用户向量和物品向量，可以看成一个MF的加强版，但是没有考虑其他特征信息，这无疑是一种浪费。</li><li>Product-based Neural Network(PNN)：在加入多组特征的基础上研究的特征交叉，这个模型和 Deep Crossing 模型的架构类似，只不过把 Deep Crossing 的 stacking 层换成了 Product 层，也就是不同特征的 embedding 向量不再是简单的堆叠，而是两两交互，更有针对性的获取特征之间的交叉信息。</li><li>在这里面研究了两两特征之间的内积和外积两种交叉方式，提出了具体的两种模型 IPNN 和 OPNN。</li></ul><h3 id="网络结构-1"><a href="#网络结构-1" class="headerlink" title="网络结构"></a>网络结构</h3><p><img src="/2021/09/%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F-Part3/image-20210928135958913.png" alt="image-20210928135958913"></p><ol><li>输入层：模型输入由 N 个特征域（Field）组成，都是离散稀疏的分类特征。数值型特征要在类别性特征交叉完之后再合并。</li><li>Embedding 层：和 DeepCrossing 一样，对每一个离散稀疏的 Field 特征域进行 Embedding 操作，参数是通过神经网络的反向传播进行学习。</li><li>Product 层：<ul><li>线性操作部分和乘积操作部分。丰富了特征交叉的能力。</li><li>z 区域表示单独特征，是单个特征与参数 w 的运算；p 区域表示交叉特征，是特征两两内积后的特征与参数 w 的计算。</li><li>p 部分又分为内积(IPNN)和外积(OPNN)</li></ul></li><li>L1、L2 层：两层全连接，输入包含了离散型特征 l<del>p</del> 和 l<del>z</del> 以及数值型特征。</li><li>输出层：二分类预测问题，使用 sigmoid 激活输出。</li></ol><h2 id="Wide-amp-Deep模型"><a href="#Wide-amp-Deep模型" class="headerlink" title="Wide&amp;Deep模型"></a>Wide&amp;Deep模型</h2><h3 id="记忆能力和泛化能力"><a href="#记忆能力和泛化能力" class="headerlink" title="记忆能力和泛化能力"></a>记忆能力和泛化能力</h3><ul><li><p>记忆能力：</p><ul><li>模型直接学习并利用历史数据中物品和特征的“共现频率”的能力。</li><li>记住了历史数据的分布特点，由原始数据直接影响结果。</li></ul></li><li><p>泛化能力：</p><ul><li>模型传递特征的相关性，以及发掘稀疏甚至从未出现过的稀有特征与最终标签相关性的能力。</li><li>让数据稀少的用户或者物品也能生成隐性特征，获得全局数据的泛化支撑，深度发掘数据中的潜在模式。</li></ul></li></ul><h3 id="背景介绍"><a href="#背景介绍" class="headerlink" title="背景介绍"></a>背景介绍</h3><ul><li>在CTR预估任务中，利用手工构造的交叉组合特征来使线性模型具有“记忆性”，使模型记住共现频率较高的特征组合，往往能达到一个不错的baseline，且可解释性强。但这种方式有较为明显的缺点：1. 特征工程需要耗费太多精力。2. 对于未曾出现过的特征组合，权重系数为0，无法进行泛化。</li><li>为了加强模型的泛化能力，研究者引入了DNN结构、将高维稀疏特征编码为低维稠密的 Embedding vector，有效提高模型的泛化能力。但是，基于 Embedding 的方式遇到高度稀疏且高秩的共现矩阵时，长尾的一些特征值无法被充分学习，即使两者没有任何关系，也会由于 dense embedding 导致预测值非0，这便会造成模型泛化过度。</li><li>因此，现在主要的两种模型：<ol><li>协同过滤、逻辑回归等：能够从历史数据中学习到高频共现的特征组合能力，但是泛化能力不足；</li><li>矩阵分解、深度学习等：能够利用相关性的传递去探索历史数据中未出现的特征组合，挖掘数据潜在的关联模式，但是对于特定的场景（数据分布长尾，共现矩阵稀疏高秩）很难有效学习低纬度的表示，造成推荐的过渡泛化。</li></ol></li><li>Wide&amp;Deep 模型，将线性模型与 DNN  结合起来，在提高模型泛化能力的同时，兼顾模型的记忆性。</li><li>Wide&amp;Deep 后来成为推荐领域的经典模式，奠定了后面深度学习模型的基础。这个是一个里程碑式的改变，模型架构并没有多复杂，重点在于思想。</li></ul><h3 id="网络结构-2"><a href="#网络结构-2" class="headerlink" title="网络结构"></a>网络结构</h3><img src="/2021/09/%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F-Part3/image-20210928143913425.png" alt="image-20210928143913425" style="zoom:150%;"><p>W&amp;D 模型把单输入层的 Wide 部分和 Embedding + 多层全连接的部分连接起来，一起输入最终的输出层得到预测结果。单层的 wide 层善于处理大量的稀疏的 id 类特征，Deep 部分利用深层的特征交叉，挖掘在特征背后的数据模式。</p><h4 id="Wide"><a href="#Wide" class="headerlink" title="Wide"></a>Wide</h4><p>Wide 部分是一个广义的线性模型，用来处理神经网络并不擅长的离散特征。</p><ul><li>特征转换：cross-product transformation(原始特征的交互特征)，如果两个特征同时为1的时候，这个特征就是1，否则就是0，这是一种特征组合。</li><li>优化器：带 L1 正则的 FTRL 算法(Follow-the-regularized-leader)，该算法非常注重模型稀疏性质，可以使特征更加稀疏，即大部分参数都为0，就大大压缩了模型权重及特征向量的维度。</li></ul><blockquote><p>Wide 部分模型训练完之后留下来的特征都是非常重要的，那么模型的“记忆能力”就可以理解为发现”直接的”，“暴力的”，“显然的”关联规则的能力。</p></blockquote><h4 id="Deep"><a href="#Deep" class="headerlink" title="Deep"></a>Deep</h4><p>Deep 部分是 Embedding+MLP 的神经网络模型，用来挖掘藏在特征背后的数据模式。</p><p>输入的特征有两类：1. 数值型特征；2. 类别型特征(会经过 embedding)。</p><blockquote><p>大规模稀疏特征通过 Embedding 转化为低维密集型特征。</p><p>DNN 模型随着层数的增加，中间的特征就越抽象，也就提高了模型的泛化能力。</p></blockquote><h3 id="谷歌推荐系统的工业经验"><a href="#谷歌推荐系统的工业经验" class="headerlink" title="谷歌推荐系统的工业经验"></a>谷歌推荐系统的工业经验</h3><p>Wide&amp;Deep 模型本身的结构非常简单，但如何根据自己的场景去选择哪些特征放在 Wide 部分，哪些特征放在 Deep 部分是用好该模型的前提。</p><p><img src="/2021/09/%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F-Part3/image-20210928150837339.png" alt="image-20210928150837339"></p><p>Google Pay 通过检索来实现推荐的召回，将大规模的 App 应用缩小到小规模（例如100）的相关应用。然后在通过用户特征、上下文特征、用户行为特征等来建立推荐模型，估计用户点击每个 App 的概率分数进行排序，推荐 Top K 个 App。</p><p><img src="/2021/09/%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F-Part3/image-20210928151001327.png" alt="image-20210928151001327"></p><ol><li>Deep部分：全量的特征向量，包括用户年龄(age)、已安装应用数量(#app installs)、设备类型(device class)、已安装应用(installed app)、曝光应用impression app)等特征。其中，已安装应用，曝光应用等类别型特征，需要经过embedding层输入连接层，而数值型的特征和前面的特征拼接起来直接输入连接层，经过3层的Relu全连接层。</li><li>Wide部分：输入仅仅是已安装应用和曝光应用两类特征。其中已安装应用代表用户的历史行为，而曝光应用代表当前待推荐应用。选择这两部分是想发现当前曝光 APP 和用户已安装 APP 之间的关联，以充分发挥Wide的记忆能力，影响最终的得分。这部分是 L1 正则化的 FTRL 优化器，可能是因为这两个 id 类特征向量组合，在维度爆炸的同时，会让原本已经非常稀疏的 multihot 特征向量变得更加稀疏。因此采用FTRL过滤掉那些稀疏特征是非常好的工程经验。</li><li>两者结合：最后将两部分的特征再进行一个拼接，输出到 logistics Loss 层进行输出。</li></ol><h2 id="Deep-amp-Cross-模型"><a href="#Deep-amp-Cross-模型" class="headerlink" title="Deep&amp;Cross 模型"></a>Deep&amp;Cross 模型</h2><h3 id="基本思路-1"><a href="#基本思路-1" class="headerlink" title="基本思路"></a>基本思路</h3><ul><li>针对问题：Wide 部分有一个不足就是需要人工进行特征的组合筛选，过程繁琐且需要经验；2阶的FM模型在线性的时间复杂度中自动进行特征交互，但是这些特征交互的表现能力并不够，并且随着阶数的上升，模型复杂度会大幅度提高。</li><li>改进方向：用一个 Cross Network 替换掉 Wide 部分，来自动进行特征之间的交叉，并且网络的时间和空间复杂度都是线性的。</li></ul><h3 id="网络结构-3"><a href="#网络结构-3" class="headerlink" title="网络结构"></a>网络结构</h3><p><img src="/2021/09/%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F-Part3/image-20210928152058933.png" alt="image-20210928152058933"></p><ol><li>Embedding and stacking layer：作用依然是把稀疏离散的类别型特征变成低维密集型。</li><li>Cross Network：目的是增加特征之间的交互力度。<ul><li><img src="/2021/09/%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F-Part3/image-20210928154001138.png" alt="image-20210928154001138"></li><li>交叉层的操作的二阶部分非常类似 PNN 提到的外积操作。</li><li>思想上类似于残差连接。</li><li>x1 中包含了所有的 x0 的 1、2 阶特征的交互，x2 包含了所有的 x1、x0 的 1、2、3 阶特征的交互。因此，交叉网络层的叉乘阶数是有限的。第 l 层特征对应的最高叉乘阶数为 l+1。</li><li>每一层特征权重共享。</li><li>交叉网络的时间和空间复杂度是线性的。因为每一层都只有w和b，没有激活函数的存在，相对于深度学习网络，交叉网络的复杂性可以忽略不计。</li><li>Cross网络是FM的泛化形式</li><li>当两个稀疏特征不全为 1 时，就不会训练权重，也就不会进行交互。</li></ul></li><li>Deep Network：与 D&amp;W 相同。</li><li>组合层：将两个网络的输出拼接，并且 Logistics 回归</li></ol><h2 id="FNN-模型"><a href="#FNN-模型" class="headerlink" title="FNN 模型"></a>FNN 模型</h2><h3 id="基本思路-2"><a href="#基本思路-2" class="headerlink" title="基本思路"></a>基本思路</h3><ul><li><p>FNN 是在 W&amp;D 之前提出的</p></li><li><p>针对问题：1. Embedding 层收敛速度过慢；2. FM 虽然考虑了二阶交叉，但无法延伸到高阶交叉信息的学习。</p></li><li><p>Embedding 层收敛速度慢的原因：1. 输入极端稀疏化，众多的 0 导致 w 无法更新；2. 参数量往往占整个神经网络的大半以上。</p></li><li><p>解决方案：</p><ol><li>提前预训练好一个 FM 模型，该模型可以用来得到各特征隐向量。</li><li>然后用 FM 训练好的特征隐向量对正式训练的模型进行 Embedding 层的权重初始化。</li></ol></li></ul><h3 id="网络结构与训练细节"><a href="#网络结构与训练细节" class="headerlink" title="网络结构与训练细节"></a>网络结构与训练细节</h3><p><img src="/2021/09/%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F-Part3/image-20210928181946861.png" alt="image-20210928181946861"></p><ul><li>类似于 Deep Crossing 模型的经典深度神经网络，从稀疏输入向量到稠密向量的转换依然是embedding结构。</li><li>FNN 模型针对 Embedding 层收敛速度慢的问题，用 FM 模型替换了下面的 Embedding 层，并且在模型的正式训练之前，先提前训练好 FM，然后用 FM 训练好的特征隐向量对正式训练的模型进行 Embedding 层的初始化操作。</li><li>采用两阶段训练方式，是为了将 FM 作为有价值先验知识加入到模型中。防止因为数据稀疏带来的歧义造成模型参数偏差、加速模型收敛、充分利用 FM 的特征表达。</li><li>类似于迁移学习。</li></ul><h3 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h3><ul><li>优点：<ul><li>采用预训练的方式</li><li>采用了组合模型的思想，引入 DNN，可以进行特征的高阶组合，减少特征工程。</li></ul></li><li>缺点：<ul><li>两阶段的训练模型，应用过程不方便，且模型能力受限于 FM 表征能力的上限。</li><li>只关注于高阶特征的组合交叉，容易丢失记忆能力。</li><li>全连接层将向量的所有元素加权求和，不会对Field进行区分，本质又回到了 Deep Crossing 的问题。</li><li>特征的学习没有针对性。</li><li>两阶段的训练方式给神经网络调参带来难题。</li></ul></li></ul><h2 id="DeepFM-模型"><a href="#DeepFM-模型" class="headerlink" title="DeepFM 模型"></a>DeepFM 模型</h2><h3 id="基本思路-3"><a href="#基本思路-3" class="headerlink" title="基本思路"></a>基本思路</h3><ul><li>存在问题：<ul><li>简单的线性模型虽然简单，同样这样是它的不足，就是限制了模型的表达能力，随着数据的大且复杂，这种模型并不能充分挖掘数据中的隐含信息，且忽略了特征间的交互，如果想交互，需要复杂的特征工程。</li><li>FM模型考虑了特征的二阶交叉，但是这种交叉仅停留在了二阶层次，虽然说能够进行高阶，但是计算量和复杂性一下子随着阶数的增加一下子就上来了。所以二阶是最常见的情况，会忽略高阶特征交叉的信息</li><li>DNN，适合天然的高阶交叉信息的学习，但是低阶的交叉会忽略掉</li><li>W&amp;D 把简单的LR模型和DNN模型进行了组合，使得模型既能够学习高阶组合特征，又能够学习低阶的特征模式。但是W&amp;D的wide部分是用了LR模型，这一块依然是需要一些经验性的特征工程，且 Wide 部分和 Deep 部分需要两种不同的输入模式，这个在具体实际应用中需要很强的业务经验。</li></ul></li></ul><h3 id="网络结构-4"><a href="#网络结构-4" class="headerlink" title="网络结构"></a>网络结构</h3><p><img src="/2021/09/%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F-Part3/image-20210928185114897.png" alt="image-20210928185114897"></p><ul><li>DeepFM 也是两部分组成，左边的 FM + 右边的 DNN。</li><li>与 W&amp;D 和 DCN 相比，DNN 部分是相同的，区别在于 Wide 部分：1. W&amp;D 采用的是 LR；2. Deep&amp;Cross 采用 Cross 交叉网络；3. DeepFM 采用了 FM。后两者都是针对于 W&amp;D 的 wide 不具备自动特征组合能力的缺陷进行改进的。</li><li>Input、Embedding：与 Wide&amp;Deep 不同的是，DeepFM 中的 Wide 部分与 Deep 部分共享了输入特征，即 Embedding 向量。</li><li>FM：与 FNN 不同，FM 的隐向量参数也是当做学习参数一块学习的，以端到端方式训练整个网络。作者发现，通过高阶和低阶交互特征一块来进行反向传播更新参数反而会使得模型表现更佳，当然这也依赖于共享Embedding输入的策略。</li><li>Deep：与 Wide 使用相同的特征 Embedding。</li></ul><h3 id="论文细节"><a href="#论文细节" class="headerlink" title="论文细节"></a>论文细节</h3><ul><li><p>特征交互本质：</p><ul><li>二阶特征交互：通过对主流应用市场的研究，我们发现人们经常在用餐时间下载送餐的应用程序，这就表明应用类别和时间戳之间的（阶数-2）交互作用是 CTR 预测的一个信号。</li><li>三阶或者高阶特征交互：我们还发现男性青少年喜欢射击游戏和 RPG 游戏，这意味着应用类别、用户性别和年龄的(阶数-3)交互是 CTR 的另一个信号。</li><li>同时考虑低阶和高阶的交互特征，比单独考虑其中之一有更多的提升。</li></ul></li><li><p>人工特征工程的挑战性：</p><ul><li>一些特征工程比较容易理解，就比如上面提到的那两个，这时候往往我们都能很容易的设计或者组合那样的特征。 然而，其他大部分特征交互都隐藏在数据中，难以先验识别（比如经典的关联规则”尿布和啤酒“就是从数据中挖掘出来的，而不是由专家发现的），只能由机器学习自动捕捉。即使是对于容易理解的交互，专家们似乎也不可能详尽地对它们进行建模，特别是当特征的数量很大的时候。</li><li>所以，尽量的避免人工特征工程，构建端到端的推荐系统时作者研究该篇论文的另一动机所在（改进了W&amp;D）</li></ul></li><li><img src="/2021/09/%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F-Part3/image-20210928192807353.png" alt="image-20210928192807353" style="zoom:150%;"></li><li><p>FNN、PNN、W&amp;D 比较：</p><ul><li>FNN 模型：预训练的方式增加了开销，模型能力受限于 FM 表征能力的上限，且只考虑了高阶交互</li><li>PNN 模型：IPNN 的内积计算非常复杂，OPNN 的外积近似计算损失了很多信息，结果不稳定，且同样忽视了低阶交互</li><li>W&amp;D 模型：虽然是考虑到了低阶和高阶交互，兼顾了模型的泛化和记忆，但是 Wide 部分输入需要专业的特征工程经验，作者这里还举了个例子，比如用户安装应用和应用推荐中曝光应用的交叉，这个需要一些强的业务经验。</li></ul></li></ul><h2 id="NFM-模型"><a href="#NFM-模型" class="headerlink" title="NFM 模型"></a>NFM 模型</h2><h3 id="基本思路-4"><a href="#基本思路-4" class="headerlink" title="基本思路"></a>基本思路</h3><ul><li>NFM(Neural Factorization Machines)</li><li>FM 的问题：真实世界中的数据往往是非线性且内部结构复杂，而 FM 还是个线性模型，且交互仅仅限于二阶交互，所以作者认为 FM 在处理真实数据的时候，表达能力并不好。</li><li>改进方向：用一个表达能力更强的函数（神经网络）来替代原 FM 中二阶隐向量内积的部分。</li><li><img src="/2021/09/%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F-Part3/image-20210928213549920.png" alt="image-20210928213549920"></li></ul><h3 id="网络结构-5"><a href="#网络结构-5" class="headerlink" title="网络结构"></a>网络结构</h3><p><img src="/2021/09/%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F-Part3/image-20210928213748093.png" alt="image-20210928213748093"></p><p>类似于 PNN，由 product_layer 换成了 Bi-Interaction Pooling，这个也是NFM的核心结构了。</p><ul><li>Input、Embedding、DNN、Output 层：同之前。</li><li>Bi-Interaction Pooling layer：在 Embedding 和 DNN 之间加入的特征交叉池化层。<ul><li><img src="/2021/09/%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F-Part3/image-20210928214540185.png" alt="image-20210928214540185"></li><li>可以认为是特征域和特征域之间做交叉</li></ul></li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li>NFM 相比较于其他模型的核心创新点是特征交叉池化层，实现了 FM 和 DNN 的无缝连接，NN 可以在 low level 就学习到包含更多信息的组合特征。集合了 FM 二阶交叉线性和 DNN 高阶交叉非线性的优势，非常适合处理稀疏数据的场景任务</li><li>在特征交叉层和隐藏层加入 dropout 技术，有利于缓解过拟合，dropout也是线性隐向量模型过拟合的策略</li><li>在 NFM 中，使用 BN+Dropout 的组合会使得学习的稳定性下降， 具体使用的时候要注意</li><li>特征交叉池化层能够较好的对二阶特征信息的交互进行学习编码，这时候，就会减少 DNN 的很多负担，只需要很少的隐藏层就可以学习到高阶特征信息，也就是 NFM 相比之前的 DNN，模型结构更浅，更简单，但是性能更好，训练和调参更容易</li><li>NFM 对参数初始化相对不敏感，也就是不会过度依赖于预训练，模型的鲁棒性较强</li><li>深度学习模型的层数不总是越深越好，太深了会产生过拟合的问题，且优化起来也会困难</li></ul><h2 id="AFM-模型"><a href="#AFM-模型" class="headerlink" title="AFM 模型"></a>AFM 模型</h2><h3 id="基本思路-5"><a href="#基本思路-5" class="headerlink" title="基本思路"></a>基本思路</h3><ul><li>AFM(Attentional Factorization Machines)</li><li>针对问题：NFM 的特征交叉池化层对于各个交叉特征向量进行加和，没有考虑不同特征对结果的影响程度。这可能会影响最后的预测效果，因为不是所有的交互特征都能够对最后的预测起作，而没有用的交互特征就可能会产生噪声。</li><li>改进方向：引入注意力机制，学习不同交叉特征对于结果的不同影响程度。</li></ul><h3 id="网络结构-6"><a href="#网络结构-6" class="headerlink" title="网络结构"></a>网络结构</h3><p><img src="/2021/09/%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F-Part3/image-20210928220446143.png" alt="image-20210928220446143"></p><ul><li><p>Input、embedding、Output 层：同之前。</p></li><li><p>Pair-wise Interaction Layer：和 NFM 是一样的，采用的也是每对 Embedding 向量进行各个元素对应相乘（element-wise product）交互。</p></li><li><p>Attention based Pooling layer：在 Pair-wise Interaction Layer 和 Output layer 中间加入的 Attention 注意力网络。</p><ul><li><p><img src="/2021/09/%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F-Part3/image-20210928221437267.png" alt="image-20210928221437267"></p></li><li><p>主要思路：不同的特征交互向量在将它们压缩为单个表示时，根据对预测结果的影响程度给其加上不同权重。</p></li><li><p>其中aij表示v<del>i</del>⊙v<del>j</del>对的注意力分数，表示该交互特征对于预测目标的重要性程度。这个注意力分数可以作为参数然后通过最小化预测损失来进行学习，但是对于从未在训练数据中共同出现的特征，就无法估计其交互作用的注意力得分。所以为了解决泛化问题，这里才使用了一个多层感知器（MLP）将注意力得分参数化，就是上面的那个 Attention Net。</p></li><li><p>该注意力网络的结构是一个简单的单全连接层加 softmax 输出层的结构</p></li><li><p><img src="/2021/09/%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F-Part3/image-20210928221953070.png" alt="image-20210928221953070"></p></li></ul></li></ul><h2 id="DIN-模型"><a href="#DIN-模型" class="headerlink" title="DIN 模型"></a>DIN 模型</h2><h3 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h3><ul><li>Deep Interest Network(DIN) 模型非常重要，是基于业务的观察，从实际应用的角度进行的模型改进，完全符合以需求为导向的创新原则。</li><li>DIN 的论文写得非常精彩，建议读原文，里面不仅提出了DIN模型，并基于真实场景下大规模数据集的模型训练问题，提出了两种重要的训练技术。</li><li>DIN 模型的创新点或者解决的问题就是使用了注意力机制来对用户的兴趣动态模拟，非常注重用户的历史行为特征（历史购买过的商品或者类别信息）。</li></ul><h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><ul><li>拥有大量的用户历史行为信息。</li><li>用户兴趣多种多样，并且变化多端。</li><li>用户的兴趣往往蕴含在历史行为当中。</li><li>用户是否点击商品，很大程度上依赖于他的历史行为。</li><li>广告推荐两个主要的阶段：召回和排序。<ul><li>召回(matching stage): 通过协同过滤等方法生成与访问用户相关的候选广告列表</li><li>排序：就是通过排序模型来预测用户对于候选广告的点击概率，根据概率生成推荐列表</li></ul></li><li>大部分的推荐场景下都会有这两大步骤， 而商品广告推荐和一些其他推荐有些区别的是很注重用户的历史行为，因为这个直接与用户的兴趣相关， 而用户兴趣又反过来和商品挂钩。</li></ul><h3 id="基本思路-6"><a href="#基本思路-6" class="headerlink" title="基本思路"></a>基本思路</h3><ul><li>Embeding&amp;MLP 模型的存在问题：1. 无法表达用户广泛的兴趣；2. 并不是用户所有的历史行为特征都会对某个商品广告点击预测起到作用。</li><li>改进方向：1. 应该考虑到用户的历史行为商品与当前商品广告的一个关联性（局部兴趣），模拟出用户对商品的兴趣程度（注意力得分）。</li></ul><h3 id="特征表示"><a href="#特征表示" class="headerlink" title="特征表示"></a>特征表示</h3><img src="/2021/09/%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F-Part3/image-20210928231725615.png" alt="image-20210928231725615" style="zoom: 80%;"><p>工业上的CTR预测数据集一般都是 multi-group categorial form 的形式，就是类别型特征最为常见。</p><h3 id="网络结构-7"><a href="#网络结构-7" class="headerlink" title="网络结构"></a>网络结构</h3><img src="/2021/09/%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F-Part3/image-20210929082029917.png" alt="image-20210929082029917"><p>base 模型：</p><ol><li>Embedding layer：把高维稀疏的输入转成低维稠密向量。multi-hot 编码会得到一个 embedding 向量的列表。</li><li>pooling layer：pooling 层的作用是将用户的历史行为，即不定长的 embedding 向量，最终变成一个定长的向量。</li><li>Concat layer：把所有特征 embedding 向量，从特征维度拼接，作为MLP的输入。</li><li>MLP：普通全连接。</li><li>Loss：二分类的问题。<img src="/2021/09/%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F-Part3/image-20210929080649441.png" alt="image-20210929080649441"></li></ol><p>存在问题：</p><ol><li>用户的历史行为特征和当前的候选广告特征拼接之前，一点交互过程都没有。</li><li>拼接之后给 MLP，虽然有交互，但是既丢失了部分信息，也引入了部分噪声<ul><li>丢失信息：已经无法看出到底用户历史行为中的哪个商品与当前商品比较相关。</li><li>引入噪声：因为当前候选广告商品交互的是池化之后的历史特征 embedding，其包含了所有的历史商品信息。</li></ul></li></ol><p>改进思路：</p><ol><li>对于给定的候选广告，DIN 通过考虑历史行为与其相关性，自适应地计算用户兴趣的表示向量，该向量随不同广告而变化。</li></ol><img src="/2021/09/%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F-Part3/image-20210928231838285.png" alt="image-20210928231838285"><p>DIN 模型的 Activation Unit：</p><ul><li>位于 embedding 和 pooling 层之间。</li><li>用于计算用户历史行为商品和当前候选商品之间的相关性，即每个历史商品的权重。</li><li>不进行 softmax，目的是为了保留用户的兴趣强度。否则可能会因为过长的序列和 0-1 映射，使得权重差距不明显。</li></ul><h3 id="论文细节-1"><a href="#论文细节-1" class="headerlink" title="论文细节"></a>论文细节</h3><ol><li><p>Mini-batch Aware Regularization：为了防止模型过拟合，一般会加入正则化，而L2正则化加入的时候，是对于所有的参数都会起作用。像这种真实数据集中，每个mini-batch的样本特征是非常稀疏的，这种情况下根本就没有必要考虑所有的参数进去，这个复杂度会非常大。仅约束那些在当前 mini-batch 样本中出现的特征(不为0的那些特征) embedding 就可以了。</p></li><li><p>Data Adaptive Activation Function：随着数据分布而动态调整的自适应激活函数。</p><ul><li><img src="/2021/09/%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F-Part3/image-20210929084620252.png" alt="image-20210929084620252"></li><li><img src="/2021/09/%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F-Part3/image-20210929084636564.png" alt="image-20210929084636564"></li><li>这里的 E(s) 和 Var(s) 是每个 mini-batch 里面样本的均值和方差，当然这是训练集部分，测试集的时候采用的是在数据上平滑的均值和方差。由于把均值和方差考虑进去了，那么这个函数的调整就可以根据数据的分布进行自适应，这样会更加的灵活且合理。</li></ul></li><li><p>衡量模型改进程度的评价标准 RelaImpr：</p><ul><li><img src="/2021/09/%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F-Part3/image-20210929084951620.png" alt="image-20210929084951620"></li><li>基于 base model 评价模型的提高程度</li><li><img src="/2021/09/%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F-Part3/image-20210929085036339.png" alt="image-20210929085036339"></li><li>#inpressiong<del>i</del> 和 AUC<del>i</del> 分别是 i 用户的喜好和 AUC。</li><li>AUC = P(P<del>正样本</del> &gt; P<del>负样本</del>)</li></ul></li></ol><h2 id="DIEN-模型"><a href="#DIEN-模型" class="headerlink" title="DIEN 模型"></a>DIEN 模型</h2><h3 id="基本思路-7"><a href="#基本思路-7" class="headerlink" title="基本思路"></a>基本思路</h3><ol><li><p>DIN有两点不足：</p><ul><li>直接将用户过去的历史行为当做了用户的兴趣，缺乏对具体行为背后的潜在兴趣进行专门的建模。只计算了当前候选广告与过去历史行为的相关性，根据这个做出推荐，但历史行为之间的依赖关系并没有很好的模拟出来。历史行为其实也是一个随时间排序的序列，既然是时间相关的序列，就一定存在或深或浅的前后依赖关系，而这样的序列信息或者说依赖关系对推荐过程是非常有价值的(能够反映用户背后的潜在兴趣变化)，大量研究发现这种信息能够用于构建更丰富的用户模型并发现附加的行为模式，而DIN模型包括之前的MLP系列模型都无法学习到这样的序列依赖关系。</li><li>DIN 模型没法捕捉到用户的兴趣变化过程，作者在论文中用到了一个词叫做”兴趣漂移”，即在相邻的访问中，用户的意图可能非常不同，用户的一个行为可能依赖于很久以前的行为。而一个用户对不同目标项的点击行为受到不同兴趣部分的影响，如果没法学习用户的兴趣演化，就很容易基于用户所有购买历史行为综合推荐，而不是针对“下一次购买”推荐，DIN虽然是能够更加注重与当前候选物品相关的历史行为，但是这些行为并不能表示出用户的兴趣变化过程，所以序列信息是非常之重要的。</li><li>总结：DIN 忽略了序列信息，容易基于历史行为综合推荐，而不是针对下一次购买进行推荐。</li></ul></li><li><p>序列的重要性：</p><p>例如：上周一位用户在挑选一双篮球鞋，这位用户上周的行为序列都会集中在篮球鞋这个品类的商品上，但是完成购买之后，本周的购物兴趣可能变成买机械键盘。</p><ul><li>加强了最近行为对下次行为预测的影响。比如上面的例子，用户近期购买机械键盘的概率会明显高于再买篮球鞋的概率。</li><li>序列模型能够学习到购买趋势的信息。这个感觉就是在建模用户的兴趣演化，在上面例子中，序列模型能在一定程度上建立“篮球鞋”到“机械键盘”的转移概率，如果这个转移概率在全局统计意义上足够高，那么用户购买篮球鞋时，推荐机械键盘也会是一个不错的选项。直观上，两者的用户群体很有可能一致。</li></ul></li><li><p>兴趣的实际状况：</p><ul><li>同一时刻下，可能会拥有多种不同的兴趣，应该用兴趣状态描述</li><li>兴趣是动态变化的，拥有各自的演化过程</li><li>兴趣发展是有一定前因后果的</li><li>当前时刻的兴趣，都有可能由上个时刻的兴趣概率转移</li></ul></li><li><p>改进方向：将 DIN 的 embedding 到 concat 之间的部分替换成兴趣进化网络。</p></li></ol><h3 id="网络结构-8"><a href="#网络结构-8" class="headerlink" title="网络结构"></a>网络结构</h3><p><img src="/2021/09/%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F-Part3/image-20210929091931368.png" alt="image-20210929091931368"></p><ol><li>行为序列层(Behavior Layer)：主要作用是把原始的 id 类行为序列转成 Embedding 行为序列， 和 DIN 下面的 Embedding 层一样。</li><li>兴趣抽取层(Interest Extractor Layer): 主要作用是通过模拟用户的兴趣迁移过程，挖掘提取用户行为背后潜藏的状态，DIN 模型没有这个东西。这个也就是 DIN 的不足①的改进，能够学习到历史序列行为之间的序列依赖关系。<ul><li>auxiliary loss：帮助监督更新这一层的 GRU 参数。让当前时刻输出的隐藏状态 h<del>t</del> 尽量的与下一个时刻用户点击的行为 embedding 相似，与下一个时刻里面用户没有点击过的行为 embedding 越远。</li><li>原来的 GRU 是只在最后一个时间步进行输出，然后与真实 label 进行了一个交叉熵的计算，而改进的这个核心点是每个时间步都会有一个输出，然后都会与一个 label 进行一个交叉熵计算，所以这里就会多出了时间步 t 维度上的加和损失，还有点不同就是 label 这里，当前时间步用的 label 是下一个时间步的输入值。</li><li>引入 auxiliary loss 的原因：目标商品的点击行为是由最后的兴趣触发，而 label 只能监督最后的兴趣，对隐藏层的状态不能有效监督。</li></ul></li><li>兴趣进化层(Interest Evolving Layer)：主要作用是通过兴趣抽取层在兴趣抽取层的基础上加入注意力机制，模拟与目标广告相关的兴趣进化过程。这个和 DIN 引入注意力的思路其实是一脉相承的， 注意力的计算得分都是一致的。只不过这里这里不是把这个注意力计算的得分与兴趣抽取层的 h 简单加权组合了，而是把这个注意力操作嵌入到了 GRU 更新门里面去，形成了一个 AUGRU 的结构，用这个层来更有针对性的模拟与目标广告相关的兴趣进化路径。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 推荐系统 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>推荐系统-Part2</title>
      <link href="/2021/09/%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F-Part2/"/>
      <url>/2021/09/%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F-Part2/</url>
      
        <content type="html"><![CDATA[<h1 id="推荐系统-Part2——传统推荐模型"><a href="#推荐系统-Part2——传统推荐模型" class="headerlink" title="推荐系统-Part2——传统推荐模型"></a>推荐系统-Part2——传统推荐模型</h1><p>[TOC]</p><h2 id="协同过滤-CF"><a href="#协同过滤-CF" class="headerlink" title="协同过滤(CF)"></a>协同过滤(CF)</h2><h3 id="基本思想"><a href="#基本思想" class="headerlink" title="基本思想"></a>基本思想</h3><blockquote><p>协同过滤是推荐系统的必看内容，因为该算法是后来推荐算法的基本思想。</p></blockquote><ul><li>基本思想：根据用户之前的喜好以及其他兴趣相近的用户的选择来给用户推荐物品(基于对用户历史行为数据的挖掘发现用户的喜好偏向，并预测用户可能喜好的产品进行推荐)。</li><li>一般是仅仅基于用户的行为数据（评价、购买、下载等）, 而不依赖于项的任何附加信息（物品自身特征）或者用户的任何附加信息（年龄， 性别等）。</li><li>目前应用比较广泛的协同过滤算法是基于邻域的方法， 而这种方法主要有下面两种算法：<ul><li>基于用户的协同过滤算法(UserCF): 给用户推荐和他兴趣相似的其他用户喜欢的产品</li><li>基于物品的协同过滤算法(ItemCF): 给用户推荐和他之前喜欢的物品相似的物品</li></ul></li></ul><h3 id="目标场景"><a href="#目标场景" class="headerlink" title="目标场景"></a>目标场景</h3><ul><li><p>存在一系列数据：行为用户记录，列为用户行为目标(包括点击、点赞、购买哪些商品/视频等一些列行为)。</p><p><img src="/2021/09/%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F-Part2/image-20210927170905175.png" alt="image-20210927170905175"></p></li></ul><h3 id="相似度计算"><a href="#相似度计算" class="headerlink" title="相似度计算"></a>相似度计算</h3><ol><li><p>杰卡德相似度：衡量两个集合的相似度，也就是交并比。</p><ul><li><img src="/2021/09/%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F-Part2/image-20210926195359526.png" alt="image-20210926195359526"></li></ul></li><li><p>余弦相似度：衡量了两个用户向量(矩阵中的行向量) i 和 j 之间的向量夹角的大小，夹角越小，说明相似度越大，两个用户越相似。</p><ul><li><p><img src="/2021/09/%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F-Part2/image-20210926195502822.png" alt="image-20210926195502822"></p></li><li><p>局限性：对于不规范的评分数据敏感。例如：A 用户比较喜欢打高分(以95分为优秀)，而 B 用户比较喜欢打低分(以80分为优秀)。</p></li><li><p>```python<br>from sklearn.metrics.pairwise import cosine_similarity</p><p>i = [1, 0, 0, 0]<br>j = [1, 0.5, 0.5, 0]<br>consine_similarity([a, b])</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">3. 皮尔逊相关系数：先将两个向量都减去分别的均值，消除偏置的影响，然后再计算向量角度 consine 值。</span><br><span class="line"></span><br><span class="line">   - ![image-20210926202642997](推荐系统-Part2&#x2F;image-20210926202642997.png)</span><br><span class="line"></span><br><span class="line">   - &#96;&#96;&#96;python</span><br><span class="line">     from scipy.stats import pearsonr</span><br><span class="line">     </span><br><span class="line">     i &#x3D; [1, 0, 0, 0]</span><br><span class="line">     j &#x3D; [1, 0.5, 0.5, 0]</span><br><span class="line">     pearsonr(i, j)</span><br></pre></td></tr></table></figure></li></ul></li><li><p>其他：欧式距离、曼哈顿距离、马氏距离。</p><ul><li>欧式距离体现数值上的绝对差异，而余弦距离体现方向上的相对差异。</li><li>如果要分析两个用户对于不同视频的偏好：以观看比例作为特征时，用户A观看向量(0,1)，用户B观看向量(1,0)，此时二者的余弦距离很大，而欧式距离很小。因此，更关注相对差异，应当用余弦距离。</li><li>如果要分析用户活跃度：以登录次数和平均观看时长作为特征时，余弦距离会认为(1,10)和(10,100)两个用户距离很近，但显然这两个用户活跃度是有着极大差异的。此时我们关注的是数值绝对差异，应当使用欧式距离。</li></ul></li></ol><h3 id="最终结果预测"><a href="#最终结果预测" class="headerlink" title="最终结果预测"></a>最终结果预测</h3><ol><li>利用 用户相似度(Wu,s) 和 相似用户的评价(Rs,p) 加权平均获得用户的评价预测：<ul><li><img src="/2021/09/%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F-Part2/image-20210926211009685.png" alt="image-20210926211009685"></li></ul></li><li>在用户相似度和相似用户的评价加权平均的基础上，将用户的评价都减去此用户的所有评分的均值：<ul><li><img src="/2021/09/%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F-Part2/image-20210926211027717.png" alt="image-20210926211027717"></li></ul></li></ol><h3 id="基于用户的协同过滤"><a href="#基于用户的协同过滤" class="headerlink" title="基于用户的协同过滤"></a>基于用户的协同过滤</h3><ul><li><p>对于需要个性化推荐的用户A，可以先找到和用户A有相似兴趣的其他用户，然后把那些用户喜欢的且用户A没有听说过的物品推荐给A。</p><p><img src="/2021/09/%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F-Part2/image-20210927170929803.png" alt="image-20210927170929803"></p></li></ul><p>步骤：</p><ol><li>根据已有的用户向量，计算与目标用户的相似度，找到最相似的 n 个用户。</li><li>根据这 n 个相似用户对目标行为的分数，加权平均来预测目标用户对目标行为的分数。</li></ol><p>缺点：</p><ol><li>数据稀疏性：在大型的电子商务中物品繁多，不同用户之间买的物品重叠性低，难以找到偏好相似的用户。<strong>UserCF 不适用于那些正反馈获取较困难的应用场景</strong>。</li><li>算法扩展性：需要维护用户相似度矩阵，该矩阵的存储开销大，且随着用户数量的增加而增加。<strong>不适合用户数据量大的情况使用</strong>。</li></ol><h3 id="基于物品的协同过滤"><a href="#基于物品的协同过滤" class="headerlink" title="基于物品的协同过滤"></a>基于物品的协同过滤</h3><ul><li><p>对于需要推广的物品A，可以先找到和物品A有相似用户群体的其他物品，然后把物品A推荐给相似物品的用户群体。</p></li><li><p>减缓 UserCF 的数据稀疏性和算法扩展性问题。</p><p><img src="/2021/09/%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F-Part2/image-20210927171027279.png" alt="image-20210927171027279"></p></li></ul><p>步骤：</p><ol><li>根据已有的物品向量，计算与目标物品之间的相似度，找到最相似的 n 个物品。</li><li>根据物品的相似度和用户的历史行为给用户生成推荐列表（购买了该商品的用户也经常购买的其他商品）</li></ol><p>优点：</p><ol><li>Item-based 算法的预测结果比 User-based 算法的质量要高一点。</li><li>由于 Item-based 算法可以预先计算好物品的相似度，所以在线的预测性能比 User-based 算法高。</li></ol><p>缺点：</p><ol><li>依然存在数据稀疏性。</li><li>用户的增长也会导致物品相似度矩阵维护难度变大。</li></ol><h3 id="应用场景区别"><a href="#应用场景区别" class="headerlink" title="应用场景区别"></a>应用场景区别</h3><table><thead><tr><th></th><th>UserCF</th><th>ItemCF</th></tr></thead><tbody><tr><td>性能</td><td>适合用户较少的场合，否则维护用户相似度矩阵代价较大</td><td>适合物品数远小于用户数的场合。如果物品太多，则维护物品相似度矩阵代价大</td></tr><tr><td>领域</td><td>时效性较强、具备强社交性、用户个性化弱的场合（热点新闻、发觉潜在喜好）</td><td>兴趣变化较为稳定、物品更新慢、用户个性化强烈的领域（推荐艺术品， 音乐， 电影）</td></tr><tr><td>实时性</td><td>用户的新行为不一定对推荐结果造成立即变化</td><td>用户的新行为一定会导致推荐结果的实时变化</td></tr><tr><td>推荐理由</td><td>很难提供令用户信服的推荐结识</td><td>利用用户的历史行为为用户推荐解释，具有信服力</td></tr></tbody></table><h3 id="存在问题分析"><a href="#存在问题分析" class="headerlink" title="存在问题分析"></a>存在问题分析</h3><ol><li>无法利用更多的信息。完全没有利用到物品或者用户的自身属性，仅利用用户与物品的交互信息就可以实现推荐，是一个可解释性强，直观、但也存在问题的模型。</li><li>较差的稀疏向量处理能力，泛化能力弱。热门物品具有很强的头部效应，容易跟大量物品产生相似，而尾部物品由于特征向量稀疏，导致很少被推荐。</li></ol><h2 id="矩阵分解-MF"><a href="#矩阵分解-MF" class="headerlink" title="矩阵分解(MF)"></a>矩阵分解(MF)</h2><h3 id="基本思路"><a href="#基本思路" class="headerlink" title="基本思路"></a>基本思路</h3><ul><li>矩阵分解算法通过引入了隐向量的概念，加强了模型处理稀疏矩阵的能力，也为后续深度学习推荐系统算法中 Embedding 的使用打下了基础。</li><li>也就是加入隐含层，抽象化用户和物品之间的特征。这个特征信息需要去挖掘。</li><li>针对问题：1. 协同过滤处理稀疏向量能力差；2. 维护相似矩阵难度大</li></ul><h3 id="隐语义模型"><a href="#隐语义模型" class="headerlink" title="隐语义模型"></a>隐语义模型</h3><ul><li><p>核心思想：通过隐含特征（latent factor）联系用户兴趣和物品（item），基于用户的行为找出潜在的主题和分类，然后对 item 进行自动聚类，划分到不同类别/主题（用户的兴趣）。</p><p><img src="/2021/09/%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F-Part2/image-20210926223713170.png" alt="image-20210926223713170"></p></li><li><p>矩阵分解算法将 m×n 维的共享矩阵 R分解成 m×k 维的用户矩阵 U 和 k×n 维的物品矩阵 V 相乘的形式。其中 m 是用户数量，n 是物品数量，k是隐向量维度（隐含特征个数），只不过这里的隐含特征变得不可解释了。k 的大小决定了隐向量表达能力的强弱，k 越大，表达信息就越强。</p></li><li><p>抽象的特征使得用户和物品向量更加稠密，解决了处理稀疏向量能力差的问题。</p></li><li><p>维护相似矩阵由用户相似矩阵的 m×m 和物品矩阵的 n×n 降低到了 (m+n)×k，解决了维护相似矩阵难度大的问题。</p></li><li><p>预测评分公式：<img src="/2021/09/%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F-Part2/image-20210926224159177.png" alt="image-20210926224159177"></p></li></ul><h3 id="MF的几种方式"><a href="#MF的几种方式" class="headerlink" title="MF的几种方式"></a>MF的几种方式</h3><ul><li>特征值分解(EVD)：1. 要求矩阵是方阵，是不符合实际场景的。</li><li>奇异值分解(SVD)：1. 要求矩阵稠密，而实际场景非常稀疏。2. 一旦补全会导致空间复杂度非常高，且补得不一定正确。3. 计算复杂度非常高，基本无法使用。</li></ul><h4 id="Basic-SVD-LFM、Funk-SVD"><a href="#Basic-SVD-LFM、Funk-SVD" class="headerlink" title="Basic SVD(LFM、Funk-SVD)"></a>Basic SVD(LFM、Funk-SVD)</h4><ul><li>把矩阵分解问题转换成最优化问题，通过梯度下降进行优化。</li><li>预测函数：<img src="/2021/09/%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F-Part2/image-20210926230607417.png" alt="image-20210926230607417"></li><li>损失函数：<img src="/2021/09/%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F-Part2/image-20210926230642256.png" alt="image-20210926230642256"></li><li>优化目标：<img src="/2021/09/%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F-Part2/image-20210926230705295.png" alt="image-20210926230705295"></li><li>求梯度：<img src="/2021/09/%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F-Part2/image-20210926230925915.png" alt="image-20210926230925915"></li><li>梯度更新：<img src="/2021/09/%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F-Part2/image-20210926231028214.png" alt="image-20210926231028214"></li></ul><h4 id="RSVD"><a href="#RSVD" class="headerlink" title="RSVD"></a>RSVD</h4><ul><li>在 Basic SVD 的基础上，在目标函数中加入正则化参数（加入惩罚项），对于目标函数来说，Q矩阵和V矩阵中的所有值都是变量，这些变量在不知道哪个变量会带来过拟合的情况下，对所有变量都进行惩罚：<img src="/2021/09/%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F-Part2/image-20210926233756786.png" alt="image-20210926233756786"></li><li>梯度的更新公式就变成了：<img src="/2021/09/%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F-Part2/image-20210926233828417.png" alt="image-20210926233828417"></li></ul><p>进一步优化：</p><ul><li><p>Netfix Prize中提出了另一种LFM，在原来的基础上加了偏置项，来消除用户和物品打分的偏差，预测公式：</p><p><img src="/2021/09/%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F-Part2/image-20210926233946536.png" alt="image-20210926233946536"></p></li><li><p>这个预测公式加入了3项偏置μ,b<del>u</del>,b<del>i</del>：</p><ul><li>μ：训练集中所有记录的评分的全局平均数。在不同网站平台中， 因为网站定位和销售物品不同，网站的整体评分分布也会显示差异。比如有的网站中用户就喜欢打高分，有的网站中用户就喜欢打低分。而全局平均数可以表示网站本身对用户评分的影响。</li><li>b<del>u</del>：用户偏差系数，可以使用定值(用户 u 给出的所有评分的均值)，也可以当做训练参数。这一项表示了用户的评分习惯中和物品没有关系的那种因素。比如有些用户比较苛刻，对什么东西要求很高，那么他评分就会偏低；而有些用户比较宽容，对什么东西都觉得不错，那么评分就偏高。</li><li>b<del>i</del>：物品偏差系数，可以使用定值(物品 i 收到的所有评分的均值)，也可以当做训练参数。这一项表示了物品接受的评分中和用户没有关系的因素。比如有些物品本身质量就很高，因此获得的评分相对比较高，有的物品本身质量很差，因此获得的评分相对较低。</li></ul></li></ul><h4 id="SVD"><a href="#SVD" class="headerlink" title="SVD++"></a>SVD++</h4><ul><li>之前都是从用户和用户之间的相似度、其他用户对物品的评分进行预测推荐，而缺少考虑用户本身的历史行为对评分预测的影响。</li><li>即，之前只考虑分解当前的共现矩阵，注意：此时并没有考虑该用户评分的历史物品。</li><li>经过一系列的演化，最终预测公式为：<img src="/2021/09/%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F-Part2/image-20210927094726696.png" alt="image-20210927094726696"></li><li>其中，1/√|N(u)| 是为了保证方差一致性。</li></ul><h3 id="优点-amp-局限性"><a href="#优点-amp-局限性" class="headerlink" title="优点&amp;局限性"></a>优点&amp;局限性</h3><p>优点：</p><ol><li>泛化能力强，一定程度上解决了数据稀疏的问题，通过为用户和物品的隐语义标签抽象化了特征。</li><li>空间复杂度低。UserCF(m×m)、ItemCF(n×n) -&gt; 用户隐向量(m×k) + 物品隐向量(n×k)</li><li>更好的扩展性和灵活性。可以和其他特征组合拼接，与深度学习网络无缝结合。</li></ol><p>局限性：</p><ol><li>与协同过滤一样，无法利用用户特征、物品特征、上下文特征。</li><li>缺乏用户历史行为时，无法推荐。</li></ol><h2 id="逻辑回归-LR"><a href="#逻辑回归-LR" class="headerlink" title="逻辑回归(LR)"></a>逻辑回归(LR)</h2><h3 id="基本思想-1"><a href="#基本思想-1" class="headerlink" title="基本思想"></a>基本思想</h3><ul><li>基础知识：逻辑回归、极大似然估计。<ul><li>逻辑回归做为神经网络中的最基础单一神经元</li><li>逻辑回归假设数据服从伯努利分布，通过极大化似然函数的方法，运用梯度下降来求解参数，来达到将数据二分类的目的。</li></ul></li><li>针对问题：协同过滤无法有效利用用户、物品、上下文等多种不同的特征。</li><li>改进方向：将推荐问题转化成了一个二分类问题。</li></ul><h3 id="推荐过程"><a href="#推荐过程" class="headerlink" title="推荐过程"></a>推荐过程</h3><ol><li><p>将用户年龄、性别、物品属性、物品描述、当前时间、当前地点等特征转成数值型向量。</p></li><li><p>确定逻辑回归的优化目标，比如把点击率预测转换成二分类问题，这样就可以得到分类问题常用的损失作为目标，训练模型。</p></li><li><p>在预测的时候，将特征向量输入模型产生预测，得到用户“点击”物品的概率。</p></li><li><p>利用点击概率对候选物品排序，得到推荐列表。</p><p><img src="/2021/09/%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F-Part2/image-20210927171345229.png" alt="image-20210927171345229"></p></li></ol><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ol><li>LR模型形式简单，可解释性好，从特征的权重可以看到不同的特征对最后结果的影响。</li><li>训练时便于并行化，在预测时只需要对特征进行线性加权，性能好，适合处理海量id类特征。用id类特征有一个很重要的好处，就是防止信息损失（相对于范化的 CTR 特征），对于头部资源会有更细致的描述。</li><li>资源占用小，尤其是内存。在实际的工程应用中只需要存储权重比较大的特征及特征对应的权重。</li><li>方便输出结果调整。逻辑回归可以很方便的得到最后的分类结果，因为输出的是每个样本的概率分数，我们可以很容易的对这些概率分数进行cutoff，也就是划分阈值。</li><li>工程化需要。在深度学习技术之前，逻辑回归凭借易于并行化、模型简单、训练开销小等特点，占领工程领域的主流。因为即使工程团队发现了复杂模型会提升效果，但一般如果没有把握击败逻辑回归的话仍然不敢尝试或者升级。</li></ol><h3 id="局限性"><a href="#局限性" class="headerlink" title="局限性"></a>局限性</h3><ol><li>表达能力不强，无法进行特征交叉、特征筛选等一系列高级操作，因此可能造成信息的损失。</li><li>准确率并不是很高。因为这毕竟是一个线性模型加了个 sigmoid，形式非常的简单，很难去拟合数据的真实分布。</li><li>处理非线性数据较麻烦。逻辑回归在不引入其他方法的情况下，只能处理线性可分的数据，如果想处理非线性，首先对连续特征的处理需要先进行离散化，而人工分桶的方式会引入多种问题。</li><li>LR 需要进行人工特征组合，这就需要开发者有非常丰富的领域经验，才能不走弯路。这样的模型迁移起来比较困难，换一个领域又需要重新进行大量的特征工程。</li></ol><h2 id="自动特征交叉"><a href="#自动特征交叉" class="headerlink" title="自动特征交叉"></a>自动特征交叉</h2><h3 id="基本思想-2"><a href="#基本思想-2" class="headerlink" title="基本思想"></a>基本思想</h3><ul><li><p>该算法属于对逻辑回归(LR)算法应用在推荐系统上的一个改进，在LR模型的基础上加上了特征交叉项，该思想不仅在传统的推荐算法中继续使用过，在深度学习推荐算法中也对其进行了改进与应用。</p></li><li><p>针对问题：逻辑回归只对单一特征做简单加权，不具备特征交叉生成组合特征的能力，因此表达能力受到了限制。</p></li><li><p>如：“化妆品”类商品与“女”性，“球类运动配件”的商品与“男”性，“电影票”的商品与“电影”品类偏好……</p></li></ul><h3 id="POLY2——特征交叉的开始"><a href="#POLY2——特征交叉的开始" class="headerlink" title="POLY2——特征交叉的开始"></a>POLY2——特征交叉的开始</h3><ul><li>POLY2是二阶多项式模型，对所有特征进行两两交叉、暴力组合。</li><li>针对问题：在逻辑回归里面，如果想得到组合特征，往往需要人工在特征工程的时候手动的组合特征，然后再进行筛选，低效且玄学。</li><li>数学形式：<img src="/2021/09/%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F-Part2/image-20210927165630280.png" alt="image-20210927165630280"></li><li>优点：<ol><li>保留了逻辑回归的优点：充分利用用户特征、物品特征、上下文特征。</li><li>一定程度上解决了特征组合的问题。</li></ol></li><li>存在问题：<ol><li>推荐系统中的数据稀疏性是实际问题中不可避免的挑战(类别型数据经过独热），经过特征较差之后特征向量更加稀疏，使得大部分特征交叉的权重缺乏有效训练，无法收敛。</li><li>训练复杂度由 O(n) 上升到 O(n^2^)</li></ol></li></ul><h3 id="FM——隐向量特征交叉"><a href="#FM——隐向量特征交叉" class="headerlink" title="FM——隐向量特征交叉"></a>FM——隐向量特征交叉</h3><ul><li>因子分解机(Factorization Machine, FM)</li><li>针对问题：1. 在面对稀疏数据向量时，PLOY2特征交叉项无法收敛。2. PLOY2 计算复杂度过高。</li><li>数学模型：<img src="/2021/09/%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F-Part2/image-20210927172557690.png" alt="image-20210927172557690" style="zoom:67%;"></li><li>优点：<ol><li>极大降低了训练开销 O(n^2^) -&gt; O(kn)</li><li>引入隐向量，更好地解决数据稀疏性的问题</li><li>FM 模型是利用两个特征的 Embedding 做内积得到二阶特征交叉的权重。可以将训练好的 FM 特征离线训练保存，以便其他拓展。</li></ol></li></ul><h3 id="FFM——引入特征域"><a href="#FFM——引入特征域" class="headerlink" title="FFM——引入特征域"></a>FFM——引入特征域</h3><ul><li><p>域感知因子分解机(Field-aware Factorization Machine, FFM)</p></li><li><p>先对特征根据性质的不同进行了一个分类，不同的分类就是不同的域，域内特征一般都是同一个 categorical 特征经过 One-Hot 编码生成的数值特征。</p><p>对于连续特征，一个特征就对应一个域；或者可以对连续特征离散化，一个分箱成为一个特征，总的分箱是一个域。</p><p><img src="/2021/09/%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F-Part2/image-20210927185945062.png" alt="image-20210927185945062"></p></li><li><p>改进方向：针对不同的交叉域要学习不同的隐向量特征</p></li><li><p>优点：引入了更多有价值的信息，表达能力更强。</p></li><li><p>缺点：</p><ol><li>参数量：FM: k×n -&gt; FFM: f×k×n</li><li>时间复杂度：FM: O(kn) -&gt; FFM: O(kn^2^)</li><li>局限在二阶特征交叉</li></ol></li><li><p>工业改进：</p><ol><li>模型上：双线性FFM(新浪微博张俊林团队)，减少参数量的一种优化思路，共享W矩阵。</li><li>业务上：对特征域再进行抽象，减少域的数量。比如说，对 100 个域进行再分类，分为上下文特征、用户特征、item特征、交互特征和匹配特征五大类，实际应用时只考虑这 5 个域即可。</li></ol></li></ul><h2 id="GBDT-LR"><a href="#GBDT-LR" class="headerlink" title="GBDT+LR"></a>GBDT+LR</h2><h3 id="基本思想-3"><a href="#基本思想-3" class="headerlink" title="基本思想"></a>基本思想</h3><ul><li>该模型仍然是对LR模型的改进，使用树模型做特征交叉，相比于 FM 的二阶特征交叉，树模型可以对特征进行深度的特征交叉，充分利用了特征之间的相关性。</li><li>针对问题：<ol><li>LR 模型无法进行特征交叉、特征筛选等一些列操作。</li><li>FM、FFM只能做二姐特征交叉，如果继续提高特征交叉的维度，会不可避免地出现组合爆炸和计算复杂度过高的问题。</li></ol></li></ul><h3 id="GBDT"><a href="#GBDT" class="headerlink" title="GBDT"></a>GBDT</h3><ul><li><p>GBDT 全称梯度提升决策树，在传统机器学习算法里面是对真实分布拟合的最好的几种算法之一。</p><ul><li>GBDT 每轮的训练是在上一轮的训练的残差基础之上进行训练的。</li><li>GBDT 无论用于分类还是回归一直都是使用的 CART 回归树。</li></ul><p><img src="/2021/09/%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F-Part2/image-20210927191924299.png" alt="image-20210927191924299"></p></li><li><p>优点：可以自动进行多维度特征的发掘与有效组合。</p></li><li><p>局限性：</p><ol><li>对于海量的 id 类特征，GBDT 由于树的深度和棵树限制（防止过拟合），不能有效的存储</li><li>另外海量特征在也会存在性能瓶颈，当 GBDT 的 one hot 特征大于 10 万维时，就必须做分布式的训练才能保证不爆内存。</li></ol><p>所以 GBDT 通常配合少量的反馈 CTR 特征来表达，这样虽然具有一定的范化能力，但是同时会有信息损失，对于头部资源不能有效的表达。</p></li></ul><h3 id="GBDT-LR-1"><a href="#GBDT-LR-1" class="headerlink" title="GBDT+LR"></a>GBDT+LR</h3><ul><li>GBDT和LR的优缺点可以进行互补</li><li><img src="/2021/09/%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F-Part2/image-20210927192931637.png" alt="image-20210927192931637"></li><li>训练：GBDT 建树的过程相当于自动进行的特征组合和离散化，从根结点到叶子节点的这条路径就可以看成是不同特征进行的特征组合。用叶子节点可以唯一地表示这条路径，并作为一个离散特征传入 LR 进行二次训练。（GBDT 和 LR 是分两步进行训练的，所以不存在 LR 梯度回传至 GBDT）</li><li>预测：会先走 GBDT 的每棵树，得到某个叶子节点对应的一个离散特征(即一组特征组合)，然后把该特征以 one-hot 形式传入 LR 进行线性加权预测。</li><li>优点：<ol><li>大大推进了特征工程模型化这一重要趋势。意味着特征工程可以完全交由一个模型独立完成，模型的输入可以是原始的特征向量，不必在特征工程上投入过多的人工筛选和模型设计的精力。</li><li>在一定程度上解决了高阶特征交叉的问题。</li></ol></li><li>缺点：容易过拟合。</li></ul><h2 id="LS-PLM-MLR"><a href="#LS-PLM-MLR" class="headerlink" title="LS-PLM(MLR)"></a>LS-PLM(MLR)</h2><ul><li><p>针对问题：LR 表达能力差</p></li><li><p>解决思路：</p><ul><li>通过聚类，构造带权 LR。</li><li>在逻辑回归的基础上，采用分而治之的思路：先对样本进行聚类，在对样本分片中应用逻辑回归进行 CTR 预估。</li><li>目的：让 CTR 预估模型对不同的用户群体、不同的应用场景更有针对性。</li></ul></li><li><p>预测函数：<img src="/2021/09/%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F-Part2/image-20210927194722571.png" alt="image-20210927194722571"></p></li><li><p>优点：</p><ol><li>端到端的非线性学习能力</li><li>稀疏性强，部署更加轻量级</li></ol></li><li><p>提升模型性能的 trick：</p><ol><li><p>结构化先验增量训练（用户特征进行训练，广告特征进行分类）</p><img src="/2021/09/%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F-Part2/image-20210927195859754.png" alt="image-20210927195859754" style="zoom: 80%;"></li><li><p>线性偏置</p></li><li><p>模型级联</p></li></ol></li></ul>]]></content>
      
      
      <categories>
          
          <category> 推荐系统 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>推荐系统-Part1</title>
      <link href="/2021/09/%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F-Part1/"/>
      <url>/2021/09/%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F-Part1/</url>
      
        <content type="html"><![CDATA[<h1 id="推荐系统-Part1——概述"><a href="#推荐系统-Part1——概述" class="headerlink" title="推荐系统-Part1——概述"></a>推荐系统-Part1——概述</h1><p>[TOC]</p><h2 id="推荐系统概述"><a href="#推荐系统概述" class="headerlink" title="推荐系统概述"></a>推荐系统概述</h2><h3 id="传统推荐模型"><a href="#传统推荐模型" class="headerlink" title="传统推荐模型"></a>传统推荐模型</h3><p>传统推荐模型化关系图：<img src="/2021/09/%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F-Part1/Javaimage-20200923143443499.png" alt="img"></p><ol><li>协同过滤</li><li>矩阵分解算法——协同过滤的进化</li><li>逻辑回归——融合多种特征的推荐模型</li><li>PLOY2、FM、FFM——自动特征交叉</li><li>GBDT+LR——特征工程模型化的开端</li><li>LS-PLM(MLR)——混合逻辑回归</li></ol><h3 id="深度学习推荐模型"><a href="#深度学习推荐模型" class="headerlink" title="深度学习推荐模型"></a>深度学习推荐模型</h3><p>模型发展时间线：<img src="/2021/09/%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F-Part1/Javaimage-20200923143559968.png" alt="img"></p><ol><li>AutoRec、DeepCrossing——改变神经网络复杂程度</li><li>NeuralCF、PNN——改变特征交叉方式</li><li>Wide&amp;Deep、Deep&amp;Cross——记忆与泛化并存</li><li>FNN、DeepFM、NFM——FM 在深度学习中的身影重现</li><li>AFM、DIN——当推荐系统遇上注意力机制</li><li>DIEN——序列模型与推荐系统的火花碰撞</li></ol><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>随着信息技术和互联网的发展，我们已经步入了一个信息过载的时代，无论是信息消费者还是信息生产者都遇到了很大的挑战：</p><ul><li>信息消费者：希望从大量的信息中找到自己感兴趣的信息。</li><li>信息生产者：希望让自己生产的信息脱颖而出，受到广大用户的关注。</li></ul><p>推荐系统，是缓解信息过载的重要技术。通过分析用户的历史行为给用户的兴趣建模，从而主动给用户推荐给能够满足他们兴趣和需求的信息。一方面帮助用户发现对自己有价值的信息，一方面让信息能够展现在对它感兴趣的用户前面。</p><h2 id="论文要求"><a href="#论文要求" class="headerlink" title="论文要求"></a>论文要求</h2><p>随着互联网、物联网、区块链、大数据、人工智能、5G技术的不断发展，特别是移动网络的发展，信息量成爆炸式增长。作为缓解信息过载的重要技术，推荐系统目前已经在健康、智能交通、教育、电子商务等领域有相当成功的应用。然而随着用户需求的持续变化，传统的推荐算法面临一些新的问题，如冷启动、推荐新颖度不够、数据稀疏等。针对这些问题，学者们将新技术应用于推荐系统中，产生了一批新的推荐方法。探讨如何将这些新的理论、方法及技术应用于推荐系统，对更好地提供个性化推荐服务具有积极的指导意义和重要的实践价值，也将促进智能时代的信息技术的持续发展。 </p><p>《武汉大学学报（理学版）》是国内知名期刊，也是北大核心期刊和CSCD-C收录期刊。《武汉大学学报（理学版）》与中国软件大会（ChinaSoft2021）合作征稿，计划于2021年出版“面向人工智能的推荐系统前沿研究”专题。本专题将收录国内外有关推荐系统研究领域创新性和突破性的高水平研究成果，深入探讨推荐系统相关基础理论、关键技术以及支撑平台等方面创新成果，并探讨相关成果在产业界的应用前景。读者群体包括软件工程、人工智能、服务计算等相关领域的专家学者、研究人员和专业工程师等。欢迎从事该领域研究的学者积极投稿。 </p><p>一、征文范围 </p><p>包括但不限于以下主题： </p><p>（1）  推荐系统的理论性研究 </p><p>（2）  面向时间序列的推荐系统研究 </p><p>（3）  基于因果推断的推荐系统研究 </p><p>（4）  面向工业领域的推荐系统及决策研究 </p><p>（4）  基于推荐系统的软件工程 </p><p>二、投稿要求 </p><p>（1）  论文应属于作者的科研成果，未在国内外公开发行的刊物或会议上发表，不存在一稿多投问题。 </p><p>（2）  论文一律用word格式排版，格式体例参考近期出版的《武汉大学学报（理学版）》的要求。<a href="http://whdy.cbpt.cnki.net/WKD/WebPublication/index.aspx?mid=whdy">http://whdy.cbpt.cnki.net/WKD/WebPublication/index.aspx?mid=whdy</a> </p><p>（3）  投稿和评审方式：本专题投稿论文需经过两轮投稿和评审。 </p><p>三、论文截止时间：10月10号 </p><p>四、投稿方式： </p><p>编 辑 部： <a href="mailto:whdz@whu.edu.cn">whdz@whu.edu.cn</a>, 027-68752220          </p><p>通信地址：武汉大学本科生院楼北楼《武汉大学学报（理学版）》编辑部，430072 </p><p>特邀编委：黄 勃   副教授   上海工程技术大学  <a href="mailto:huangbosues@sues.edu.cn">huangbosues@sues.edu.cn</a>   </p><p>​               武 星   副教授   上海大学  <a href="mailto:xingwu@shu.edu.cn">xingwu@shu.edu.cn</a></p>]]></content>
      
      
      <categories>
          
          <category> 推荐系统 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>PyTorch-完结目录</title>
      <link href="/2021/09/PyTorch-%E5%AE%8C%E7%BB%93%E7%9B%AE%E5%BD%95/"/>
      <url>/2021/09/PyTorch-%E5%AE%8C%E7%BB%93%E7%9B%AE%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<h1 id="PyTorch-完结目录"><a href="#PyTorch-完结目录" class="headerlink" title="PyTorch-完结目录"></a>PyTorch-完结目录</h1>]]></content>
      
      
      <categories>
          
          <category> PyTorch </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>PyTorch-Part3</title>
      <link href="/2021/09/PyTorch-Part3/"/>
      <url>/2021/09/PyTorch-Part3/</url>
      
        <content type="html"><![CDATA[<h1 id="PyTorch-Part3——TensorFlow转PyTorch"><a href="#PyTorch-Part3——TensorFlow转PyTorch" class="headerlink" title="PyTorch-Part3——TensorFlow转PyTorch"></a>PyTorch-Part3——TensorFlow转PyTorch</h1><p>[TOC]</p><h2 id="函数对应"><a href="#函数对应" class="headerlink" title="函数对应"></a>函数对应</h2><p>TensorFlow - tf.reshape 函数 &amp; Pytorch - torch.reshape 函数</p><p>TensorFlow - tf.concat 函数 &amp; Pytorch - torch.cat 函数</p><p>TensorFlow - tf.abs 函数 &amp;</p><ul><li>针对张量的每一位的元素分别计算其绝对值，并输出原格式的新张量。</li></ul><p>TensorFlow - tf.expand_dims 函数 &amp; torch.unsqueeze</p><ul><li><p>TensorFlow - tf.less 函数 &amp;<br>torch.le same as torch.ge — &gt;=<br>torch.lt same as torch.gt — &gt;<br>与torch.min相同的是，其均是用来比较两个张量每一位元素的最小值，不同的是tf.less输出的是是否为最小值的bool值，torch.min是输出两元素中的最小值并重新组合成张量。<br>返回值： 一个 torch.ByteTensor 张量，包含了每个位置的比较结果(是否 input &gt;= other )。 返回类型： Tensor</p></li><li><p>torch.le(input, other, out=None) -&gt; Tensor:</p></li><li><p>逐元素比较input和other，即是否input &lt;= other，第二个参数可以为一个数或与第一个参数相同形状和类型的张量。</p></li><li><p>torch.lt(input, other, out=None) -&gt; Tensor:</p></li><li><p>逐元素比较input和other，即是否input &lt; other</p></li></ul><p>TensorFlow - tf.equal 函数 &amp; torch.equal</p><ul><li>若两个张量有相同的形状和元素值，则返回True， 否则False。</li></ul><p>TensorFlow - tf.greater_equal 函数 &amp; torch.ge torch.gt</p><ul><li>逐元素比较input和other，是否input &gt; other。若两个张量有相同的形状和元素值，则返回True，否则False。</li></ul><p>TensorFlow - tf.norm 函数 &amp; torch.norm</p><p>TensorFlow - tf.argmin 函数 &amp; torch.argmin</p><p>TensorFlow - tf.gather_nd 函数 &amp;</p><ul><li><p>目前torch中自带的同类型函数只有torch.gather，用于处理指定一维度，无gather_nd的用法，但开源工具torchsample中则加入了类似的函数th_gather_nd，模仿tensorflow中的使用，详见：<br>torchsample推荐安装，有点类似于tf中的keras，提供高级api，减少开发时间，实用。</p><p>Pytorch的高级训练，数据增强和实用程序(torchsample/Keras)</p></li></ul><p>TensorFlow - tf.gather 函数 &amp; torch.gather</p><ul><li>根据索引从参数轴上收集切片.</li></ul><p>TensorFlow - tf.shape 函数 &amp; torch.size</p><p>TensorFlow - tf.range 函数 &amp; torch.arange / torch.range</p><p>TensorFlow - tf.stack 函数 &amp; torch.stack</p><p>TensorFlow - tf.reduce_mean 函数 &amp; torch.mean</p><p>TensorFlow - tf.cast 函数 &amp;</p><ul><li>torch中没有相似的类型转换函数，直接使用torch.FloatTensor()或data.float()类似的进行转换就可以了。</li></ul><p>TensorFlow - tf.count_nonzero 函数 &amp; torch.nonzero</p><ul><li>计算并输出各个维度上非０元素的个数。</li></ul><p>TensorFlow - tf.tile 函数 &amp; Tensor.repeat()</p><p>Tensorflow tf.where &amp; torch.le / torch.lt</p><p>Tensorflow tf.nn.in_top_k</p><ul><li><p>tensorflow    pytroch<br>tf.reshape(input, shape)    input.view()<br>tf.expand_dims(input, dim)    input.unsqueeze(dim) / input.view()<br>tf.squeeze(input, dim)    torch.squeeze(dim)/ input.view()<br>tf.gather(input1, input2)    input1[input2]<br>tf.tile(input, shape)    input.repeat(shape)<br>tf.boolean_mask(input, mask)    input[mask] #注意，mask是bool值，不是0,1的数值<br>tf.concat(input1, input2)    torch.cat(input1, input2)<br>tf.matmul()    torch.matmul()<br>tf.minium(input, min)    torch.clamp(input, max=min)<br>tf.equal(input1, input2)    torch.eq(input1, input2)/ input1 == input2<br>tf.logical_and(input1, input2)    input1 &amp; input2<br>tf.logical_not(input)    ~ input<br>tf.reduce_logsumexp(input, [dim])    torch.logsumexp(input, dim=dim)<br>tf.reduce_any(input, dim)    input.any(dim)<br>tf.reduce_mean(input)    torch.mean(input)<br>tf.reduce_sum(input)    input.sum()<br>tf.transpose(input)    input.t()<br>tf.softmax_cross_entroy_with_logits(logits, labels)    torch.nn.CrossEntropyLoss(logits, labels)</p></li><li><p>获取词向量：</p></li><li><p>tensorflow中: input_emb = tf.gather(tf.get_variable(“input_emb”, [num, embedding_size]), input)<br>pytorch中：1.embedding = nn.Embedding(num, embedding_size)，2.input_emb = embedding (input)<br>只是初始化embedding矩阵</p></li><li><p>tensorflow中: input_emb = tf.get_variable(“input_emb”, [num, embedding_size])<br>pytorch中：1.embedding = nn.Embedding(num, embedding_size)， 2.input_emb = embedding .weight</p></li><li><p>基本重构完成代码之后，检查代码以下方面：</p><ol><li>👌 初始化网络权重是否正确</li><li>👌 如果有预训练模型，检查是否加载正确</li><li>👌 检查优化器，整个任务是相同的学习率，还是说是不同层，设置了不同的学习率</li><li>👌 如果数据预处理也需要改动，最好也检查一下预处理是否正确</li></ol></li></ul><p><a href="https://blog.csdn.net/qq_41895190/article/details/89954394">https://blog.csdn.net/qq_41895190/article/details/89954394</a></p><blockquote><p>两个 tf 流程</p><ol><li><a href="https://www.cnblogs.com/tengge/p/6376073.html">https://www.cnblogs.com/tengge/p/6376073.html</a></li><li><a href="https://blog.csdn.net/lcczzu/article/details/91449731">https://blog.csdn.net/lcczzu/article/details/91449731</a></li></ol></blockquote><h2 id="常见的loss问题"><a href="#常见的loss问题" class="headerlink" title="常见的loss问题"></a>常见的loss问题</h2><h3 id="train-loss与test-loss结果分析"><a href="#train-loss与test-loss结果分析" class="headerlink" title="train loss与test loss结果分析"></a>train loss与test loss结果分析</h3><p>train loss 不断下降，test loss不断下降，说明网络仍在学习;</p><p>train loss 不断下降，test loss趋于不变，说明网络过拟合;</p><p>train loss 趋于不变，test loss不断下降，说明数据集100%有问题;</p><p>train loss 趋于不变，test loss趋于不变，说明学习遇到瓶颈，需要减小学习率或批量数目;</p><p>train loss 不断上升，test loss不断上升，说明网络结构设计不当，训练超参数设置不当，数据集经过清洗等问题。</p><p>二，<br>这个比较长，比较完整 Loss和神经网络训练</p><p><a href="https://blog.csdn.net/u011534057/article/details/51452564">https://blog.csdn.net/u011534057/article/details/51452564</a></p><p>有1.梯度检验2.训练前检查，3.训练中监控4.首层可视化5.模型融合和优化等等等</p><p>三，<a href="https://www.zhihu.com/question/38937343">https://www.zhihu.com/question/38937343</a></p><p>四，<a href="https://blog.csdn.net/u010911921/article/details/71079367">https://blog.csdn.net/u010911921/article/details/71079367</a></p><p>原文地址：<a href="http://blog.csdn.net/u010911921/article/details/71079367">http://blog.csdn.net/u010911921/article/details/71079367</a><br>这段在使用caffe的时候遇到了两个问题都是在训练的过程中loss基本保持常数值，特此记录一下。</p><p>1.loss等于87.33不变<br>loss等于87.33这个问题是在对Inception-V3网络不管是fine-tuning还是train的时候遇到的，无论网络迭代多少次，网络的loss一直保持恒定。</p><p>查阅相关资料以后发现是由于loss的最大值由FLT_MIN计算得到，FLT_MIN是其对应的自然对数正好是-87.3356，这也就对应上了loss保持87.3356了。</p><p>这说明softmax在计算的过程中得到了概率值出现了零，由于softmax是用指数函数计算的，指数函数的值都是大于0的，所以应该是计算过程中出现了float溢出的异常，也就是出现了inf，nan等异常值导致softmax输出为0.</p><p>当softmax之前的feature值过大时，由于softmax先求指数，会超出float的数据范围，成为inf。inf与其他任何数值的和都是inf，softmax在做除法时任何正常范围的数值除以inf都会变成0.然后求loss就出现了87.3356的情况。</p><p>解决办法</p><p>由于softmax输入的feature由两部分计算得到：一部分是输入数据，另一部分是各层的权值等组成</p><p>减小初始化权重，以使得softmax的输入feature处于一个比较小的范围</p><p>降低学习率，这样可以减小权重的波动范围</p><p>如果有BN(batch normalization)层，finetune时最好不要冻结BN的参数，否则数据分布不一致时很容易使输出值变得很大(注意将batch_norm_param中的use_global_stats设置为false )。</p><p>观察数据中是否有异常样本或异常label导致数据读取异常</p><p>本文遇到的情况采用降低学习率的方法，learning rate设置为0.01或者原来loss的或者。</p><p>2.loss保持0.69左右<br>采用VGG-16在做一个二分类问题,所以计算loss时等价与下面的公式：</p><p>当p=0.5时，loss正好为0.693147，也就是训练过程中，无论如何调节网络都不收敛。最初的网络配置文件卷积层的参数如下所示：</p><p>从VGG-16训练好的模型进行fine-tuning也不发生改变，当在网络中加入初始化参数和decay_mult以后再次训练网络开始收敛。</p><p>但是具体是什么原因造成的，暂时还没有找到，难道是初始化参数的问题还是？</p><p>参考资料<br><a href="http://blog.csdn.net/jkfdqjjy/article/details/52268565?locationNum=14">http://blog.csdn.net/jkfdqjjy/article/details/52268565?locationNum=14</a></p><p><a href="https://groups.google.com/forum/#!topic/caffe-users/KEgrRlwXz9c">https://groups.google.com/forum/#!topic/caffe-users/KEgrRlwXz9c</a></p><p><a href="https://www.zhihu.com/question/68603783">https://www.zhihu.com/question/68603783</a></p><p>loss一直不下降的原因有很多，可以从头到尾滤一遍： 1）数据的输入是否正常，data和label是否一致。 2）网络架构的选择，一般是越深越好，也分数据集。 并且用不用在大数据集上pre-train的参数也很重要的 3）loss 对不对。</p><p>具体到语音，很多是把audio转成频谱图送给CNN训练。</p><p>NIPS16 有个soundNet(torch的code)，语音分类的performance很高，我觉得可以用来初始化你的model 参数, 可以参考下。</p><p>还有我见的3D-CNN 多用于视频，做audio 用3D 的工作比较少，倒是见过是用1维卷积做audio的</p><blockquote><p><a href="https://blog.csdn.net/u011534057/article/details/51452564/">https://blog.csdn.net/u011534057/article/details/51452564/</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> PyTorch </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>PyTorch-Part2</title>
      <link href="/2021/09/PyTorch-Part2/"/>
      <url>/2021/09/PyTorch-Part2/</url>
      
        <content type="html"><![CDATA[<h1 id="PyTorch-Part2——Pytorch模型训练"><a href="#PyTorch-Part2——Pytorch模型训练" class="headerlink" title="PyTorch-Part2——Pytorch模型训练"></a>PyTorch-Part2——Pytorch模型训练</h1><p>[TOC]</p><h2 id="数据-Data"><a href="#数据-Data" class="headerlink" title="数据(Data)"></a>数据(Data)</h2><h3 id="数据集划分"><a href="#数据集划分" class="headerlink" title="数据集划分"></a>数据集划分</h3><ul><li><p>严谨的人工智能模型应用应当划分训练集(train set)、测试集(test set)和验证集(valid/dev set)三部分。</p></li><li><p>训练集就用来训练模型，测试集是用来估计模型在实际应用中的泛化能力，而验证集是用于模型选择和调参的。</p><p>在研究过程中，验证集和测试集作用都是一样的，只是对模型的泛化能力进行一个观测。</p><p>而当在工程应用中，由于尽可能地用尽所有数据集并迭代，要防止模型过拟合到测试集上，要有验证集对其进行约束。</p></li><li><p>可以使用 <code>train : test : valid = 8 : 1 : 1</code> 这个比例。</p></li></ul><blockquote><p><a href="https://blog.csdn.net/u011995719/article/details/77451213">https://blog.csdn.net/u011995719/article/details/77451213</a></p></blockquote><h3 id="PyTorch读取数据集"><a href="#PyTorch读取数据集" class="headerlink" title="PyTorch读取数据集"></a>PyTorch读取数据集</h3><ul><li><p>自定义数据集要继承 <code>Dataset</code> 类，并重写 <code>__getitem__()</code> 和 <code>__len__()</code> 方法</p><ul><li><code>__init__()</code>：生成数据的路径列表，尤其对于非结构化数据集，不能直接将所有数据读入内存。</li><li><code>__getitem__()</code>：由 DataLoader 进行调用，返回相应索引的数据，同时进行一系列的数据增强扩充数据集的多样性。</li><li><code>__len__()</code>：提供数据集长度的查询。</li></ul></li><li><p>读取数据流程：</p><ol><li><p>在 MyDataset 中初始化图片路径和标签、数据增强方式</p></li><li><p>在 DataLoader 中初始化 num_workers、shuffle、batch_size、sampler、batch_sampler、collate_fn。即多进程读取数据、采样与拼接方法。</p><p>在 sampler 中会调用到 MyDataset 的 <code>__len__()</code> 方法。</p></li><li><p>在 iteration 进行时，DataLoder 才读取一个 batch 的图片数据。由 batch_sampler 与 collate_fn 确定一个 batch 的 indices 并进行拼接。</p><p>在 collate_fn 中会调用 MyDataset 类中的 <code>__getitem__()</code> 方法。</p></li></ol></li><li><p>在训练时，一般要对图片进行以下操作：</p><ol><li>随机裁剪</li><li>ToTensor：包含①[h, w, c] -&gt; [c, h, w]；② /255：归一化至 0~1 区间。</li><li>数据标准化(减均值，除以标准差)</li></ol></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"><span class="keyword">from</span> torch.utils.data <span class="keyword">import</span> Dataset</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyDataset</span>(<span class="params">Dataset</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, txt_path, transform=<span class="literal">None</span>, target_transform=<span class="literal">None</span></span>):</span></span><br><span class="line">        fh = <span class="built_in">open</span>(txt_path, <span class="string">&#x27;r&#x27;</span>)</span><br><span class="line">        imgs = []</span><br><span class="line">        <span class="keyword">for</span> line <span class="keyword">in</span> fh:</span><br><span class="line">            line = line.rstrip()</span><br><span class="line">            words = line.split()</span><br><span class="line">            imgs.append((words[<span class="number">0</span>], <span class="built_in">int</span>(words[<span class="number">1</span>])))</span><br><span class="line"></span><br><span class="line">        self.imgs = imgs  <span class="comment"># 最主要就是要生成这个list， 然后DataLoader中给index，通过getitem读取图片数据</span></span><br><span class="line">        self.transform = transform</span><br><span class="line">        self.target_transform = target_transform</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getitem__</span>(<span class="params">self, index</span>):</span></span><br><span class="line">        fn, label = self.imgs[index]</span><br><span class="line">        img = Image.<span class="built_in">open</span>(fn).convert(<span class="string">&#x27;RGB&#x27;</span>)  <span class="comment"># 像素值 0~255，在transfrom.totensor会除以255，使像素值变成 0~1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> self.transform <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            img = self.transform(img)  <span class="comment"># 在这里做transform，转为tensor等等</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> img, label</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__len__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(self.imgs)</span><br></pre></td></tr></table></figure><h3 id="transforms-的二十二个方法-干货"><a href="#transforms-的二十二个方法-干货" class="headerlink" title="transforms 的二十二个方法(干货)"></a>transforms 的二十二个方法(干货)</h3><ol><li>裁剪——Crop<ul><li>中心裁剪：<code>transforms.CenterCrop(size)</code><ul><li><strong>size-</strong> (sequence or int)，若为 sequence，则为(h,w)，若为 int，则(size,size)</li></ul></li><li>随机裁剪：<code>transforms.RandomCrop(size, padding=None, pad_if_needed=False, fill=0, padding_mode=&#39;constant&#39;)</code><ul><li><strong>size-</strong> (sequence or int)，若为 sequence，则为(h,w)，若为 int，则(size,size)</li><li><strong>padding-</strong>(sequence or int, optional)，当为 int时， 例如padding=a时，图片上下左右均填充a个像素；当为tupple时，(a, b)，则左右填充a个像素，上下填充b个像素；(a, b, c, d)， 则左填充a个像素，下填充b个像素，右填充c个像素, 上填充d个像素。</li><li><strong>fill-</strong> (int or tuple)，填充的值（仅当padding_mode=’constant’）。int 时，各通道均填充该值，当长度为 3 的 tuple 时，表示 RGB 通道需要填充的值。</li><li><strong>padding_mode-</strong> 填充模式：1. constant，常量。2. edge，按照图片边缘的像素值来填充。3. reflect，镜像填充，最后一个像素不镜像。 4. symmetric，最后一个像素镜像。</li></ul></li><li>随机长宽比裁剪：<code>transforms.RandomResizedCrop(size, scale=(0.08, 1.0), ratio=(0.75, 1.33), interpolation=2) </code><ul><li><strong>size-</strong> 所需裁剪图片尺寸。</li><li><strong>scale-</strong> 随机裁剪面积比例，默认scale=(0.08, 1.0)，表示随机 crop 出来的图片会在的 0.08倍至 1 倍之间。</li><li><strong>ratio-</strong> 随机长宽比设置，默认(3/4, 4/3)</li><li><strong>interpolation</strong>- 插值的方法，默认为双线性插值(PIL.Image.BILINEAR)</li></ul></li><li>上下左右中心裁剪：<code>transforms.FiveCrop(size)</code><ul><li><strong>size-</strong> (sequence or int)，若为 sequence,则为(h,w)，若为 int，则(size,size)</li></ul></li><li>上下左右中心裁剪后翻转：<code>transforms.TenCrop(size, vertical_flip=False)</code><ul><li><strong>size-</strong> (sequence or int)，若为 sequence,则为(h,w)，若为 int，则(size,size)</li><li><strong>vertical_flip</strong>- (bool)，是否垂直翻转，默认为 flase，即默认为水平翻转</li></ul></li></ul></li><li>翻转和旋转——Flip and Rotation<ul><li>依概率 p 水平翻转：<code>transforms.RandomHorizontalFlip(p=0.5)</code><ul><li><strong>p-</strong> 概率，默认值为 0.5</li></ul></li><li>依概率 p 垂直翻转：<code>transforms.RandomVerticalFlip(p=0.5)</code><ul><li><strong>p-</strong> 概率，默认值为 0.5</li></ul></li><li>随机旋转：<code>transforms.RandomRotation(degrees, resample=False, expand=False, center=None)</code><ul><li><strong>degress</strong>- (sequence or float or int) ，若为 int，则在（-int，+int）之间随机旋转，若为 sequence，则在 s[0]~s[1] 度之间随机旋转</li><li><strong>resample</strong>- 重采样方法</li><li><strong>expand</strong>- 是否扩大图片，以保存图片原有信息</li><li><strong>center</strong>- 旋转中心，(0, 0)为左上角。默认为图片中心</li></ul></li></ul></li><li>图像变换<ul><li>resize：<code>transforms.Resize(size, interpolation=2)</code><ul><li><strong>size</strong>- If size is an int, if height &gt; width, then image will be rescaled to (size * height / width, size)，所以建议 size 设定为 h*w</li><li><strong>interpolation</strong>- 插值方法选择，默认为 PIL.Image.BILINEAR</li></ul></li><li>标准化：<code>transforms.Normalize(mean, std)</code><ul><li>对数据按通道进行标准化，即先减均值，再除以标准差，注意是 [h, w, c]</li></ul></li><li>转为 tensor，并归一化至[0-1]：<code>transforms.ToTensor</code><ul><li>归一化至[0-1]是直接除以 255，若自己的 ndarray 数据尺度有变化，则需要自行修改。</li></ul></li><li>填充图像边缘：<code>transforms.Pad(padding, fill=0, padding_mode=&#39;constant&#39;)</code><ul><li>同 随机裁剪 RandomCrop 的参数</li></ul></li><li>修改亮度、对比度和饱和度：<code>transforms.ColorJitter(brightness=0, contrast=0, saturation=0, hue=0)</code><ul><li><strong>brightness</strong>- 亮度调整因子。当为a时，从 max((0, 1-a), 1+a) 中随机选择；当为(a, b)时，从[a, b]中随机选择。</li><li><strong>constant</strong>- 对比度参数，同brightness</li><li><strong>saturation</strong>- 饱和度参数，同brightness</li><li><strong>hue</strong>- 色相参数，当为a时，从[-a, a]中选择参数，注：0 &lt;= a &lt;= 0.5；当为(a, b)时，从[a, b]中选择参数，注：-0.5 &lt;= a &lt;= b &lt;= 0.5</li></ul></li><li>转灰度图：<code>transforms.Grayscale(num_output_channels=1)</code><ul><li><strong>num_output_channels</strong>- 输出通道数，只能设置1或者3</li></ul></li><li>线性变换：<code>transforms.LinearTransformation(transformation_matrix)</code><ul><li>对矩阵做线性变化，可用于白化处理。 whitening: zero-center the data, compute the data covariance matrix</li></ul></li><li>仿射变换：<code>transforms.RandomAffine(degrees, translate=None, scale=None, shear=None, resample=False, fillcolor=0)</code><ul><li><strong>degrees</strong>- 旋转角度设置</li><li><strong>translate</strong>- 平移区间设置如(a, b), a设置宽(width), b设置高(height) 。图像在宽维度的平移区间为 -img_width * a &lt; dx &lt; img_width * a</li><li><strong>scale</strong>- 缩放比例（以面积为单位）</li><li><strong>file_color</strong>- 填充颜色设置</li><li><strong>share</strong>- 错切角度设置，有水平错切和垂直错切，若为a，则仅在x轴错切，错切角度为(-a, a)之间；若为(a, b), 则a设置x轴角度，b设置y的角度；若为(a, b, c, d), 则a，b设置x轴度，c， d设置y角度</li><li><strong>resample</strong>- 重采样方式有NEAREST、BILINEAR、BICUBIC</li></ul></li><li>依概率 p 转为灰度图：<code>transforms.RandomGrayscale(p=0.1)</code><ul><li><strong>p</strong>- 概率值，图像被转换为灰度图的概率</li></ul></li><li>将数据转换为 PILImage：<code>transforms.ToPILImage(mode=None)</code><ul><li><strong>mode</strong>- 为 None 时，为 1 通道， mode=3 通道默认转换为 RGB，4 通道默认转换为 RGBA</li></ul></li><li>随机遮挡：<code>transforms.RandomErasing(p=0.5, scale=(0.02, 0.33), ratio=(0.3, 3.3), value=0, inplace=False)</code><ul><li><strong>p</strong>- 概率值</li><li><strong>scale</strong>- 遮挡区域与输入图像的比例范围</li><li><strong>ratio</strong>- 遮挡区域长宽比</li><li><strong>value</strong>- 设置遮挡区域的像素值，(R, G, B) or (Gray), value为字符串(不一定非要random)时，随机填充像素值。</li><li><strong>inplace</strong>- 改变自身</li></ul></li><li>transforms.Lambda：Apply a user-defined lambda as a transform</li></ul></li><li>对 transforms 操作，使数据增强更灵活<ul><li>transforms.RandomChoice(transforms)，从给定的一系列 transforms 中选一个进行操作</li><li>transforms.RandomApply(transforms, p=0.5)，给一个 transform 加上概率，依概率进行操作</li><li>transforms.RandomOrder，将 transforms 中的操作随机打乱</li></ul></li><li>自定义 transforms <ul><li>仅接收一个参数，返回一个参数</li><li>注意上下游的输出与输入</li></ul></li></ol><h3 id="计算-Normalize-所用均值和方差"><a href="#计算-Normalize-所用均值和方差" class="headerlink" title="计算 Normalize 所用均值和方差"></a>计算 Normalize 所用均值和方差</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    随机挑选CNum张图片，进行按通道计算均值mean和标准差std</span></span><br><span class="line"><span class="string">    先将像素从0～255归一化至 0-1 再计算</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">train_txt_path = os.path.join(<span class="string">&quot;..&quot;</span>, <span class="string">&quot;..&quot;</span>, <span class="string">&quot;Data/train.txt&quot;</span>)</span><br><span class="line">CNum = <span class="number">2000</span>  <span class="comment"># 挑选多少图片进行计算</span></span><br><span class="line"></span><br><span class="line">img_h, img_w = <span class="number">32</span>, <span class="number">32</span></span><br><span class="line">imgs = np.zeros([img_w, img_h, <span class="number">3</span>, <span class="number">1</span>])</span><br><span class="line">means, stdevs = [], []</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(train_txt_path, <span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    lines = f.readlines()</span><br><span class="line">    random.shuffle(lines)  <span class="comment"># shuffle , 随机挑选图片</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(CNum):</span><br><span class="line">        img_path = lines[i].rstrip().split()[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">        img = cv2.imread(img_path)</span><br><span class="line">        img = cv2.resize(img, (img_h, img_w))</span><br><span class="line"></span><br><span class="line">        img = img[:, :, :, np.newaxis]</span><br><span class="line">        imgs = np.concatenate((imgs, img), axis=<span class="number">3</span>)</span><br><span class="line">        print(i)</span><br><span class="line"></span><br><span class="line">imgs = imgs.astype(np.float32) / <span class="number">255.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>):</span><br><span class="line">    pixels = imgs[:, :, i, :].ravel()  <span class="comment"># 拉成一行</span></span><br><span class="line">    means.append(np.mean(pixels))</span><br><span class="line">    stdevs.append(np.std(pixels))</span><br><span class="line"></span><br><span class="line">means.reverse()  <span class="comment"># BGR --&gt; RGB</span></span><br><span class="line">stdevs.reverse()</span><br><span class="line"></span><br><span class="line">print(<span class="string">&quot;normMean = &#123;&#125;&quot;</span>.<span class="built_in">format</span>(means))</span><br><span class="line">print(<span class="string">&quot;normStd = &#123;&#125;&quot;</span>.<span class="built_in">format</span>(stdevs))</span><br><span class="line">print(<span class="string">&#x27;transforms.Normalize(normMean = &#123;&#125;, normStd = &#123;&#125;)&#x27;</span>.<span class="built_in">format</span>(means, stdevs))</span><br></pre></td></tr></table></figure><h2 id="模型-Model"><a href="#模型-Model" class="headerlink" title="模型(Model)"></a>模型(Model)</h2><h3 id="模型定义"><a href="#模型定义" class="headerlink" title="模型定义"></a>模型定义</h3><ul><li>三个要点<ul><li>必须继承 <code>nn.Module</code> 这个类，要让 PyTorch 知道这个类是一个 Module。</li><li>在 <code>__init__(self)</code> 中设置好需要的隐藏层(如 conv、pooling、Linear、BatchNorm等)。</li><li>在 <code>forward(self, x)</code> 中用定义好的网络结构进行组装，定义前馈过程。</li></ul></li><li>可以使用类似 <code>_make_layer()</code> 类似的方法来辅助自定义网络层。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> .BasicModule <span class="keyword">import</span> BasicModule</span><br><span class="line"><span class="keyword">from</span> torch <span class="keyword">import</span> nn</span><br><span class="line"><span class="keyword">from</span> torch.nn <span class="keyword">import</span> functional <span class="keyword">as</span> F</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ResidualBlock</span>(<span class="params">nn.Module</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    实现子module: Residual Block</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, inchannel, outchannel, stride=<span class="number">1</span>, shortcut=<span class="literal">None</span></span>):</span></span><br><span class="line">        <span class="built_in">super</span>(ResidualBlock, self).__init__()</span><br><span class="line">        self.left = nn.Sequential(</span><br><span class="line">            nn.Conv2d(inchannel, outchannel, <span class="number">3</span>, stride, <span class="number">1</span>, bias=<span class="literal">False</span>),</span><br><span class="line">            nn.BatchNorm2d(outchannel),</span><br><span class="line">            nn.ReLU(inplace=<span class="literal">True</span>),</span><br><span class="line">            nn.Conv2d(outchannel, outchannel, <span class="number">3</span>, <span class="number">1</span>, <span class="number">1</span>, bias=<span class="literal">False</span>),</span><br><span class="line">            nn.BatchNorm2d(outchannel))</span><br><span class="line">        self.right = shortcut</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span>(<span class="params">self, x</span>):</span></span><br><span class="line">        out = self.left(x)</span><br><span class="line">        residual = x <span class="keyword">if</span> self.right <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">else</span> self.right(x)</span><br><span class="line">        out += residual</span><br><span class="line">        <span class="keyword">return</span> F.relu(out)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ResNet34</span>(<span class="params">BasicModule</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    实现主module：ResNet34</span></span><br><span class="line"><span class="string">    ResNet34包含多个layer，每个layer又包含多个Residual block</span></span><br><span class="line"><span class="string">    用子module来实现Residual block，用_make_layer函数来实现layer</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, num_classes=<span class="number">2</span></span>):</span></span><br><span class="line">        <span class="built_in">super</span>(ResNet34, self).__init__()</span><br><span class="line">        self.model_name = <span class="string">&#x27;resnet34&#x27;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 前几层: 图像转换</span></span><br><span class="line">        self.pre = nn.Sequential(</span><br><span class="line">            nn.Conv2d(<span class="number">3</span>, <span class="number">64</span>, <span class="number">7</span>, <span class="number">2</span>, <span class="number">3</span>, bias=<span class="literal">False</span>),</span><br><span class="line">            nn.BatchNorm2d(<span class="number">64</span>),</span><br><span class="line">            nn.ReLU(inplace=<span class="literal">True</span>),</span><br><span class="line">            nn.MaxPool2d(<span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>))</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 重复的layer，分别有3，4，6，3个residual block</span></span><br><span class="line">        self.layer1 = self._make_layer(<span class="number">64</span>, <span class="number">128</span>, <span class="number">3</span>)</span><br><span class="line">        self.layer2 = self._make_layer(<span class="number">128</span>, <span class="number">256</span>, <span class="number">4</span>, stride=<span class="number">2</span>)</span><br><span class="line">        self.layer3 = self._make_layer(<span class="number">256</span>, <span class="number">512</span>, <span class="number">6</span>, stride=<span class="number">2</span>)</span><br><span class="line">        self.layer4 = self._make_layer(<span class="number">512</span>, <span class="number">512</span>, <span class="number">3</span>, stride=<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 分类用的全连接</span></span><br><span class="line">        self.fc = nn.Linear(<span class="number">512</span>, num_classes)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_make_layer</span>(<span class="params">self, inchannel, outchannel, block_num, stride=<span class="number">1</span></span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        构建layer,包含多个residual block</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        shortcut = nn.Sequential(</span><br><span class="line">            nn.Conv2d(inchannel, outchannel, <span class="number">1</span>, stride, bias=<span class="literal">False</span>),</span><br><span class="line">            nn.BatchNorm2d(outchannel))</span><br><span class="line"></span><br><span class="line">        layers = []</span><br><span class="line">        layers.append(ResidualBlock(inchannel, outchannel, stride, shortcut))</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, block_num):</span><br><span class="line">            layers.append(ResidualBlock(outchannel, outchannel))</span><br><span class="line">        <span class="keyword">return</span> nn.Sequential(*layers)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span>(<span class="params">self, x</span>):</span></span><br><span class="line">        x = self.pre(x)</span><br><span class="line"></span><br><span class="line">        x = self.layer1(x)</span><br><span class="line">        x = self.layer2(x)</span><br><span class="line">        x = self.layer3(x)</span><br><span class="line">        x = self.layer4(x)</span><br><span class="line"></span><br><span class="line">        x = F.avg_pool2d(x, <span class="number">7</span>)</span><br><span class="line">        x = x.view(x.size(<span class="number">0</span>), -<span class="number">1</span>)  <span class="comment"># 按batch_size展平</span></span><br><span class="line">        <span class="keyword">return</span> self.fc(x)</span><br></pre></td></tr></table></figure><h3 id="Sequential"><a href="#Sequential" class="headerlink" title="Sequential"></a>Sequential</h3><ul><li>可以用 list 或者 OrderedDict 进行网络的堆叠。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Example of using Sequential</span></span><br><span class="line">model = nn.Sequential(</span><br><span class="line">    nn.Conv2d(<span class="number">1</span>, <span class="number">20</span>, <span class="number">5</span>),</span><br><span class="line">    nn.ReLU(),</span><br><span class="line">    nn.Conv2d(<span class="number">20</span>, <span class="number">64</span>, <span class="number">5</span>),</span><br><span class="line">    nn.ReLU()</span><br><span class="line">)</span><br><span class="line"><span class="comment"># Example of using Sequential with OrderedDict</span></span><br><span class="line">model = nn.Sequential(OrderedDict([</span><br><span class="line">    (<span class="string">&#x27;conv1&#x27;</span>, nn.Conv2d(<span class="number">1</span>, <span class="number">20</span>, <span class="number">5</span>)),</span><br><span class="line">    (<span class="string">&#x27;relu1&#x27;</span>, nn.ReLU()),</span><br><span class="line">    (<span class="string">&#x27;conv2&#x27;</span>, nn.Conv2d(<span class="number">20</span>, <span class="number">64</span>, <span class="number">5</span>)),</span><br><span class="line">    (<span class="string">&#x27;relu2&#x27;</span>, nn.ReLU())</span><br><span class="line">]))</span><br></pre></td></tr></table></figure><h3 id="权值初始化"><a href="#权值初始化" class="headerlink" title="权值初始化"></a>权值初始化</h3><h4 id="权值初始化流程"><a href="#权值初始化流程" class="headerlink" title="权值初始化流程"></a>权值初始化流程</h4><ul><li>初始化流程<ul><li>第一步，先设定什么层用什么初始化方法，初始化方法在 torch.nn.init 中给出；</li><li>第二步，实例化一个模型之后，执行该函数，即可完成初始化。</li></ul></li><li><code>named_children()</code>和<code>named_modules()</code>的区别：<a href="https://blog.csdn.net/watermelon1123/article/details/98036360">https://blog.csdn.net/watermelon1123/article/details/98036360</a></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 定义权值初始化</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">initialize_weights</span>(<span class="params">self</span>):</span></span><br><span class="line">    <span class="keyword">for</span> m <span class="keyword">in</span> self.modules():</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">isinstance</span>(m, nn.Conv2d):</span><br><span class="line">            torch.nn.init.xavier_normal_(m.weight.data)</span><br><span class="line">            <span class="keyword">if</span> m.bias <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">                m.bias.data.zero_()</span><br><span class="line">        <span class="keyword">elif</span> <span class="built_in">isinstance</span>(m, nn.BatchNorm2d):</span><br><span class="line">            m.weight.data.fill_(<span class="number">1</span>)</span><br><span class="line">            m.bias.data.zero_()</span><br><span class="line">        <span class="keyword">elif</span> <span class="built_in">isinstance</span>(m, nn.Linear):</span><br><span class="line">            torch.nn.init.normal_(m.weight.data, <span class="number">0</span>, <span class="number">0.01</span>)</span><br><span class="line">            m.bias.data.zero_()</span><br></pre></td></tr></table></figure><h4 id="权值初始化的十种方法-干货"><a href="#权值初始化的十种方法-干货" class="headerlink" title="权值初始化的十种方法(干货)"></a>权值初始化的十种方法(干货)</h4><ol><li>Xavier 均匀分布：<code>torch.nn.init.xavier_uniform_(tensor, gain=1)</code><ul><li>xavier 初始化方法中服从均匀分布 U(−a,a) ，分布的参数 a = gain * sqrt(6/fan_in+fan_out)。也称为 Glorot initialization。</li><li><strong>gain</strong>- 增益的大小是依据激活函数类型来设定。</li><li>eg：nn.init.xavier_uniform_(w, gain=nn.init.calculate_gain(‘relu’))</li></ul></li><li>Xavier 正态分布：<code>torch.nn.init.xavier_normal_(tensor, gain=1)</code><ul><li>xavier 初始化方法中服从正态分布，mean=0,std = gain * sqrt(2/fan_in + fan_out)</li><li>kaiming 初始化方法，论文在《 Delving deep into rectifiers: Surpassing human-level performance on ImageNet classification》，公式推导同样从“方差一致性”出法，kaiming是针对 xavier 初始化方法在 relu 这一类激活函数表现不佳而提出的改进，详细可以参看论文。</li></ul></li><li>kaiming 均匀分布：<code>torch.nn.init.kaiming_uniform_(tensor, a=0, mode=&#39;fan_in&#39;, nonlinearity=&#39;leaky_relu&#39;)</code><ul><li>此为均匀分布，U～（-bound, bound）, bound = sqrt(6/(1+a^2)*fan_in)。其中，a 为激活函数的负半轴的斜率，relu 是 0。</li><li><strong>mode</strong>- 可选为 fan_in 或 fan_out, fan_in 使正向传播时，方差一致; fan_out 使反向传播时，方差一致</li><li><strong>nonlinearity</strong>- 可选 relu 和 leaky_relu ，默认值为 。 leaky_relu</li><li>eg：nn.init.kaiming_uniform_(w, mode=’fan_in’, nonlinearity=’relu’)</li></ul></li><li>kaiming 正态分布：<code>torch.nn.init.kaiming_normal_(tensor, a=0, mode=&#39;fan_in&#39;, nonlinearity=&#39;leaky_relu&#39;)</code><ul><li>此为 0 均值的正态分布，N～ (0,std)，其中 std = sqrt(2/(1+a^2)*fan_in) </li><li><strong>a</strong>- 激活函数的负半轴的斜率，relu 是 0</li><li><strong>mode</strong>- 可选为 fan_in 或 fan_out。fan_in 使正向传播时，方差一致；fan_out 使反向传播时，方差一致</li><li><strong>nonlinearity</strong>- 可选 relu 和 leaky_relu ，默认值为 leaky_relu。</li><li>eg：nn.init.kaiming_normal_(w, mode=’fan_out’, nonlinearity=’relu’)</li></ul></li><li>均匀分布初始化：<code>torch.nn.init.uniform_(tensor, a=0, b=1)</code><ul><li>使值服从均匀分布 U(a,b)</li></ul></li><li>正态分布初始化：<code>torch.nn.init.normal_(tensor, mean=0, std=1)</code><ul><li>使值服从正态分布 N(mean, std)，默认值为 0，1</li></ul></li><li>常数初始化：<code>torch.nn.init.constant_(tensor, val)</code><ul><li>使值为常数 val nn.init.constant_(w, 0.3)</li></ul></li><li>单位矩阵初始化：<code>torch.nn.init.eye_(tensor)</code><ul><li>将二维 tensor 初始化为单位矩阵（the identity matrix）</li></ul></li><li>正交初始化：<code>torch.nn.init.orthogonal_(tensor, gain=1)</code><ul><li>使得 tensor 是正交的，论文:Exact solutions to the nonlinear dynamics of learning in deep linear neural networks” - Saxe, A. et al. (2013)</li></ul></li><li>稀疏初始化：<code>torch.nn.init.sparse_(tensor, sparsity, std=0.01)</code><ul><li>从正态分布 N～（0. std）中进行稀疏化，使每一个 column 有一部分为 0</li><li><strong>sparsity</strong>- 每一个 column 稀疏的比例，即为 0 的比例</li><li>eg：nn.init.sparse_(w, sparsity=0.1)</li></ul></li><li>计算增益：<code>torch.nn.init.calculate_gain(nonlinearity, param=None)</code></li></ol><blockquote><p>其实，在创建网络实例的过程中, 一旦调用 nn.Conv2d 的时候就会有对权值进行初始化。</p><p>在 PyTorch1.0 版本后，Conv2d 改用了 <code>kaiming_uniform_()</code> 进行初始化，可以在 <code>torch/nn/modules/conv.py</code> 中的 _ConvNd 类中的函数 <code>reset_parameters()</code> 中看到初始化方式。</p></blockquote><h3 id="模型加载与保存-Finetune"><a href="#模型加载与保存-Finetune" class="headerlink" title="模型加载与保存 Finetune"></a>模型加载与保存 Finetune</h3><ul><li>模型 Finetune 权值初始化：<ol><li>保存模型，拥有一个预训练模型</li><li>加载模型，把预训练模型中的权值取出来</li><li>初始化，将网络的权重用预训练模型初始化</li></ol></li><li>官方文档中介绍了两种保存模型的方法，一种是保存整个模型，另外一种是仅保存模型参数（官方推荐用这种方法）</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1. 创建 net</span></span><br><span class="line">net = Net()</span><br><span class="line"><span class="comment"># 2. 获取已创建 net 的 state_dict</span></span><br><span class="line">net_state_dict = net.state_dict()</span><br><span class="line"><span class="comment"># 3. 加载模型，这里只是加载模型的参数</span></span><br><span class="line">pretrained_dict = torch.load(<span class="string">&#x27;net_params.pkl&#x27;</span>)</span><br><span class="line"><span class="comment"># 4. 将 pretrained_dict 里不属于 net_state_dict 的键剔除掉</span></span><br><span class="line">pretrained_dict_1 = &#123;k: v <span class="keyword">for</span> k, v <span class="keyword">in</span> pretrained_dict.items() <span class="keyword">if</span> k <span class="keyword">in</span> net_state_dict&#125;</span><br><span class="line"><span class="comment"># 5. 用预训练模型的参数字典 对 新模型的参数字典 net_state_dict 进行更新</span></span><br><span class="line">net_state_dict.update(pretrained_dict_1)</span><br><span class="line"><span class="comment"># 6. 将更新了参数的字典 “放”回到网络中</span></span><br><span class="line">net.load_state_dict(net_state_dict)</span><br><span class="line"><span class="comment"># 7. 将网络的参数保存下来</span></span><br><span class="line">torch.save(net.state_dict(), <span class="string">&#x27;net_params.pkl&#x27;</span>)</span><br></pre></td></tr></table></figure><h3 id="不同层设置不同的学习率"><a href="#不同层设置不同的学习率" class="headerlink" title="不同层设置不同的学习率"></a>不同层设置不同的学习率</h3><ul><li>在利用 pre-trained model 的参数做初始化之后，我们可能想让 fc 层更新相对快一些，而希望前面的权值更新小一些，这就可以通过为不同的层设置不同的学习率来达到此目的。</li><li>为不同层设置不同的学习率，主要通过优化器对多个参数组进行设置不同的参数。所以，只需要将原始的参数组，划分成两个，甚至更多的参数组，然后分别进行设置学习率。</li><li>这里将原始参数“切分”成 fc3 层参数和其余参数，为 fc3 层设置更大的学习率。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">lr_init: <span class="built_in">float</span> = <span class="number">0.001</span></span><br><span class="line">    </span><br><span class="line"><span class="comment"># 将fc3层的参数从原始网络参数中剔除</span></span><br><span class="line">ignored_params = <span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">id</span>, net.fc3.parameters()))  <span class="comment"># 返回的是 parameters 的内存地址</span></span><br><span class="line">base_params = <span class="built_in">filter</span>(<span class="keyword">lambda</span> p: <span class="built_in">id</span>(p) <span class="keyword">not</span> <span class="keyword">in</span> ignored_params, net.parameters())</span><br><span class="line"></span><br><span class="line"><span class="comment"># 为fc3层设置需要的学习率</span></span><br><span class="line">optimizer = optim.SGD([</span><br><span class="line">    &#123;<span class="string">&#x27;params&#x27;</span>: base_params&#125;,</span><br><span class="line">    &#123;<span class="string">&#x27;params&#x27;</span>: net.fc3.parameters(), <span class="string">&#x27;lr&#x27;</span>: lr_init*<span class="number">10</span>&#125;</span><br><span class="line">],  lr_init, momentum=<span class="number">0.9</span>, weight_decay=<span class="number">1e-4</span>)</span><br><span class="line"></span><br><span class="line">criterion = nn.CrossEntropyLoss()                                                   <span class="comment"># 选择损失函数</span></span><br><span class="line">scheduler = torch.optim.lr_scheduler.StepLR(optimizer, step_size=<span class="number">50</span>, gamma=<span class="number">0.1</span>)     <span class="comment"># 设置学习率下降策略</span></span><br></pre></td></tr></table></figure><ul><li>挑选出特定的层的机制是利用内存地址作为过滤条件，将需要单独设定的部分参数从总的参数中剔除。<ul><li><code>net.fc3.parameters()</code> 是一个&lt;generator object parameters at 0x11b63bf00&gt;</li><li><code>ignored_params</code> 是包含 net.fc3 中 weight、bias 两者对应参数的内存地址列表</li><li><code>base_params</code> 是一个 list，每个元素是一个 Parameter 类，其中剔除了 net.fc3 的 weight、bias</li></ul></li></ul><blockquote><p><strong>冻结权重</strong>与<strong>优化器仅传入部分参数</strong>两者是等价的。</p><p>个人认为：1. 用requires_grad=False会提高内存优化，因为不需要保存梯度。2. 仅传入优化器可以提高运行速度，因为不用对部分参数进行计算</p><p><a href="https://blog.csdn.net/answer3664/article/details/108493753">https://blog.csdn.net/answer3664/article/details/108493753</a></p></blockquote><h2 id="损失函数-Loss-Function"><a href="#损失函数-Loss-Function" class="headerlink" title="损失函数(Loss Function)"></a>损失函数(Loss Function)</h2><h3 id="PyTorch-的十七个损失函数-干货"><a href="#PyTorch-的十七个损失函数-干货" class="headerlink" title="PyTorch 的十七个损失函数(干货)"></a>PyTorch 的十七个损失函数(干货)</h3><ul><li>训练网络的过程，是不断优化网络权值使得损失函数值最小化的过程。</li></ul><ol><li><p>L1loss：<code>torch.nn.L1Loss(size_average=None, reduce=None)</code></p><ul><li><p>计算 output 和 target 之差的绝对值</p><img src="/2021/09/PyTorch-Part2/image-20210913142253796.png" alt="image-20210913142253796" style="zoom:67%;"></li><li><p><strong>reduce</strong>(bool)- 返回值是否为标量，默认为 True</p><p><strong>size_average</strong>(bool)- 当 reduce=True 时有效。为 True 时，返回的 loss 为平均值；为 False时，返回的各样本的 loss 之和</p></li></ul></li><li><p>MSELoss：<code>torch.nn.MSELoss(size_average=None, reduce=None, reduction=&#39;elementwise_mean&#39;)</code></p><ul><li><p>计算 output 和 target 之差的平方</p><img src="/2021/09/PyTorch-Part2/image-20210913142318096.png" alt="image-20210913142318096" style="zoom:67%;"></li><li><p><strong>reduce</strong>(bool)- 返回值是否为标量，默认为 True</p><p><strong>size_average</strong>(bool)- 当 reduce=True 时有效。为 True 时，返回的 loss 为平均值；为 False时，返回的各样本的 loss 之和</p></li></ul></li><li><p>CrossEntropyLoss：<code>torch.nn.CrossEntropyLoss(weight=None, size_average=None, ignore_index=-100, reduce=None, reduction=&#39;elementwise_mean&#39;)</code></p><ul><li><p>将输入经过 softmax 激活函数之后，再计算其与 target 的交叉熵损失。</p><p>该方法将 nn.LogSoftmax() 和 nn.NLLLoss() 进行了结合。严格意义上的交叉熵损失函数应该是 nn.NLLLoss()。</p><img src="/2021/09/PyTorch-Part2/image-20210913142855509.png" alt="image-20210913142855509" style="zoom:67%;"></li><li><p><strong>weight</strong>(Tensor)- 为每个类别的 loss 设置权值，常用于类别不均衡问题。weight 必须是 float类型的 tensor，其长度要于类别 C 一致，即每一个类别都要设置有 weight。</p><p><strong>size_average</strong>(bool)- 当 reduce=True 时有效。为 True 时，返回的 loss 为平均值；为 False时，返回的各样本的 loss 之和。</p><p><strong>reduce</strong>(bool)- 返回值是否为标量，默认为 True</p><p><strong>ignore_index</strong>(int)- 忽略某一类别，不计算其 loss，其 loss 会为 0，并且，在采用size_average 时，不会计算那一类的 loss，除的时候的分母也不会统计那一类的样本。</p></li></ul></li><li><p>NLLLoss：<code>torch.nn.NLLLoss(weight=None, size_average=None, ignore_index=-100, reduce=None, reduction=&#39;elementwise_mean&#39;)</code></p><ul><li><p>不带 log_softmax 层的 CrossEntropyLoss 。</p><img src="/2021/09/PyTorch-Part2/image-20210913144640040.png" alt="image-20210913144640040" style="zoom:67%;"></li><li><p><strong>weight</strong>(Tensor)- 为每个类别的 loss 设置权值，常用于类别不均衡问题。weight 必须是 float类型的 tensor，其长度要于类别 C 一致，即每一个类别都要设置有 weight。</p><p><strong>size_average</strong>(bool)- 当 reduce=True 时有效。为 True 时，返回的 loss 为除以权重之和的平均值；为 False 时，返回的各样本的 loss 之和。</p><p><strong>reduce</strong>(bool)- 返回值是否为标量，默认为 True。</p><p><strong>ignore_index</strong>(int)- 忽略某一类别，不计算其 loss，其 loss 会为 0，并且，在采用 size_average 时，不会计算那一类的 loss，除的时候的分母也不会统计那一类的样本。</p></li></ul></li><li><p>PoissonNLLLoss：<code>torch.nn.PoissonNLLLoss(log_input=True, full=False, size_average=None, eps=1e-08, reduce=None, reduction=&#39;elementwise_mean&#39;)</code></p><ul><li><p>用于 target 服从泊松分布的分类任务。</p><img src="/2021/09/PyTorch-Part2/image-20210913144654680.png" alt="image-20210913144654680" style="zoom:67%;"></li><li><p>log_input(bool)- 为 True 时，计算公式为：loss(input,target)=exp(input) - target * input; 为 False 时，loss(input,target)=input - target * log(input+eps)</p><p><strong>full</strong>(bool)- 是否计算全部的 loss。例如，当采用斯特林公式近似阶乘项时，此为 target*log(target) - target+0.5∗log(2πtarget)</p><p><strong>eps</strong>(float)- 当 log_input = False 时，用来防止计算 log(0)，而增加的一个修正项。即</p><p><strong>loss</strong>(input,target)=input - target * log(input+eps)</p><p><strong>size_average</strong>(bool)- 当 reduce=True 时有效。为 True 时，返回的 loss 为平均值；为 False时，返回的各样本的 loss 之和。</p><p><strong>reduce</strong>(bool)- 返回值是否为标量，默认为 True</p></li></ul></li><li><p>KLDivLoss：<code>torch.nn.KLDivLoss(size_average=None, reduce=None, reduction=&#39;elementwise_mean&#39;)</code></p><ul><li><p>计算 input 和 target 之间的 KL 散度( Kullback–Leibler divergence) 。又称为相对熵(Relative Entropy)，用于描述两个概率分布之间的差异。</p><p>要想获得真正的 KL 散度，需要如下操作：1. reduce = True ；size_average=False；2. 计算得到的 loss 要对 batch 进行求平均</p><img src="/2021/09/PyTorch-Part2/image-20210913144829614.png" alt="image-20210913144829614" style="zoom:67%;"></li><li><p><strong>size_average</strong>(bool)- 当 reduce=True 时有效。为 True 时，返回的 loss 为平均值，平均值为</p><p><strong>element</strong>-wise 的，而不是针对样本的平均；为 False 时，返回是各样本各维度的 loss 之和。</p><p><strong>reduce</strong>(bool)- 返回值是否为标量，默认为 True。</p></li></ul></li><li><p>BCELoss：<code>torch.nn.BCELoss(weight=None, size_average=None, reduce=None, reduction=&#39;elementwise_mean&#39;)</code></p><ul><li><p>二分类任务时的交叉熵计算函数。可以认为是 <strong>nn.CrossEntropyLoss</strong> 函数的特例。在 BCELoss 之前，input 一般为 sigmoid 激活层的输出。</p><img src="/2021/09/PyTorch-Part2/image-20210913145243878.png" alt="image-20210913145243878" style="zoom:67%;"></li><li><p><strong>weight</strong>(Tensor)- 为每个类别的 loss 设置权值，常用于类别不均衡问题。</p><p><strong>size_average</strong>(bool)- 当 reduce=True 时有效。为 True 时，返回的 loss 为平均值；为 False 时，返回的各样本的 loss 之和。</p><p><strong>reduce</strong>(bool)- 返回值是否为标量，默认为 True</p></li></ul></li><li><p>BCEWithLogitsLoss：<code>torch.nn.BCEWithLogitsLoss(weight=None, size_average=None, reduce=None, reduction=&#39;elementwise_mean&#39;, pos_weight=None)</code></p><ul><li><p>将 Sigmoid 与 BCELoss 结合，类似于 CrossEntropyLoss(将 nn.LogSoftmax()和 nn.NLLLoss() 进行结合）。即 input 会经过 Sigmoid 激活函数，将 input 变成概率分布的形式。</p><img src="/2021/09/PyTorch-Part2/image-20210913145354209.png" alt="image-20210913145354209" style="zoom:67%;"></li><li><p><strong>weight</strong>(Tensor)- : 为 batch 中单个样本设置权值，If given, has to be a Tensor of size “nbatch”.</p><p><strong>pos_weight</strong>-: 正样本的权重, 当 p&gt;1，提高召回率，当 P&lt;1，提高精确度。可达到权衡召回率(Recall)和精确度(Precision)的作用。 Must be a vector with length equal to the number of classes.</p><p><strong>size_average</strong>(bool)- 当 reduce=True 时有效。为 True 时，返回的 loss 为平均值；为 False 时，返回的各样本的 loss 之和。</p><p><strong>reduce</strong>(bool)- 返回值是否为标量，默认为 True</p></li></ul></li><li><p>MarginRankingLoss：<code>torch.nn.MarginRankingLoss(margin=0, size_average=None, reduce=None, reduction=&#39;elementwise_mean&#39;)</code></p><ul><li><p>计算两个向量之间的相似度，当两个向量之间的距离大于 margin，则 loss 为正，小于 margin，loss 为 0。</p><img src="/2021/09/PyTorch-Part2/image-20210913145522074.png" alt="image-20210913145522074" style="zoom:67%;"></li><li><p><strong>margin</strong>(float)- x1 和 x2 之间的差异。</p><p><strong>size_average</strong>(bool)- 当 reduce=True 时有效。为 True 时，返回的 loss 为平均值；为 False时，返回的各样本的 loss 之和。</p><p><strong>reduce</strong>(bool)- 返回值是否为标量，默认为 True。</p></li></ul></li><li><p>HingeEmbeddingLoss：<code>torch.nn.HingeEmbeddingLoss(margin=1.0, size_average=None, reduce=None, reduction=&#39;elementwise_mean&#39;)</code></p><ul><li><p>为折页损失的拓展，主要用于衡量两个输入是否相似。used for learning nonlinear embeddings or semi-supervised</p></li><li><p><strong>margin</strong>(float)- 默认值为 1，容忍的差距。</p><p><strong>size_average</strong>(bool)- 当 reduce=True 时有效。为 True 时，返回的 loss 为平均值；为 False时，返回的各样本的 loss 之和。</p><p><strong>reduce</strong>(bool)- 返回值是否为标量，默认为 True。</p></li></ul></li><li><p>MultiLabelMarginLoss：<code>torch.nn.MultiLabelMarginLoss(size_average=None, reduce=None, reduction=&#39;elementwise_mean&#39;)</code></p><ul><li><p>用于一个样本属于多个类别时的分类任务。例如一个四分类任务，样本 x 属于第 0 类，第 1 类，不属于第 2 类，第 3 类。</p><img src="/2021/09/PyTorch-Part2/image-20210913145842583.png" alt="image-20210913145842583"></li><li><p><strong>size_average</strong>(bool)- 当 reduce=True 时有效。为 True 时，返回的 loss 为平均值；为 False时，返回的各样本的 loss 之和。</p><p><strong>reduce</strong>(bool)- 返回值是否为标量，默认为 True。</p><p><strong>Input</strong>: (C) or (N,C) where N is the batch size and C is the number of classes.</p><p><strong>Target</strong>: (C) or (N,C), same shape as the input.</p></li></ul></li><li><p>SmoothL1Loss：<code>torch.nn.SmoothL1Loss(size_average=None, reduce=None, reduction=&#39;elementwise_mean&#39;)</code></p><ul><li><p>计算平滑 L1 损失，属于 Huber Loss 中的一种(因为参数 δ 固定为 1 了)。</p><p>Huber Loss 常用于回归问题，其最大的特点是对离群点（outliers）、噪声不敏感，具有较强的鲁棒性。</p><p>当误差绝对值小于 δ，采用 L2 损失；若大于 δ，采用 L1 损失。</p><img src="/2021/09/PyTorch-Part2/image-20210913150004347.png" alt="image-20210913150004347" style="zoom:67%;"></li><li><p><strong>size_average</strong>(bool)- 当 reduce=True 时有效。为 True 时，返回的 loss 为平均值；为 False时，返回的各样本的 loss 之和。</p><p><strong>reduce</strong>(bool)- 返回值是否为标量，默认为 True。</p></li></ul></li><li><p>SoftMarginLoss：<code>torch.nn.SoftMarginLoss(size_average=None, reduce=None, reduction=&#39;elementwise_mean&#39;)</code></p><ul><li><p>Creates a criterion that optimizes a two-class classification logistic loss between input tensor x and target tensor y (containing 1 or -1). </p><img src="/2021/09/PyTorch-Part2/image-20210913150303241.png" alt="image-20210913150303241"></li><li><p><strong>size_average</strong>(bool)- 当 reduce=True 时有效。为 True 时，返回的 loss 为平均值；为 False时，返回的各样本的 loss 之和。</p><p><strong>reduce</strong>(bool)- 返回值是否为标量，默认为 True。</p></li></ul></li><li><p>MultiLabelSoftMarginLoss：<code>torch.nn.MultiLabelSoftMarginLoss(weight=None, size_average=None, reduce=None, reduction=&#39;elementwise_mean&#39;)</code></p><ul><li><p>SoftMarginLoss 多标签版本，a multi-label one-versus-all loss based on max-entropy.</p><p><img src="/2021/09/PyTorch-Part2/image-20210913150349060.png" alt="image-20210913150349060"></p></li><li><p><strong>weight</strong>(Tensor)- 为每个类别的 loss 设置权值。weight 必须是 float 类型的 tensor，其长度要于类别 C 一致，即每一个类别都要设置有 weight。</p></li></ul></li><li><p>CosineEmbeddingLoss：torch.nn.CosineEmbeddingLoss(margin=0, size_average=None, reduce=None, reduction=’elementwise_mean’)</p><ul><li><p>用 Cosine 函数来衡量两个输入是否相似。 used for learning nonlinear embeddings or semi-supervised</p><p><img src="/2021/09/PyTorch-Part2/image-20210913150448355.png" alt="image-20210913150448355"></p></li><li><p><strong>margin</strong>(float)- ： 取值范围[-1,1]， 推荐设置范围 [0, 0.5] </p><p><strong>size_average</strong>(bool)- 当 reduce=True 时有效。为 True 时，返回的 loss 为平均值；为 False时，返回的各样本的 loss 之和。</p><p><strong>reduce</strong>(bool)- 返回值是否为标量，默认为 True。</p></li></ul></li><li><p>MultiMarginLoss：<code>torch.nn.MultiMarginLoss(p=1, margin=1, weight=None, size_average=None, reduce=None, reduction=&#39;elementwise_mean&#39;)</code></p><ul><li><p>计算多分类的折页损失。</p><p><img src="/2021/09/PyTorch-Part2/image-20210913150527386.png" alt="image-20210913150527386"></p></li><li><p><strong>p</strong>(int)- 默认值为 1，仅可选 1 或者 2。</p><p><strong>margin</strong>(float)- 默认值为 1</p><p><strong>weight</strong>(Tensor)- 为每个类别的 loss 设置权值。weight 必须是 float 类型的 tensor，其长度要与类别 C 一致，即每一个类别都要设置有 weight。</p><p><strong>size_average</strong>(bool)- 当 reduce=True 时有效。为 True 时，返回的 loss 为平均值；为 False时，返回的各样本的 loss 之和。</p><p><strong>reduce</strong>(bool)- 返回值是否为标量，默认为 True。</p></li></ul></li><li><p>TripletMarginLoss：torch.nn.TripletMarginLoss(margin=1.0, p=2, eps=1e-06, swap=False, size_average=None, reduce=None, reduction=’elementwise_mean’)</p><ul><li><p>计算三元组损失，人脸验证中常用。</p><p><img src="/2021/09/PyTorch-Part2/image-20210913150644479.png" alt="image-20210913150644479"></p></li><li><p><strong>margin</strong>(float)- 默认值为 1</p><p><strong>p</strong>(int)- The norm degree ，默认值为 2</p><p><strong>swap</strong>(float)– The distance swap is described in detail in the paper Learning shallow convolutional </p><p><strong>feature</strong> descriptors with triplet losses by V. Balntas, E. Riba et al. Default: False</p><p><strong>size_average</strong>(bool)- 当 reduce=True 时有效。为 True 时，返回的 loss 为平均值；为 False时，返回的各样本的 loss 之和。</p><p><strong>reduce</strong>(bool)- 返回值是否为标量，默认为 True。</p></li></ul></li></ol><h2 id="优化器-Optimizer"><a href="#优化器-Optimizer" class="headerlink" title="优化器(Optimizer)"></a>优化器(Optimizer)</h2><h3 id="优化器类"><a href="#优化器类" class="headerlink" title="优化器类"></a>优化器类</h3><ul><li>PyTorch 中所有的优化器均是 Optimizer 的子类。</li></ul><h4 id="参数组"><a href="#参数组" class="headerlink" title="参数组"></a>参数组</h4><ul><li>参数组(param_groups)在 finetune、某层定制学习率、某层学习率置零等操作中，将发挥重要作用。</li><li>optimizer 对参数的管理是基于组的概念，可以为每一组参数配置特定的 lr、momentum、weight_decay 等等。</li><li>参数组在 optimizer 中表现为一个 list(self.param_groups)，其中每个元素是 dict，表示一个参数及其相应配置，在 dict 中包含’params’、’weight_decay’、’lr’ 、’momentum’等字段。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">w1 = torch.randn((<span class="number">2</span>, <span class="number">2</span>), requires_grad=<span class="literal">True</span>)</span><br><span class="line">w2 = torch.randn((<span class="number">2</span>, <span class="number">2</span>), requires_grad=<span class="literal">True</span>)</span><br><span class="line">w3 = torch.randn((<span class="number">2</span>, <span class="number">2</span>), requires_grad=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 一个参数组</span></span><br><span class="line">optimizer_1 = optim.SGD([w1, w3], lr=<span class="number">0.1</span>)</span><br><span class="line">print(<span class="string">&#x27;len(optimizer.param_groups): &#x27;</span>, <span class="built_in">len</span>(optimizer_1.param_groups))</span><br><span class="line">print(optimizer_1.param_groups, <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 两个参数组</span></span><br><span class="line">optimizer_2 = optim.SGD([&#123;<span class="string">&#x27;params&#x27;</span>: w1, <span class="string">&#x27;lr&#x27;</span>: <span class="number">0.1</span>&#125;,</span><br><span class="line">                         &#123;<span class="string">&#x27;params&#x27;</span>: w2, <span class="string">&#x27;lr&#x27;</span>: <span class="number">0.001</span>&#125;])</span><br><span class="line">print(<span class="string">&#x27;len(optimizer.param_groups): &#x27;</span>, <span class="built_in">len</span>(optimizer_2.param_groups))</span><br><span class="line">print(optimizer_2.param_groups)</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">len(optimizer.param_groups): 1</span></span><br><span class="line"><span class="string">[&#123;&#x27;params&#x27;: [tensor([[0.6320, 0.4332], [-0.0429, -0.4769]], requires_grad=True), </span></span><br><span class="line"><span class="string">             tensor([[0.4598, 0.3449], [0.5621, -1.2329]], requires_grad=True)],</span></span><br><span class="line"><span class="string">  &#x27;lr&#x27;: 0.1, &#x27;momentum&#x27;: 0, &#x27;dampening&#x27;: 0, &#x27;weight_decay&#x27;: 0, &#x27;nesterov&#x27;: False&#125;]</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">len(optimizer.param_groups): 2</span></span><br><span class="line"><span class="string">[&#123;&#x27;params&#x27;: [tensor([[0.6320, 0.4332], [-0.0429, -0.4769]], requires_grad=True)], </span></span><br><span class="line"><span class="string">  &#x27;lr&#x27;: 0.1, &#x27;momentum&#x27;: 0, &#x27;dampening&#x27;: 0, &#x27;weight_decay&#x27;: 0, &#x27;nesterov&#x27;: False&#125;, </span></span><br><span class="line"><span class="string"> &#123;&#x27;params&#x27;: [tensor([[-0.8244, 2.3955], [0.6752, -0.0980]], requires_grad=True)], </span></span><br><span class="line"><span class="string">  &#x27;lr&#x27;: 0.001, &#x27;momentum&#x27;: 0, &#x27;dampening&#x27;: 0, &#x27;weight_decay&#x27;: 0, &#x27;nesterov&#x27;: False&#125;]</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure><h4 id="优化器常用方法"><a href="#优化器常用方法" class="headerlink" title="优化器常用方法"></a>优化器常用方法</h4><ol><li><code>zero_grad()</code>：将梯度清零。<ul><li>由于 PyTorch 不会自动清零梯度，所以在每一次反向传播之前都应当进行此操作。</li></ul></li><li><code>state_dict()</code>：将优化器的状态作为dict返回。返回 state、param_groups 组成的字典。<ul><li><strong>state</strong> - 保存当前优化状态的字典。 其内容优化器类之间有所不同。<br><strong>param_groups</strong> - 包含所有参数组的字典</li></ul></li><li><code>load_state_dict(state_dict)</code>：加载优化器状态。<ul><li>常用于 finetune。</li></ul></li><li><code>add_param_group()</code>：给 optimizer 管理的参数组中增加一组参数。<ul><li>可为该组参数定制 lr、momentum、weight_decay 等，在 finetune 中常用。</li></ul></li><li><code>step(closure)</code>：执行一步权值更新, 其中可传入参数 closure（一个闭包）。<ul><li>如，当采用 LBFGS 优化方法时，需要多次计算，因此需要传入一个闭包去允许它们重新计算 loss 。</li></ul></li></ol><h3 id="PyTorch-的十个优化器-干货"><a href="#PyTorch-的十个优化器-干货" class="headerlink" title="PyTorch 的十个优化器(干货)"></a>PyTorch 的十个优化器(干货)</h3><ol><li><p>torch.optim.SGD：<code>torch.optim.SGD(params, lr=&lt;object object&gt;, momentum=0, dampening=0, weight_decay=0, nesterov=False)</code></p><ul><li><p>实现带动量的 SGD 优化算法，并且均可拥有 weight_decay 项。</p></li><li><p><strong>params</strong>(iterable)- 参数组(参数组的概念请查看 3.2 优化器基类：Optimizer)，优化器要管理的那部分参数。</p><p><strong>lr</strong>(float)- 初始学习率，可按需随着训练过程不断调整学习率。</p><p><strong>momentum</strong>(float)- 动量，通常设置为 0.9，0.8</p><p><strong>dampening</strong>(float)- 若采用 nesterov，dampening 必须为 0.</p><p><strong>weight_decay</strong>(float)- 权值衰减系数，也就是 L2 正则项的系数</p><p><strong>nesterov</strong>(bool)- bool 选项，是否使用 NAG(Nesterov accelerated gradient)</p></li></ul></li><li><p>torch.optim.ASGD：<code>torch.optim.ASGD(params, lr=0.01, lambd=0.0001, alpha=0.75, t0=1000000.0, weight_decay=0)</code></p><ul><li><p>ASGD 也称为 SAG，表示随机平均梯度下降(Averaged Stochastic Gradient Descent)，简单地说 ASGD 就是用空间换时间的一种 SGD。</p><p><a href="http://riejohnson.com/rie/stograd_nips.pdf">http://riejohnson.com/rie/stograd_nips.pdf</a> </p></li><li><p><strong>params</strong>(iterable)- 参数组(参数组的概念请查看 3.1 优化器基类：Optimizer)，优化器要优化的那些参数。</p><p><strong>lr</strong>(float)- 初始学习率，可按需随着训练过程不断调整学习率。</p><p><strong>lambd</strong>(float)- 衰减项，默认值 1e-4。</p><p><strong>alpha</strong>(float)- power for eta update ，默认值 0.75。</p><p><strong>t0</strong>(float)- point at which to start averaging，默认值 1e6。</p><p><strong>weight_decay</strong>(float)- 权值衰减系数，也就是 L2 正则项的系数。</p></li></ul></li><li><p>torch.optim.Rprop：<code>torch.optim.Rprop(params, lr=0.01, etas=(0.5, 1.2), step_sizes=(1e-06, 50))</code></p><ul><li><p>实现 Rprop 优化方法(弹性反向传播)，该优化方法适用于 full-batch，不适用于 mini-batch，因而在 mini-batch 大行其道的时代里，很少见到。</p><p>《Martin Riedmiller und Heinrich Braun: Rprop -A Fast Adaptive Learning Algorithm. Proceedings of the International Symposium on Computer and Information Science VII, 1992》</p></li></ul></li><li><p>torch.optim.Adagrad：<code>torch.optim.Adagrad(params, lr=0.01, lr_decay=0, weight_decay=0, initial_accumulator_value=0)</code></p><ul><li><p>Adagrad(Adaptive Gradient) 是一种自适应优化方法，是自适应的为各个参数分配不同的学习率。这个学习率的变化，会受到梯度的大小和迭代次数的影响。梯度越大，学习率越小；梯度越小，学习率越大。缺点是训练后期，学习率过小，因为 Adagrad 累加之前所有的梯度平方作为分母。</p><p><a href="http://www.jmlr.org/papers/volume12/duchi11a/duchi11a.pdf">Adaptive Subgradient Methods for Online Learning and Stochastic Optimization John Duchi, Elad Hazan, Yoram Singer; 12(Jul):2121−2159, 2011.</a></p></li></ul></li><li><p>torch.optim.Adadelta：<code>torch.optim.Adadelta(params, lr=1.0, rho=0.9, eps=1e-06, weight_decay=0)</code></p><ul><li><p>实现 Adadelta 优化方法。<strong>Adadelta</strong> 是 <strong>Adagrad</strong> 的改进。Adadelta 分母中采用距离当前时间点比较近的累计项，这可以避免在训练后期，学习率过小。</p><p><a href="https://arxiv.org/pdf/1212.5701.pdf">https://arxiv.org/pdf/1212.5701.pdf</a></p></li></ul></li><li><p>torch.optim.RMSprop：<code>torch.optim.RMSprop(params, lr=0.01, alpha=0.99, eps=1e-08, weight_decay=0, momentum=0, centered=False)</code></p><ul><li><p>实现 RMSprop 优化方法（Hinton 提出），RMS 是均方根（root meam square）的意思。RMSprop 和 Adadelta 一样，也是对 Adagrad 的一种改进。RMSprop 采用均方根作为分母，可缓解 Adagrad 学习率下降较快的问题，并且引入均方根，可以减少摆动</p><p><a href="http://www.cs.toronto.edu/~tijmen/csc321/slides/lecture_slides_lec6.pdf">http://www.cs.toronto.edu/~tijmen/csc321/slides/lecture_slides_lec6.pdf</a></p></li></ul></li><li><p>torch.optim.Adam(AMSGrad)：<code>torch.optim.Adam(params, lr=0.001, betas=(0.9, 0.999), eps=1e- 08, weight_decay=0, amsgrad=False)</code></p><ul><li><p>实现 Adam(Adaptive Moment Estimation))优化方法。Adam 是一种自适应学习率的优化方法，Adam 利用梯度的一阶矩估计和二阶矩估计动态的调整学习率。吴老师课上说过，Adam 是结合了 Momentum 和 RMSprop，并进行了偏差修正。</p><p><a href="https://arxiv.org/abs/1412.6980">Adam: A Method for Stochastic Optimization</a></p></li><li><p><strong>amsgrad</strong>- 是否采用 AMSGrad 优化方法，asmgrad 优化方法是针对 Adam 的改进，通过添加额外的约束，使学习率始终为正值。</p></li></ul></li><li><p>torch.optim.Adamax：<code>torch.optim.Adamax(params, lr=0.002, betas=(0.9, 0.999), eps=1e-08, weight_decay=0)</code></p><ul><li><p>实现 Adamax 优化方法。Adamax 是对 Adam 增加了一个学习率上限的概念</p><p><a href="https://arxiv.org/abs/1412.6980">Adam: A Method for Stochastic Optimization</a></p></li></ul></li><li><p>torch.optim.SparseAdam：<code>torch.optim.SparseAdam(params, lr=0.001, betas=(0.9, 0.999), eps=1e-08)</code></p><ul><li>针对稀疏张量的一种“阉割版”Adam 优化方法。</li></ul></li><li><p>torch.optim.LBFGS：<code>torch.optim.LBFGS(params, lr=1, max_iter=20, max_eval=None, tolerance_grad=1e-05, tolerance_change=1e-09, history_size=100, line_search_fn=None)</code></p><ul><li>实现 L-BFGS（Limited-memory Broyden–Fletcher–Goldfarb–Shanno）优化方法。L-BFGS 属于拟牛顿算法。L-BFGS 是对 BFGS 的改进，特点就是节省内存。</li></ul></li></ol><h3 id="PyTorch-的六个学习率调整方法-干货"><a href="#PyTorch-的六个学习率调整方法-干货" class="headerlink" title="PyTorch 的六个学习率调整方法(干货)"></a>PyTorch 的六个学习率调整方法(干货)</h3><ol><li><p>StepLR：<code>torch.optim.lr_scheduler.StepLR(optimizer, step_size, gamma=0.1, last_epoch=-1)</code></p><ul><li><p>等间隔调整学习率，调整倍数为 gamma 倍，调整间隔为 step_size。</p><p>间隔单位是 step。需要注意的是，step 通常是指 epoch，不要当成 iteration 。</p></li><li><p><strong>step_size</strong>(int)- 学习率下降间隔数，若为 30，则会在 30、60、90……个 step 时，将学习率调整为 lr*gamma。</p><p><strong>gamma</strong>(float)- 学习率调整倍数，默认为 0.1 倍，即下降 10 倍。</p><p><strong>last_epoch</strong>(int)- 上一个 epoch 数，这个变量用来指示学习率是否需要调整。当 last_epoch 符合设定的间隔时，就会对学习率进行调整。当为 -1 时，学习率设置为初始值。</p></li></ul></li><li><p>MultiStepLR：<code>torch.optim.lr_scheduler.MultiStepLR(optimizer, milestones, gamma=0.1, last_epoch=-1)</code></p><ul><li><p>按设定的间隔调整学习率。这个方法适合后期调试使用，观察 loss 曲线，为每个实验定制学习率调整时机</p></li><li><p><strong>milestones</strong>(list)- 一个 list，每一个元素代表何时调整学习率，list 元素必须是递增的。如 milestones=[30, 80, 120]</p><p><strong>gamma</strong>(float)- 学习率调整倍数，默认为 0.1 倍，即下降 10 倍。</p><p><strong>last_epoch</strong>(int)- 上一个 epoch 数，这个变量用来指示学习率是否需要调整。当 last_epoch 符合设定的间隔时，就会对学习率进行调整。当为 -1 时，学习率设置为初始值。</p></li></ul></li><li><p>ExponentialLR：<code>torch.optim.lr_scheduler.ExponentialLR(optimizer, gamma, last_epoch=-1)</code></p><ul><li><p>按指数衰减调整学习率，调整公式: lr = lr * gamma**epoch</p></li><li><p><strong>gamma</strong>- 学习率调整倍数的底，指数为 epoch，即 gamma**epoch</p><p><strong>last_epoch</strong>(int)- 上一个 epoch 数，这个变量用来指示学习率是否需要调整。当 last_epoch 符合设定的间隔时，就会对学习率进行调整。当为-1 时，学习率设置为初始值。</p></li></ul></li><li><p>CosineAnnealingLR：<code>torch.optim.lr_scheduler.CosineAnnealingLR(optimizer, T_max, eta_min=0, last_epoch=-1)</code></p><ul><li><p>余弦退火，以余弦函数为周期，并在每个周期最大值时重新设置学习率。</p><p><a href="https://arxiv.org/abs/1608.03983">《SGDR: Stochastic Gradient Descent with Warm Restarts》(ICLR-2017)</a></p></li><li><p><strong>T_max</strong>(int)- 一次学习率周期的迭代次数，即 T_max 个 epoch 之后重新设置学习率。</p><p><strong>eta_min</strong>(float)- 最小学习率，即在一个周期中，学习率最小会下降到 eta_min，默认值为 0。</p></li></ul></li><li><p>ReduceLROnPlateau：<code>torch.optim.lr_scheduler.ReduceLROnPlateau(optimizer, mode=&#39;min&#39;,factor=0.1, patience=10, verbose=False, threshold=0.0001, threshold_mode=&#39;rel&#39;, cooldown=0, min_lr=0, eps=1e-08)</code></p><ul><li><p>检测指定的指标，当某指标不再变化（下降或升高）时，调整学习率。这是非常实用的学习率调整策略。</p><p>例如，当验证集的 loss 不再下降时，进行学习率调整；或者监测验证集的 accuracy，当 accuracy 不再上升时，则调整学习率。</p></li><li><p><strong>mode</strong>(str)- 模式选择，有 min 和 max 两种模式，min 表示当指标不再降低(如监测loss)，max 表示当指标不再升高(如监测 accuracy)。</p><p><strong>factor</strong>(float)- 学习率调整倍数(等同于其它方法的 gamma)，即学习率更新为 lr = lr * factor</p><p><strong>patience</strong>(int)- “耐心”，即忍受该指标多少个 step 不变化，当忍无可忍时，调整学习率。</p><p><strong>verbose</strong>(bool)- 是否打印学习率信息：print(‘Epoch {:5d}: reducing learning rate’ ‘ of group {} to {:.4e}.’.format(epoch, i, new_lr))</p><p><strong>threshold</strong>(float)- Threshold for measuring the new optimum，配合 threshold_mode 使用。</p><p><strong>threshold_mode</strong>(str)- 选择判断指标是否达最优的模式，有两种模式，rel 和 abs。 当 threshold_mode=rel，并且 mode=max 时，dynamic_threshold = best * ( 1 + threshold )；</p><p>​        当 threshold_mode=rel，并且 mode=min 时，dynamic_threshold = best * ( 1 -threshold )； </p><p>​        当 threshold_mode=abs，并且 mode=max 时，dynamic_threshold = best + threshold ； </p><p>​        当 threshold_mode=rel，并且 mode=max 时，dynamic_threshold = best - threshold </p><p><strong>cooldown</strong>(int)- “冷却时间“，当调整学习率之后，让学习率调整策略冷静一下，让模型再训练一段时间，再重启监测模式。</p><p><strong>min_lr</strong>(float or list)- 学习率下限，可为 float，或者 list，当有多个参数组时，可用 list 进行设置。</p><p><strong>eps</strong>(float)- 学习率衰减的最小值，当学习率变化小于 eps 时，则不调整学习率。</p></li></ul></li><li><p>LambdaLR：<code>torch.optim.lr_scheduler.LambdaLR(optimizer, lr_lambda, last_epoch=- 1)</code></p><ul><li><p>为不同参数组自定义学习率调整策略。调整规则为，lr = base_lr * lmbda(self.last_epoch) 。</p></li><li><p><strong>lr_lambda</strong>(function or list)- 一个计算学习率调整倍数的函数，输入通常为 step，当有多个参数组时，设为 list。</p><p><strong>last_epoch</strong>(int)- 上一个 epoch 数，这个变量用来指示学习率是否需要调整。当 last_epoch 符合设定的间隔时，就会对学习率进行调整。当为-1 时，学习率设置为初始值。</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">model = resnet18(pretrained=<span class="literal">False</span>)  <span class="comment"># 加载模型</span></span><br><span class="line">optimizer = torch.optim.SGD(params=[  <span class="comment"># 初始化优化器，并设置两个param_groups</span></span><br><span class="line">    &#123;<span class="string">&#x27;params&#x27;</span>: model.layer2.parameters()&#125;,</span><br><span class="line">    &#123;<span class="string">&#x27;params&#x27;</span>: model.layer3.parameters(), <span class="string">&#x27;lr&#x27;</span>: <span class="number">0.2</span>&#125;,</span><br><span class="line">], lr=<span class="number">1</span>, momentum=<span class="number">0.9</span>, weight_decay=<span class="number">0.005</span>)  <span class="comment"># base_lr = 0.1</span></span><br><span class="line"></span><br><span class="line">epochs = <span class="number">500</span>  <span class="comment"># 训练次数</span></span><br><span class="line">warm_up_epoch = <span class="number">5</span></span><br><span class="line">t_max = epochs - warm_up_epoch  <span class="comment"># cos衰减周期</span></span><br><span class="line">lr_max = <span class="number">0.1</span>  <span class="comment"># 最大值</span></span><br><span class="line">lr_min = <span class="number">0.001</span>  <span class="comment"># 最小值</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_warmup_cos_lambda</span>(<span class="params">lr_max, lr_min, start, warm_up_epoch, t_max</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">warmup_cos_lambda</span>(<span class="params">cur_epoch</span>):</span></span><br><span class="line">        <span class="keyword">if</span> cur_epoch &lt; start:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">elif</span> cur_epoch &lt; warm_up_epoch + start:</span><br><span class="line">            <span class="keyword">return</span> (cur_epoch - start) / warm_up_epoch + lr_min</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> (lr_max - lr_min) * (<span class="number">1.0</span> + math.cos((cur_epoch - start - warm_up_epoch) / t_max * math.pi)) / <span class="number">2</span> + lr_min</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> warmup_cos_lambda</span><br><span class="line"></span><br><span class="line"><span class="comment"># LambdaLR</span></span><br><span class="line">scheduler = torch.optim.lr_scheduler.LambdaLR(</span><br><span class="line">    optimizer,</span><br><span class="line">    lr_lambda=[</span><br><span class="line">        get_warmup_cos_lambda(lr_max, lr_min, <span class="number">0</span>, warm_up_epoch, t_max),</span><br><span class="line">        get_warmup_cos_lambda(lr_max, lr_min, <span class="number">5</span>, warm_up_epoch, t_max)</span><br><span class="line">    ]</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> epoch <span class="keyword">in</span> <span class="built_in">range</span>(epochs):</span><br><span class="line">    print(optimizer.param_groups[<span class="number">0</span>][<span class="string">&#x27;lr&#x27;</span>], optimizer.param_groups[<span class="number">1</span>][<span class="string">&#x27;lr&#x27;</span>])</span><br><span class="line">    optimizer.step()</span><br><span class="line">    scheduler.step()</span><br></pre></td></tr></table></figure><h3 id="scheduler-step"><a href="#scheduler-step" class="headerlink" title="scheduler.step()"></a>scheduler.step()</h3></li></ol><ul><li>当调用 <code>scheduler.step(epoch=None)</code> 时，如果不传入 epoch，默认成员变量 last_epoch+=1，如果传入 epoch，则直接更新 last_epoch。</li><li>因此，scheduler.step() 要放在 epoch 的 for 循环当中执行。当然也可以放在每个 batch 的 iter 中更新，这样更加细致。</li><li>更新完 last_epoch 之后，则调用 <code>get_lr()</code> 获取当前 epoch 下，该参数组的学习率。</li></ul><h2 id="可视化"><a href="#可视化" class="headerlink" title="可视化"></a>可视化</h2><h3 id="TensorBoardX"><a href="#TensorBoardX" class="headerlink" title="TensorBoardX"></a>TensorBoardX</h3><ul><li>无法显示图表有可能是因为浏览器差异。</li></ul><h4 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h4><blockquote><p>在浏览器中查看可视化数据，只要在命令行中开启 tensorboard ：<code>tensorboard --logdir=&lt;your_log_dir&gt;</code></p><p>其中的 <your_log_dir> 既可以是单个 run 的路径，也可以是多个 run 的父目录。如 runs/ 下面可能会有很多的子文件夹，每个文件夹都代表了一次实验，我们令 –logdir=runs/ 就可以在 tensorboard 可视化界面中方便地横向比较不同实验所得数据的差异。</your_log_dir></p></blockquote><ol><li><p>SummaryWriter：<code>SummaryWriter(logdir=None, comment=&quot;&quot;, purge_step=None, max_queue=10, flush_secs=120, filename_suffix=&#39;&#39;, write_to_disk=True, log_dir=None, comet_config=&#123;&quot;disabled&quot;: True&#125;, **kwargs)</code></p><ul><li><p>创建一个 SummaryWriter 的实例</p></li><li><p><strong>logdir</strong>- 用该路径来保存日志。无参数，默认将使用 runs/日期时间</p><p><strong>comment</strong>- 文件夹后缀，将使用 runs/日期时间-comment 路径来保存日志</p><p><strong>filename_suffix</strong>- 设置 event file 文件名后缀</p></li><li><p>```python<br>writer = SummaryWriter(log_dir=’./tensorboard event file’, filename_suffix=str(cfg.EPOCH_NUMBER), comment=’test_tensorboard’)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">2. add_scalar：&#96;add_scalar(tag, scalar_value, global_step&#x3D;None, walltime&#x3D;None)&#96;</span><br><span class="line"></span><br><span class="line">   - 在一个图表中记录一个标量的变化，常用于 loss、accuracy、learning rate 曲线的记录。</span><br><span class="line"></span><br><span class="line">   - **tag**(string)- 该图的标签，类似于 polt.title</span><br><span class="line"></span><br><span class="line">     **scalar_value**(float or string&#x2F;blobname)- 用于存储的值，曲线图的 y 坐标。注意，对于 PyTorch scalar tensor，需要调用 &#96;.item()&#96; 方法获取其数值</span><br><span class="line"></span><br><span class="line">     **global_step**(int)- 曲线图的 x 坐标</span><br><span class="line"></span><br><span class="line">     **walltime**(float)- 为 event 文件的文件名设置时间，默认为 time.time()</span><br><span class="line">     </span><br><span class="line">   - &#96;&#96;&#96;python</span><br><span class="line">     writer.add_scalar(&#39;Train Loss&#39;, train_loss &#x2F; num_mini_batch, epoch)</span><br></pre></td></tr></table></figure></li></ul></li><li><p>add_scalars：<code>add_scalars(main_tag, tag_scalar_dict, global_step=None, walltime=None)</code></p><ul><li><p>在一个图表中记录多个标量的变化，常用于对比，如 trainLoss 和 validLoss 的比较等。</p></li><li><p><strong>main_tag</strong>(string)- 该图的标签。</p><p><strong>tag_scalar_dict</strong>(dict)- key 是变量的 tag，value 是变量的值。</p><p><strong>global_step</strong>(int)- 曲线图的 x 坐标</p><p><strong>walltime</strong>(float)- 为 event 文件的文件名设置时间，默认为 time.time()</p></li><li><pre><code class="python">    writer.add_scalars(&#39;data/scalar_group&#39;, &#123;&quot;xsinx&quot;: x * np.sin(x),                                             &quot;xcosx&quot;: x * np.cos(x),                                             &quot;arctanx&quot;: np.arctan(x)&#125;, x)<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">4. add_histogram：&#96;add_histogram(tag, values, global_step&#x3D;None, bins&#x3D;&#39;tensorflow&#39;, walltime&#x3D;None)&#96;</span><br><span class="line"></span><br><span class="line">   - 绘制直方图和多分位数折线图，常用于监测权值及梯度的分布变化情况，便于诊断网络更新方向是否正确。</span><br><span class="line"></span><br><span class="line">   - **tag**(string)- 该图的标签，类似于 polt.title。</span><br><span class="line"></span><br><span class="line">     **values**(torch.Tensor, numpy.array or string&#x2F;blobname)- 用于绘制直方图的值</span><br><span class="line"></span><br><span class="line">     **global_step**(int)- 曲线图的 y 坐标</span><br><span class="line"></span><br><span class="line">     **bins**(string)- 决定如何取 bins，默认为‘tensorflow’，可选：’auto’, ‘fd’等</span><br><span class="line"></span><br><span class="line">     **walltime**(float)- 为 event 文件的文件名设置时间，默认为 time.time()</span><br><span class="line"></span><br><span class="line">5. add_image：&#96;add_image(tag, img_tensor, global_step&#x3D;None, walltime&#x3D;None)&#96;</span><br><span class="line"></span><br><span class="line">   - 绘制图片，可用于检查模型的输入，监测 feature map 的变化，或是观察 weight。</span><br><span class="line"></span><br><span class="line">   - **tag**(string)- 该图的标签，类似于 polt.title。</span><br><span class="line"></span><br><span class="line">     **img_tensor**(torch.Tensor,numpy.array, or string&#x2F;blobname)- 需要可视化的图片数据， shape &#x3D; [C,H,W]。</span><br><span class="line"></span><br><span class="line">     **global_step**(int)- x 坐标。</span><br><span class="line"></span><br><span class="line">     **walltime**(float)- 为 event 文件的文件名设置时间，默认为 time.time()。</span><br><span class="line"></span><br><span class="line">   - 通常会借助 torchvision.utils.make_grid() 将一组图片绘制到一个窗口</span><br><span class="line"></span><br><span class="line">   - torchvision.utils.make_grid：&#96;torchvision.utils.make_grid(tensor, nrow&#x3D;8, padding&#x3D;2, normalize&#x3D;False, range&#x3D;None, scale_each&#x3D;False, pad_value&#x3D;0)&#96;</span><br><span class="line"></span><br><span class="line">     - 将一组图片拼接成一张图片，便于可视化。</span><br><span class="line"></span><br><span class="line">     - **tensor**(Tensor or list)- 需可视化的数据，shape:(B x C x H x W) ,B 表示 batch 数，即几张图片</span><br><span class="line"></span><br><span class="line">       **nrow**(int)- 一行显示几张图，默认值为 8。</span><br><span class="line"></span><br><span class="line">       **padding**(int)- 每张图片之间的间隔，默认值为 2。</span><br><span class="line"></span><br><span class="line">       **normalize**(bool)- 是否进行归一化至(0,1)。</span><br><span class="line"></span><br><span class="line">       **range**(tuple)- 设置归一化的 min 和 max，若不设置，默认从 tensor 中找 min 和 max。</span><br><span class="line"></span><br><span class="line">       **scale_each**(bool)- 每张图片是否单独进行归一化，还是 min 和 max 的一个选择。</span><br><span class="line"></span><br><span class="line">       **pad_value**(float)- 填充部分的像素值，默认为 0，即黑色。</span><br><span class="line"></span><br><span class="line">6. add_graph：&#96;add_graph(model, input_to_model&#x3D;None, verbose&#x3D;False, **kwargs)&#96;</span><br><span class="line"></span><br><span class="line">   - 绘制网络结构拓扑图。</span><br><span class="line"></span><br><span class="line">   - **model**(torch.nn.Module)- 模型实例</span><br><span class="line"></span><br><span class="line">     **inpjt_to_model**(torch.autograd.Variable)- 模型的输入数据，可以生成一个随机数，只要 shape 符合要求即可</span><br><span class="line">     </span><br><span class="line">   - &#96;&#96;&#96;python</span><br><span class="line">     init_img &#x3D; torch.zeros((1, 3, 400, 400), device&#x3D;device)</span><br><span class="line">     init_msg &#x3D; torch.zeros((1, secret_size), device&#x3D;device)</span><br><span class="line">     tb_writer.add_graph(StegaStampEncoder, &#123;&quot;img&quot;: init_img, &quot;msg&quot;: init_msg&#125;)</span><br></pre></td></tr></table></figure></code></pre></li><li><p>另外一种用于 debug 检查模型的方法：summary() 可输出模型每层输入输出的 shape 以及模型总量。使用前需要在终端 pip install torchsummary。</p><ul><li><pre><code class="python">from torchsummary import summaryprint(summary(net, (3, 360, 640), device=&quot;cpu&quot;))<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">7. add_embedding：&#96;add_embedding(mat, metadata&#x3D;None, label_img&#x3D;None, global_step&#x3D;None, tag&#x3D;&#39;default&#39;, metadata_header&#x3D;None)&#96;</span><br><span class="line"></span><br><span class="line">   - 在三维空间或二维空间展示数据分布，可选 T-SNE、PCA 和 CUSTOM 方法。</span><br><span class="line"></span><br><span class="line">   - **mat**(torch.Tensor or numpy.array)- 需要绘制的数据，一个样本必须是一个向量形式。</span><br><span class="line"></span><br><span class="line">     **shape** &#x3D; (N,D)，N 是样本数，D 是特征维数。</span><br><span class="line"></span><br><span class="line">     **metadata**(list)- 数据的标签，是一个 list，长度为 N。</span><br><span class="line"></span><br><span class="line">     **label_img**(torch.Tensor)- 空间中展示的图片，shape &#x3D; (N,C,H,W)。</span><br><span class="line"></span><br><span class="line">     **global_step**(int)- Global step value to record，不理解这里有何用处呢？知道的朋友补充一下吧。</span><br><span class="line"></span><br><span class="line">     **tag**(string)- 标签</span><br><span class="line"></span><br><span class="line">8. add_text：&#96;add_text(tag, text_string, global_step&#x3D;None, walltime&#x3D;None)&#96;</span><br><span class="line"></span><br><span class="line">   - 记录文字</span><br><span class="line"></span><br><span class="line">9. add_video：&#96;add_video(tag, vid_tensor, global_step&#x3D;None, fps&#x3D;4, walltime&#x3D;None)&#96;</span><br><span class="line"></span><br><span class="line">   - 记录 video</span><br><span class="line"></span><br><span class="line">10. add_figure：&#96;add_figure(tag, figure, global_step&#x3D;None, close&#x3D;True, walltime&#x3D;None)&#96;</span><br><span class="line"></span><br><span class="line">    - 添加 matplotlib 图片到图像中</span><br><span class="line"></span><br><span class="line">11. add_image_with_boxes：&#96;add_image_with_boxes(tag, img_tensor, box_tensor, global_step&#x3D;None, walltime&#x3D;None, **kwargs)&#96;</span><br><span class="line"></span><br><span class="line">    - 图像中绘制 Box，目标检测中会用到</span><br><span class="line"></span><br><span class="line">12. add_pr_curve：&#96;add_pr_curve(tag, labels, predictions, global_step&#x3D;None, num_thresholds&#x3D;127, weights&#x3D;None, walltime&#x3D;None)&#96;</span><br><span class="line"></span><br><span class="line">    - 绘制 PR 曲线</span><br><span class="line"></span><br><span class="line">13. add_pr_curve_raw：&#96;add_pr_curve_raw(tag, true_positive_counts, false_positive_counts, true_negative_counts, false_negative_counts, precision, recall, global_step&#x3D;None, num_thresholds&#x3D;127, weights&#x3D;None, walltime&#x3D;None)&#96;</span><br><span class="line"></span><br><span class="line">    - 从原始数据上绘制 PR 曲线</span><br><span class="line"></span><br><span class="line">14. export_scalars_to_json：&#96;export_scalars_to_json(path)&#96;</span><br><span class="line"></span><br><span class="line">    - 将 scalars 信息保存到 json 文件，便于后期使用</span><br><span class="line"></span><br><span class="line">#### 卷积核可视化 </span><br><span class="line"></span><br><span class="line">- 神经网络中最重要的就是权值，而人们对神经网络理解有限，所以我们需要通过尽可能了解权值来帮助诊断网络的训练情况。除了查看权值分布图和多折线分位图，还可以对卷积核权值进行可视化，来辅助我们分析网络。对卷积核权值进行可视化，在一定程度上帮助我们诊断网络的训练好坏，因此对卷积核权值的可视化十分有必要。</span><br><span class="line">- 可视化原理很简单，对单个卷积核进行“归一化”至 0～255，然后将其展现出来即可，这一系列操作可以借助 TensorboardX 的 add_image 来实现。</span><br><span class="line">- 决定一张特征图需要的卷积核的维度由输入通道决定，生成的特征图数量由卷积核的数量决定。</span><br><span class="line"></span><br><span class="line">&#96;&#96;&#96;python</span><br><span class="line">import os</span><br><span class="line">import torch</span><br><span class="line">import torchvision.utils as vutils</span><br><span class="line">from tensorboardX import SummaryWriter</span><br><span class="line">import torch.nn as nn</span><br><span class="line">import torch.nn.functional as F</span><br><span class="line"></span><br><span class="line">net &#x3D; Net()  # 创建一个网络</span><br><span class="line">pretrained_dict &#x3D; torch.load(os.path.join(&quot;..&quot;, &quot;2_model&quot;, &quot;net_params.pkl&quot;))</span><br><span class="line">net.load_state_dict(pretrained_dict)</span><br><span class="line"></span><br><span class="line">writer &#x3D; SummaryWriter(log_dir&#x3D;os.path.join(&quot;..&quot;, &quot;..&quot; &quot;Result&quot;, &quot;visual_weights&quot;))</span><br><span class="line">params &#x3D; net.state_dict()</span><br><span class="line">for k, v in params.items():</span><br><span class="line">    if &#39;conv&#39; in k and &#39;weight&#39; in k:</span><br><span class="line"></span><br><span class="line">        c_int &#x3D; v.size()[1]  # 输入层通道数</span><br><span class="line">        c_out &#x3D; v.size()[0]  # 输出层通道数</span><br><span class="line"></span><br><span class="line">        # 以feature map为单位，绘制一组卷积核，一张feature map对应的卷积核个数为输入通道数</span><br><span class="line">        for j in range(c_out):</span><br><span class="line">            print(k, v.size(), j)</span><br><span class="line">            kernel_j &#x3D; v[j, :, :, :].unsqueeze(1)  # 压缩维度，为make_grid制作输入</span><br><span class="line">            kernel_grid &#x3D; vutils.make_grid(kernel_j, normalize&#x3D;True, scale_each&#x3D;True, nrow&#x3D;c_int)  # 1*输入通道数, w, h</span><br><span class="line">            writer.add_image(k + &#39;_split_in_channel&#39;, kernel_grid, global_step&#x3D;j)  # j 表示feature map数</span><br><span class="line"></span><br><span class="line">        # 将一个卷积层的卷积核绘制在一起，每一行是一个 feature map 的卷积核</span><br><span class="line">        k_w, k_h &#x3D; v.size()[-1], v.size()[-2]</span><br><span class="line">        kernel_all &#x3D; v.view(-1, 1, k_w, k_h)</span><br><span class="line">        kernel_grid &#x3D; vutils.make_grid(kernel_all, normalize&#x3D;True, scale_each&#x3D;True, nrow&#x3D;c_int)  # 1*输入通道数, w, h</span><br><span class="line">        writer.add_image(k + &#39;_all&#39;, kernel_grid, global_step&#x3D;666)</span><br><span class="line">writer.close()</span><br></pre></td></tr></table></figure>#### 特征图可视化</code></pre></li></ul></li></ul></li><li><p>获取图片，将其转换成模型输入前的数据格式，即一系列 transform，</p></li><li><p>获取模型各层操作，手动的执行每一层操作，拿到所需的 feature maps，</p></li><li><p>借助 tensorboardX 进行绘制。</p></li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> torchvision.utils <span class="keyword">as</span> vutils</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> tensorboardX <span class="keyword">import</span> SummaryWriter</span><br><span class="line"><span class="keyword">import</span> torch.nn.functional <span class="keyword">as</span> F</span><br><span class="line"><span class="keyword">import</span> torchvision.transforms <span class="keyword">as</span> transforms</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line">sys.path.append(<span class="string">&quot;..&quot;</span>)</span><br><span class="line"><span class="keyword">from</span> utils.utils <span class="keyword">import</span> MyDataset, Net, normalize_invert</span><br><span class="line"><span class="keyword">from</span> torch.utils.data <span class="keyword">import</span> DataLoader</span><br><span class="line"></span><br><span class="line">vis_layer = <span class="string">&#x27;conv1&#x27;</span></span><br><span class="line">log_dir = os.path.join(<span class="string">&quot;..&quot;</span>, <span class="string">&quot;..&quot;</span> <span class="string">&quot;Result&quot;</span>, <span class="string">&quot;visual_featuremaps&quot;</span>)</span><br><span class="line">txt_path = os.path.join(<span class="string">&quot;..&quot;</span>, <span class="string">&quot;..&quot;</span>, <span class="string">&quot;Data&quot;</span>, <span class="string">&quot;visual.txt&quot;</span>)</span><br><span class="line">pretrained_path = os.path.join(<span class="string">&quot;..&quot;</span>, <span class="string">&quot;..&quot;</span>, <span class="string">&quot;Data&quot;</span>, <span class="string">&quot;net_params_72p.pkl&quot;</span>)</span><br><span class="line"></span><br><span class="line">net = Net()</span><br><span class="line">net.load_state_dict(torch.load(pretrained_path))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 数据预处理</span></span><br><span class="line">normMean = [<span class="number">0.49139968</span>, <span class="number">0.48215827</span>, <span class="number">0.44653124</span>]</span><br><span class="line">normStd = [<span class="number">0.24703233</span>, <span class="number">0.24348505</span>, <span class="number">0.26158768</span>]</span><br><span class="line">testTransform = transforms.Compose([</span><br><span class="line">    transforms.Resize((<span class="number">32</span>, <span class="number">32</span>)),</span><br><span class="line">    transforms.ToTensor(),</span><br><span class="line">    transforms.Normalize(normMean, normStd)</span><br><span class="line">])</span><br><span class="line"><span class="comment"># 载入数据</span></span><br><span class="line">test_data = MyDataset(txt_path=txt_path, transform=testTransform)</span><br><span class="line">test_loader = DataLoader(dataset=test_data, batch_size=<span class="number">1</span>)</span><br><span class="line">img, label = <span class="built_in">iter</span>(test_loader).<span class="built_in">next</span>()</span><br><span class="line"></span><br><span class="line">x = img</span><br><span class="line">writer = SummaryWriter(log_dir=log_dir)</span><br><span class="line"><span class="keyword">for</span> name, layer <span class="keyword">in</span> net._modules.items():</span><br><span class="line">    <span class="comment"># 为fc层预处理x</span></span><br><span class="line">    x = x.view(x.size(<span class="number">0</span>), -<span class="number">1</span>) <span class="keyword">if</span> <span class="string">&quot;fc&quot;</span> <span class="keyword">in</span> name <span class="keyword">else</span> x</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 对x执行单层运算</span></span><br><span class="line">    x = layer(x)</span><br><span class="line">    print(x.size())</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 由于__init__()相较于forward()缺少relu操作，需要手动增加</span></span><br><span class="line">    x = F.relu(x) <span class="keyword">if</span> <span class="string">&#x27;conv&#x27;</span> <span class="keyword">in</span> name <span class="keyword">else</span> x</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 依据选择的层，进行记录feature maps</span></span><br><span class="line">    <span class="keyword">if</span> name == vis_layer:</span><br><span class="line">        <span class="comment"># 绘制feature maps</span></span><br><span class="line">        x1 = x.transpose(<span class="number">0</span>, <span class="number">1</span>)  <span class="comment"># C，B, H, W  ---&gt; B，C, H, W</span></span><br><span class="line">        img_grid = vutils.make_grid(x1, normalize=<span class="literal">True</span>, scale_each=<span class="literal">True</span>, nrow=<span class="number">2</span>)  <span class="comment"># B，C, H, W</span></span><br><span class="line">        writer.add_image(vis_layer + <span class="string">&#x27;_feature_maps&#x27;</span>, img_grid, global_step=<span class="number">666</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 绘制原始图像</span></span><br><span class="line">        img_raw = normalize_invert(img, normMean, normStd)  <span class="comment"># 图像去标准化</span></span><br><span class="line">        img_raw = np.array(img_raw * <span class="number">255</span>).clip(<span class="number">0</span>, <span class="number">255</span>).squeeze().astype(<span class="string">&#x27;uint8&#x27;</span>)</span><br><span class="line">        writer.add_image(<span class="string">&#x27;raw img&#x27;</span>, img_raw, global_step=<span class="number">666</span>)  <span class="comment"># j 表示feature map数</span></span><br><span class="line">writer.close()</span><br></pre></td></tr></table></figure><h4 id="梯度及权值分布可视化"><a href="#梯度及权值分布可视化" class="headerlink" title="梯度及权值分布可视化"></a>梯度及权值分布可视化</h4><h5 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h5><ul><li>在网络训练过程中，我们常常会遇到梯度消失、梯度爆炸等问题，我们可以通过记录每个 epoch 的梯度的值来监测梯度的情况，还可以记录权值，分析权值更新的方向是否符合规律。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">from</span> torch.utils.data <span class="keyword">import</span> DataLoader</span><br><span class="line"><span class="keyword">import</span> torchvision.transforms <span class="keyword">as</span> transforms</span><br><span class="line"><span class="keyword">from</span> torch.autograd <span class="keyword">import</span> Variable</span><br><span class="line"><span class="keyword">import</span> torch.nn <span class="keyword">as</span> nn</span><br><span class="line"><span class="keyword">import</span> torch.optim <span class="keyword">as</span> optim</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line">sys.path.append(<span class="string">&quot;..&quot;</span>)</span><br><span class="line"><span class="keyword">from</span> utils.utils <span class="keyword">import</span> MyDataset, validate, show_confMat, Net</span><br><span class="line"><span class="keyword">from</span> tensorboardX <span class="keyword">import</span> SummaryWriter</span><br><span class="line">train_txt_path = os.path.join(<span class="string">&quot;..&quot;</span>, <span class="string">&quot;..&quot;</span>, <span class="string">&quot;Data&quot;</span>, <span class="string">&quot;train.txt&quot;</span>)</span><br><span class="line">valid_txt_path = os.path.join(<span class="string">&quot;..&quot;</span>, <span class="string">&quot;..&quot;</span>, <span class="string">&quot;Data&quot;</span>, <span class="string">&quot;valid.txt&quot;</span>)</span><br><span class="line"></span><br><span class="line">classes_name = [<span class="string">&#x27;plane&#x27;</span>, <span class="string">&#x27;car&#x27;</span>, <span class="string">&#x27;bird&#x27;</span>, <span class="string">&#x27;cat&#x27;</span>, <span class="string">&#x27;deer&#x27;</span>, <span class="string">&#x27;dog&#x27;</span>, <span class="string">&#x27;frog&#x27;</span>, <span class="string">&#x27;horse&#x27;</span>, <span class="string">&#x27;ship&#x27;</span>, <span class="string">&#x27;truck&#x27;</span>]</span><br><span class="line"></span><br><span class="line">train_bs = <span class="number">16</span></span><br><span class="line">valid_bs = <span class="number">16</span></span><br><span class="line">lr_init = <span class="number">0.001</span></span><br><span class="line">max_epoch = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># log</span></span><br><span class="line">log_dir = os.path.join(<span class="string">&quot;..&quot;</span>, <span class="string">&quot;..&quot;</span>, <span class="string">&quot;Result&quot;</span>, <span class="string">&quot;hist_grad_weight&quot;</span>)</span><br><span class="line"></span><br><span class="line">writer = SummaryWriter(log_dir=log_dir)</span><br><span class="line"></span><br><span class="line"><span class="comment"># ------------------------------------ step 1/4 : 加载数据-------------------------------------------------</span></span><br><span class="line"><span class="comment"># 数据预处理设置</span></span><br><span class="line">normMean = [<span class="number">0.4948052</span>, <span class="number">0.48568845</span>, <span class="number">0.44682974</span>]</span><br><span class="line">normStd = [<span class="number">0.24580306</span>, <span class="number">0.24236229</span>, <span class="number">0.2603115</span>]</span><br><span class="line">trainTransform = transforms.Compose([</span><br><span class="line">    transforms.Resize(<span class="number">32</span>),</span><br><span class="line">    transforms.RandomCrop(<span class="number">32</span>, padding=<span class="number">4</span>),</span><br><span class="line">    transforms.ToTensor(),</span><br><span class="line">    transforms.Normalize(normMean, normStd)</span><br><span class="line">])</span><br><span class="line"></span><br><span class="line">validTransform = transforms.Compose([</span><br><span class="line">    transforms.ToTensor(),</span><br><span class="line">    transforms.Normalize(normMean, normStd)</span><br><span class="line">])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 构建MyDataset实例</span></span><br><span class="line">train_data = MyDataset(txt_path=train_txt_path, transform=trainTransform)</span><br><span class="line">valid_data = MyDataset(txt_path=valid_txt_path, transform=validTransform)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 构建DataLoder</span></span><br><span class="line">train_loader = DataLoader(dataset=train_data, batch_size=train_bs, shuffle=<span class="literal">True</span>)</span><br><span class="line">valid_loader = DataLoader(dataset=valid_data, batch_size=valid_bs)</span><br><span class="line"></span><br><span class="line"><span class="comment"># ------------------------------------ step 2/4 : 网络初始化----------------------------------------------</span></span><br><span class="line">net = Net()  <span class="comment"># 创建一个网络</span></span><br><span class="line">net.initialize_weights()  <span class="comment"># 初始化权值</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ------------------------------------ step 3/4 : 定义损失函数和优化器 ------------------------------------</span></span><br><span class="line">criterion = nn.CrossEntropyLoss()  <span class="comment"># 选择损失函数</span></span><br><span class="line">optimizer = optim.SGD(net.parameters(), lr=lr_init, momentum=<span class="number">0.9</span>, dampening=<span class="number">0.1</span>)  <span class="comment"># 选择优化器</span></span><br><span class="line">scheduler = torch.optim.lr_scheduler.StepLR(optimizer, step_size=<span class="number">50</span>, gamma=<span class="number">0.1</span>)  <span class="comment"># 设置学习率下降策略</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ------------------------------------ step 4/4 : 训练 --------------------------------------------------</span></span><br><span class="line"><span class="keyword">for</span> epoch <span class="keyword">in</span> <span class="built_in">range</span>(max_epoch):</span><br><span class="line">    loss_sigma = <span class="number">0.0</span>  <span class="comment"># 记录一个epoch的loss之和</span></span><br><span class="line">    correct = <span class="number">0.0</span></span><br><span class="line">    total = <span class="number">0.0</span></span><br><span class="line">    scheduler.step()  <span class="comment"># 更新学习率</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i, data <span class="keyword">in</span> <span class="built_in">enumerate</span>(train_loader):</span><br><span class="line">        <span class="comment"># 获取图片和标签</span></span><br><span class="line">        inputs, labels = data</span><br><span class="line">        inputs, labels = Variable(inputs), Variable(labels)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># forward, backward, update weights</span></span><br><span class="line">        optimizer.zero_grad()</span><br><span class="line">        outputs = net(inputs)</span><br><span class="line">        loss = criterion(outputs, labels)</span><br><span class="line">        loss.backward()</span><br><span class="line">        optimizer.step()</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 统计预测信息</span></span><br><span class="line">        _, predicted = torch.<span class="built_in">max</span>(outputs.data, <span class="number">1</span>)</span><br><span class="line">        total += labels.size(<span class="number">0</span>)</span><br><span class="line">        correct += (predicted == labels).squeeze().<span class="built_in">sum</span>().numpy()</span><br><span class="line">        loss_sigma += loss.item()</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 每10个iteration 打印一次训练信息，loss为10个iteration的平均</span></span><br><span class="line">        <span class="keyword">if</span> i % <span class="number">10</span> == <span class="number">9</span>:</span><br><span class="line">            loss_avg = loss_sigma / <span class="number">10</span></span><br><span class="line">            loss_sigma = <span class="number">0.0</span></span><br><span class="line">            print(<span class="string">&quot;Training: Epoch[&#123;:0&gt;3&#125;/&#123;:0&gt;3&#125;] Iteration[&#123;:0&gt;3&#125;/&#123;:0&gt;3&#125;] Loss: &#123;:.4f&#125; Acc:&#123;:.2%&#125;&quot;</span>.<span class="built_in">format</span>(</span><br><span class="line">                epoch + <span class="number">1</span>, max_epoch, i + <span class="number">1</span>, <span class="built_in">len</span>(train_loader), loss_avg, correct / total))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 每个epoch，记录梯度，权值</span></span><br><span class="line">    <span class="keyword">for</span> name, layer <span class="keyword">in</span> net.named_parameters():</span><br><span class="line">        writer.add_histogram(name + <span class="string">&#x27;_grad&#x27;</span>, layer.grad.cpu().data.numpy(), epoch)</span><br><span class="line">        writer.add_histogram(name + <span class="string">&#x27;_data&#x27;</span>, layer.cpu().data.numpy(), epoch)</span><br><span class="line"></span><br><span class="line">print(<span class="string">&#x27;Finished Training&#x27;</span>)</span><br></pre></td></tr></table></figure><h5 id="可视化分析"><a href="#可视化分析" class="headerlink" title="可视化分析"></a>可视化分析</h5><h6 id="权值-weights-的监控"><a href="#权值-weights-的监控" class="headerlink" title="权值 weights 的监控"></a>权值 weights 的监控</h6><p>经过 100 个 epoch 的训练，来看看第一个卷积层的权值分布的变化。x 轴即变量大小，y 轴为 gloabl_step。</p><p>图 1 x=0.306， y=0， 数值显示为 0.00，表示第 0 个 epoch 时，权值为 0.306 的个数为 0.00。 </p><img src="/2021/09/PyTorch-Part2/image-20210914221527396.png" alt="image-20210914221527396" style="zoom:67%;"><p>图 2， x=0.306， y=85， 数值显示为 5.71，表示第 85 个 epoch 时，权值在 0.306 区间的有 5.71 个。</p><img src="/2021/09/PyTorch-Part2/image-20210914221609780.png" alt="image-20210914221609780" style="zoom:67%;"><p>通过 HISTOGRAMS 可以看到第一个卷积层的权值随着训练的不断的“扩散”，一开始是个比较标准的高斯分布，并且最大值不会超过 0.3。</p><p>而到了后期，权值会发散到 0.6+，这个问题也是需要关注的，若权值太大容易导致过拟合。因为模型的输出值会被该特征所主导，从而引起过拟合现象，这个可以通过权值衰减(weight_decay)来缓解。</p><h6 id="偏置-bias-的监控"><a href="#偏置-bias-的监控" class="headerlink" title="偏置 bias 的监控"></a>偏置 bias 的监控</h6><p>通常会监控输出层的 bias 的大小，若有特别大，或者特别小的 bias，那么某一类别的召回率可能会很低，可以通过观察输出层的 bias 来诊断是否在这一环节出问题。</p><p>从图上可以看到，一开始 10 个类别的 bias 都比较小，随着训练的进行，每个类别都有了自己的固定的 bias 大小。</p><img src="/2021/09/PyTorch-Part2/image-20210914221837983.png" alt="image-20210914221837983" style="zoom:67%;"><h6 id="梯度的监控"><a href="#梯度的监控" class="headerlink" title="梯度的监控"></a>梯度的监控</h6><p>下图为第一个卷积层权值的梯度变化情况，可以看到，几乎都是服从高斯分布的。倘若前面几层的梯度非常小，那么就是梯度流通不畅导致的，可以考虑残差结构或者辅助损失层等 trick 来解决梯度消失。</p><img src="/2021/09/PyTorch-Part2/image-20210914221932315.png" alt="image-20210914221932315" style="zoom:67%;"><h6 id="文末思考："><a href="#文末思考：" class="headerlink" title="文末思考："></a>文末思考：</h6><ol><li><p>通过观察各层的梯度，权值分布，我们可以针对性的设置学习率，为那些梯度小的层设置更大的学习率，让那些层可以有效的更新。</p></li><li><p>对权值特别大的那些层，可以考虑为那一层设置更大的 weight_decay，是否能有效降低该层权值大小呢。</p></li><li><p>通过对梯度的观察，可以合理的设置梯度 clip 的值。</p></li></ol><h4 id="混淆矩阵及其可视化"><a href="#混淆矩阵及其可视化" class="headerlink" title="混淆矩阵及其可视化"></a>混淆矩阵及其可视化</h4><p>混淆矩阵(Confusion Matrix)常用来观察分类结果，其是一个 N*N 的方阵，N 表示类别数。混淆矩阵的行表示真实类别，列表示预测类别。</p><img src="/2021/09/PyTorch-Part2/image-20210914222323808.png" alt="image-20210914222323808" style="zoom: 67%;"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show_confMat</span>(<span class="params">confusion_mat, classes_name, set_name, out_dir</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    可视化混淆矩阵，保存png格式</span></span><br><span class="line"><span class="string">    :param confusion_mat: nd-array</span></span><br><span class="line"><span class="string">    :param classes_name: list,各类别名称</span></span><br><span class="line"><span class="string">    :param set_name: str, eg: &#x27;valid&#x27;, &#x27;train&#x27;</span></span><br><span class="line"><span class="string">    :param out_dir: str, png输出的文件夹</span></span><br><span class="line"><span class="string">    :return:</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># 归一化</span></span><br><span class="line">    confusion_mat_N = confusion_mat.copy()</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(classes_name)):</span><br><span class="line">        confusion_mat_N[i, :] = confusion_mat[i, :] / confusion_mat[i, :].<span class="built_in">sum</span>()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 获取颜色</span></span><br><span class="line">    cmap = plt.cm.get_cmap(<span class="string">&#x27;Greys&#x27;</span>)  <span class="comment"># 更多颜色: http://matplotlib.org/examples/color/colormaps_reference.html</span></span><br><span class="line">    plt.imshow(confusion_mat_N, cmap=cmap)</span><br><span class="line">    plt.colorbar()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 设置文字</span></span><br><span class="line">    xlocations = np.array(<span class="built_in">range</span>(<span class="built_in">len</span>(classes_name)))</span><br><span class="line">    plt.xticks(xlocations, classes_name, rotation=<span class="number">60</span>)</span><br><span class="line">    plt.yticks(xlocations, classes_name)</span><br><span class="line">    plt.xlabel(<span class="string">&#x27;Predict label&#x27;</span>)</span><br><span class="line">    plt.ylabel(<span class="string">&#x27;True label&#x27;</span>)</span><br><span class="line">    plt.title(<span class="string">&#x27;Confusion_Matrix_&#x27;</span> + set_name)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 打印数字</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(confusion_mat_N.shape[<span class="number">0</span>]):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(confusion_mat_N.shape[<span class="number">1</span>]):</span><br><span class="line">            plt.text(x=j, y=i, s=<span class="built_in">int</span>(confusion_mat[i, j]), va=<span class="string">&#x27;center&#x27;</span>, ha=<span class="string">&#x27;center&#x27;</span>, color=<span class="string">&#x27;red&#x27;</span>, fontsize=<span class="number">10</span>)</span><br><span class="line">    <span class="comment"># 保存</span></span><br><span class="line">    plt.savefig(os.path.join(out_dir, <span class="string">&#x27;Confusion_Matrix_&#x27;</span> + set_name + <span class="string">&#x27;.png&#x27;</span>))</span><br><span class="line">    plt.close()</span><br></pre></td></tr></table></figure><h3 id="wandb-待补充"><a href="#wandb-待补充" class="headerlink" title="wandb(待补充)"></a>wandb(待补充)</h3><blockquote><p>GitHub：<a href="https://github.com/wandb/client">https://github.com/wandb/client</a></p><p>文档：<a href="https://docs.wandb.ai/">https://docs.wandb.ai/</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> PyTorch </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>PyTorch-Part1</title>
      <link href="/2021/09/PyTorch-Part1/"/>
      <url>/2021/09/PyTorch-Part1/</url>
      
        <content type="html"><![CDATA[<h1 id="PyTorch-Part1——基本概念"><a href="#PyTorch-Part1——基本概念" class="headerlink" title="PyTorch-Part1——基本概念"></a>PyTorch-Part1——基本概念</h1><p>[TOC]</p><h2 id="资源汇总（后续放入总结篇）"><a href="#资源汇总（后续放入总结篇）" class="headerlink" title="资源汇总（后续放入总结篇）"></a>资源汇总（后续放入总结篇）</h2><ol><li><a href="https://github.com/zergtant/pytorch-handbook">PyTorch-handbook 中文手册</a>：与 PyTorch 版本保持一致。</li><li><a href="https://github.com/TingsongYu/PyTorch_Tutorial">《Pytorch模型训练实用教程》</a>：PyTorch 模型训练方面的干货教程。特别工业化，真的非常棒。</li><li><a href="https://www.pytorch123.com/">PyTorch官方教程中文版</a>：标准教程，主要是因为有stn。</li><li><a href="https://github.com/chenyuntc/pytorch-book">《深度学习框架PyTorch：入门与实践》</a>：理论和实战，动漫头像生成器。</li><li><a href="https://github.com/bharathgs/Awesome-pytorch-list">Awesome-Pytorch-list</a>：庞大的 PyTorch 资源库。</li><li><a href="https://github.com/pytorch/examples">PyTorch Examples</a>：入门案例，可以在这个基础上增改自己的代码。</li><li><a href="https://discuss.pytorch.org/">PyTorch Forums</a>：PyTorch 官方论坛，可以经常翻阅，减少弯路。</li></ol><ol><li><a href="https://blog.csdn.net/tszupup/article/details/112916388">检查是否可导</a></li><li><a href="https://www.zhihu.com/question/291987781">哪些操作不可微</a></li></ol><p>本篇笔记只记录 PyTorch 常用操作</p><ol><li>按照训练顺序记录各步骤常用方法</li><li>实战干货总结</li><li>不同网络案例代码</li><li>底层剖析与数学原理</li><li>tf1转pytorch</li></ol><h2 id="Pytorch-简介"><a href="#Pytorch-简介" class="headerlink" title="Pytorch 简介"></a>Pytorch 简介</h2><ul><li>Torch 是一个与 Numpy 类似的张量（Tensor）操作库，与 Numpy 不同的是 Torch 对GPU支持的很好，Lua 是 Torch 的上层包装。</li><li>PyTorch 和 Torch 使用包含所有相同性能的C库：TH, THC, THNN, THCUNN，只是使用了不同的上层包装语言。</li><li>PyTorch 框架设计相当简洁优雅且高效快速。</li><li>与 google 的 Tensorflow 类似，FAIR 的支持足以确保 PyTorch 获得持续的开发更新。</li><li>PyTorch 拥有完善的文档，作者亲自维护论坛。</li></ul><h2 id="PyTorch-安装与测试"><a href="#PyTorch-安装与测试" class="headerlink" title="PyTorch 安装与测试"></a>PyTorch 安装与测试</h2><ul><li><p>PyTorch 官网：<a href="https://pytorch.org/">https://pytorch.org/</a></p></li><li><p>CUDA安装：<a href="https://blog.csdn.net/Mind_programmonkey/article/details/99688839/">https://blog.csdn.net/Mind_programmonkey/article/details/99688839/</a></p></li><li><p>测试安装：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line">torch.__version__</span><br><span class="line">torch.cuda.is_available()</span><br></pre></td></tr></table></figure></li><li><p><a href="https://pytorch.org/tutorials/beginner/deep_learning_60min_blitz.html">https://pytorch.org/tutorials/beginner/deep_learning_60min_blitz.html</a>)</p></li></ul><h2 id="张量"><a href="#张量" class="headerlink" title="张量"></a>张量</h2><h3 id="创建张量"><a href="#创建张量" class="headerlink" title="创建张量"></a>创建张量</h3><ul><li>快速测试可以经常使用 <code>torch.rand()</code>。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建未初始化的5行3列的矩阵，注意和 torch.zeros 是不同的</span></span><br><span class="line">x = torch.empty(<span class="number">5</span>, <span class="number">3</span>)</span><br><span class="line"><span class="comment"># 创建一个随机初始化的矩阵</span></span><br><span class="line">x = torch.rand(<span class="number">5</span>, <span class="number">3</span>)</span><br><span class="line"><span class="comment"># 创建一个 0 填充的矩阵，数据类型为 long，long 不允许计算梯度</span></span><br><span class="line">x = torch.zeros(<span class="number">5</span>, <span class="number">3</span>, dtype=torch.long)</span><br><span class="line"><span class="comment"># 创建 tensor 并使用现有数据初始化，只要有一个是 float，则都为 float</span></span><br><span class="line">x = torch.tensor([<span class="number">5.5</span>, <span class="number">3</span>])</span><br><span class="line"><span class="comment"># _like 方法: 根据现有的张量创建相同大小的张量</span></span><br><span class="line">x = torch.randn_like(x, dtype=torch.<span class="built_in">float</span>)</span><br><span class="line">x = torch.ones_like(x).to(torch.<span class="built_in">float</span>)</span><br><span class="line"><span class="comment"># 获取张量大小。size() 和 shape 是等价的。</span></span><br><span class="line">print(x.size())</span><br><span class="line">print(x.shape)</span><br></pre></td></tr></table></figure><ul><li>可以好好体会下面一个例子: <code>batch_size=2 channel=3 size=(h=4, w=5)</code></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span> x = torch.rand((<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>), dtype=torch.<span class="built_in">float</span>, requires_grad=<span class="literal">True</span>)</span><br><span class="line">tensor([[[[<span class="number">0.0628</span>, <span class="number">0.6673</span>, <span class="number">0.3958</span>, <span class="number">0.0904</span>, <span class="number">0.2442</span>],</span><br><span class="line">          [<span class="number">0.4635</span>, <span class="number">0.0213</span>, <span class="number">0.2310</span>, <span class="number">0.1643</span>, <span class="number">0.7705</span>],</span><br><span class="line">          [<span class="number">0.6754</span>, <span class="number">0.9084</span>, <span class="number">0.3516</span>, <span class="number">0.8552</span>, <span class="number">0.5362</span>],</span><br><span class="line">          [<span class="number">0.0650</span>, <span class="number">0.8016</span>, <span class="number">0.1424</span>, <span class="number">0.3343</span>, <span class="number">0.0216</span>]],</span><br><span class="line"></span><br><span class="line">         [[<span class="number">0.2237</span>, <span class="number">0.5758</span>, <span class="number">0.1204</span>, <span class="number">0.8498</span>, <span class="number">0.4453</span>],</span><br><span class="line">          [<span class="number">0.0703</span>, <span class="number">0.1054</span>, <span class="number">0.4191</span>, <span class="number">0.1271</span>, <span class="number">0.9603</span>],</span><br><span class="line">          [<span class="number">0.4301</span>, <span class="number">0.9627</span>, <span class="number">0.9707</span>, <span class="number">0.9125</span>, <span class="number">0.9281</span>],</span><br><span class="line">          [<span class="number">0.4365</span>, <span class="number">0.1514</span>, <span class="number">0.9759</span>, <span class="number">0.4679</span>, <span class="number">0.8695</span>]],</span><br><span class="line"></span><br><span class="line">         [[<span class="number">0.4225</span>, <span class="number">0.5115</span>, <span class="number">0.2755</span>, <span class="number">0.1248</span>, <span class="number">0.8858</span>],</span><br><span class="line">          [<span class="number">0.4288</span>, <span class="number">0.8042</span>, <span class="number">0.2394</span>, <span class="number">0.6829</span>, <span class="number">0.5082</span>],</span><br><span class="line">          [<span class="number">0.7765</span>, <span class="number">0.7435</span>, <span class="number">0.2163</span>, <span class="number">0.9029</span>, <span class="number">0.6852</span>],</span><br><span class="line">          [<span class="number">0.2889</span>, <span class="number">0.3367</span>, <span class="number">0.8794</span>, <span class="number">0.9265</span>, <span class="number">0.6639</span>]]],</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        [[[<span class="number">0.8373</span>, <span class="number">0.0672</span>, <span class="number">0.8151</span>, <span class="number">0.7912</span>, <span class="number">0.2508</span>],</span><br><span class="line">          [<span class="number">0.9232</span>, <span class="number">0.5653</span>, <span class="number">0.1964</span>, <span class="number">0.0986</span>, <span class="number">0.5448</span>],</span><br><span class="line">          [<span class="number">0.8444</span>, <span class="number">0.8974</span>, <span class="number">0.0763</span>, <span class="number">0.9074</span>, <span class="number">0.7959</span>],</span><br><span class="line">          [<span class="number">0.6146</span>, <span class="number">0.1738</span>, <span class="number">0.0814</span>, <span class="number">0.7200</span>, <span class="number">0.0448</span>]],</span><br><span class="line"></span><br><span class="line">         [[<span class="number">0.9523</span>, <span class="number">0.3441</span>, <span class="number">0.1840</span>, <span class="number">0.9286</span>, <span class="number">0.4231</span>],</span><br><span class="line">          [<span class="number">0.9800</span>, <span class="number">0.4126</span>, <span class="number">0.8632</span>, <span class="number">0.8323</span>, <span class="number">0.2245</span>],</span><br><span class="line">          [<span class="number">0.9756</span>, <span class="number">0.5459</span>, <span class="number">0.1382</span>, <span class="number">0.2115</span>, <span class="number">0.0617</span>],</span><br><span class="line">          [<span class="number">0.8045</span>, <span class="number">0.4060</span>, <span class="number">0.6943</span>, <span class="number">0.0992</span>, <span class="number">0.4955</span>]],</span><br><span class="line"></span><br><span class="line">         [[<span class="number">0.0712</span>, <span class="number">0.9649</span>, <span class="number">0.7187</span>, <span class="number">0.5300</span>, <span class="number">0.8720</span>],</span><br><span class="line">          [<span class="number">0.2673</span>, <span class="number">0.9442</span>, <span class="number">0.5604</span>, <span class="number">0.2986</span>, <span class="number">0.2902</span>],</span><br><span class="line">          [<span class="number">0.8061</span>, <span class="number">0.5989</span>, <span class="number">0.4864</span>, <span class="number">0.7042</span>, <span class="number">0.1167</span>],</span><br><span class="line">          [<span class="number">0.6609</span>, <span class="number">0.0652</span>, <span class="number">0.9130</span>, <span class="number">0.8308</span>, <span class="number">0.6552</span>]]]], requires_grad=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure><h3 id="操作张量"><a href="#操作张量" class="headerlink" title="操作张量"></a>操作张量</h3><ul><li>加法</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"></span><br><span class="line">x = torch.ones(<span class="number">5</span>, <span class="number">3</span>)</span><br><span class="line">y = torch.ones(<span class="number">5</span>, <span class="number">3</span>)</span><br><span class="line"><span class="comment"># 1. 直接运算符相加</span></span><br><span class="line">z = x + y</span><br><span class="line"><span class="comment"># 2. .add() 方法</span></span><br><span class="line">z = torch.add(x, y)</span><br><span class="line"><span class="comment"># 3. 替换指定张量</span></span><br><span class="line">z = torch.empty(<span class="number">5</span>, <span class="number">3</span>)</span><br><span class="line">torch.add(x, y, out=z)</span><br><span class="line"><span class="comment"># 4. 将 x 加在y上</span></span><br><span class="line">y.add_(x)</span><br></pre></td></tr></table></figure><blockquote><p>任何 以 <code>_</code> 结尾的操作都会用结果替换原变量。例如：<code>x.copy_(y)</code>、<code>x.t_()</code>，都会改变 <code>x</code>。</p></blockquote><ul><li>使用索引切片操作张量</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">x = torch.ones(<span class="number">5</span>, <span class="number">3</span>)</span><br><span class="line">print(x)</span><br><span class="line">print(x[:, <span class="number">1</span>])</span><br><span class="line">print(x[:, [<span class="number">1</span>]])  <span class="comment"># 依然保持二维</span></span><br></pre></td></tr></table></figure><ul><li><code>torch.view()</code>：改变张量的维度和大小</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">x = torch.rand((<span class="number">4</span>, <span class="number">4</span>), dtype=torch.<span class="built_in">float</span>)</span><br><span class="line">y = x.view(<span class="number">16</span>)</span><br><span class="line">z = x.view(-<span class="number">1</span>, <span class="number">1</span>, <span class="number">8</span>)  <span class="comment"># -1 为自动推断</span></span><br><span class="line">print(x.size(), y.size(), z.size())</span><br></pre></td></tr></table></figure><ul><li><code>.item()</code>：以Python数据类型获取张量中的数值</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">x = torch.randn(<span class="number">1</span>)</span><br><span class="line">print(x)</span><br><span class="line">print(<span class="built_in">type</span>(x.item()))</span><br></pre></td></tr></table></figure><blockquote><p>100+ Tensor operations, including transposing, indexing, slicing, mathematical operations, linear algebra, random numbers, etc., are described here <a href="https://pytorch.org/docs/torch">https://pytorch.org/docs/torch</a>.</p></blockquote><h3 id="NumPy-转换"><a href="#NumPy-转换" class="headerlink" title="NumPy 转换"></a>NumPy 转换</h3><blockquote><p>Torch Tensor与NumPy数组共享底层内存地址，修改任何一个都会导致另一个变化。</p></blockquote><ul><li><code>.numpy()</code>：将一个 Torch Tensor 转换为 NumPy 数组</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">a = torch.ones(<span class="number">5</span>)  <span class="comment"># tensor([1., 1., 1., 1., 1.])</span></span><br><span class="line">b = a.numpy()  <span class="comment"># [1. 1. 1. 1. 1.]</span></span><br><span class="line"><span class="comment"># 共享内存的操作</span></span><br><span class="line">a.add_(<span class="number">1</span>)</span><br><span class="line">print(a)  <span class="comment"># tensor([2., 2., 2., 2., 2.])</span></span><br><span class="line">print(b)  <span class="comment"># [2. 2. 2. 2. 2.]</span></span><br><span class="line"><span class="comment"># 不共享内存的操作</span></span><br><span class="line">a = a + <span class="number">1</span></span><br><span class="line">print(a)  <span class="comment"># tensor([2., 2., 2., 2., 2.])</span></span><br><span class="line">print(b)  <span class="comment"># [1. 1. 1. 1. 1.]</span></span><br></pre></td></tr></table></figure><ul><li><code>torch.from_numpy(a)</code>：NumPy Array 转化成 Torch Tensor</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">a = np.ones(<span class="number">5</span>)</span><br><span class="line">b = torch.from_numpy(a)</span><br><span class="line"><span class="comment"># 共享内存的操作</span></span><br><span class="line">a += <span class="number">1</span></span><br><span class="line">np.add(a, <span class="number">1</span>, out=a)</span><br><span class="line"><span class="comment"># 不共享内存的操作</span></span><br><span class="line">a = a + <span class="number">1</span></span><br><span class="line">a = np.add(a, <span class="number">1</span>)</span><br></pre></td></tr></table></figure><h3 id="CUDA-张量"><a href="#CUDA-张量" class="headerlink" title="CUDA 张量"></a>CUDA 张量</h3><ul><li><code>torch.device(&quot;cuda:0&quot;)</code>：参数可以为 <code>&quot;cuda:0&quot;/&quot;cuda&quot;/&quot;cpu&quot;</code>。</li><li><code>device参数</code>：可传参同上。</li><li><code>.to(device)</code>：可以指定数据类型，也移动到指定设备。<ul><li>同时指定时顺序需要为：<code>.to(device, torch.float)</code></li><li>注意：只调用 <code>.to(&quot;cuda&quot;)</code> 并没有复制张量到 GPU 上，而是返回了一个 copy。所以，需要把它赋值给一个新的张量并在GPU上使用这个张量。</li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">x = torch.randn(<span class="number">3</span>)</span><br><span class="line">device = torch.device(<span class="string">&quot;cuda:0&quot;</span>)        <span class="comment"># 创建 CUDA 设备对象</span></span><br><span class="line">y = torch.ones_like(x, device=device)  <span class="comment"># 直接在 CUDA 中创建张量</span></span><br><span class="line">x = x.to(device)                       <span class="comment"># .to(&quot;cuda&quot;) 将张量移动到 cuda 中</span></span><br><span class="line">z = x + y</span><br><span class="line">print(z)</span><br><span class="line">print(z.to(<span class="string">&quot;cpu&quot;</span>, torch.double))       <span class="comment"># 同时指定设备与类型</span></span><br></pre></td></tr></table></figure><h2 id="自动求导机制-Autograd"><a href="#自动求导机制-Autograd" class="headerlink" title="自动求导机制(Autograd)"></a>自动求导机制(Autograd)</h2><ul><li> <code>torch.autograd</code> 包是 PyTorch 中所有神经网络的核心，它为张量上的所有操作提供了自动求导。</li><li> <code>torch.autograd</code> 是一个在运行时定义的框架，这意味着反向传播是根据你的代码来确定如何运行，并且每次迭代可以是不同的。</li></ul><h3 id="张量（Tensor）"><a href="#张量（Tensor）" class="headerlink" title="张量（Tensor）"></a>张量（Tensor）</h3><ul><li><p><code>torch.Tensor</code> 是这个包的核心类。</p><ul><li>如果设置 <code>.requires_grad=True</code>，那么将会追踪所有对于该张量的操作。当完成计算后通过调用 <code>.backward()</code>，自动计算所有的梯度，这个张量的所有梯度将会积累到 <code>.grad</code> 属性。</li><li>要阻止张量跟踪历史记录，可以调用 <code>.detach()</code> 方法将其与计算历史记录分离，并禁止跟踪它将来的计算记录。</li><li>为了防止跟踪历史记录（和使用内存），可以将代码块包装在<code>with torch.no_grad()：</code>中。在评估模型时特别有用，因为模型可能具有 <code>requires_grad = True</code> 的可训练参数，但是我们不需要梯度计算。</li></ul></li><li><p>在自动梯度计算中还有另外一个重要的类 <code>Function</code>.</p><ul><li><code>Tensor</code> 和 <code>Function</code> 互相连接并生成一个非循环图，它表示和存储了完整的计算历史。每个张量都有一个 <code>.grad_fn</code> 属性，这个属性引用了一个创建了 <code>Tensor</code> 的 <code>Function</code> （除非这个张量是用户手动创建的，即，这个张量的 <code>grad_fn</code> 是 <code>None</code>）。</li><li>如果需要计算导数，你可以在 <code>Tensor</code> 上调用 <code>.backward()</code>。 如果 <code>Tensor</code> 是一个标量（即它包含一个元素数据）则不需要为 <code>backward()</code> 指定任何参数，但是如果它有更多的元素，你需要指定一个<code>gradient</code> 参数来匹配张量的形状。</li></ul></li><li><p>在其他的文章中可能会看到说将 Tensor 包裹到 Variable 中提供自动梯度计算。Variable 在0.41版中已经被标注为过期了，现在可以直接使用 Tensor，官方文档：<a href="https://pytorch.org/docs/stable/autograd.html#variable-deprecated">https://pytorch.org/docs/stable/autograd.html#variable-deprecated</a></p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">x = torch.ones(<span class="number">2</span>, <span class="number">2</span>, requires_grad=<span class="literal">True</span>)</span><br><span class="line">print(x)  <span class="comment"># requires_grad=True</span></span><br><span class="line">y = x + <span class="number">2</span>  <span class="comment"># &lt;AddBackward0 object at 0x0000025D5A03A860&gt;</span></span><br><span class="line">print(y)  <span class="comment"># 进行了一次加运算得出结果 y，因此自动生成了 grad_fn 追踪张量操作，但还没有生成梯度</span></span><br><span class="line"></span><br><span class="line">z = y * y * <span class="number">3</span>  <span class="comment"># grad_fn=&lt;MulBackward0&gt;</span></span><br><span class="line">out = z.mean()  <span class="comment"># grad_fn=&lt;MeanBackward0&gt;</span></span><br></pre></td></tr></table></figure><h3 id="梯度"><a href="#梯度" class="headerlink" title="梯度"></a>梯度</h3><ul><li><img src="/2021/09/PyTorch-Part1/image-20210912171608055.png" alt="image-20210912171608055" style="zoom:150%;"></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 现在让我们来看一个vector-Jacobian product的例子</span></span><br><span class="line">x = torch.randn(<span class="number">3</span>, requires_grad=<span class="literal">True</span>)</span><br><span class="line">y = x * <span class="number">2</span></span><br><span class="line"><span class="keyword">while</span> y.data.norm() &lt; <span class="number">1000</span>:</span><br><span class="line">    y = y * <span class="number">2</span></span><br><span class="line">print(y)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在这个情形中，y不再是个标量。torch.autograd无法直接计算出完整的雅可比行列，但是如果我们只想要vector-Jacobian product，只需将向量作为参数传入backward：</span></span><br><span class="line">gradients = torch.tensor([<span class="number">0.1</span>, <span class="number">1.0</span>, <span class="number">0.0001</span>], dtype=torch.<span class="built_in">float</span>)</span><br><span class="line">y.backward(gradients)</span><br><span class="line">print(x.grad)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果.requires_grad=True但是你又不希望进行autograd的计算， 那么可以将变量包裹在 with torch.no_grad()中:</span></span><br><span class="line">print(x.requires_grad)</span><br><span class="line">print((x ** <span class="number">2</span>).requires_grad)</span><br><span class="line"><span class="keyword">with</span> torch.no_grad():</span><br><span class="line">    print((x ** <span class="number">2</span>).requires_grad)</span><br></pre></td></tr></table></figure><blockquote><p><code>autograd</code> 和 <code>Function</code> 的官方文档 <a href="https://pytorch.org/docs/autograd">https://pytorch.org/docs/autograd</a></p></blockquote><p>model.train():<br>在使用pytorch构建神经网络的时候，训练过程中会在程序上方添加一句model.train()，作用是启用batch normalization和drop out。</p><p>model.eval():<br>测试过程中会使用model.eval()，这时神经网络会沿用batch normalization的值，并不使用drop out。</p>]]></content>
      
      
      <categories>
          
          <category> PyTorch </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Typora-完结目录</title>
      <link href="/2021/09/Typora-%E5%AE%8C%E7%BB%93%E7%9B%AE%E5%BD%95/"/>
      <url>/2021/09/Typora-%E5%AE%8C%E7%BB%93%E7%9B%AE%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<h1 id="Typora——完结目录"><a href="#Typora——完结目录" class="headerlink" title="Typora——完结目录"></a>Typora——完结目录</h1><p>推荐资源：</p><ul><li>Typora 使用手册：<a href="https://support.typora.io/">https://support.typora.io/</a></li></ul><p>写了大半年的Markdown，总结并重新学习。</p><table><thead><tr><th align="center"><strong><a href="/2021/09/Typora-Part1/">Typora-Part1——Markdown、Hexo与Typora</a></strong></th></tr></thead><tbody><tr><td align="center"><strong><a href="/2021/09/Typora-Part2/">Typora-Part2——技术文档写作规范</a></strong></td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> Typora </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MarkDown </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Typora-Part2</title>
      <link href="/2021/09/Typora-Part2/"/>
      <url>/2021/09/Typora-Part2/</url>
      
        <content type="html"><![CDATA[<h1 id="Typora-Part2——技术文档写作规范"><a href="#Typora-Part2——技术文档写作规范" class="headerlink" title="Typora-Part2——技术文档写作规范"></a>Typora-Part2——技术文档写作规范</h1><p>[TOC]</p><blockquote><p>本文来自： <a href="https://github.com/ruanyf">ruanyf</a>/<a href="https://github.com/ruanyf/document-style-guide">document-style-guide</a></p></blockquote><h2 id="1-标题"><a href="#1-标题" class="headerlink" title="1.标题"></a>1.标题</h2><h3 id="1-1层级"><a href="#1-1层级" class="headerlink" title="1.1层级"></a>1.1层级</h3><p>标题分为四级。</p><ul><li>一级标题：文章的标题</li><li>二级标题：文章主要部分的大标题</li><li>三级标题：二级标题下面一级的小标题</li><li>四级标题：三级标题下面某一方面的小标题</li></ul><p>下面是示例。</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 一级标题</span></span><br><span class="line"></span><br><span class="line"><span class="section">## 二级标题</span></span><br><span class="line"></span><br><span class="line"><span class="section">### 三级标题</span></span><br><span class="line"></span><br><span class="line"><span class="section">#### 四级标题</span></span><br></pre></td></tr></table></figure><h3 id="1-2原则"><a href="#1-2原则" class="headerlink" title="1.2原则"></a>1.2原则</h3><p><strong>（1）一级标题下，不能直接出现三级标题。</strong></p><p>示例：下面的文章结构，缺少二级标题。</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 一级标题</span></span><br><span class="line"></span><br><span class="line"><span class="section">### 三级标题</span></span><br></pre></td></tr></table></figure><p><strong>（2）标题要避免孤立编号（即同级标题只有一个）。</strong></p><p>示例：下面的文章结构，<code>二级标题 A</code>只包含一个三级标题，完全可以省略<code>三级标题 A</code>。</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">## 二级标题 A</span></span><br><span class="line"></span><br><span class="line"><span class="section">### 三级标题 A</span></span><br><span class="line"></span><br><span class="line"><span class="section">## 二级标题 B</span></span><br></pre></td></tr></table></figure><p><strong>（3）下级标题不重复上一级标题的名字。</strong></p><p>示例：下面的文章结构，二级标题与下属的三级标题同名，建议避免。</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">## 概述</span></span><br><span class="line"></span><br><span class="line"><span class="section">### 概述</span></span><br></pre></td></tr></table></figure><p><strong>（4）谨慎使用四级标题，尽量避免出现，保持层级的简单，防止出现过于复杂的章节。</strong></p><p>如果三级标题下有并列性的内容，建议只使用项目列表（Item list）。</p><p>示例：下面的结构二要好于结构一。后者适用的场景，主要是较长篇幅的内容。</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">结构一</span><br><span class="line"></span><br><span class="line"><span class="section">### 三级标题</span></span><br><span class="line"></span><br><span class="line"><span class="section">#### 四级标题 A</span></span><br><span class="line"></span><br><span class="line"><span class="section">#### 四级标题 B</span></span><br><span class="line"></span><br><span class="line"><span class="section">#### 四级标题 C</span></span><br><span class="line"></span><br><span class="line">结构二</span><br><span class="line"></span><br><span class="line"><span class="section">### 三级标题</span></span><br><span class="line"></span><br><span class="line"><span class="strong">**（1）A**</span></span><br><span class="line"></span><br><span class="line"><span class="strong">**（2）B**</span></span><br><span class="line"></span><br><span class="line"><span class="strong">**（3）C**</span></span><br></pre></td></tr></table></figure><h2 id="2-文本"><a href="#2-文本" class="headerlink" title="2.文本"></a>2.文本</h2><h3 id="2-1字间距"><a href="#2-1字间距" class="headerlink" title="2.1字间距"></a>2.1字间距</h3><p>全角中文字符与半角英文字符之间，应有一个半角空格。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">错误：本文介绍如何快速启动Windows系统。</span><br><span class="line"></span><br><span class="line">正确：本文介绍如何快速启动 Windows 系统。</span><br></pre></td></tr></table></figure><p>全角中文字符与半角阿拉伯数字之间，有没有半角空格都可，但必须保证风格统一，不能两种风格混杂。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">正确：2011年5月15日，我订购了5台笔记本电脑与10台平板电脑。</span><br><span class="line"></span><br><span class="line">正确：2011 年 5 月 15 日，我订购了 5 台笔记本电脑与 10 台平板电脑。</span><br></pre></td></tr></table></figure><p>半角的百分号，视同阿拉伯数字。</p><p>英文单位若不翻译，单位前的阿拉伯数字与单位间不留空格。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">错误：一部容量为 16 GB 的智能手机</span><br><span class="line"></span><br><span class="line">正确：一部容量为 16GB 的智能手机</span><br></pre></td></tr></table></figure><p>半角英文字符和半角阿拉伯数字，与全角标点符号之间不留空格。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">错误：他的电脑是 MacBook Air 。</span><br><span class="line"></span><br><span class="line">正确：他的电脑是 MacBook Air。</span><br></pre></td></tr></table></figure><h3 id="2-2-句子"><a href="#2-2-句子" class="headerlink" title="2.2 句子"></a>2.2 句子</h3><ul><li>避免使用长句。句子内部不使用逗号时，总长度不应该超过 40 个字；使用逗号时，总长度不应该超过 100 字或者正文的 3 行。</li><li>尽量使用简单句和并列句，避免使用复合句。</li></ul><h3 id="2-3写作风格"><a href="#2-3写作风格" class="headerlink" title="2.3写作风格"></a>2.3写作风格</h3><p><strong>（1）尽量不使用被动语态，改为使用主动语态。</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">错误：假如此软件尚未被安装，</span><br><span class="line"></span><br><span class="line">正确：假如尚未安装这个软件，</span><br></pre></td></tr></table></figure><p><strong>（2）不使用非正式的语言风格。</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">错误：Lady Gaga 的演唱会真是酷毙了，从没看过这么给力的表演！！！</span><br><span class="line"></span><br><span class="line">正确：无法参加本次活动，我深感遗憾。</span><br></pre></td></tr></table></figure><p><strong>（3）不使用冷僻、生造或者文言文的词语，而要使用现代汉语的常用表达方式。</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">错误：这是唯二的快速启动的方法。</span><br><span class="line"></span><br><span class="line">正确：这是仅有的两种快速启动的方法。</span><br></pre></td></tr></table></figure><p><strong>（4）用对“的”、“地”、“得”。</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">她露出了开心的笑容。</span><br><span class="line">（形容词＋的＋名词）</span><br><span class="line"></span><br><span class="line">她开心地笑了。</span><br><span class="line">（副词＋地＋动词）</span><br><span class="line"></span><br><span class="line">她笑得很开心。</span><br><span class="line">（动词＋得＋副词）</span><br></pre></td></tr></table></figure><p><strong>（5）使用代词时（比如“其”、“该”、“此”、“这”等词），必须明确指代的内容，保证只有一个含义。</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">错误：从管理系统可以监视中继系统和受其直接控制的分配系统。</span><br><span class="line"></span><br><span class="line">正确：从管理系统可以监视两个系统：中继系统和受中继系统直接控制的分配系统。</span><br></pre></td></tr></table></figure><p><strong>（6）名词前不要使用过多的形容词。</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">错误：此设备的使用必须在接受过本公司举办的正式的设备培训的技师的指导下进行。</span><br><span class="line"></span><br><span class="line">正确：此设备必须在技师的指导下使用，且指导技师必须接受过由本公司举办的正式设备培训。</span><br></pre></td></tr></table></figure><p><strong>（7）不包含任何标点符号的单个句子，或者以逗号分隔的句子构件，长度尽量保持在 20 个字以内；20～29 个字的句子，可以接受；30～39 个字的句子，语义必须明确，才能接受；多于 40 个字的句子，在任何情况下都不能接受。</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">错误：本产品适用于从由一台服务器进行动作控制的单一节点结构到由多台服务器进行动作控制的并行处理程序结构等多种体系结构。</span><br><span class="line"></span><br><span class="line">正确：本产品适用于多种体系结构。无论是由一台服务器（单一节点结构），还是由多台服务器（并行处理结构）进行动作控制，均可以使用本产品。</span><br></pre></td></tr></table></figure><p><strong>（8）同样一个意思，尽量使用肯定句表达，不使用否定句表达。</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">错误：请确认没有接通装置的电源。</span><br><span class="line"></span><br><span class="line">正确：请确认装置的电源已关闭。</span><br></pre></td></tr></table></figure><p><strong>（9）避免使用双重否定句。</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">错误：没有删除权限的用户，不能删除此文件。</span><br><span class="line"></span><br><span class="line">正确：用户必须拥有删除权限，才能删除此文件。</span><br></pre></td></tr></table></figure><h3 id="2-4英文处理"><a href="#2-4英文处理" class="headerlink" title="2.4英文处理"></a>2.4英文处理</h3><p><strong>（1）英文原文如果使用了复数形式，翻译成中文时，应该将其还原为单数形式。</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">英文：⋯information stored in random access memory (RAMs)⋯</span><br><span class="line"></span><br><span class="line">中文：……存储在随机存取存储器（RAM）里的信息……</span><br></pre></td></tr></table></figure><p><strong>（2）外文缩写可以使用半角圆点(<code>.</code>)表示缩写。</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">U</span><span class="selector-class">.S</span><span class="selector-class">.A</span>.</span><br><span class="line"><span class="selector-tag">Apple</span>, <span class="selector-tag">Inc</span>.</span><br></pre></td></tr></table></figure><p><strong>（3）表示中文时，英文省略号（<code>⋯</code>）应改为中文省略号（<code>……</code>）。</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">英文：5 minutes later⋯</span><br><span class="line"></span><br><span class="line">中文：5 分钟过去了⋯⋯</span><br></pre></td></tr></table></figure><p><strong>（4）英文书名或电影名改用中文表达时，双引号应改为书名号。</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">英文：He published an article entitled <span class="string">&quot;The Future of the Aviation&quot;</span>.</span><br><span class="line"></span><br><span class="line">中文：他发表了一篇名为《航空业的未来》的文章。</span><br></pre></td></tr></table></figure><p><strong>（5）第一次出现英文词汇时，在括号中给出中文标注。此后再次出现时，直接使用英文缩写即可。</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">IOC（International Olympic Committee，国际奥林匹克委员会）。这样定义后，便可以直接使用“IOC”了。</span><br></pre></td></tr></table></figure><p><strong>（6）专有名词中每个词第一个字母均应大写，非专有名词则不需要大写。</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">“American Association of Physicists in Medicine”（美国医学物理学家协会）是专有名词，需要大写。</span><br><span class="line"></span><br><span class="line">“online transaction processing”（在线事务处理）不是专有名词，不应大写。</span><br></pre></td></tr></table></figure><h2 id="3-段落"><a href="#3-段落" class="headerlink" title="3.段落"></a>3.段落</h2><h3 id="3-1原则"><a href="#3-1原则" class="headerlink" title="3.1原则"></a>3.1原则</h3><ul><li>一个段落只能有一个主题，或一个中心句子。</li><li>段落的中心句子放在段首，对全段内容进行概述。后面陈述的句子为核心句服务。</li><li>一个段落的长度不能超过七行，最佳段落长度小于等于四行。</li><li>段落的句子语气要使用陈述和肯定语气，避免使用感叹语气。</li><li>段落之间使用一个空行隔开。</li><li>段落开头不要留出空白字符。</li></ul><h3 id="3-2引用"><a href="#3-2引用" class="headerlink" title="3.2引用"></a>3.2引用</h3><p><strong>（1）引用第三方内容时，应注明出处。</strong></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">One man’s constant <span class="keyword">is</span> another man’s variable. — Alan Perlis</span><br></pre></td></tr></table></figure><p><strong>（2）如果是全篇转载，请在全文开头显著位置注明作者和出处，并链接至原文。</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">本文转载自 WikiQuote</span><br></pre></td></tr></table></figure><p><strong>（3）使用外部图片时，必须在图片下方或文末标明来源。</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">本文部分图片来自 Wikipedia</span><br></pre></td></tr></table></figure><h2 id="4-数值"><a href="#4-数值" class="headerlink" title="4.数值"></a>4.数值</h2><h3 id="4-1半角数字"><a href="#4-1半角数字" class="headerlink" title="4.1半角数字"></a>4.1半角数字</h3><p>数字一律使用半角形式，不得使用全角形式。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">错误： 这件商品的价格是１０００元。</span><br><span class="line"></span><br><span class="line">正确： 这件商品的价格是 1000 元。</span><br></pre></td></tr></table></figure><h3 id="4-2千分号"><a href="#4-2千分号" class="headerlink" title="4.2千分号"></a>4.2千分号</h3><p>数值为千位以上，应添加千分号（半角逗号）。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">XXX 公司的实收资本为 RMB1,258,000。</span><br></pre></td></tr></table></figure><p>对于 4 ～ 6 位的数值，千分号是选用的，比如<code>1000</code>和<code>1,000</code>都可以接受。对于7位及以上的数值，千分号是必须的。</p><p>多位小数要从小数点后从左向右添加千分号，比如<code>4.234,345</code>。</p><h3 id="4-3货币"><a href="#4-3货币" class="headerlink" title="4.3货币"></a>4.3货币</h3><p>货币应为阿拉伯数字，并在数字前写出货币符号，或在数字后写出货币中文名称。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$1</span>,000</span><br><span class="line">1,000 美元</span><br></pre></td></tr></table></figure><h3 id="4-4数值范围"><a href="#4-4数值范围" class="headerlink" title="4.4数值范围"></a>4.4数值范围</h3><p>表示数值范围时，用<code>～</code>连接。参见《标点符号》一节的“连接号”部分。</p><p>带有单位或百分号时，两个数字都要加上单位或百分号，不能只加后面一个。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">错误：132～234kg</span><br><span class="line">正确：132kg～234kg</span><br><span class="line"></span><br><span class="line">错误：67～89%</span><br><span class="line">正确：67%～89%</span><br></pre></td></tr></table></figure><h3 id="4-5变化程度的表示法"><a href="#4-5变化程度的表示法" class="headerlink" title="4.5变化程度的表示法"></a>4.5变化程度的表示法</h3><p>数字的增加要使用“增加了”、“增加到”。“了”表示增量，“到”表示定量。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">增加到过去的两倍</span><br><span class="line">（过去为一，现在为二）</span><br><span class="line"></span><br><span class="line">增加了两倍</span><br><span class="line">（过去为一，现在为三）</span><br></pre></td></tr></table></figure><p>数字的减少要使用“降低了”、“降低到”。“了”表示增量，“到”表示定量。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">降低到百分之八十</span><br><span class="line">（定额是一百，现在是八十）</span><br><span class="line"></span><br><span class="line">降低了百分之八十</span><br><span class="line">（原来是一百，现在是二十）</span><br></pre></td></tr></table></figure><p>不能用“降低N倍”或“减少N倍”的表示法，要用“降低百分之几”或“减少百分之几”。因为减少（或降低）一倍表示数值原来为一百，现在等于零。</p><h2 id="5-标点符号"><a href="#5-标点符号" class="headerlink" title="5.标点符号"></a>5.标点符号</h2><h3 id="5-1原则"><a href="#5-1原则" class="headerlink" title="5.1原则"></a>5.1原则</h3><ul><li>中文语句的标点符号，均应该采取全角符号，这样可以保证视觉的一致。</li><li>如果整句为英文，则该句使用英文/半角标点。</li><li>句号、问号、叹号、逗号、顿号、分号和冒号不得出现在一行之首。</li></ul><h3 id="5-2句号"><a href="#5-2句号" class="headerlink" title="5.2句号"></a>5.2句号</h3><p>中文语句中的结尾处应该用全角句号（<code>。</code>）。</p><p>句子末尾用括号加注时，句号应在括号之外。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">错误：关于文件的输出，请参照第 1.3 节（见第 26 页。）</span><br><span class="line"></span><br><span class="line">正确：关于文件的输出，请参照第 1.3 节（见第 26 页）。</span><br></pre></td></tr></table></figure><h3 id="5-3逗号"><a href="#5-3逗号" class="headerlink" title="5.3逗号"></a>5.3逗号</h3><p>逗号<code>，</code>表示句子内部的一般性停顿。</p><p>注意避免“一逗到底”，即整个段落除了结尾，全部停顿都使用逗号。</p><h3 id="5-4顿号"><a href="#5-4顿号" class="headerlink" title="5.4顿号"></a>5.4顿号</h3><p>句子内部的并列词，应该用全角顿号(<code>、</code>) 分隔，而不用逗号，即使并列词是英语也是如此。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">错误：我最欣赏的科技公司有 Google, Facebook, 腾讯, 阿里和百度等。</span><br><span class="line"></span><br><span class="line">正确：我最欣赏的科技公司有 Google、Facebook、腾讯、阿里和百度等。</span><br></pre></td></tr></table></figure><p>英文句子中，并列词语之间使用半角逗号（<code>,</code>）分隔。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">例句：Microsoft Office includes Word, Excel, PowerPoint, Outlook and other components.</span><br></pre></td></tr></table></figure><h3 id="5-5分号"><a href="#5-5分号" class="headerlink" title="5.5分号"></a>5.5分号</h3><p>分号<code>；</code>表示复句内部并列分句之间的停顿。</p><h3 id="5-6引号"><a href="#5-6引号" class="headerlink" title="5.6引号"></a>5.6引号</h3><p>引用时，应该使用全角双引号（<code>“ ”</code>），注意前后双引号不同。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">例句：许多人都认为客户服务的核心是“友好”和“专业”。</span><br></pre></td></tr></table></figure><p>引号里面还要用引号时，外面一层用双引号，里面一层用单引号（<code>‘ ’</code>），注意前后单引号不同。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">例句：鲍勃解释道：“我要放音乐，可萨利说，‘不行！’。”</span><br></pre></td></tr></table></figure><h3 id="5-7圆括号"><a href="#5-7圆括号" class="headerlink" title="5.7圆括号"></a>5.7圆括号</h3><p>补充说明时，使用全角圆括号<code>（）</code>，括号前后不加空格。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">例句：请确认所有的连接（电缆和接插件）均安装牢固。</span><br></pre></td></tr></table></figure><h3 id="5-8冒号"><a href="#5-8冒号" class="headerlink" title="5.8冒号"></a>5.8冒号</h3><p>全角冒号（<code>：</code>）常用在需要解释的词语后边，引出解释和说明。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">例句：请确认以下几项内容：时间、地点、活动名称，以及来宾数量。</span><br></pre></td></tr></table></figure><p>表示时间时，应使用半角冒号（<code>:</code>）。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">例句：早上 8<span class="selector-pseudo">:00</span></span><br></pre></td></tr></table></figure><h3 id="5-9省略号"><a href="#5-9省略号" class="headerlink" title="5.9省略号"></a>5.9省略号</h3><p>省略号<code>……</code>表示语句未完、或者语气的不连续。它占两个汉字空间、包含六个省略点，不要使用<code>。。。</code>或<code>...</code>等非标准形式。</p><p>省略号不应与“等”这个词一起使用。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">错误：我们为会餐准备了香蕉、苹果、梨…等各色水果。</span><br><span class="line"></span><br><span class="line">正确：我们为会餐准备了各色水果，有香蕉、苹果、梨……</span><br><span class="line"></span><br><span class="line">正确：我们为会餐准备了香蕉、苹果、梨等各色水果。</span><br></pre></td></tr></table></figure><h3 id="5-10感叹号"><a href="#5-10感叹号" class="headerlink" title="5.10感叹号"></a>5.10感叹号</h3><p>应该使用平静的语气叙述，尽量避免使用感叹号<code>！</code>。</p><p>不得多个感叹号连用，比如<code>！！</code>和<code>!!!</code>。</p><h3 id="5-11破折号"><a href="#5-11破折号" class="headerlink" title="5.11破折号"></a>5.11破折号</h3><p>破折号<code>————</code>一般用于进一步解释。</p><p>破折号应占两个汉字的位置。如果破折号本身只占一个汉字的位置，那么前后应该留出一个半角空格。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">例句：直觉————尽管它并不总是可靠的————告诉我，这事可能出了些问题。</span><br><span class="line"></span><br><span class="line">例句：直觉 —— 尽管它并不总是可靠的 —— 告诉我，这事可能出了些问题。</span><br></pre></td></tr></table></figure><h3 id="5-12连接号"><a href="#5-12连接号" class="headerlink" title="5.12连接号"></a>5.12连接号</h3><p>连接号用于连接两个类似的词。</p><p>以下场合应该使用直线连接号（<code>-</code>），占一个半角字符的位置。</p><ul><li>两个名词的复合</li><li>图表编号</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">例句：氧化-还原反应</span><br><span class="line"></span><br><span class="line">例句：图 1-1</span><br></pre></td></tr></table></figure><p>以下场合应该使用波浪连接号（<code>～</code>），占一个全角字符的位置。</p><ul><li>数值范围（例如日期、时间或数字）</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">例句：2009 年～2011 年</span><br></pre></td></tr></table></figure><p>注意，波浪连接号前后两个值都应该加上单位。</p><p>波浪连接号也可以用汉字“至”代替。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">例句：周围温度：-20°C 至 -10°C</span><br></pre></td></tr></table></figure><h2 id="6-文档体系"><a href="#6-文档体系" class="headerlink" title="6.文档体系"></a>6.文档体系</h2><h3 id="6-1结构"><a href="#6-1结构" class="headerlink" title="6.1结构"></a>6.1结构</h3><p>软件手册是一部完整的书，建议采用下面的结构。</p><ul><li><p><strong>简介</strong>（Introduction）： [必备] [文件] 提供对产品和文档本身的总体的、扼要的说明</p></li><li><p><strong>快速上手</strong>（Getting Started）：[可选] [文件] 如何最快速地使用产品</p></li><li><p>入门篇</p><p>（Basics）： [必备] [目录] 又称”使用篇“，提供初级的使用教程</p><ul><li><strong>环境准备</strong>（Prerequisite）：[必备] [文件] 软件使用需要满足的前置条件</li><li><strong>安装</strong>（Installation）：[可选] [文件] 软件的安装方法</li><li><strong>设置</strong>（Configuration）：[必备] [文件] 软件的设置</li></ul></li><li><p><strong>进阶篇</strong>（Advanced)：[可选] [目录] 又称”开发篇“，提供中高级的开发教程</p></li><li><p><strong>API</strong>（Reference）：[可选] [目录|文件] 软件 API 的逐一介绍</p></li><li><p><strong>FAQ</strong>：[可选] [文件] 常见问题解答</p></li><li><p>附录</p><p>（Appendix）：[可选] [目录] 不属于教程本身、但对阅读教程有帮助的内容</p><ul><li><strong>Glossary</strong>：[可选] [文件] 名词解释</li><li><strong>Recipes</strong>：[可选] [文件] 最佳实践</li><li><strong>Troubleshooting</strong>：[可选] [文件] 故障处理</li><li><strong>ChangeLog</strong>：[可选] [文件] 版本说明</li><li><strong>Feedback</strong>：[可选] [文件] 反馈方式</li></ul></li></ul><p>下面是两个真实范例，可参考。</p><ul><li><a href="http://redux.js.org/index.html">Redux 手册</a></li><li><a href="http://flight-manual.atom.io/">Atom 手册</a></li></ul><h3 id="6-2文件名"><a href="#6-2文件名" class="headerlink" title="6.2文件名"></a>6.2文件名</h3><p>文档的文件名不得含有空格。</p><p>文件名必须使用半角字符，不得使用全角字符。这也意味着，中文不能用于文件名。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">错误： 名词解释<span class="selector-class">.md</span></span><br><span class="line"></span><br><span class="line">正确： <span class="selector-tag">glossary</span><span class="selector-class">.md</span></span><br></pre></td></tr></table></figure><p>文件名建议只使用小写字母，不使用大写字母。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">错误：<span class="selector-tag">TroubleShooting</span><span class="selector-class">.md</span></span><br><span class="line"></span><br><span class="line">正确：<span class="selector-tag">troubleshooting</span><span class="selector-class">.md</span> </span><br></pre></td></tr></table></figure><p>为了醒目，某些说明文件的文件名，可以使用大写字母，比如<code>README</code>、<code>LICENSE</code>。</p><p>文件名包含多个单词时，单词之间建议使用半角的连词线（<code>-</code>）分隔。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">不佳：<span class="selector-tag">advanced_usage</span><span class="selector-class">.md</span></span><br><span class="line"></span><br><span class="line">正确：<span class="selector-tag">advanced-usage</span><span class="selector-class">.md</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Typora </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Typora-Part1</title>
      <link href="/2021/09/Typora-Part1/"/>
      <url>/2021/09/Typora-Part1/</url>
      
        <content type="html"><![CDATA[<h1 id="Typora-Part1——Markdown、Hexo与Typora"><a href="#Typora-Part1——Markdown、Hexo与Typora" class="headerlink" title="Typora-Part1——Markdown、Hexo与Typora"></a>Typora-Part1——Markdown、Hexo与Typora</h1><p>[TOC]</p><h2 id="Markdown"><a href="#Markdown" class="headerlink" title="Markdown"></a>Markdown</h2><ul><li>Markdown 是一种轻量级标记语言，通过简单的标记语法，使普通文本内容具有一定的格式。</li><li>Markdown 编写的文档可以导出 HTML 、Word、图像、PDF、Epub 等多种格式的文件。</li><li>Markdown 编写的文档后缀为 .md、.markdown。</li><li>Markdown 具有一系列衍生版本，用于扩展 Markdown 的功能（如表格、脚注、内嵌HTML等）。这些功能原初的Markdown尚不具备，它们能让Markdown转换成更多的格式，例如LaTeX，Docbook。</li><li>Markdown 增强版中比较有名的有 Markdown Extra、MultiMarkdown、Maruku 等。这些衍生版本要么基于工具，如Pandoc；要么基于网站，如 GitHub 和 Wikipedia，在语法上基本兼容，但在一些语法和渲染效果上有改动。</li></ul><h2 id="Hexo"><a href="#Hexo" class="headerlink" title="Hexo"></a>Hexo</h2><ul><li>Hexo 是一款快速、简洁且高效的博客框架。</li><li>Hexo 支持 GitHub Flavored Markdown 的所有功能，可以快速生成模板文档，编辑完成后可以快速部署到 GitHub Pages 等平台。</li><li>Typora 支持在文档头部加上基于 YAML 的 front-matter 信息，这一特性适用于把 Markdown 文档分类归档上传到用 Hexo 框架搭建的博客中。</li><li>Hexo 和 Typora 两者可以高效结合，非常好用。</li></ul><h2 id="Typora"><a href="#Typora" class="headerlink" title="Typora"></a>Typora</h2><blockquote><p>Typora 官网：<a href="https://typora.io/">https://typora.io/</a> </p></blockquote><ul><li>Typora 是一款 Markdown 编辑器，支持 MacOS 、Windows、Linux 平台。<ul><li>包含多种主题，并且可以自己通过css样式定义风格。</li><li>编辑文本的同时直接渲染出效果——所见即所得。</li><li>支持导出HTML、PDF、Word、图片等多种类型文件。</li></ul></li></ul><h2 id="在-Typora-中编辑-Markdown-文本"><a href="#在-Typora-中编辑-Markdown-文本" class="headerlink" title="在 Typora 中编辑 Markdown 文本"></a>在 Typora 中编辑 Markdown 文本</h2><blockquote><p>可以使用反斜杠 <code>\</code> 来防止转义。</p></blockquote><h3 id="基本功能"><a href="#基本功能" class="headerlink" title="基本功能"></a>基本功能</h3><h4 id="标题段落"><a href="#标题段落" class="headerlink" title="标题段落"></a>标题段落</h4><ul><li><p>段落只是一行或多行连续的文本。在markdown源代码中，段落由两个或多个空行分隔。在Typora中，只需要一个空行（按Enter一次）即可创建一个新段落。</p></li><li><p>按Shift+Enter可创建单个换行符。大多数其他 markdown 解析器将忽略单换行符，因此为了使其他降价解析器识别换行符，可以在行的末尾留下两个空格，或者插入<code>&lt;br/&gt;</code>。</p></li></ul><table><thead><tr><th>功能</th><th>快捷键</th><th>Markdown</th><th>HTML</th></tr></thead><tbody><tr><td>段落</td><td>Ctrl+0</td><td></td><td>&lt;p&gt; &lt;/p&gt;</td></tr><tr><td>n级标题</td><td>Ctrl+n</td><td>#*n + space*2</td><td>&lt;h1&gt; &lt;/h1&gt;</td></tr><tr><td>提升标题级别</td><td>Ctrl+‘+’</td><td></td><td></td></tr><tr><td>降低标题级别</td><td>Ctrl+‘-’</td><td></td><td></td></tr></tbody></table><h4 id="字体操作"><a href="#字体操作" class="headerlink" title="字体操作"></a>字体操作</h4><table><thead><tr><th>功能</th><th>快捷键</th><th>Markdown</th><th>HTML</th><th>备注</th></tr></thead><tbody><tr><td>加粗</td><td>Ctrl+B</td><td>**加粗** 或 __加粗__</td><td>&lt;B&gt;加粗&lt;/B&gt;</td><td></td></tr><tr><td>下划线</td><td>Ctrl+U</td><td></td><td>&lt;u&gt;下划线&lt;/u&gt;</td><td></td></tr><tr><td>倾斜</td><td>Ctrl+I</td><td>*倾斜* 或 _倾斜_</td><td>&lt;I&gt;倾斜&lt;/I&gt;</td><td></td></tr><tr><td>删除线</td><td>Alt+Shift+5</td><td>~~删除线~~</td><td></td><td></td></tr><tr><td>清除样式</td><td>Ctrl+\</td><td></td><td></td><td>这个好用，清干净</td></tr><tr><td>下标</td><td></td><td>H~2~O</td><td>&lt;sub&gt;下标&lt;/sub&gt;</td><td>需要在设置中启动</td></tr><tr><td>上标</td><td></td><td>2^10^</td><td>&lt;sup&gt;上标&lt;/sup&gt;</td><td>需要在设置中启动</td></tr><tr><td>高亮</td><td></td><td>==高亮==</td><td></td><td>需要在设置中启动</td></tr></tbody></table><h4 id="插入功能"><a href="#插入功能" class="headerlink" title="插入功能"></a>插入功能</h4><h5 id="插入快捷键"><a href="#插入快捷键" class="headerlink" title="插入快捷键"></a>插入快捷键</h5><table><thead><tr><th>功能</th><th>快捷键</th><th>Markdown</th><th>HTML</th><th>备注</th></tr></thead><tbody><tr><td>插入图片</td><td>Ctrl+Shift+I</td><td>![alt 属性文本](图片地址 “可选标题”)</td><td>&lt;img src=””/&gt;</td><td>建议直接复制粘贴图片。</td></tr><tr><td>插入表格</td><td>Ctrl+T</td><td></td><td></td><td></td></tr><tr><td>插入有序列表</td><td>Ctrl+Shift+[</td><td>num+ . +space</td><td>&lt;ol&gt;&lt;li&gt;*n&lt;/ol&gt;</td><td></td></tr><tr><td>插入无序列表</td><td>Ctrl+Shift+]</td><td>‘-/+/*’+space</td><td>&lt;ul&gt;&lt;li&gt;*n&lt;/ul&gt;</td><td>选定行按TAB以嵌套</td></tr><tr><td>插入超链接</td><td>Ctrl+K</td><td>[链接名称](链接地址) 或 &lt;链接地址&gt;</td><td>&lt;a href=””&gt; &lt;/a&gt;</td><td></td></tr><tr><td>插入代码片</td><td>Ctrl+Shift+`</td><td>``</td><td></td><td>开启匹配Markdown字符</td></tr><tr><td>插入代码块</td><td>Ctrl+Shift+K</td><td>```+lang</td><td></td><td></td></tr><tr><td>插入公式块</td><td>Ctrl+Shift+M</td><td>$$</td><td></td><td></td></tr><tr><td>插入引用块</td><td>Ctrl+Shift+Q</td><td>&gt;+space</td><td></td><td>可以嵌套</td></tr><tr><td>插入目录</td><td></td><td>[TOC]+enter</td><td></td><td></td></tr><tr><td>插入注释</td><td></td><td></td><td>&lt;!– comments –&gt;</td><td>html注释</td></tr><tr><td>插入分割线</td><td></td><td>— 或 ***</td><td></td><td></td></tr><tr><td>任务列表</td><td></td><td>-space[space]space</td><td></td><td>[]里换成x就是打上勾</td></tr></tbody></table><h5 id="插入图片说明"><a href="#插入图片说明" class="headerlink" title="插入图片说明"></a>插入图片说明</h5><ul><li><p>只有html标签可以指定图片属性。</p></li><li><p>建议将图片保存至当前目录的同名文件夹下，这样结构清晰。</p><p><img src="/2021/09/Typora-Part1/image-20210901220801184.png" alt="image-20210901220801184"></p></li></ul><h5 id="链接详解"><a href="#链接详解" class="headerlink" title="链接详解"></a>链接详解</h5><ul><li>Ctrl + 左键，跳转指定url</li></ul><ol><li>内联链接：<ul><li>[浅幽丶奈芙莲](<a href="http://nephrencake.gitee.io/">http://nephrencake.gitee.io/</a>)</li></ul></li><li>引用链接：<ul><li>[浅幽丶奈芙莲][变量名]</li><li>[变量名]: <a href="http://nephrencake.gitee.io/">http://nephrencake.gitee.io/</a></li></ul></li><li>直接使用地址：<ul><li>&lt;<a href="http://nephrencake.gitee.io/&gt;">http://nephrencake.gitee.io/&gt;</a></li></ul></li></ol><ul><li><p>HTML页内跳转：</p><p name="top">这里是页头</p><p><a href="#top">回页头</a></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">name</span>=<span class="string">&quot;top&quot;</span>&gt;</span>这里是页头<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#top&quot;</span>&gt;</span>回页头<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><h5 id="脚注详解"><a href="#脚注详解" class="headerlink" title="脚注详解"></a>脚注详解</h5></li><li><p>脚注语法：</p><ul><li>文本[^说明文字]</li><li>[^说明文字]: 解释说明</li></ul></li><li><p>示例：使用 Markdown<a href="Markdown%E6%98%AF%E4%B8%80%E7%A7%8D%E7%BA%AF%E6%96%87%E6%9C%AC%E6%A0%87%E8%AE%B0%E8%AF%AD%E8%A8%80">^1</a>可以效率的书写文档, 直接转换成 HTML[^2], 你可以使用 Typora[^T] 编辑器进行书写。</p></li></ul><p>[^2]:HyperText Markup Language 超文本标记语言<br>[^T]:NEW WAY TO READ &amp; WRITE MARKDOWN.扩展操作</p><h3 id="扩展操作"><a href="#扩展操作" class="headerlink" title="扩展操作"></a>扩展操作</h3><h4 id="表格扩展"><a href="#表格扩展" class="headerlink" title="表格扩展"></a>表格扩展</h4><h5 id="表格快捷键"><a href="#表格快捷键" class="headerlink" title="表格快捷键"></a>表格快捷键</h5><ul><li>在表格中，可以使用鼠标拖动行或者列，达到交换行和列。</li></ul><table><thead><tr><th>功能</th><th>快捷键</th><th>备注</th></tr></thead><tbody><tr><td>下方插入行</td><td>Ctrl+Enter</td><td></td></tr><tr><td>上移该行</td><td>Alt+↑</td><td></td></tr><tr><td>下移该行</td><td>Alt+↓</td><td></td></tr><tr><td>左移该列</td><td>Win+←</td><td>左右移动表格列的快捷键与WinDows系统自带的快捷键冲突</td></tr><tr><td>右移该列</td><td>Win+→</td><td></td></tr><tr><td>删除该行</td><td>Ctrl+Shift+BackSpace</td><td></td></tr></tbody></table><h5 id="表格详解"><a href="#表格详解" class="headerlink" title="表格详解"></a>表格详解</h5><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"># 1. 表格的Markdown语法</span><br><span class="line">| 表头   | 表头   | 表头   |</span><br><span class="line">| ------ | ------ | ------ |</span><br><span class="line">| 单元格 | 单元格 | 单元格 |</span><br><span class="line">| 单元格 | 单元格 | 单元格 |</span><br><span class="line">    </span><br><span class="line"># 2. 可以设置表格的对齐方式：</span><br><span class="line"># - -: 设置内容和标题栏居右对齐。</span><br><span class="line"># - :- 设置内容和标题栏居左对齐。</span><br><span class="line"># - :-: 设置内容和标题栏居中对齐。</span><br><span class="line">| 左对齐 | 右对齐 | 居中对齐 |</span><br><span class="line">| :----- | -----: | :------: |</span><br><span class="line">| 单元格 | 单元格 |  单元格  |</span><br><span class="line">| 单元格 | 单元格 |  单元格  |</span><br><span class="line">    </span><br><span class="line"># HTML语法</span><br><span class="line"><span class="tag">&lt;<span class="name">table</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">caption</span>&gt;</span>标题内容<span class="tag">&lt;/<span class="name">caption</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span>表格内容<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span>表格内容<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span>表格内容<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span>表格内容<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="视图操作"><a href="#视图操作" class="headerlink" title="视图操作"></a>视图操作</h4><h5 id="侧边栏"><a href="#侧边栏" class="headerlink" title="侧边栏"></a>侧边栏</h5><table><thead><tr><th>功能</th><th>快捷键</th></tr></thead><tbody><tr><td>大纲视图</td><td>Ctrl+Shift+1</td></tr><tr><td>文件列表视图</td><td>Ctrl+Shift+2</td></tr><tr><td>文件树视图</td><td>Ctrl+Shift+3</td></tr><tr><td>显示/隐藏侧边栏</td><td>Ctrl+Shift+L</td></tr><tr><td>放大视图</td><td>Ctrl+Shift+‘+’</td></tr><tr><td>缩小视图</td><td>Ctrl+Shift+‘-’</td></tr><tr><td>恢复原来大小视图</td><td>Ctrl+Shift+9</td></tr></tbody></table><h5 id="编辑模式"><a href="#编辑模式" class="headerlink" title="编辑模式"></a>编辑模式</h5><table><thead><tr><th>功能</th><th>快捷键</th><th>备注</th></tr></thead><tbody><tr><td>源代码模式</td><td>Ctrl+/</td><td></td></tr><tr><td>专注模式</td><td>F8</td><td>当前编辑行为黑，其他行为灰色</td></tr><tr><td>打字机模式</td><td>F9</td><td>光标始终在屏幕中央位置</td></tr></tbody></table><h5 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h5><table><thead><tr><th>功能</th><th>快捷键</th></tr></thead><tbody><tr><td>全屏</td><td>F11</td></tr><tr><td>应用内窗口切换</td><td>Ctrl+Tab</td></tr><tr><td>开发者工具</td><td>Shift+F12</td></tr></tbody></table><h4 id="搜索扩展"><a href="#搜索扩展" class="headerlink" title="搜索扩展"></a>搜索扩展</h4><table><thead><tr><th>功能</th><th>快捷键</th></tr></thead><tbody><tr><td>查找/搜索</td><td>Ctrl+F</td></tr><tr><td>替换</td><td>Ctrl+H</td></tr><tr><td>查找下一个</td><td>F3</td></tr><tr><td>查找上一个</td><td>Shift+F3</td></tr></tbody></table><h3 id="编辑操作"><a href="#编辑操作" class="headerlink" title="编辑操作"></a>编辑操作</h3><h4 id="选择操作"><a href="#选择操作" class="headerlink" title="选择操作"></a>选择操作</h4><table><thead><tr><th>功能</th><th>快捷键</th></tr></thead><tbody><tr><td>全选</td><td>Ctrl+A</td></tr><tr><td>选择当前行/句</td><td>Ctrl+L</td></tr><tr><td>选择相同格式文字</td><td>Ctrl+E</td></tr><tr><td>选择当前单词</td><td>Ctrl+D</td></tr><tr><td>删除当前单词</td><td>Ctrl+Shift+D</td></tr></tbody></table><h4 id="跳转操作"><a href="#跳转操作" class="headerlink" title="跳转操作"></a>跳转操作</h4><table><thead><tr><th>功能</th><th>快捷键</th></tr></thead><tbody><tr><td>跳转到文首</td><td>Ctrl+Home</td></tr><tr><td>跳转到所选内容</td><td>Ctrl+J</td></tr><tr><td>跳转到文末</td><td>Ctrl+End</td></tr></tbody></table><h4 id="粘贴复制操作"><a href="#粘贴复制操作" class="headerlink" title="粘贴复制操作"></a>粘贴复制操作</h4><table><thead><tr><th>功能</th><th>快捷键</th></tr></thead><tbody><tr><td>普通复制</td><td>Ctrl+C</td></tr><tr><td>普通粘贴</td><td>Ctrl+V</td></tr><tr><td>剪切</td><td>Ctrl+X</td></tr><tr><td>复制为MarkDown标记语法</td><td>Ctrl+Shift+C</td></tr><tr><td>粘贴为纯文本</td><td>Ctrl+Shift+V</td></tr></tbody></table><h4 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h4><table><thead><tr><th>功能</th><th>快捷键</th><th>备注</th></tr></thead><tbody><tr><td>新建</td><td>Ctrl+N</td><td></td></tr><tr><td>新建窗口</td><td>Ctrl+Shift+N</td><td>在Windows中，这两个作用一样</td></tr><tr><td>打开文件</td><td>Ctrl+O</td><td></td></tr><tr><td>快速打开</td><td>Ctrl+P</td><td>在最近打开中打开</td></tr><tr><td>保存</td><td>Ctrl+S</td><td></td></tr><tr><td>另存为</td><td>Ctrl+Shift+S</td><td></td></tr><tr><td>偏好设置</td><td>Ctrl+，</td><td>似乎跟搜狗快捷键冲突</td></tr><tr><td>关闭</td><td>Ctrl+W</td><td></td></tr><tr><td>重新打开关闭的文件</td><td>Ctrl+Shift+T</td><td></td></tr><tr><td>文件目录查找</td><td>Ctrl+Shift+F</td><td></td></tr></tbody></table><h3 id="Typora快键键修改"><a href="#Typora快键键修改" class="headerlink" title="Typora快键键修改"></a>Typora快键键修改</h3><ol><li>在Typora菜单栏中，文件–&gt;偏好设置–&gt;打开高级设置</li><li>在打开的文件夹中找到conf.user.json文件</li><li>修改KeyBeing中的键值对，重新设置快捷键</li><li>重启Typora软件即可生效</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;keyBinding&quot;</span>: &#123;</span><br><span class="line">    <span class="comment">// for example:</span></span><br><span class="line">    <span class="comment">// &quot;Always on Top&quot;: &quot;Ctrl+Shift+P&quot;</span></span><br><span class="line">    <span class="string">&quot;Always on Top&quot;</span>: <span class="string">&quot;Ctrl+Shift+P&quot;</span>,</span><br><span class="line">    <span class="string">&quot;Code Fences&quot;</span>: <span class="string">&quot;Ctrl+Shift+F&quot;</span>,</span><br><span class="line">    <span class="string">&quot;Ordered List&quot;</span>: <span class="string">&quot;Ctrl+Alt+o&quot;</span>,</span><br><span class="line">    <span class="string">&quot;Unordered List&quot;</span>: <span class="string">&quot;Ctrl+Alt+u&quot;</span></span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><h3 id="数学公式"><a href="#数学公式" class="headerlink" title="数学公式"></a>数学公式</h3><blockquote><p>LaTeX 语法移步：<a href="https://blog.csdn.net/happyday_d/article/details/83715440">https://blog.csdn.net/happyday_d/article/details/83715440</a></p></blockquote><ul><li>可以通过使用 MathJax 来实现 LaTeX 的数学符号的表达。</li><li>在Markdown语法中，数学的公式块是通过利用 <code>$...$</code> 以及 <code>$$...$$</code> 标记借用 LaTeX 语言来实现的：</li></ul><p>$$<br>\mathbf{V}_1 \times \mathbf{V}_2 =  \begin{vmatrix}<br>\mathbf{i} &amp; \mathbf{j} &amp; \mathbf{k} \<br>\frac{\partial X}{\partial u} &amp;  \frac{\partial Y}{\partial u} &amp; 0 \<br>\frac{\partial X}{\partial v} &amp;  \frac{\partial Y}{\partial v} &amp; 0 \<br>\end{vmatrix}<br>$$</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$$</span><br><span class="line">\mathbf&#123;V&#125;<span class="emphasis">_1 \times \mathbf&#123;V&#125;_</span>2 =  \begin&#123;vmatrix&#125; </span><br><span class="line">\mathbf&#123;i&#125; &amp; \mathbf&#123;j&#125; &amp; \mathbf&#123;k&#125; \\</span><br><span class="line">\frac&#123;\partial X&#125;&#123;\partial u&#125; &amp;  \frac&#123;\partial Y&#125;&#123;\partial u&#125; &amp; 0 \\</span><br><span class="line">\frac&#123;\partial X&#125;&#123;\partial v&#125; &amp;  \frac&#123;\partial Y&#125;&#123;\partial v&#125; &amp; 0 \\</span><br><span class="line">\end&#123;vmatrix&#125;</span><br><span class="line">$$</span><br></pre></td></tr></table></figure><h3 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h3><blockquote><p>炫酷画图方法：<a href="https://support.typora.io/Draw-Diagrams-With-Markdown/">https://support.typora.io/Draw-Diagrams-With-Markdown/</a></p></blockquote><ul><li>我选择直接扔图片。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">st&#x3D;&gt;start: Start</span><br><span class="line">op&#x3D;&gt;operation: Your Operation</span><br><span class="line">cond&#x3D;&gt;condition: Yes or No?</span><br><span class="line">e&#x3D;&gt;end</span><br><span class="line"></span><br><span class="line">st-&gt;op-&gt;cond</span><br><span class="line">cond(yes)-&gt;e</span><br><span class="line">cond(no)-&gt;op</span><br></pre></td></tr></table></figure><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="code">```flow</span></span><br><span class="line"><span class="code">st=&gt;start: Start</span></span><br><span class="line"><span class="code">op=&gt;operation: Your Operation</span></span><br><span class="line"><span class="code">cond=&gt;condition: Yes or No?</span></span><br><span class="line"><span class="code">e=&gt;end</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="code">st-&gt;op-&gt;cond</span></span><br><span class="line"><span class="code">cond(yes)-&gt;e</span></span><br><span class="line"><span class="code">cond(no)-&gt;op</span></span><br><span class="line"><span class="code">```</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Typora </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>OpenCV-Part5</title>
      <link href="/2021/09/OpenCV-Part5/"/>
      <url>/2021/09/OpenCV-Part5/</url>
      
        <content type="html"><![CDATA[<h1 id="OpenCV-Part5——综合运用"><a href="#OpenCV-Part5——综合运用" class="headerlink" title="OpenCV-Part5——综合运用"></a>OpenCV-Part5——综合运用</h1><p>[TOC]</p><p>注：本篇仅为记录本人使用过的比较高阶的OpenCV算法流程。</p><h2 id="K-Means聚类"><a href="#K-Means聚类" class="headerlink" title="K-Means聚类"></a>K-Means聚类</h2><ul><li>从分布的角度重新构造图像色彩度，减少图像中颜色数量。</li><li><code>cv2.kmeans(data, K, bestLabels, criteria, attempts, flags)</code>：<ul><li>data：np.float32数据类型，每个功能应该放在一个列中</li><li>K：集群数(nclusters)</li><li>bestLabels：预设的分类标签，没有则设为None</li><li>criteria：迭代终止标准。满足此条件时，算法迭代停止。它由3个参数的元组组成：<code>（type，max_iter，epsilon）</code>。<ul><li>type：<ul><li><code>cv2.TERM_CRITERIA_EPS</code>：如果达到指定的精度epsilon，则停止算法迭代。</li><li><code>cv2.TERM_CRITERIA_MAX_ITER</code>：在指定的迭代次数max_iter之后停止算法。</li><li><code>cv2.TERM_CRITERIA_EPS + cv2.TERM_CRITERIA_MAX_ITER</code>：当满足上述任何条件时停止迭代。</li></ul></li><li>max_iter：指定最大迭代次数的整数</li><li>epsilon：要求的准确性</li></ul></li><li>attempts：重复试验kmeans算法次数，将会返回最好的一次结果。</li><li>flags：该标志用于指定初始中心的采用方式。通常会使用两个标志：<code>cv2.KMEANS_PP_CENTERS</code>和<code>cv2.KMEANS_RANDOM_CENTERS</code>。</li><li>返回三个数据：<ul><li>retval：从每个点到它们相应中心的平方距离之和。</li><li>bestLabels：标签数组。是不固定的。</li><li>centers：一组聚类中心。即标签对应的值。</li></ul></li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"></span><br><span class="line">img = cv2.imread(<span class="string">&#x27;test.jpg&#x27;</span>)</span><br><span class="line">Z = img.reshape((-<span class="number">1</span>, <span class="number">3</span>))  <span class="comment"># 把所有像素拉成一条直线</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 1. convert to np.float32</span></span><br><span class="line">Z = np.float32(Z)  <span class="comment"># uint8 -&gt; float32</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. define criteria, number of clusters(K) and apply kmeans()</span></span><br><span class="line">criteria = (cv2.TERM_CRITERIA_EPS + cv2.TERM_CRITERIA_MAX_ITER, <span class="number">10</span>, <span class="number">1.0</span>)</span><br><span class="line">K = <span class="number">3</span></span><br><span class="line">ret, label, center = cv2.kmeans(Z, K, <span class="literal">None</span>, criteria, <span class="number">10</span>, cv2.KMEANS_RANDOM_CENTERS)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. Now convert back into uint8, and make original image</span></span><br><span class="line">center = np.uint8(center)  <span class="comment"># float32 -&gt; uint8</span></span><br><span class="line">res = center[label.flatten()]  <span class="comment"># 将标签数组赋予真正的bgr值</span></span><br><span class="line">res2 = res.reshape(img.shape)  <span class="comment"># 重构图像</span></span><br><span class="line"></span><br><span class="line">cv2.imshow(<span class="string">&#x27;res2&#x27;</span>, res2)</span><br><span class="line">cv2.waitKey(<span class="number">0</span>)</span><br><span class="line">cv2.destroyAllWindows()</span><br></pre></td></tr></table></figure><h2 id="极坐标与直角坐标变换"><a href="#极坐标与直角坐标变换" class="headerlink" title="极坐标与直角坐标变换"></a>极坐标与直角坐标变换</h2><h3 id="极坐标转直角坐标"><a href="#极坐标转直角坐标" class="headerlink" title="极坐标转直角坐标"></a>极坐标转直角坐标</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> math</span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"></span><br><span class="line">cir_img = cv2.imread(<span class="string">&#x27;4-1.jpg&#x27;</span>)</span><br><span class="line">cv2.imshow(<span class="string">&#x27;panoramagram&#x27;</span>, cir_img)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 得到圆形区域的中心坐标</span></span><br><span class="line">x0, y0 = cir_img.shape[<span class="number">0</span>] // <span class="number">2</span>, cir_img.shape[<span class="number">1</span>] // <span class="number">2</span></span><br><span class="line"><span class="comment"># 通过圆形区域半径构造展开后的图像</span></span><br><span class="line">radius = cir_img.shape[<span class="number">0</span>] // <span class="number">2</span></span><br><span class="line">rect_height = radius</span><br><span class="line">rect_width = <span class="built_in">int</span>(<span class="number">2</span> * math.pi * radius)</span><br><span class="line">rect_img = np.zeros((rect_height, rect_width, <span class="number">3</span>), dtype=<span class="string">&quot;u1&quot;</span>)</span><br><span class="line"></span><br><span class="line">start = <span class="number">0</span>  <span class="comment"># 从正下方开始切，start设定偏移角度，单位为度</span></span><br><span class="line">except_count = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(rect_width):</span><br><span class="line">    theta = <span class="number">2</span> * math.pi * (j / rect_width) + <span class="number">2</span> * math.pi * (start / <span class="number">360</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(rect_height):</span><br><span class="line">        <span class="comment"># 适应椭圆的极坐标展开</span></span><br><span class="line">        x = (x0 - i) * math.cos(theta) + x0  <span class="comment"># &quot;sin&quot; is clockwise but &quot;cos&quot; is anticlockwise</span></span><br><span class="line">        y = (y0 - i) * math.sin(theta) + y0</span><br><span class="line">        x, y = <span class="built_in">int</span>(x), <span class="built_in">int</span>(y)</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            rect_img[i, j, :] = cir_img[x, y, :]</span><br><span class="line">        <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">            except_count = except_count + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">print(except_count)</span><br><span class="line">cv2.imwrite(<span class="string">&quot;rect_img.jpg&quot;</span>, rect_img)</span><br><span class="line">cv2.imshow(<span class="string">&quot;rect_img&quot;</span>, rect_img)</span><br><span class="line">cv2.waitKey(<span class="number">0</span>)</span><br></pre></td></tr></table></figure><h3 id="直角坐标转极坐标"><a href="#直角坐标转极坐标" class="headerlink" title="直角坐标转极坐标"></a>直角坐标转极坐标</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> math</span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"></span><br><span class="line">img_name = <span class="string">&#x27;8.jpeg&#x27;</span></span><br><span class="line">img = cv2.imread(img_name)</span><br><span class="line">cv2.imshow(<span class="string">&#x27;panoramagram&#x27;</span>, img)</span><br><span class="line">img = wrapped_img = cv2.resize(img, <span class="literal">None</span>, fx=<span class="number">2</span>, fy=<span class="number">2</span>, interpolation=cv2.INTER_CUBIC)</span><br><span class="line"><span class="comment"># 准备工作，计算原图像尺寸和变换后的图片大小</span></span><br><span class="line">x0 = img.shape[<span class="number">0</span>]</span><br><span class="line">y0 = img.shape[<span class="number">1</span>]</span><br><span class="line">print(x0, y0)</span><br><span class="line"><span class="comment"># 最大半径计算</span></span><br><span class="line">radius = <span class="built_in">int</span>(y0 / (<span class="number">2</span> * math.pi))</span><br><span class="line">w = <span class="number">2</span> * radius</span><br><span class="line">h = <span class="number">2</span> * radius</span><br><span class="line">wrapped_img = <span class="number">255</span> * np.ones((w, h, <span class="number">3</span>), dtype=<span class="string">&quot;u1&quot;</span>)</span><br><span class="line"></span><br><span class="line">except_count = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(y0):</span><br><span class="line">    <span class="comment"># 1. 求极坐标系中对应的角度theta</span></span><br><span class="line">    theta = <span class="number">2</span> * math.pi * (j / y0)</span><br><span class="line">    <span class="comment"># print(theta)</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(x0):</span><br><span class="line">        <span class="comment"># 2. 计算半径缩放系数</span></span><br><span class="line">        wrapped_radius = (i - x0) * radius / x0</span><br><span class="line">        <span class="comment"># 3. 利用对应关系进行换算</span></span><br><span class="line">        y = wrapped_radius * math.cos(theta) + radius</span><br><span class="line">        x = wrapped_radius * math.sin(theta) + radius</span><br><span class="line">        x, y = <span class="built_in">int</span>(x), <span class="built_in">int</span>(y)</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            wrapped_img[x, y, :] = img[i, j, :]</span><br><span class="line">            <span class="comment"># 注意点,在数学坐标系中的坐标与数字图像中的坐标表示存在差异需要注意</span></span><br><span class="line">        <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">            except_count = except_count + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">print(except_count)</span><br><span class="line"><span class="comment"># 提取ROI区域进行平滑处理，效果一般</span></span><br><span class="line">roi = wrapped_img[<span class="number">0</span>:radius, radius - <span class="number">5</span>:radius + <span class="number">5</span>, :]</span><br><span class="line">roi_blur = cv2.blur(roi, (<span class="number">3</span>, <span class="number">3</span>))</span><br><span class="line">wrapped_img[<span class="number">0</span>:radius, radius - <span class="number">5</span>:radius + <span class="number">5</span>, :] = roi_blur</span><br><span class="line"><span class="comment"># wrapped_img = cv2.resize(wrapped_img,None,fx=1,fy=1,interpolation=cv2.INTER_CUBIC)</span></span><br><span class="line">name = <span class="string">&#x27;p_&#x27;</span> + img_name</span><br><span class="line">cv2.imwrite(name, wrapped_img)</span><br><span class="line">cv2.imshow(<span class="string">&quot;Unwrapped&quot;</span>, wrapped_img)</span><br><span class="line">cv2.waitKey(<span class="number">0</span>)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> OpenCV </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>OpenCV-完结目录</title>
      <link href="/2021/08/OpenCV-%E5%AE%8C%E7%BB%93%E7%9B%AE%E5%BD%95/"/>
      <url>/2021/08/OpenCV-%E5%AE%8C%E7%BB%93%E7%9B%AE%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<h1 id="OpenCV——完结目录"><a href="#OpenCV——完结目录" class="headerlink" title="OpenCV——完结目录"></a>OpenCV——完结目录</h1><p>推荐资源：</p><ol><li><a href="http://www.woshicver.com/">OpenCV中文官方文档</a></li></ol><p>在实习时用到，随后做一次总结与再学习，记录遇到的注意点与个人理解。</p><p>该笔记还未记录直方图到机器学习的部分，主要是 python-opencv 框架的使用。</p><table><thead><tr><th align="center"><a href="/2021/08/OpenCV-Part1/">OpenCV-Part1——基础操作</a></th></tr></thead><tbody><tr><td align="center"><strong><a href="/2021/08/OpenCV-Part2/">OpenCV-Part2——图像处理（上）</a></strong></td></tr><tr><td align="center"><strong><a href="/2021/08/OpenCV-Part3/">OpenCV-Part3——图像处理（中）</a></strong></td></tr><tr><td align="center"><strong><a href="/2021/08/OpenCV-Part4/">OpenCV-Part4——图像处理（下）</a></strong></td></tr><tr><td align="center"><strong><a href="/2021/09/OpenCV-Part5/">OpenCV-Part5——综合运用</a></strong></td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> OpenCV </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OpenCV-Part4</title>
      <link href="/2021/08/OpenCV-Part4/"/>
      <url>/2021/08/OpenCV-Part4/</url>
      
        <content type="html"><![CDATA[<h1 id="OpenCV-Part4——图像处理（下）"><a href="#OpenCV-Part4——图像处理（下）" class="headerlink" title="OpenCV-Part4——图像处理（下）"></a>OpenCV-Part4——图像处理（下）</h1><p>[TOC]</p><h2 id="直方图"><a href="#直方图" class="headerlink" title="直方图"></a>直方图</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><ul><li><p>直方图，是在X轴上具有像素值（不总是从0到255的范围），在Y轴上具有图像中相应像素数的图。</p></li><li><p>直方图，可以用来总体了解图像的强度分布。</p></li><li><p>直方图只是理解图像的另一种方式。通过查看图像的直方图，可以直观地了解该图像的对比度，亮度，强度分布等。</p></li><li><p><img src="/2021/08/OpenCV-Part4/histogram_sample.jpg" alt="img"></p><p>如图，此直方图是针对灰度图像而非彩色图像绘制的。其左侧区域显示图像中较暗像素的数量，而右侧区域则显示明亮像素的数量。</p><p>从该直方图中，可以看到暗区域多于亮区域，而中间灰度值的数量就非常少。</p></li><li><p>有关直方图的术语：</p><ul><li>BINS：像素值的区间段数。将整个直方图在 x 轴上分成 n 个子部分，每个子部分的值就是其中所有像素数的总和，每个子部分都称为一个 BIN 。当 x 轴采用 255 个值来展示直方图时，BINS=255。可用于对具体像素精度不在乎，而意图找固定区间段划分的像素总量的情况。在 OpenCV 中也称作 histSize 。</li><li>DIMS：收集数据的参数量。当仅收集关于强度值的一件事的数据时，这里是1。</li><li>RANGE：测量的强度值范围。通常为[0, 256]，即所有强度值。</li></ul></li></ul><h3 id="查找并绘制直方图"><a href="#查找并绘制直方图" class="headerlink" title="查找并绘制直方图"></a>查找并绘制直方图</h3><h4 id="OpenCV计算直方图"><a href="#OpenCV计算直方图" class="headerlink" title="OpenCV计算直方图"></a>OpenCV计算直方图</h4><ul><li><code>cv2.calcHist(images，channels，mask，histSize，ranges，hist，accumulate)</code>：查找直方图。<ul><li><code>images</code>：<code>uint8</code>或<code>float32</code>类型的源图像。需要由列表[img]包裹。</li><li><code>channels</code>：计算直方图的通道索引。对于灰度图像，则其值为[0]。对于彩色图像，可以传递[0]、[1]或[2]分别计算蓝色，绿色或红色通道的直方图。需要由列表[channels]包裹。</li><li><code>mask</code>：图像掩码。None：查找完整图像的直方图。否则为查找特定区域mask掩码的直方图。</li><li><code>histSize</code>：像素值的区间段数。需要放在方括号中。对于全尺寸，我们通过[256]。需要由列表[histSize]包裹。</li><li><code>ranges</code>：测量的强度值范围。通常为<code>[0, 256]</code>。</li></ul></li><li>Numpy 也有计算直方图的函数，但是 <code>cv2.calcHist()</code> 比 <code>np.histogram()</code> 快大约40倍。因此，尽可能使用OpenCV函数。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">img = cv2.imread(<span class="string">&#x27;home.jpg&#x27;</span>, <span class="number">0</span>)</span><br><span class="line">hist = cv2.calcHist([img], channels=[<span class="number">0</span>], mask=<span class="literal">None</span>, histSize=[<span class="number">256</span>], ranges=[<span class="number">0</span>, <span class="number">256</span>])</span><br></pre></td></tr></table></figure><h4 id="Matplotlib绘制直方图"><a href="#Matplotlib绘制直方图" class="headerlink" title="Matplotlib绘制直方图"></a>Matplotlib绘制直方图</h4><ol><li><p><code>matplotlib.pyplot.hist()</code> ：Matplotlib自带直方图绘图功能，能够直接找到直方图并将其绘制。而无需使用 <code>cv2.calcHist() </code>查找直方图。</p><ul><li><pre><code class="python">import numpy as npimport cv2from matplotlib import pyplot as pltimage = cv2.imread(&#39;home.jpg&#39;)# numpy的ravel函数功能是将多维数组降为一维数组plt.hist(image.ravel(), bins=256, range=[0, 256], histtype=&quot;step&quot;, color=&#39;black&#39;)  # 对整图的，需要注意和灰度是有区别的！plt.hist(image[:, :, 0].ravel(), bins=256, range=[0, 256], histtype=&quot;step&quot;, color=&#39;blue&#39;)plt.hist(image[:, :, 1].ravel(), bins=256, range=[0, 256], histtype=&quot;step&quot;, color=&#39;green&#39;)plt.hist(image[:, :, 2].ravel(), bins=256, range=[0, 256], histtype=&quot;step&quot;, color=&#39;red&#39;)plt.show()<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">   </span><br><span class="line">2. &#96;cv2.calcHist()&#96;+&#96;plt.plot()&#96;：先找到直方图数据，再使用matplotlib的法线图。分离了数据和画图，更符合程序解耦设计。</span><br><span class="line"></span><br><span class="line">   - &#96;&#96;&#96;python</span><br><span class="line">     import numpy as np</span><br><span class="line">     import cv2</span><br><span class="line">     from matplotlib import pyplot as plt</span><br><span class="line">     </span><br><span class="line">     image &#x3D; cv2.imread(&#39;home.jpg&#39;)</span><br><span class="line">     color &#x3D; [&quot;blue&quot;, &quot;green&quot;, &quot;red&quot;]</span><br><span class="line">     ranges &#x3D; [0, 256]</span><br><span class="line">     # 同时列出数据下标和数据</span><br><span class="line">     for i, color in enumerate(color):</span><br><span class="line">         hist &#x3D; cv2.calcHist([image], channels&#x3D;[i], mask&#x3D;None, histSize&#x3D;[256], ranges&#x3D;ranges)</span><br><span class="line">         print(type(hist), hist.shape)  # &lt;class &#39;numpy.ndarray&#39;&gt;  (256, 1)</span><br><span class="line">         plt.plot(hist, color&#x3D;color)</span><br><span class="line">         plt.xlim(ranges)</span><br><span class="line">     plt.show()</span><br></pre></td></tr></table></figure>![img](OpenCV-Part4/histogram_rgb_plot.jpg)</code></pre></li></ul></li></ol><h3 id="直方图均衡化"><a href="#直方图均衡化" class="headerlink" title="直方图均衡化"></a>直方图均衡化</h3><h4 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h4><ul><li>直方图均衡化，可以使限制在某一区间的色彩亮度均衡到整个色彩区间上，使像素在直方图上的分布更均匀。</li><li>直方图均衡化，是用来改善图像的全局亮度和对比度的。例如，在对人脸数据进行训练之前，对人脸图像进行直方图均衡化处理，使其具有相同的光照条件。</li><li><img src="/2021/08/OpenCV-Part4/histogram_equalization.png" alt="img"></li></ul><h4 id="全局均衡化"><a href="#全局均衡化" class="headerlink" title="全局均衡化"></a>全局均衡化</h4><ul><li><code>cv2.equalizeHist()</code>：只能输入灰度图像，输出直方图均衡化后的图像。 </li><li><code>np.hstack((img1, img2))</code>：横向拼接。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">equ = cv2.equalizeHist(img)</span><br><span class="line">cv2.imshow(<span class="string">&#x27;equalization&#x27;</span>, np.hstack((img, equ)))  <span class="comment"># 并排显示</span></span><br><span class="line">cv2.waitKey(<span class="number">0</span>)</span><br></pre></td></tr></table></figure><p><img src="/2021/08/OpenCV-Part4/equalization_opencv.jpg" alt="img"></p><h4 id="自适应直方图均衡化-CLAHE"><a href="#自适应直方图均衡化-CLAHE" class="headerlink" title="自适应直方图均衡化(CLAHE)"></a>自适应直方图均衡化(CLAHE)</h4><ul><li>当一张图同时拥有较多暗部和亮部时，全局均衡化极其容易丢失信息。</li><li>自适应直方图均衡，可以将图像分成称为 tiles 的小块（在 OpenCV 中，tileSize 默认为 8x8 ）。并在每个较小的区域中，进行直方图均衡。</li><li>如果在 tiles 中有噪音，则应用了对比度限制：任何直方图 bin 超出指定的对比度限制（在OpenCV中默认为40），则在应用直方图均衡之前，将这些像素裁剪并均匀地分布到其他bin。</li><li><code>cv2.createCLAHE(clipLimit, tileGridSize)</code>：CLAHE 自适应直方图均衡化。<ul><li><code>clipLimit</code>：颜色对比度的阈值。</li><li><code>titleGridSize</code>：进行像素均衡化的网格大小。</li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cl1 = cv2.createCLAHE(clipLimit=<span class="number">2.0</span>, tileGridSize=(<span class="number">8</span>, <span class="number">8</span>)).apply(img)</span><br><span class="line">cv2.imshow(<span class="string">&#x27;equalization&#x27;</span>, np.hstack((img, cl1)))  <span class="comment"># 并排显示</span></span><br><span class="line">cv2.waitKey(<span class="number">0</span>)</span><br></pre></td></tr></table></figure><img src="/2021/08/OpenCV-Part4/image-20210902221852779.png" alt="image-20210902221852779" style="zoom:67%;"><h3 id="二维直方图"><a href="#二维直方图" class="headerlink" title="二维直方图"></a>二维直方图</h3><h4 id="定义-2"><a href="#定义-2" class="headerlink" title="定义"></a>定义</h4><ul><li>上述都是在计算一维直方图，因为仅考虑一个特征，即像素的灰度强度值。</li><li>但是在二维直方图中，需要考虑两个特征：每个像素的 <code>色相(Hue)</code> 和 <code>饱和度(Saturation)</code> 值。</li><li>二维直方图，通常用于查找颜色直方图。</li></ul><h4 id="查找并绘制直方图-1"><a href="#查找并绘制直方图-1" class="headerlink" title="查找并绘制直方图"></a>查找并绘制直方图</h4><h5 id="OpenCV计算二维直方图"><a href="#OpenCV计算二维直方图" class="headerlink" title="OpenCV计算二维直方图"></a>OpenCV计算二维直方图</h5><ul><li><p>对于颜色直方图，我们需要将图像从BGR转换为HSV。对于一维直方图，我们从BGR转换为灰度</p></li><li><p><code>cv2.calcHist()</code>：对于二维直方图，使用相同的函数，但其参数将进行如下修改：</p><ul><li><code>channels=[0, 1]</code>：因为需要同时处理H和S平面。</li><li><code>histSize=[180, 256]</code>：对于H平面为180，对于S平面为256。</li><li><code>ranges=[0, 180, 0, 256]</code>：色相值介于0和180之间，饱和度介于0和256之间。</li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"></span><br><span class="line">img = cv2.imread(<span class="string">&#x27;home.jpg&#x27;</span>)</span><br><span class="line">hsv = cv2.cvtColor(img, cv2.COLOR_BGR2HSV)</span><br><span class="line">hist = cv2.calcHist([hsv], channels=[<span class="number">0</span>, <span class="number">1</span>], mask=<span class="literal">None</span>, histSize=[<span class="number">180</span>, <span class="number">256</span>], ranges=[<span class="number">0</span>, <span class="number">180</span>, <span class="number">0</span>, <span class="number">256</span>])</span><br></pre></td></tr></table></figure><h5 id="Matplotlib绘制二维直方图"><a href="#Matplotlib绘制二维直方图" class="headerlink" title="Matplotlib绘制二维直方图"></a>Matplotlib绘制二维直方图</h5><ul><li>matplotlib.pyplot.imshow()：绘制2D直方图。</li><li>使用此功能时，插值法应采用最近邻以获得更好的结果。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">from</span> matplotlib <span class="keyword">import</span> pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">img = cv2.imread(<span class="string">&quot;test.jpg&quot;</span>)</span><br><span class="line">hsv = cv2.cvtColor(img, cv2.COLOR_BGR2HSV)</span><br><span class="line">hist = cv2.calcHist([hsv], channels=[<span class="number">0</span>, <span class="number">1</span>], mask=<span class="literal">None</span>, histSize=[<span class="number">180</span>, <span class="number">256</span>], ranges=[<span class="number">0</span>, <span class="number">180</span>, <span class="number">0</span>, <span class="number">256</span>])</span><br><span class="line">plt.imshow(hist, interpolation=<span class="string">&#x27;nearest&#x27;</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><ul><li><p>下面是输入图像及其颜色直方图。X轴显示S值，Y轴显示色相。</p><img src="http://qiniu.aihubs.net/2dhist_matplotlib.jpg" alt="img" style="zoom:200%;"></li><li><p>在该直方图中，可以在H = 100 和 S = 200 附近看到一些较高的值，对应于天空的蓝色。同样，在 H = 25 和 S = 100 附近可以看到另一个峰值，对应于宫殿的黄色。</p></li></ul><h3 id="YUV色彩空间对彩色图像做直方图均衡化"><a href="#YUV色彩空间对彩色图像做直方图均衡化" class="headerlink" title="YUV色彩空间对彩色图像做直方图均衡化"></a>YUV色彩空间对彩色图像做直方图均衡化</h3><ul><li><p>YUV色彩空间是把亮度（Luma）与色度（Chroma）分离。</p><ul><li>“Y”表示亮度，也就是灰度值。</li><li>“U”表示蓝色通道与亮度的差值。</li><li>“V”表示红色通道与亮度的差值。</li></ul></li><li><p>对彩色图像进行直方图均衡化时，先将图像从RGB空间转到YUV空间，然后对亮度Y通道进行直方图均衡化得到通道Y”，然后将Y”UV通道进行合并。</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">img = cv2.imread(<span class="string">&#x27;input.jpg&#x27;</span>)</span><br><span class="line"></span><br><span class="line">img_yuv = cv2.cvtColor(img, cv2.COLOR_BGR2YUV)</span><br><span class="line"><span class="comment"># equalize the histogram of the Y channel</span></span><br><span class="line">img_yuv[:, :, <span class="number">0</span>] = cv2.createCLAHE(clipLimit=<span class="number">2.0</span>, tileGridSize=(<span class="number">8</span>, <span class="number">8</span>)).apply(img_yuv[:, :, <span class="number">0</span>])</span><br><span class="line"><span class="comment"># convert the YUV image back to RGB format</span></span><br><span class="line">img_output = cv2.cvtColor(img_yuv, cv2.COLOR_YUV2BGR)</span><br><span class="line"></span><br><span class="line">cv2.imshow(<span class="string">&#x27;Color input image&#x27;</span>, img)</span><br><span class="line">cv2.imshow(<span class="string">&#x27;Histogram equalized&#x27;</span>, img_output)</span><br><span class="line">cv2.waitKey(<span class="number">0</span>)</span><br></pre></td></tr></table></figure><h3 id="直方图比较"><a href="#直方图比较" class="headerlink" title="直方图比较"></a>直方图比较</h3><ul><li>对输入的两张图像进行直方图均衡化后，可以对两个图像的直方图进行对比，从对比的结果得到一些的结论。</li><li><code>cv2.compareHist(H1, H2, method)</code>：对比两个图像的直方图。<code>method</code>有三中可用：<ul><li><code>cv2.HISTCMP_BHATTACHARYYA</code>：巴氏距离，越小越相似。</li><li><code>cv2.HISTCMP_CORREL</code>：相关性，越大越相似。</li><li><code>cv2.HISTCMP_CHISQR</code>：卡方，越大越不相似。</li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">create_rgb_hist</span>(<span class="params">image</span>):</span></span><br><span class="line">    h, w, c = image.shape</span><br><span class="line">    rgbHist = np.zeros([<span class="number">16</span> * <span class="number">16</span> * <span class="number">16</span>, <span class="number">1</span>], np.float32)</span><br><span class="line">    bsize = <span class="number">256</span> / <span class="number">16</span></span><br><span class="line">    <span class="keyword">for</span> row <span class="keyword">in</span> <span class="built_in">range</span>(h):</span><br><span class="line">        <span class="keyword">for</span> col <span class="keyword">in</span> <span class="built_in">range</span>(w):</span><br><span class="line">            b = image[row, col, <span class="number">0</span>]</span><br><span class="line">            g = image[row, col, <span class="number">1</span>]</span><br><span class="line">            r = image[row, col, <span class="number">2</span>]</span><br><span class="line">            index = np.<span class="built_in">int</span>(b / bsize) * <span class="number">16</span> * <span class="number">16</span> + np.<span class="built_in">int</span>(g / bsize) * <span class="number">16</span> + np.<span class="built_in">int</span>(r / bsize)</span><br><span class="line">            rgbHist[np.<span class="built_in">int</span>(index), <span class="number">0</span>] = rgbHist[np.<span class="built_in">int</span>(index), <span class="number">0</span>] + <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> rgbHist</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hist_compare</span>(<span class="params">image1, image2</span>):</span></span><br><span class="line">    hist1 = create_rgb_hist(image1)</span><br><span class="line">    hist2 = create_rgb_hist(image2)</span><br><span class="line">    match1 = cv2.compareHist(hist1, hist2, cv2.HISTCMP_BHATTACHARYYA)</span><br><span class="line">    match2 = cv2.compareHist(hist1, hist2, cv2.HISTCMP_CORREL)</span><br><span class="line">    match3 = cv2.compareHist(hist1, hist2, cv2.HISTCMP_CHISQR)</span><br><span class="line">    <span class="comment"># 巴氏距离越小越相似，相关性越大越相似，卡方越大越不相似</span></span><br><span class="line">    print(<span class="string">&quot;巴氏距离&quot;</span>, match1)</span><br><span class="line">    print(<span class="string">&quot;相关性&quot;</span>, match2)</span><br><span class="line">    print(<span class="string">&quot;卡方&quot;</span>, match3)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    img1 = cv2.imread(<span class="string">&quot;img5.jpg&quot;</span>)</span><br><span class="line">    img2 = cv2.imread(<span class="string">&quot;img6.jpg&quot;</span>)</span><br><span class="line">    cv2.imshow(<span class="string">&quot;img1&quot;</span>, img1)</span><br><span class="line">    cv2.imshow(<span class="string">&quot;img2&quot;</span>, img2)</span><br><span class="line">    hist_compare(img1, img2)</span><br><span class="line">    cv2.waitKey(<span class="number">0</span>)</span><br><span class="line">    cv2.destroyAllWindows()</span><br></pre></td></tr></table></figure><p><img src="https://img2018.cnblogs.com/blog/760885/201906/760885-20190626155749111-319065259.png" alt="img"></p><h3 id="直方图反投影"><a href="#直方图反投影" class="headerlink" title="直方图反投影"></a>直方图反投影</h3><h4 id="定义-3"><a href="#定义-3" class="headerlink" title="定义"></a>定义</h4><ul><li>直方图反投影，常用于图像分割或在图像中查找感兴趣的对象。本质是定位模板图像在输入图像的位置。</li><li>直方图反投影，一般使用的是颜色直方图，颜色直方图比灰度直方图更容易定义对象。</li><li>流程：1. 选定一个目标图像，这个图像应包含并尽可能填充我们的检测目标对象；2. 创建该图像的直方图；3. 将该直方图反投影到需要检测的测试图像上，计算出每个像素属于该目标的概率。</li><li>直方图反投影可以与 camshift 算法等配合使用。</li><li>我选择 U-Net。</li></ul><h4 id="OpenCV的反投影"><a href="#OpenCV的反投影" class="headerlink" title="OpenCV的反投影"></a>OpenCV的反投影</h4><ul><li><code>cv2.calcBackProject(images, channels, hist, ranges, scale, dst)</code>：<ul><li><code>hist</code>：目标进行归一化后的直方图。</li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"></span><br><span class="line">roi = cv2.imread(<span class="string">&#x27;rose_red.png&#x27;</span>)</span><br><span class="line">hsv = cv2.cvtColor(roi, cv2.COLOR_BGR2HSV)</span><br><span class="line">target = cv2.imread(<span class="string">&#x27;rose.png&#x27;</span>)</span><br><span class="line">hsvt = cv2.cvtColor(target, cv2.COLOR_BGR2HSV)</span><br><span class="line"><span class="comment"># 1. 计算检测目标的直方图</span></span><br><span class="line">roihist = cv2.calcHist([hsv], [<span class="number">0</span>, <span class="number">1</span>], <span class="literal">None</span>, [<span class="number">180</span>, <span class="number">256</span>], [<span class="number">0</span>, <span class="number">180</span>, <span class="number">0</span>, <span class="number">256</span>])</span><br><span class="line"><span class="comment"># 2. 归一化目标直方图</span></span><br><span class="line">cv2.normalize(roihist, roihist, <span class="number">0</span>, <span class="number">255</span>, cv2.NORM_MINMAX)</span><br><span class="line"><span class="comment"># 3. 反传算法</span></span><br><span class="line">dst = cv2.calcBackProject([hsvt], channels=[<span class="number">0</span>, <span class="number">1</span>], hist=roihist, ranges=[<span class="number">0</span>, <span class="number">180</span>, <span class="number">0</span>, <span class="number">256</span>], scale=<span class="number">1</span>)</span><br><span class="line"><span class="comment"># 4. 用圆盘卷积核对概率图像进行均值滤波</span></span><br><span class="line">disc = cv2.getStructuringElement(cv2.MORPH_ELLIPSE, (<span class="number">5</span>, <span class="number">5</span>))</span><br><span class="line">cv2.filter2D(dst, -<span class="number">1</span>, disc, dst)</span><br><span class="line"><span class="comment"># 5. 应用阈值作，获得mask</span></span><br><span class="line">ret, thresh = cv2.threshold(dst, <span class="number">50</span>, <span class="number">255</span>, <span class="number">0</span>)</span><br><span class="line">thresh = cv2.merge((thresh, thresh, thresh))</span><br><span class="line">res = cv2.bitwise_and(target, thresh)</span><br><span class="line">res = np.vstack((target, thresh, res))  <span class="comment"># 上下拼接</span></span><br><span class="line">cv2.imwrite(<span class="string">&#x27;res.jpg&#x27;</span>, res)</span><br></pre></td></tr></table></figure><ul><li><p>如下示例中，蓝色矩形的区域为目标对象，使用直方图反投影提取整个地面。</p><img src="/2021/08/OpenCV-Part4/backproject_opencv.jpg" alt="img" style="zoom: 33%;"></li></ul><h2 id="傅里叶变换"><a href="#傅里叶变换" class="headerlink" title="傅里叶变换"></a>傅里叶变换</h2><h3 id="定义-4"><a href="#定义-4" class="headerlink" title="定义"></a>定义</h3><ul><li><p>傅立叶变换，可以用于分析各种滤波器的频率特性。</p></li><li><p>对于正弦信号：如果幅度在短时间内变化快，则为高频信号；如果变化慢，则为低频信号。</p><p>可以将相同的想法扩展到图像：图像中的振幅在边缘点或噪声急剧变化，边缘和噪声就是图像中的高频内容；如果图像中幅度没有太大变化，则就是低频分量。</p></li><li><p>傅里叶变换，可以将一幅图片分解为正弦和余弦两个分量，即可以将一幅图像从其空间域（spatial domain）转换为频域（frequency domain）。</p></li></ul><blockquote><p>详细讲解傅里叶的文章：</p><ul><li><a href="https://zhuanlan.zhihu.com/p/19759362">https://zhuanlan.zhihu.com/p/19759362</a></li><li><a href="https://zhuanlan.zhihu.com/p/28478034">https://zhuanlan.zhihu.com/p/28478034</a></li></ul></blockquote><ul><li><p><img src="/2021/08/OpenCV-Part4/bb8de9d8a622ec08852a334ed34f404b_b.jpg" alt="img"></p></li><li><p>正弦波就是一个圆周运动在一条直线上的投影。所以频域的基本单元也可以理解为一个始终在旋转的圆：</p><img src="/2021/08/OpenCV-Part4/Fourier_series_square_wave_circles_animation.gif" alt="File:Fourier series square wave circles animation.gif" style="zoom: 80%;"></li><li><p>时域与频域之间的联系：</p><img src="/2021/08/OpenCV-Part4/Fourier_series_and_transform.gif" alt="File:Fourier series and transform.gif" style="zoom:80%;"></li></ul><h3 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h3><ol><li><p>灰度图 与 傅里叶变换：</p><ul><li><p>可以看到白色区域大多在中心，显示低频率的内容比较多。</p></li><li><img src="/2021/08/OpenCV-Part4/image-20210903141954326.png" alt="image-20210903141954326" style="zoom: 30%;"></li></ul></li><li><p>傅里叶变换删去低频内容：</p><ul><li><p>删除图像中的低频内容，即将HPF应用于图像，本质是提取边缘。</p></li><li><img src="/2021/08/OpenCV-Part4/image-20210903142034836.png" alt="image-20210903142034836" style="zoom: 67%;"></li></ul></li><li><p>傅里叶变换删去高频内容：</p><ul><li><p>删除图像中的高频内容，即将LPF应用于图像，本质是模糊图像。</p></li><li><img src="/2021/08/OpenCV-Part4/image-20210903142118824.png" alt="image-20210903142118824" style="zoom: 33%;"></li></ul></li><li><p>各滤波器是 HPF（High Pass Filter）还是 LPF（Low Pass Filter）：</p><ul><li><p>白点在中间的就是 LPF ，白点在四周的就是 HPF。</p></li><li><img src="http://qiniu.aihubs.net/fft5.jpg" alt="img" style="zoom:80%;"></li></ul></li></ol><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><ul><li>对于图像，可以使用2D离散傅里叶变换（DFT, 2D Discrete Fourier Transform）查找频域。同时，可以使用快速傅立叶变换（FFT, Fast Fourier Transform）的快速算法用于DFT的计算。</li><li>OpenCV使用 <code>cv2.dft()</code>、<code>cv2.idft()</code> 实现傅里叶变换，效率更高。</li><li>Numpy使用 <code>np.ifft2()</code>、<code>np.fft.ifftshift()</code> 实现傅里叶变换，使用更友好。</li><li>DFT的性能优化：在一定的阵列尺寸下，DFT计算的性能较好。当数组大小为2的幂时，速度最快。大小为2、3和5的乘积的数组也可以非常有效地处理。<br>为达到最佳性能，可以通过OpenCV提供的函数 <code>cv2.getOptimalDFTSize()</code> 寻找最佳尺寸。<br>然后将图像填充成最佳性能大小的阵列：1. 对于OpenCV，必须手动填充零；2. 对于Numpy，可以指定FFT计算的新大小，自动填充零。</li><li>通过使用最优阵列，大概能提升4倍的效率。而OpenCV本身也比Numpy效率快近3倍。</li></ul><h4 id="Numpy中的傅里叶变换"><a href="#Numpy中的傅里叶变换" class="headerlink" title="Numpy中的傅里叶变换"></a>Numpy中的傅里叶变换</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> matplotlib <span class="keyword">import</span> pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">img = cv2.imread(<span class="string">&#x27;test.jpg&#x27;</span>, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 1. 使用Numpy实现傅里叶变换 fft.fft2()</span></span><br><span class="line">f = np.fft.fft2(img)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 一旦得到结果，零频率分量（直流分量）将出现在左上角。</span></span><br><span class="line"><span class="comment"># 如果要将其置于中心，则需要使用 np.fft.fftshift() 将结果在两个方向上移动。</span></span><br><span class="line"><span class="comment"># 一旦找到了频率变换，就能找到幅度谱。</span></span><br><span class="line">fshift = np.fft.fftshift(f)</span><br><span class="line">magnitude_spectrum = <span class="number">20</span> * np.log(np.<span class="built_in">abs</span>(fshift))</span><br><span class="line"></span><br><span class="line">plt.subplot(<span class="number">121</span>), plt.imshow(img, cmap=<span class="string">&#x27;gray&#x27;</span>)</span><br><span class="line">plt.title(<span class="string">&#x27;Input Image&#x27;</span>), plt.xticks([]), plt.yticks([])</span><br><span class="line">plt.subplot(<span class="number">122</span>), plt.imshow(magnitude_spectrum, cmap=<span class="string">&#x27;gray&#x27;</span>)</span><br><span class="line">plt.title(<span class="string">&#x27;Magnitude Spectrum&#x27;</span>), plt.xticks([]), plt.yticks([])</span><br><span class="line">plt.show()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. 找到了频率变换，就可以进行高通滤波和重建图像，也就是求逆DFT</span></span><br><span class="line">rows, cols = img.shape</span><br><span class="line">crow, ccol = rows // <span class="number">2</span>, cols // <span class="number">2</span></span><br><span class="line">fshift[crow - <span class="number">30</span>:crow + <span class="number">30</span>, ccol - <span class="number">30</span>:ccol + <span class="number">30</span>] = <span class="number">0</span></span><br><span class="line">f_ishift = np.fft.ifftshift(fshift)</span><br><span class="line">img_back = np.fft.ifft2(f_ishift)</span><br><span class="line">img_back = np.<span class="built_in">abs</span>(img_back)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 4. 众所周知，高通滤波是一种边缘检测操作。这也表明大部分图像数据存在于频谱的低频区域。</span></span><br><span class="line"><span class="comment"># 仔细观察结果可以看到最后一张用JET颜色显示的图像，有一些瑕疵，即显示了一些波纹状的结构，这是振铃效应。</span></span><br><span class="line"><span class="comment"># 这是由于用矩形窗口mask造成的，掩码mask被转换为sinc形状，从而导致此问题。所以矩形窗口不用于过滤，更好的选择是高斯mask。</span></span><br><span class="line">plt.subplot(<span class="number">131</span>), plt.imshow(img, cmap=<span class="string">&#x27;gray&#x27;</span>)</span><br><span class="line">plt.title(<span class="string">&#x27;Input Image&#x27;</span>), plt.xticks([]), plt.yticks([])</span><br><span class="line">plt.subplot(<span class="number">132</span>), plt.imshow(img_back, cmap=<span class="string">&#x27;gray&#x27;</span>)</span><br><span class="line">plt.title(<span class="string">&#x27;Image after HPF&#x27;</span>), plt.xticks([]), plt.yticks([])</span><br><span class="line">plt.subplot(<span class="number">133</span>), plt.imshow(img_back)</span><br><span class="line">plt.title(<span class="string">&#x27;Result in JET&#x27;</span>), plt.xticks([]), plt.yticks([])</span><br><span class="line"></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><h4 id="OpenCV中的傅里叶变换"><a href="#OpenCV中的傅里叶变换" class="headerlink" title="OpenCV中的傅里叶变换"></a>OpenCV中的傅里叶变换</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> matplotlib <span class="keyword">import</span> pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">img = cv2.imread(<span class="string">&#x27;test.jpg&#x27;</span>, <span class="number">0</span>)</span><br><span class="line">rows, cols = img.shape</span><br><span class="line"></span><br><span class="line"><span class="comment"># 1. 计算DFT效率最佳的尺寸</span></span><br><span class="line">nrows = cv2.getOptimalDFTSize(rows)</span><br><span class="line">ncols = cv2.getOptimalDFTSize(cols)</span><br><span class="line">print(<span class="string">f&quot;rows: <span class="subst">&#123;rows&#125;</span>-&gt;<span class="subst">&#123;nrows&#125;</span>; cols: <span class="subst">&#123;cols&#125;</span>-&gt;<span class="subst">&#123;ncols&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 将大小扩充成2、3和5的乘积</span></span><br><span class="line">nimg = np.zeros((nrows, ncols))</span><br><span class="line">nimg[:rows, :cols] = img</span><br><span class="line">img = nimg</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. OpenCV计算快速傅里叶变换: 输入图像应首先转换为 np.float32 ，然后使用函数 cv2.dft() 和 cv2.idft() 。</span></span><br><span class="line"><span class="comment"># 返回结果与Numpy相同，但有两个通道。第一个通道为有结果的实部，第二个通道为有结果的虚部。</span></span><br><span class="line">dft = cv2.dft(np.float32(img), flags=cv2.DFT_COMPLEX_OUTPUT)</span><br><span class="line">dft_shift = np.fft.fftshift(dft)</span><br><span class="line">magnitude_spectrum = <span class="number">20</span> * np.log(cv2.magnitude(dft_shift[:, :, <span class="number">0</span>], dft_shift[:, :, <span class="number">1</span>]))</span><br><span class="line"></span><br><span class="line">plt.subplot(<span class="number">121</span>), plt.imshow(img, cmap=<span class="string">&#x27;gray&#x27;</span>)</span><br><span class="line">plt.title(<span class="string">&#x27;Input Image&#x27;</span>), plt.xticks([]), plt.yticks([])</span><br><span class="line">plt.subplot(<span class="number">122</span>), plt.imshow(magnitude_spectrum, cmap=<span class="string">&#x27;gray&#x27;</span>)</span><br><span class="line">plt.title(<span class="string">&#x27;Magnitude Spectrum&#x27;</span>), plt.xticks([]), plt.yticks([])</span><br><span class="line">plt.show()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 4. 删除图像中的高频内容(将LPF应用于图像/模糊图像)</span></span><br><span class="line"><span class="comment"># 首先创建一个在低频时具有高值的mask掩码，中心正方形为1，其他均为0。即传递LF内容，在HF区域为0。</span></span><br><span class="line">rows, cols = img.shape</span><br><span class="line">crow, ccol = rows // <span class="number">2</span>, cols // <span class="number">2</span></span><br><span class="line">mask = np.zeros((rows, cols, <span class="number">2</span>), np.uint8)</span><br><span class="line">mask[crow - <span class="number">30</span>:crow + <span class="number">30</span>, ccol - <span class="number">30</span>:ccol + <span class="number">30</span>] = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 5. 应用掩码Mask和求逆DTF</span></span><br><span class="line">fshift = dft_shift * mask</span><br><span class="line">f_ishift = np.fft.ifftshift(fshift)</span><br><span class="line">img_back = cv2.idft(f_ishift)</span><br><span class="line">img_back = cv2.magnitude(img_back[:, :, <span class="number">0</span>], img_back[:, :, <span class="number">1</span>])</span><br><span class="line"></span><br><span class="line">plt.subplot(<span class="number">121</span>), plt.imshow(img, cmap=<span class="string">&#x27;gray&#x27;</span>)</span><br><span class="line">plt.title(<span class="string">&#x27;Input Image&#x27;</span>), plt.xticks([]), plt.yticks([])</span><br><span class="line">plt.subplot(<span class="number">122</span>), plt.imshow(img_back, cmap=<span class="string">&#x27;gray&#x27;</span>)</span><br><span class="line">plt.title(<span class="string">&#x27;Magnitude Spectrum&#x27;</span>), plt.xticks([]), plt.yticks([])</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><h4 id="HPF-or-LPF"><a href="#HPF-or-LPF" class="headerlink" title="HPF or LPF"></a>HPF or LPF</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> matplotlib <span class="keyword">import</span> pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 简单的均值滤波</span></span><br><span class="line">mean_filter = np.ones((<span class="number">3</span>, <span class="number">3</span>))</span><br><span class="line"><span class="comment"># 构建高斯滤波</span></span><br><span class="line">x = cv2.getGaussianKernel(<span class="number">5</span>, <span class="number">10</span>)</span><br><span class="line">gaussian = x * x.T</span><br><span class="line"><span class="comment"># 不同的边缘检测算法Scharr-x方向</span></span><br><span class="line">scharr = np.array([[-<span class="number">3</span>, <span class="number">0</span>, <span class="number">3</span>],</span><br><span class="line">                   [-<span class="number">10</span>, <span class="number">0</span>, <span class="number">10</span>],</span><br><span class="line">                   [-<span class="number">3</span>, <span class="number">0</span>, <span class="number">3</span>]])</span><br><span class="line"><span class="comment"># Sobel_x</span></span><br><span class="line">sobel_x = np.array([[-<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>],</span><br><span class="line">                    [-<span class="number">2</span>, <span class="number">0</span>, <span class="number">2</span>],</span><br><span class="line">                    [-<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>]])</span><br><span class="line"><span class="comment"># Sobel_y</span></span><br><span class="line">sobel_y = np.array([[-<span class="number">1</span>, -<span class="number">2</span>, -<span class="number">1</span>],</span><br><span class="line">                    [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">                    [<span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>]])</span><br><span class="line"><span class="comment"># 拉普拉斯</span></span><br><span class="line">laplacian = np.array([[<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>],</span><br><span class="line">                      [<span class="number">1</span>, -<span class="number">4</span>, <span class="number">1</span>],</span><br><span class="line">                      [<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>]])</span><br><span class="line"></span><br><span class="line">filters = [mean_filter, gaussian, laplacian, sobel_x, sobel_y, scharr]</span><br><span class="line">filter_name = [<span class="string">&#x27;mean_filter&#x27;</span>, <span class="string">&#x27;gaussian&#x27;</span>, <span class="string">&#x27;laplacian&#x27;</span>, <span class="string">&#x27;sobel_x&#x27;</span>, <span class="string">&#x27;sobel_y&#x27;</span>, <span class="string">&#x27;scharr_x&#x27;</span>]</span><br><span class="line">fft_filters = [np.fft.fft2(x) <span class="keyword">for</span> x <span class="keyword">in</span> filters]</span><br><span class="line">fft_shift = [np.fft.fftshift(y) <span class="keyword">for</span> y <span class="keyword">in</span> fft_filters]</span><br><span class="line">mag_spectrum = [np.log(np.<span class="built_in">abs</span>(z) + <span class="number">1</span>) <span class="keyword">for</span> z <span class="keyword">in</span> fft_shift]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">6</span>):</span><br><span class="line">    plt.subplot(<span class="number">2</span>, <span class="number">3</span>, i + <span class="number">1</span>), plt.imshow(mag_spectrum[i], cmap=<span class="string">&#x27;gray&#x27;</span>)</span><br><span class="line">    plt.title(filter_name[i]), plt.xticks([]), plt.yticks([])</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><h2 id="模板匹配"><a href="#模板匹配" class="headerlink" title="模板匹配"></a>模板匹配</h2><ul><li>模板匹配，在较大图像中查找模板图像位置的方法。</li><li>我选择深度学习。</li></ul><h3 id="OpenCV中的模板匹配"><a href="#OpenCV中的模板匹配" class="headerlink" title="OpenCV中的模板匹配"></a>OpenCV中的模板匹配</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">from</span> matplotlib <span class="keyword">import</span> pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">img = cv2.imread(<span class="string">&#x27;test.jpg&#x27;</span>, <span class="number">0</span>)</span><br><span class="line">template = cv2.imread(<span class="string">&#x27;test2.png&#x27;</span>, <span class="number">0</span>)</span><br><span class="line">w, h = template.shape[::-<span class="number">1</span>]</span><br><span class="line"><span class="comment"># 列表中所有的6种比较方法</span></span><br><span class="line">methods = [<span class="string">&#x27;cv2.TM_CCOEFF&#x27;</span>, <span class="string">&#x27;cv2.TM_CCOEFF_NORMED&#x27;</span>, <span class="string">&#x27;cv2.TM_CCORR&#x27;</span>,</span><br><span class="line">           <span class="string">&#x27;cv2.TM_CCORR_NORMED&#x27;</span>, <span class="string">&#x27;cv2.TM_SQDIFF&#x27;</span>, <span class="string">&#x27;cv2.TM_SQDIFF_NORMED&#x27;</span>]</span><br><span class="line"><span class="keyword">for</span> meth <span class="keyword">in</span> methods:</span><br><span class="line">    img_ = img.copy()</span><br><span class="line">    method = <span class="built_in">eval</span>(meth)</span><br><span class="line">    <span class="comment"># 应用模板匹配</span></span><br><span class="line">    res = cv2.matchTemplate(img_, template, method)</span><br><span class="line">    min_val, max_val, min_loc, max_loc = cv2.minMaxLoc(res)</span><br><span class="line">    <span class="comment"># 如果方法是TM_SQDIFF或TM_SQDIFF_NORMED，则取最小值</span></span><br><span class="line">    <span class="keyword">if</span> method <span class="keyword">in</span> [cv2.TM_SQDIFF, cv2.TM_SQDIFF_NORMED]:</span><br><span class="line">        top_left = min_loc</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        top_left = max_loc</span><br><span class="line">    bottom_right = (top_left[<span class="number">0</span>] + w, top_left[<span class="number">1</span>] + h)</span><br><span class="line">    cv2.rectangle(img_, top_left, bottom_right, <span class="number">255</span>, <span class="number">2</span>)</span><br><span class="line">    </span><br><span class="line">    plt.subplot(<span class="number">121</span>), plt.imshow(res, cmap=<span class="string">&#x27;gray&#x27;</span>)</span><br><span class="line">    plt.title(<span class="string">&#x27;Matching Result&#x27;</span>), plt.xticks([]), plt.yticks([])</span><br><span class="line">    plt.subplot(<span class="number">122</span>), plt.imshow(img_, cmap=<span class="string">&#x27;gray&#x27;</span>)</span><br><span class="line">    plt.title(<span class="string">&#x27;Detected Point&#x27;</span>), plt.xticks([]), plt.yticks([])</span><br><span class="line">    plt.suptitle(meth)</span><br><span class="line">    plt.show()</span><br></pre></td></tr></table></figure><h3 id="多对象模板匹配"><a href="#多对象模板匹配" class="headerlink" title="多对象模板匹配"></a>多对象模板匹配</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">img_rgb = cv2.imread(<span class="string">&#x27;mario.png&#x27;</span>)</span><br><span class="line">img_gray = cv2.cvtColor(img_rgb, cv2.COLOR_BGR2GRAY)</span><br><span class="line">template = cv2.imread(<span class="string">&#x27;mario_coin.png&#x27;</span>, <span class="number">0</span>)</span><br><span class="line">w, h = template.shape[::-<span class="number">1</span>]</span><br><span class="line">res = cv2.matchTemplate(img_gray, template, cv2.TM_CCOEFF_NORMED)</span><br><span class="line">threshold = <span class="number">0.8</span></span><br><span class="line">loc = np.where(res &gt;= threshold)</span><br><span class="line"><span class="keyword">for</span> pt <span class="keyword">in</span> <span class="built_in">zip</span>(*loc[::-<span class="number">1</span>]):</span><br><span class="line">    cv2.rectangle(img_rgb, pt, (pt[<span class="number">0</span>] + w, pt[<span class="number">1</span>] + h), (<span class="number">0</span>, <span class="number">0</span>, <span class="number">255</span>), <span class="number">2</span>)</span><br><span class="line">cv2.imwrite(<span class="string">&#x27;res.png&#x27;</span>, img_rgb)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> OpenCV </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>OpenCV-Part3</title>
      <link href="/2021/08/OpenCV-Part3/"/>
      <url>/2021/08/OpenCV-Part3/</url>
      
        <content type="html"><![CDATA[<h1 id="OpenCV-Part3——图像处理（中）"><a href="#OpenCV-Part3——图像处理（中）" class="headerlink" title="OpenCV-Part3——图像处理（中）"></a>OpenCV-Part3——图像处理（中）</h1><p>[TOC]</p><h2 id="图像边缘检测"><a href="#图像边缘检测" class="headerlink" title="图像边缘检测"></a>图像边缘检测</h2><h3 id="边缘检测"><a href="#边缘检测" class="headerlink" title="边缘检测"></a>边缘检测</h3><ul><li>边缘是图像中的重要的结构性特征，边缘往往存在于目标和背景之间、不同的区域之间，因此它可以作为图像分割的重要依据。</li><li>边缘检测是检测图像中的像素点，其周围的像素值是否发生了急剧的变化，这个剧烈的变化就是不同物体的边界。<ul><li>边缘其实就是图像上灰度级变化很快、梯度很大的点的集合。</li><li>图像的梯度可以用一阶导数和二阶偏导数来求解。</li><li>边缘检测提取的是图像中不连续部分的特征，将闭合的边缘提取出来便可以作为一个区域。</li></ul></li><li>与区域划分相比，边缘检测不需要逐个的对像素进行比较，比较适合大图像的处理。</li><li>图像数据以二/三维矩阵的形式存储的，对一幅图像的求导相当于对一个曲面求导。<ul><li>对图像求导、获取一幅图像的梯度：使用模板（Roberts、Prewitt、Sobel、Lapacian算子）对原图像进行卷积。</li><li>OpenCV 提供的梯度滤波器（高通滤波器）：Sobel、Scharr、Laplacian、Canny。</li><li>使用一阶导的算子有 Prewitt、Sobel、Canny；使用二阶导的有 Lapacian 。Scharr 是对 Sobel（使用小的卷积核求解求解梯度角度时）的优化。</li></ul></li></ul><h3 id="各种算子比较"><a href="#各种算子比较" class="headerlink" title="各种算子比较"></a>各种算子比较</h3><h4 id="Roberts-算子"><a href="#Roberts-算子" class="headerlink" title="Roberts 算子"></a>Roberts 算子</h4><ul><li>Roberts 算子又称为交叉微分算子，是基于交叉差分的一阶微分算子。比较简单，计算量小。</li><li>Roberts 常用来处理具有陡峭的低噪声图像，当图像边缘接近于正 45° 或负 45° 时，该算法处理效果更理想。其缺点是对边缘的定位不太准确，提取的边缘线条较粗。</li><li>对应的模板：<img src="/2021/08/OpenCV-Part3/20200604163101990-163037519253316.png" alt="img"></li></ul><h4 id="Prewitt-算子"><a href="#Prewitt-算子" class="headerlink" title="Prewitt 算子"></a>Prewitt 算子</h4><ul><li><p>Prewitt 算子也是一种一阶微分算子。由 Roberts 的 2×2 改为 3×3 模板矩阵，增加了计算量。</p></li><li><p>Prewitt 在水平方向和垂直方向分别利用两个方向模板与图像进行邻域卷积，边缘检测效果比 Robert 算子更加明显。</p></li><li><p>Prewitt 在权重上对局部像素进行了平均，对噪声有抑制作用。但是同时像素平均也代表了对图像的低通滤波，所以 Prewitt 算子对边缘的定位不如 Roberts 算子。</p></li><li><p>Prewitt 会造成边缘点的误判，因为许多噪声点的灰度值也很大。而且对于幅值较小的边缘点，其边缘反而丢失了。</p></li><li><p>对应的模板：<img src="/2021/08/OpenCV-Part3/image-20210830155817284.png" alt="image-20210830155817284" style="zoom: 67%;"></p></li></ul><h4 id="Sobel-算子"><a href="#Sobel-算子" class="headerlink" title="Sobel 算子"></a>Sobel 算子</h4><ul><li><p>Sobel 是结合了高斯平滑与微分求导的一阶微分算子。在 Prewitt 基础上，将权值改为符合高斯分布。</p></li><li><p>Sobel 考虑了不同距离的相邻点对当前像素点的影响，距离越近的像素点对应当前像素的影响越大，从而实现锐化边缘。因此，比 Prewitt 和 Roberts 都更能准确检测图像边缘。</p></li><li><p>Sobel 算子根据像素点上下左右邻点灰度加权差，在边缘处达到极值这一现象检测边缘，对噪声具有平滑作用，并提供较为精确的边缘方向信息。</p></li><li><p>对应的模板：<img src="/2021/08/OpenCV-Part3/image-20210830155931977.png" alt="image-20210830155931977"></p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">img = cv2.imread(<span class="string">&#x27;box.png&#x27;</span>, <span class="number">0</span>)</span><br><span class="line"><span class="comment"># 使用float64为了保留负数信息</span></span><br><span class="line">sobelx = cv2.Sobel(img, cv2.CV_64F, <span class="number">1</span>, <span class="number">0</span>, ksize=<span class="number">5</span>)</span><br><span class="line">sobely = cv2.Sobel(img, cv2.CV_64F, <span class="number">0</span>, <span class="number">1</span>, ksize=<span class="number">5</span>)</span><br></pre></td></tr></table></figure><h4 id="Laplacian-算子"><a href="#Laplacian-算子" class="headerlink" title="Laplacian 算子"></a>Laplacian 算子</h4><ul><li><p>拉普拉斯（Laplacian）是一个二阶微分算子，是二阶 Sobel 导数，常用于图像增强和边缘提取。</p></li><li><p>Laplacian 原理：在卷积邻域内，如果中心像素的灰度更高，则提升中心像素的灰度；反之则降低中心像素的灰度。</p><ol><li>模板与图像进行卷积运算：当中心像素灰度等于邻域内其他像素的平均灰度时，结果为0；当中心像素高于平均灰度时，结果为正数；当中心像素低于平均灰度时，结果为负数。</li><li>对上述卷积运算结果用适当的衰弱因子处理后，加在原中心像素上，就可以实现图像的锐化处理。</li></ol></li><li><p>Laplacian 算子模板分为四邻域和八邻域，四邻域是对邻域中心像素的四方向求梯度，八邻域是对八方向求梯度。</p><ol><li>四邻域模板：<img src="/2021/08/OpenCV-Part3/20200604163300437.png" alt="img" style="zoom:67%;"></li><li>八邻域模板：<img src="/2021/08/OpenCV-Part3/20200604163310938.png" alt="img" style="zoom:67%;"></li></ol></li><li><p>Laplacian 用于图像增强时，有这几个比较适合的场合。</p><ul><li>由于是通过二次微分正峰和负峰之间的过零点来确定边缘线的位置，因此对孤立点或端点更为敏感，这一特性适用于以突出图像中的孤立点、孤立线或线端点为目的的场合。</li><li>用来改善因扩散效应的模糊特别有效，因为它符合降制模型。扩散效应是成像过程中经常发生的现象。</li></ul></li><li><p>Laplacian 用于边缘提取时，一般不使用其原始形式。它对于边缘和噪声都非常敏感，在锐化边缘的同时也会增强图像中的噪声，所以需要先对图像进行平滑处理。</p><ul><li>原因：1. Laplacian 对噪声具有无法接受的敏感性；2. 同时其幅值产生算边缘，这是复杂的分割不希望有的结果；3. 不能检测边缘的方向。</li><li>取而代之，一般使用的是高斯型拉普拉斯算子(Laplacian of a Gaussian,LoG)，利用该LoG算子进行卷积 等价于 高斯模糊+拉普拉斯。所以，在 LoG 中使用高斯函数的目的就是对图像进行平滑处理，使用 Laplacian 的目的是提供一幅由零交叉确定边缘位置的图像。图像的平滑处理减少了噪声的影响，并且还抵消由 Laplacian 算子的二阶导数引起的逐渐增加的噪声影响。</li></ul></li><li><p>Laplacian 用于图像分割时的作用：</p><ul><li>利用它的零交叉性质进行边缘定位。</li><li>确定一个像素是在一条边缘暗的一面还是亮的一面。</li></ul></li><li><p>图像锐化处理的作用是使灰度反差增强，从而使模糊图像变得更加清晰。图像模糊的实质就是图像受到平均运算或积分运算，因此可以对图像进行逆运算，如微分运算能够突出图像细节，使图像变得更为清晰。</p><p>由于拉普拉斯是一种微分算子，它的应用可增强图像中灰度突变的区域，减弱灰度的缓慢变化区域。因此，锐化处理可选择拉普拉斯算子对原图像进行处理，产生描述灰度突变的图像，再将拉普拉斯图像与原始图像叠加。最终结果是使图像中的各灰度值得到保留、灰度突变处的对比度得到增强，在保留图像背景的前提下，突现出图像中小的细节信息锐化图像。</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">img = cv2.imread(<span class="string">&#x27;box.png&#x27;</span>, <span class="number">0</span>)</span><br><span class="line">laplacian = cv2.Laplacian(img, cv2.CV_64F)</span><br></pre></td></tr></table></figure><p><img src="/2021/08/OpenCV-Part3/gradients.jpg" alt="img"></p><h4 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h4><ul><li><p>对于使用数据类型为<code>cv2.CV_8U</code>或<code>np.uint8</code>，会有一个小问题：黑色到白色的过渡被视为正斜率（具有正值），而白色到黑色的过渡被视为负斜率（具有负值）。因此，当将数据转换为np.uint8时，所有负斜率均设为零，即错过这一边缘信息。</p></li><li><p>如果要检测两个边缘，更好的选择是将输出数据类型保留为更高的形式，例如<code>cv2.CV_16S</code>，<code>cv2.CV_64F</code>等，取其绝对值，然后转换回<code>cv2.CV_8U</code>。 </p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">img = cv2.imread(<span class="string">&#x27;box.png&#x27;</span>, <span class="number">0</span>)</span><br><span class="line"><span class="comment"># Output dtype = cv2.CV_8U</span></span><br><span class="line">sobelx8u = cv2.Sobel(img, cv2.CV_8U, <span class="number">1</span>, <span class="number">0</span>, ksize=<span class="number">5</span>)</span><br><span class="line"><span class="comment"># Output dtype = cv2.CV_64F. Then take its absolute and convert to cv.CV_8U</span></span><br><span class="line">sobelx64f = cv2.Sobel(img, cv2.CV_64F, <span class="number">1</span>, <span class="number">0</span>, ksize=<span class="number">5</span>)</span><br><span class="line">abs_sobel64f = np.absolute(sobelx64f)</span><br><span class="line">sobel_8u = np.uint8(abs_sobel64f)</span><br></pre></td></tr></table></figure> <img src="/2021/08/OpenCV-Part3/double_edge.jpg" alt="img" style="zoom:150%;"><h3 id="Canny边缘检测算子"><a href="#Canny边缘检测算子" class="headerlink" title="Canny边缘检测算子"></a>Canny边缘检测算子</h3><h4 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h4><ul><li><p>Canny 算子是一个具有滤波、增强、检测的多阶段的边缘检测算子。其产生的边缘很细，没有强弱之分，边缘检测性能比前面几种都要好。</p></li><li><p>Canny 的具体算法步骤：</p><ol><li><p>用高斯滤波器<strong>平滑图像</strong>；</p><ul><li>去除噪声。由于边缘检测很容易受到噪声影响，所以第一步是使用 5x5 的高斯滤波器去除噪声。</li></ul></li><li><p>用一阶偏导的有限差分来<strong>计算并记录梯度和幅值方向</strong>；</p><ul><li><p>对平滑后的图像使用 Sobel 算子计算水平方向和竖直方向的一阶导数（图像梯度）Gx 和 Gy 。根据得到的这两幅梯度图 Gx 和 Gy 找到边界的梯度和方向，公式如下：</p><img src="/2021/08/OpenCV-Part3/image-20210831114755186.png" alt="image-20210831114755186" style="zoom:80%;"></li><li><p>梯度的方向一般总是与边界垂直。梯度方向被归为四类：垂直，水平，和两个对角线。</p></li></ul></li><li><p>对梯度幅值进行<strong>非极大值抑制</strong>：</p><ul><li><p>在获得梯度的方向和大小之后，应该对整幅图像做一个扫描，去除那些非边界上的点。对每一个像素进行检查，看这个点的梯度是不是周围具有相同梯度方向的点中最大的。</p><img src="/2021/08/OpenCV-Part3/image-20210831115028137.png" alt="image-20210831115028137" style="zoom:80%;"></li><li><p>现在你得到的是一个包含“窄边界”的二值图像。</p></li></ul></li><li><p>用<strong>双阈值算法检测和连接边缘</strong>：</p><ul><li><p>现在要确定那些边界才是真正的边界。这时我们需要设置两个阈值：minVal 和 maxVal。当图像的灰度梯度高于 maxVal 时被认为是真的边界，那些低于 minVal 的边界会被抛弃。如果介于两者之间的话，就要看这个点是否与某个被确定为真正的边界点相连，如果是就认为它也是边界点，如果不是就抛弃。</p><img src="/2021/08/OpenCV-Part3/image-20210831115538954.png" alt="image-20210831115538954" style="zoom: 67%;"></li><li><p>A 高于阈值 maxVal 所以是真正的边界点，C 虽然低于 maxVal 但高于minVal 并且与 A 相连，所以也被认为是真正的边界点。而 B 就会被抛弃，因为他不仅低于 maxVal 而且不与真正的边界点相连。所以选择合适的 maxVal和 minVal 对于能否得到好的结果非常重要。在这一步一些小的噪声点也会被除去，因为我们假设边界都是一些长的线段。</p></li></ul></li></ol></li></ul><h4 id="OpenCV中的Canny检测"><a href="#OpenCV中的Canny检测" class="headerlink" title="OpenCV中的Canny检测"></a>OpenCV中的Canny检测</h4><ul><li><code>cv2.Canny(src, threshold1, threshold2)</code>：封装了 Canny 的所有步骤。<ul><li><code>threshold1, threshold2</code>：即双阈值算法的 minVal 和 maxVal 。</li><li><code>perture_size</code>：用于查找图像渐变的 Sobel 内核的大小。默认为3。</li><li><code>L2gradient</code>：用于查找梯度幅度的方程式。如果为<code>True</code>，则使用更精确的公式，默认为<code>False</code>。</li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">edges = cv2.Canny(img, threshold1=<span class="number">100</span>, threshold2=<span class="number">200</span>)  <span class="comment"># 建议放入彩色图</span></span><br></pre></td></tr></table></figure><h2 id="图像金字塔"><a href="#图像金字塔" class="headerlink" title="图像金字塔"></a>图像金字塔</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><ul><li>图像金字塔，是同一图像、不同分辨率的图像的集合。</li><li>图像金字塔，可以协助同时在不同分辨率的相同图像中进行目标检测，即同时检测不同大小的对象，因为我们不能确定对象将会以多大的尺寸显示在图像中。</li></ul><h3 id="构造图像金字塔"><a href="#构造图像金字塔" class="headerlink" title="构造图像金字塔"></a>构造图像金字塔</h3><ul><li><p>构造图像金字塔一般包括二个步骤：</p><ol><li>利用低通滤波器平滑图像</li><li>对平滑后的图像进行采样</li></ol></li><li><p>有两种采样方式：上采样（分辨率逐级升高，不会恢复细节信息）和下采样（分辨率逐级降低，会丢失细节信息）。</p></li><li><p>使用函数<code>cv2.pyrDown()</code>和<code>cv2.pyrUp()</code>构建图像金字塔。</p><ul><li><code>cv2.pyrDown()</code>：从一个高分辨率大尺寸的图像向上构建一个金子塔（尺寸变小，分辨率降低）。</li><li><code>cv2.pyrUp()</code>：从一个低分辨率小尺寸的图像向下构建一个金子塔（尺寸变大，但分辨率不会增加）。</li></ul></li><li><p>下采样过后的层也称为 Octave 。</p><p><img src="/2021/08/OpenCV-Part3/v2-8c6640fe15ab1ecd253a4c06d3b40ddf_720w.jpg" alt="img"></p></li></ul><h4 id="高斯金字塔"><a href="#高斯金字塔" class="headerlink" title="高斯金字塔"></a>高斯金字塔</h4><ul><li>高斯金字塔的构造过程：<ol><li>用高斯内核与图像卷积。</li><li>删除所有偶数行列。</li></ol></li><li>此时<code>higher_reso</code>与<code>higher_reso2</code>是不一样的，因为一旦进行下采样就丢失了细节信息。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">higher_reso = cv2.imread(<span class="string">&#x27;messi5.jpg&#x27;</span>) </span><br><span class="line">lower_reso = cv2.pyrDown(higher_reso)  <span class="comment"># 下采样</span></span><br><span class="line">higher_reso2 = cv.pyrUp(lower_reso)  <span class="comment"># 上采样</span></span><br></pre></td></tr></table></figure><h4 id="拉普拉斯金字塔"><a href="#拉普拉斯金字塔" class="headerlink" title="拉普拉斯金字塔"></a>拉普拉斯金字塔</h4><ul><li>拉普拉斯金字塔由高斯金字塔的高低层级差形成，仅为图像边缘信息。</li><li>拉普拉斯金字塔可以用于图像压缩。</li></ul><h3 id="使用金字塔进行图像融合"><a href="#使用金字塔进行图像融合" class="headerlink" title="使用金字塔进行图像融合"></a>使用金字塔进行图像融合</h3><ul><li>金字塔另一种常用的应用是图像融合。将两个不同层级或不同图像的 Octave 经过变换成相同大小并堆叠在一起，这可以使图像获得不同的特征数据（特征融合）。</li></ul><ol><li>加载两个图像</li><li>查找两个图像的高斯金字塔（在此示例中， 级别数为6）</li><li>在高斯金字塔中，找到其拉普拉斯金字塔</li><li>然后在每个拉普拉斯金字塔级别中加入A的左半部分和B的右半部分</li><li>最后从此联合图像金字塔中重建原始图像。</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">A = cv2.imread(<span class="string">&#x27;test2.png&#x27;</span>)</span><br><span class="line">B = cv2.imread(<span class="string">&#x27;test.jpg&#x27;</span>)</span><br><span class="line"><span class="comment"># 注意：为了使后面可以逐渐减半，这里的尺寸必须为2的次幂</span></span><br><span class="line">A = cv2.resize(A, (<span class="number">256</span>, <span class="number">256</span>), interpolation=cv2.INTER_CUBIC)</span><br><span class="line">B = cv2.resize(B, (<span class="number">256</span>, <span class="number">256</span>), interpolation=cv2.INTER_CUBIC)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成高斯金字塔</span></span><br><span class="line">G = A.copy()</span><br><span class="line">gpA = [G]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>):</span><br><span class="line">    G = cv2.pyrDown(G)</span><br><span class="line">    gpA.append(G)</span><br><span class="line"></span><br><span class="line">G = B.copy()</span><br><span class="line">gpB = [G]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>):</span><br><span class="line">    G = cv2.pyrDown(G)</span><br><span class="line">    gpB.append(G)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 产生Laplacian金字塔</span></span><br><span class="line">lpA = [gpA[<span class="number">5</span>]]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>, <span class="number">0</span>, -<span class="number">1</span>):</span><br><span class="line">    GE = cv2.pyrUp(gpA[i])</span><br><span class="line">    L = cv2.subtract(gpA[i - <span class="number">1</span>], GE)</span><br><span class="line">    lpA.append(L)</span><br><span class="line"></span><br><span class="line">lpB = [gpB[<span class="number">5</span>]]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>, <span class="number">0</span>, -<span class="number">1</span>):</span><br><span class="line">    GE = cv2.pyrUp(gpB[i])</span><br><span class="line">    L = cv2.subtract(gpB[i - <span class="number">1</span>], GE)</span><br><span class="line">    lpB.append(L)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 合并</span></span><br><span class="line">LS = []</span><br><span class="line"><span class="keyword">for</span> la, lb <span class="keyword">in</span> <span class="built_in">zip</span>(lpA, lpB):</span><br><span class="line">    rows, cols, dpt = la.shape</span><br><span class="line">    ls = np.hstack((la[:, <span class="number">0</span>:cols // <span class="number">2</span>], lb[:, cols // <span class="number">2</span>:]))</span><br><span class="line">    LS.append(ls)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重新构建图像</span></span><br><span class="line">ls_ = LS[<span class="number">0</span>]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">6</span>):</span><br><span class="line">    ls_ = cv2.pyrUp(ls_)</span><br><span class="line">    ls_ = cv2.add(ls_, LS[i])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 连接</span></span><br><span class="line">real = np.hstack((A[:, :cols // <span class="number">2</span>], B[:, cols // <span class="number">2</span>:]))</span><br><span class="line"></span><br><span class="line">cv2.imshow(<span class="string">&quot;LS&quot;</span>, ls_)</span><br><span class="line">cv2.imshow(<span class="string">&quot;Real&quot;</span>, real)</span><br><span class="line"></span><br><span class="line">cv2.waitKey(<span class="number">0</span>)</span><br><span class="line">cv2.destroyAllWindows()</span><br></pre></td></tr></table></figure><h2 id="图像轮廓"><a href="#图像轮廓" class="headerlink" title="图像轮廓"></a>图像轮廓</h2><h3 id="轮廓定义"><a href="#轮廓定义" class="headerlink" title="轮廓定义"></a>轮廓定义</h3><ul><li>轮廓，是连接具有相同颜色或强度的所有连续点（沿边界）的曲线。轮廓是用于形状分析以及对象检测和识别的有用工具。</li><li>为了找到轮廓，通常应用阈值或Canny边缘检测。</li></ul><h3 id="查找轮廓"><a href="#查找轮廓" class="headerlink" title="查找轮廓"></a>查找轮廓</h3><ul><li><code>findContours(image, mode, method)</code>：从黑色背景中找到白色物体的轮廓。<ul><li><code>image</code>：仅接受二值图。</li><li><code>mode</code>：轮廓检索模式。<ul><li><code>cv2.RETR_EXTERNAL</code>：表示只检测外轮廓。</li><li><code>cv2.RETR_LIST</code>：检测的轮廓不建立等级关系。</li><li><code>cv2.RETR_CCOMP</code>：建立两个等级的轮廓，上面的一层为外边界，里面的一层为内孔的边界信息。如果内孔内还有一个连通物体，这个物体的边界也在顶层。</li><li><code>cv2.RETR_TREE</code>：建立一个等级树结构的轮廓。</li></ul></li><li><code>method</code>：轮廓近似方法。<ul><li><code>cv2.CHAIN_APPROX_NONE</code>：存储所有的轮廓点，相邻的两个点的像素位置差不超过1。</li><li><code>cv2.CHAIN_APPROX_SIMPLE</code>：压缩水平、垂直、对角线方向的元素，只保留该方向的终点坐标，例如一个矩形轮廓只需4个点来保存轮廓信息</li><li><code>cv2.CHAIN_APPROX_TC89_L1/CV_CHAIN_APPROX_TC89_KCOS</code>：使用 teh-Chinl chain 近似算法</li></ul></li><li><code>contours</code>：返回的第一个值，图像中所有轮廓组成的list。<ul><li>每个轮廓的类型为<code>ndarray</code>，本质是轮廓上的点的集合。</li></ul></li><li><code>hierarchy</code>：返回的第二个可选值，是一个<code>ndarray</code>，其元素个数和轮廓个数相同。<ul><li>每个轮廓<code>contours[i]</code>对应4个轮廓层级属性<code>hierarchy[i][0] ~ hierarchy[i][3]</code>，分别表示后一个轮廓、前一个轮廓、父轮廓、内嵌轮廓的索引。如果没有对应项，则该值为负数。</li></ul></li></ul></li><li>在OpenCV中，<code>findContours()</code>的版本区别：<ul><li>OpenCV3.2 之前，函数会修改源图像。OpenCV3.2 之后，不再修改源图像。</li><li>OpenCV2 返回两个值：<code>contours</code>、<code>hierarchy</code>。OpenCV3 返回三个值：<code>img</code>、<code>countours</code>、<code>hierarchy</code>。这里可以用 try-except 解决版本兼容问题。</li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">im = cv2.imread(<span class="string">&#x27;test.jpg&#x27;</span>)</span><br><span class="line">imgray = cv2.cvtColor(im, cv2.COLOR_BGR2GRAY)</span><br><span class="line">ret, thresh = cv2.threshold(imgray, <span class="number">127</span>, <span class="number">255</span>, <span class="number">0</span>)  <span class="comment"># 转二值</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    img, contours, hierarchy = cv2.findContours(thresh, mode=cv2.RETR_EXTERNAL, method=cv2.CHAIN_APPROX_SIMPLE)</span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line">    contours, hierarchy = cv2.findContours(thresh, mode=cv2.RETR_EXTERNAL, method=cv2.CHAIN_APPROX_SIMPLE)</span><br></pre></td></tr></table></figure><h3 id="绘制轮廓"><a href="#绘制轮廓" class="headerlink" title="绘制轮廓"></a>绘制轮廓</h3><ul><li><p><code>cv2.drawContours(image, contours, contourIdx, color, thickness, lineType, hierarchy, maxLevel, offset)</code>：绘制任何形状的轮廓。</p><ul><li><code>image</code>：指明在哪幅图像上绘制轮廓。</li><li><code>contours</code>：轮廓集合。</li><li><code>contourIdx</code>：指定绘制轮廓集合中的哪条轮廓，如果是-1，则绘制其中的所有轮廓。</li><li><code>thickness</code>：表明轮廓线的宽度，如果是-1(cv2.FILLED)，则为填充。</li></ul></li><li><p>在图像中绘制所有轮廓：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cv2.drawContours(img, contours, -<span class="number">1</span>, (<span class="number">0</span>, <span class="number">255</span>, <span class="number">0</span>), <span class="number">3</span>)</span><br></pre></td></tr></table></figure></li><li><p>绘制单个轮廓，如第四个轮廓：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cv2.drawContours(img, contours, <span class="number">3</span>, (<span class="number">0</span>, <span class="number">255</span>, <span class="number">0</span>), <span class="number">3</span>)</span><br><span class="line"><span class="comment"># 更好用的等价方法</span></span><br><span class="line">cnt = contours[<span class="number">4</span>]</span><br><span class="line">cv2.drawContours(img, [cnt], <span class="number">0</span>, (<span class="number">0</span>,<span class="number">255</span>,<span class="number">0</span>), <span class="number">3</span>)</span><br></pre></td></tr></table></figure></li><li><p>绘制面积最大的轮廓：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 找到最大的轮廓</span></span><br><span class="line">area = []</span><br><span class="line"><span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(contours)):</span><br><span class="line">    area.append(cv2.contourArea(contours[k]))</span><br><span class="line">max_idx = np.argmax(np.array(area))</span><br><span class="line">cnt = contours[max_idx]</span><br><span class="line">cv2.drawContours(img, [cnt], <span class="number">0</span>, (<span class="number">0</span>,<span class="number">255</span>,<span class="number">0</span>), <span class="number">3</span>)</span><br></pre></td></tr></table></figure></li></ul><h3 id="轮廓特征"><a href="#轮廓特征" class="headerlink" title="轮廓特征"></a>轮廓特征</h3><h4 id="特征矩"><a href="#特征矩" class="headerlink" title="特征矩"></a>特征矩</h4><ul><li>特征矩可以帮助计算目标的特征，例如物体的质心、面积等。</li><li><code>cv2.moments()</code>：提供所有计算出的矩值字典。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">img = cv2.imread(<span class="string">&#x27;test.jpg&#x27;</span>, <span class="number">0</span>)</span><br><span class="line">thresh = cv2.Canny(img, <span class="number">100</span>, <span class="number">200</span>)</span><br><span class="line">image, contours, hierarchy = cv2.findContours(thresh, <span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">cnt = contours[<span class="number">0</span>]</span><br><span class="line">M = cv2.moments(cnt)</span><br><span class="line">print(M)</span><br><span class="line"><span class="comment"># &#123;&#x27;m00&#x27;: 6.0, &#x27;m10&#x27;: 3258.0, &#x27;m01&#x27;: 3474.0, &#x27;m20&#x27;: 1769095.6666666665, &#x27;m11&#x27;: 1886382.0, &#x27;m02&#x27;: 2011451.0, &#x27;m30&#x27;: 960620757.0, &#x27;m21&#x27;: 1024306391.0, &#x27;m12&#x27;: 1092217893.0, &#x27;m03&#x27;: 1164635919.0, &#x27;mu20&#x27;: 1.6666666665114462, &#x27;mu11&#x27;: 0.0, &#x27;mu02&#x27;: 5.0, &#x27;mu30&#x27;: 2.384185791015625e-07, &#x27;mu21&#x27;: 8.987262845039368e-08, &#x27;mu12&#x27;: 0.0, &#x27;mu03&#x27;: 0.0, &#x27;nu20&#x27;: 0.04629629629198462, &#x27;nu11&#x27;: 0.0, &#x27;nu02&#x27;: 0.1388888888888889, &#x27;nu30&#x27;: 2.7037215925843386e-09, &#x27;nu21&#x27;: 1.0191763034546432e-09, &#x27;nu12&#x27;: 0.0, &#x27;nu03&#x27;: 0.0&#125;</span></span><br></pre></td></tr></table></figure><ul><li>计算质心：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cx = <span class="built_in">int</span>(M[<span class="string">&#x27;m10&#x27;</span>] / M[<span class="string">&#x27;m00&#x27;</span>])</span><br><span class="line">cy = <span class="built_in">int</span>(M[<span class="string">&#x27;m01&#x27;</span>] / M[<span class="string">&#x27;m00&#x27;</span>])</span><br><span class="line">print(cx, cy)</span><br><span class="line"><span class="comment"># 543 579</span></span><br></pre></td></tr></table></figure><h4 id="轮廓面积"><a href="#轮廓面积" class="headerlink" title="轮廓面积"></a>轮廓面积</h4><ul><li><code>cv2.contourArea(curve)</code>：轮廓面积，等价于矩<code>M[&#39;m00&#39;]</code>。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">area = cv2.contourArea(cnt) </span><br></pre></td></tr></table></figure><h4 id="轮廓周长"><a href="#轮廓周长" class="headerlink" title="轮廓周长"></a>轮廓周长</h4><ul><li><code>cv2.arcLength(curve, closed)</code>：轮廓弧长。<ul><li><code>closed</code>：<code>True</code>指定形状是闭合轮廓，<code>False</code>为曲线。</li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">perimeter = cv2.arcLength(cnt, closed=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure><h3 id="轮廓凹凸状况"><a href="#轮廓凹凸状况" class="headerlink" title="轮廓凹凸状况"></a>轮廓凹凸状况</h3><h4 id="轮廓近似"><a href="#轮廓近似" class="headerlink" title="轮廓近似"></a>轮廓近似</h4><ul><li>例如试图在图像中找到一个正方形，但是由于图像问题，没能得到一个完美的正方形，则可以近似形状。</li><li><code>cv2.approxPolyDP(curve, epsilon, closed)</code>：根据指定的精度，将轮廓形状近似为顶点数量较少的其他形状。由Douglas-Peucker算法实现。<ul><li><code>epsilon</code>：是一个精度参数，表示从轮廓到近似轮廓的最大距离。需要正确选择epsilon才能获得正确的输出。</li><li><code>closed</code>：指定曲线是否闭合。</li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">epsilon = <span class="number">0.3</span> * cv2.arcLength(cnt, <span class="literal">True</span>)</span><br><span class="line">approx = cv2.approxPolyDP(cnt, epsilon, <span class="literal">True</span>)</span><br></pre></td></tr></table></figure><ul><li><p>在第二张图片中，绿线显示了<code>ε=周长×10％</code>时的近似曲线。第三张图中，显示了<code>ε=周长×1％</code>时的情况。</p><p><img src="/2021/08/OpenCV-Part3/approx-16304145028132.jpg" alt="img"></p></li></ul><h4 id="轮廓凸包"><a href="#轮廓凸包" class="headerlink" title="轮廓凸包"></a>轮廓凸包</h4><ul><li><p>凸包与轮廓逼近相似，在某些情况下两者可能提供相同的结果。</p></li><li><p><code>cv2.convexHull(points, hull, clockwise, returnPoints)</code>：检查曲线是否存在凸凹缺陷并进行校正。</p><ul><li><code>points</code>：传入轮廓点集。</li><li><code>hull</code>：输出，通常不需要。</li><li><code>clockwise</code>：方向标志。<code>True</code>表示输出的凸包是顺时针方向的，否则为逆时针。</li><li><code>returnPoints</code>：默认值为<code>True</code>。返回凸包点的(x, y)坐标。如果设置为 False，则返回凸包点在轮廓中相应的索引。</li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hull = cv2.convexHull(cnt) </span><br></pre></td></tr></table></figure><h4 id="检查凸度"><a href="#检查凸度" class="headerlink" title="检查凸度"></a>检查凸度</h4><ul><li><code>cv2.isContourConvex(point)</code>：检查曲线是否凸出。只返回True或False。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">k = cv2.isContourConvex(cnt) </span><br></pre></td></tr></table></figure><h4 id="凸性缺陷"><a href="#凸性缺陷" class="headerlink" title="凸性缺陷"></a>凸性缺陷</h4><ul><li>凸包的任何偏差都可以被认为是凸性缺陷。</li><li><code>cv2.convexityDefects()</code>：查找凸性缺陷。<ul><li>在寻找凸包时，对<code>cv2.convexHull(points, returnPoints)</code>必须传递<code>returnPoints=False</code>。</li><li>返回一个数组，其中每行包含这些值：**[起点、终点、最远点、到最远点的近似距离]**。</li><li>该函数返回的前三个值是cnt的索引。</li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"></span><br><span class="line">img = cv2.imread(<span class="string">&#x27;test.jpg&#x27;</span>)</span><br><span class="line">thresh = cv2.Canny(img, <span class="number">100</span>, <span class="number">200</span>)</span><br><span class="line">_, contours, hierarchy = cv2.findContours(thresh, <span class="number">2</span>, <span class="number">1</span>)</span><br><span class="line">cnt = contours[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查找凸性缺陷</span></span><br><span class="line">hull = cv2.convexHull(cnt, returnPoints=<span class="literal">False</span>)</span><br><span class="line">defects = cv2.convexityDefects(cnt, hull)  </span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(defects.shape[<span class="number">0</span>]):</span><br><span class="line">    s, e, f, d = defects[i, <span class="number">0</span>]</span><br><span class="line">    start = <span class="built_in">tuple</span>(cnt[s][<span class="number">0</span>])</span><br><span class="line">    end = <span class="built_in">tuple</span>(cnt[e][<span class="number">0</span>])</span><br><span class="line">    far = <span class="built_in">tuple</span>(cnt[f][<span class="number">0</span>])</span><br><span class="line">    cv2.line(img, start, end, [<span class="number">0</span>, <span class="number">255</span>, <span class="number">0</span>], <span class="number">2</span>)</span><br><span class="line">    cv2.circle(img, far, <span class="number">5</span>, [<span class="number">0</span>, <span class="number">0</span>, <span class="number">255</span>], -<span class="number">1</span>)</span><br><span class="line">cv2.imshow(<span class="string">&#x27;img&#x27;</span>, img)</span><br><span class="line">cv2.waitKey(<span class="number">0</span>)</span><br></pre></td></tr></table></figure><ul><li><img src="/2021/08/OpenCV-Part3/defects.jpg" alt="img"></li></ul><h4 id="点多边形测试"><a href="#点多边形测试" class="headerlink" title="点多边形测试"></a>点多边形测试</h4><ul><li><code>cv2.pointPolygonTest(contour, pt, measureDist)</code>：计算图像中某一点到轮廓线的最短距离。<ul><li><code>measureDist</code>：如果不想找到距离，则设置为False，因为设置为False可使速度提高2-3倍。<ul><li><code>True</code>：计算有符号距离。点在轮廓线外时为负数，点在轮廓线内时为正数，点在轮廓线上时为零。</li><li><code>False</code>：判断该点是在轮廓线外部还是内部。点在轮廓线外时为<code>-1</code>，点在轮廓线内时为<code>+1</code>，点在轮廓线上时为<code>0</code>。</li></ul></li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dist = cv2.pointPolygonTest(contour=cnt, pt=(<span class="number">50</span>, <span class="number">50</span>), measureDist=<span class="literal">True</span>)  <span class="comment"># 检查(50, 50)到轮廓线的最短距离</span></span><br></pre></td></tr></table></figure><h4 id="形状匹配"><a href="#形状匹配" class="headerlink" title="形状匹配"></a>形状匹配</h4><ul><li><code>cv2.matchShapes()</code>：比较两个形状或两个轮廓，返回一个显示相似性的度量。结果越低，匹配越好。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"></span><br><span class="line">img1 = cv2.imread(<span class="string">&#x27;star.jpg&#x27;</span>, <span class="number">0</span>)</span><br><span class="line">img2 = cv2.imread(<span class="string">&#x27;star2.jpg&#x27;</span>, <span class="number">0</span>)</span><br><span class="line">ret, thresh = cv2.threshold(img1, <span class="number">127</span>, <span class="number">255</span>, <span class="number">0</span>)</span><br><span class="line">ret, thresh2 = cv2.threshold(img2, <span class="number">127</span>, <span class="number">255</span>, <span class="number">0</span>)</span><br><span class="line">contours, hierarchy = cv2.findContours(thresh, <span class="number">2</span>, <span class="number">1</span>)</span><br><span class="line">cnt1 = contours[<span class="number">0</span>]</span><br><span class="line">contours, hierarchy = cv2.findContours(thresh2, <span class="number">2</span>, <span class="number">1</span>)</span><br><span class="line">cnt2 = contours[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">ret = cv2.matchShapes(cnt1, cnt2, <span class="number">1</span>, <span class="number">0.0</span>)</span><br><span class="line">print(ret)</span><br></pre></td></tr></table></figure><ul><li><p>在以下案例中：匹配图像A与本身=0.0；匹配图像A与图像B=0.001946；匹配图像A与图像C=0.326911。</p><p><img src="http://qiniu.aihubs.net/matchshapes.jpg" alt="img"></p></li><li><p>即使是图像旋转也不会对这个比较产生很大的影响。</p></li></ul><h3 id="拟合轮廓"><a href="#拟合轮廓" class="headerlink" title="拟合轮廓"></a>拟合轮廓</h3><h4 id="直角矩形"><a href="#直角矩形" class="headerlink" title="直角矩形"></a>直角矩形</h4><ul><li><code>cv2.boundingRect(points)</code>：不考虑物体旋转，拟合最小矩形框。注意，其面积不是最小的。<ul><li><code>points</code>：目标轮廓的点集。</li><li><code>(x，y)</code>为矩形的左上角坐标，而<code>(w，h)</code>为矩形的宽度和高度。</li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x, y, w, h = cv2.boundingRect(cnt)</span><br><span class="line">cv2.rectangle(img, (x, y), (x + w, y + h), (<span class="number">0</span>, <span class="number">255</span>, <span class="number">0</span>), <span class="number">2</span>)</span><br></pre></td></tr></table></figure><h4 id="旋转矩形"><a href="#旋转矩形" class="headerlink" title="旋转矩形"></a>旋转矩形</h4><ul><li><code>cv2.minAreaRect(point)</code>：考虑旋转，拟合面积最小的外接矩形。<ul><li><code>point</code>：目标轮廓的点集。</li><li>返回一个Box2D结构：<code>(中心坐标(x, y), (宽, 高), 旋转角度)</code>。</li></ul></li><li>cv2.boxPoints()：<code>(中心坐标(x, y), (宽, 高), 旋转角度)</code> -&gt; <code>[[x, y] * 4]</code><ul><li>注意版本区别：OpenCV2中为<code>cv2.cv.BoxPoints</code>，OpenCV3中为<code>cv2.boxPoints()</code>。同样可以用 try-except 兼容版本问题。</li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">rect = cv2.minAreaRect(cnt)</span><br><span class="line">box = cv2.boxPoints(rect)</span><br><span class="line">box = np.int0(box)</span><br><span class="line">cv2.drawContours(img, [box], contourIdx=<span class="number">0</span>, color=(<span class="number">0</span>, <span class="number">0</span>, <span class="number">255</span>), thickness=<span class="number">2</span>)  <span class="comment"># 画(拟合后矩形的)轮廓</span></span><br><span class="line">cv2.polylines(img, [box], isClosed=<span class="literal">True</span>, color=(<span class="number">0</span>, <span class="number">255</span>, <span class="number">255</span>), thickness=<span class="number">2</span>)  <span class="comment"># 画多边形</span></span><br></pre></td></tr></table></figure><ul><li><img src="/2021/08/OpenCV-Part3/image-20210831214555327.png" alt="image-20210831214555327" style="zoom: 50%;"></li></ul><h4 id="最小闭合圈"><a href="#最小闭合圈" class="headerlink" title="最小闭合圈"></a>最小闭合圈</h4><ul><li><code>cv2.minEnclosingCircle(point)</code>：拟合最小外接圆。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(x, y), radius = cv2.minEnclosingCircle(cnt)</span><br><span class="line">center = (<span class="built_in">int</span>(x), <span class="built_in">int</span>(y))</span><br><span class="line">radius = <span class="built_in">int</span>(radius)</span><br><span class="line">cv2.circle(img, center, radius, (<span class="number">0</span>, <span class="number">255</span>, <span class="number">0</span>), <span class="number">2</span>)</span><br></pre></td></tr></table></figure><h4 id="拟合椭圆"><a href="#拟合椭圆" class="headerlink" title="拟合椭圆"></a>拟合椭圆</h4><ul><li><code>cv2.fitEllipse(point)</code>：内接椭圆的旋转矩形。</li><li>很多时候效果并不是非常理想，并没有做到外接。</li><li>需要5个点以上才能拟合椭圆，否则只能用圆形。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ellipse = cv2.fitEllipse(cnt)</span><br><span class="line">(x, y), (w, h), t = ellipse</span><br><span class="line">e_x, e_y, e_a, e_b, e_t = <span class="built_in">int</span>(x), <span class="built_in">int</span>(y), <span class="built_in">int</span>(w / <span class="number">2</span>), <span class="built_in">int</span>(h / <span class="number">2</span>), <span class="built_in">int</span>(t)</span><br><span class="line">cv2.ellipse(img, (e_x, e_y), (e_a, e_b), e_t, <span class="number">0</span>, <span class="number">360</span>, (<span class="number">255</span>, <span class="number">0</span>, <span class="number">0</span>), <span class="number">5</span>)</span><br></pre></td></tr></table></figure><ul><li><img src="/2021/08/OpenCV-Part3/image-20210831221246120.png" alt="image-20210831221246120" style="zoom:50%;"></li></ul><h4 id="拟合直线"><a href="#拟合直线" class="headerlink" title="拟合直线"></a>拟合直线</h4><ul><li><code>cv2.fitLine(points, distType, param, reps, aeps)</code>：在一组点集上近似一条直线。</li><li>也没啥用。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">rows, cols = img.shape[:<span class="number">2</span>]</span><br><span class="line">[vx, vy, x, y] = cv2.fitLine(cnt, cv2.DIST_L2, <span class="number">0</span>, <span class="number">0.01</span>, <span class="number">0.01</span>)</span><br><span class="line">lefty = <span class="built_in">int</span>((-x * vy / vx) + y)</span><br><span class="line">righty = <span class="built_in">int</span>(((cols - x) * vy / vx) + y)</span><br><span class="line">cv2.line(img, (cols - <span class="number">1</span>, righty), (<span class="number">0</span>, lefty), (<span class="number">0</span>, <span class="number">255</span>, <span class="number">0</span>), <span class="number">2</span>)</span><br></pre></td></tr></table></figure><h3 id="轮廓性质"><a href="#轮廓性质" class="headerlink" title="轮廓性质"></a>轮廓性质</h3><h4 id="长宽比"><a href="#长宽比" class="headerlink" title="长宽比"></a>长宽比</h4><ul><li>长宽比：对象边界矩形的宽高比。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x, y, w, h = cv2.boundingRect(cnt)</span><br><span class="line">aspect_ratio = <span class="built_in">float</span>(w) / h</span><br></pre></td></tr></table></figure><h4 id="范围"><a href="#范围" class="headerlink" title="范围"></a>范围</h4><ul><li>范围：轮廓区域与边界矩形区域的比值。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">area = cv2.contourArea(cnt)</span><br><span class="line">x, y, w, h = cv2.boundingRect(cnt)</span><br><span class="line">rect_area = w * h</span><br><span class="line">extent = <span class="built_in">float</span>(area) / rect_area</span><br></pre></td></tr></table></figure><h4 id="坚实度"><a href="#坚实度" class="headerlink" title="坚实度"></a>坚实度</h4><ul><li>坚实度：等高线面积与其凸包面积之比。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">area = cv2.contourArea(cnt)</span><br><span class="line">hull = cv2.convexHull(cnt)</span><br><span class="line">hull_area = cv2.contourArea(hull)</span><br><span class="line">solidity = <span class="built_in">float</span>(area) / hull_area</span><br></pre></td></tr></table></figure><h4 id="等效直径"><a href="#等效直径" class="headerlink" title="等效直径"></a>等效直径</h4><ul><li>等效直径：面积与轮廓面积相同的圆的直径。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">area = cv2.contourArea(cnt)</span><br><span class="line">equi_diameter = np.sqrt(<span class="number">4</span> * area / np.pi)</span><br></pre></td></tr></table></figure><h4 id="取向"><a href="#取向" class="headerlink" title="取向"></a>取向</h4><ul><li>取向：物体指向的角度。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(x, y), (MA, ma), angle = cv2.fitEllipse(cnt)</span><br></pre></td></tr></table></figure><h4 id="掩码"><a href="#掩码" class="headerlink" title="掩码"></a>掩码</h4><ul><li>掩码：构成该对象的所有点。</li><li>Numpy给出的坐标是<code>(行、列)</code>格式，而OpenCV给出的坐标是<code>(x,y)</code>格式。注意，<code>row = x, column = y</code>。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mask = np.zeros(imgray.shape, np.uint8)</span><br><span class="line">cv2.drawContours(mask, [cnt], <span class="number">0</span>, <span class="number">255</span>, -<span class="number">1</span>)</span><br><span class="line">pixelpoints = np.transpose(np.nonzero(mask))</span><br><span class="line"><span class="comment"># pixelpoints = cv2.findNonZero(mask)  # 等价方法</span></span><br></pre></td></tr></table></figure><h4 id="最大值、最小值及其位置"><a href="#最大值、最小值及其位置" class="headerlink" title="最大值、最小值及其位置"></a>最大值、最小值及其位置</h4><ul><li>可以使用掩码图像找到这些参数。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">min_val, max_val, min_loc, max_loc = cv2.minMaxLoc(imgray, mask=mask)</span><br></pre></td></tr></table></figure><h4 id="平均颜色、平均强度"><a href="#平均颜色、平均强度" class="headerlink" title="平均颜色、平均强度"></a>平均颜色、平均强度</h4><ul><li>找到对象的平均颜色，或者灰度模式下物体的平均强度。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mean_val = cv2.mean(img, mask=mask)</span><br></pre></td></tr></table></figure><h4 id="极端点"><a href="#极端点" class="headerlink" title="极端点"></a>极端点</h4><ul><li>极端点：指对象的最顶部，最底部，最右侧和最左侧的点。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">leftmost = <span class="built_in">tuple</span>(cnt[cnt[:, :, <span class="number">0</span>].argmin()][<span class="number">0</span>])</span><br><span class="line">rightmost = <span class="built_in">tuple</span>(cnt[cnt[:, :, <span class="number">0</span>].argmax()][<span class="number">0</span>])</span><br><span class="line">topmost = <span class="built_in">tuple</span>(cnt[cnt[:, :, <span class="number">1</span>].argmin()][<span class="number">0</span>])</span><br><span class="line">bottommost = <span class="built_in">tuple</span>(cnt[cnt[:, :, <span class="number">1</span>].argmax()][<span class="number">0</span>])</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> OpenCV </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>OpenCV-Part2</title>
      <link href="/2021/08/OpenCV-Part2/"/>
      <url>/2021/08/OpenCV-Part2/</url>
      
        <content type="html"><![CDATA[<h1 id="OpenCV-Part2——图像处理（上）"><a href="#OpenCV-Part2——图像处理（上）" class="headerlink" title="OpenCV-Part2——图像处理（上）"></a>OpenCV-Part2——图像处理（上）</h1><p>[TOC]</p><h2 id="HSV色彩空间"><a href="#HSV色彩空间" class="headerlink" title="HSV色彩空间"></a>HSV色彩空间</h2><h3 id="RGB与HSV格式转换"><a href="#RGB与HSV格式转换" class="headerlink" title="RGB与HSV格式转换"></a>RGB与HSV格式转换</h3><ul><li><code>cv2.cvtColor(img, cv2.COLOR_BGR2HSV)</code>：将BGR图片转换成HSV格式。</li><li><code>cv2.inRange(img_hsv, lower, upper)</code>：提取范围内的区域。</li><li>HSV图像的每个像素<code>[h, w]</code>按[H, S, V]顺序存储。其中，H范围[0, 179]、S范围[0, 255]、V范围[0, 255]。</li><li>在对像素值标量进行表达式计算时，要将类型从<code>numpy.uint8</code>转<code>int</code>，防止越界。</li><li>在针对提取某一种颜色之前，可以通过高通滤波来锐化边缘，提高对颜色较淡区域的捕捉能力。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 提取红色区域</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">extract_red</span>():</span></span><br><span class="line">    img = cv2.imread(<span class="string">&quot;test.jpg&quot;</span>)</span><br><span class="line">    img_hsv = cv2.cvtColor(img, cv2.COLOR_BGR2HSV)</span><br><span class="line">    <span class="comment"># 区间1</span></span><br><span class="line">    lower_red_1 = np.array([<span class="number">0</span>, <span class="number">45</span>, <span class="number">177</span>])</span><br><span class="line">    upper_red_1 = np.array([<span class="number">30</span>, <span class="number">255</span>, <span class="number">255</span>])</span><br><span class="line">    mask_1 = cv2.inRange(img_hsv, lower_red_1, upper_red_1)</span><br><span class="line">    <span class="comment"># 区间2</span></span><br><span class="line">    lower_red_2 = np.array([<span class="number">150</span>, <span class="number">45</span>, <span class="number">177</span>])</span><br><span class="line">    upper_red_2 = np.array([<span class="number">180</span>, <span class="number">255</span>, <span class="number">255</span>])</span><br><span class="line">    mask_2 = cv2.inRange(img_hsv, lower_red_2, upper_red_2)</span><br><span class="line">    <span class="comment"># 在空白画布上拼接两个区间</span></span><br><span class="line">    mask = mask_1 + mask_2</span><br><span class="line">    img_ = cv2.bitwise_and(img, img, mask=mask)  <span class="comment"># 这里不要去创建空白的np数组，浪费效率</span></span><br><span class="line">    cv2.imshow(<span class="string">&quot;img_&quot;</span>, img_)</span><br><span class="line">    cv2.waitKey(<span class="number">0</span>)</span><br></pre></td></tr></table></figure><h3 id="找到要追踪的HSV值"><a href="#找到要追踪的HSV值" class="headerlink" title="找到要追踪的HSV值"></a>找到要追踪的HSV值</h3><ul><li>使用相同的函数<code>cv2.cvtColor()</code>传递期望的BGR值，而不是传递图像。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查找绿色的HSV值，</span></span><br><span class="line">green = np.uint8([[[<span class="number">0</span>,<span class="number">255</span>,<span class="number">0</span> ]]])</span><br><span class="line">hsv_green = cv2.cvtColor(green, cv2.COLOR_BGR2HSV)</span><br><span class="line">print(hsv_green)  <span class="comment"># [[[60, 255, 255]]]</span></span><br></pre></td></tr></table></figure><h2 id="图像几何变换"><a href="#图像几何变换" class="headerlink" title="图像几何变换"></a>图像几何变换</h2><h3 id="缩放"><a href="#缩放" class="headerlink" title="缩放"></a>缩放</h3><ul><li><code>cv2.resize()</code>：调整图像的大小。图像的大小可以手动指定，也可以指定缩放比例。出于调整大小的目的，默认使用的插值方法为<code>cv2.INTER_LINEAR</code>。<ul><li><code>dsize</code>：shape是[高, 宽]，dsize是(宽, 高)。</li><li><code>fx/fy</code>：缩放比例。</li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">img = cv2.imread(<span class="string">&quot;test.jpg&quot;</span>)</span><br><span class="line">img_ = cv2.resize(img, dsize=<span class="literal">None</span>, fx=<span class="number">2</span>, fy=<span class="number">2</span>)</span><br><span class="line">img_ = cv2.resize(img, dsize=(img.shape[<span class="number">1</span>] // <span class="number">2</span>, img.shape[<span class="number">0</span>] // <span class="number">2</span>))</span><br></pre></td></tr></table></figure><h3 id="平移"><a href="#平移" class="headerlink" title="平移"></a>平移</h3><ul><li><code>cv2.warpAffine()</code>：<ul><li><code>dsize</code>：输出图像的大小，其形式为<code>(width，height)</code>。记住<code>width</code> =列数/宽，<code>height</code> =行数/高。</li></ul></li><li>将变换矩阵放入<code>np.float32</code>类型的Numpy数组中，并传递给<code>cv2.warpAffine</code>函数。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 偏移(100, 50)</span></span><br><span class="line">h, w, _ = img.shape</span><br><span class="line">M = np.float32([[<span class="number">1</span>, <span class="number">0</span>, <span class="number">100</span>], [<span class="number">0</span>, <span class="number">1</span>, <span class="number">50</span>]])</span><br><span class="line">dst = cv2.warpAffine(img, M, (w, h))</span><br></pre></td></tr></table></figure><p><img src="/2021/08/OpenCV-Part2/translation.jpg" alt="img"></p><h3 id="旋转"><a href="#旋转" class="headerlink" title="旋转"></a>旋转</h3><ul><li><code>cv2.getRotationMatrix2D(center, angle, scale)</code>：获取旋转矩阵。<ul><li><code>center</code>：旋转中心(x, y)。</li><li><code>angle</code>：逆时针旋转角度，可以为负数。</li><li><code>scale</code>：以center为中心的缩放比例。</li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">img = cv2.imread(<span class="string">&quot;test.jpg&quot;</span>)</span><br><span class="line">x, y = img.shape[<span class="number">1</span>] // <span class="number">2</span>, img.shape[<span class="number">0</span>] // <span class="number">2</span></span><br><span class="line">mat_rotate = cv2.getRotationMatrix2D(center=(x, y), angle=-<span class="number">90</span>, scale=<span class="number">0.5</span>)</span><br><span class="line">img = cv2.warpAffine(img, M=mat_rotate, dsize=(img.shape[<span class="number">1</span>], img.shape[<span class="number">0</span>]))</span><br></pre></td></tr></table></figure><ul><li>在如上的方法中，在非正方形的图中旋转，很有可能会受到画布大小的限制。</li><li>对于90°旋转可以使用<code>np.rot90</code>函数。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">img_ = np.rot90(img)</span><br></pre></td></tr></table></figure><h3 id="翻转"><a href="#翻转" class="headerlink" title="翻转"></a>翻转</h3><ul><li><code>cv2.flip(scr, flipCode)</code>：上下/左右翻转图像。<ul><li><code>flipCode</code>：1为水平翻转，0位垂直翻转</li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">img = cv2.flip(img, flipCode=<span class="number">1</span>) </span><br></pre></td></tr></table></figure><h3 id="变换"><a href="#变换" class="headerlink" title="变换"></a>变换</h3><ul><li>OpenCV提供了两个转换函数<code>cv2.warpAffine</code>和<code>cv2.warpPerspective</code>。</li><li><code>cv2.warpAffine</code>采用2x3转换矩阵，而<code>cv2.warpPerspective</code>采用3x3转换矩阵作为输入。</li></ul><h4 id="仿射变换"><a href="#仿射变换" class="headerlink" title="仿射变换"></a>仿射变换</h4><ul><li>在仿射变换中，原始图像中的所有平行线在输出图像中仍将平行。</li><li>通过输入图像中的三个点及其在输出图像中的对应位置，使用<code>cv2.getAffineTransform</code>创建相应的变换矩阵，该矩阵将传递给<code>cv2.warpAffine</code>。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">img = cv2.imread(<span class="string">&quot;test.jpg&quot;</span>)</span><br><span class="line">pts1 = np.float32([[<span class="number">50</span>, <span class="number">50</span>], [<span class="number">200</span>, <span class="number">50</span>], [<span class="number">50</span>, <span class="number">200</span>]])</span><br><span class="line">pts2 = np.float32([[<span class="number">10</span>, <span class="number">100</span>], [<span class="number">200</span>, <span class="number">50</span>], [<span class="number">100</span>, <span class="number">250</span>]])</span><br><span class="line">M = cv2.getAffineTransform(pts1, pts2)</span><br><span class="line">img = cv2.warpAffine(img, M=M, dsize=(img.shape[<span class="number">1</span>], img.shape[<span class="number">0</span>]))</span><br></pre></td></tr></table></figure><img src="/2021/08/OpenCV-Part2/image-20210823211535020.png" alt="image-20210823211535020" style="zoom:67%;"><h4 id="透视变换"><a href="#透视变换" class="headerlink" title="透视变换"></a>透视变换</h4><ul><li>对于透视变换，在转换后，直线也将保持直线。要找到此变换矩阵，需要在输入图像上的4个点，以及在输出图像上对应的4个点。在这4个点中，其中3个不应共线。</li><li>可以通过<code>cv2.getPerspectiveTransform</code>找到该3x3变换矩阵，应用于<code>cv2.warpPerspective</code>。</li><li>注意，这里应用的是3x3变换矩阵，与2x2变换矩阵的方法是不一样的。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">img = cv2.imread(<span class="string">&quot;test.jpg&quot;</span>)</span><br><span class="line">pts1 = np.float32([[<span class="number">180</span>, <span class="number">50</span>], [<span class="number">600</span>, <span class="number">200</span>], [<span class="number">50</span>, <span class="number">430</span>], [<span class="number">470</span>, <span class="number">570</span>]])</span><br><span class="line">pts2 = np.float32([[<span class="number">0</span>, <span class="number">0</span>], [<span class="number">300</span>, <span class="number">0</span>], [<span class="number">0</span>, <span class="number">300</span>], [<span class="number">300</span>, <span class="number">300</span>]])</span><br><span class="line">M = cv2.getPerspectiveTransform(pts1, pts2)</span><br><span class="line">img = cv2.warpPerspective(img, M=M, dsize=(<span class="number">300</span>, <span class="number">300</span>))</span><br></pre></td></tr></table></figure><img src="/2021/08/OpenCV-Part2/image-20210823213417052.png" alt="image-20210823213417052" style="zoom:50%;"><h2 id="图像二值化"><a href="#图像二值化" class="headerlink" title="图像二值化"></a>图像二值化</h2><h3 id="简单阈值"><a href="#简单阈值" class="headerlink" title="简单阈值"></a>简单阈值</h3><ul><li><p><code>cv2.threshold(src, thresh, maxval, type)</code>：对于每个像素，应用同一阈值，用于对像素值进行分类。</p><ul><li><code>cv2.THRESH_BINARY</code>：对于设定的thresh，小于则将当前像素值设置为 0(黑色)，超过则将像素值设置为maxval(白色)。</li><li><code>cv2.THRESH_BINARY_INV</code>：与<code>THRESH_BINARY</code>互为翻转，可以用这一type省去手动翻转的过程。</li><li><code>cv2.THRESH_TRUNC</code>：对于设定的thresh，小于则将当前像素值*2，超过则将像素值设置为maxval(白色)。</li><li><code>cv2.THRESH_TOZERO</code>：对于设定的thresh，小于则将当前像素值设置为 0(黑色)，超过则像素值不变。</li><li><code>cv2.THRESH_TOZERO_INV</code>：对于设定的thresh，小于则将当前像素值*2，超过则将像素值设置为 0(黑色)。</li></ul></li><li><p>输入图像应该是单通道灰度图像。</p></li></ul><ul><li>该方法返回两个输出。第一个是使用的阈值，第二个输出是阈值后的图像。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"></span><br><span class="line">img = cv2.imread(<span class="string">&#x27;radient.png&#x27;</span>, cv2.IMREAD_GRAYSCALE)</span><br><span class="line">ret, thresh1 = cv2.threshold(img, <span class="number">127</span>, <span class="number">255</span>, cv2.THRESH_BINARY)</span><br><span class="line">ret, thresh2 = cv2.threshold(img, <span class="number">127</span>, <span class="number">255</span>, cv2.THRESH_BINARY_INV)</span><br><span class="line">ret, thresh3 = cv2.threshold(img, <span class="number">127</span>, <span class="number">255</span>, cv2.THRESH_TRUNC)</span><br><span class="line">ret, thresh4 = cv2.threshold(img, <span class="number">127</span>, <span class="number">255</span>, cv2.THRESH_TOZERO)</span><br><span class="line">ret, thresh5 = cv2.threshold(img, <span class="number">127</span>, <span class="number">255</span>, cv2.THRESH_TOZERO_INV)</span><br><span class="line">cv2.imshow(<span class="string">&quot;BINARY&quot;</span>, thresh1)</span><br><span class="line">cv2.imshow(<span class="string">&quot;BINARY_INV&quot;</span>, thresh2)</span><br><span class="line">cv2.imshow(<span class="string">&quot;TRUNC&quot;</span>, thresh3)</span><br><span class="line">cv2.imshow(<span class="string">&quot;TOZERO&quot;</span>, thresh4)</span><br><span class="line">cv2.imshow(<span class="string">&quot;TOZERO_INV&quot;</span>, thresh5)</span><br><span class="line">cv2.waitKey(<span class="number">0</span>)</span><br></pre></td></tr></table></figure><p><img src="/2021/08/OpenCV-Part2/threshold.jpg" alt="img"></p><h3 id="自适应阈值"><a href="#自适应阈值" class="headerlink" title="自适应阈值"></a>自适应阈值</h3><ul><li><code>cv2.threshold</code>：使用一个值作为全局像素的阈值，这样不能具备普适性，例如，图像在不同区域具有不同的光照条件时。</li><li><code>cv2.adaptiveThreshold</code>：基于像素周围的小区域确定像素的阈值。对于同一图像的不同区域，获取不同的阈值。<ul><li><code>cv2.ADAPTIVE_THRESH_MEAN_C</code>：阈值是邻近区域的<strong>平均值</strong>减去常数<code>C</code>。</li><li><code>cv2.ADAPTIVE_THRESH_GAUSSIAN_C</code>：阈值是邻域值的<strong>高斯加权总和</strong>减去常数<code>C</code>。</li><li><code>BLOCKSIZE</code>：核大小，给定奇数边长。</li><li><code>C</code>：从邻域像素的平均或加权总和中减去的常数。</li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"></span><br><span class="line">img = cv2.imread(<span class="string">&#x27;test.jpg&#x27;</span>, cv2.IMREAD_GRAYSCALE)</span><br><span class="line">thresh1 = cv2.adaptiveThreshold(img, maxValue=<span class="number">255</span>, adaptiveMethod=cv2.ADAPTIVE_THRESH_GAUSSIAN_C,</span><br><span class="line">                                thresholdType=cv2.THRESH_BINARY, blockSize=<span class="number">101</span>, C=<span class="number">15</span>)</span><br><span class="line">cv2.imshow(<span class="string">&quot;BINARY&quot;</span>, thresh1)</span><br><span class="line">cv2.waitKey(<span class="number">0</span>)</span><br></pre></td></tr></table></figure><img src="/2021/08/OpenCV-Part2/image-20210828195757940.png" alt="image-20210828195757940" style="zoom:80%;"><h3 id="Otsu二值化（大津法）"><a href="#Otsu二值化（大津法）" class="headerlink" title="Otsu二值化（大津法）"></a>Otsu二值化（大津法）</h3><ul><li><p>Otsu方法将考虑仅具有两个主要的不同像素值的图像（双峰图像），即直方图仅包含两个峰。</p></li><li><p><code>cv2.threshold(img, thresh, maxval, type=cv2.THRESH_BINARY + cv2.THRESH_OTSU)</code>：Otsu二值化，从图像直方图中自动确定最佳全局阈值以区分这两个值，而无需手动选择。找到最佳阈值后，使用的阈值将作为第一输出返回。</p><ul><li><code>cv2.THRESH_OTSU</code>：作为附加标志传递，实质上是int类型相加。</li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">from</span> matplotlib <span class="keyword">import</span> pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">img = cv2.imread(<span class="string">&#x27;test.jpg&#x27;</span>, cv2.IMREAD_GRAYSCALE)</span><br><span class="line"><span class="comment"># 1. 采用值为127的全局阈值</span></span><br><span class="line">ret1, th1 = cv2.threshold(img, <span class="number">127</span>, <span class="number">255</span>, cv2.THRESH_BINARY)</span><br><span class="line"><span class="comment"># 2. 直接采用Otsu阈值法</span></span><br><span class="line">ret2, th2 = cv2.threshold(img, <span class="number">0</span>, <span class="number">255</span>, cv2.THRESH_BINARY + cv2.THRESH_OTSU)</span><br><span class="line"><span class="comment"># 3. 首先使用5x5高斯核对图像进行滤波以去除噪声，然后应用Otsu阈值处理</span></span><br><span class="line">ret3, th3 = cv2.threshold(cv2.GaussianBlur(img, (<span class="number">5</span>, <span class="number">5</span>), <span class="number">0</span>), <span class="number">0</span>, <span class="number">255</span>, </span><br><span class="line">                          cv2.THRESH_BINARY + cv2.THRESH_OTSU)</span><br><span class="line"><span class="comment"># 绘制所有图像及其直方图</span></span><br><span class="line">images = [img, <span class="number">0</span>, th1,</span><br><span class="line">          img, <span class="number">0</span>, th2,</span><br><span class="line">          blur, <span class="number">0</span>, th3]</span><br><span class="line">titles = [<span class="string">&#x27;Original Noisy Image&#x27;</span>, <span class="string">&#x27;Histogram&#x27;</span>, <span class="string">&#x27;Global Thresholding (v=127)&#x27;</span>,</span><br><span class="line">          <span class="string">&#x27;Original Noisy Image&#x27;</span>, <span class="string">&#x27;Histogram&#x27;</span>, <span class="string">&quot;Otsu&#x27;s Thresholding&quot;</span>,</span><br><span class="line">          <span class="string">&#x27;Gaussian filtered Image&#x27;</span>, <span class="string">&#x27;Histogram&#x27;</span>, <span class="string">&quot;Otsu&#x27;s Thresholding&quot;</span>]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>):</span><br><span class="line">    plt.subplot(<span class="number">3</span>, <span class="number">3</span>, i * <span class="number">3</span> + <span class="number">1</span>), plt.imshow(images[i * <span class="number">3</span>], <span class="string">&#x27;gray&#x27;</span>)</span><br><span class="line">    plt.title(titles[i * <span class="number">3</span>]), plt.xticks([]), plt.yticks([])</span><br><span class="line">    plt.subplot(<span class="number">3</span>, <span class="number">3</span>, i * <span class="number">3</span> + <span class="number">2</span>), plt.hist(images[i * <span class="number">3</span>].ravel(), <span class="number">256</span>)</span><br><span class="line">    plt.title(titles[i * <span class="number">3</span> + <span class="number">1</span>]), plt.xticks([]), plt.yticks([])</span><br><span class="line">    plt.subplot(<span class="number">3</span>, <span class="number">3</span>, i * <span class="number">3</span> + <span class="number">3</span>), plt.imshow(images[i * <span class="number">3</span> + <span class="number">2</span>], <span class="string">&#x27;gray&#x27;</span>)</span><br><span class="line">    plt.title(titles[i * <span class="number">3</span> + <span class="number">2</span>]), plt.xticks([]), plt.yticks([])</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure> <img src="/2021/08/OpenCV-Part2/otsu.jpg" alt="img"><h2 id="图像卷积"><a href="#图像卷积" class="headerlink" title="图像卷积"></a>图像卷积</h2><h3 id="模糊、滤波与卷积的区别"><a href="#模糊、滤波与卷积的区别" class="headerlink" title="模糊、滤波与卷积的区别"></a>模糊、滤波与卷积的区别</h3><blockquote><p>图像卷积的本质，是提取图像不同『频段』的特征。<a href="https://zhuanlan.zhihu.com/p/28478034">https://zhuanlan.zhihu.com/p/28478034</a></p><p>图像模糊(平滑)和滤波，都属于卷积，不同滤波方法之间只是卷积核不同。</p></blockquote><h3 id="低-高通滤波概念"><a href="#低-高通滤波概念" class="headerlink" title="低/高通滤波概念"></a>低/高通滤波概念</h3><p>图像滤波既可以在实域进行，也可以在频域进行。通过滤波，可以强调一些特征或者去除图像中一些不需要的部分。</p><p>滤波是一个邻域操作算子，利用给定像素周围的像素的值决定此像素的最终的输出值。</p><ul><li><p>高通滤波器（HPF）：根据中心像素与周围像素的亮度差值来提升像素的亮度，保留变化强烈的部分，过滤缓和部分。用于：增强、锐化、边缘提取。</p><p>通过高通滤波器进行滤波后，再和原图像叠加，可以增强图像中灰度级变化较快的部分。</p></li><li><p>低通滤波器（LPF）：当中心像素与周围像素的亮度差值大于一个特定值时，平滑该像素的亮度。用于：平滑、模糊、去除噪点。</p><p>低通滤波器容许低频信号通过，但截止了高频信号（噪音，边界）。</p></li></ul><h3 id="自定义滤波"><a href="#自定义滤波" class="headerlink" title="自定义滤波"></a>自定义滤波</h3><ul><li><code>cv2.filter2D(src, ddepth, kernel)</code>：将内核与图像进行卷积。<ul><li><code>ddepth</code>：表示目标图像的所需深度。 当ddepth=-1时，表示输出图像与原图像有相同的深度。</li><li><code>kernel</code>：滤波器/卷积核。如果要将不同的内核应用于不同的通道，需要将图像拆分为单独的颜色平面，分别处理。</li></ul></li><li>在OpenCV中可以自己定义滤波器，然后使用<code>filter2D()</code>对一幅图像进行卷积操作。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="comment"># 高通滤波器模板实现</span></span><br><span class="line">kernel_3x3 = np.array([[-<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>],</span><br><span class="line">                       [-<span class="number">1</span>, <span class="number">8</span>, -<span class="number">1</span>],</span><br><span class="line">                       [-<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>]])</span><br><span class="line">kernel_5x5 = np.array([[-<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>],</span><br><span class="line">                       [-<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>, -<span class="number">1</span>],</span><br><span class="line">                       [-<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">2</span>, -<span class="number">1</span>],</span><br><span class="line">                       [-<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>, -<span class="number">1</span>],</span><br><span class="line">                       [-<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>]])</span><br><span class="line"></span><br><span class="line">img = cv2.imread(<span class="string">&quot;test.jpg&quot;</span>, <span class="number">0</span>)</span><br><span class="line">k3 = cv2.filter2D(img, ddepth=-<span class="number">1</span>, kernel=kernel_3x3)</span><br><span class="line">k5 = cv2.filter2D(img, ddepth=-<span class="number">1</span>, kernel=kernel_5x5)</span><br><span class="line"></span><br><span class="line">cv2.imshow(<span class="string">&quot;img&quot;</span>, img)</span><br><span class="line">cv2.imshow(<span class="string">&quot;3x3&quot;</span>, k3)</span><br><span class="line">cv2.imshow(<span class="string">&quot;5x5&quot;</span>, k5)</span><br><span class="line">cv2.waitKey(<span class="number">0</span>)</span><br></pre></td></tr></table></figure><p><img src="/2021/08/OpenCV-Part2/image-20210829164529053.png" alt="image-20210829164529053"></p><h3 id="常用的图像滤波"><a href="#常用的图像滤波" class="headerlink" title="常用的图像滤波"></a>常用的图像滤波</h3><p>线性滤波（方框滤波、均值滤波、高斯滤波）、非线性滤波（中值滤波、双边滤波）</p><h4 id="方框滤波"><a href="#方框滤波" class="headerlink" title="方框滤波"></a>方框滤波</h4><ul><li><p>方框滤波即一个具有相同权重的二维矩阵。</p></li><li><p>大小 3x3 、权重为 a 的kernel：<img src="/2021/08/OpenCV-Part2/20200525191244444.png" alt="img"></p></li><li><p><code>cv2.boxFilter(src, ddepth, ksize, normalize)</code>：当可选参数 <code>normalize=True</code> 时，方框滤波就是均值滤波，a=1/9； <code>normalize=False</code> 时，a=1，相当于求区域内的像素和。</p></li></ul><h4 id="均值滤波"><a href="#均值滤波" class="headerlink" title="均值滤波"></a>均值滤波</h4><ul><li><code>cv2.blur(src, ksize)</code>：对图像进行均值滤波，即将图像与归一化框滤波器进行卷积。</li><li>保持这个kernel在一个像素点上，获取内核区域下所有像素的平均值，并替换中心元素。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">from</span> matplotlib <span class="keyword">import</span> pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">img = cv2.imread(<span class="string">&#x27;opencv_logo.png&#x27;</span>)[:, :, ::-<span class="number">1</span>]  <span class="comment"># 转换成plt格式</span></span><br><span class="line">kernel = np.ones((<span class="number">5</span>, <span class="number">5</span>), np.float32) / <span class="number">25</span></span><br><span class="line">print(kernel)  <span class="comment"># 5*5的二维矩阵，每个权重为0.04</span></span><br><span class="line"></span><br><span class="line">dst = cv2.filter2D(img, ddepth=-<span class="number">1</span>, kernel=kernel)  <span class="comment"># 法一：filter2D + 手动创建kernel 实现均值滤波</span></span><br><span class="line">dst = cv2.blur(img, (<span class="number">5</span>, <span class="number">5</span>))  <span class="comment"># 法二：blur 直接实现均值滤波</span></span><br><span class="line">dst = cv2.boxFilter(img, ddepth=-<span class="number">1</span>, (<span class="number">5</span>, <span class="number">5</span>), normalize=<span class="literal">True</span>)  <span class="comment"># 法三：boxFilter + normalize=True 实现均值滤波</span></span><br><span class="line"></span><br><span class="line">plt.subplot(<span class="number">121</span>), plt.imshow(img), plt.title(<span class="string">&#x27;Original&#x27;</span>)</span><br><span class="line">plt.xticks([]), plt.yticks([])</span><br><span class="line">plt.subplot(<span class="number">122</span>), plt.imshow(dst), plt.title(<span class="string">&#x27;Averaging&#x27;</span>)</span><br><span class="line">plt.xticks([]), plt.yticks([])</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p> <img src="/2021/08/OpenCV-Part2/filter.jpg" alt="img"></p><h4 id="高斯模糊"><a href="#高斯模糊" class="headerlink" title="高斯模糊"></a>高斯模糊</h4><ul><li>不同于均值滤波，高斯滤波的卷积核权重：中间像素点权重最高，远离中心的像素根据离中心的距离递减，符合正态分布。</li><li>均值滤波是求平均数，高斯滤波是高斯求加权平均数。</li><li><code>cv2.GaussianBlur(src, ksize, sigmaX)</code>：高斯滤波可以有效的从图像中去除高斯噪音。<ul><li>高斯核的宽和高（必须是奇数）</li><li>高斯函数沿 X，Y 方向的标准差。如果只指定了 X 方向的的标准差，Y 方向也会取相同值。如果两个标准差都是 0，那么函数会根据核函数的大小自动计算。</li></ul></li><li><code>cv.getGaussianKernel()</code>：构建一个高斯内核。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">blur = cv2.GaussianBlur(img, (<span class="number">5</span>, <span class="number">5</span>), <span class="number">0</span>)</span><br></pre></td></tr></table></figure><p><img src="/2021/08/OpenCV-Part2/gaussian.jpg" alt="img"></p><h4 id="中位模糊"><a href="#中位模糊" class="headerlink" title="中位模糊"></a>中位模糊</h4><ul><li><code>cv2.medianBlur()</code>：中值模糊，保证了中心元素不会是新计算的值，而是该内核区域中所有像素的中值。</li><li>很容易消除掉孤立的斑点(如0或255)，对于消除椒盐噪声和斑点噪声非常有效。</li><li>中值是一种非线性操作，效率相比线性滤波要慢。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">median = cv2.medianBlur(img, <span class="number">5</span>)</span><br></pre></td></tr></table></figure><p><img src="/2021/08/OpenCV-Part2/median.jpg" alt="img"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sp_noise</span>(<span class="params">image, prob</span>):</span></span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    添加椒盐噪声</span></span><br><span class="line"><span class="string">    prob: 噪声比例</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    output = np.zeros(image.shape, np.uint8)</span><br><span class="line">    thres = <span class="number">1</span> - prob</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(image.shape[<span class="number">0</span>]):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(image.shape[<span class="number">1</span>]):</span><br><span class="line">            rdn = random.random()</span><br><span class="line">            <span class="keyword">if</span> rdn &lt; prob:</span><br><span class="line">                output[i][j] = <span class="number">0</span></span><br><span class="line">            <span class="keyword">elif</span> rdn &gt; thres:</span><br><span class="line">                output[i][j] = <span class="number">255</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                output[i][j] = image[i][j]</span><br><span class="line">    <span class="keyword">return</span> output</span><br></pre></td></tr></table></figure><h4 id="双边滤波"><a href="#双边滤波" class="headerlink" title="双边滤波"></a>双边滤波</h4><ul><li>高斯滤波器是求中心点邻近区域像素的高斯加权平均值，只考虑像素之间的空间关系（平面上的距离），而不会考虑像素值之间的关系（像素值之间的相似度/强度差）。</li><li>所以使用线性滤波器进行模糊无法判断一个像素是否位于边界，基本都会损失掉图像细节信息，边缘信息很难保留下来。</li><li>双边滤波同时使用空间高斯权重和灰度值相似性高斯权重。空间高斯函数确保只有邻近区域的像素对中心点有影响，灰度值相似性高斯函数确保只有与中心像素灰度值相近的才会被用来做模糊运算。由于边缘的像素强度变化较大，因此可以保留边缘。</li><li>双边滤波属于非线性滤波，相比线性滤波会比较慢。</li><li><code>cv2.bilateralFilter()</code>：双边滤波。保持边界清晰的情况下有效去除噪音。<ul><li><code>d</code>：邻域直径</li><li><code>sigmaColor</code>：空间高斯函数标准差</li><li><code>sigmaSpace</code>：灰度值相似性高斯函数标准差</li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bilateralFilter = cv2.bilateralFilter(img, d=<span class="number">9</span>, sigmaColor=<span class="number">75</span>, sigmaSpace=<span class="number">75</span>)</span><br></pre></td></tr></table></figure><img src="/2021/08/OpenCV-Part2/bilateral.jpg" alt="img" style="zoom:200%;"><h2 id="形态学转换"><a href="#形态学转换" class="headerlink" title="形态学转换"></a>形态学转换</h2><h3 id="理论"><a href="#理论" class="headerlink" title="理论"></a>理论</h3><ul><li>形态学操作是根据图像形状进行的简单操作。</li><li>常见图像形态学运算：腐蚀、膨胀、开运算、闭运算、骨架抽取、极线腐蚀、击中击不中变换、Top-hat变换、颗粒分析、流域变换、形态学梯度等。</li><li>最基本的形态学操作是：膨胀(dilation)和腐蚀(erosion)。</li><li>形态学转换在一般情况下是对<strong>二值化图像</strong>进行操作。</li><li>腐蚀和膨胀是对像素值大的部分而言的，即白色(255)部分而不是黑色(0)部分。<ul><li>膨胀就是图像中的高亮部分进行膨胀，效果图拥有比原图<strong>更大的白色区域</strong>。</li><li>腐蚀就是原图中的高亮部分被腐蚀，效果图拥有比原图<strong>更小的白色区域</strong>。</li></ul></li></ul><h3 id="结构元素"><a href="#结构元素" class="headerlink" title="结构元素"></a>结构元素</h3><ul><li><p>形态学操作其实也是将图像与核进行卷积。</p></li><li><p>核（即结构元素/模板/掩码）可以是任何的形状（矩形/椭圆/十字形）和大小，其中心点称为锚点(anchorpoint)。</p></li><li><p><code>cv2.getStructuringElement(shape, ksize)</code>：生成不同形状的结构元素。</p><ul><li><code>shape</code>：形状。</li><li><code>ksize</code>：大小。</li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 矩形内核</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>cv2.getStructuringElement(shape=cv2.MORPH_RECT, ksize=(<span class="number">5</span>, <span class="number">5</span>))</span><br><span class="line">array([[<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>],</span><br><span class="line">       [<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>],</span><br><span class="line">       [<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>],</span><br><span class="line">       [<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>],</span><br><span class="line">       [<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>]], dtype=uint8)</span><br><span class="line"><span class="comment"># 椭圆内核</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>cv2.getStructuringElement(shape=cv2.MORPH_ELLIPSE, ksize=(<span class="number">5</span>, <span class="number">5</span>))</span><br><span class="line">array([[<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">       [<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>],</span><br><span class="line">       [<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>],</span><br><span class="line">       [<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>],</span><br><span class="line">       [<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>]], dtype=uint8)</span><br><span class="line"><span class="comment"># 十字内核</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>cv2.getStructuringElement(shape=cv2.MORPH_CROSS, ksize=(<span class="number">5</span>, <span class="number">5</span>))</span><br><span class="line">array([[<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">       [<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">       [<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>],</span><br><span class="line">       [<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">       [<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>]], dtype=uint8)</span><br></pre></td></tr></table></figure><h3 id="常用的形态学转换"><a href="#常用的形态学转换" class="headerlink" title="常用的形态学转换"></a>常用的形态学转换</h3><ul><li><code>cv2.morphologyEx(src, op, kernel)</code>：形态学转换方法<ul><li><code>op</code>：形态学运算类型。可选包括 侵蚀、膨胀、开闭运算等等。</li></ul></li></ul><h4 id="侵蚀"><a href="#侵蚀" class="headerlink" title="侵蚀"></a>侵蚀</h4><ul><li>侵蚀前景（白色）物体的边界。</li><li>对于原始图像中的每个像素点，内核下的所有像素只要有一个像素为0，则像素元素为0。</li><li>效果：1. 分离出两个独立对象；2. 消除孤立的白色噪点；3. 白色物体中的黑色空洞会被扩大。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">img = cv2.imread(<span class="string">&#x27;j.png&#x27;</span>, cv2.IMREAD_GRAYSCALE)  <span class="comment"># 注意要控制为目标为白色</span></span><br><span class="line">kernel = np.ones((<span class="number">5</span>, <span class="number">5</span>), np.uint8)</span><br><span class="line"></span><br><span class="line">erode = cv2.erode(img, kernel=kernel, iterations=<span class="number">1</span>)</span><br><span class="line">erode = cv2.morphologyEx(img, op=cv2.MORPH_ERODE, kernel=kernel)</span><br></pre></td></tr></table></figure><p><img src="/2021/08/OpenCV-Part2/erosion.png" alt="img"></p><h4 id="扩张"><a href="#扩张" class="headerlink" title="扩张"></a>扩张</h4><ul><li>扩张前景（白色）物体的边界。</li><li>对于原始图像中的每个像素点，内核下的所有像素只要有一个像素为1，则像素元素为1。</li><li>效果：1. 连接两个对象为一个整体；2. 填补白色物体中的黑色空洞；3. 主体外区域的白色噪点会被放大。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dilation = cv2.dilate(img, kernel=kernel, iterations=<span class="number">1</span>) </span><br><span class="line">dilation = cv2.morphologyEx(img, op=cv2.MORPH_DILATE, kernel=kernel)</span><br></pre></td></tr></table></figure><p><img src="/2021/08/OpenCV-Part2/dilation.png" alt="img"></p><h4 id="开运算"><a href="#开运算" class="headerlink" title="开运算"></a>开运算</h4><ul><li>开运算 等价于 <strong>侵蚀</strong>×1+<strong>扩张</strong>×1。</li><li>开运算×1 等价于 开运算×n。</li><li>作用：1. 消除目标外的背景噪音、孤立点；2. 平滑物体轮廓(如果边缘上有凸起)。</li><li>注意：开运算过后的变量名不要设置为open，这与打开文件的方法名重复。闭运算同理。</li></ul><blockquote><ol><li>开/闭运算的精髓在于对细小孤立的白/黑区域(即可能被看做前/背景的噪声)进行消除，而对连续平滑的主体不产生影响。</li><li>对一张黑白图进行开运算 等价于 对其反色的图进行闭运算。</li></ol></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># morphologyEx</span></span><br><span class="line">opening = cv2.morphologyEx(img, op=cv2.MORPH_OPEN, kernel=kernel)</span><br><span class="line"><span class="comment"># erode + dilate</span></span><br><span class="line">erode = cv2.erode(img, kernel=kernel, iterations=<span class="number">1</span>)</span><br><span class="line">opening = cv2.dilate(erode, kernel=kernel, iterations=<span class="number">1</span>)</span><br></pre></td></tr></table></figure><p><img src="/2021/08/OpenCV-Part2/opening.png" alt="img"></p><h4 id="闭运算"><a href="#闭运算" class="headerlink" title="闭运算"></a>闭运算</h4><ul><li>闭运算 等价于 <strong>扩张</strong>×1+<strong>侵蚀</strong>×1。</li><li>闭运算×1 等价于 闭运算×n。</li><li>作用：1. 填补目标内部的黑洞、连接目标裂缝；2. 平滑物体轮廓(如果边缘上有凹陷)。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># morphologyEx</span></span><br><span class="line">closing = cv2.morphologyEx(img, op=cv2.MORPH_CLOSE, kernel=kernel)</span><br><span class="line"><span class="comment"># dilate + erode</span></span><br><span class="line">dilate = cv2.dilate(img, kernel=kernel, iterations=<span class="number">1</span>)</span><br><span class="line">closing = cv2.erode(dilate, kernel=kernel, iterations=<span class="number">1</span>)</span><br></pre></td></tr></table></figure><p><img src="/2021/08/OpenCV-Part2/closing.png" alt="img"></p><h4 id="梯度"><a href="#梯度" class="headerlink" title="梯度"></a>梯度</h4><ul><li>基本梯度 等价于 膨胀后的图像减去腐蚀后的图像。表现图像扩张和侵蚀之间的区别，</li><li>作用：提取对象的轮廓。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># morphologyEx</span></span><br><span class="line">gradient = cv2.morphologyEx(img, op=cv2.MORPH_GRADIENT, kernel=kernel)</span><br><span class="line"><span class="comment"># dilate - erode</span></span><br><span class="line">dilate = cv2.dilate(img, kernel=kernel, iterations=<span class="number">1</span>)</span><br><span class="line">erode = cv2.erode(img, kernel=kernel, iterations=<span class="number">1</span>)</span><br><span class="line">gradient = dilate - erode</span><br></pre></td></tr></table></figure><p><img src="/2021/08/OpenCV-Part2/gradient.jpg" alt="gradient"></p><h4 id="顶帽"><a href="#顶帽" class="headerlink" title="顶帽"></a>顶帽</h4><ul><li>顶帽 等价于 源图像减去开运算后的图像。</li><li>作用：显示开操作所去掉的白噪点。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># morphologyEx</span></span><br><span class="line">tophat = cv2.morphologyEx(img, cv2.MORPH_TOPHAT, kernel) </span><br><span class="line"><span class="comment"># img - open</span></span><br><span class="line">tophat = img - cv2.morphologyEx(img, cv2.MORPH_OPEN, kernel)</span><br></pre></td></tr></table></figure><p><img src="/2021/08/OpenCV-Part2/tophat.jpg" alt="tophat"></p><h4 id="黑帽"><a href="#黑帽" class="headerlink" title="黑帽"></a>黑帽</h4><ul><li>黑帽 等价于 闭运算后的图像减去源图像。</li><li>作用：显示闭操作所填充的黑洞及裂缝。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># morphologyEx</span></span><br><span class="line">blackhat = cv2.morphologyEx(img, cv2.MORPH_BLACKHAT, kernel) </span><br><span class="line"><span class="comment"># close - img</span></span><br><span class="line">blackhat = cv2.morphologyEx(img, cv2.MORPH_CLOSE, kernel) - img</span><br></pre></td></tr></table></figure><p><img src="/2021/08/OpenCV-Part2/blackhat.png" alt="blackhat"></p>]]></content>
      
      
      <categories>
          
          <category> OpenCV </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>OpenCV-Part1</title>
      <link href="/2021/08/OpenCV-Part1/"/>
      <url>/2021/08/OpenCV-Part1/</url>
      
        <content type="html"><![CDATA[<h1 id="OpenCV-Part1——基础操作"><a href="#OpenCV-Part1——基础操作" class="headerlink" title="OpenCV-Part1——基础操作"></a>OpenCV-Part1——基础操作</h1><p>[TOC]</p><h2 id="OpenCV"><a href="#OpenCV" class="headerlink" title="OpenCV"></a>OpenCV</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><ul><li>OpenCV是计算机视觉中经典的专用库。</li><li>OpenCV-Python为OpenCV提供了Python接口，使得使用者在Python中能够调用C/C++，在保证易读性和运行效率的前提下，实现所需的功能。</li><li>所有OpenCV数组结构都与Numpy数组相互转换，所以要使用OpenCV-Python编写优化的代码，必须先明白Numpy。</li><li>本笔记以OpenCV4为主，会有个别版本上的差异，可能的话会提供解决方案。</li></ul><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install opencv-python</span><br></pre></td></tr></table></figure><h2 id="GUI特性"><a href="#GUI特性" class="headerlink" title="GUI特性"></a>GUI特性</h2><h3 id="图像入门"><a href="#图像入门" class="headerlink" title="图像入门"></a>图像入门</h3><h4 id="读取图像"><a href="#读取图像" class="headerlink" title="读取图像"></a>读取图像</h4><ul><li>鉴于兼容windows和linux，文件路径请用<code>/</code>分隔</li><li>文件路径中不得出现中文</li><li>可以选择图像加载方式：<ul><li>cv2.IMREAD_COLOR：默认加载彩色图像。任何图像的透明度都会被忽视。</li><li>cv2.IMREAD_GRAYSCALE：以灰度模式加载图像。</li><li>cv2.IMREAD_UNCHANGED：加载图像，包括alpha通道。</li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">img = cv2.imread(<span class="string">&quot;validation/origin/circle/4101035072410.jpg&quot;</span>, cv2.IMREAD_COLOR)</span><br></pre></td></tr></table></figure><h4 id="显示图像"><a href="#显示图像" class="headerlink" title="显示图像"></a>显示图像</h4><ul><li>图像窗口名称参数不建议使用中文</li><li>如果创建同名窗口两次，则第二张图片会替换前一张图片</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cv2.imshow(<span class="string">&quot;img&quot;</span>, img)</span><br></pre></td></tr></table></figure><h4 id="等待事件"><a href="#等待事件" class="headerlink" title="等待事件"></a>等待事件</h4><ul><li>如果想要暂停并显示图片，必须使用<code>cv2.waitKey(0)</code>，不能用<code>input</code>替代</li><li>可以选择等待时间参数：<ul><li>非零：单位为毫秒，期间如果按下键，则忽略剩余时间、直接运行</li><li>0：无限期地等待一次敲击键</li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cv2.waitKey(<span class="number">0</span>)</span><br></pre></td></tr></table></figure><ul><li>返回参数为keyCode，通过此可以设置检测特定的按键</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> cv2.waitKey(<span class="number">1000</span>) != <span class="built_in">ord</span>(<span class="string">&quot;q&quot;</span>):</span><br><span class="line">    cv2.imshow(<span class="string">&quot;img&quot;</span>, img)</span><br></pre></td></tr></table></figure><h4 id="销毁窗口"><a href="#销毁窗口" class="headerlink" title="销毁窗口"></a>销毁窗口</h4><ul><li>cv2.destroyAllWindows()：会销毁创建的所有窗口</li><li>cv2.destroyWindow()：销毁特定窗口</li></ul><h4 id="创建窗口"><a href="#创建窗口" class="headerlink" title="创建窗口"></a>创建窗口</h4><ul><li>手动创建窗口，并指定窗口是否可以调整大小<ul><li>cv2.WINDOW_AUTOSIZE：默认，按照图像大小固定窗口大小</li><li>cv2.WINDOW_NORMAL：可以自动调整大小，对于大分辨率图像的查看有帮助</li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cv2.namedWindow(<span class="string">&#x27;image&#x27;</span>, cv2.WINDOW_NORMAL)</span><br></pre></td></tr></table></figure><h4 id="写入图像"><a href="#写入图像" class="headerlink" title="写入图像"></a>写入图像</h4><ul><li>同样路径不得出现中文，否则无输出</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cv2.imwrite(<span class="string">&quot;test.jpg&quot;</span>, img)</span><br></pre></td></tr></table></figure><h4 id="OpenCV与其他库"><a href="#OpenCV与其他库" class="headerlink" title="OpenCV与其他库"></a>OpenCV与其他库</h4><h5 id="OpenCV与Matplotlib互转"><a href="#OpenCV与Matplotlib互转" class="headerlink" title="OpenCV与Matplotlib互转"></a>OpenCV与Matplotlib互转</h5><ul><li>OpenCV加载的彩色图像处于BGR模式，但是Matplotlib以RGB模式显示。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">from</span> matplotlib <span class="keyword">import</span> pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">img = cv2.imread(<span class="string">&quot;validation/origin/circle/4101035072410.jpg&quot;</span>)</span><br><span class="line">img = img[:, :, ::-<span class="number">1</span>]</span><br><span class="line">plt.imshow(img)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><h5 id="PIL-Image转换成OpenCV"><a href="#PIL-Image转换成OpenCV" class="headerlink" title="PIL.Image转换成OpenCV"></a>PIL.Image转换成OpenCV</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"><span class="keyword">import</span> numpy</span><br><span class="line"></span><br><span class="line">image = Image.<span class="built_in">open</span>(<span class="string">&quot;test.jpg&quot;</span>)</span><br><span class="line">image.show()</span><br><span class="line">img = cv2.cvtColor(numpy.asarray(image), cv2.COLOR_RGB2BGR)</span><br><span class="line">cv2.imshow(<span class="string">&quot;img&quot;</span>, img)</span><br><span class="line">cv2.waitKey(<span class="number">0</span>)</span><br></pre></td></tr></table></figure><h5 id="OpenCV转换成PIL-Image"><a href="#OpenCV转换成PIL-Image" class="headerlink" title="OpenCV转换成PIL.Image"></a>OpenCV转换成PIL.Image</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"></span><br><span class="line">img = cv2.imread(<span class="string">&quot;test.jpg&quot;</span>)</span><br><span class="line">cv2.imshow(<span class="string">&quot;img&quot;</span>, img)</span><br><span class="line">image = Image.fromarray(cv2.cvtColor(img, cv2.COLOR_BGR2RGB))</span><br><span class="line">image.show()</span><br><span class="line">cv2.waitKey(<span class="number">0</span>)</span><br></pre></td></tr></table></figure><h3 id="视频入门"><a href="#视频入门" class="headerlink" title="视频入门"></a>视频入门</h3><h4 id="读取摄像头视频"><a href="#读取摄像头视频" class="headerlink" title="读取摄像头视频"></a>读取摄像头视频</h4><ul><li>需要创建一个 VideoCapture 对象。它的参数可以是设备索引或视频文件的名称。</li><li><code>cap.read()</code>：返回是否正确读取帧。可以通过检查此返回值来判断是否到达视频的结尾。</li><li><code>cap.isOpened()</code>：返回是否初始化捕获。否则，使用<code>cap.open()</code>打开它。</li><li>当打开视频文件时，播放速度会不受限制，最好是从fps属性动态计算每帧之间相隔的时间，作为参数传入<code>cv2.waitKey()</code></li><li>使用视频捕获必须确保安装了正确的 ffmpeg 或 gstreamer 版本。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"></span><br><span class="line">cap = cv2.VideoCapture(<span class="number">0</span>)</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> cap.isOpened():</span><br><span class="line">    exit(<span class="string">&quot;Cannot open camera&quot;</span>)</span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    ret, frame = cap.read()  <span class="comment"># 逐帧读取</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> ret:  <span class="comment"># 如果成功读取帧，ret为True</span></span><br><span class="line">        print(<span class="string">&quot;Can&#x27;t receive frame (stream end?). Exiting ...&quot;</span>)</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    cv2.imshow(<span class="string">&#x27;frame&#x27;</span>, frame)  <span class="comment"># 显示当前帧</span></span><br><span class="line">    <span class="keyword">if</span> cv2.waitKey(<span class="number">1</span>) == <span class="built_in">ord</span>(<span class="string">&#x27;q&#x27;</span>):</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">cap.release()  <span class="comment"># 完成所有操作后，释放捕获器</span></span><br><span class="line">cv2.destroyAllWindows()</span><br></pre></td></tr></table></figure><h4 id="视频属性"><a href="#视频属性" class="headerlink" title="视频属性"></a>视频属性</h4><h5 id="属性方法"><a href="#属性方法" class="headerlink" title="属性方法"></a>属性方法</h5><ul><li><code>cap.get(propId)</code>：查看视频的属性。</li><li><code>cap.set(propId，value)</code>：修改视频的属性。</li><li>cap画布的长宽上下限似乎和摄像头本身有关。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">cap = cv2.VideoCapture(<span class="number">0</span>)</span><br><span class="line">print(cap.get(cv2.CAP_PROP_FRAME_WIDTH), cap.get(cv2.CAP_PROP_FRAME_HEIGHT))</span><br><span class="line">cap.<span class="built_in">set</span>(cv2.CAP_PROP_FRAME_WIDTH, cap.get(cv2.CAP_PROP_FRAME_WIDTH) * <span class="number">2</span>)</span><br><span class="line">print(cap.get(cv2.CAP_PROP_FRAME_WIDTH), cap.get(cv2.CAP_PROP_FRAME_HEIGHT))</span><br><span class="line">cap.<span class="built_in">set</span>(cv2.CAP_PROP_FRAME_WIDTH, cap.get(cv2.CAP_PROP_FRAME_WIDTH) * <span class="number">0.1</span>)</span><br><span class="line">print(cap.get(cv2.CAP_PROP_FRAME_WIDTH), cap.get(cv2.CAP_PROP_FRAME_HEIGHT))</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">640.0 480.0</span></span><br><span class="line"><span class="string">1280.0 720.0</span></span><br><span class="line"><span class="string">320.0 240.0</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure><h5 id="propId对应表"><a href="#propId对应表" class="headerlink" title="propId对应表"></a>propId对应表</h5><table><thead><tr><th>propid</th><th>属性</th><th>视频流属性</th></tr></thead><tbody><tr><td>0</td><td>CV_CAP_PROP_POS_MSEC</td><td>视频文件以毫秒为单位的当前位置或视频捕获时间戳（就是说你这个位置是视频当中的第几秒第几毫秒）</td></tr><tr><td>1</td><td>CV_CAP_PROP_POS_FRAMES</td><td>基于索引的帧解码/捕获（就是说你现在的位置是视频的第几帧位置）</td></tr><tr><td>2</td><td>CV_CAP_PROP_POS_AVI_RATIO</td><td>视频文件的相对位置:0 -电影,开始1 -电影结束（就是说输出0表示视频刚开始，输出1表示视频结束了）</td></tr><tr><td>3</td><td>CV_CAP_PROP_FRAME_WIDTH</td><td>视频流画面的宽度</td></tr><tr><td>4</td><td>CV_CAP_PROP_FRAME_HEIGHT</td><td>视频流画面的长度</td></tr><tr><td>5</td><td>CV_CAP_PROP_FPS</td><td>视频流的帧频</td></tr><tr><td>6</td><td>CV_CAP_PROP_FOURCC</td><td>编辑器的四字符编码</td></tr><tr><td>7</td><td>CV_CAP_PROP_FRAME_COUNT</td><td>视屏文件的帧数</td></tr><tr><td>8</td><td>CV_CAP_PROP_FORMAT</td><td>Format of the Mat objects returned by retrieve()</td></tr><tr><td>9</td><td>CV_CAP_PROP_MODE</td><td>Backend-specific value indicating the current capture mode</td></tr><tr><td>10</td><td>CV_CAP_PROP_BRIGHTNESS</td><td>Brightness of the image (only for cameras)摄像机图像的亮度(只有摄像头才可以)</td></tr><tr><td>11</td><td>CV_CAP_PROP_CONTRAST</td><td>Contrast of the image (only for cameras).摄像机图像的对比度(只有摄像头才可以)</td></tr><tr><td>12</td><td>CV_CAP_PROP_SATURATION</td><td>Saturation of the image (only for cameras)摄像机图像的饱和度(只有摄像头才可以)</td></tr><tr><td>13</td><td>CV_CAP_PROP_HUE</td><td>图片的色调(只有摄像头才可以)</td></tr><tr><td>14</td><td>CV_CAP_PROP_GAIN</td><td>Gain of the image(只有摄像头才可以)</td></tr><tr><td>15</td><td>CV_CAP_PROP_EXPOSURE</td><td>Exposure 曝光(只有摄像头才可以)</td></tr><tr><td>16</td><td>CV_CAP_PROP_CONVERT_RGB</td><td>布尔值指示是否应该转换为RGB图</td></tr><tr><td>17</td><td>CV_CAP_PROP_WHITE_BALANCE_U</td><td>The U value of the whitebalance setting (note: only supported by DC1394 v 2.x backend currently)</td></tr><tr><td>18</td><td>CV_CAP_PROP_WHITE_BALANCE_V</td><td>The V value of the whitebalance setting (note: only supported by DC1394 v 2.x backend currently)</td></tr><tr><td>19</td><td>CV_CAP_PROP_RECTIFICATION</td><td>Rectification flag for stereo cameras (note: only supported by DC1394 v 2.x backend currently)</td></tr><tr><td>20</td><td>CV_CAP_PROP_ISO_SPEED</td><td>The ISO speed of the camera (note: only supported by DC1394 v 2.x backend currently)</td></tr><tr><td>21</td><td>CV_CAP_PROP_BUFFERSIZE</td><td>Amount of frames stored in internal buffer memory (note: only supported by DC1394 v 2.x backend currently)</td></tr></tbody></table><h4 id="保存视频"><a href="#保存视频" class="headerlink" title="保存视频"></a>保存视频</h4><ul><li>需要创建一个 VideoWriter 对象。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"></span><br><span class="line">cap = cv2.VideoCapture(<span class="number">0</span>)</span><br><span class="line"><span class="comment"># 定义编解码器并创建VideoWriter对象</span></span><br><span class="line">fourcc = cv2.VideoWriter_fourcc(*<span class="string">&#x27;XVID&#x27;</span>)</span><br><span class="line">writer = cv2.VideoWriter(<span class="string">&#x27;output.avi&#x27;</span>, fourcc, <span class="number">30.0</span>, (<span class="number">640</span>, <span class="number">480</span>))</span><br><span class="line"><span class="keyword">while</span> cap.isOpened():</span><br><span class="line">    ret, frame = cap.read()</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> ret:</span><br><span class="line">        print(<span class="string">&quot;Can&#x27;t receive frame (stream end?). Exiting ...&quot;</span>)</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    <span class="comment"># 写翻转的框架</span></span><br><span class="line">    writer.write(frame)</span><br><span class="line">    cv2.imshow(<span class="string">&#x27;frame&#x27;</span>, frame)</span><br><span class="line">    <span class="keyword">if</span> cv2.waitKey(<span class="number">1</span>) == <span class="built_in">ord</span>(<span class="string">&#x27;q&#x27;</span>):</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"><span class="comment"># 完成工作后释放所有内容</span></span><br><span class="line">cap.release()</span><br><span class="line">writer.release()</span><br><span class="line">cv2.destroyAllWindows()</span><br></pre></td></tr></table></figure><h3 id="绘图功能"><a href="#绘图功能" class="headerlink" title="绘图功能"></a>绘图功能</h3><ul><li>color：对于bgr颜色要传递元组，例如<code>(255,0,0)</code>，传递int则视为b值。</li><li>thickness：线条厚度，默认为<code>1</code>；对于封闭图形，<code>-1</code>位填充。</li><li>lineType：线的类型，默认为为8连接线；对于曲线可以设置为抗锯齿线<code>cv2.LINE_AA</code>。</li></ul><h4 id="画线"><a href="#画线" class="headerlink" title="画线"></a>画线</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cv2.line(img, pt1=(<span class="number">0</span>, <span class="number">0</span>), pt2=(<span class="number">511</span>, <span class="number">511</span>), color=(<span class="number">255</span>, <span class="number">0</span>, <span class="number">0</span>), thickness=<span class="number">5</span>, lineType=cv2.LINE_AA)</span><br></pre></td></tr></table></figure><h4 id="画矩形"><a href="#画矩形" class="headerlink" title="画矩形"></a>画矩形</h4><ul><li>两个点分别为左上角和右下角</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cv2.rectangle(img, pt1=(<span class="number">384</span>, <span class="number">0</span>), pt2=(<span class="number">510</span>, <span class="number">128</span>), color=(<span class="number">0</span>, <span class="number">255</span>, <span class="number">0</span>), thickness=<span class="number">3</span>)</span><br></pre></td></tr></table></figure><h4 id="画圆"><a href="#画圆" class="headerlink" title="画圆"></a>画圆</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cv2.circle(img, center=(<span class="number">447</span>, <span class="number">63</span>), radius=<span class="number">63</span>, color=(<span class="number">0</span>, <span class="number">0</span>, <span class="number">255</span>), thickness=-<span class="number">1</span>)</span><br></pre></td></tr></table></figure><h4 id="画椭圆"><a href="#画椭圆" class="headerlink" title="画椭圆"></a>画椭圆</h4><ul><li>angle：按顺时针偏转的角度</li><li>startAngle、endAngle：按顺时针计算区间。[0, 0]则无椭圆，[0, 360]则完整椭圆。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cv2.ellipse(img, center=(<span class="number">256</span>, <span class="number">256</span>), axes=(<span class="number">100</span>, <span class="number">50</span>), angle=<span class="number">0</span>, startAngle=<span class="number">0</span>, endAngle=<span class="number">180</span>, color=<span class="number">255</span>, thickness=-<span class="number">1</span>)</span><br></pre></td></tr></table></figure><p><img src="/2021/08/OpenCV-Part1/image-20210816075339107.png" alt="image-20210816075339107"></p><h4 id="画多边形"><a href="#画多边形" class="headerlink" title="画多边形"></a>画多边形</h4><ul><li>必须转换成int32</li><li>注意pts要用列表装饰</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pts = [[<span class="number">10</span>, <span class="number">5</span>], [<span class="number">20</span>, <span class="number">30</span>], [<span class="number">70</span>, <span class="number">20</span>], [<span class="number">50</span>, <span class="number">10</span>]]</span><br><span class="line">pts = np.array(pts).astype(np.int32).reshape((-<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>))</span><br><span class="line">cv2.polylines(img, pts=[pts], isClosed=<span class="literal">True</span>, color=(<span class="number">0</span>, <span class="number">255</span>, <span class="number">255</span>), thickness=<span class="number">3</span>)</span><br></pre></td></tr></table></figure><h4 id="添加文本"><a href="#添加文本" class="headerlink" title="添加文本"></a>添加文本</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cv2.putText(img, text=<span class="string">&#x27;OpenCV&#x27;</span>, org=(<span class="number">10</span>, <span class="number">350</span>), fontFace=cv2.FONT_HERSHEY_SIMPLEX, </span><br><span class="line">            fontScale=<span class="number">1</span>, color=(<span class="number">255</span>, <span class="number">255</span>, <span class="number">255</span>), thickness=<span class="number">2</span>, lineType=cv2.LINE_AA)</span><br></pre></td></tr></table></figure><h3 id="鼠标作为画笔"><a href="#鼠标作为画笔" class="headerlink" title="鼠标作为画笔"></a>鼠标作为画笔</h3><h4 id="可用事件与回调函数"><a href="#可用事件与回调函数" class="headerlink" title="可用事件与回调函数"></a>可用事件与回调函数</h4><ul><li>列出所有可用事件</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2 <span class="keyword">as</span> cv</span><br><span class="line">events = [i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">dir</span>(cv) <span class="keyword">if</span> <span class="string">&#x27;EVENT&#x27;</span> <span class="keyword">in</span> i]</span><br><span class="line">print( events )</span><br></pre></td></tr></table></figure><ul><li><code>setMouseCallback</code>：鼠标回调函数，参数是固定的，会自动与窗口绑定</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"></span><br><span class="line">drawing = <span class="literal">False</span>  <span class="comment"># 如果按下鼠标，则为真</span></span><br><span class="line">mode = <span class="literal">True</span>  <span class="comment"># 如果为真，绘制矩形。按 m 键可以切换到曲线</span></span><br><span class="line">ix, iy = -<span class="number">1</span>, -<span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 鼠标回调函数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">draw_circle</span>(<span class="params">event, x, y, flags, param</span>):</span></span><br><span class="line">    <span class="keyword">global</span> ix, iy, drawing, mode</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> event == cv2.EVENT_LBUTTONDOWN:</span><br><span class="line">        drawing = <span class="literal">True</span></span><br><span class="line">        ix, iy = x, y</span><br><span class="line">    <span class="keyword">elif</span> event == cv2.EVENT_MOUSEMOVE:</span><br><span class="line">        <span class="keyword">if</span> drawing:</span><br><span class="line">            <span class="keyword">if</span> mode:</span><br><span class="line">                cv2.rectangle(img, (ix, iy), (x, y), (<span class="number">0</span>, <span class="number">255</span>, <span class="number">0</span>), -<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                cv2.circle(img, (x, y), <span class="number">5</span>, (<span class="number">0</span>, <span class="number">0</span>, <span class="number">255</span>), -<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">elif</span> event == cv2.EVENT_LBUTTONUP:</span><br><span class="line">        drawing = <span class="literal">False</span></span><br><span class="line">        <span class="keyword">if</span> mode:</span><br><span class="line">            cv2.rectangle(img, (ix, iy), (x, y), (<span class="number">0</span>, <span class="number">255</span>, <span class="number">0</span>), -<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            cv2.circle(img, (x, y), <span class="number">5</span>, (<span class="number">0</span>, <span class="number">0</span>, <span class="number">255</span>), -<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="comment"># 创建一个黑色的图像，一个窗口，并绑定到窗口的功能</span></span><br><span class="line">    img = np.zeros((<span class="number">512</span>, <span class="number">512</span>, <span class="number">3</span>), np.uint8)</span><br><span class="line">    cv2.namedWindow(<span class="string">&#x27;image&#x27;</span>)</span><br><span class="line">    cv2.setMouseCallback(<span class="string">&#x27;image&#x27;</span>, draw_circle)</span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">not</span> cv2.waitKey(<span class="number">25</span>) &amp; <span class="number">0xFF</span> == <span class="number">27</span>:</span><br><span class="line">        cv2.imshow(<span class="string">&#x27;image&#x27;</span>, img)</span><br><span class="line">    cv2.destroyAllWindows()</span><br></pre></td></tr></table></figure><h2 id="核心操作"><a href="#核心操作" class="headerlink" title="核心操作"></a>核心操作</h2><h3 id="图像基本操作"><a href="#图像基本操作" class="headerlink" title="图像基本操作"></a>图像基本操作</h3><h4 id="访问和修改像素值"><a href="#访问和修改像素值" class="headerlink" title="访问和修改像素值"></a>访问和修改像素值</h4><ul><li><p>对于 BGR 图像，它返回一个由蓝色、绿色和红色值组成的数组。对于灰度图像，只返回相应的灰度。</p></li><li><p>通常会使用numpy切片图像，不建议使用numpy索引来访问、修改单个像素值。</p></li><li><p>访问、修改单个像素值时，使用方法<code>item()</code>和<code>itemset())</code>被认为更好，但是它们始终操作单通道。</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">print(img[<span class="number">100</span>, <span class="number">100</span>])  <span class="comment"># 彩色图片返回 [蓝, 绿, 红]</span></span><br><span class="line"><span class="comment"># [157, 166, 200]</span></span><br><span class="line">print(img[<span class="number">100</span>, <span class="number">100</span>, <span class="number">0</span>])  <span class="comment"># 仅访问蓝色像素</span></span><br><span class="line"><span class="comment"># 157</span></span><br><span class="line">img[<span class="number">100</span>, <span class="number">100</span>] = [<span class="number">157</span>, <span class="number">166</span>, <span class="number">200</span>]  <span class="comment"># 修改像素</span></span><br><span class="line">img[<span class="number">100</span>, <span class="number">100</span>, <span class="number">0</span>] = <span class="number">157</span>  <span class="comment"># 仅修改蓝色像素</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 访问 RED 值</span></span><br><span class="line">print(img.item(<span class="number">10</span>, <span class="number">10</span>, <span class="number">2</span>))  <span class="comment"># 59</span></span><br><span class="line"><span class="comment"># 修改 RED 值</span></span><br><span class="line">img.itemset((<span class="number">10</span>, <span class="number">10</span>, <span class="number">2</span>), <span class="number">100</span>)  </span><br></pre></td></tr></table></figure><h4 id="访问图像属性"><a href="#访问图像属性" class="headerlink" title="访问图像属性"></a>访问图像属性</h4><ul><li><code>img.shape</code>：图像的形状<code>[行数(高height), 列数(宽width), [蓝, 绿, 红]]</code></li><li>如果图像是灰度的，则返回的元组仅包含行数和列数</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">print(img.shape)</span><br><span class="line">(<span class="number">342</span>, <span class="number">548</span>, <span class="number">3</span>)</span><br></pre></td></tr></table></figure><ul><li><code>img.size</code>：像素总数</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">print(img.size)</span><br><span class="line"><span class="comment"># 562248</span></span><br></pre></td></tr></table></figure><ul><li><code>img.dtype</code>：图像数据类型</li><li>img.dtype在调试时非常重要，因为OpenCV-Python代码中的大量错误是由无效的数据类型引起的。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">print( img.dtype )</span><br><span class="line"><span class="comment"># uint8</span></span><br></pre></td></tr></table></figure><h4 id="图像区域切片"><a href="#图像区域切片" class="headerlink" title="图像区域切片"></a>图像区域切片</h4><ul><li>注意，索引顺序是<code>[行数, 列数, 通道]</code>，即<code>[高, 宽, [蓝, 绿, 红]]</code></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将球复制到图像中的另一个区域</span></span><br><span class="line">ball = img[<span class="number">280</span>:<span class="number">340</span>, <span class="number">330</span>:<span class="number">390</span>]</span><br><span class="line">img[<span class="number">273</span>:<span class="number">333</span>, <span class="number">100</span>:<span class="number">160</span>] = ball </span><br></pre></td></tr></table></figure><h4 id="拆分和合并图像通道"><a href="#拆分和合并图像通道" class="headerlink" title="拆分和合并图像通道"></a>拆分和合并图像通道</h4><ul><li><code>cv2.split(img)</code>：切分三个通道</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># split()比较耗时，可以考虑使用np切片</span></span><br><span class="line">b, g, r = cv2.split(img)</span><br><span class="line">b, g, r = img [:, :]</span><br><span class="line"><span class="comment"># 只获取蓝通道，使用numpy更快</span></span><br><span class="line">b = img [:, :, <span class="number">0</span>]</span><br><span class="line"><span class="comment"># 将所有红色像素都设置为零，则无需拆分通道</span></span><br><span class="line">img [:, :, <span class="number">2</span>] = <span class="number">0</span></span><br></pre></td></tr></table></figure><ul><li><code>cv2.merge((b,g,r))</code>：合并三个通道</li><li>可以将灰度图扩展成三通道</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">img = cv2.merge((b,g,r))</span><br></pre></td></tr></table></figure><h4 id="填充边框"><a href="#填充边框" class="headerlink" title="填充边框"></a>填充边框</h4><ul><li><code>cv2.copyMakeBorder()</code>：padding经常使用。<ul><li><code>src</code>：输入图像</li><li><code>top</code>，<code>bottom</code>，<code>left</code>，<code>right</code>：边界宽度</li><li><code>borderType</code>：定义要添加哪种边框的标志。它可以是以下类型：<ul><li><code>cv2.BORDER_CONSTANT</code>：添加恒定的彩色边框。该值应作为下一个参数给出。</li><li><code>cv2.BORDER_REFLECT</code> 或 <code>cv2.BORDER_REFLECT_101</code>或 <code>cv2.BORDER_DEFAULT</code>：边框将是边框元素的镜像</li><li><code>cv2.BORDER_REPLICATE</code>：重复边界最后一个元素被复制</li><li><code>cv2.BORDER_WRAP</code>：将图片复制平铺</li></ul></li><li><code>value</code>：边框的颜色，如果边框类型为 cv.BORDER_CONSTANT</li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">img = cv2.imread(<span class="string">&quot;test.jpg&quot;</span>, cv2.IMREAD_COLOR)</span><br><span class="line"><span class="comment"># 在右边接一张原图</span></span><br><span class="line">img = cv2.copyMakeBorder(img, top=<span class="number">0</span>, bottom=<span class="number">0</span>, left=<span class="number">0</span>, right=img.shape[<span class="number">1</span>], borderType=cv2.BORDER_WRAP)</span><br><span class="line"><span class="comment"># 底部加一条绿边</span></span><br><span class="line">img = cv2.copyMakeBorder(img, top=<span class="number">0</span>, bottom=<span class="number">10</span>, left=<span class="number">0</span>, right=<span class="number">0</span>, borderType=cv2.BORDER_CONSTANT, value=[<span class="number">0</span>, <span class="number">255</span>, <span class="number">0</span>])</span><br><span class="line">cv2.imshow(<span class="string">&quot;img&quot;</span>, img)</span><br><span class="line">cv2.waitKey(<span class="number">0</span>)</span><br></pre></td></tr></table></figure><p><img src="/2021/08/OpenCV-Part1/image-20210818232157400.png" alt="image-20210818232157400"></p><h3 id="图像加法"><a href="#图像加法" class="headerlink" title="图像加法"></a>图像加法</h3><ul><li>可以通过OpenCV函数<code>cv2.add()</code>或numpy操作<code>res = img1 + img2</code>相加两个图像。</li><li>OpenCV加法和Numpy加法之间有区别。OpenCV加法是饱和运算，而Numpy加法是模运算。</li><li>两个图像需要有相同的深度和类型，或者第二个图像可以只是一个标量值。</li><li>一般会使用OpenCV的方法，或直接使用图像融合。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">x = np.uint8([<span class="number">250</span>])</span><br><span class="line">y = np.uint8([<span class="number">10</span>])</span><br><span class="line">print(cv2.add(x, y))  <span class="comment"># 250 + 10 = 260 =&gt; 255</span></span><br><span class="line"><span class="comment"># [[255]]</span></span><br><span class="line">print( x + y )  <span class="comment"># (250 + 10) % 256 = 260 % 256 = 4</span></span><br><span class="line"><span class="comment"># [4]</span></span><br></pre></td></tr></table></figure><h4 id="图像反色"><a href="#图像反色" class="headerlink" title="图像反色"></a>图像反色</h4><ul><li>千万不要用循环！</li><li>需要在指定区域反色的话，就加入mask参数。比如，将黑色背景反转为白色背景。</li><li>因为两者范围都在0-255，所以直接做np减法。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">img = np.full(img.shape, (<span class="number">255</span>, <span class="number">255</span>, <span class="number">255</span>), dtype=np.uint8) - img</span><br></pre></td></tr></table></figure><h3 id="图像融合"><a href="#图像融合" class="headerlink" title="图像融合"></a>图像融合</h3><ul><li><code>cv2.addWeighted()</code>：对图像赋予不同的权重，并相加。</li><li>通过动态更改两张的图像权重<code>0-&gt;1, 1-&gt;0</code>，可以完成一个图像到另一个图像之间的视觉过渡。</li><li>并不要求两者权重相加为1</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">img1 = cv.imread(<span class="string">&#x27;ml.png&#x27;</span>)</span><br><span class="line">img2 = cv.imread(<span class="string">&#x27;opencv-logo.png&#x27;</span>)</span><br><span class="line">dst = cv.addWeighted(img1, <span class="number">0.7</span>, img2, <span class="number">0.3</span>, <span class="number">0</span>)</span><br><span class="line">cv.imshow(<span class="string">&#x27;dst&#x27;</span>, dst)</span><br><span class="line">cv.waitKey(<span class="number">0</span>)</span><br></pre></td></tr></table></figure><p> <img src="http://qiniu.aihubs.net/blending.jpg" alt="img"></p><h3 id="按位运算"><a href="#按位运算" class="headerlink" title="按位运算"></a>按位运算</h3><ul><li><p> <code>AND</code>、 <code>OR</code>、<code>NOT</code>、<code>XOR</code> ：用于提取图像的任意部分、定义和处理非矩形ROI。</p></li><li><p>当需要将A图像覆盖在B图像上时。如果将两个图像相加，则改变颜色。如果将两个图像混合，则获得透明效果。</p><p>如果是矩形区域，则可以像上一章一样使用ROI切片，重置区域数值。A图像不是矩形。因此，可以进行按位操作。、</p></li><li><p>mask需要为np.uint8类型，否则<code>.astype(np.uint8)</code>；mask需要通道数为1，否则<code>mask = mask[:, :, 0]</code></p></li><li><p>前景图片大小不能超过背景，否则会报错</p></li><li><p>mask的含义是：仅mask中的白色区域会进行运算，其他部分全部为黑色</p></li><li><p>最后相加时，要确保相加部分是 0 + img_mask = img_mask；否则依然会出现融合效果</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 加载两张图片</span></span><br><span class="line">img1 = cv2.imread(<span class="string">&#x27;test.jpg&#x27;</span>)</span><br><span class="line">img2 = cv2.imread(<span class="string">&#x27;test2.png&#x27;</span>)</span><br><span class="line">img2 = cv2.resize(img2, (img2.shape[<span class="number">0</span>]//<span class="number">2</span>, img2.shape[<span class="number">1</span>]//<span class="number">2</span>))  <span class="comment"># 控制前景大小</span></span><br><span class="line"><span class="comment"># 想把logo放在左上角，所以在左上角创建了ROI</span></span><br><span class="line">rows, cols, channels = img2.shape</span><br><span class="line">roi = img1[<span class="number">0</span>:rows, <span class="number">0</span>:cols]</span><br><span class="line"><span class="comment"># 现在创建logo的掩码，并同时创建其相反掩码</span></span><br><span class="line">mask_inv = extract_red(img2, cfg=&#123;<span class="string">&quot;debug&quot;</span>: <span class="literal">False</span>&#125;)[:, :, <span class="number">0</span>]  <span class="comment"># mask为单通道</span></span><br><span class="line">mask = cv2.bitwise_not(mask_inv)</span><br><span class="line"><span class="comment"># 现在将ROI中logo的区域涂黑</span></span><br><span class="line">print(roi.dtype, mask_inv.dtype, roi.shape, mask_inv.shape)  <span class="comment"># uint8 uint8 (533, 548, 3) (533, 548)</span></span><br><span class="line">img1_bg = cv2.bitwise_and(roi, roi, mask=mask_inv)</span><br><span class="line"><span class="comment"># 仅从logo图像中提取logo区域</span></span><br><span class="line">img2_fg = cv2.bitwise_and(img2, img2, mask=mask)  <span class="comment"># 仅白色区域会从原图中保留，其他部分全部为黑色</span></span><br><span class="line"><span class="comment"># 将logo放入ROI并修改主图像</span></span><br><span class="line">dst = cv2.add(img1_bg, img2_fg)  <span class="comment"># 要确保相加部分是 0 + img_mask = img_mask；否则依然会出现融合效果</span></span><br><span class="line">img1[<span class="number">0</span>:rows, <span class="number">0</span>:cols] = dst</span><br><span class="line">cv2.imshow(<span class="string">&#x27;res&#x27;</span>, img1)</span><br><span class="line">cv2.waitKey(<span class="number">0</span>)</span><br></pre></td></tr></table></figure><img src="/2021/08/OpenCV-Part1/image-20210819112755771.png" alt="image-20210819112755771"><h2 id="性能衡量和提升技术"><a href="#性能衡量和提升技术" class="headerlink" title="性能衡量和提升技术"></a>性能衡量和提升技术</h2><h3 id="使用OpenCV衡量性能"><a href="#使用OpenCV衡量性能" class="headerlink" title="使用OpenCV衡量性能"></a>使用OpenCV衡量性能</h3><p><code>cv2.getTickCount</code>：函数返回从参考事件（如打开机器的那一刻）到调用此函数那一刻之间的时钟周期数。</p><p><code>cv2.getTickFrequency</code>：函数返回时钟周期的频率或每秒的时钟周期数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">e1 = cv2.getTickCount()</span><br><span class="line"><span class="comment"># 你的执行代码</span></span><br><span class="line">e2 = cv2.getTickCount()</span><br><span class="line">time = (e2 - e1) / cv.getTickFrequency()  <span class="comment"># 计算两次执行函数的时间差</span></span><br></pre></td></tr></table></figure><blockquote><p>使用time.time()函数，然后取两次相差，与上述方法是等价的。</p></blockquote><h3 id="OpenCV中的默认优化"><a href="#OpenCV中的默认优化" class="headerlink" title="OpenCV中的默认优化"></a>OpenCV中的默认优化</h3><p>许多OpenCV函数都默认使用了SSE2、AVX等进行优化。可以使用 <code>cv2.Useoptimized</code> 检查是否启用和 <code>cv2.Setuseoptimized</code> 以启用/禁用优化。</p><h3 id="性能优化技术"><a href="#性能优化技术" class="headerlink" title="性能优化技术"></a>性能优化技术</h3><p>首先尝试以一种简单的方式实现算法。然后，分析、找到瓶颈，再进行优化。</p><p>使用下面的技巧来充分利用 Python 和 Numpy 的最大性能。</p><ol><li>Python标量操作比Numpy标量操作快。因此，对于包含一两个元素的运算，Python标量比Numpy数组好。当数组大小稍大时，Numpy会占优势。</li><li>通常，OpenCV函数比Numpy函数要快。因此，对于相同的操作，首选OpenCV功能。但是，可能会有例外，尤其是当Numpy处理视图而不是副本时。</li><li>尽量避免在Python中使用循环，尤其是双/三重循环等。</li><li>由于Numpy和OpenCV已针对向量运算进行了优化，因此将算法/代码向量化到最大程度。</li><li>利用缓存一致性。</li><li>除非需要，否则切勿创建数组的副本。尝试改用视图。数组复制是一项昂贵的操作。</li></ol><p>执行了所有这些操作后，如果仍然很慢，或者不可避免地需要使用大循环，请使用Cython等其他库来使其更快。</p><h3 id="其他资源"><a href="#其他资源" class="headerlink" title="其他资源"></a>其他资源</h3><ol><li>Python优化技术：<a href="http://wiki.python.org/moin/PythonSpeed/PerformanceTips">http://wiki.python.org/moin/PythonSpeed/PerformanceTips</a></li><li>Scipy讲义- 高级Numpy：<a href="http://scipy-lectures.github.io/advanced/advanced_numpy/index.html#advanced-numpy">http://scipy-lectures.github.io/advanced/advanced_numpy/index.html#advanced-numpy</a></li><li>IPython中的时序和性能分析：<a href="http://pynash.org/2013/03/06/timing-and-profiling/">http://pynash.org/2013/03/06/timing-and-profiling/</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> OpenCV </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Django-完结目录</title>
      <link href="/2021/08/Django-%E5%AE%8C%E7%BB%93%E7%9B%AE%E5%BD%95/"/>
      <url>/2021/08/Django-%E5%AE%8C%E7%BB%93%E7%9B%AE%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<h1 id="Django——完结目录"><a href="#Django——完结目录" class="headerlink" title="Django——完结目录"></a>Django——完结目录</h1><p>教程视频传送门：</p><ol><li><a href="https://www.bilibili.com/video/BV1QE41147hU?p=704">老男孩Python全栈开发29期全套(2020年3月开班)-同步更新</a></li></ol><p>推荐资源：</p><ol><li><a href="https://www.runoob.com/django/django-tutorial.html">菜鸟教程</a></li><li><a href="https://code.ziqiangxuetang.com/django/django-tutorial.html">自强学堂</a></li><li><a href="https://www.cnblogs.com/Dominic-Ji/p/10881214.html">https://www.cnblogs.com/Dominic-Ji/p/10881214.html</a></li></ol><p>讲的非常好，但是重点偏向全栈，需要再模仿、学习前后端分离的项目架构。</p><p>讲法偏向循序渐进，做笔记的时候顺序不建议按照课程来，需要二次整理。</p><p>==DRF框架==：<a href="https://www.bilibili.com/video/BV1Sz4y1o7E8?p=3">https://www.bilibili.com/video/BV1Sz4y1o7E8?p=3</a></p><table><thead><tr><th align="center"><a href="/2021/08/Django-Part1/">Django-Part1——基础操作</a></th></tr></thead><tbody><tr><td align="center"><strong><a href="/2021/08/Django-Part2/">Django-Part2——路由层</a></strong></td></tr><tr><td align="center"><strong><a href="/2021/08/Django-Part3/">Django-Part3——视图层</a></strong></td></tr><tr><td align="center"><strong><a href="/2021/08/Django-Part4/">Django-Part4——模型层</a></strong></td></tr><tr><td align="center"><strong><a href="/2021/08/Django-Part5/">Django-Part5——数据交互</a></strong></td></tr><tr><td align="center"><a href="/2021/08/Django-Part6/"><strong>Django-Part6——中间件与Auth模块</strong></a></td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> Django </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Web </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Django-Part6</title>
      <link href="/2021/08/Django-Part6/"/>
      <url>/2021/08/Django-Part6/</url>
      
        <content type="html"><![CDATA[<h1 id="Django-Part6——中间件与Auth模块"><a href="#Django-Part6——中间件与Auth模块" class="headerlink" title="Django-Part6——中间件与Auth模块"></a>Django-Part6——中间件与Auth模块</h1><p>[TOC]</p><h2 id="Django中间件"><a href="#Django中间件" class="headerlink" title="Django中间件"></a>Django中间件</h2><h3 id="中间件简介"><a href="#中间件简介" class="headerlink" title="中间件简介"></a>中间件简介</h3><ul><li>django自带七个中间件，并且支持程序员自定义中间件</li><li>只要是涉及到全局相关的功能都可以使用中间件完成</li><li>全局用户身份、权限校验<ul><li>全局访问频率校验</li></ul></li><li>…</li><li>django中间件是django的门户<ul><li>请求需要先经过中间件才能到达django后端</li><li>响应也需要经过中间件才能发送出去</li></ul></li></ul><h3 id="自定义中间件"><a href="#自定义中间件" class="headerlink" title="自定义中间件"></a>自定义中间件</h3><ul><li><p>中间件可以在项目名或者应用名下任意名称的文件夹中定义</p></li><li><p>自定义中间件类必须继承于MiddlewareMixin类</p></li><li><p>需要将类的路径以字符串的形式注册到配置文件中才能生效</p></li><li><p>中间件将暴露五个可以自定义的方法，按需求重写</p><ul><li><p><code>process_request(self, request)</code>：</p><ol><li><p>请求来的时候需要经过每一个中间件里面的process_request方法</p></li><li><p>顺序是按照配置文件中注册的中间件从上往下的顺序依次执行</p></li><li><p>如果中间件里面没有定义该方法，则跳过</p></li><li><p>如果该方法返回了HttpResponse对象，则请求将不再继续往后执行，而是从同级别的process_reponse向上原路返回</p><p>flask中即使中途返回数据，但依然经过所有中间件</p></li></ol><p>process_request方法可以用来做全局相关的所有限制功能</p></li><li><p><code>process_response(self, request, response)</code>：</p><ol><li>响应走的时候需要经过每一个中间件里面的process_response方法</li><li>顺序是按照配置文件中注册了的中间件从下往上依次经过</li><li>如果中间件里面没有定义该方法，则跳过</li><li>该方法必须返回一个HttpResponse对象，默认返回的就是形参response</li></ol></li><li><p><code>process_view(self, request, view_func, view_args, view_kwargs)</code>：</p><ol><li>触发时间在路由匹配成功之后，执行视图函数之前</li><li>顺序是按照配置文件中注册的中间件从上往下的顺序依次执行</li></ol></li><li><p><code>process_template_response(self, request, response)</code>：</p><ol><li>返回的HttpResponse对象有render属性的时候才会触发</li><li>顺序是按照配置文件中注册了的中间件从下往上依次经过</li></ol></li><li><p><code>process_exception(self, request, exception)</code>：</p><ol><li>当视图函数中出现异常的情况下触发</li><li>顺序是按照配置文件中注册了的中间件从下往上依次经过</li></ol></li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.utils.deprecation <span class="keyword">import</span> MiddlewareMixin</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MD1</span>(<span class="params">MiddlewareMixin</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">process_request</span>(<span class="params">self, request</span>):</span></span><br><span class="line">        print(<span class="string">&quot;MD1里面的 process_request&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">process_response</span>(<span class="params">self, request, response</span>):</span></span><br><span class="line">        print(<span class="string">&quot;MD1里面的 process_response&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> response</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">process_view</span>(<span class="params">self, request, view_func, view_args, view_kwargs</span>):</span></span><br><span class="line">        print(<span class="string">&quot;-&quot;</span> * <span class="number">80</span>)</span><br><span class="line">        print(<span class="string">&quot;MD1 中的process_view&quot;</span>)</span><br><span class="line">        print(view_func, view_func.__name__)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">process_exception</span>(<span class="params">self, request, exception</span>):</span></span><br><span class="line">        print(exception)</span><br><span class="line">        print(<span class="string">&quot;MD1 中的process_exception&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> HttpResponse(<span class="built_in">str</span>(exception))</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">process_template_response</span>(<span class="params">self, request, response</span>):</span></span><br><span class="line">        print(<span class="string">&quot;MD1 中的process_template_response&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> response</span><br></pre></td></tr></table></figure><h3 id="csrf跨站请求伪造"><a href="#csrf跨站请求伪造" class="headerlink" title="csrf跨站请求伪造"></a>csrf跨站请求伪造</h3><h4 id="使用cookie完成csrf校验"><a href="#使用cookie完成csrf校验" class="headerlink" title="使用cookie完成csrf校验"></a>使用cookie完成csrf校验</h4><ul><li>为了确保请求来源是本服务器发送出去的</li><li>为每一次发出去的页面提供唯一标识，如果校验标识失败则直接拒绝(403 forbbiden)</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src=<span class="string">&quot;get请求url&quot;</span>&gt;&lt;/script&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Ajax CSRF in cookies start</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getCookie</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> cookieValue = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">document</span>.cookie &amp;&amp; <span class="built_in">document</span>.cookie !== <span class="string">&#x27;&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">var</span> cookies = <span class="built_in">document</span>.cookie.split(<span class="string">&#x27;;&#x27;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; cookies.length; i++) &#123;</span><br><span class="line">            <span class="keyword">var</span> cookie = jQuery.trim(cookies[i]);</span><br><span class="line">            <span class="comment">// Does this cookie string begin with the name we want?</span></span><br><span class="line">            <span class="keyword">if</span> (cookie.substring(<span class="number">0</span>, name.length + <span class="number">1</span>) === (name + <span class="string">&#x27;=&#x27;</span>)) &#123;</span><br><span class="line">                cookieValue = <span class="built_in">decodeURIComponent</span>(cookie.substring(name.length + <span class="number">1</span>));</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cookieValue;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> csrftoken = getCookie(<span class="string">&#x27;csrftoken&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">csrfSafeMethod</span>(<span class="params">method</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// these HTTP methods do not require CSRF protection</span></span><br><span class="line">  <span class="keyword">return</span> (<span class="regexp">/^(GET|HEAD|OPTIONS|TRACE)$/</span>.test(method));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$.ajaxSetup(&#123;</span><br><span class="line">  beforeSend: <span class="function"><span class="keyword">function</span> (<span class="params">xhr, settings</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!csrfSafeMethod(settings.type) &amp;&amp; !<span class="built_in">this</span>.crossDomain) &#123;</span><br><span class="line">      xhr.setRequestHeader(<span class="string">&quot;X-CSRFToken&quot;</span>, csrftoken);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// Ajax CSRF in cookies end</span></span><br></pre></td></tr></table></figure><ol><li>如果使用从cookie中取csrftoken的方式，需要确保cookie存在csrftoken值。</li><li> 如果你的视图渲染的HTML文件中没有包含 {% csrf_token %}，Django可能不会设置CSRFtoken的cookie。</li><li>这个时候需要使用ensure_csrf_cookie()装饰器强制设置Cookie。</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">django.views.decorators.csrf <span class="keyword">import</span> ensure_csrf_cookie</span><br><span class="line"> </span><br><span class="line"><span class="meta">@ensure_csrf_cookie</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">login</span>(<span class="params">request</span>):</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><h4 id="csrf相关装饰器"><a href="#csrf相关装饰器" class="headerlink" title="csrf相关装饰器"></a>csrf相关装饰器</h4><ul><li>@csrf_protect：需要校验</li><li>@csrf_exempt：忽视校验</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.views.decorators.csrf <span class="keyword">import</span> csrf_protect, csrf_exempt</span><br><span class="line"><span class="keyword">from</span> django.utils.decorators <span class="keyword">import</span> method_decorator</span><br><span class="line"></span><br><span class="line"><span class="comment"># @csrf_exempt</span></span><br><span class="line"><span class="comment"># @csrf_protect</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">transfer</span>(<span class="params">request</span>):</span></span><br><span class="line">    <span class="keyword">if</span> request.method == <span class="string">&#x27;POST&#x27;</span>:</span><br><span class="line">        username = request.POST.get(<span class="string">&#x27;username&#x27;</span>)</span><br><span class="line">        target_user = request.POST.get(<span class="string">&#x27;target_user&#x27;</span>)</span><br><span class="line">        money = request.POST.get(<span class="string">&#x27;money&#x27;</span>)</span><br><span class="line">        print(<span class="string">&#x27;%s给%s转了%s元&#x27;</span>%(username,target_user,money))</span><br><span class="line">    <span class="keyword">return</span> render(request,<span class="string">&#x27;transfer.html&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> django.views <span class="keyword">import</span> View</span><br><span class="line"></span><br><span class="line"><span class="comment"># @method_decorator(csrf_protect, name=&#x27;post&#x27;)  # 针对csrf_protect 第二种方式可以</span></span><br><span class="line"><span class="comment"># @method_decorator(csrf_exempt, name=&#x27;post&#x27;)  # 针对csrf_exempt 第二种方式不可以</span></span><br><span class="line"><span class="meta">@method_decorator(<span class="params">csrf_exempt, name=<span class="string">&#x27;dispatch&#x27;</span></span>)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyCsrfToken</span>(<span class="params">View</span>):</span></span><br><span class="line">    <span class="comment"># @method_decorator(csrf_protect)  # 针对csrf_protect 第三种方式可以</span></span><br><span class="line">    <span class="comment"># @method_decorator(csrf_exempt)  # 针对csrf_exempt 第三种方式可以</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dispatch</span>(<span class="params">self, request, *args, **kwargs</span>):</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>(MyCsrfToken, self).dispatch(request, *args, **kwargs)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span>(<span class="params">self,request</span>):</span></span><br><span class="line">        <span class="keyword">return</span> HttpResponse(<span class="string">&#x27;get&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># @method_decorator(csrf_protect)  # 针对csrf_protect 第一种方式可以</span></span><br><span class="line">    <span class="comment"># @method_decorator(csrf_exempt)  # 针对csrf_exempt 第一种方式不可以</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">post</span>(<span class="params">self,request</span>):</span></span><br><span class="line">        <span class="keyword">return</span> HttpResponse(<span class="string">&#x27;post&#x27;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="跨域请求"><a href="#跨域请求" class="headerlink" title="跨域请求"></a>跨域请求</h3><ul><li>对于前后端分离的报错：<code>has been blocked by CORS policy: NO &#39;Access-Control-Allow-Origin&#39; header is present on the reauested resource.</code></li></ul><h4 id="同源策略"><a href="#同源策略" class="headerlink" title="同源策略"></a>同源策略</h4><ul><li>浏览器的同源策略：浏览器发现ip或端口是不一样的，就会认为存在风险，会进行拦截。</li><li>推荐的方法是使用Nginx进行反向代理。</li></ul><h4 id="添加响应头解决跨域"><a href="#添加响应头解决跨域" class="headerlink" title="添加响应头解决跨域"></a>添加响应头解决跨域</h4><ul><li>解决思路就是告诉浏览器：不进行拦截。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -&gt; app01/middlewares/Mycors.py</span></span><br><span class="line"><span class="keyword">from</span> django.utils.deprecation <span class="keyword">import</span> MiddlewareMixin</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyCors</span>(<span class="params">MiddlewareMixin</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">process_response</span>(<span class="params">self, request, response</span>):</span></span><br><span class="line">        response[<span class="string">&quot;Access-Control-Allow-Origin&quot;</span>] = <span class="string">&quot;*&quot;</span></span><br><span class="line">        <span class="keyword">if</span> request.method == <span class="string">&quot;OPTIONS&quot;</span>:</span><br><span class="line">            response[<span class="string">&quot;Access-Control-Allow-Headers&quot;</span>] = <span class="string">&quot;Content-Type&quot;</span></span><br><span class="line">            response[<span class="string">&quot;Access-Control-Allow-Methods&quot;</span>] = <span class="string">&quot;DELETE, PUT, POST&quot;</span></span><br><span class="line">        <span class="keyword">return</span> response</span><br><span class="line"></span><br><span class="line"><span class="comment"># -&gt; DjangoProject/settings.py</span></span><br><span class="line">MIDDLEWARE = [</span><br><span class="line">    ...</span><br><span class="line">    <span class="string">&#x27;app01.middlewares.Mycors.MyCors&#x27;</span>,</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h2 id="配置文件与反射"><a href="#配置文件与反射" class="headerlink" title="配置文件与反射"></a>配置文件与反射</h2><h3 id="importlib模块"><a href="#importlib模块" class="headerlink" title="importlib模块"></a>importlib模块</h3><p>使用importlib，以字符串形式导入模块</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> myfile <span class="keyword">import</span> b</span><br><span class="line">print(b)</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> importlib</span><br><span class="line">res = <span class="string">&#x27;myfile.b&#x27;</span></span><br><span class="line">ret = importlib.import_module(res)  <span class="comment"># 该方法最小只能到py文件名</span></span><br><span class="line">print(ret)</span><br></pre></td></tr></table></figure><h3 id="实例展示"><a href="#实例展示" class="headerlink" title="实例展示"></a>实例展示</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> settings</span><br><span class="line"><span class="keyword">import</span> importlib</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">send_all</span>(<span class="params">content</span>):</span></span><br><span class="line">    <span class="keyword">for</span> path_str <span class="keyword">in</span> settings.NOTIFY_LIST:  <span class="comment"># &#x27;notify.email.Email&#x27;</span></span><br><span class="line">        module_path,class_name = path_str.rsplit(<span class="string">&#x27;.&#x27;</span>, maxsplit=<span class="number">1</span>)</span><br><span class="line">        <span class="comment"># module_path = &#x27;notify.email&#x27;  class_name = &#x27;Email&#x27;</span></span><br><span class="line">        <span class="comment"># 1 利用字符串导入模块</span></span><br><span class="line">        module = importlib.import_module(module_path)  <span class="comment"># from notify import email</span></span><br><span class="line">        <span class="comment"># 2 利用反射获取类名</span></span><br><span class="line">        cls = <span class="built_in">getattr</span>(module, class_name)  <span class="comment"># Email、QQ、Wechat</span></span><br><span class="line">        <span class="comment"># 3 生成类的对象</span></span><br><span class="line">        obj = cls()</span><br><span class="line">        <span class="comment"># 4 利用鸭子类型直接调用send方法</span></span><br><span class="line">        obj.send(content)</span><br></pre></td></tr></table></figure><h2 id="Auth模块"><a href="#Auth模块" class="headerlink" title="Auth模块"></a>Auth模块</h2><blockquote><p> 使用auth模块要用就用全套</p></blockquote><p>Django的admin路由对应的就是就是auth_user表，必须是管理员用户才能进入。</p><p>创建超级用户(管理员)：<code>python3 manage.py createsuperuser</code></p><h3 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h3><ul><li><code>auth.authenticate(request, username, password)</code>：根据用户名在表中查询加密后的密码，并将请求中的密码加密比对是否正确。返回用户对象，不匹配则返回None</li><li><code>auth.login(request, user_obj)</code>：保存用户状态，建立session。执行该方法后，可以在任何地方通过<code>request.user</code>获取到当前登陆的用户对象</li><li><code>request.user</code>：</li><li><code>request.user.is_authenticated()</code>：判断当前用户是否登陆</li><li><code>@login_required</code>：校验登录装饰器<ul><li>局部配置：<code>@login_required(login_url=&#39;/login/&#39;)</code></li><li>全局配置：<code>settings.py -&gt; LOGIN_URL = &#39;/login/&#39;</code></li></ul></li><li><code>request.user.check_password(old_password)</code>：将请求中的密码加密，并比对原密码</li><li><code>request.user.set_password(new_password)</code>：修改用户对象的密码</li><li><code>request.user.save()</code>：将修改密码后的用户对象写入数据库</li><li><code>auth.logout(request)</code> ：注销，清除双方session</li><li><code>User.objects.create_user(username=username,password=password)</code>：注册用户。注意不能使用<code>create</code>方法，该方法不对密码进行加密。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">login</span>(<span class="params">request</span>):</span></span><br><span class="line">    <span class="keyword">if</span> request.method == <span class="string">&#x27;POST&#x27;</span>:</span><br><span class="line">        username = request.POST.get(<span class="string">&#x27;username&#x27;</span>)</span><br><span class="line">        password = request.POST.get(<span class="string">&#x27;password&#x27;</span>)</span><br><span class="line">        user_obj = auth.authenticate(request, username=username, password=password)</span><br><span class="line">        print(user_obj)  <span class="comment"># 用户对象，不存在则返回None</span></span><br><span class="line">        print(user_obj.username)  <span class="comment"># jason</span></span><br><span class="line">        print(user_obj.password)  <span class="comment"># pbkdf2_sha256$36000$zeNDf8CkZj7y$b+e/CjzZoAnbBIpvUWgz25ybBDqDzRTmYAHPytxqRYQ=</span></span><br><span class="line">        <span class="comment"># 判断当前用户是否存在</span></span><br><span class="line">        <span class="keyword">if</span> user_obj:</span><br><span class="line">            auth.login(request, user_obj)  <span class="comment"># 保持用户状态，类似于request.session[key] = user_obj</span></span><br><span class="line">            <span class="comment"># 执行该方法后，可以在任何地方通过request.user获取到当前登陆的用户对象</span></span><br><span class="line">            <span class="keyword">return</span> redirect(<span class="string">&#x27;/home/&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> render(request, <span class="string">&#x27;login.html&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@login_required(<span class="params">login_url=<span class="string">&#x27;/login/&#x27;</span></span>)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">home</span>(<span class="params">request</span>):</span></span><br><span class="line">    print(request.user)  <span class="comment"># 在django_session中判断用户是否登陆，没有登录则为AnonymousUser匿名用户</span></span><br><span class="line">    print(request.user.is_authenticated())</span><br><span class="line">    <span class="keyword">return</span> HttpResponse(<span class="string">&#x27;home&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@login_required</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">set_password</span>(<span class="params">request</span>):</span></span><br><span class="line">    <span class="keyword">if</span> request.method == <span class="string">&#x27;POST&#x27;</span>:</span><br><span class="line">        old_password = request.POST.get(<span class="string">&#x27;old_password&#x27;</span>)</span><br><span class="line">        new_password = request.POST.get(<span class="string">&#x27;new_password&#x27;</span>)</span><br><span class="line">        confirm_password = request.POST.get(<span class="string">&#x27;confirm_password&#x27;</span>)</span><br><span class="line">        <span class="comment"># 校验两次密码是否一致、老密码是否正确</span></span><br><span class="line">        <span class="keyword">if</span> new_password == confirm_password <span class="keyword">and</span> request.user.check_password(old_password):</span><br><span class="line">            request.user.set_password(new_password)  <span class="comment"># 仅仅是在修改对象的密码属性</span></span><br><span class="line">            request.user.save()  <span class="comment"># 这一步才是真正的操作数据库</span></span><br><span class="line">        <span class="keyword">return</span> redirect(<span class="string">&#x27;/login/&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> render(request, <span class="string">&#x27;set_password.html&#x27;</span>, <span class="built_in">locals</span>())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@login_required</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">logout</span>(<span class="params">request</span>):</span></span><br><span class="line">    auth.logout(request)  <span class="comment"># 类似于request.session.flush()</span></span><br><span class="line">    <span class="keyword">return</span> redirect(<span class="string">&#x27;/login/&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">register</span>(<span class="params">request</span>):</span></span><br><span class="line">    <span class="keyword">if</span> request.method == <span class="string">&#x27;POST&#x27;</span>:</span><br><span class="line">        username = request.POST.get(<span class="string">&#x27;username&#x27;</span>)</span><br><span class="line">        password = request.POST.get(<span class="string">&#x27;password&#x27;</span>)</span><br><span class="line">        User.objects.create_user(username=username, password=password)  <span class="comment"># 创建普通用户</span></span><br><span class="line">    <span class="keyword">return</span> render(request, <span class="string">&#x27;register.html&#x27;</span>)</span><br></pre></td></tr></table></figure><h3 id="扩展auth-user表"><a href="#扩展auth-user表" class="headerlink" title="扩展auth_user表"></a>扩展auth_user表</h3><ul><li>面向对象继承，自由增加字段，对象可以直接访问字段</li><li>如果继承了<code>AbstractUser</code>，那么在执行数据库迁移命令的时候<code>auth_user</code>表就不会再创建出来了，而是替换成定义的子类</li><li>auth模块的功能还是照常使用</li><li>前提：<ol><li>在继承之前没有执行过数据库迁移命令、auth_user没有被创建</li><li>继承的类里面不要覆盖<code>AbstractUser</code>里面的字段名，只扩展额外字段</li><li>需要在配置文件中添加<code>AUTH_USER_MODEL = &#39;app01.UserInfo&#39;</code></li></ol></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserInfo</span>(<span class="params">AbstractUser</span>):</span></span><br><span class="line">    phone = models.BigIntegerField()</span><br></pre></td></tr></table></figure><h2 id="BBS实战"><a href="#BBS实战" class="headerlink" title="BBS实战"></a>BBS实战</h2><h3 id="表设计"><a href="#表设计" class="headerlink" title="表设计"></a>表设计</h3><ol><li><p>用户表(AbstractUser)</p><ul><li>phone：电话号码</li><li>avatar：用户头像</li><li>create_time：创建时间</li><li>一对一：个人站点表</li></ul></li><li><p>个人站点表</p><ul><li>site_name：站点名称</li><li>site_title：站点标题</li><li>site_theme：站点样式</li></ul></li><li><p>文章标签表</p><ul><li>name：标签名</li><li>一对多：个人站点</li></ul></li><li><p>文章分类表</p><ul><li>name：分类名</li><li>一对多：个人站点</li></ul></li><li><p>文章表</p><ul><li><p>title：文章标题</p></li><li><p>desc：文章简介</p></li><li><p>content：文章内容</p></li><li><p>create_time：发布时间</p><p>数据库字段设计优化：虽然下述的三个字段可以从其他表里面跨表查询计算得出，但是频繁跨表效率</p></li><li><p>up_num：点赞数</p></li><li><p>down_num：点踩数</p></li><li><p>comment_num：评论数</p></li><li><p>一对多个人站点</p></li><li><p>多对多文章标签</p></li><li><p>一对多文章分类</p></li></ul></li><li><p>点赞点踩表（记录哪个用户给哪篇文章点了赞还是点了踩）</p><ul><li>user：ForeignKey(to=”User”)</li><li>article：ForeignKey(to=”Article”)    </li><li>is_up：BooleanField()</li></ul></li><li><p>文章评论表</p><ul><li><p>user：ForeignKey(to=”User”)                </p></li><li><p>article：ForeignKey(to=”Article”)</p></li><li><p>content：CharField()</p></li><li><p>comment_time：DateField()</p></li><li><p>parent：ForeignKey(to=”self/Comment”,null=True)</p><p>根评论子评论，评论当前发布的内容，根评论与子评论是一对多的关系</p></li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> Django </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Django-Part5</title>
      <link href="/2021/08/Django-Part5/"/>
      <url>/2021/08/Django-Part5/</url>
      
        <content type="html"><![CDATA[<h1 id="Django-Part5——数据交互"><a href="#Django-Part5——数据交互" class="headerlink" title="Django-Part5——数据交互"></a>Django-Part5——数据交互</h1><p>[TOC]</p><h2 id="前后端交互"><a href="#前后端交互" class="headerlink" title="前后端交互"></a>前后端交互</h2><h3 id="发送请求的方式"><a href="#发送请求的方式" class="headerlink" title="发送请求的方式"></a>发送请求的方式</h3><ol><li>浏览器地址栏直接输入url回车 (GET)</li><li>a标签href属性 (GET)</li><li>form表单 (GET/POST)</li><li>ajax (GET/POST)    </li></ol><h2 id="Ajax"><a href="#Ajax" class="headerlink" title="Ajax"></a>Ajax</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><ul><li><p>Ajax 最大的优点是异步提交，局部刷新。</p></li><li><p>AJAX 不是新的编程语言，而是一种使用现有标准的新方法。</p></li><li><p>Ajax 在这里只学习jQuery封装之后的版本，而不是原生的。所以在前端页面使用ajax的时候需要确保导入了jQuery。</p></li><li><p>并不只有jQuery能够实现ajax，其他的框架也可以，原理是一样的。</p></li></ul><p>demo：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">href</span>=<span class="string">&quot;https://cdn.bootcss.com/twitter-bootstrap/3.4.1/css/bootstrap.min.css&quot;</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://cdn.bootcss.com/jquery/3.3.1/jquery.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://cdn.bootcss.com/twitter-bootstrap/3.4.1/js/bootstrap.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">id</span>=<span class="string">&quot;i1&quot;</span>&gt;</span> + <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">id</span>=<span class="string">&quot;i2&quot;</span>&gt;</span> = <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">id</span>=<span class="string">&quot;i3&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">&quot;btn&quot;</span>&gt;</span>点我<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    $(<span class="string">&#x27;#btn&#x27;</span>).click(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        $.ajax(&#123;</span></span><br><span class="line"><span class="javascript">            <span class="comment">// 1. 指定朝哪个地址发请求</span></span></span><br><span class="line"><span class="javascript">            url: <span class="string">&quot;&quot;</span>,  <span class="comment">// 不写就是朝当前页面发</span></span></span><br><span class="line"><span class="javascript">            <span class="comment">// 2. 请求方式</span></span></span><br><span class="line"><span class="javascript">            type: <span class="string">&#x27;post&#x27;</span>, <span class="comment">// 不指定，默认为get，都是小写</span></span></span><br><span class="line"><span class="javascript">            <span class="comment">// 3. 数据，post和get携带参数都是用data表示</span></span></span><br><span class="line">            &#123;#data:&#123;&#x27;username&#x27;: &#x27;jason&#x27;, &#x27;password&#x27;: 123&#125;,#&#125;</span><br><span class="line">            data: &#123;</span><br><span class="line"><span class="javascript">                <span class="string">&#x27;i1&#x27;</span>: $(<span class="string">&#x27;#i1&#x27;</span>).val(),</span></span><br><span class="line"><span class="javascript">                <span class="string">&#x27;i2&#x27;</span>: $(<span class="string">&#x27;#i2&#x27;</span>).val()</span></span><br><span class="line">            &#125;,</span><br><span class="line"><span class="javascript">            <span class="comment">// 4. 回调函数，异步回调机制，在接收到数据时自动触发</span></span></span><br><span class="line"><span class="javascript">            success: <span class="function"><span class="keyword">function</span> (<span class="params">args</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">                &#123;#alert(args)  <span class="comment">// 即使返回页面也全都由ajax来接收#&#125;</span></span></span><br><span class="line"><span class="javascript">                $(<span class="string">&quot;#i3&quot;</span>).val(args.i3)  <span class="comment">// 通过DOM操作动态渲染到第三个input里面</span></span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">ab_ajax</span>(<span class="params">request</span>):</span></span><br><span class="line">    <span class="keyword">if</span> request.method == <span class="string">&#x27;POST&#x27;</span>:</span><br><span class="line">        print(request.POST)</span><br><span class="line">        i1 = <span class="built_in">int</span>(request.POST.get(<span class="string">&#x27;i1&#x27;</span>))</span><br><span class="line">        i2 = <span class="built_in">int</span>(request.POST.get(<span class="string">&#x27;i2&#x27;</span>))</span><br><span class="line">        <span class="keyword">return</span> JsonResponse(&#123;<span class="string">&quot;i3&quot;</span>: i1 + i2&#125;)  <span class="comment"># 无法用 HttpResponse + json.dumps 代替</span></span><br><span class="line">    <span class="keyword">return</span> render(request, <span class="string">&#x27;index.html&#x27;</span>)</span><br></pre></td></tr></table></figure><ul><li>针对后端如果是用HttpResponse返回的数据，回调函数不会自动反序列化<ul><li>解决方式1：在前端JSON.parse()</li><li>解决方式2：在ajax里面配置一个参数</li></ul></li><li>如果后端直接用的是JsonResponse返回的数据，回调函数会自动反序列化</li></ul><h3 id="编码格式-Content-Type"><a href="#编码格式-Content-Type" class="headerlink" title="编码格式(Content-Type)"></a>编码格式(Content-Type)</h3><p>前后端传输数据的编码格式：</p><ol><li>urlencoded（例如：username=jason&amp;password=123）</li><li>formdata</li><li>json</li><li>……</li></ol><p>在form表单中：</p><ul><li>默认的数据编码格式是urlencoded，推荐都写成formdata。</li><li>django针对符合urlencoded编码格式的数据都解析封装到request.POST中。</li><li>编码格式设定为formdata时，普通的键值对还是解析到request.POST中，文件将解析到request.FILES中（文件在urlencoded格式下只会解析文件名）。</li><li>form表单是没有办法发送json格式数据的。</li></ul><p>Ajax：</p><ul><li>默认的编码格式也是urlencoded</li><li>对符合urlencoded编码格式的数据都解析封装到request.POST中</li></ul><h3 id="Ajax发送json"><a href="#Ajax发送json" class="headerlink" title="Ajax发送json"></a>Ajax发送json</h3><p>前后端传输数据的时候一定要确保编码格式跟数据真正的格式是一致的。</p><p>ajax传输json格式数据注意点：</p><ol><li>contentType参数指定成:application/json</li><li>数据是原始的json格式数据</li><li>django后端不会封装处理json格式数据，需要自己在request.body获取二进制数据并处理</li></ol><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    $(<span class="string">&#x27;#d1&#x27;</span>).click(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        $.ajax(&#123;</span></span><br><span class="line"><span class="javascript">            url: <span class="string">&quot;&quot;</span>,</span></span><br><span class="line"><span class="javascript">            type: <span class="string">&#x27;post&#x27;</span>,</span></span><br><span class="line"><span class="javascript">            data: <span class="built_in">JSON</span>.stringify(&#123;</span></span><br><span class="line"><span class="javascript">                <span class="string">&#x27;username&#x27;</span>: <span class="string">&#x27;jason&#x27;</span>,</span></span><br><span class="line"><span class="javascript">                <span class="string">&#x27;age&#x27;</span>: <span class="number">25</span></span></span><br><span class="line">            &#125;),</span><br><span class="line"><span class="javascript">            contentType: <span class="string">&#x27;application/json&#x27;</span>,</span></span><br><span class="line"><span class="javascript">            success: <span class="function"><span class="keyword">function</span> (<span class="params">args</span>) </span>&#123;&#125;</span></span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>request.is_ajax()：判断当前请求是否是ajax请求，返回布尔值</li><li>request.body：获取请求体，这里是未经处理的二进制数据</li><li>处理json文件：json.loads(request.body)</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">ab_ajax</span>(<span class="params">request</span>):</span></span><br><span class="line">    <span class="keyword">if</span> request.method == <span class="string">&#x27;POST&#x27;</span>:</span><br><span class="line">        print(request.is_ajax())  <span class="comment"># 判断当前请求是否是ajax请求</span></span><br><span class="line">        print(request.body)  <span class="comment"># 获取请求体</span></span><br><span class="line">        json_bytes = request.body</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 1. 手动处理二进制流</span></span><br><span class="line">        json_str = json_bytes.decode(<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">        json_dict = json.loads(json_str)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 2. json.loads如果传入二进制数据则自动解码再反序列化</span></span><br><span class="line">        json_dict = json.loads(json_bytes)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> JsonResponse(json_dict)</span><br><span class="line">    <span class="keyword">return</span> render(request, <span class="string">&#x27;index.html&#x27;</span>)</span><br></pre></td></tr></table></figure><h3 id="Ajax发送文件"><a href="#Ajax发送文件" class="headerlink" title="Ajax发送文件"></a>Ajax发送文件</h3><ol><li>ajax发送文件需要借助于js内置对象FormData</li><li>需要指定两个关键性的参数 contentType:false  processData:false</li><li>django能直接识别formdata对象，并将内部的普通键值对自动解析封装到request.POST中，文件数据自动解析封装到request.FILES中</li></ol><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="comment">// 点击按钮朝后端发送普通键值对和文件数据</span></span></span><br><span class="line"><span class="javascript">    $(<span class="string">&#x27;#d4&#x27;</span>).on(<span class="string">&#x27;click&#x27;</span>,<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="comment">// 1. 需要先利用FormData内置对象</span></span></span><br><span class="line"><span class="javascript">        <span class="keyword">let</span> formDateObj = <span class="keyword">new</span> FormData();</span></span><br><span class="line"><span class="javascript">        <span class="comment">// 2. 添加普通的键值对</span></span></span><br><span class="line"><span class="javascript">        formDateObj.append(<span class="string">&#x27;username&#x27;</span>,$(<span class="string">&#x27;#d1&#x27;</span>).val());</span></span><br><span class="line"><span class="javascript">        formDateObj.append(<span class="string">&#x27;password&#x27;</span>,$(<span class="string">&#x27;#d2&#x27;</span>).val());</span></span><br><span class="line"><span class="javascript">        <span class="comment">// 3. 添加文件对象</span></span></span><br><span class="line"><span class="javascript">        formDateObj.append(<span class="string">&#x27;myfile&#x27;</span>,$(<span class="string">&#x27;#d3&#x27;</span>)[<span class="number">0</span>].files[<span class="number">0</span>])</span></span><br><span class="line"><span class="javascript">        <span class="comment">// 4. 将对象基于ajax发送给后端</span></span></span><br><span class="line"><span class="javascript">        $.ajax(&#123;</span></span><br><span class="line"><span class="javascript">            url:<span class="string">&#x27;&#x27;</span>,</span></span><br><span class="line"><span class="javascript">            type:<span class="string">&#x27;post&#x27;</span>,</span></span><br><span class="line"><span class="javascript">            data:formDateObj,  <span class="comment">// 直接将对象放在data后面即可</span></span></span><br><span class="line"><span class="javascript">            <span class="comment">// ajax发送文件必须要指定的两个参数</span></span></span><br><span class="line"><span class="javascript">            contentType:<span class="literal">false</span>,  <span class="comment">// 不需使用任何编码 django后端能够自动识别formdata对象</span></span></span><br><span class="line"><span class="javascript">            processData:<span class="literal">false</span>,  <span class="comment">// 告诉你的浏览器不要对你的数据进行任何处理</span></span></span><br><span class="line"><span class="javascript">            success:<span class="function"><span class="keyword">function</span> (<span class="params">args</span>) </span>&#123;&#125;</span></span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">ab_file</span>(<span class="params">request</span>):</span></span><br><span class="line">    <span class="keyword">if</span> request.is_ajax():</span><br><span class="line">        <span class="keyword">if</span> request.method == <span class="string">&#x27;POST&#x27;</span>:</span><br><span class="line">            print(request.POST)</span><br><span class="line">            print(request.FILES)</span><br><span class="line">    <span class="keyword">return</span> render(request,<span class="string">&#x27;ab_file.html&#x27;</span>)</span><br></pre></td></tr></table></figure><h3 id="Django自带的序列化组件"><a href="#Django自带的序列化组件" class="headerlink" title="Django自带的序列化组件"></a>Django自带的序列化组件</h3><ul><li>使用<code>django.core.serializers.serialize(&#39;指定数据格式&#39;, 数据本体)</code>快速完成序列化</li><li>后续还有更多的序列化组件，例如：drf</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 需求:在前端获取后端用户表里面所有的数据，列表套字典</span></span><br><span class="line"><span class="keyword">from</span> django.http <span class="keyword">import</span> JsonResponse</span><br><span class="line"><span class="keyword">from</span> django.core <span class="keyword">import</span> serializers</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">ab_ser</span>(<span class="params">request</span>):</span></span><br><span class="line">    user_queryset = models.User.objects.<span class="built_in">all</span>()</span><br><span class="line">    <span class="comment"># user_list = []</span></span><br><span class="line">    <span class="comment"># for user_obj in user_queryset:</span></span><br><span class="line">    <span class="comment">#     tmp = &#123;</span></span><br><span class="line">    <span class="comment">#         &#x27;pk&#x27;:user_obj.pk,</span></span><br><span class="line">    <span class="comment">#         &#x27;username&#x27;:user_obj.username,</span></span><br><span class="line">    <span class="comment">#         &#x27;age&#x27;:user_obj.age,</span></span><br><span class="line">    <span class="comment">#         &#x27;gender&#x27;:user_obj.get_gender_display()</span></span><br><span class="line">    <span class="comment">#     &#125;</span></span><br><span class="line">    <span class="comment">#     user_list.append(tmp)</span></span><br><span class="line">    <span class="comment"># return JsonResponse(user_list, safe=False)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 序列化</span></span><br><span class="line">    res = serializers.serialize(<span class="string">&#x27;json&#x27;</span>, user_queryset)</span><br><span class="line">    <span class="keyword">return</span> HttpResponse(res)</span><br></pre></td></tr></table></figure><h3 id="Ajax结合SweetAlert"><a href="#Ajax结合SweetAlert" class="headerlink" title="Ajax结合SweetAlert"></a>Ajax结合SweetAlert</h3><ul><li>每个元素都可以自定义属性，可以用来传值</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    $(<span class="string">&#x27;.del&#x27;</span>).on(<span class="string">&#x27;click&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="comment">// 1. 先将当前标签对象存储起来</span></span></span><br><span class="line"><span class="javascript">        <span class="keyword">let</span> currentBtn = $(<span class="built_in">this</span>);</span></span><br><span class="line"><span class="javascript">        <span class="comment">// 2. 二次确认弹框</span></span></span><br><span class="line">        swal(&#123;</span><br><span class="line"><span class="javascript">            title: <span class="string">&quot;你确定要删吗?&quot;</span>,</span></span><br><span class="line"><span class="javascript">            text: <span class="string">&quot;你可要考虑清除哦，可能需要拎包跑路哦!&quot;</span>,</span></span><br><span class="line"><span class="javascript">            type: <span class="string">&quot;warning&quot;</span>,</span></span><br><span class="line"><span class="javascript">            showCancelButton: <span class="literal">true</span>,</span></span><br><span class="line"><span class="javascript">            confirmButtonClass: <span class="string">&quot;btn-danger&quot;</span>,</span></span><br><span class="line"><span class="javascript">            confirmButtonText: <span class="string">&quot;是的，老子就要删!&quot;</span>,</span></span><br><span class="line"><span class="javascript">            cancelButtonText: <span class="string">&quot;算了,算了!&quot;</span>,</span></span><br><span class="line"><span class="javascript">            closeOnConfirm: <span class="literal">false</span>,</span></span><br><span class="line"><span class="javascript">            closeOnCancel: <span class="literal">false</span>,</span></span><br><span class="line"><span class="javascript">            showLoaderOnConfirm: <span class="literal">true</span></span></span><br><span class="line"><span class="javascript">        &#125;, <span class="function"><span class="keyword">function</span> (<span class="params">isConfirm</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">            <span class="keyword">if</span> (isConfirm) &#123;</span></span><br><span class="line"><span class="javascript">                <span class="comment">// 3. 朝后端发送ajax请求删除数据，之后弹完成情况的提示框</span></span></span><br><span class="line"><span class="javascript">                $.ajax(&#123;</span></span><br><span class="line"><span class="javascript">                    url: <span class="string">&#x27;/delete/user/&#x27;</span>,  <span class="comment">// 传递主键值可以放在url中，也可以放在请求体里面</span></span></span><br><span class="line"><span class="javascript">                    type: <span class="string">&#x27;post&#x27;</span>,</span></span><br><span class="line"><span class="javascript">                    data: &#123;<span class="string">&#x27;delete_id&#x27;</span>: currentBtn.attr(<span class="string">&#x27;delete_id&#x27;</span>)&#125;,</span></span><br><span class="line"><span class="javascript">                    success: <span class="function"><span class="keyword">function</span> (<span class="params">args</span>) </span>&#123;  <span class="comment">// args = &#123;&#x27;code&#x27;: &#x27;&#x27;, &#x27;msg&#x27;: &#x27;&#x27;&#125;</span></span></span><br><span class="line"><span class="javascript">                        <span class="comment">// 4. 判断响应状态码，然后做不同的处理</span></span></span><br><span class="line"><span class="javascript">                        <span class="keyword">if</span> (args.code === <span class="number">1000</span>) &#123;</span></span><br><span class="line"><span class="javascript">                            swal(<span class="string">&quot;删了!&quot;</span>, args.msg, <span class="string">&quot;success&quot;</span>);</span></span><br><span class="line"><span class="javascript">                            <span class="comment">// (1) lowb版本 直接刷新当前页面</span></span></span><br><span class="line">                            &#123;#window.location.reload()#&#125;</span><br><span class="line"><span class="javascript">                            <span class="comment">// (2) 利用DOM操作 动态刷新</span></span></span><br><span class="line">                            currentBtn.parent().parent().remove()</span><br><span class="line"><span class="javascript">                        &#125; <span class="keyword">else</span> &#123;</span></span><br><span class="line"><span class="javascript">                            swal(<span class="string">&#x27;完了&#x27;</span>, <span class="string">&#x27;出现了位置的错误&#x27;</span>, <span class="string">&#x27;info&#x27;</span>)</span></span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;)</span><br><span class="line"><span class="javascript">            &#125; <span class="keyword">else</span> &#123;</span></span><br><span class="line"><span class="javascript">                swal(<span class="string">&quot;怂逼&quot;</span>, <span class="string">&quot;不要说我认识你&quot;</span>, <span class="string">&quot;error&quot;</span>);</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="forms组件"><a href="#forms组件" class="headerlink" title="forms组件"></a>forms组件</h2><p>forms组件能够完成的事情：</p><ol><li>渲染html代码</li><li>校验数据</li><li>展示提示信息</li></ol><p>数据校验前端可有可无，但是后端必须要有！</p><p>因为前端的校验是弱不禁风的，可以直接修改，或者利用爬虫绕过前端页面直接朝后端提交数据。</p><h3 id="定义forms组件"><a href="#定义forms组件" class="headerlink" title="定义forms组件"></a>定义forms组件</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django <span class="keyword">import</span> forms</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyForm</span>(<span class="params">forms.Form</span>):</span></span><br><span class="line">    <span class="comment"># username字符串类型最小3位最大8位</span></span><br><span class="line">    username = forms.CharField(min_length=<span class="number">3</span>, max_length=<span class="number">8</span>, label=<span class="string">&#x27;用户名&#x27;</span>)</span><br><span class="line">    <span class="comment"># password字符串类型最小3位最大8位</span></span><br><span class="line">    password = forms.CharField(min_length=<span class="number">3</span>, max_length=<span class="number">8</span>)</span><br><span class="line">    <span class="comment"># email字段必须符合邮箱格式  xxx@xx.com</span></span><br><span class="line">    email = forms.EmailField()</span><br></pre></td></tr></table></figure><h3 id="校验数据"><a href="#校验数据" class="headerlink" title="校验数据"></a>校验数据</h3><ul><li>可以直接在 python console 中测试</li><li>默认情况下数据可以多传但是绝不可能少传</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> app01 <span class="keyword">import</span> views</span><br><span class="line"><span class="comment"># 1 将带校验的数据组织成字典的形式传入即可</span></span><br><span class="line">form_obj = views.MyForm(&#123;<span class="string">&#x27;username&#x27;</span>:<span class="string">&#x27;jason&#x27;</span>,<span class="string">&#x27;password&#x27;</span>:<span class="string">&#x27;123&#x27;</span>,<span class="string">&#x27;email&#x27;</span>:<span class="string">&#x27;123&#x27;</span>&#125;)</span><br><span class="line"><span class="comment"># 2 判断数据是否合法：注意该方法只有在所有的数据全部合法的情况下才会返回True</span></span><br><span class="line">form_obj.is_valid()  <span class="comment"># False</span></span><br><span class="line"><span class="comment"># 3 查看所有校验通过的数据</span></span><br><span class="line">form_obj.cleaned_data <span class="comment"># &#123;&#x27;username&#x27;: &#x27;jason&#x27;, &#x27;password&#x27;: &#x27;123&#x27;&#125;</span></span><br><span class="line"><span class="comment"># 4 查看所有不符合校验规则以及不符合的原因</span></span><br><span class="line">form_obj.errors  <span class="comment"># &#123;&#x27;email&#x27;: [&#x27;Enter a valid email address.&#x27;]&#125;</span></span><br><span class="line"><span class="comment"># 5 只校验类中出现的字段，多传的字段直接忽略</span></span><br><span class="line">form_obj = views.MyForm(&#123;<span class="string">&#x27;username&#x27;</span>:<span class="string">&#x27;jason&#x27;</span>,<span class="string">&#x27;password&#x27;</span>:<span class="string">&#x27;123&#x27;</span>,<span class="string">&#x27;email&#x27;</span>:<span class="string">&#x27;123@qq.com&#x27;</span>,<span class="string">&#x27;hobby&#x27;</span>:<span class="string">&#x27;study&#x27;</span>&#125;)</span><br><span class="line">form_obj.is_valid()  <span class="comment"># True</span></span><br><span class="line"><span class="comment"># 6 默认情况下，类里面所有的字段都必须传值</span></span><br><span class="line">form_obj = views.MyForm(&#123;<span class="string">&#x27;username&#x27;</span>:<span class="string">&#x27;jason&#x27;</span>,<span class="string">&#x27;password&#x27;</span>:<span class="string">&#x27;123&#x27;</span>&#125;)</span><br><span class="line">form_obj.is_valid()  <span class="comment"># False</span></span><br></pre></td></tr></table></figure><h3 id="渲染标签"><a href="#渲染标签" class="headerlink" title="渲染标签"></a>渲染标签</h3><ul><li>forms组件只会自动渲染获取用户输入的标签(input select radio checkbox)，不能渲染提交按钮</li><li>设置form表单让浏览器不做校验<code>&lt;form action=&quot;&quot; method=&quot;post&quot; novalidate&gt;</code></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span>(<span class="params">request</span>):</span></span><br><span class="line">    <span class="comment"># 1. 先生成一个空对象</span></span><br><span class="line">    form_obj = MyForm()</span><br><span class="line">    <span class="keyword">if</span> request.method == <span class="string">&#x27;POST&#x27;</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        1. 多个字段的数据获取繁琐</span></span><br><span class="line"><span class="string">        2. 校验数据需要构造成字典的格式传入</span></span><br><span class="line"><span class="string">        3. request.POST就是一个字典</span></span><br><span class="line"><span class="string">        4. 对于提供多余的字段不在意</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="comment"># 3. 校验数据</span></span><br><span class="line">        form_obj = MyForm(request.POST)</span><br><span class="line">        <span class="comment"># 4. 判断数据是否合法</span></span><br><span class="line">        <span class="keyword">if</span> form_obj.is_valid():</span><br><span class="line">            <span class="comment"># 5. 合法，操作数据库存储数据</span></span><br><span class="line">            <span class="keyword">return</span> HttpResponse(<span class="string">&#x27;OK&#x27;</span>)</span><br><span class="line">        <span class="comment"># 5. 不合法，有错误。此时可以基于上一次结果进行修改</span></span><br><span class="line">    <span class="comment"># 2. 直接将该空对象传递给html页面</span></span><br><span class="line">    <span class="keyword">return</span> render(request, <span class="string">&#x27;index.html&#x27;</span>, <span class="built_in">locals</span>())</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>第一种渲染方式:代码书写极少，封装程度太高，不便于后续的扩展，一般情况下只在本地测试使用<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  &#123;&#123; form_obj.as_p &#125;&#125;</span><br><span class="line">  &#123;&#123; form_obj.as_ul &#125;&#125;</span><br><span class="line">  &#123;&#123; form_obj.as_table &#125;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>第二种渲染方式:可扩展性很强 但是需要书写的代码太多，一般情况下不用<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123; form_obj.username.label &#125;&#125;:&#123;&#123; form_obj.username &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123; form_obj.password.label &#125;&#125;:&#123;&#123; form_obj.password &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123; form_obj.email.label &#125;&#125;:&#123;&#123; form_obj.email &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>第三种渲染方式(推荐使用):代码书写简单 并且扩展性也高<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  &#123;% for form in form_obj %&#125;</span><br><span class="line">      <span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">          &#123;&#123; form.label &#125;&#125;:&#123;&#123; form &#125;&#125;</span><br><span class="line">          <span class="tag">&lt;<span class="name">span</span> <span class="attr">style</span>=<span class="string">&quot;color: red&quot;</span>&gt;</span>&#123;&#123; form.errors.0 &#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  &#123;% endfor %&#125;</span><br></pre></td></tr></table></figure><h3 id="自定义错误信息"><a href="#自定义错误信息" class="headerlink" title="自定义错误信息"></a>自定义错误信息</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyForm</span>(<span class="params">forms.Form</span>):</span></span><br><span class="line">    <span class="comment"># username字符串类型最小3位最大8位</span></span><br><span class="line">    username = forms.CharField(min_length=<span class="number">3</span>, max_length=<span class="number">8</span>, label=<span class="string">&#x27;用户名&#x27;</span>,</span><br><span class="line">                               error_messages=&#123;</span><br><span class="line">                                   <span class="string">&#x27;min_length&#x27;</span>: <span class="string">&#x27;用户名最少3位&#x27;</span>,</span><br><span class="line">                                   <span class="string">&#x27;max_length&#x27;</span>: <span class="string">&#x27;用户名最大8位&#x27;</span>,</span><br><span class="line">                                   <span class="string">&#x27;required&#x27;</span>: <span class="string">&quot;用户名不能为空&quot;</span></span><br><span class="line">                               &#125;)</span><br><span class="line">    <span class="comment"># password字符串类型最小3位最大8位</span></span><br><span class="line">    password = forms.CharField(min_length=<span class="number">3</span>, max_length=<span class="number">8</span>, label=<span class="string">&#x27;密码&#x27;</span>,</span><br><span class="line">                               error_messages=&#123;</span><br><span class="line">                                   <span class="string">&#x27;min_length&#x27;</span>: <span class="string">&#x27;密码最少3位&#x27;</span>,</span><br><span class="line">                                   <span class="string">&#x27;max_length&#x27;</span>: <span class="string">&#x27;密码最大8位&#x27;</span>,</span><br><span class="line">                                   <span class="string">&#x27;required&#x27;</span>: <span class="string">&quot;密码不能为空&quot;</span></span><br><span class="line">                               &#125;)</span><br><span class="line">    <span class="comment"># email字段必须符合邮箱格式  xxx@xx.com</span></span><br><span class="line">    email = forms.EmailField(label=<span class="string">&#x27;邮箱&#x27;</span>,</span><br><span class="line">                             error_messages=&#123;</span><br><span class="line">                                 <span class="string">&#x27;invalid&#x27;</span>: <span class="string">&#x27;邮箱格式不正确&#x27;</span>,</span><br><span class="line">                                 <span class="string">&#x27;required&#x27;</span>: <span class="string">&quot;邮箱不能为空&quot;</span></span><br><span class="line">                             &#125;)</span><br></pre></td></tr></table></figure><h3 id="钩子函数-HOOK"><a href="#钩子函数-HOOK" class="headerlink" title="钩子函数(HOOK)"></a>钩子函数(HOOK)</h3><ul><li>钩子函数将书写在Form类中，能够让我们自定义校验规则</li><li>在forms组件中有两类钩子<ol><li>局部钩子：给单个字段增加校验规则</li><li>全局钩子：给多个字段增加校验规则</li></ol></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyForm</span>(<span class="params">forms.Form</span>):</span></span><br><span class="line">    ......</span><br><span class="line">    <span class="comment"># 局部钩子</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">clean_username</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="comment"># 获取用户名</span></span><br><span class="line">        username = self.cleaned_data.get(<span class="string">&#x27;username&#x27;</span>)</span><br><span class="line">        <span class="keyword">if</span> <span class="string">&#x27;666&#x27;</span> <span class="keyword">in</span> username:</span><br><span class="line">            <span class="comment"># 1. 校验用户名中不能含有666，添加错误信息</span></span><br><span class="line">            self.add_error(<span class="string">&#x27;username&#x27;</span>, <span class="string">&#x27;光喊666是不行滴～&#x27;</span>)</span><br><span class="line">        <span class="comment"># 将钩子函数钩去出来得特定数据放回去</span></span><br><span class="line">        <span class="keyword">return</span> username</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 全局钩子</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">clean</span>(<span class="params">self</span>):</span></span><br><span class="line">        password = self.cleaned_data.get(<span class="string">&#x27;password&#x27;</span>)</span><br><span class="line">        confirm_password = self.cleaned_data.get(<span class="string">&#x27;confirm_password&#x27;</span>)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> confirm_password == password:</span><br><span class="line">            <span class="comment"># 2. 校验密码和确认密码是否一致</span></span><br><span class="line">            self.add_error(<span class="string">&#x27;confirm_password&#x27;</span>, <span class="string">&#x27;两次密码不一致&#x27;</span>)</span><br><span class="line">        <span class="comment"># 将钩子函数钩出来的所有数据放回去</span></span><br><span class="line">        <span class="keyword">return</span> self.cleaned_data</span><br></pre></td></tr></table></figure><h3 id="forms字段其他参数与样式渲染"><a href="#forms字段其他参数与样式渲染" class="headerlink" title="forms字段其他参数与样式渲染"></a>forms字段其他参数与样式渲染</h3><ul><li>label：字段名</li><li>error_messages：自定义报错信息</li><li>initial：默认值</li><li>required：控制字段是否必填</li><li>widget：type类型<ul><li>attrs：以字典类型定义属性</li></ul></li><li>validators：可以使用<code>RegexValidator</code>添加正则表达式校验</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyForm</span>(<span class="params">forms.Form</span>):</span></span><br><span class="line">    username = forms.CharField(min_length=<span class="number">3</span>, max_length=<span class="number">8</span>, label=<span class="string">&#x27;用户名&#x27;</span>, initial=<span class="string">&#x27;jason&#x27;</span>, required=<span class="literal">False</span>,</span><br><span class="line">                               widget=forms.widgets.TextInput(attrs=&#123;<span class="string">&#x27;class&#x27;</span>: <span class="string">&#x27;form-control&#x27;</span>&#125;),</span><br><span class="line">                               error_messages=&#123;</span><br><span class="line">                                   <span class="string">&#x27;min_length&#x27;</span>: <span class="string">&#x27;用户名最少3位&#x27;</span>,</span><br><span class="line">                                   <span class="string">&#x27;max_length&#x27;</span>: <span class="string">&#x27;用户名最大8位&#x27;</span>,</span><br><span class="line">                                   <span class="string">&#x27;required&#x27;</span>: <span class="string">&quot;用户名不能为空&quot;</span></span><br><span class="line">                               &#125;)</span><br><span class="line">    password = forms.CharField(min_length=<span class="number">3</span>, max_length=<span class="number">8</span>, label=<span class="string">&#x27;密码&#x27;</span>,</span><br><span class="line">                               widget=forms.widgets.PasswordInput(attrs=&#123;<span class="string">&#x27;class&#x27;</span>: <span class="string">&#x27;form-control c1 c2&#x27;</span>&#125;),</span><br><span class="line">                               error_messages=&#123;</span><br><span class="line">                                   <span class="string">&#x27;min_length&#x27;</span>: <span class="string">&#x27;密码最少3位&#x27;</span>,</span><br><span class="line">                                   <span class="string">&#x27;max_length&#x27;</span>: <span class="string">&#x27;密码最大8位&#x27;</span>,</span><br><span class="line">                                   <span class="string">&#x27;required&#x27;</span>: <span class="string">&quot;密码不能为空&quot;</span></span><br><span class="line">                               &#125;)</span><br><span class="line">    confirm_password = forms.CharField(min_length=<span class="number">3</span>, max_length=<span class="number">8</span>, label=<span class="string">&#x27;确认密码&#x27;</span>,</span><br><span class="line">                                       widget=forms.widgets.PasswordInput(attrs=&#123;<span class="string">&#x27;class&#x27;</span>: <span class="string">&#x27;form-control&#x27;</span>&#125;),</span><br><span class="line">                                       error_messages=&#123;</span><br><span class="line">                                           <span class="string">&#x27;min_length&#x27;</span>: <span class="string">&#x27;确认密码最少3位&#x27;</span>,</span><br><span class="line">                                           <span class="string">&#x27;max_length&#x27;</span>: <span class="string">&#x27;确认密码最大8位&#x27;</span>,</span><br><span class="line">                                           <span class="string">&#x27;required&#x27;</span>: <span class="string">&quot;确认密码不能为空&quot;</span></span><br><span class="line">                                       &#125;)</span><br><span class="line">    email = forms.EmailField(label=<span class="string">&#x27;邮箱&#x27;</span>, widget=forms.widgets.EmailInput(attrs=&#123;<span class="string">&#x27;class&#x27;</span>: <span class="string">&#x27;form-control&#x27;</span>&#125;),</span><br><span class="line">                             error_messages=&#123;</span><br><span class="line">                                 <span class="string">&#x27;invalid&#x27;</span>: <span class="string">&#x27;邮箱格式不正确&#x27;</span>,</span><br><span class="line">                                 <span class="string">&#x27;required&#x27;</span>: <span class="string">&quot;邮箱不能为空&quot;</span></span><br><span class="line">                             &#125;)</span><br><span class="line">    phone = forms.CharField(validators=[</span><br><span class="line">        RegexValidator(<span class="string">r&#x27;^[0-9]+$&#x27;</span>, <span class="string">&#x27;请输入数字&#x27;</span>),</span><br><span class="line">        RegexValidator(<span class="string">r&#x27;^159[0-9]+$&#x27;</span>, <span class="string">&#x27;数字必须以159开头&#x27;</span>)</span><br><span class="line">    ])</span><br><span class="line"></span><br><span class="line">    <span class="comment"># radio</span></span><br><span class="line">    gender = forms.ChoiceField(</span><br><span class="line">        choices=((<span class="number">1</span>, <span class="string">&quot;男&quot;</span>), (<span class="number">2</span>, <span class="string">&quot;女&quot;</span>), (<span class="number">3</span>, <span class="string">&quot;保密&quot;</span>)),</span><br><span class="line">        label=<span class="string">&quot;性别&quot;</span>,</span><br><span class="line">        initial=<span class="number">3</span>,</span><br><span class="line">        widget=forms.widgets.RadioSelect()</span><br><span class="line">    )</span><br><span class="line">    <span class="comment"># 单选select</span></span><br><span class="line">    hobby = forms.ChoiceField(</span><br><span class="line">        choices=((<span class="number">1</span>, <span class="string">&quot;篮球&quot;</span>), (<span class="number">2</span>, <span class="string">&quot;足球&quot;</span>), (<span class="number">3</span>, <span class="string">&quot;双色球&quot;</span>),),</span><br><span class="line">        label=<span class="string">&quot;爱好&quot;</span>,</span><br><span class="line">        initial=<span class="number">3</span>,</span><br><span class="line">        widget=forms.widgets.Select()</span><br><span class="line">    )</span><br><span class="line">    <span class="comment"># 多选select</span></span><br><span class="line">    hobby1 = forms.MultipleChoiceField(</span><br><span class="line">        choices=((<span class="number">1</span>, <span class="string">&quot;篮球&quot;</span>), (<span class="number">2</span>, <span class="string">&quot;足球&quot;</span>), (<span class="number">3</span>, <span class="string">&quot;双色球&quot;</span>),),</span><br><span class="line">        label=<span class="string">&quot;爱好&quot;</span>,</span><br><span class="line">        initial=[<span class="number">1</span>, <span class="number">3</span>],</span><br><span class="line">        widget=forms.widgets.SelectMultiple()</span><br><span class="line">    )</span><br><span class="line">    <span class="comment"># 单选checkbox</span></span><br><span class="line">    keep = forms.ChoiceField(</span><br><span class="line">        label=<span class="string">&quot;是否记住密码&quot;</span>,</span><br><span class="line">        initial=<span class="string">&quot;checked&quot;</span>,</span><br><span class="line">        widget=forms.widgets.CheckboxInput()</span><br><span class="line">    )</span><br><span class="line">    <span class="comment"># 多选checkbox</span></span><br><span class="line">    hobby2 = forms.MultipleChoiceField(</span><br><span class="line">        choices=((<span class="number">1</span>, <span class="string">&quot;篮球&quot;</span>), (<span class="number">2</span>, <span class="string">&quot;足球&quot;</span>), (<span class="number">3</span>, <span class="string">&quot;双色球&quot;</span>),),</span><br><span class="line">        label=<span class="string">&quot;爱好&quot;</span>,</span><br><span class="line">        initial=[<span class="number">1</span>, <span class="number">3</span>],</span><br><span class="line">        widget=forms.widgets.CheckboxSelectMultiple()</span><br><span class="line">    )</span><br></pre></td></tr></table></figure><h3 id="choice字段实时更新"><a href="#choice字段实时更新" class="headerlink" title="choice字段实时更新"></a>choice字段实时更新</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.forms <span class="keyword">import</span> Form</span><br><span class="line"><span class="keyword">from</span> django.forms <span class="keyword">import</span> widgets</span><br><span class="line"><span class="keyword">from</span> django.forms <span class="keyword">import</span> fields</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyForm</span>(<span class="params">Form</span>):</span></span><br><span class="line">    <span class="comment"># 方式一</span></span><br><span class="line">    user = fields.ChoiceField(</span><br><span class="line">        <span class="comment"># choices=((1, &#x27;上海&#x27;), (2, &#x27;北京&#x27;),),</span></span><br><span class="line">        initial=<span class="number">2</span>,</span><br><span class="line">        widget=widgets.Select</span><br><span class="line">    )</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, *args, **kwargs</span>):</span></span><br><span class="line">        <span class="built_in">super</span>(MyForm,self).__init__(*args, **kwargs)</span><br><span class="line">        <span class="comment"># self.fields[&#x27;user&#x27;].choices = ((1, &#x27;上海&#x27;), (2, &#x27;北京&#x27;),)</span></span><br><span class="line">        <span class="comment"># 或</span></span><br><span class="line">        self.fields[<span class="string">&#x27;user&#x27;</span>].choices = models.Classes.objects.<span class="built_in">all</span>().values_list(<span class="string">&#x27;id&#x27;</span>, <span class="string">&#x27;caption&#x27;</span>)</span><br><span class="line">        </span><br><span class="line">    <span class="comment"># 方式二</span></span><br><span class="line">    authors = form_model.ModelMultipleChoiceField(queryset=models.NNewType.objects.<span class="built_in">all</span>())  <span class="comment"># 多选</span></span><br><span class="line">    <span class="comment"># authors = form_model.ModelChoiceField(queryset=models.NNewType.objects.all())  # 单选</span></span><br></pre></td></tr></table></figure><h2 id="Cookie与Session"><a href="#Cookie与Session" class="headerlink" title="Cookie与Session"></a>Cookie与Session</h2><p>目标：</p><ul><li>为了保持用户登陆状态。</li></ul><p>Cookie：</p><ul><li>登陆之后，将用户的信息返回给用户浏览器，保存在本地，之后访问网站的时候携带保存在浏览器上的用户信息发送给服务端，自动验证。</li><li>服务端保存在客户端浏览器上的信息都可以称之为cookie。</li><li>它的表现形式一般都是k:v键值对(可以有多个)。</li></ul><p>Session：</p><ul><li>登陆之后，服务端保存kv键值对形式的数据。k为随机字符串，交由客户端浏览器保存，v为用户信息。</li><li>数据保存在服务端，并且表现形式一般也是k:v键值对。</li><li>Session是基于Cookie工作的(包括其他保存用户操作的状态都需要使用到cookie)。</li></ul><p>Token：</p><ul><li>为了减轻Session给服务端带来的压力：随着连接数增多，服务端保存的数据量越大。</li><li>登陆之后，将用户信息进行公司内独有的加密处理，并将多段数据拼接(jwt认证)，整体返回给浏览器保存。</li><li>浏览器之后访问的时候带着密文，服务端自动解密并比对。</li></ul><h3 id="Cookie操作"><a href="#Cookie操作" class="headerlink" title="Cookie操作"></a>Cookie操作</h3><ul><li>虽然cookie是服务端要求客户端需要保存内容，但是客户端可以选择拒绝保存，如果禁止，那么只要是需要记录用户状态的网站功能都无法使用了。</li><li>如果想要操作cookie，就不得不使用HttpResponse对象。</li></ul><p>Cookie方法：</p><ol><li><code>HttpResponseObject.set_cookie(key,value)</code>：设置cookie</li><li><code>request.COOKIES.get(key)</code>：获取cookie</li><li><code>HttpResponseObject.set_cookie(key, value, max_age, expires)</code>：在设置cookie的时候可以添加一个超时时间<ul><li>max_age、expires 都是设置超时时间的，并且都是以秒为单位，针对IE浏览器需要使用expires。</li></ul></li><li><code>HttpResponseObject.delete_cookie(key)</code>：清除Cookie</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 校验用户是否登陆的装饰器</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">login_auth</span>(<span class="params">func</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inner</span>(<span class="params">request, *args, **kwargs</span>):</span></span><br><span class="line">        target_url = request.get_full_path()  <span class="comment"># 能够获取到用户上一次想要访问的url</span></span><br><span class="line">        <span class="keyword">if</span> request.COOKIES.get(<span class="string">&#x27;username&#x27;</span>):</span><br><span class="line">            <span class="keyword">return</span> func(request, *args, **kwargs)</span><br><span class="line">        <span class="keyword">return</span> redirect(<span class="string">&#x27;/login/?next=%s&#x27;</span> % target_url)</span><br><span class="line">    <span class="keyword">return</span> inner</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">login</span>(<span class="params">request</span>):</span></span><br><span class="line">    <span class="keyword">if</span> request.method == <span class="string">&#x27;POST&#x27;</span>:</span><br><span class="line">        username = request.POST.get(<span class="string">&#x27;username&#x27;</span>)</span><br><span class="line">        password = request.POST.get(<span class="string">&#x27;password&#x27;</span>)</span><br><span class="line">        <span class="keyword">if</span> username == <span class="string">&#x27;jason&#x27;</span> <span class="keyword">and</span> password == <span class="string">&#x27;123&#x27;</span>:</span><br><span class="line">            <span class="comment"># 获取用户上一次想要访问的url</span></span><br><span class="line">            target_url = request.GET.get(<span class="string">&#x27;next&#x27;</span>)  <span class="comment"># 这个结果可能是None</span></span><br><span class="line">            <span class="keyword">if</span> target_url:</span><br><span class="line">                obj = redirect(target_url)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                obj = redirect(<span class="string">&#x27;/home/&#x27;</span>)</span><br><span class="line">            <span class="comment"># 让浏览器记录cookie数据，保存用户登陆状态，超时时间3秒到期</span></span><br><span class="line">            obj.set_cookie(<span class="string">&#x27;username&#x27;</span>, <span class="string">&#x27;jason666&#x27;</span>, max_age=<span class="number">3</span>)</span><br><span class="line">            <span class="comment"># 跳转到一个需要用户登陆之后才能看的页面</span></span><br><span class="line">            <span class="keyword">return</span> obj</span><br><span class="line">    <span class="keyword">return</span> render(request, <span class="string">&#x27;login.html&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@login_auth</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">home</span>(<span class="params">request</span>):</span></span><br><span class="line">    <span class="keyword">return</span> HttpResponse(<span class="string">&quot;我是home页面，只有登陆的用户才能进来哟~&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@login_auth</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">logout</span>(<span class="params">request</span>):</span></span><br><span class="line">    obj = redirect(<span class="string">&#x27;/login/&#x27;</span>)</span><br><span class="line">    obj.delete_cookie(<span class="string">&#x27;username&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> obj</span><br></pre></td></tr></table></figure><blockquote><p>对装饰器的详细解释：<a href="https://www.runoob.com/w3cnote/python-func-decorators.html">https://www.runoob.com/w3cnote/python-func-decorators.html</a></p></blockquote><h3 id="Session操作"><a href="#Session操作" class="headerlink" title="Session操作"></a>Session操作</h3><ul><li><p>Session数据是保存在服务端的，给客户端返回的是一个key为sessionid、value为随机字符串的键值对。</p></li><li><p>在使用Session之前要使用数据库迁移命令，因为Session的数据是存储在django_session表中的。</p></li><li><p>Django默认session的过期时间是14天。</p></li><li><p>django_session表中的数据条数是取决于 user-agent ，同一个浏览器在期限内只会有一条数据被写入在表中。</p><p>当session过期时，可能会出现多条数据对应一个IP地址，但是该现象不会持续很久，内部会自动清除过期的数据，也可以通过代码手动清除。</p></li><li><p>session保存位置可以有多种选择：1. MySQL  2. 文件  3. redis  4. memcache</p></li></ul><p>Session方法：</p><ol><li><code>request.session[&#39;key&#39;] = value</code>：设置session</li><li><code>request.session.get(&#39;key&#39;)</code>：获取session</li><li><code>request.session.set_expiry()</code>：设置过期时间<ul><li>非零正数：持续的秒数</li><li>datetime或timedelta日期对象：指定日期失效</li><li>0：一旦浏览器窗口关闭则失效</li><li>None：session会依赖全局session失效策略</li></ul></li><li><code>request.session.delete()</code>：清除session，只删服务端的，客户端的不删</li><li><code>request.session.flush()</code>：清除session，浏览器和服务端都清空(推荐使用)</li><li><code>request.session.session_key</code>：会话session的key</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">set_session</span>(<span class="params">request</span>):</span></span><br><span class="line">    request.session[<span class="string">&#x27;hobby&#x27;</span>] = <span class="string">&#x27;girl&#x27;</span></span><br><span class="line">    request.session.set_expiry(<span class="number">5</span>)</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    1. django内部自动生成一个随机字符串</span></span><br><span class="line"><span class="string">    2. django内部自动将随机字符串和对应的数据存储到django_session表中</span></span><br><span class="line"><span class="string">        2.1 先在内存中产生操作数据的缓存</span></span><br><span class="line"><span class="string">        2.2 在响应结果经过django中间件时才真正地操作数据库</span></span><br><span class="line"><span class="string">            django.contrib.sessions.middleware.SessionMiddleware</span></span><br><span class="line"><span class="string">    3. 将产生的随机字符串返回给客户端浏览器保存</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">return</span> HttpResponse(<span class="string">&#x27;嘿嘿嘿&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_session</span>(<span class="params">request</span>):</span></span><br><span class="line">    <span class="keyword">if</span> request.session.get(<span class="string">&#x27;hobby&#x27;</span>):</span><br><span class="line">        print(request.session)</span><br><span class="line">        print(request.session.get(<span class="string">&quot;hobby&quot;</span>))</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        1. 先从请求中获取sessionid对应的随机字符串</span></span><br><span class="line"><span class="string">        2. 拿着该随机字符串去django_session表中查找对应的数据</span></span><br><span class="line"><span class="string">            2.1 如果比对上了，则将对应的数据取出并以字典的形式封装到request.session中</span></span><br><span class="line"><span class="string">            2.2 如果比对不上，则request.session.get()返回None</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> HttpResponse(<span class="string">&quot;哈哈哈&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> HttpResponse(<span class="string">&quot;大爷 关门了 明晚再来吧&quot;</span>)</span><br></pre></td></tr></table></figure><h4 id="利用session实现登陆验证"><a href="#利用session实现登陆验证" class="headerlink" title="利用session实现登陆验证"></a>利用session实现登陆验证</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> wraps</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">check_login</span>(<span class="params">func</span>):</span></span><br><span class="line"><span class="meta">    @wraps(<span class="params">func</span>)</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inner</span>(<span class="params">request, *args, **kwargs</span>):</span></span><br><span class="line">        next_url = request.get_full_path()</span><br><span class="line">        <span class="keyword">if</span> request.session.get(<span class="string">&quot;user&quot;</span>):</span><br><span class="line">            <span class="keyword">return</span> func(request, *args, **kwargs)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> redirect(<span class="string">&quot;/login/?next=&#123;&#125;&quot;</span>.<span class="built_in">format</span>(next_url))</span><br><span class="line">    <span class="keyword">return</span> inner</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">login</span>(<span class="params">request</span>):</span></span><br><span class="line">    <span class="keyword">if</span> request.method == <span class="string">&quot;POST&quot;</span>:</span><br><span class="line">        user = request.POST.get(<span class="string">&quot;user&quot;</span>)</span><br><span class="line">        pwd = request.POST.get(<span class="string">&quot;pwd&quot;</span>)</span><br><span class="line">        <span class="keyword">if</span> user == <span class="string">&quot;alex&quot;</span> <span class="keyword">and</span> pwd == <span class="string">&quot;alex1234&quot;</span>:</span><br><span class="line">            <span class="comment"># 设置session</span></span><br><span class="line">            request.session[<span class="string">&quot;user&quot;</span>] = user</span><br><span class="line">            <span class="comment"># 获取跳到登陆页面之前的URL</span></span><br><span class="line">            next_url = request.GET.get(<span class="string">&quot;next&quot;</span>)</span><br><span class="line">            <span class="comment"># 如果有，就跳转回登陆之前的URL</span></span><br><span class="line">            <span class="keyword">if</span> next_url:</span><br><span class="line">                <span class="keyword">return</span> redirect(next_url)</span><br><span class="line">            <span class="comment"># 否则默认跳转到index页面</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> redirect(<span class="string">&quot;/index/&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> render(request, <span class="string">&quot;login.html&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@check_login</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">logout</span>(<span class="params">request</span>):</span></span><br><span class="line">    <span class="comment"># 删除所有当前请求相关的session</span></span><br><span class="line">    request.session.flush()</span><br><span class="line">    <span class="keyword">return</span> redirect(<span class="string">&quot;/login/&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@check_login</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span>(<span class="params">request</span>):</span></span><br><span class="line">    current_user = request.session.get(<span class="string">&quot;user&quot;</span>, <span class="literal">None</span>)</span><br><span class="line">    <span class="keyword">return</span> render(request, <span class="string">&quot;index.html&quot;</span>, &#123;<span class="string">&quot;user&quot;</span>: current_user&#125;)</span><br></pre></td></tr></table></figure><h3 id="CBV添加装饰器"><a href="#CBV添加装饰器" class="headerlink" title="CBV添加装饰器"></a>CBV添加装饰器</h3><h4 id="加在CBV的get或post方法上"><a href="#加在CBV的get或post方法上" class="headerlink" title="加在CBV的get或post方法上"></a>加在CBV的get或post方法上</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.utils.decorators <span class="keyword">import</span> method_decorator</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HomeView</span>(<span class="params">View</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span>(<span class="params">self, request</span>):</span></span><br><span class="line">        <span class="keyword">return</span> render(request, <span class="string">&quot;home.html&quot;</span>)</span><br><span class="line">    </span><br><span class="line"><span class="meta">    @method_decorator(<span class="params">check_login</span>)</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">post</span>(<span class="params">self, request</span>):</span></span><br><span class="line">        print(<span class="string">&quot;Home View POST method...&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> redirect(<span class="string">&quot;/index/&quot;</span>)</span><br></pre></td></tr></table></figure><h4 id="加在dispatch方法上"><a href="#加在dispatch方法上" class="headerlink" title="加在dispatch方法上"></a>加在dispatch方法上</h4><p>因为CBV中首先执行的就是dispatch方法，所以直接作用于当前类里面的所有的方法</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.utils.decorators <span class="keyword">import</span> method_decorator</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HomeView</span>(<span class="params">View</span>):</span></span><br><span class="line"><span class="meta">    @method_decorator(<span class="params">check_login</span>)</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dispatch</span>(<span class="params">self, request, *args, **kwargs</span>):</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>(HomeView, self).dispatch(request, *args, **kwargs)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span>(<span class="params">self, request</span>):</span></span><br><span class="line">        <span class="keyword">return</span> render(request, <span class="string">&quot;home.html&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">post</span>(<span class="params">self, request</span>):</span></span><br><span class="line">        print(<span class="string">&quot;Home View POST method...&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> redirect(<span class="string">&quot;/index/&quot;</span>)</span><br></pre></td></tr></table></figure><h4 id="加在视图类上"><a href="#加在视图类上" class="headerlink" title="加在视图类上"></a>加在视图类上</h4><p>如果get方法和post方法都需要登录校验的话就写两个装饰器。</p><p>但method_decorator必须传 name 关键字参数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.utils.decorators <span class="keyword">import</span> method_decorator</span><br><span class="line"></span><br><span class="line"><span class="meta">@method_decorator(<span class="params">check_login, name=<span class="string">&quot;get&quot;</span></span>)</span></span><br><span class="line"><span class="meta">@method_decorator(<span class="params">check_login, name=<span class="string">&quot;post&quot;</span></span>)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HomeView</span>(<span class="params">View</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span>(<span class="params">self, request</span>):</span></span><br><span class="line">        <span class="keyword">return</span> render(request, <span class="string">&quot;home.html&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">post</span>(<span class="params">self, request</span>):</span></span><br><span class="line">        print(<span class="string">&quot;Home View POST method...&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> redirect(<span class="string">&quot;/index/&quot;</span>)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Django </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Django-Part4</title>
      <link href="/2021/08/Django-Part4/"/>
      <url>/2021/08/Django-Part4/</url>
      
        <content type="html"><![CDATA[<h1 id="Django-Part4——模型层"><a href="#Django-Part4——模型层" class="headerlink" title="Django-Part4——模型层"></a>Django-Part4——模型层</h1><p>[TOC]</p><h2 id="测试脚本"><a href="#测试脚本" class="headerlink" title="测试脚本"></a>测试脚本</h2><ul><li>当只是想测试django项目中的某一个.py文件内容，那么可以不用书写前后端交互的形式，而是直接写一个测试脚本即可。</li><li>脚本代码无论是写在应用下的tests.py，还是单独开设.py文件都可以。</li><li>django中的文件默认不会暴露出来，需要准备测试环境才能进行测试。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 测试环境的准备：1. 在manage.py中拷贝前四行代码；2. 额外增加两行代码</span></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    os.environ.setdefault(<span class="string">&quot;DJANGO_SETTINGS_MODULE&quot;</span>, <span class="string">&quot;djangoProject.settings&quot;</span>)  <span class="comment"># 这里要改成相应的项目名</span></span><br><span class="line">    <span class="keyword">import</span> django</span><br><span class="line">    django.setup()</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 测试代码</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li><p>当<code>from app01 import models</code>写在main之外时，可以通过勾选”使用Python控制台运行”来解决 <a href="https://blog.csdn.net/weixin_44393803/article/details/89739066">https://blog.csdn.net/weixin_44393803/article/details/89739066</a></p></li><li><p>当不准备环境配置时，可以在运行配置中勾选 Python控制台启动 。这样会忽略脚本中的配置环境代码。（推荐）</p></li></ul><h2 id="Django-ORM"><a href="#Django-ORM" class="headerlink" title="Django ORM"></a>Django ORM</h2><h3 id="创建模型表"><a href="#创建模型表" class="headerlink" title="创建模型表"></a>创建模型表</h3><ul><li>对象关系映射（ORM），能够以面向对象的方式简便快捷地操作数据库。但是封装程度太高，有时候还是需要自己写SQL语句。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -&gt; app -&gt; models.py</span></span><br><span class="line"><span class="comment"># 1. 首先在models.py中书写一个类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span>(<span class="params">models.Model</span>):</span></span><br><span class="line">    <span class="comment"># id int primary_key auto_increment</span></span><br><span class="line">    <span class="built_in">id</span> = models.AutoField(primary_key=<span class="literal">True</span>, verbose_name=<span class="string">&#x27;主键&#x27;</span>)  <span class="comment"># verbose_name用来对字段解释</span></span><br><span class="line">    <span class="comment"># username varchar(32)</span></span><br><span class="line">    username = models.CharField(max_length=<span class="number">32</span>, verbose_name=<span class="string">&#x27;用户名&#x27;</span>)  <span class="comment"># CharField必须要指定max_length参数，否则报错</span></span><br><span class="line">    <span class="comment"># password int</span></span><br><span class="line">    password = models.IntegerField(verbose_name=<span class="string">&#x27;密码&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Author</span>(<span class="params">models.Model</span>):</span></span><br><span class="line">    <span class="comment"># 由于一张表中必须要有一个主键字段，并且一般情况下都叫id字段</span></span><br><span class="line">    <span class="comment"># 所以当不定义主键字段时，orm会自动创建一个名为id主键字段</span></span><br><span class="line">    <span class="comment"># 也就意味着：后续在创建表时，如果主键字段名没有额外的叫法，那么主键字段可以省略不写</span></span><br><span class="line">    <span class="comment"># username varchar(32)</span></span><br><span class="line">    username = models.CharField(max_length=<span class="number">32</span>)</span><br><span class="line">    <span class="comment"># password int</span></span><br><span class="line">    password = models.IntegerField()</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>每次只要修改了models.py中跟数据库相关的代码，就必须重新执行以下两条命令。</li><li>如果发现执行之后没有发生变化，则检查app是否已经注册</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -&gt; 控制台</span></span><br><span class="line"><span class="comment"># 2. 数据库迁移命令</span></span><br><span class="line">python manage.py makemigrations  <span class="comment"># 将操作记录记录migrations文件夹中</span></span><br><span class="line">python manage.py migrate  <span class="comment"># 将操作真正的同步到数据库中</span></span><br></pre></td></tr></table></figure><ul><li>除自建表之外，还有Django需要使用的表</li></ul><p><img src="/2021/08/Django-Part4/image-20210616153539184.png" alt="image-20210616153539184"></p><h3 id="字段的增-删-改"><a href="#字段的增-删-改" class="headerlink" title="字段的增/删/改"></a>字段的增/删/改</h3><ul><li><p>当数据表拥有记录时，不能增加非空字段：</p><ol><li>在终端内直接给出默认值</li><li>退出终端程序，并修改代码为可以为空<code>xxx = models.CharField(max_length=32, null=True)</code></li><li>退出终端程序，并修改代码设置默认值<code>xxx = models.CharField(max_length=32, default=&#39;xxx&#39;)</code></li></ol></li><li><p>修改字段则是修改对应代码</p></li><li><p>删除字段则是注释/删除对应代码</p></li></ul><p>修改model文件之后，不要忘了执行数据库迁移的两条命令</p><blockquote><p>不要轻易地删除/注释字段，删除也最好使用软删除！</p><p>在对于数据库操作时一定要注意隐私安全，一定要锁屏！</p></blockquote><h3 id="创建表关系"><a href="#创建表关系" class="headerlink" title="创建表关系"></a>创建表关系</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.db <span class="keyword">import</span> models</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Create your models here.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建表关系。先将基表创建出来，然后再添加外键字段</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Book</span>(<span class="params">models.Model</span>):</span></span><br><span class="line">    title = models.CharField(max_length=<span class="number">32</span>, verbose_name=<span class="string">&quot;书名&quot;</span>)</span><br><span class="line">    price = models.DecimalField(max_digits=<span class="number">8</span>, decimal_places=<span class="number">2</span>)  <span class="comment"># 总共八位 小数点后面占两位</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 图书和出版社是一对多，并且书是多的一方，所以外键字段放在书表里面</span></span><br><span class="line">    publish = models.ForeignKey(to=<span class="string">&#x27;Publish&#x27;</span>, on_delete=models.CASCADE)</span><br><span class="line">    <span class="comment"># to_field=默认与出版社表的主键字段做外键关联</span></span><br><span class="line">    <span class="comment"># 如果该字段是ForeignKey，则orm会自动在字段的后面加 _id -&gt; publish_id</span></span><br><span class="line">    <span class="comment"># 因此在定义ForeignKey的时候就不要加 _id</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 图书和作者是多对多的关系，外键字段建在任意一方均可，但是推荐建在查询频率较高的一方</span></span><br><span class="line">    authors = models.ManyToManyField(to=<span class="string">&#x27;Author&#x27;</span>)</span><br><span class="line">    <span class="comment"># authors是一个虚拟字段 主要是用来告诉orm 书籍表和作者表是多对多关系</span></span><br><span class="line">    <span class="comment"># orm将自动创建第三张关系表</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Publish</span>(<span class="params">models.Model</span>):</span></span><br><span class="line">    name = models.CharField(max_length=<span class="number">32</span>)</span><br><span class="line">    addr = models.CharField(max_length=<span class="number">32</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Author</span>(<span class="params">models.Model</span>):</span></span><br><span class="line">    name = models.CharField(max_length=<span class="number">32</span>)</span><br><span class="line">    age = models.IntegerField()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 作者与作者详情是一对一的关系 外键字段建在任意一方都可以 但是推荐你建在查询频率较高的表中</span></span><br><span class="line">    author_detail = models.OneToOneField(to=<span class="string">&#x27;AuthorDetail&#x27;</span>, on_delete=models.CASCADE)  <span class="comment"># django2.x之后要手动添加级联删除</span></span><br><span class="line">    <span class="comment"># OneToOneField()也会自动给字段 author_detail 加 _id 后缀</span></span><br><span class="line">    <span class="comment"># on_delete有CASCADE、PROTECT、SET_NULL、SET_DEFAULT、SET(value)五个可选择的值</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AuthorDetail</span>(<span class="params">models.Model</span>):</span></span><br><span class="line">    phone = models.BigIntegerField()  <span class="comment"># 直接用字符类型更好</span></span><br><span class="line">    addr = models.CharField(max_length=<span class="number">32</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li><code>A表外键字段 = models.ForeignKey(to=B表)</code> </li><li><code>关系表外键字段 = models.ManyToManyField(to=B表)</code> </li><li><code>A表外键字段 = models.OneToOneField(to=B表)</code> </li></ul><blockquote><p>外键都会自动加_id后缀</p></blockquote><h2 id="单表操作"><a href="#单表操作" class="headerlink" title="单表操作"></a>单表操作</h2><h3 id="增删改查"><a href="#增删改查" class="headerlink" title="增删改查"></a>增删改查</h3><ul><li>在视图函数中，<code>from app01 import models</code>首先导入对应的app下的model</li><li>django自带的sqlite3数据库对日期格式不是很敏感，处理的时候容易出错。</li><li>pk会自动查找到当前表的主键字段，指代的就是当前表的主键字段，避免区分当前表的主键字段名uid/pid/sid</li></ul><h4 id="增"><a href="#增" class="headerlink" title="增"></a>增</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">reg</span>(<span class="params">request</span>):</span></span><br><span class="line">    <span class="keyword">if</span> request.method == <span class="string">&quot;POST&quot;</span>:</span><br><span class="line">        username = request.POST.get(<span class="string">&#x27;username&#x27;</span>)</span><br><span class="line">        password = request.POST.get(<span class="string">&#x27;password&#x27;</span>)</span><br><span class="line">        <span class="keyword">from</span> app01 <span class="keyword">import</span> models</span><br><span class="line">        <span class="comment"># 第一种方式(推荐使用)</span></span><br><span class="line">reslt = models.User.objects.create(username=username, password=password)  </span><br><span class="line">        print(res, res.username, res.password)  <span class="comment"># 返回值就是当前被创建的对象本身</span></span><br><span class="line">        <span class="comment"># 第二种方式</span></span><br><span class="line">user_obj = models.User(username=username, password=password)</span><br><span class="line">user_obj.save()  <span class="comment"># 保存数据</span></span><br><span class="line">        </span><br><span class="line">    <span class="comment"># 先给用户返回一个注册页面</span></span><br><span class="line">    <span class="keyword">return</span> render(request, <span class="string">&#x27;reg.html&#x27;</span>)</span><br></pre></td></tr></table></figure><h4 id="查"><a href="#查" class="headerlink" title="查"></a>查</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">login</span>(<span class="params">request</span>):</span></span><br><span class="line">    <span class="keyword">if</span> request.method == <span class="string">&#x27;POST&#x27;</span>:</span><br><span class="line">        <span class="comment"># 获取用户的用户名和密码 然后利用orm操作数据 校验数据是否正确</span></span><br><span class="line">        username = request.POST.get(<span class="string">&#x27;username&#x27;</span>)</span><br><span class="line">        password = request.POST.get(<span class="string">&#x27;password&#x27;</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 去数据库中查询数据</span></span><br><span class="line">        <span class="keyword">from</span> app01 <span class="keyword">import</span> models</span><br><span class="line">        <span class="comment"># select * from user where username=&#x27;jason&#x27;;</span></span><br><span class="line">        <span class="comment"># filter相当于where，括号内可以携带多个参数，参数与参数之间是and关系</span></span><br><span class="line">        result = models.User.objects.<span class="built_in">filter</span>(username=username)</span><br><span class="line">        print(<span class="built_in">type</span>(result))  <span class="comment"># &lt;QuerySet [&lt;User: User object&gt;]&gt;</span></span><br><span class="line"><span class="comment"># 支持索引取值、切片操作，但是不支持负数索引</span></span><br><span class="line">user_obj = reslt.first()  <span class="comment"># 从queryset拿出一个个数据对象</span></span><br><span class="line">print(user_obj.username)  <span class="comment"># 直接调用字段</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 比对密码是否一致</span></span><br><span class="line">        <span class="keyword">if</span> user_obj:</span><br><span class="line">            <span class="keyword">if</span> password == user_obj.password:</span><br><span class="line">                <span class="keyword">return</span> HttpResponse(<span class="string">&quot;登陆成功&quot;</span>)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> HttpResponse(<span class="string">&quot;密码错误&quot;</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> HttpResponse(<span class="string">&quot;用户不存在&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> render(request, <span class="string">&#x27;login.html&#x27;</span>)</span><br></pre></td></tr></table></figure><ul><li><code>models.User.objects.filter()</code>等效于<code>models.User.objects.all()</code></li><li><code>.first()</code>等效于<code>[0]</code></li></ul><p>数据展示：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -&gt; views.py</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">userlist</span>(<span class="params">request</span>):</span></span><br><span class="line">    <span class="comment"># 查询出用户表里面所有的数据</span></span><br><span class="line">    user_queryset = models.User.objects.<span class="built_in">all</span>()</span><br><span class="line">    <span class="comment"># return render(request,&#x27;userlist.html&#x27;,&#123;&#x27;user_queryset&#x27;:user_queryset&#125;)</span></span><br><span class="line">    <span class="keyword">return</span> render(request,<span class="string">&#x27;userlist.html&#x27;</span>, <span class="built_in">locals</span>())  <span class="comment"># 返回当前的命名空间</span></span><br></pre></td></tr></table></figure><p>模板语法for：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#123;% for user_obj in user_queryset %&#125;</span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span>&#123;&#123; user_obj.id &#125;&#125;<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span>&#123;&#123; user_obj.username &#125;&#125;<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span>&#123;&#123; user_obj.password &#125;&#125;<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span></span><br><span class="line">&#123;#            利用url问号后面携带参数的方式，将编辑按钮所在行的主键值发送给后端#&#125;</span><br><span class="line">            <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;/edit_user/?user_id=&#123;&#123; user_obj.id &#125;&#125;&quot;</span> <span class="attr">class</span>=<span class="string">&quot;btn btn-primary btn-xs&quot;</span>&gt;</span>编辑<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;/delete_user/?user_id=&#123;&#123; user_obj.id &#125;&#125;&quot;</span> <span class="attr">class</span>=<span class="string">&quot;btn btn-danger btn-xs&quot;</span>&gt;</span>删除<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">&#123;% endfor %&#125;</span><br></pre></td></tr></table></figure><h4 id="改"><a href="#改" class="headerlink" title="改"></a>改</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">edit_user</span>(<span class="params">request</span>):</span></span><br><span class="line">    <span class="comment"># 获取url问号后面的参数</span></span><br><span class="line">    edit_id = request.GET.get(<span class="string">&#x27;user_id&#x27;</span>)</span><br><span class="line">    <span class="comment"># 查询当前用户想要编辑的数据对象</span></span><br><span class="line">    edit_list = models.User.objects.<span class="built_in">filter</span>(<span class="built_in">id</span>=edit_id)</span><br><span class="line">    edit_obj = edit_list.first()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> request.method == <span class="string">&quot;POST&quot;</span>:</span><br><span class="line">        username = request.POST.get(<span class="string">&#x27;username&#x27;</span>)</span><br><span class="line">        password = request.POST.get(<span class="string">&#x27;password&#x27;</span>)</span><br><span class="line">        <span class="comment"># 改 1 批量更新filter查询出来的列表中所有对象。只修改被修改的字段</span></span><br><span class="line">        edit_list.update(username=username, password=password)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 改 2 单条数据更新。无论该字段是否被修改，重写所有字段(当字段特别多时，效率很低)</span></span><br><span class="line">        edit_obj.username = username</span><br><span class="line">        edit_obj.password = password</span><br><span class="line">        edit_obj.save()</span><br><span class="line">      </span><br><span class="line">        <span class="keyword">return</span> redirect(<span class="string">&#x27;/userlist/&#x27;</span>)  <span class="comment"># 跳转到数据的展示页面</span></span><br><span class="line">    <span class="keyword">return</span> render(request, <span class="string">&#x27;edit_user.html&#x27;</span>, <span class="built_in">locals</span>())  <span class="comment"># 将数据对象展示到页面上</span></span><br></pre></td></tr></table></figure><h4 id="删"><a href="#删" class="headerlink" title="删"></a>删</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">delete_user</span>(<span class="params">request</span>):</span></span><br><span class="line">    <span class="comment"># 获取用户想要删除的数据id值</span></span><br><span class="line">    delete_id = request.GET.get(<span class="string">&#x27;user_id&#x27;</span>)</span><br><span class="line">    <span class="comment"># 删 1 批量删除数据库中找到对应的数据</span></span><br><span class="line">    res = models.User.objects.<span class="built_in">filter</span>(<span class="built_in">id</span>=delete_id).delete()</span><br><span class="line">    print(res)  <span class="comment"># (1, &#123;&#x27;app01.User&#x27;: 1&#125;)</span></span><br><span class="line">    <span class="comment"># 删 2</span></span><br><span class="line">    user_obj = models.User.objects.<span class="built_in">filter</span>(pk=delete_id).first()</span><br><span class="line">    user_obj.delete()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> redirect(<span class="string">&#x27;/userlist/&#x27;</span>)</span><br></pre></td></tr></table></figure><blockquote><p>一般都会添加一个is_delete字段做软删除，而不会直接删除。</p></blockquote><h3 id="必知必会13条"><a href="#必知必会13条" class="headerlink" title="必知必会13条"></a>必知必会13条</h3><ol><li><p>all()：查询所有数据</p></li><li><p>filter()：带有过滤条件的查询</p></li><li><p>get()：直接拿数据对象，但是条件不存在直接报错</p></li><li><p>first()：拿queryset里面第一个元素</p></li><li><p>last()：拿queryset里面最后一个元素</p></li><li><p>values()：可以指定获取的数据字段，相当于select name,age from …     </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">res = models.User.objects.values(<span class="string">&#x27;name&#x27;</span>,<span class="string">&#x27;age&#x27;</span>)</span><br><span class="line">print(res)  <span class="comment"># 列表套字典 &lt;QuerySet [&#123;&#x27;name&#x27;: &#x27;jason&#x27;, &#x27;age&#x27;: 18&#125;, &#123;&#x27;name&#x27;: &#x27;egonPPP&#x27;, &#x27;age&#x27;: 84&#125;]&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>values_list()：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">res = models.User.objects.values_list(<span class="string">&#x27;name&#x27;</span>,<span class="string">&#x27;age&#x27;</span>)</span><br><span class="line">print(res)  <span class="comment"># 列表套元组 &lt;QuerySet [(&#x27;jason&#x27;, 18), (&#x27;egonPPP&#x27;, 84)]&gt;</span></span><br></pre></td></tr></table></figure><p>和values()仅仅只是封装格式不一样，sql查询语句是一样的。</p></li><li><p>distinct()：去重</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">res = models.User.objects.values(<span class="string">&#x27;name&#x27;</span>,<span class="string">&#x27;age&#x27;</span>).distinct()</span><br><span class="line">print(res)</span><br></pre></td></tr></table></figure><ul><li><p>去重一定要是（在虚表中）一模一样的数据。</p><p>例如：.all()的数据带有主键，因此无法去重</p></li></ul></li><li><p>order_by()：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">res = models.User.objects.order_by(<span class="string">&#x27;age&#x27;</span>)  <span class="comment"># 默认升序</span></span><br><span class="line">res = models.User.objects.order_by(<span class="string">&#x27;-age&#x27;</span>)  <span class="comment"># 降序</span></span><br><span class="line">print(res)</span><br></pre></td></tr></table></figure></li><li><p>reverse()：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">res = models.User.objects.<span class="built_in">all</span>()  <span class="comment"># 反转</span></span><br><span class="line">res1 = models.User.objects.order_by(<span class="string">&#x27;age&#x27;</span>).reverse()  <span class="comment"># 必须先排序</span></span><br><span class="line">print(res, res1)</span><br></pre></td></tr></table></figure></li><li><p>count()：统计当前数据的个数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">res = models.User.objects.count()  <span class="comment"># 统计当前数据的个数</span></span><br><span class="line">print(res)</span><br></pre></td></tr></table></figure></li><li><p>exclude()：排除在外</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">res = models.User.objects.exclude(name=<span class="string">&#x27;jason&#x27;</span>)</span><br><span class="line">print(res)</span><br></pre></td></tr></table></figure></li><li><p>exists()：基本用不到因为数据本身就自带布尔值  返回的是布尔值</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">res = models.User.objects.<span class="built_in">filter</span>(pk=<span class="number">10</span>).exists()</span><br><span class="line">print(res)</span><br></pre></td></tr></table></figure><h3 id="查看内部sql语句的方式"><a href="#查看内部sql语句的方式" class="headerlink" title="查看内部sql语句的方式"></a>查看内部sql语句的方式</h3></li><li><p>只有QuerySet类对象可以使用.query查看内部封装的sql语句</p></li><li><p>在配置文件中配置logging，查看所有的sql语句</p></li><li><p>需要在Python控制台中运行才能看见</p></li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 方式1</span></span><br><span class="line">res = models.User.objects.values_list(<span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;age&#x27;</span>)</span><br><span class="line">print(res.query)  <span class="comment"># SELECT `app01_user`.`name`, `app01_user`.`age` FROM `app01_user`</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 方式2</span></span><br><span class="line"><span class="comment"># -&gt; settings.py</span></span><br><span class="line">LOGGING = &#123;</span><br><span class="line">    <span class="string">&#x27;version&#x27;</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="string">&#x27;disable_existing_loggers&#x27;</span>: <span class="literal">False</span>,</span><br><span class="line">    <span class="string">&#x27;handlers&#x27;</span>: &#123;</span><br><span class="line">        <span class="string">&#x27;console&#x27;</span>:&#123;</span><br><span class="line">            <span class="string">&#x27;level&#x27;</span>:<span class="string">&#x27;DEBUG&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;class&#x27;</span>:<span class="string">&#x27;logging.StreamHandler&#x27;</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">&#x27;loggers&#x27;</span>: &#123;</span><br><span class="line">        <span class="string">&#x27;django.db.backends&#x27;</span>: &#123;</span><br><span class="line">            <span class="string">&#x27;handlers&#x27;</span>: [<span class="string">&#x27;console&#x27;</span>],</span><br><span class="line">            <span class="string">&#x27;propagate&#x27;</span>: <span class="literal">True</span>,</span><br><span class="line">            <span class="string">&#x27;level&#x27;</span>:<span class="string">&#x27;DEBUG&#x27;</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="双下划线查询"><a href="#双下划线查询" class="headerlink" title="双下划线查询"></a>双下划线查询</h3><ul><li>__gt: 大于</li><li>__gte: 大于等于</li><li>__lt: 小于</li><li>__lte: 小于等于</li><li>__in: 在目标集合中，左右闭区间</li><li>__range: 在目标范围中</li><li>__contains: 模糊查询，包含（区分大小写）</li><li>__icontains: 包含（不区分大小写）</li><li>__startswith: 以某字符开头</li><li>__endswith: 以某字符结尾</li><li>__month: 在目标月份</li><li>__year: 在目标年份</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 年龄大于35岁的数据</span></span><br><span class="line">res = models.User.objects.<span class="built_in">filter</span>(age__gt=<span class="number">35</span>)</span><br><span class="line">print(res)</span><br><span class="line"><span class="comment"># 年龄小于35岁的数据</span></span><br><span class="line">res = models.User.objects.<span class="built_in">filter</span>(age__lt=<span class="number">35</span>)</span><br><span class="line">print(res)</span><br><span class="line"><span class="comment"># 大于等于 小于等于</span></span><br><span class="line">res = models.User.objects.<span class="built_in">filter</span>(age__gte=<span class="number">32</span>)</span><br><span class="line">print(res)</span><br><span class="line">res = models.User.objects.<span class="built_in">filter</span>(age__lte=<span class="number">32</span>)</span><br><span class="line">print(res)</span><br><span class="line"><span class="comment"># 年龄是 18 或者 32 或者 40</span></span><br><span class="line">res = models.User.objects.<span class="built_in">filter</span>(age__in=[<span class="number">18</span>, <span class="number">32</span>, <span class="number">40</span>])</span><br><span class="line">print(res)</span><br><span class="line"><span class="comment"># 年龄在18到40岁之间的  首尾都要</span></span><br><span class="line">res = models.User.objects.<span class="built_in">filter</span>(age__range=[<span class="number">18</span>, <span class="number">40</span>])</span><br><span class="line">print(res)</span><br><span class="line"><span class="comment"># 查询出名字里面含有s的数据  模糊查询</span></span><br><span class="line">res = models.User.objects.<span class="built_in">filter</span>(name__contains=<span class="string">&#x27;s&#x27;</span>)</span><br><span class="line">print(res)</span><br><span class="line"><span class="comment"># 是否区分大小写  查询出名字里面含有p的数据  区分大小写</span></span><br><span class="line">res = models.User.objects.<span class="built_in">filter</span>(name__contains=<span class="string">&#x27;p&#x27;</span>)</span><br><span class="line">print(res)</span><br><span class="line"><span class="comment"># 忽略大小写</span></span><br><span class="line">res = models.User.objects.<span class="built_in">filter</span>(name__icontains=<span class="string">&#x27;p&#x27;</span>)</span><br><span class="line">print(res)</span><br><span class="line"><span class="comment"># 开头结尾 </span></span><br><span class="line">res = models.User.objects.<span class="built_in">filter</span>(name__startswith=<span class="string">&#x27;j&#x27;</span>)</span><br><span class="line">res1 = models.User.objects.<span class="built_in">filter</span>(name__endswith=<span class="string">&#x27;j&#x27;</span>)</span><br><span class="line">print(res, res1)</span><br><span class="line"><span class="comment"># 查询出注册时间是 2020 1月</span></span><br><span class="line">res = models.User.objects.<span class="built_in">filter</span>(register_time__month=<span class="string">&#x27;1&#x27;</span>, register_time__year=<span class="string">&#x27;2020&#x27;</span>)</span><br><span class="line">res = res.<span class="built_in">filter</span>(register_time__year=<span class="string">&#x27;2020&#x27;</span>)</span><br></pre></td></tr></table></figure><h3 id="一对多外键增删改查"><a href="#一对多外键增删改查" class="headerlink" title="一对多外键增删改查"></a>一对多外键增删改查</h3><ul><li><p>增 create(): publish_id=num或者publish=publish_obj</p></li><li><p>删 filter(pk=pk).delete(): 会按照on_delete处理对应外键</p></li><li><p>改 filter(pk=pk).update(): publish_id=num或者publish=publish_obj</p><p>这是批量修改，在first()返回的对象中没有update这个方法</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 一对多增删改查</span></span><br><span class="line"><span class="comment"># 1. 增</span></span><br><span class="line"><span class="comment"># 直接写实际字段 id</span></span><br><span class="line">models.Book.objects.create(title=<span class="string">&#x27;三国演义&#x27;</span>, price=<span class="number">123.23</span>, publish_id=<span class="number">1</span>)</span><br><span class="line"><span class="comment"># 投放虚拟字段 对象</span></span><br><span class="line">publish_obj = models.Publish.objects.<span class="built_in">filter</span>(pk=<span class="number">2</span>).first()</span><br><span class="line">models.Book.objects.create(title=<span class="string">&quot;红楼梦&quot;</span>, price=<span class="number">666.23</span>, publish=publish_obj)</span><br><span class="line"><span class="comment"># 2. 删</span></span><br><span class="line">models.Publish.objects.<span class="built_in">filter</span>(pk=<span class="number">1</span>).delete()  <span class="comment"># 会按照on_delete处理对应外键</span></span><br><span class="line"><span class="comment"># 3. 改</span></span><br><span class="line">models.Book.objects.<span class="built_in">filter</span>(pk=<span class="number">1</span>).update(publish_id=<span class="number">2</span>)</span><br><span class="line">publish_obj = models.Publish.objects.<span class="built_in">filter</span>(pk=<span class="number">1</span>).first()</span><br><span class="line">models.Book.objects.<span class="built_in">filter</span>(pk=<span class="number">1</span>).update(publish=publish_obj)</span><br></pre></td></tr></table></figure><h3 id="多对多外键增删改查"><a href="#多对多外键增删改查" class="headerlink" title="多对多外键增删改查"></a>多对多外键增删改查</h3><ul><li><p>models.表名.objects.filter(pk=条件).first().多对多关系.add()</p><p>方法支持传递主键，也可以传递对象</p></li><li><p>models.表名.objects.filter(pk=条件).first().多对多关系.remove()</p><p>这只是在第三张关系表中删除记录</p></li><li><p>models.表名.objects.filter(pk=条件).first().多对多关系.set()</p><p>括号内必须给一个可迭代对象</p><p>如果不符合要求，则先删除，后新增</p></li><li><p>models.表名.objects.filter(pk=条件).first().多对多关系.clear()</p><p>在第三张关系表中清空某个书籍与作者的绑定关系</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1. 增加关系</span></span><br><span class="line">   <span class="comment"># 给书籍添加作者</span></span><br><span class="line">   book_obj = models.Book.objects.<span class="built_in">filter</span>(pk=<span class="number">1</span>).first()</span><br><span class="line">   print(book_obj.authors)  <span class="comment"># 就类似于你已经到了Book和Authors的多对多关系表了</span></span><br><span class="line">   book_obj.authors.add(<span class="number">1</span>)  <span class="comment"># 书籍id为1的书籍绑定一个主键为1的作者</span></span><br><span class="line">   book_obj.authors.add(<span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">   author_obj = models.Author.objects.<span class="built_in">filter</span>(pk=<span class="number">1</span>).first()</span><br><span class="line">   author_obj1 = models.Author.objects.<span class="built_in">filter</span>(pk=<span class="number">2</span>).first()</span><br><span class="line">   author_obj2 = models.Author.objects.<span class="built_in">filter</span>(pk=<span class="number">3</span>).first()</span><br><span class="line">   book_obj.authors.add(author_obj)</span><br><span class="line">   book_obj.authors.add(author_obj1, author_obj2)</span><br><span class="line"></span><br><span class="line">   <span class="comment"># 2. 删</span></span><br><span class="line">   book_obj.authors.remove(<span class="number">2</span>)</span><br><span class="line">   book_obj.authors.remove(<span class="number">1</span>, <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">   author_obj = models.Author.objects.<span class="built_in">filter</span>(pk=<span class="number">2</span>).first()</span><br><span class="line">   author_obj1 = models.Author.objects.<span class="built_in">filter</span>(pk=<span class="number">3</span>).first()</span><br><span class="line">   book_obj.authors.remove(author_obj, author_obj1)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. 改</span></span><br><span class="line">   book_obj.authors.<span class="built_in">set</span>([<span class="number">1</span>, <span class="number">2</span>])</span><br><span class="line">   book_obj.authors.<span class="built_in">set</span>([<span class="number">3</span>])  <span class="comment"># 括号内必须给一个可迭代对象</span></span><br><span class="line"></span><br><span class="line">   author_obj = models.Author.objects.<span class="built_in">filter</span>(pk=<span class="number">2</span>).first()</span><br><span class="line">   author_obj1 = models.Author.objects.<span class="built_in">filter</span>(pk=<span class="number">3</span>).first()</span><br><span class="line">   book_obj.authors.<span class="built_in">set</span>([author_obj, author_obj1])  <span class="comment"># 支持多个</span></span><br><span class="line"></span><br><span class="line">   <span class="comment"># 4. 清空</span></span><br><span class="line">   book_obj.authors.clear()</span><br><span class="line">   book_obj.authors.<span class="built_in">set</span>([])</span><br></pre></td></tr></table></figure><h2 id="多表查询"><a href="#多表查询" class="headerlink" title="多表查询"></a>多表查询</h2><h3 id="正反向"><a href="#正反向" class="headerlink" title="正反向"></a>正反向</h3><ul><li>当a表中拥有b表的外键字段，则a查b为正向，否则反向。</li><li>一对一和多对多正反向的判断也是如此</li></ul><p>外键字段要放在查询频率高的表中。</p><blockquote><ul><li>正向查询按 <code>字段</code> </li><li>反向查询<ul><li>查询一对多、多对多时按 <code>表名小写+_set</code> </li><li>查询一对一时按 <code>表名小写</code></li></ul></li></ul></blockquote><h3 id="子查询-基于对象的跨表查询"><a href="#子查询-基于对象的跨表查询" class="headerlink" title="子查询(基于对象的跨表查询)"></a>子查询(基于对象的跨表查询)</h3><p>在书写orm语句的时候跟写sql语句一样的：</p><ul><li>不要企图一次性将orm语句写完，如果比较复杂，就写一点看一点</li></ul><blockquote><p>正向什么时候需要加.all()：</p><ul><li>查询 多对多 和 一对多 关系时需要加</li><li>查询 一对一 和 多对一 关系时不需要</li><li>当为需要all()的情况时，即使结果只有一个，也会返回集合</li></ul></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1. 查询主键为1的书籍的出版社</span></span><br><span class="line">   <span class="comment"># 有字段 -&gt; 正向；查询多对一关系中一的一方 -&gt; 不用.all()</span></span><br><span class="line">   book_obj = models.Book.objects.<span class="built_in">filter</span>(pk=<span class="number">1</span>).first()</span><br><span class="line">   res = book_obj.publish</span><br><span class="line">   print(res.name)</span><br><span class="line"></span><br><span class="line">   <span class="comment"># 2. 查询主键为2的书籍的作者</span></span><br><span class="line">   <span class="comment"># 有字段 -&gt; 正向；多对多关系 -&gt; 要.all()</span></span><br><span class="line">   book_obj = models.Book.objects.<span class="built_in">filter</span>(pk=<span class="number">1</span>).first()</span><br><span class="line">   res = book_obj.authors</span><br><span class="line">   print(res)</span><br><span class="line">   <span class="comment"># app01.Author.None</span></span><br><span class="line">   print(res.<span class="built_in">all</span>())</span><br><span class="line">   <span class="comment"># &lt;QuerySet [&lt;Author: Author object (1)&gt;, &lt;Author: Author object (3)&gt;]&gt;</span></span><br><span class="line">   print(models.Book.objects.<span class="built_in">filter</span>(pk=<span class="number">3</span>).first().authors.<span class="built_in">all</span>())</span><br><span class="line">   <span class="comment"># &lt;QuerySet [&lt;Author: Author object (1)&gt;]&gt;</span></span><br><span class="line">   </span><br><span class="line">   <span class="comment"># 3. 查询作者jason的电话号码</span></span><br><span class="line">   <span class="comment"># 有字段 -&gt; 正向；一对一关系 -&gt; 不用.all()</span></span><br><span class="line">   author_obj = models.Author.objects.<span class="built_in">filter</span>(name=<span class="string">&quot;jason&quot;</span>).first()</span><br><span class="line">   res = author_obj.author_detail</span><br><span class="line">   print(res.phone, res.addr)</span><br><span class="line"></span><br><span class="line">   <span class="comment"># 4. 查询出版社是东方出版社出版的书</span></span><br><span class="line">   <span class="comment"># 无字段 -&gt; 反向；查询一对多关系中多的一方 -&gt; 要.all()</span></span><br><span class="line">   publish_obj = models.Publish.objects.<span class="built_in">filter</span>(name=<span class="string">&#x27;东方出版社&#x27;</span>).first()</span><br><span class="line">   res = publish_obj.book_set  <span class="comment"># app01.Book.None</span></span><br><span class="line">   res = publish_obj.book_set.<span class="built_in">all</span>()</span><br><span class="line">   print(res)</span><br><span class="line"></span><br><span class="line">   <span class="comment"># 5. 查询作者jason写过的书</span></span><br><span class="line">   <span class="comment"># 无字段 -&gt; 反向；多对多关系 -&gt; 要.all()</span></span><br><span class="line">   author_obj = models.Author.objects.<span class="built_in">filter</span>(name=<span class="string">&#x27;jason&#x27;</span>).first()</span><br><span class="line">   res = author_obj.book_set  <span class="comment"># app01.Book.None</span></span><br><span class="line">   res = author_obj.book_set.<span class="built_in">all</span>()</span><br><span class="line">   print(res)</span><br><span class="line"></span><br><span class="line">   <span class="comment"># 6.查询手机号是110的作者姓名</span></span><br><span class="line">   <span class="comment"># 无字段 -&gt; 反向；一对一关系 -&gt; 不用.all()，不用_set</span></span><br><span class="line">   author_detail_obj = models.AuthorDetail.objects.<span class="built_in">filter</span>(phone=<span class="number">110</span>).first()</span><br><span class="line">   res = author_detail_obj.author</span><br><span class="line">   print(res.name)</span><br></pre></td></tr></table></figure><h3 id="联表查询-基于双下划线的跨表查询"><a href="#联表查询-基于双下划线的跨表查询" class="headerlink" title="联表查询(基于双下划线的跨表查询)"></a>联表查询(基于双下划线的跨表查询)</h3><ul><li>QuerySet要先用int取字典，再用key取对应的数据</li><li>可以放多个查询的键</li><li>__就是用来获得表下的一个字段</li><li>而写到__之前则表示已经进入了另外一个表</li><li>这里非对象时都不需要_set</li><li>可以 __ id 或者 __pk，是等价的</li><li>可以无限制的跨表，正向、反向</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1. 查询jason的手机号和作者姓名</span></span><br><span class="line"><span class="comment"># 有字段 -&gt; 正向；</span></span><br><span class="line">res = models.Author.objects.<span class="built_in">filter</span>(name=<span class="string">&#x27;jason&#x27;</span>).values(<span class="string">&quot;author_detail__phone&quot;</span>, <span class="string">&quot;name&quot;</span>)</span><br><span class="line">print(res[<span class="number">0</span>][<span class="string">&quot;author_detail__phone&quot;</span>])</span><br><span class="line"><span class="comment"># 反向</span></span><br><span class="line">res = models.AuthorDetail.objects.<span class="built_in">filter</span>(author__name=<span class="string">&#x27;jason&#x27;</span>)  <span class="comment"># 拿作者姓名是jason的作者详情</span></span><br><span class="line">res = models.AuthorDetail.objects.<span class="built_in">filter</span>(author__name=<span class="string">&#x27;jason&#x27;</span>).values(<span class="string">&#x27;phone&#x27;</span>, <span class="string">&#x27;author__name&#x27;</span>)</span><br><span class="line">print(res)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2.查询书籍主键为1的出版社名称和书的名称</span></span><br><span class="line"><span class="comment"># 正向，写到publish时就已经到了publish表，主需要__来取这个表下的任意字段</span></span><br><span class="line">res = models.Book.objects.<span class="built_in">filter</span>(pk=<span class="number">1</span>).values(<span class="string">&#x27;title&#x27;</span>, <span class="string">&#x27;publish__name&#x27;</span>)</span><br><span class="line">print(res)</span><br><span class="line"><span class="comment"># 反向</span></span><br><span class="line">res = models.Publish.objects.<span class="built_in">filter</span>(book__pk=<span class="number">1</span>).values(<span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;book__title&#x27;</span>)</span><br><span class="line">print(res)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3.查询书籍主键为1的作者姓名</span></span><br><span class="line"><span class="comment"># 正向</span></span><br><span class="line">res = models.Book.objects.<span class="built_in">filter</span>(pk=<span class="number">1</span>).values(<span class="string">&#x27;authors__name&#x27;</span>)</span><br><span class="line">print(res)</span><br><span class="line"><span class="comment"># 反向</span></span><br><span class="line">res = models.Author.objects.<span class="built_in">filter</span>(book__id=<span class="number">1</span>).values(<span class="string">&#x27;name&#x27;</span>)</span><br><span class="line">print(res)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 4. 查询书籍主键是1的作者的手机号</span></span><br><span class="line">res = models.Book.objects.<span class="built_in">filter</span>(pk=<span class="number">1</span>).values(<span class="string">&quot;authors__author_detail__phone&quot;</span>)</span><br><span class="line">print(res)</span><br></pre></td></tr></table></figure><h3 id="聚合查询-aggregate"><a href="#聚合查询-aggregate" class="headerlink" title="聚合查询(aggregate)"></a>聚合查询(aggregate)</h3><ul><li>只要是跟数据库相关的模块，基本上都在django.db.models里面，如果没有则应该在django.db里面。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> app01 <span class="keyword">import</span> models</span><br><span class="line"><span class="keyword">from</span> django.db.models <span class="keyword">import</span> Max,Min,Sum,Count,Avg</span><br><span class="line">res = models.Book.objects.aggregate(Max(<span class="string">&#x27;price&#x27;</span>),Min(<span class="string">&#x27;price&#x27;</span>),Sum(<span class="string">&#x27;price&#x27;</span>),Count(<span class="string">&#x27;pk&#x27;</span>),Avg(<span class="string">&#x27;price&#x27;</span>))</span><br><span class="line">print(res)</span><br><span class="line"><span class="comment"># &#123;&#x27;price__max&#x27;: Decimal(&#x27;899.23&#x27;), &#x27;price__min&#x27;: Decimal(&#x27;123.23&#x27;), &#x27;price__sum&#x27;: Decimal(&#x27;2466.58&#x27;), &#x27;pk__count&#x27;: 5, &#x27;price__avg&#x27;: Decimal(&#x27;493.316000&#x27;)&#125;</span></span><br></pre></td></tr></table></figure><h3 id="分组查询-annotate"><a href="#分组查询-annotate" class="headerlink" title="分组查询(annotate)"></a>分组查询(annotate)</h3><ul><li>MySQL分组查询特点：分组之后默认只能获取到分组的依据，组内其他字段都无法直接获取了(严格模式，ONLY_FULL_GROUP_BY)</li><li>author和author__pk是等价的，个人认为写全更好</li><li>models后面点什么，就是按什么分组</li><li>author_num是自己定义的临时字段，用来存储统计出来的每本书对应的作者个数</li><li>在使用values创建虚表时，依然可以放入多个字段</li><li>只要orm语句得出的结果还是一个queryset对象，那么就可以继续无限制的点queryset对象封装的方法</li><li>queryset对象就代表一个虚表</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1. 统计每一本书的作者个数</span></span><br><span class="line">   <span class="comment"># 只需要写author就可以了</span></span><br><span class="line">   <span class="comment"># models后面点什么，就是按什么分组</span></span><br><span class="line">   <span class="comment"># author_num是我们自己定义的字段，用来存储统计出来的每本书对应的作者个数</span></span><br><span class="line">   <span class="comment"># 在使用values创建虚表时，依然可以放入多个字段 </span></span><br><span class="line">   res = models.Book.objects.annotate(author_num=Count(<span class="string">&quot;author__pk&quot;</span>)).values(<span class="string">&quot;author_num&quot;</span>, <span class="string">&#x27;title&#x27;</span>, <span class="string">&#x27;author_num&#x27;</span>)</span><br><span class="line">   print(res)</span><br><span class="line">   </span><br><span class="line">   <span class="comment"># 2. 统计每个出版社卖的最便宜的书的价格</span></span><br><span class="line">   <span class="comment"># 按publish分组，反向找book表中price的最小值，作为publish表的min_price临时字段</span></span><br><span class="line">   res = models.Publish.objects.annotate(min_price=Min(<span class="string">&#x27;book__price&#x27;</span>)).values(<span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;min_price&#x27;</span>)</span><br><span class="line">   print(res)</span><br><span class="line">   </span><br><span class="line">   <span class="comment"># 3. 统计不止一个作者的图书</span></span><br><span class="line">   <span class="comment"># 先按照图书分组，求每一本书对应的作者个数</span></span><br><span class="line">   <span class="comment"># 过滤出不止一个作者的图书</span></span><br><span class="line">   res = models.Book.objects.annotate(author_num=Count(<span class="string">&quot;author_id&quot;</span>)) \</span><br><span class="line">       .<span class="built_in">filter</span>(author__num__gt=<span class="number">1</span>) \</span><br><span class="line">       .values(<span class="string">&#x27;title&#x27;</span>, <span class="string">&#x27;author_num&#x27;</span>)</span><br><span class="line">   <span class="comment"># 只要orm语句得出的结果还是一个queryset对象，那么就可以继续无限制的点queryset对象封装的方法</span></span><br><span class="line">   <span class="comment"># queryset对象就代表一个虚表</span></span><br><span class="line">   print(res)</span><br><span class="line">   </span><br><span class="line">   <span class="comment"># 4. 查询每个作者出的书的总价格</span></span><br><span class="line">   res = models.Author.objects.annotate(sum_price=Sum(<span class="string">&#x27;book__price&#x27;</span>)).values(<span class="string">&#x27;name&#x27;</span>, <span class="string">&quot;sum_price&quot;</span>)</span><br><span class="line">   print(res)</span><br><span class="line">   </span><br><span class="line">   <span class="comment"># 5. 按照指定的字段分组，本质也是创造虚表</span></span><br><span class="line">   models.Book.objects.values(<span class="string">&#x27;price&#x27;</span>).annotate()</span><br></pre></td></tr></table></figure><h3 id="F与Q查询"><a href="#F与Q查询" class="headerlink" title="F与Q查询"></a>F与Q查询</h3><h4 id="F"><a href="#F" class="headerlink" title="F"></a>F</h4><ul><li>能够直接获取到表中某个字段对应的数据</li><li>F不能够直接操作字符串</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1. 查询卖出数大于库存数的书籍</span></span><br><span class="line">   <span class="keyword">from</span> django.db.models <span class="keyword">import</span> F</span><br><span class="line">   res = models.Book.objects.<span class="built_in">filter</span>(sale__gt=F(<span class="string">&#x27;store&#x27;</span>))</span><br><span class="line">   print(res)</span><br><span class="line"></span><br><span class="line">   <span class="comment"># 2. 将所有书籍的价格提升500块</span></span><br><span class="line">   models.Book.objects.update(price=F(<span class="string">&#x27;price&#x27;</span>) + <span class="number">500</span>)</span><br><span class="line"></span><br><span class="line">   <span class="comment"># 3. 将所有书的名称后面加上爆款两个字</span></span><br><span class="line">   <span class="comment"># 在操作字符类型的数据的时候，F不能够直接做到字符串的拼接</span></span><br><span class="line">   <span class="keyword">from</span> django.db.models.functions <span class="keyword">import</span> Concat</span><br><span class="line">   <span class="keyword">from</span> django.db.models <span class="keyword">import</span> Value</span><br><span class="line">   <span class="comment"># models.Book.objects.update(title=F(&#x27;title&#x27;) + &#x27;爆款&#x27;)  # 所有的名称会全部变成空白</span></span><br><span class="line">   models.Book.objects.update(title=Concat(F(<span class="string">&#x27;title&#x27;</span>), Value(<span class="string">&#x27;爆款&#x27;</span>)))</span><br></pre></td></tr></table></figure><h4 id="Q"><a href="#Q" class="headerlink" title="Q"></a>Q</h4><ul><li>扩展搜索表达式</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1.查询卖出数大于100或者价格小于600的书籍</span></span><br><span class="line"><span class="comment"># res = models.Book.objects.filter(maichu__gt=100,price__lt=600)  # filter括号内多个参数是and关系</span></span><br><span class="line"><span class="keyword">from</span> django.db.models <span class="keyword">import</span> Q</span><br><span class="line">res = models.Book.objects.<span class="built_in">filter</span>(Q(maichu__gt=<span class="number">100</span>), Q(price__lt=<span class="number">600</span>))  <span class="comment"># Q包裹逗号分割 还是and关系</span></span><br><span class="line">res = models.Book.objects.<span class="built_in">filter</span>(Q(maichu__gt=<span class="number">100</span>) | Q(price__lt=<span class="number">600</span>))  <span class="comment"># | or关系</span></span><br><span class="line">res = models.Book.objects.<span class="built_in">filter</span>(~Q(maichu__gt=<span class="number">100</span>) | Q(price__lt=<span class="number">600</span>))  <span class="comment"># ~ not关系</span></span><br><span class="line">print(res)  <span class="comment"># &lt;QuerySet []&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. Q的高阶用法，将查询条件的左边变成字符串形式</span></span><br><span class="line">q = Q()</span><br><span class="line">q.connector = <span class="string">&#x27;or&#x27;</span>  <span class="comment"># 默认是and关系</span></span><br><span class="line">q.children.append((<span class="string">&#x27;maichu__gt&#x27;</span>, <span class="number">100</span>))</span><br><span class="line">q.children.append((<span class="string">&#x27;price__lt&#x27;</span>, <span class="number">600</span>))</span><br><span class="line">res = models.Book.objects.<span class="built_in">filter</span>(q)</span><br><span class="line">print(res)</span><br></pre></td></tr></table></figure><h2 id="django中如何开启事务"><a href="#django中如何开启事务" class="headerlink" title="django中如何开启事务"></a>django中如何开启事务</h2><ul><li>ACID<ul><li>原子性<ul><li>不可分割的最小单位</li></ul></li><li>一致性<ul><li>跟原子性是相辅相成</li></ul></li><li>隔离性<ul><li>事务之间互相不干扰</li></ul></li><li>持久性<ul><li>事务一旦确认永久生效</li></ul></li></ul></li><li>事务的回滚 <ul><li>rollback</li></ul></li><li>事务的确认<ul><li>commit</li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Django中如何简单地开启事务</span></span><br><span class="line"><span class="keyword">from</span> django.db <span class="keyword">import</span> transaction</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="keyword">with</span> transaction.atomic():</span><br><span class="line">        <span class="comment"># sql1</span></span><br><span class="line">        <span class="comment"># sql2</span></span><br><span class="line">        ...</span><br><span class="line">        <span class="comment"># 在with代码快内书写的所有orm操作都是属于同一个事务</span></span><br><span class="line"><span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">    print(e)</span><br></pre></td></tr></table></figure><h2 id="orm字段及参数"><a href="#orm字段及参数" class="headerlink" title="orm字段及参数"></a>orm字段及参数</h2><h3 id="常用字段及参数"><a href="#常用字段及参数" class="headerlink" title="常用字段及参数"></a>常用字段及参数</h3><ol><li><p>AutoField：主键字段</p><ul><li>primary_key=True</li></ul><p>一般会自动创建，不需要手动设置</p></li><li><p>CharField：varchar</p><ul><li>verbose_name=字段的注释</li><li>max_length=长度</li><li>null=True可以为空</li><li>blank=True可以存空字符串（这两个有区别）</li><li>unique=True唯一</li></ul></li><li><p>IntegerField：int</p></li><li><p>BigIntegerField：bigint</p></li><li><p>DecimalField</p><ul><li>max_digits=允许的最大位数</li><li>decimal_places=小数的最大位数</li></ul></li><li><p>EmailFiled：varchar(254)</p></li><li><p>DateField：date</p><p>DateTimeField：datetime</p><ul><li>auto_now=每次修改数据时更新当前时间</li><li>auto_now_add=只在创建数据时记录当前时间</li></ul></li><li><p>BooleanField：Field</p><p>该字段传布尔值(False/True)，数据库里面存0/1</p></li><li><p>TextField：Field</p><p>该字段可以用来存大段内容(文章、博客…)，没有字数限制</p></li><li><p>FileField：Field</p><ul><li><p>upload_to = “/data/{file}”</p><p>给该字段传一个文件对象，会自动将文件保存到/data目录下，并将文件路径保存到数据库中</p></li></ul></li></ol><blockquote><p>更多字段，直接参考博客:<a href="https://www.cnblogs.com/Dominic-Ji/p/9203990.html%EF%BC%8C%E5%90%8E%E7%BB%AD%E8%A1%A5%E5%85%A8">https://www.cnblogs.com/Dominic-Ji/p/9203990.html，后续补全</a></p></blockquote><h3 id="自定义字段"><a href="#自定义字段" class="headerlink" title="自定义字段"></a>自定义字段</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 定义字段</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyCharField</span>(<span class="params">models.Field</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, max_length, *args, **kwargs</span>):</span></span><br><span class="line">        self.max_length = max_length</span><br><span class="line">        <span class="comment"># 调用父类的init方法</span></span><br><span class="line">        <span class="built_in">super</span>().__init__(max_length=max_length, *args, **kwargs)  <span class="comment"># 一定要是关键字的形式传入</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">db_type</span>(<span class="params">self, connection</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        返回真正的数据类型及各种约束条件</span></span><br><span class="line"><span class="string">        :param connection:</span></span><br><span class="line"><span class="string">        :return:</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;char(%s)&#x27;</span> % self.max_length</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 自定义字段使用</span></span><br><span class="line">myfield = MyCharField(max_length=<span class="number">16</span>, null=<span class="literal">True</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="外键字段及参数"><a href="#外键字段及参数" class="headerlink" title="外键字段及参数"></a>外键字段及参数</h3><ol><li><p>unique=True</p><p>ForeignKey(unique=True)等价于OneToOneField()</p></li><li><p>db_index=True</p><p>为此字段设置索引</p></li><li><p>to</p><p>设置要关联的表</p></li><li><p>to_field</p><p>设置要关联的表的字段，默认关联另外一张的主键字段，并且自动添加_id后缀</p></li><li><p>on_delete</p><p>当删除关联表中的数据时，当前表与其关联的行的行为。</p></li><li><p>related_name</p><p>反向查询使用的字段名，即代替 字段名__set</p></li><li><p>limit_choices_to</p><p>限制选择条件</p></li></ol><h2 id="数据库查询优化"><a href="#数据库查询优化" class="headerlink" title="数据库查询优化"></a>数据库查询优化</h2><h3 id="all"><a href="#all" class="headerlink" title="all()"></a>all()</h3><ul><li><p>orm语句的特点：惰性查询</p><p>如果仅仅只是书写了orm语句，在后面根本没有用到该语句所查询出来的参数，那么orm会自动识别，直接不执行。</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">res = models.Book.objects.<span class="built_in">all</span>()  <span class="comment"># 此时并没有查询数据库</span></span><br><span class="line">print(res)  <span class="comment"># 要用数据了才会走数据库</span></span><br></pre></td></tr></table></figure><h3 id="only"><a href="#only" class="headerlink" title="only()"></a>only()</h3><blockquote><p>只取目标字段</p></blockquote><ul><li>拿到数据对象，这些对象本身只有only中提到的字段参数</li><li>如果调用没有包含的字段，则会重新回到数据库查询</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 获取书籍表中所有书的名字</span></span><br><span class="line">res = models.Book.objects.values(<span class="string">&#x27;title&#x27;</span>)</span><br><span class="line"><span class="keyword">for</span> d <span class="keyword">in</span> res:</span><br><span class="line">    print(d.get(<span class="string">&#x27;title&#x27;</span>))</span><br><span class="line"><span class="comment"># 实现获取数据对象，点title就能够拿到书名，并且没有其他字段</span></span><br><span class="line">res = models.Book.objects.only(<span class="string">&#x27;title&#x27;</span>)</span><br><span class="line">print(res)  <span class="comment"># &lt;QuerySet [&lt;Book: 三国演义爆款&gt;, &lt;Book: 红楼梦爆款&gt;, &lt;Book: 论语爆款&gt;, &lt;Book: 聊斋爆款&gt;, &lt;Book: 老子爆款&gt;]&gt;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> res:</span><br><span class="line">    print(i.title)  <span class="comment"># 点only括号内的字段，不会走数据库</span></span><br><span class="line">    print(i.price)  <span class="comment"># 点only括号内没有的字段，会重新走数据库查询而all()不需要走了</span></span><br></pre></td></tr></table></figure><h3 id="defer"><a href="#defer" class="headerlink" title="defer()"></a>defer()</h3><ul><li>defer与only刚好相反</li><li>defer括号内放的字段不在查询出来的对象里面，查询该字段需要重新走数据库</li><li>而如果查询的是非括号内的字段，则不需要走数据库了</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">res = models.Book.objects.defer(<span class="string">&#x27;title&#x27;</span>)  <span class="comment"># 对象除了没有title属性之外其他的都有</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> res:</span><br><span class="line">    print(i.price)</span><br></pre></td></tr></table></figure><h3 id="select-related"><a href="#select-related" class="headerlink" title="select_related()"></a>select_related()</h3><blockquote><p>跨表操作</p></blockquote><ul><li><p>select_related内部先将book与publish连起来，然后一次性将大虚表的所有数据封装给查询出来的对象</p><p>这个时候对象无论是点击book表的数据还是publish表的数据都无需再走数据库查询了</p></li><li><p>select_related括号内只能放外键字段：一对多、一对一</p><p>不可以多对多</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">   res = models.Book.objects.<span class="built_in">all</span>()</span><br><span class="line">   <span class="keyword">for</span> i <span class="keyword">in</span> res:</span><br><span class="line">       print(i.publish.name)  <span class="comment"># 每循环一次就要走一次数据库查询</span></span><br><span class="line"></span><br><span class="line">   res = models.Book.objects.select_related(<span class="string">&#x27;authors&#x27;</span>)  <span class="comment"># INNER JOIN</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> res:</span><br><span class="line">       print(i.publish.name)  <span class="comment"># 每循环一次就要走一次数据库查询</span></span><br></pre></td></tr></table></figure><h3 id="prefetch-related"><a href="#prefetch-related" class="headerlink" title="prefetch_related()"></a>prefetch_related()</h3><ul><li><p>prefetch_related内部其实就是子查询</p><p>指把内部查询的结果作为外层查询的比较条件</p></li><li><p>两次查询，但不一定就比select_related差，要看实际情况</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">res = models.Book.objects.prefetch_related(<span class="string">&#x27;publish&#x27;</span>)  <span class="comment"># 子查询</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> res:</span><br><span class="line">    print(i.publish.name)</span><br></pre></td></tr></table></figure><h3 id="批量插入"><a href="#批量插入" class="headerlink" title="批量插入"></a>批量插入</h3><p>当批量插入数据的时候，使用orm的<code>bulk_create</code>方法能够大幅减少操作时间</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">ab_pl</span>(<span class="params">request</span>):</span></span><br><span class="line">    <span class="comment"># 1. 逐条插入</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10000</span>):</span><br><span class="line">        models.Book.objects.create(title=<span class="string">&#x27;第%s本书&#x27;</span> % i)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 2. 批量插入</span></span><br><span class="line">    book_list = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">100000</span>):</span><br><span class="line">        book_list.append(models.Book(title=<span class="string">&#x27;第%s本书&#x27;</span> % i))</span><br><span class="line">    models.Book.objects.bulk_create(book_list)</span><br><span class="line">    </span><br><span class="line">    book_queryset = models.Book.objects.<span class="built_in">all</span>()</span><br><span class="line">    <span class="keyword">return</span> render(request, <span class="string">&#x27;ab_pl.html&#x27;</span>, <span class="built_in">locals</span>())</span><br></pre></td></tr></table></figure><h3 id="分页器"><a href="#分页器" class="headerlink" title="分页器"></a>分页器</h3><p>减少同一时间的数据展示量</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">ab_pl</span>(<span class="params">request</span>):</span></span><br><span class="line">    <span class="comment"># 分页</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        cur_page = <span class="built_in">int</span>(request.GET.get(<span class="string">&#x27;cur_page&#x27;</span>, default=<span class="number">1</span>))  <span class="comment"># 如果获取不到当前页码，就展示第一页</span></span><br><span class="line">        per_page = <span class="built_in">int</span>(request.GET.get(<span class="string">&#x27;per_page&#x27;</span>, default=<span class="number">10</span>))  <span class="comment"># 每页展示多少条</span></span><br><span class="line">        start_page = <span class="built_in">int</span>((cur_page - <span class="number">1</span>) * per_page)  <span class="comment"># 起始位置</span></span><br><span class="line">        end_page = <span class="built_in">int</span>(cur_page * per_page)  <span class="comment"># 终止位置</span></span><br><span class="line">    <span class="keyword">except</span> Exception:</span><br><span class="line">        start_page = <span class="number">0</span></span><br><span class="line">        end_page = <span class="number">10</span></span><br><span class="line"></span><br><span class="line">    book_list = models.Book.objects.<span class="built_in">all</span>()</span><br><span class="line"></span><br><span class="line">    page_queryset = book_list[start_page:end_page]</span><br><span class="line">    response = serializers.serialize(<span class="string">&#x27;json&#x27;</span>, page_queryset)</span><br><span class="line">    <span class="keyword">return</span> HttpResponse(response)</span><br></pre></td></tr></table></figure><h2 id="choices参数"><a href="#choices参数" class="headerlink" title="choices参数"></a>choices参数</h2><ul><li>只要某个字段的内容是可以枚举完全的，则可以采用choices参数：<ul><li>学历</li><li>客户来源</li><li>……</li></ul></li><li>元组套元组</li><li>需要保证数据库表中字段类型跟key的数据类型一致</li><li>在数据库中存的是key，value在orm中</li><li>不存在的key直接输出key，存在的key可以通过<code>get_字段_display()</code>转换成value输出</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -&gt; models.py</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span>(<span class="params">models.Model</span>):</span></span><br><span class="line">    username = models.CharField(max_length=<span class="number">32</span>)</span><br><span class="line">    age = models.IntegerField()</span><br><span class="line">    <span class="comment"># 性别</span></span><br><span class="line">    gender_choices = ((<span class="number">1</span>, <span class="string">&#x27;男&#x27;</span>), (<span class="number">2</span>, <span class="string">&#x27;女&#x27;</span>))</span><br><span class="line">    gender = models.SmallIntegerField(choices=gender_choices)</span><br><span class="line"></span><br><span class="line">    score = models.CharField(choices=(</span><br><span class="line">        (<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;优秀&#x27;</span>),</span><br><span class="line">        (<span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;良好&#x27;</span>),</span><br><span class="line">        (<span class="string">&#x27;C&#x27;</span>, <span class="string">&#x27;及格&#x27;</span>),</span><br><span class="line">        (<span class="string">&#x27;D&#x27;</span>, <span class="string">&#x27;不合格&#x27;</span>),</span><br><span class="line">    ), null=<span class="literal">True</span>)  <span class="comment"># 保证字段类型跟列举出来的元组第一个数据类型一致</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># -&gt; test.py</span></span><br><span class="line">    <span class="comment"># 存的时候，没有列举出来的数字也能存，范围还是按照字段类型决定</span></span><br><span class="line">    models.User.objects.create(username=<span class="string">&#x27;jason&#x27;</span>, age=<span class="number">18</span>, gender=<span class="number">1</span>)</span><br><span class="line">    models.User.objects.create(username=<span class="string">&#x27;egon&#x27;</span>, age=<span class="number">85</span>, gender=<span class="number">2</span>)</span><br><span class="line">    models.User.objects.create(username=<span class="string">&#x27;tank&#x27;</span>, age=<span class="number">40</span>, gender=<span class="number">3</span>)</span><br><span class="line">    models.User.objects.create(username=<span class="string">&#x27;tony&#x27;</span>, age=<span class="number">45</span>, gender=<span class="number">4</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 取</span></span><br><span class="line">    user_obj = models.User.objects.<span class="built_in">filter</span>(pk=<span class="number">1</span>).first()</span><br><span class="line">    print(user_obj.gender)  <span class="comment"># 数据库中存储的key</span></span><br><span class="line">    print(user_obj.get_gender_display())  <span class="comment"># 对于choices参数的字段，通过get_字段名_display()获取对应的值</span></span><br><span class="line">    user_obj = models.User.objects.<span class="built_in">filter</span>(pk=<span class="number">4</span>).first()</span><br><span class="line">    print(user_obj.get_gender_display())  <span class="comment"># 如果没有对应关系，那么返回字段存储的原key</span></span><br></pre></td></tr></table></figure><h2 id="MTV与MVC模型"><a href="#MTV与MVC模型" class="headerlink" title="MTV与MVC模型"></a>MTV与MVC模型</h2><ul><li>MTV：Django号称是MTV模型<ul><li>M：models</li><li>T：templates</li><li>V：views</li></ul></li><li>MVC：其实django本质也是MVC<ul><li>M：models</li><li>V：views</li><li>C：controller</li></ul></li><li>vue框架：MVVM模型</li></ul><h2 id="多对多三种创建方式"><a href="#多对多三种创建方式" class="headerlink" title="多对多三种创建方式"></a>多对多三种创建方式</h2><h3 id="全自动"><a href="#全自动" class="headerlink" title="全自动"></a>全自动</h3><ul><li>利用orm自动帮我们创建第三张关系表</li><li>优点：<ul><li>不需要写代码，非常方便</li><li>支持orm提供操作第三张关系表的方法</li></ul></li><li>不足之处：<ul><li>第三张关系表的扩展性极差：没有办法额外添加字段</li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Book</span>(<span class="params">models.Model</span>):</span></span><br><span class="line">    name = models.CharField(max_length=<span class="number">32</span>)</span><br><span class="line">    authors = models.ManyToManyField(to=<span class="string">&#x27;Author&#x27;</span>)</span><br><span class="line">    </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Author</span>(<span class="params">models.Model</span>):</span></span><br><span class="line">    name = models.CharField(max_length=<span class="number">32</span>)</span><br><span class="line">    </span><br></pre></td></tr></table></figure><h3 id="纯手动"><a href="#纯手动" class="headerlink" title="纯手动"></a>纯手动</h3><ul><li>优点：<ul><li>第三张表完全取决于你自己进行额外的扩展</li></ul></li><li>不足之处：<ul><li>需要写的代码较多</li><li>不能够使用orm提供的简单方法</li></ul></li></ul><p>不建议使用该方式。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Book</span>(<span class="params">models.Model</span>):</span></span><br><span class="line">    name = models.CharField(max_length=<span class="number">32</span>)</span><br><span class="line">    </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Author</span>(<span class="params">models.Model</span>):</span></span><br><span class="line">    name = models.CharField(max_length=<span class="number">32</span>)</span><br><span class="line">  </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Book2Author</span>(<span class="params">models.Model</span>):</span></span><br><span class="line">    book_id = models.ForeignKey(to=<span class="string">&#x27;Book&#x27;</span>)</span><br><span class="line">    author_id = models.ForeignKey(to=<span class="string">&#x27;Author&#x27;</span>)</span><br><span class="line">    </span><br></pre></td></tr></table></figure><h3 id="半自动"><a href="#半自动" class="headerlink" title="半自动"></a>半自动</h3><ul><li>可以使用orm的正反向查询</li><li>但是没法使用add、set、remove、clear这四个方法</li><li>多对多表关系可以放在任何一方</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Book</span>(<span class="params">models.Model</span>):</span></span><br><span class="line">    name = models.CharField(max_length=<span class="number">32</span>)</span><br><span class="line">    authors = models.ManyToManyField(to=<span class="string">&#x27;Author&#x27;</span>,</span><br><span class="line">                                     through=<span class="string">&#x27;Book2Author&#x27;</span>,</span><br><span class="line">                                     through_fields=(<span class="string">&#x27;book&#x27;</span>,<span class="string">&#x27;author&#x27;</span>)</span><br><span class="line">                                     )  <span class="comment"># 将当前表名放在元组第一位</span></span><br><span class="line">    </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Author</span>(<span class="params">models.Model</span>):</span></span><br><span class="line">    name = models.CharField(max_length=<span class="number">32</span>)</span><br><span class="line">    <span class="comment"># books = models.ManyToManyField(to=&#x27;Book&#x27;,</span></span><br><span class="line">    <span class="comment">#                                  through=&#x27;Book2Author&#x27;,</span></span><br><span class="line">    <span class="comment">#                                  through_fields=(&#x27;author&#x27;, &#x27;book&#x27;)</span></span><br><span class="line">    <span class="comment">#                                  )</span></span><br><span class="line">    </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Book2Author</span>(<span class="params">models.Model</span>):</span></span><br><span class="line">    book = models.ForeignKey(to=<span class="string">&#x27;Book&#x27;</span>)  <span class="comment"># 外键默认加id，这里不要加，包括through_fields</span></span><br><span class="line">    author = models.ForeignKey(to=<span class="string">&#x27;Author&#x27;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Django </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Django-Part3</title>
      <link href="/2021/08/Django-Part3/"/>
      <url>/2021/08/Django-Part3/</url>
      
        <content type="html"><![CDATA[<h1 id="Django-Part3——视图层"><a href="#Django-Part3——视图层" class="headerlink" title="Django-Part3——视图层"></a>Django-Part3——视图层</h1><p>[TOC]</p><h2 id="三板斧"><a href="#三板斧" class="headerlink" title="三板斧"></a>三板斧</h2><h3 id="HttpResponse"><a href="#HttpResponse" class="headerlink" title="HttpResponse"></a>HttpResponse</h3><ul><li>HttpResponse：返回字符串类型</li><li>render：返回html页面，并且在返回给浏览器之前还可以给html文件传值</li><li>redirect：重定向</li></ul><blockquote><p>视图函数必须要返回一个HttpResponse对象</p></blockquote><h3 id="render"><a href="#render" class="headerlink" title="render"></a>render</h3><ul><li>返回html文件</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test</span>(<span class="params">request</span>):</span></span><br><span class="line">    <span class="keyword">from</span> django.template <span class="keyword">import</span> Template, Context</span><br><span class="line">    res = Template(<span class="string">&#x27;&lt;h1&gt;&#123;&#123; user &#125;&#125;&lt;/h1&gt;&#x27;</span>)  <span class="comment"># 模板对象</span></span><br><span class="line">    con = Context(&#123;<span class="string">&#x27;user&#x27;</span>: &#123;<span class="string">&#x27;username&#x27;</span>: <span class="string">&#x27;jason&#x27;</span>, <span class="string">&#x27;password&#x27;</span>: <span class="number">123</span>&#125;&#125;)  <span class="comment"># 动态确定模板变量的内容，此处是&#123;&#x27;username&#x27;:&#x27;jason&#x27;, &#x27;password&#x27;:123&#125;</span></span><br><span class="line">    ret = res.render(con)  <span class="comment"># 将模板和动态内容组装</span></span><br><span class="line">    print(ret)  <span class="comment"># &lt;h1&gt;&#123;&amp;#x27;username&amp;#x27;: &amp;#x27;jason&amp;#x27;, &amp;#x27;password&amp;#x27;: 123&#125;&lt;/h1&gt;</span></span><br><span class="line">    print(<span class="built_in">type</span>(ret))  <span class="comment"># &lt;class &#x27;django.utils.safestring.SafeString&#x27;&gt;</span></span><br><span class="line">    <span class="keyword">return</span> HttpResponse(ret)</span><br></pre></td></tr></table></figure><h3 id="redirect"><a href="#redirect" class="headerlink" title="redirect"></a>redirect</h3><ul><li><p>重定向至任意网站<br><code>return redirect(&#39;https://www.mzitu.com/&#39;)</code></p></li><li><p>跳转本站不需要加https</p><p><code>return redirect(&#39;/home/&#39;)</code> </p></li></ul><h2 id="JsonResponse"><a href="#JsonResponse" class="headerlink" title="JsonResponse"></a>JsonResponse</h2><ul><li>前后端数据交互需要使用json作为过渡，实现跨语言传输数据。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">ab_json</span>(<span class="params">request</span>):</span></span><br><span class="line">    user_dict = &#123;<span class="string">&#x27;username&#x27;</span>: <span class="string">&#x27;jason好帅哦,我好喜欢!&#x27;</span>, <span class="string">&#x27;password&#x27;</span>: <span class="string">&#x27;123&#x27;</span>, <span class="string">&#x27;hobby&#x27;</span>: <span class="string">&#x27;girl&#x27;</span>&#125;</span><br><span class="line">    l = [<span class="number">111</span>,<span class="number">222</span>,<span class="number">333</span>,<span class="number">444</span>,<span class="number">555</span>]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># import json  # 先转成json格式字符串</span></span><br><span class="line">    <span class="comment"># json_str = json.dumps(user_dict, ensure_ascii=False)  # 禁止内部转码</span></span><br><span class="line">    <span class="comment"># return HttpResponse(json_str)  # 将该字符串作为参数，返回HttpResponse对象</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">from</span> django.http <span class="keyword">import</span> JsonResponse</span><br><span class="line">    <span class="keyword">return</span> JsonResponse(user_dict, json_dumps_params=&#123;<span class="string">&quot;ensure_ascii&quot;</span>: <span class="literal">False</span>&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 报错：In order to allow non-dict objects to be serialized set the safe parameter to False.</span></span><br><span class="line">    <span class="comment"># return JsonResponse(l, safe=False)  </span></span><br></pre></td></tr></table></figure><ul><li>指将字典打散成关键字的形式</li><li>默认只能序列化字典，序列化其他需要加safe参数</li></ul><blockquote><p>很多时候都可以通过读源码来掌握用法</p></blockquote><h2 id="上传文件与后端操作"><a href="#上传文件与后端操作" class="headerlink" title="上传文件与后端操作"></a>上传文件与后端操作</h2><h3 id="使用form表单上传"><a href="#使用form表单上传" class="headerlink" title="使用form表单上传"></a>使用form表单上传</h3><p>在 .html 中：</p><ol><li>method 必须指定成 post</li><li>enctype 必须换成 multipart/formdata</li></ol><h3 id="使用requests模块上传"><a href="#使用requests模块上传" class="headerlink" title="使用requests模块上传"></a>使用requests模块上传</h3><ul><li>Requests 使得上传多部分编码文件变得很简单 </li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>url = <span class="string">&#x27;http://httpbin.org/post&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>files = &#123;<span class="string">&#x27;file&#x27;</span>: <span class="built_in">open</span>(<span class="string">&#x27;report.xls&#x27;</span>, <span class="string">&#x27;rb&#x27;</span>)&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>r = requests.post(url, files=files)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>r.text</span><br><span class="line">&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="string">&quot;files&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;file&quot;</span>: <span class="string">&quot;&lt;censored...binary...data&gt;&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>你可以显式地设置文件名，文件类型和请求头</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>url = <span class="string">&#x27;http://httpbin.org/post&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>files = &#123;<span class="string">&#x27;file&#x27;</span>: (<span class="string">&#x27;report.xls&#x27;</span>, <span class="built_in">open</span>(<span class="string">&#x27;report.xls&#x27;</span>, <span class="string">&#x27;rb&#x27;</span>), <span class="string">&#x27;application/vnd.ms-excel&#x27;</span>, &#123;<span class="string">&#x27;Expires&#x27;</span>: <span class="string">&#x27;0&#x27;</span>&#125;)&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>r = requests.post(url, files=files)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>r.text</span><br><span class="line">&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="string">&quot;files&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;file&quot;</span>: <span class="string">&quot;&lt;censored...binary...data&gt;&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>也可以发送作为文件来接收的字符串</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>url = <span class="string">&#x27;http://httpbin.org/post&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>files = &#123;<span class="string">&#x27;file&#x27;</span>: (<span class="string">&#x27;report.csv&#x27;</span>, <span class="string">&#x27;some,data,to,send\nanother,row,to,send\n&#x27;</span>)&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>r = requests.post(url, files=files)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>r.text</span><br><span class="line">&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="string">&quot;files&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;file&quot;</span>: <span class="string">&quot;some,data,to,send\\nanother,row,to,send\\n&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>把多个文件组织到一个元组的列表中，其中元组结构为 (form_field_name, file_info)</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">data = &#123;<span class="string">&#x27;ts_id&#x27;</span>: tsid&#125;</span><br><span class="line">files = [(<span class="string">&#x27;images&#x27;</span>, (<span class="string">&#x27;1.png&#x27;</span>, <span class="built_in">open</span>(<span class="string">&#x27;/home/1.png&#x27;</span>, <span class="string">&#x27;rb&#x27;</span>), <span class="string">&#x27;image/png&#x27;</span>)),</span><br><span class="line">         (<span class="string">&#x27;images&#x27;</span>, (<span class="string">&#x27;2.png&#x27;</span>, <span class="built_in">open</span>(<span class="string">&#x27;/home/2.png&#x27;</span>, <span class="string">&#x27;rb&#x27;</span>), <span class="string">&#x27;image/png&#x27;</span>))]</span><br><span class="line">r = requests.post(url, data=data, files=files)</span><br><span class="line"><span class="built_in">print</span> r.text</span><br></pre></td></tr></table></figure><h3 id="使用request接收文件"><a href="#使用request接收文件" class="headerlink" title="使用request接收文件"></a>使用request接收文件</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">ab_file</span>(<span class="params">request</span>):</span></span><br><span class="line">    <span class="keyword">if</span> request.method == <span class="string">&#x27;POST&#x27;</span>:</span><br><span class="line">        print(request.POST)  <span class="comment"># 只能获取普通的键值对数据，文件不行 &lt;QueryDict: &#123;&#x27;username&#x27;: [&#x27;&#x27;]&#125;&gt;</span></span><br><span class="line">        print(request.FILES)  <span class="comment"># 获取文件数据 &lt;MultiValueDict: &#123;&#x27;file&#x27;: [&lt;InMemoryUploadedFile: 4101021694766.jpg (image/jpeg)&gt;]&#125;&gt;</span></span><br><span class="line">        file_obj = request.FILES.get(<span class="string">&#x27;file&#x27;</span>)  <span class="comment"># 获取文件对象</span></span><br><span class="line">        print(file_obj.name)  <span class="comment"># 4101021694766.jpg</span></span><br><span class="line">        <span class="keyword">with</span> <span class="built_in">open</span>(file_obj.name, <span class="string">&#x27;wb&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">            <span class="keyword">for</span> line <span class="keyword">in</span> file_obj.chunks():  <span class="comment"># 推荐加上chunks方法，两者几乎等效</span></span><br><span class="line">                f.write(line)</span><br><span class="line">    <span class="keyword">return</span> render(request,<span class="string">&#x27;form.html&#x27;</span>)</span><br></pre></td></tr></table></figure><ul><li>接收保存多个文件</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> werkzeug.utils <span class="keyword">import</span> secure_filename</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">upload_file</span>(<span class="params">request</span>):</span></span><br><span class="line">    <span class="keyword">if</span> request.method == <span class="string">&#x27;POST&#x27;</span>:</span><br><span class="line">        uploaded_files = request.FILES.getlist(<span class="string">&quot;images&quot;</span>)  <span class="comment"># 获取相同标签</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="keyword">for</span> file_obj <span class="keyword">in</span> uploaded_files:</span><br><span class="line">                file_name = secure_filename(file_obj.name)</span><br><span class="line">                handle_uploaded_file(os.path.join(file_name), file_obj)</span><br><span class="line">            result_json = &#123;<span class="string">&quot;msg&quot;</span>: <span class="string">&quot;success&quot;</span>&#125;</span><br><span class="line">        <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">            result_json = &#123;<span class="string">&quot;msg&quot;</span>: <span class="built_in">str</span>(e)&#125;</span><br><span class="line">        <span class="keyword">return</span> JsonResponse(result_json, safe=<span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">handle_uploaded_file</span>(<span class="params">file_name, file_obj</span>):</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">with</span> <span class="built_in">open</span>(file_name, <span class="string">&#x27;wb&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">            <span class="keyword">for</span> chunk <span class="keyword">in</span> file_obj.chunks():</span><br><span class="line">                f.write(chunk)</span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">        <span class="keyword">raise</span> Exception(<span class="string">&#x27;save %s failed: %s&#x27;</span> % (file_name, <span class="built_in">str</span>(e)))</span><br></pre></td></tr></table></figure><h2 id="request对象方法"><a href="#request对象方法" class="headerlink" title="request对象方法"></a>request对象方法</h2><ul><li><code>get</code>请求携带的数据是有大小限制的，而<code>post</code>请求则没有限制。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">login</span>(<span class="params">request</span>):</span></span><br><span class="line">    <span class="comment"># 视图函数必须要接受一个形参request</span></span><br><span class="line">    <span class="keyword">if</span> request.method == <span class="string">&#x27;POST&#x27;</span>:  <span class="comment"># 返回请求方式 并且是全大写的字符串形式  &lt;class &#x27;str&#x27;&gt;</span></span><br><span class="line">        <span class="keyword">return</span> HttpResponse(<span class="string">&quot;收到了 宝贝&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> render(request, <span class="string">&#x27;login.html&#x27;</span>)</span><br></pre></td></tr></table></figure><blockquote><ul><li>对于<code>get</code>请求和<code>post</code>请求应该有不同的处理机制</li><li>对<code>post</code>做特殊处理，而将<code>request</code>放置在<code>if</code>围绕之外，提高可阅读性</li></ul></blockquote><ol><li><code>request.method</code>：返回请求方式，并且是全大写的字符串形式  &lt;class ‘str’&gt;</li><li><code>request.POST</code>：获取用户post请求提交的普通数据不包含文件</li><li><code>request.POST.get()</code>：只获取列表最后一个元素</li><li><code>request.POST.getlist()</code>：直接将列表取出</li><li><code>request.GET</code>：获取用户提交的get请求数据</li><li><code>request.GET.get()</code>：只获取列表最后一个元素</li><li><code>request.GET.getlist()</code>：直接将列表取出</li><li><code>request.FILES.get()</code>：用键取出对应的文件，是以字典形式封装好的</li><li><code>request.body</code>：发过来的原生二进制数据</li><li><code>request.path_info</code>：获取url(例如<code>/app01/ab_file/</code>)，和request.path是等效的</li><li><code>request.get_full_path()</code>：获取完整的url及问号后面的参数 </li></ol><blockquote><p>可以使用以下装饰器来指定请求类型：</p><ol><li>@require_http_methods([“GET”])</li><li>@require_http_methods([“POST”])</li></ol></blockquote><h2 id="FBV与CBV"><a href="#FBV与CBV" class="headerlink" title="FBV与CBV"></a>FBV与CBV</h2><p>视图函数既可以是 函数 FBV（function base views），也可以是 类 CBV（class base views）。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># FBV</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span>(<span class="params">request</span>):</span></span><br><span class="line"><span class="keyword">return</span> HttpResponse(<span class="string">&#x27;index&#x27;</span>)</span><br><span class="line"><span class="comment"># FBV路由</span></span><br><span class="line">path(<span class="string">&quot;login/&quot;</span>, views.login)</span><br><span class="line"></span><br><span class="line"><span class="comment"># CBV</span></span><br><span class="line"><span class="keyword">from</span> django.views <span class="keyword">import</span> View</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyLogin</span>(<span class="params">View</span>):</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get</span>(<span class="params">self,request</span>):</span></span><br><span class="line"><span class="keyword">return</span> render(request, <span class="string">&#x27;form.html&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">post</span>(<span class="params">self,request</span>):</span></span><br><span class="line">        <span class="keyword">return</span> HttpResponse(<span class="string">&#x27;post方法&#x27;</span>)</span><br><span class="line"><span class="comment"># CBV路由</span></span><br><span class="line">url(<span class="string">r&#x27;^login/&#x27;</span>, views.MyLogin.as_view())</span><br></pre></td></tr></table></figure><h3 id="CBV源码剖析"><a href="#CBV源码剖析" class="headerlink" title="CBV源码剖析"></a>CBV源码剖析</h3><ul><li>首先，不建议自己修改源码</li><li>函数名/方法名，加括号执行优先级最高，例如views.MyLogin.as_view()会立刻执行as_view()方法</li><li>CBV与FBV在路由匹配上本质是一样的，都是路由对应函数内存地址。</li><li>在没有实例的情况下使用函数，则只可能使用@staicmethod或者@classmethod</li><li>在看python源码的时候，一定要时刻提醒自己面向对象属性方法查找顺序：<ul><li>先从对象自己找</li><li>再去产生对象的类里面找</li><li>之后再去父类找</li><li>…</li></ul></li><li>反射 getattr()</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 突破口在urls.py</span></span><br><span class="line">url(<span class="string">r&#x27;^login/&#x27;</span>, views.MyLogin.as_view())</span><br><span class="line">url(<span class="string">r&#x27;^login/&#x27;</span>, views.view)</span><br><span class="line"><span class="comment"># CBV与FBV在路由匹配上本质是一样的，都是路由对应函数内存地址</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">函数名/方法名 加括号执行优先级最高</span></span><br><span class="line"><span class="string">猜测：</span></span><br><span class="line"><span class="string">    as_view()</span></span><br><span class="line"><span class="string">        要么是被@staicmethod修饰的静态方法</span></span><br><span class="line"><span class="string">        要么是被@classmethod修饰的类方法  正确</span></span><br><span class="line"><span class="string">        </span></span><br><span class="line"><span class="string">    @classonlymethod</span></span><br><span class="line"><span class="string">    def as_view(cls, **initkwargs):</span></span><br><span class="line"><span class="string">        pass</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @classonlymethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">as_view</span>(<span class="params">cls, **initkwargs</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        cls就是我们自己写的类   MyCBV</span></span><br><span class="line"><span class="string">        Main entry point for a request-response process.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">view</span>(<span class="params">request, *args, **kwargs</span>):</span></span><br><span class="line">            self = cls(**initkwargs)  <span class="comment"># cls是我们自己写的类</span></span><br><span class="line">            <span class="comment"># self = MyLogin(**initkwargs)  产生一个我们自己写的类的对象</span></span><br><span class="line">            <span class="keyword">return</span> self.dispatch(request, *args, **kwargs)</span><br><span class="line">            <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">            以后你们会经常需要看源码 但是在看python源码的时候 一定要时刻提醒自己面向对象属性方法查找顺序</span></span><br><span class="line"><span class="string">                先从对象自己找</span></span><br><span class="line"><span class="string">                再去产生对象的类里面找</span></span><br><span class="line"><span class="string">                之后再去父类找</span></span><br><span class="line"><span class="string">                ...</span></span><br><span class="line"><span class="string">            总结:看源码只要看到了self点一个东西，一定要问你自己当前这个self到底是谁</span></span><br><span class="line"><span class="string">            &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> view</span><br><span class="line">      </span><br><span class="line"><span class="comment"># CBV的精髓</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dispatch</span>(<span class="params">self, request, *args, **kwargs</span>):</span></span><br><span class="line">        <span class="comment"># 获取当前请求的小写格式 然后比对当前请求方式是否合法</span></span><br><span class="line">        <span class="comment"># get请求为例</span></span><br><span class="line">        <span class="comment"># post请求</span></span><br><span class="line">        <span class="keyword">if</span> request.method.lower() <span class="keyword">in</span> self.http_method_names:</span><br><span class="line">            handler = <span class="built_in">getattr</span>(self, request.method.lower(), self.http_method_not_allowed)</span><br><span class="line">            <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">            反射:通过字符串来操作对象的属性或者方法</span></span><br><span class="line"><span class="string">                handler = getattr(自己写的类产生的对象, &#x27;get&#x27;,当找不到get属性或者方法的时候就会用第三个参数)</span></span><br><span class="line"><span class="string">                handler = 我们自己写的类里面的get方法</span></span><br><span class="line"><span class="string">            &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            handler = self.http_method_not_allowed</span><br><span class="line">        <span class="keyword">return</span> handler(request, *args, **kwargs)  <span class="comment"># 调用get方法</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 要求掌握到不看源码也能够描述出CBV的内部执行流程</span></span><br></pre></td></tr></table></figure><h2 id="模版语法"><a href="#模版语法" class="headerlink" title="模版语法"></a>模版语法</h2>###  传值- {{ }}:变量相关- {% %}：逻辑相关- 传递函数名会自动加括号调用，但是模版语法不支持给函数传额外的参数- 传类名的时候也会自动加括号调用(实例化)- 内部将自动判断出当前的变量名是否可以加括号调用，如果可以就会自动执行。针对的是函数名和类名，不针对对象的call方法。- 对象被展示到html页面上，就类似于执行了打印操作也会触发str方法- django模版语法的取值只能采用句点符`.`，即可以点键也可以点索引，也可以两者混用。<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -&gt; views.py</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span>(<span class="params">request</span>):</span></span><br><span class="line">    <span class="comment"># 模版语法可以传递的后端python数据类型</span></span><br><span class="line">    n = <span class="number">123</span></span><br><span class="line">    f = <span class="number">11.11</span></span><br><span class="line">    s = <span class="string">&#x27;我也想奔现&#x27;</span></span><br><span class="line">    b = <span class="literal">True</span></span><br><span class="line">    l = [<span class="string">&#x27;小红&#x27;</span>, <span class="string">&#x27;姗姗&#x27;</span>, <span class="string">&#x27;花花&#x27;</span>, <span class="string">&#x27;茹茹&#x27;</span>]</span><br><span class="line">    t = (<span class="number">111</span>,<span class="number">222</span>,<span class="number">333</span>,<span class="number">444</span>)</span><br><span class="line">    d = &#123;<span class="string">&#x27;username&#x27;</span>:<span class="string">&#x27;jason&#x27;</span>, <span class="string">&#x27;age&#x27;</span>:<span class="number">18</span>, <span class="string">&#x27;info&#x27;</span>:<span class="string">&#x27;这个人有点意思&#x27;</span>&#125;</span><br><span class="line">    se = &#123;<span class="string">&#x27;晶晶&#x27;</span>, <span class="string">&#x27;洋洋&#x27;</span>, <span class="string">&#x27;嘤嘤&#x27;</span>&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">func</span>():</span></span><br><span class="line">        print(<span class="string">&#x27;我被执行了&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;你的另一半在等你&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">MyClass</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">get_self</span>(<span class="params">self</span>):</span></span><br><span class="line">            <span class="keyword">return</span> <span class="string">&#x27;self&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">        @staticmethod</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">get_func</span>():</span></span><br><span class="line">            <span class="keyword">return</span> <span class="string">&#x27;func&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">        @classmethod</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">get_class</span>(<span class="params">cls</span>):</span></span><br><span class="line">            <span class="keyword">return</span> <span class="string">&#x27;cls&#x27;</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 对象被展示到html页面上，就类似于执行了打印操作也会触发__str__方法</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">__str__</span>(<span class="params">self</span>):</span></span><br><span class="line">            <span class="keyword">return</span> <span class="string">&#x27;到底会不会？&#x27;</span>  </span><br><span class="line">        </span><br><span class="line">    obj = MyClass()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># return render(request,&#x27;index.html&#x27;,&#123;&#125;)  # 一个个传</span></span><br><span class="line">    <span class="keyword">return</span> render(request,<span class="string">&#x27;index.html&#x27;</span>,<span class="built_in">locals</span>())</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"># -&gt; .html</span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123; n &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123; f &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123; s &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123; b &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123; l &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123; d &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123; t &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123; se &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123; func &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123; MyClass &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123; obj &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123; obj.get_self &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123; obj.get_func &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123; obj.get_class &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"># django模版语法的取值 是固定的格式 只能采用“句点符” .</span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123; d.username &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123; l.0 &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123; d.hobby.3.info &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>### 过滤器- 过滤器就类似于是模版语法的内置方法- 基本语法：{{数据|过滤器:参数}}- 过滤器只能最多有两个参数- 在全栈项目的时候，前端代码不一定非要在前端页面书写，也可以现在先在后端写好，然后传递给前端页面。<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>过滤器<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>统计长度:&#123;&#123; s|length &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>默认值(True则展示|前的值, False则展示default值):&#123;&#123; b|default:&#x27;啥也不是&#x27; &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>文件大小:&#123;&#123; file_size|filesizeformat &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>日期格式化:&#123;&#123; current_time|date:&#x27;Y-m-d H:i:s&#x27; &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>切片操作(支持步长):&#123;&#123; l|slice:&#x27;0:4:2&#x27; &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>切取字符(包含三个点):&#123;&#123; info|truncatechars:9 &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>切取词段(不包含三个点 按照空格切):&#123;&#123; egl|truncatewords:9 &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>切取词段(不包含三个点 按照空格切):&#123;&#123; info|truncatewords:9 &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>移除特定的字符:&#123;&#123; msg|cut:&#x27; &#x27; &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>拼接操作:&#123;&#123; l|join:&#x27;$&#x27; &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>拼接操作(加法):&#123;&#123; n|add:10 &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>拼接操作(加法):&#123;&#123; s|add:msg &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>转义:&#123;&#123; hhh|safe &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>转义:&#123;&#123; sss|safe &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>转义:&#123;&#123; res &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span>(<span class="params">request</span>):</span></span><br><span class="line">    <span class="comment"># 模版语法可以传递的后端python数据类型</span></span><br><span class="line">    n = <span class="number">123</span></span><br><span class="line">    f = <span class="number">11.11</span></span><br><span class="line">    s = <span class="string">&#x27;我也想奔现&#x27;</span></span><br><span class="line">    b = <span class="literal">False</span></span><br><span class="line">    l = [<span class="string">&#x27;小红&#x27;</span>, <span class="string">&#x27;姗姗&#x27;</span>, <span class="string">&#x27;花花&#x27;</span>, <span class="string">&#x27;茹茹&#x27;</span>, <span class="string">&#x27;敏敏&#x27;</span>, <span class="string">&#x27;新新&#x27;</span>]</span><br><span class="line">    t = (<span class="number">111</span>, <span class="number">222</span>, <span class="number">333</span>, <span class="number">444</span>)</span><br><span class="line">    d = &#123;<span class="string">&#x27;username&#x27;</span>: <span class="string">&#x27;jason&#x27;</span>, <span class="string">&#x27;age&#x27;</span>: <span class="number">18</span>, <span class="string">&#x27;info&#x27;</span>: <span class="string">&#x27;这个人有点意思&#x27;</span>, <span class="string">&#x27;hobby&#x27;</span>: [<span class="number">111</span>, <span class="number">222</span>, <span class="number">333</span>, &#123;<span class="string">&#x27;info&#x27;</span>: <span class="string">&#x27;NB&#x27;</span>&#125;]&#125;</span><br><span class="line">    se = &#123;<span class="string">&#x27;晶晶&#x27;</span>, <span class="string">&#x27;洋洋&#x27;</span>, <span class="string">&#x27;嘤嘤&#x27;</span>&#125;</span><br><span class="line">    lll = []</span><br><span class="line">    file_size = <span class="number">123123112</span></span><br><span class="line">    <span class="keyword">import</span> datetime</span><br><span class="line">    current_time = datetime.datetime.now()</span><br><span class="line">    info = <span class="string">&#x27;本 文 始 发 于 个 人 公 众 号： ...&#x27;</span></span><br><span class="line">    egl = <span class="string">&#x27;my name is jason my age is 18 and i am from China&#x27;</span></span><br><span class="line">    msg = <span class="string">&#x27;I Love You And You?&#x27;</span></span><br><span class="line">    hhh = <span class="string">&#x27;&lt;h1&gt;敏敏&lt;/h1&gt;&#x27;</span></span><br><span class="line">    sss = <span class="string">&#x27;&lt;script&gt;alert(123)&lt;/script&gt;&#x27;</span></span><br><span class="line">    <span class="comment"># 后端转义字符串</span></span><br><span class="line">    <span class="keyword">from</span> django.utils.safestring <span class="keyword">import</span> mark_safe</span><br><span class="line">    res = mark_safe(<span class="string">&#x27;&lt;h1&gt;新新&lt;/h1&gt;&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> render(request, <span class="string">&#x27;index.html&#x27;</span>, <span class="built_in">locals</span>())  <span class="comment"># 返回所有变量的命名空间</span></span><br></pre></td></tr></table></figure>### 标签- 使用Tab键快速补全#### for循环<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;#for循环#&#125;</span><br><span class="line">&#123;% for foo in l %&#125;</span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123; forloop &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">&#123;#  &#123;&#x27;parentloop&#x27;: &#123;&#125;, &#x27;counter0&#x27;: 0, &#x27;counter&#x27;: 1, &#x27;revcounter&#x27;: 6, &#x27;revcounter0&#x27;: 5, &#x27;first&#x27;: True, &#x27;last&#x27;: False&#125;#&#125;</span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123; foo &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">&#123;% endfor %&#125;</span><br></pre></td></tr></table></figure>#### if判断<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;#if判断#&#125;</span><br><span class="line">&#123;% if b %&#125;</span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>baby<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">&#123;% elif s %&#125;</span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>都来把<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">&#123;% else %&#125;</span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>老baby<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">&#123;% endif %&#125;</span><br></pre></td></tr></table></figure>#### for与if混合使用<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#123;#for与if混合使用#&#125;</span><br><span class="line">&#123;% for foo in lll %&#125;</span><br><span class="line">&#123;% if forloop.first %&#125;</span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>这是我的第一次<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">&#123;% elif forloop.last %&#125;</span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>这是最后一次啊<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">&#123;% else %&#125;</span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123; foo &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">&#123;% endif %&#125;</span><br><span class="line">&#123;% empty %&#125;</span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>for循环的可迭代对象内部没有元素，根本没法循环<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">&#123;% endfor %&#125;</span><br></pre></td></tr></table></figure>#### 处理字典其他方法<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;#处理字典其他方法#&#125;</span><br><span class="line">&#123;% for foo in d.keys %&#125;</span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123; foo &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">&#123;% endfor %&#125;</span><br><span class="line">&#123;% for foo in d.values %&#125;</span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123; foo &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">&#123;% endfor %&#125;</span><br><span class="line">&#123;% for foo in d.items %&#125;</span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123; foo &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">&#123;% endfor %&#125;</span><br></pre></td></tr></table></figure>#### with起别名<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;#with起别名#&#125;</span><br><span class="line">&#123;% with d.hobby.3.info as nb %&#125;</span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123; nb &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123; d.hobby.3.info &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">&#123;% endwith %&#125;</span><br></pre></td></tr></table></figure>### 自定义过滤器、标签、inclusion_tag1. 在应用下创建一个名字**必须**叫 templatetags 文件夹2. 在该文件夹内创建**任意**名称的py文件 eg: mytag.py3. 在该py文件内**必须**先书写下面两行代码   <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django <span class="keyword">import</span> template</span><br><span class="line">register = template.Library()</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1. 自定义过滤器(参数只能两个)</span></span><br><span class="line"><span class="meta">@register.filter(<span class="params">name=<span class="string">&#x27;baby&#x27;</span></span>)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">my_sum</span>(<span class="params">v1, v2</span>):</span></span><br><span class="line">    <span class="keyword">return</span> v1 + v2</span><br><span class="line"><span class="comment"># 使用 </span></span><br><span class="line">&#123;% load mytag %&#125;  <span class="comment"># 只需要load一次！</span></span><br><span class="line">&lt;p&gt;&#123;&#123; n|baby:666 &#125;&#125;&lt;/p&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 自定义标签(参数可以有多个)，类似于自定义函数</span></span><br><span class="line"><span class="meta">@register.simple_tag(<span class="params">name=<span class="string">&#x27;plus&#x27;</span></span>)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span>(<span class="params">a,b,c,d</span>):</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;%s-%s-%s-%s&#x27;</span>%(a,b,c,d)</span><br><span class="line"><span class="comment"># 使用，标签多个参数彼此之间空格隔开</span></span><br><span class="line">&lt;p&gt;&#123;% plus &#x27;jason&#x27; 123 123 123 %&#125;&lt;/p&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. 自定义inclusion_tag</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">内部原理</span></span><br><span class="line"><span class="string">先定义一个方法 </span></span><br><span class="line"><span class="string">在页面上调用该方法，并且可以传值</span></span><br><span class="line"><span class="string">该方法会生成一些数据然后传递给一个指定的html页面</span></span><br><span class="line"><span class="string">之后将渲染好的结果放到调用的位置</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="meta">@register.inclusion_tag(<span class="params"><span class="string">&#x27;left_menu.html&#x27;</span></span>)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">left</span>(<span class="params">n</span>):</span></span><br><span class="line">    data = [<span class="string">&#x27;第&#123;&#125;项&#x27;</span>.<span class="built_in">format</span>(i) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line">    <span class="comment"># 第一种</span></span><br><span class="line">    <span class="comment"># return &#123;&#x27;data&#x27;:data&#125;  # 将data传递给left_menu.html</span></span><br><span class="line">    <span class="comment"># 第二种</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">locals</span>()  <span class="comment"># 将data传递给left_menu.html</span></span><br><span class="line"><span class="comment"># 使用</span></span><br><span class="line">&#123;% left <span class="number">5</span> %&#125;</span><br></pre></td></tr></table></figure>> 当html页面某一个地方的页面需要传参数才能够动态的渲染出来，并且在多个页面上都需要使用到该局部 那么就考虑将该局部页面做成inclusion_tag形式。例如：bbs### 模版的继承- 有些网站不同url的页面整体类似，只是某一些局部在做变化。例如：导航栏不变，主干部分在变化。<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 先设计好父类模版页面</span></span><br><span class="line">&#123;% extends <span class="string">&#x27;home.html&#x27;</span> %&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在父类模板中划定可以被修改的区域</span></span><br><span class="line">&#123;% block name %&#125;</span><br><span class="line">模版内容</span><br><span class="line">&#123;% endblock %&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在子页面声明想要修改的区域内容</span></span><br><span class="line">&#123;% block name %&#125;</span><br><span class="line">子页面内容</span><br><span class="line">&#123;% endblock %&#125;</span><br></pre></td></tr></table></figure>- 一般情况下模版页面上应该至少有三块可以被修改的区域，每一个子页面都有独有的css代码、html代码、js代码。  1. css区域  2. html区域  3. js区域<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#123;% block css %&#125;</span><br><span class="line">css</span><br><span class="line">&#123;% endblock %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% block content %&#125;</span><br><span class="line">html</span><br><span class="line">&#123;% endblock %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% block js %&#125;</span><br><span class="line">js</span><br><span class="line">&#123;% endblock %&#125;</span><br></pre></td></tr></table></figure>### 模版的导入将一个局部内容做成模块的形式，在需要的地方直接导入。<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% include <span class="string">&#x27;wasai.html&#x27;</span> %&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Django </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Django-Part2</title>
      <link href="/2021/08/Django-Part2/"/>
      <url>/2021/08/Django-Part2/</url>
      
        <content type="html"><![CDATA[<h1 id="Django-Part2——路由层"><a href="#Django-Part2——路由层" class="headerlink" title="Django-Part2——路由层"></a>Django-Part2——路由层</h1><p>[TOC]</p><h2 id="Django请求生命周期流程图-重点"><a href="#Django请求生命周期流程图-重点" class="headerlink" title="Django请求生命周期流程图(重点)"></a>Django请求生命周期流程图(重点)</h2><ul><li>wsgiref模块能够支持的并发量很小，上线之后换成uwsgi</li><li>wsgi、wsgiref、uwsgi之间的关系<ul><li>wsgi是协议</li><li>wsgiref和uwsgi是实现该协议的功能模块</li></ul></li></ul><p><img src="/2021/08/Django-Part2/202011130830231.png" alt="202011130830231.png"></p><h2 id="路由匹配"><a href="#路由匹配" class="headerlink" title="路由匹配"></a>路由匹配</h2><h3 id="path-re-path-与url"><a href="#path-re-path-与url" class="headerlink" title="path()/re_path()与url()"></a>path()/re_path()与url()</h3><ul><li>匹配顺序从上到下，只要能够匹配到内容，那么就会立刻停止往下匹配。</li><li>2.x之后的<code>re_path()</code>与1.x的<code>url()</code>是等价的，推荐使用新版本的方法，方法名更加容易辨别意思。</li><li><code>re_path()</code>的第一个参数是正则表达式，一旦匹配到了，则进入响应的视图函数并停止匹配。</li><li><code>path()</code>的第一个参数是路径，只有完全匹配时才会执行对应的视图函数。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.contrib <span class="keyword">import</span> admin</span><br><span class="line"><span class="keyword">from</span> django.urls <span class="keyword">import</span> path</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> app01 <span class="keyword">import</span> views</span><br><span class="line"></span><br><span class="line">urlpatterns = [</span><br><span class="line">    path(<span class="string">&#x27;admin/&#x27;</span>, admin.site.urls),</span><br><span class="line">    path(<span class="string">r&#x27;test/&#x27;</span>, views.test),</span><br><span class="line">    path(<span class="string">r&#x27;testadd/&#x27;</span>, views.testadd)</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> django.urls <span class="keyword">import</span> re_path</span><br><span class="line"></span><br><span class="line">urlpatterns = [</span><br><span class="line">    <span class="comment"># 首页</span></span><br><span class="line">    re_path(<span class="string">r&#x27;^$&#x27;</span>,views.home),</span><br><span class="line">    <span class="comment"># 路由匹配</span></span><br><span class="line">    re_path(<span class="string">r&#x27;^test/$&#x27;</span>,views.test),  <span class="comment"># 和path(r&#x27;test/&#x27;, views.test)等效</span></span><br><span class="line">    re_path(<span class="string">r&#x27;^testadd/$&#x27;</span>, views.testadd),</span><br><span class="line">    <span class="comment"># 尾页(但这种写法失去了重定向)</span></span><br><span class="line">    re_path(<span class="string">r&#x27;&#x27;</span>,views.error),</span><br><span class="line">]</span><br></pre></td></tr></table></figure><ul><li>在访问url时会以输入的原url进行一次匹配。当匹配失败时，会在原url上添加后缀<code>/</code>，再次进行一次匹配。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 取消自动加斜杠，默认为True</span></span><br><span class="line">APPEND_SLASH = <span class="literal">False</span></span><br></pre></td></tr></table></figure><h3 id="无名分组"><a href="#无名分组" class="headerlink" title="无名分组"></a>无名分组</h3><ul><li>无名分组就是将括号内正则表达式匹配到的内容当作位置参数传递给后面的视图函数</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -&gt; urls.py</span></span><br><span class="line">re_path(<span class="string">r&#x27;^test/(\d+)/&#x27;</span>, views.test)</span><br><span class="line"></span><br><span class="line"><span class="comment"># -&gt; views.py</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test</span>(<span class="params">request, xx</span>):</span></span><br><span class="line">    print(xx)</span><br><span class="line">    <span class="keyword">return</span> HttpResponse(<span class="string">&#x27;test&#x27;</span>)</span><br></pre></td></tr></table></figure><h3 id="有名分组"><a href="#有名分组" class="headerlink" title="有名分组"></a>有名分组</h3><ul><li>有名分组就是将括号内正则表达式匹配到的内容当作关键字参数传递给后面的视图函数</li><li>需要有一个对应的形参来接收</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -&gt; urls.py</span></span><br><span class="line">re_path(<span class="string">r&#x27;^testadd/(?P&lt;year&gt;\d+)&#x27;</span>, views.testadd)</span><br><span class="line"></span><br><span class="line"><span class="comment"># -&gt; views.py</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">testadd</span>(<span class="params">request, year</span>):</span></span><br><span class="line">    print(year)</span><br><span class="line">    <span class="keyword">return</span> HttpResponse(<span class="string">&#x27;testadd&#x27;</span>)</span><br></pre></td></tr></table></figure><h3 id="无名有名是否可以混合使用"><a href="#无名有名是否可以混合使用" class="headerlink" title="无名有名是否可以混合使用"></a>无名有名是否可以混合使用</h3><ul><li>不能混用无名、有名分组</li><li>但是只使用一种分组时可以使用多次/传多个形参</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -&gt; urls.py</span></span><br><span class="line">re_path(<span class="string">r&#x27;^index/(\d+)/(\d+)/(\d+)/&#x27;</span>, views.index),</span><br><span class="line">re_path(<span class="string">r&#x27;^index/(?P&lt;year&gt;\d+)/(?P&lt;age&gt;\d+)/(?P&lt;month&gt;\d+)/&#x27;</span>, views.index)</span><br><span class="line"></span><br><span class="line"><span class="comment"># -&gt; views.py</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">testadd</span>(<span class="params">request, *args, **kwargs</span>):</span></span><br><span class="line">    print(args, kwargs)</span><br><span class="line">    <span class="keyword">return</span> HttpResponse(<span class="string">&#x27;testadd&#x27;</span>)</span><br></pre></td></tr></table></figure><h2 id="反向解析"><a href="#反向解析" class="headerlink" title="反向解析"></a>反向解析</h2><h3 id="别名"><a href="#别名" class="headerlink" title="别名"></a>别名</h3><ul><li>通过一些方法得到一个结果 该结果可以直接访问对应的url触发视图函数</li></ul><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -&gt; urls.py</span></span><br><span class="line"><span class="comment"># 给路由与视图函数起一个别名</span></span><br><span class="line">re_path(<span class="string">r&#x27;^urls/&#x27;</span>, views.func, name=<span class="string">&#x27;name&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># -&gt; views.py</span></span><br><span class="line"><span class="comment"># 后端反向解析</span></span><br><span class="line"><span class="keyword">from</span> django.shortcuts <span class="keyword">import</span> reverse</span><br><span class="line">reverse(<span class="string">&#x27;name&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># -&gt; xxx.html</span></span><br><span class="line"><span class="comment"># 前端反向解析</span></span><br><span class="line">&lt;a href=&quot;&#123;% url &#x27;name&#x27; %&#125;&quot;&gt;string&lt;/a&gt;</span><br></pre></td></tr></table></figure><h3 id="无名分组反向解析"><a href="#无名分组反向解析" class="headerlink" title="无名分组反向解析"></a>无名分组反向解析</h3><blockquote><p>分组的解析值一般就是数据的主键值。</p></blockquote><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -&gt; urls.py</span></span><br><span class="line"><span class="comment"># 无名分组反向解析</span></span><br><span class="line">re_path(<span class="string">r&#x27;^edit/(\d+)/&#x27;</span>, views.edit, name=<span class="string">&#x27;xxx&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># -&gt; views.py</span></span><br><span class="line"><span class="comment"># 后端</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">edit</span>(<span class="params">request, edit_id</span>):</span></span><br><span class="line">    reverse(<span class="string">&#x27;xxx&#x27;</span>, args=(edit_id, ))</span><br><span class="line"></span><br><span class="line"><span class="comment"># -&gt; xxx.html   </span></span><br><span class="line"><span class="comment"># 前端</span></span><br><span class="line">&lt;a href=&quot;&#123;% url &#x27;xxx&#x27; user_obj.id %&#125;&quot;&gt;编辑&lt;/a&gt;</span><br></pre></td></tr></table></figure><h3 id="有名分组反向解析"><a href="#有名分组反向解析" class="headerlink" title="有名分组反向解析"></a>有名分组反向解析</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -&gt; urls.py</span></span><br><span class="line"><span class="comment"># 有名分组反向解析</span></span><br><span class="line">re_path(<span class="string">r&#x27;^func/(?P&lt;year&gt;\d+)/&#x27;</span>, views.func, name=<span class="string">&#x27;ooo&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># -&gt; views.py</span></span><br><span class="line"><span class="comment"># 后端</span></span><br><span class="line"><span class="comment"># 有名分组反向解析</span></span><br><span class="line">print(reverse(<span class="string">&#x27;ooo&#x27;</span>, kwargs=&#123;<span class="string">&#x27;year&#x27;</span>:<span class="number">123</span>&#125;))</span><br><span class="line"><span class="comment"># 简便的写法，和无名一样</span></span><br><span class="line">print(reverse(<span class="string">&#x27;ooo&#x27;</span>, args=(<span class="number">111</span>,)))</span><br><span class="line"></span><br><span class="line"><span class="comment"># -&gt; xxx.html   </span></span><br><span class="line"><span class="comment"># 前端</span></span><br><span class="line">&lt;a href=&quot;&#123;% url &#x27;ooo&#x27; year=123 %&#125;&quot;&gt;111&lt;/a&gt;  # 了解</span><br><span class="line">&lt;a href=&quot;&#123;% url &#x27;ooo&#x27; 123 %&#125;&quot;&gt;222&lt;/a&gt;  # 记忆</span><br></pre></td></tr></table></figure><h3 id="如何理解分组反向解析"><a href="#如何理解分组反向解析" class="headerlink" title="如何理解分组反向解析"></a>如何理解分组反向解析</h3><ul><li>分组是基于正则表达式匹配url，即不同的url能够进入相同的视图函数，多存在于 <code>https://xxx/id/</code> 类似，这部分会在id不同时发生变化。</li><li>反向解析基于别名，在.html和.py中动态获得 <code>https://xxx/id/</code> 的xxx部分，这部分可能会在重构url地址时发生变化。</li><li>分组反向解析则是通过上述两条结合，动态地获得 <code>https://xxx/id/</code> 这条有很多种可能的url，以方便进入相应的视图函数。</li><li>分组的解析值一般就是数据的主键值，相当于是在视图函数中增加形参，来代替在request中获取的部分数据。</li></ul><h2 id="路由分发"><a href="#路由分发" class="headerlink" title="路由分发"></a>路由分发</h2><h3 id="include"><a href="#include" class="headerlink" title="include()"></a>include()</h3><ul><li>django的每一个应用都可以有自己的templates、urls.py、static（需要自己新建）。这样能够很好地做到分组开发，最终利用路由分发进行整合。</li><li>当django项目中的url特别多的时候，总路由urls.py代码非常冗余不好维护，这时也可以利用路由分发来减轻总路由的压力。</li><li>使用路由分发之后，总路由不再将url与视图函数直接对应，而是识别分类当前url所属应用，并分发给对应的应用去处理。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 总路由</span></span><br><span class="line"><span class="keyword">from</span> django.urls <span class="keyword">import</span> include, re_path</span><br><span class="line"><span class="comment"># from app01 import urls as app01_urls</span></span><br><span class="line"><span class="comment"># from app02 import urls as app02_urls</span></span><br><span class="line"></span><br><span class="line">urlpatterns = [</span><br><span class="line">    re_path(<span class="string">r&#x27;^admin/&#x27;</span>, admin.site.urls),</span><br><span class="line">    <span class="comment"># 路由分发</span></span><br><span class="line">    <span class="comment"># url(r&#x27;^app01/&#x27;, include(app01_urls)),  # 只要url前缀是app01开头，全部交给app01处理</span></span><br><span class="line">    <span class="comment"># url(r&#x27;^app02/&#x27;, include(app02_urls))   # 只要url前缀是app02开头，全部交给app02处理</span></span><br><span class="line">    <span class="comment"># 推荐写法</span></span><br><span class="line">    re_path(<span class="string">r&#x27;^app01/&#x27;</span>, include(<span class="string">&#x27;app01.urls&#x27;</span>)),</span><br><span class="line">    re_path(<span class="string">r&#x27;^app02/&#x27;</span>, include(<span class="string">&#x27;app02.urls&#x27;</span>))</span><br><span class="line">    <span class="comment"># 注意事项: 总路由里面的url千万不能加$结尾</span></span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 子路由</span></span><br><span class="line"><span class="comment"># -&gt; app01 -&gt; urls.py</span></span><br><span class="line"><span class="keyword">from</span> django.urls <span class="keyword">import</span> include, re_path</span><br><span class="line"><span class="keyword">from</span> app01 <span class="keyword">import</span> views</span><br><span class="line"></span><br><span class="line">urlpatterns = [</span><br><span class="line">re_path(<span class="string">r&#x27;^reg/&#x27;</span>, views.reg)</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="comment"># -&gt; app02 -&gt; urls.py</span></span><br><span class="line"><span class="keyword">from</span> django.urls <span class="keyword">import</span> include, re_path</span><br><span class="line"><span class="keyword">from</span> app02 <span class="keyword">import</span> views</span><br><span class="line"></span><br><span class="line">urlpatterns = [</span><br><span class="line">re_path(<span class="string">r&#x27;^reg/&#x27;</span>, views.reg)</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h3 id="名称空间"><a href="#名称空间" class="headerlink" title="名称空间"></a>名称空间</h3><ul><li>当多个应用出现了相同的别名，反向解析只能识别后缀而不能识别前缀，例如 <code>https://app/xxx/</code> </li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 总路由 </span></span><br><span class="line"><span class="comment"># -&gt; urls.py</span></span><br><span class="line">urlpatterns = [</span><br><span class="line">    re_path(<span class="string">r&#x27;^app01/&#x27;</span>, include(<span class="string">&#x27;app01.urls&#x27;</span>, namespace=<span class="string">&#x27;app01&#x27;</span>))，</span><br><span class="line">re_path(<span class="string">r&#x27;^app02/&#x27;</span>, include(<span class="string">&#x27;app02.urls&#x27;</span>, namespace=<span class="string">&#x27;app02&#x27;</span>))</span><br><span class="line">]</span><br><span class="line"><span class="comment"># 子路由</span></span><br><span class="line"><span class="comment"># -&gt; app01 -&gt; urls.py</span></span><br><span class="line">urlpatterns = [</span><br><span class="line">    re_path(<span class="string">r&#x27;^reg/&#x27;</span>, views.reg, name=<span class="string">&#x27;reg&#x27;</span>)</span><br><span class="line">]</span><br><span class="line"><span class="comment"># -&gt; app02 -&gt; urls.py</span></span><br><span class="line">urlpatterns = [</span><br><span class="line">    re_path(<span class="string">r&#x27;^reg/&#x27;</span>, views.reg, name=<span class="string">&#x27;reg&#x27;</span>)</span><br><span class="line">]</span><br><span class="line">    </span><br><span class="line"><span class="comment"># 反向解析</span></span><br><span class="line"><span class="comment"># -&gt; views.py</span></span><br><span class="line">reverse(<span class="string">&#x27;app01:reg&#x27;</span>)</span><br><span class="line">reverse(<span class="string">&#x27;app02:reg&#x27;</span>)</span><br><span class="line"><span class="comment"># -&gt; .html</span></span><br><span class="line">&#123;% url <span class="string">&#x27;app01:reg&#x27;</span> %&#125;</span><br><span class="line">&#123;% url <span class="string">&#x27;app02:reg&#x27;</span> %&#125;</span><br></pre></td></tr></table></figure><ul><li>利用名称空间可以区分不同app的相同别名，但一般只需要在别名之前添加所属应用作为前缀，就大可不必使用名称空间。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -&gt; urls.py</span></span><br><span class="line">urlpatterns = [</span><br><span class="line">    re_path(<span class="string">r&#x27;^reg/&#x27;</span>, views.reg, name=<span class="string">&#x27;app01_reg&#x27;</span>)</span><br><span class="line">]</span><br><span class="line">urlpatterns = [</span><br><span class="line">    re_path(<span class="string">r&#x27;^reg/&#x27;</span>, views.reg, name=<span class="string">&#x27;app02_reg&#x27;</span>)</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h2 id="伪静态"><a href="#伪静态" class="headerlink" title="伪静态"></a>伪静态</h2><ul><li>静态网页：数据是写死的 万年不变</li><li>伪静态：将一个动态网页伪装成静态网页</li><li>伪装的目的：<ul><li>增大本网站的seo查询力度</li><li>增加搜索引擎收藏本网上的概率</li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 仅将url地址改为.html结尾，假装只是返回html文件，实际上还是经过视图函数，可以做动态处理</span></span><br><span class="line">urlpatterns = [</span><br><span class="line">    re_path(<span class="string">r&#x27;^reg.html&#x27;</span>, views.reg, name=<span class="string">&#x27;app02_reg&#x27;</span>)</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h2 id="虚拟环境"><a href="#虚拟环境" class="headerlink" title="虚拟环境"></a>虚拟环境</h2><ul><li>在正常开发中，通常每一个项目配备一个独有的解释器环境，只有该项目用到的模块，用不到一概不装。</li><li>但是较多的虚拟环境会消耗更多的硬盘空间。</li><li>一般通过requirement.txt来标识项目的虚拟环境需要的模块。</li></ul><h2 id="path-转换器"><a href="#path-转换器" class="headerlink" title="path()转换器"></a>path()转换器</h2><ol><li>str：匹配除了路径分隔符<code>/</code>之外的非空字符串，这是默认的形式</li><li>int：匹配正整数，包含0。</li><li>slug：匹配字母、数字以及横杠、下划线组成的字符串。</li><li>uuid：匹配格式化的uuid，如：075194d3-6885-417e-a8a8-6c931e272f00。</li><li>path：匹配任何非空字符串，包含了路径分隔符（/）</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -&gt; urls.py</span></span><br><span class="line"><span class="comment"># 将匹配内容转成相应类型，作为形参传递给后面的视图函数</span></span><br><span class="line">path(<span class="string">&#x27;index/&lt;int:id&gt;/&#x27;</span>, index)</span><br><span class="line"></span><br><span class="line"><span class="comment"># -&gt; views.py</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span>(<span class="params">request,<span class="built_in">id</span></span>):</span></span><br><span class="line">    print(<span class="built_in">id</span>, <span class="built_in">type</span>(<span class="built_in">id</span>))</span><br><span class="line">    <span class="keyword">return</span> HttpResponse(<span class="string">&#x27;index&#x27;</span>)</span><br></pre></td></tr></table></figure><ol start="6"><li>自定义转换器</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -&gt; path_converts.py</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MonthConverter</span>:</span></span><br><span class="line">    regex=<span class="string">&#x27;\d&#123;2&#125;&#x27;</span>  <span class="comment"># 属性名必须为regex</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">to_python</span>(<span class="params">self, value</span>):</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">int</span>(value)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">to_url</span>(<span class="params">self, value</span>):</span></span><br><span class="line">        <span class="keyword">return</span> value  <span class="comment"># 匹配的regex是两个数字，返回的结果也必须是两个数字</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># -&gt; urls.py</span></span><br><span class="line"><span class="keyword">from</span> django.urls <span class="keyword">import</span> path, register_converter</span><br><span class="line"><span class="keyword">from</span> path_converts <span class="keyword">import</span> MonthConverter</span><br><span class="line"><span class="keyword">from</span> app01 <span class="keyword">import</span> views</span><br><span class="line"></span><br><span class="line"><span class="comment"># 先注册转换器</span></span><br><span class="line">register_converter(MonthConverter, <span class="string">&#x27;mon&#x27;</span>)</span><br><span class="line"></span><br><span class="line">urlpatterns = [</span><br><span class="line">    path(<span class="string">&#x27;articles/&lt;int:year&gt;/&lt;mon:month&gt;/&lt;slug:other&gt;/&#x27;</span>, views.article_detail, name=<span class="string">&#x27;aaa&#x27;</span>),</span><br><span class="line">]</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Django </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Django-Part1</title>
      <link href="/2021/08/Django-Part1/"/>
      <url>/2021/08/Django-Part1/</url>
      
        <content type="html"><![CDATA[<h1 id="Django-Part1——基础操作"><a href="#Django-Part1——基础操作" class="headerlink" title="Django-Part1——基础操作"></a>Django-Part1——基础操作</h1><p>[TOC]</p><h2 id="后端"><a href="#后端" class="headerlink" title="后端"></a>后端</h2><blockquote><p>后端很重要，每个领域的知识都应该学，要做一个全能型人才</p></blockquote><h2 id="软件开发架构"><a href="#软件开发架构" class="headerlink" title="软件开发架构"></a>软件开发架构</h2><ul><li>cs架构(Client/Server)  建立在局域网的基础上</li><li>bs架构(Browser/Server)  建立在广域网的基础上</li></ul><p>bs本质也是cs</p><h2 id="HTTP协议"><a href="#HTTP协议" class="headerlink" title="HTTP协议"></a>HTTP协议</h2><h3 id="网络协议"><a href="#网络协议" class="headerlink" title="网络协议"></a>网络协议</h3><ol><li>HTTP协议              数据传输是明文</li><li>HTTPS协议             数据传输是密文</li><li>websocket协议      数据传输是密文</li></ol><h3 id="四大特性"><a href="#四大特性" class="headerlink" title="四大特性"></a>四大特性</h3><ol><li>基于请求响应</li><li>基于TCP、IP作用于应用层之上的协议</li><li>无状态</li><li>短/无链接</li></ol><h3 id="数据格式"><a href="#数据格式" class="headerlink" title="数据格式"></a>数据格式</h3><ol><li>请求首行</li><li>请求头</li><li>请求体</li></ol><h3 id="响应状态码"><a href="#响应状态码" class="headerlink" title="响应状态码"></a>响应状态码</h3><ul><li>1xx：指示信息–表示请求已接收，继续处理。</li><li>2xx：成功–表示请求已被成功接收、理解、接受。</li><li>3xx：重定向–要完成请求必须进行更进一步的操作。</li><li>4xx：客户端错误–请求有语法错误或请求无法实现。</li><li>5xx：服务器端错误–服务器未能实现合法的请求。</li></ul><p><a href="https://zhuanlan.zhihu.com/p/53165474">响应状态码大全</a></p><h2 id="wsgiref模块"><a href="#wsgiref模块" class="headerlink" title="wsgiref模块"></a>wsgiref模块</h2><h3 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h3><ol><li>urls.py                        路由与视图函数对应关系</li><li>views.py                    视图函数(后端业务逻辑)</li><li>templates文件夹        专门用来存储html文件</li></ol><p>按照功能的不同拆分之后，后续添加功能只需要在<code>urls.py</code>注册对应关系然后在<code>views.py</code>书写业务逻辑即可</p><h3 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h3><ol><li>请求来的时候解析http格式的数据，封装成大字典</li><li>响应走的时候给数据打包成符合http格式，再返回给浏览器</li></ol><h2 id="动静态网页"><a href="#动静态网页" class="headerlink" title="动静态网页"></a>动静态网页</h2><ul><li><p>静态网页</p><ul><li>页面上的数据是直接写死的，万年不变</li></ul></li><li><p>动态网页</p><ul><li>页面框架不变，而数据是实时获取的</li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 动态网页制作</span></span><br><span class="line"><span class="keyword">import</span> datetime</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_time</span>(<span class="params">env</span>):</span></span><br><span class="line">    <span class="comment"># 动态获取当前时间，即每次获取的都不固定</span></span><br><span class="line">    current_time = datetime.datetime.now().strftime(<span class="string">&#x27;%Y-%m-%d %X&#x27;</span>)</span><br><span class="line">    <span class="comment"># 将后端获取到的数据传递给html文件</span></span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">r&#x27;templates/03 mytime.html&#x27;</span>,<span class="string">&#x27;r&#x27;</span>,encoding=<span class="string">&#x27;utf-8&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        <span class="comment"># data就是一堆字符串</span></span><br><span class="line">        data = f.read()</span><br><span class="line">    <span class="comment"># 在后端将html页面处理好之后再返回给前端</span></span><br><span class="line">    data = data.replace(<span class="string">&#x27;dwadasdsadsadasdas&#x27;</span>,current_time)  </span><br><span class="line">    <span class="comment"># 返回带有动态数据的html页面</span></span><br><span class="line">    <span class="keyword">return</span> data</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将一个字典传递给html文件，更加方便快捷的操作字典数据</span></span><br><span class="line"><span class="keyword">from</span> jinja2 <span class="keyword">import</span> Template</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_dict</span>(<span class="params">env</span>):</span></span><br><span class="line">    user_dic = &#123;<span class="string">&#x27;username&#x27;</span>:<span class="string">&#x27;jason&#x27;</span>,<span class="string">&#x27;age&#x27;</span>:<span class="number">18</span>,<span class="string">&#x27;hobby&#x27;</span>:<span class="string">&#x27;read&#x27;</span>&#125;</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">r&#x27;templates/04 get_dict.html&#x27;</span>,<span class="string">&#x27;r&#x27;</span>,encoding=<span class="string">&#x27;utf-8&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        data = f.read()</span><br><span class="line">    tmp = Template(data)</span><br><span class="line">    res = tmp.render(user=user_dic)</span><br><span class="line">    <span class="comment"># 给get_dict.html传递了一个值 页面上通过变量名user就能够拿到user_dict</span></span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="模版语法之Jinja2模块"><a href="#模版语法之Jinja2模块" class="headerlink" title="模版语法之Jinja2模块"></a>模版语法之Jinja2模块</h3><blockquote><p>模版语法仅在后端服务器上起作用</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"># 模版语法(非常贴近python语法)</span><br><span class="line">&#123;&#123; user &#125;&#125;</span><br><span class="line">&#123;&#123; user.get(&#x27;username&#x27;)&#125;&#125;</span><br><span class="line">&#123;&#123; user.age &#125;&#125;</span><br><span class="line">&#123;&#123; user[&#x27;hobby&#x27;] &#125;&#125;</span><br><span class="line"></span><br><span class="line"># 循环</span><br><span class="line">&#123;% for user_dict in user_list %&#125;</span><br><span class="line">                        <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">td</span>&gt;</span>&#123;&#123; user_dict.id&#125;&#125;<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">td</span>&gt;</span>&#123;&#123; user_dict.username&#125;&#125;<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">td</span>&gt;</span>&#123;&#123; user_dict.password&#125;&#125;<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">td</span>&gt;</span>&#123;&#123; user_dict.hobby&#125;&#125;<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">&#123;% endfor%&#125;</span><br></pre></td></tr></table></figure><h2 id="Python三大主流web框架"><a href="#Python三大主流web框架" class="headerlink" title="Python三大主流web框架"></a>Python三大主流web框架</h2><ol><li><p>django</p><ul><li>特点：大而全，自带的功能特别多</li><li>不足之处：有时候过于笨重</li><li>组成：<ul><li>socket部分用的是别人的：wsgiref模块</li><li>路由匹配用的是自己的</li><li>模版语法用的是自己的(没有jinja2好用 但是也很方便)</li></ul></li></ul></li><li><p>flask</p><ul><li>特点：小而精，自带的功能特别少。但第三方的模块特别多，如果将flask第三方的模块加起来完全可以盖过django，并且也越来越像django</li><li>不足之处：比较依赖于第三方的开发者，可能不兼容        </li><li>组成：<ul><li>socket部分用的是别人的：werkzeug(内部还是wsgiref模块)</li><li>路由匹配用的是自己的</li><li>模版语法用的是别人的：jinja2</li></ul></li></ul></li><li><p>tornado</p><ul><li>特点：异步非阻塞，支持高并发，甚至可以开发游戏服务器</li><li>组成：<ul><li>socket部分用的是自己的</li><li>路由匹配用的是自己的</li><li>模版语法用的是自己的</li></ul></li></ul></li></ol><h2 id="开始Django"><a href="#开始Django" class="headerlink" title="开始Django"></a>开始Django</h2><h3 id="如何让你的计算机能够正常的启动django项目"><a href="#如何让你的计算机能够正常的启动django项目" class="headerlink" title="如何让你的计算机能够正常的启动django项目"></a>如何让你的计算机能够正常的启动django项目</h3><ol><li>计算机的名称不能是中文</li><li>一个pycharm窗口只开一个django项目</li><li>项目里面所有的文件也尽量不要出现中文</li><li>python解释器尽量使用3.4~3.6之间的版本(如果依然报错，点击最后一个报错信息，在源码中把逗号删掉)</li></ol><h3 id="django安装"><a href="#django安装" class="headerlink" title="django安装"></a>django安装</h3><ul><li>如果已经安装了其他版本，可以<code>pip install django==xx.xx.xx</code>自动卸载安装新的版本</li><li>在mac终端可以输入django-admin验证安装成功</li></ul><h2 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h2><h3 id="命令行操作"><a href="#命令行操作" class="headerlink" title="命令行操作"></a>命令行操作</h3><ol><li><p>切换到指定目录，创建django项目<br><code>django-admin startproject mysite</code></p></li><li><p>启动django项目</p><p><code>cd /mysite</code></p><p><code>python3 manage.py runserver</code></p></li><li><p>创建应用</p><p><code>python manage.py startapp app01</code></p></li></ol><blockquote><p>使用命令行创建项目时一定要记得配置templates路径，建议使用pycharm创建</p></blockquote><h3 id="pycharm操作"><a href="#pycharm操作" class="headerlink" title="pycharm操作"></a>pycharm操作</h3><ol><li><p>new project -&gt; django</p></li><li><p>启动django项目</p><p>命令行 或者 绿色箭头运行</p></li><li><p>创建应用</p><p>命令行 或者 tools -&gt; run manage.py task -&gt; start app02(有提示，前期不要用，背完整命令)</p></li><li><p>修改端口号以及创建server</p><p>edit -&gt; config</p></li></ol><h3 id="命令行与pycharm创建的区别"><a href="#命令行与pycharm创建的区别" class="headerlink" title="命令行与pycharm创建的区别"></a>命令行与pycharm创建的区别</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1 命令行创建django项目时,不仅要创建templates文件夹，还需要自己在setting.py中配置路径。</span></span><br><span class="line"><span class="comment"># -&gt; settings.py</span></span><br><span class="line"><span class="comment"># pycharm创建</span></span><br><span class="line">TEMPLATES = [</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">&#x27;BACKEND&#x27;</span>: <span class="string">&#x27;django.template.backends.django.DjangoTemplates&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;DIRS&#x27;</span>: [os.path.join(BASE_DIR, <span class="string">&#x27;templates&#x27;</span>)]</span><br><span class="line">]</span><br><span class="line"><span class="comment"># 命令行创建</span></span><br><span class="line">TEMPLATES = [</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">&#x27;BACKEND&#x27;</span>: <span class="string">&#x27;django.template.backends.django.DjangoTemplates&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;DIRS&#x27;</span>: [],</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h3 id="更快捷的Django命令"><a href="#更快捷的Django命令" class="headerlink" title="更快捷的Django命令"></a>更快捷的Django命令</h3><ul><li>这里的命令将拥有代码提示</li></ul><p><img src="/2021/08/Django-Part1/Django-Part1%5Cimage-20210615221710342.png?lastModify=1628778347" alt="image-20210615221710342"></p><h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><p>django是一款专门用来开发app的web框架。</p><p>而这里的app指的是一种具体的功能模块。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">INSTALLED_APPS = [</span><br><span class="line">    <span class="string">&#x27;django.contrib.admin&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;django.contrib.auth&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;django.contrib.contenttypes&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;django.contrib.sessions&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;django.contrib.messages&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;django.contrib.staticfiles&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;app01.apps.App01Config&#x27;</span>,<span class="comment"># 全写</span></span><br><span class="line">  <span class="string">&#x27;app01&#x27;</span>, <span class="comment"># 简写</span></span><br><span class="line">]</span><br></pre></td></tr></table></figure><blockquote><p>创建出来的的应用第一步一定要先去settings.py中注册</p></blockquote><h2 id="工程文件介绍"><a href="#工程文件介绍" class="headerlink" title="工程文件介绍"></a>工程文件介绍</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">-mysite项目文件夹</span><br><span class="line">  --manage.pydjango的入口文件</span><br><span class="line">  --db.sqlite3django自带的sqlite3数据库(不用)</span><br><span class="line">  --mysite文件夹</span><br><span class="line">  ---settings.py    配置文件</span><br><span class="line">    ---urls.py路由与视图函数对应关系(路由层)</span><br><span class="line">    ---wsgi.pywsgiref模块(不考虑)</span><br><span class="line">  --app01文件夹</span><br><span class="line">  ---admin.pydjango后台管理</span><br><span class="line">    ---apps.py注册使用</span><br><span class="line">    ---migrations文件夹  数据库迁移记录</span><br><span class="line">    ---models.py数据库相关的 模型类(orm)</span><br><span class="line">  ---tests.py测试文件</span><br><span class="line">    ---views.py视图函数(视图层)</span><br></pre></td></tr></table></figure><h2 id="静态文件配置"><a href="#静态文件配置" class="headerlink" title="静态文件配置"></a>静态文件配置</h2><h3 id="Templates"><a href="#Templates" class="headerlink" title="Templates"></a>Templates</h3><ul><li>将html文件默认都放在 Templates文件夹下</li></ul><h3 id="Static"><a href="#Static" class="headerlink" title="Static"></a>Static</h3><ul><li>将网站所使用的静态文件放在Static文件夹下</li></ul><p>这里的静态文件指前端已经写好了的，能够直接调用的文件。包括 js、css、.jpg、第三方前端框架等。</p><blockquote><p>Django不会自动创建static文件夹 需要手动创建</p></blockquote><h3 id="访问静态文件"><a href="#访问静态文件" class="headerlink" title="访问静态文件"></a>访问静态文件</h3><blockquote><p>如果访问不到资源，则一定说明后端没有开设该资源的接口。</p></blockquote><p>在写django项目的时候，可能会出现后端代码修改了，但是前端页面没有变化的情况。那么可能原因有：</p><ol><li><p>在同一个端口开了好几个django项目，而一直在跑的其实是第一个django项目</p></li><li><p>浏览器缓存的问题。勾选 settings -&gt; network -&gt; disable cache </p></li></ol><h3 id="静态文件访问令牌"><a href="#静态文件访问令牌" class="headerlink" title="静态文件访问令牌"></a>静态文件访问令牌</h3><p>想要调用静态文件，则文件地址必须以 令牌(<code>STATIC_URL</code>) + 文件名 形式。</p><p>然后将在 <code>STATICFILES_DIRS</code> 注册的文件夹列表中从上往下依次<strong>非递归</strong>查找。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -&gt; settings.py</span></span><br><span class="line">STATIC_URL = <span class="string">&#x27;/static/&#x27;</span>  <span class="comment"># 访问静态文件的令牌</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 需要自己创建STATICFILES_DIRS，配置静态文件所在文件夹</span></span><br><span class="line">STATICFILES_DIRS = [</span><br><span class="line">    os.path.join(BASE_DIR,<span class="string">&#x27;static&#x27;</span>),</span><br><span class="line">    os.path.join(BASE_DIR,<span class="string">&#x27;static1&#x27;</span>)</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>同时也可以动态解析令牌</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 静态文件动态解析</span></span><br><span class="line">    &#123;% load static %&#125;</span><br><span class="line">    &lt;link rel=<span class="string">&quot;stylesheet&quot;</span> href=<span class="string">&quot;&#123;% static &#x27;bootstrap-3.3.7-dist/css/bootstrap.min.css&#x27; %&#125;&quot;</span>&gt;</span><br><span class="line">    &lt;script src=&quot;&#123;% static &#x27;bootstrap-3.3.7-dist/js/bootstrap.min.js&#x27; %&#125;&quot;&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>在前期使用django提交post请求时，需要在settings中注释掉一行代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -&gt; settings.py</span></span><br><span class="line">MIDDLEWARE = [</span><br><span class="line">    <span class="string">&#x27;django.middleware.security.SecurityMiddleware&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;django.contrib.sessions.middleware.SessionMiddleware&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;django.middleware.common.CommonMiddleware&#x27;</span>,</span><br><span class="line">    <span class="comment"># &#x27;django.middleware.csrf.CsrfViewMiddleware&#x27;,  # 表示django全局发送post请求均需要字符串验证</span></span><br><span class="line">    <span class="string">&#x27;django.contrib.auth.middleware.AuthenticationMiddleware&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;django.contrib.messages.middleware.MessageMiddleware&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;django.middleware.clickjacking.XFrameOptionsMiddleware&#x27;</span>,</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h2 id="数据库链接"><a href="#数据库链接" class="headerlink" title="数据库链接"></a>数据库链接</h2><h3 id="Pycharm链接数据库"><a href="#Pycharm链接数据库" class="headerlink" title="Pycharm链接数据库"></a>Pycharm链接数据库</h3><ul><li>需要提前创建好对应使用的mysql数据库文件</li><li>pycharm右侧上方database</li></ul><h3 id="Django链接数据库"><a href="#Django链接数据库" class="headerlink" title="Django链接数据库"></a>Django链接数据库</h3><ol><li>Django默认使用sqlite3，首先改settings</li><li>Django默认使用mysqldb，需要改为pymysql</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -&gt; settings.py</span></span><br><span class="line">DATABASES = &#123;</span><br><span class="line">    <span class="string">&#x27;default&#x27;</span>: &#123;</span><br><span class="line">        <span class="string">&#x27;ENGINE&#x27;</span>: <span class="string">&#x27;django.db.backends.mysql&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;NAME&#x27;</span>: <span class="string">&#x27;day60&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;USER&#x27;</span>: <span class="string">&#x27;root&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;PASSWORD&#x27;</span>:<span class="string">&#x27;admin123&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;HOST&#x27;</span>:<span class="string">&#x27;127.0.0.1&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;PORT&#x27;</span>: <span class="number">3306</span>,</span><br><span class="line">        <span class="string">&#x27;CHARSET&#x27;</span>:<span class="string">&#x27;utf8&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># -&gt; 在项目名下或任意应用名下的init文件</span></span><br><span class="line"><span class="keyword">import</span> pymysql</span><br><span class="line"></span><br><span class="line">pymysql.install_as_MySQLdb()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Django </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>爬虫-完结目录</title>
      <link href="/2021/06/%E7%88%AC%E8%99%AB-%E5%AE%8C%E7%BB%93%E7%9B%AE%E5%BD%95/"/>
      <url>/2021/06/%E7%88%AC%E8%99%AB-%E5%AE%8C%E7%BB%93%E7%9B%AE%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<h1 id="爬虫——完结目录"><a href="#爬虫——完结目录" class="headerlink" title="爬虫——完结目录"></a>爬虫——完结目录</h1><p>教程视频传送门：</p><ol><li><a href="https://www.bilibili.com/video/BV1i54y1h75W?p=1">2021年最新Python爬虫教程+实战项目案例（最新录制）</a></li></ol><p>讲的非常好，只要跟着耐心做一遍就能整明白，很清晰。</p><table><thead><tr><th align="center"><a href="/2021/05/%E7%88%AC%E8%99%ABPart1/">爬虫Part1——原理与request入门</a></th></tr></thead><tbody><tr><td align="center"><strong><a href="/2021/05/%E7%88%AC%E8%99%ABPart2/">爬虫Part2——数据解析与提取</a></strong></td></tr><tr><td align="center"><strong><a href="/2021/06/%E7%88%AC%E8%99%ABPart3/">爬虫Part3——Requests进阶</a></strong></td></tr><tr><td align="center"><strong><a href="/2021/06/%E7%88%AC%E8%99%ABPart4/">爬虫Part4——异步爬虫</a></strong></td></tr><tr><td align="center"><strong><a href="/2021/06/%E7%88%AC%E8%99%ABPart5/">爬虫Part5——Selenuim</a></strong></td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 爬虫 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> crawler </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>爬虫Part5</title>
      <link href="/2021/06/%E7%88%AC%E8%99%ABPart5/"/>
      <url>/2021/06/%E7%88%AC%E8%99%ABPart5/</url>
      
        <content type="html"><![CDATA[<h1 id="爬虫Part5——Selenuim"><a href="#爬虫Part5——Selenuim" class="headerlink" title="爬虫Part5——Selenuim"></a>爬虫Part5——Selenuim</h1><p>[TOC]</p><h2 id="Selenuim简介"><a href="#Selenuim简介" class="headerlink" title="Selenuim简介"></a>Selenuim简介</h2><ul><li><p>有些网页的响应内容经过复杂的加密，通过手动调试解密已经非常地狱，所以可以尝试直接获取浏览器运行后的结果。</p></li><li><p>selenium本体是自动化测试工具，控制浏览器操作。</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"></span><br><span class="line">url = <span class="string">&quot;https://www.baidu.com&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 下载的文件名是msedgedriver.exe，默认启动为MicrosoftWebDriver.exe，修正一下文件名就可以不用给.Edge()传文件名参数了</span></span><br><span class="line">driver = webdriver.Edge()  <span class="comment"># 必须用已经在python路径中的driver启动</span></span><br><span class="line">driver.get(url)  <span class="comment"># 打开某个网址</span></span><br><span class="line"></span><br><span class="line">print(driver.title)  <span class="comment"># 百度一下，你就知道</span></span><br></pre></td></tr></table></figure><ul><li>使用selenium需要：1. <code>pip install selenium</code> 2. 下载对应版本的浏览器driver并放在python根目录下</li><li><code>.get()</code>打开某个网址</li></ul><h2 id="拉钩"><a href="#拉钩" class="headerlink" title="拉钩"></a>拉钩</h2><h3 id="元素获取与事件处理"><a href="#元素获取与事件处理" class="headerlink" title="元素获取与事件处理"></a>元素获取与事件处理</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium.webdriver <span class="keyword">import</span> Edge</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.common.keys <span class="keyword">import</span> Keys</span><br><span class="line"></span><br><span class="line">url = <span class="string">&quot;http://lagou.com&quot;</span></span><br><span class="line"></span><br><span class="line">driver = Edge()</span><br><span class="line">driver.get(url)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 用选择工具找到 &#x27;//*[@id=&quot;changeCityBox&quot;]/p[1]/a&#x27; 或者下面都是可以的</span></span><br><span class="line">ele = driver.find_element_by_xpath(<span class="string">&#x27;//*[@id=&quot;changeCityBox&quot;]/p[1]/a/i&#x27;</span>)</span><br><span class="line">ele.click()</span><br><span class="line"></span><br><span class="line">driver.find_element_by_xpath(<span class="string">&#x27;//*[@id=&quot;search_input&quot;]&#x27;</span>).send_keys(<span class="string">&quot;python&quot;</span>, Keys.ENTER)</span><br><span class="line"></span><br><span class="line">li_list = driver.find_elements_by_xpath(<span class="string">&#x27;//*[@id=&quot;s_position_list&quot;]/ul/li&#x27;</span>)</span><br><span class="line"><span class="keyword">for</span> li <span class="keyword">in</span> li_list:</span><br><span class="line">    job_name = li.find_element_by_tag_name(<span class="string">&quot;h3&quot;</span>).text</span><br><span class="line">    job_price = li.find_element_by_xpath(<span class="string">&quot;./div/div/div[2]/div/span&quot;</span>).text</span><br><span class="line">    company_name = li.find_element_by_xpath(<span class="string">&#x27;./div/div[2]/div/a&#x27;</span>).text</span><br><span class="line">    print(company_name, job_name, job_price)</span><br></pre></td></tr></table></figure><ul><li><code>find_element_by_xpath() </code>获取元素对象</li><li><code>.click()</code> 使元素对象产生点击事件</li><li><code>.send_keys() </code>使元素对象填入文本</li><li><code>.text </code>获取元素内的文本</li></ul><h3 id="切换窗口与跳转frame"><a href="#切换窗口与跳转frame" class="headerlink" title="切换窗口与跳转frame"></a>切换窗口与跳转frame</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium.webdriver <span class="keyword">import</span> Edge</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.common.keys <span class="keyword">import</span> Keys</span><br><span class="line"></span><br><span class="line">web = Edge()</span><br><span class="line"></span><br><span class="line">web.get(<span class="string">&quot;http://lagou.com&quot;</span>)</span><br><span class="line">web.find_element_by_xpath(<span class="string">&#x27;//*[@id=&quot;changeCityBox&quot;]/p[1]/a/i&#x27;</span>).click()</span><br><span class="line">web.find_element_by_xpath(<span class="string">&#x27;//*[@id=&quot;search_input&quot;]&#x27;</span>).send_keys(<span class="string">&quot;python&quot;</span>, Keys.ENTER)</span><br><span class="line">web.find_element_by_xpath(<span class="string">&#x27;//*[@id=&quot;s_position_list&quot;]/ul/li[1]/div[1]/div[1]/div[1]/a/h3&#x27;</span>).click()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 1. 在selenium的眼中，新窗口默认是不切换过来的，需要手动切换</span></span><br><span class="line">web.switch_to.window(web.window_handles[-<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在新窗口中提取内容</span></span><br><span class="line">job_detail = web.find_element_by_xpath(<span class="string">&#x27;//*[@id=&quot;job_detail&quot;]/dd[2]/div&#x27;</span>).text</span><br><span class="line">print(job_detail)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 关掉子窗口，或者返回上一页面</span></span><br><span class="line">web.close()</span><br><span class="line"><span class="comment"># web.back()</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 变更selenium的窗口视角，回到原来的窗口中</span></span><br><span class="line">web.switch_to.window(web.window_handles[<span class="number">0</span>])</span><br><span class="line">print(web.find_element_by_xpath(<span class="string">&#x27;//*[@id=&quot;s_position_list&quot;]/ul/li[1]/div[1]/div[1]/div[1]/a/h3&#x27;</span>).text)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 跳转进入iframe</span></span><br><span class="line">web.get(<span class="string">&quot;https://www.91kanju.com/vod-play/541-2-1.html&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 先拿到iframe</span></span><br><span class="line">iframe = web.find_element_by_xpath(<span class="string">&#x27;//*[@id=&quot;player_iframe&quot;]&#x27;</span>)</span><br><span class="line"><span class="comment"># 切换到iframe</span></span><br><span class="line">web.switch_to.frame(iframe)</span><br><span class="line"><span class="comment"># 拿到数据</span></span><br><span class="line">tx = web.find_element_by_xpath(<span class="string">&#x27;//*[@id=&quot;main&quot;]/h3[1]&#x27;</span>).text</span><br><span class="line">print(tx)</span><br><span class="line">web.switch_to.default_content()  <span class="comment"># 切换回原页面</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li><code>switch_to.window(web.window_handles[-1])</code> 切换到最后一个标签</li><li><code>.close()</code> 关闭标签</li><li><code>.back()</code> 返回当前标签的上一页面</li><li><code>switch_to.frame(iframe) </code>切换到内嵌的html中</li></ul><h2 id="艺恩"><a href="#艺恩" class="headerlink" title="艺恩"></a>艺恩</h2><h3 id="无头浏览器"><a href="#无头浏览器" class="headerlink" title="无头浏览器"></a>无头浏览器</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium.webdriver <span class="keyword">import</span> Edge</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="comment"># 准备好参数配置</span></span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.support.select <span class="keyword">import</span> Select</span><br><span class="line"></span><br><span class="line">opt = &#123;</span><br><span class="line">    <span class="comment"># 这里是默认的</span></span><br><span class="line">    <span class="string">&quot;browserName&quot;</span>: <span class="string">&quot;MicrosoftEdge&quot;</span>,</span><br><span class="line">    <span class="string">&quot;version&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">    <span class="string">&quot;platform&quot;</span>: <span class="string">&quot;WINDOWS&quot;</span>,</span><br><span class="line">    <span class="comment"># 设置无头</span></span><br><span class="line">    <span class="string">&quot;ms:edgeOptions&quot;</span>: &#123;</span><br><span class="line">        <span class="string">&#x27;extensions&#x27;</span>: [],</span><br><span class="line">        <span class="string">&#x27;args&#x27;</span>: [</span><br><span class="line">            <span class="string">&#x27;--headless&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;--disable-gpu&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;--remote-debugging-port=9222&#x27;</span>,</span><br><span class="line">        ]&#125;</span><br><span class="line">&#125;</span><br><span class="line">web = Edge(capabilities=opt)  <span class="comment"># 把参数配置设置到浏览器中</span></span><br><span class="line"></span><br><span class="line">web.get(<span class="string">&quot;https://www.endata.com.cn/BoxOffice/BO/Year/index.html&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 拿到经过数据加载以及js执行之后的结果的html内容!!!这样可以结合选择工具直接定位了</span></span><br><span class="line">print(web.page_source)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定位到下拉列表</span></span><br><span class="line">sel_el = web.find_element_by_xpath(<span class="string">&#x27;//*[@id=&quot;OptionDate&quot;]&#x27;</span>)</span><br><span class="line"><span class="comment"># 对元素进行包装, 包装成下拉菜单</span></span><br><span class="line">sel = Select(sel_el)</span><br><span class="line"><span class="comment"># 让浏览器进行调整选项</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(sel.options)):  <span class="comment"># i就是每一个下拉框选项的索引位置</span></span><br><span class="line">    sel.select_by_index(i)  <span class="comment"># 按照索引进行切换</span></span><br><span class="line">    time.sleep(<span class="number">2</span>)</span><br><span class="line">    table = web.find_element_by_xpath(<span class="string">&#x27;//*[@id=&quot;TableList&quot;]/table&#x27;</span>)</span><br><span class="line">    print(table.text)  <span class="comment"># 打印所有文本信息</span></span><br><span class="line">    print(<span class="string">&quot;===================================&quot;</span>)</span><br><span class="line"></span><br><span class="line">web.close()  <span class="comment"># 关闭页面</span></span><br><span class="line">web.quit()  <span class="comment"># 关闭浏览器</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li><code>.quit()</code> 关闭浏览器</li><li><code>web.page_source</code> 拿到经过数据加载以及js执行之后的结果的html内容！！！这样可以结合选择工具直接定位了</li><li><code>Select(sel_el).select_by_index(i)</code> 将元素包装成下拉菜单并按照索引进行切换</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># chrome设置无头</span></span><br><span class="line">chrome_options = webdriver.ChromeOptions()</span><br><span class="line">chrome_options.add_argument(<span class="string">&#x27;--headless&#x27;</span>)</span><br><span class="line">chrome_options.add_argument(<span class="string">&#x27;--disable-gpu&#x27;</span>)</span><br><span class="line"></span><br><span class="line">driver = webdriver.Chrome(options=chrome_options)</span><br></pre></td></tr></table></figure><h2 id="超级鹰"><a href="#超级鹰" class="headerlink" title="超级鹰"></a>超级鹰</h2><h3 id="验证码"><a href="#验证码" class="headerlink" title="验证码"></a>验证码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium.webdriver <span class="keyword">import</span> Edge</span><br><span class="line"><span class="keyword">from</span> chaojiying <span class="keyword">import</span> Chaojiying_Client</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">web = Edge()</span><br><span class="line">web.get(<span class="string">&quot;http://www.chaojiying.com/user/login/&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 处理验证码</span></span><br><span class="line">img = web.find_element_by_xpath(<span class="string">&#x27;/html/body/div[3]/div/div[3]/div[1]/form/div/img&#x27;</span>).screenshot_as_png  <span class="comment"># 将元素组件以图像形式存储在内存</span></span><br><span class="line">chaojiying = Chaojiying_Client(<span class="string">&#x27;18614075987&#x27;</span>, <span class="string">&#x27;6035945&#x27;</span>, <span class="string">&#x27;914467&#x27;</span>)</span><br><span class="line">dic = chaojiying.PostPic(img, <span class="number">1902</span>)</span><br><span class="line">verify_code = dic[<span class="string">&#x27;pic_str&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 向页面中填入用户名, 密码, 验证码</span></span><br><span class="line">web.find_element_by_xpath(<span class="string">&#x27;/html/body/div[3]/div/div[3]/div[1]/form/p[1]/input&#x27;</span>).send_keys(<span class="string">&quot;18614075987&quot;</span>)</span><br><span class="line">web.find_element_by_xpath(<span class="string">&#x27;/html/body/div[3]/div/div[3]/div[1]/form/p[2]/input&#x27;</span>).send_keys(<span class="string">&quot;6035945&quot;</span>)</span><br><span class="line">web.find_element_by_xpath(<span class="string">&#x27;/html/body/div[3]/div/div[3]/div[1]/form/p[3]/input&#x27;</span>).send_keys(verify_code)</span><br><span class="line"></span><br><span class="line">time.sleep(<span class="number">5</span>)</span><br><span class="line"><span class="comment"># 点击登录</span></span><br><span class="line">web.find_element_by_xpath(<span class="string">&#x27;/html/body/div[3]/div/div[3]/div[1]/form/p[4]/input&#x27;</span>).click()</span><br></pre></td></tr></table></figure><ul><li><code>.screenshot_as_png</code> 将元素组件以图像形式存储在内存</li></ul><h2 id="12306"><a href="#12306" class="headerlink" title="12306"></a>12306</h2><h3 id="反检测与滑块拖动"><a href="#反检测与滑块拖动" class="headerlink" title="反检测与滑块拖动"></a>反检测与滑块拖动</h3><ul><li><p><a href="https://blog.csdn.net/cqcre/article/details/110944075">chrome反检测driver</a></p></li><li><p><em>edge还没找到，暂时先不整了</em></p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium.webdriver <span class="keyword">import</span> Chrome</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver <span class="keyword">import</span> ActionChains</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.chrome.options <span class="keyword">import</span> Options</span><br><span class="line"><span class="keyword">from</span> chaojiying <span class="keyword">import</span> Chaojiying_Client</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">chaojiying = Chaojiying_Client(<span class="string">&#x27;18614075987&#x27;</span>, <span class="string">&#x27;6035945&#x27;</span>, <span class="string">&#x27;914467&#x27;</span>)</span><br><span class="line"></span><br><span class="line">option = Options()</span><br><span class="line">option.add_argument(<span class="string">&#x27;--disable-blink-features=AutomationControlled&#x27;</span>)</span><br><span class="line"></span><br><span class="line">web = Chrome(options=option)</span><br><span class="line">web.get(<span class="string">&quot;https://kyfw.12306.cn/otn/resources/login.html&quot;</span>)</span><br><span class="line">time.sleep(<span class="number">2</span>)</span><br><span class="line">web.find_element_by_xpath(<span class="string">&#x27;/html/body/div[2]/div[2]/ul/li[2]/a&#x27;</span>).click()</span><br><span class="line">time.sleep(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 先处理验证码</span></span><br><span class="line">verify_img_element = web.find_element_by_xpath(<span class="string">&#x27;//*[@id=&quot;J-loginImg&quot;]&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 用超级鹰去识别验证码</span></span><br><span class="line">dic = chaojiying.PostPic(verify_img_element.screenshot_as_png, <span class="number">9004</span>)</span><br><span class="line">result = dic[<span class="string">&#x27;pic_str&#x27;</span>]  <span class="comment"># x1,y1|x2,y2|x3,y3</span></span><br><span class="line">rs_list = result.split(<span class="string">&quot;|&quot;</span>)</span><br><span class="line"><span class="keyword">for</span> rs <span class="keyword">in</span> rs_list:  <span class="comment"># x1,y1</span></span><br><span class="line">    p_temp = rs.split(<span class="string">&quot;,&quot;</span>)</span><br><span class="line">    x = <span class="built_in">int</span>(p_temp[<span class="number">0</span>])</span><br><span class="line">    y = <span class="built_in">int</span>(p_temp[<span class="number">1</span>])</span><br><span class="line">    <span class="comment"># 鼠移动标 -&gt; 点击 -&gt; 执行.perform()</span></span><br><span class="line">    ActionChains(web).move_to_element_with_offset(verify_img_element, x, y).click().perform()</span><br><span class="line"><span class="comment"># time.sleep(5)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 输入用户名和密码</span></span><br><span class="line">web.find_element_by_xpath(<span class="string">&#x27;//*[@id=&quot;J-userName&quot;]&#x27;</span>).send_keys(<span class="string">&quot;userName&quot;</span>)</span><br><span class="line">web.find_element_by_xpath(<span class="string">&#x27;//*[@id=&quot;J-password&quot;]&#x27;</span>).send_keys(<span class="string">&quot;password&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 点击登录</span></span><br><span class="line">web.find_element_by_xpath(<span class="string">&#x27;//*[@id=&quot;J-login&quot;]&#x27;</span>).click()</span><br><span class="line">time.sleep(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 拖拽</span></span><br><span class="line">btn = web.find_element_by_xpath(<span class="string">&#x27;//*[@id=&quot;nc_1_n1z&quot;]&#x27;</span>)</span><br><span class="line">ActionChains(web).drag_and_drop_by_offset(btn, <span class="number">300</span>, <span class="number">0</span>).perform()</span><br></pre></td></tr></table></figure><ul><li>拖动时不能切换页面</li><li>适当使用 <code>time.sleep(3)</code> 防止过快</li><li>事件链 ActionChains 必须在末尾协商执行语句 <code>.perform()</code></li></ul>]]></content>
      
      
      <categories>
          
          <category> 爬虫 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>爬虫Part4</title>
      <link href="/2021/06/%E7%88%AC%E8%99%ABPart4/"/>
      <url>/2021/06/%E7%88%AC%E8%99%ABPart4/</url>
      
        <content type="html"><![CDATA[<h1 id="爬虫Part4——异步爬虫"><a href="#爬虫Part4——异步爬虫" class="headerlink" title="爬虫Part4——异步爬虫"></a>爬虫Part4——异步爬虫</h1><p>[TOC]</p><h2 id="多线程与多进程"><a href="#多线程与多进程" class="headerlink" title="多线程与多进程"></a>多线程与多进程</h2><h3 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h3><ol><li>进程是资源单位，开启一个程序则开启一个进程，为每个进程分配内存空间。</li><li>线程是执行单位，每一个进程至少要有一个线程，为每个线程分配计算资源。</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span>(<span class="params">name</span>):</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1000</span>):</span><br><span class="line">        print(name, i)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span>(<span class="params">Thread</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, name</span>):</span>  <span class="comment"># 传参做初始化</span></span><br><span class="line">        <span class="built_in">super</span>().__init__()</span><br><span class="line">        self.name = name</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span>(<span class="params">self</span>):</span>  <span class="comment"># 当线程被start时, 自动调用run()</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1000</span>):</span><br><span class="line">            print(self.name, i)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="comment"># 1. 通过函数启动线程</span></span><br><span class="line">    t = Thread(target=func, args=(<span class="string">&quot;t&quot;</span>,))  <span class="comment"># 传参必须是元组</span></span><br><span class="line">    t.start()</span><br><span class="line"></span><br><span class="line">    t0 = Thread(target=func, args=(<span class="string">&quot;t0&quot;</span>,))</span><br><span class="line">    t0.start()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 2. 通过类启动线程</span></span><br><span class="line">    t1 = MyThread(<span class="string">&quot;t1&quot;</span>)</span><br><span class="line">    <span class="comment"># t1.run()  # 直接run则为单线程</span></span><br><span class="line">    t1.start()  <span class="comment"># 开启多线程</span></span><br><span class="line"></span><br><span class="line">    t2 = MyThread(<span class="string">&quot;t2&quot;</span>)</span><br><span class="line">    t2.start()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 主线程</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1000</span>):</span><br><span class="line">        print(<span class="string">&quot;主线程&quot;</span>, i)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="多进程"><a href="#多进程" class="headerlink" title="多进程"></a>多进程</h3><ul><li>开进程太费资源，不建议使用</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span>():</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10000</span>):</span><br><span class="line">        print(<span class="string">&quot;子&quot;</span>, i)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    p = Process(target=func)</span><br><span class="line">    p.start()</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10000</span>):</span><br><span class="line">        print(<span class="string">&quot;主进程&quot;</span>, i)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="线程池和进程池"><a href="#线程池和进程池" class="headerlink" title="线程池和进程池"></a>线程池和进程池</h3><ul><li>线程池：一次性开辟多个线程，只需要考虑给线程池子编写任务，线程任务的调度交给线程池来完成。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> concurrent.futures <span class="keyword">import</span> ThreadPoolExecutor, ProcessPoolExecutor</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span>(<span class="params">name</span>):</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1000</span>):</span><br><span class="line">        print(name, i)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="keyword">with</span> ThreadPoolExecutor(<span class="number">50</span>) <span class="keyword">as</span> t:</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">100</span>):</span><br><span class="line">            t.submit(func, name=<span class="string">f&quot;线程<span class="subst">&#123;i&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="comment"># 等待线程池中的任务全部执行完毕. 才继续执行和后续操作</span></span><br><span class="line">    print(<span class="string">&quot;yes!&quot;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="批量新发地菜价"><a href="#批量新发地菜价" class="headerlink" title="批量新发地菜价"></a>批量新发地菜价</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> concurrent.futures <span class="keyword">import</span> ThreadPoolExecutor, ProcessPoolExecutor</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">from</span> lxml <span class="keyword">import</span> etree</span><br><span class="line"><span class="keyword">import</span> csv</span><br><span class="line"></span><br><span class="line">f = <span class="built_in">open</span>(<span class="string">&quot;source/菜价.csv&quot;</span>, encoding=<span class="string">&quot;utf-8&quot;</span>, newline=<span class="string">&quot;&quot;</span>, mode=<span class="string">&quot;w&quot;</span>)</span><br><span class="line">csv_writer = csv.writer(f)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">download</span>(<span class="params">url</span>):</span></span><br><span class="line">    resp = requests.get(url=url)</span><br><span class="line">    <span class="comment"># print(resp.text)</span></span><br><span class="line">    tree = etree.HTML(resp.text)</span><br><span class="line">    ts = tree.xpath(<span class="string">&quot;/html/body/div[2]/div[4]/div[1]/table&quot;</span>)[<span class="number">0</span>]  <span class="comment"># tbody是生成的，需要删去</span></span><br><span class="line">    <span class="comment"># print(len(ts))  # 即使结果只有一个，xpath()也永远返回list</span></span><br><span class="line">    trs = ts.xpath(<span class="string">&quot;./tr[position()&gt;1]&quot;</span>)  <span class="comment"># table下有多个tr，tr下有多个td</span></span><br><span class="line">    <span class="comment"># rows = t.xpath(&quot;./tr&quot;)[1:]</span></span><br><span class="line">    <span class="keyword">for</span> tr <span class="keyword">in</span> trs:</span><br><span class="line">        tds = tr.xpath(<span class="string">&quot;./td/text()&quot;</span>)</span><br><span class="line">        <span class="comment"># 对数据做简单处理</span></span><br><span class="line">        tds = <span class="built_in">list</span>(td.replace(<span class="string">&#x27;\\&#x27;</span>, <span class="string">&quot;&quot;</span>).replace(<span class="string">&quot;/&quot;</span>, <span class="string">&quot;&quot;</span>) <span class="keyword">for</span> td <span class="keyword">in</span> tds)  <span class="comment"># 将生成器转成list</span></span><br><span class="line">        <span class="comment"># print(tds)</span></span><br><span class="line">        csv_writer.writerow(tds)</span><br><span class="line">    print(url, <span class="string">&quot;have been downloaded!&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="keyword">with</span> ThreadPoolExecutor(<span class="number">50</span>) <span class="keyword">as</span> t:</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">200</span>):</span><br><span class="line">            u = <span class="string">f&quot;http://www.xinfadi.com.cn/marketanalysis/0/list%20/<span class="subst">&#123;i&#125;</span>.shtml&quot;</span></span><br><span class="line">            t.submit(download, url=u)</span><br><span class="line"></span><br><span class="line">f.close()</span><br></pre></td></tr></table></figure><h2 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h2><h3 id="asyncio"><a href="#asyncio" class="headerlink" title="asyncio"></a>asyncio</h3><ul><li><p>协程能够更加⾼效的利用CPU资源。</p></li><li><p><code>time.sleep()</code>、<code>input()</code>以及<code>request.get()</code>的等待过程中，该线程都处于阻塞状态，CPU资源浪费。</p><ul><li>一般情况下，遇到IO操作时，线程都会处于阻塞状态。</li></ul></li><li><p>协程：当程序遇到阻塞时，可以选择性地切换到其他任务上。(单线程多任务异步操作)</p><ul><li><p>在微观上，是一个个任务进行切换</p></li><li><p>在宏观上，能感受到的其实是多个任务一起在执行</p></li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">func</span>():</span></span><br><span class="line">    print(<span class="string">&quot;你好啊, 我叫赛利亚&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    g = func()  <span class="comment"># 此时的函数是异步协程函数，将返回一个协程对象</span></span><br><span class="line">    <span class="comment"># print(g)</span></span><br><span class="line">    asyncio.run(g)  <span class="comment"># 协程程序运行需要asyncio模块的支持(需要python3.7以上)</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">func1</span>():</span></span><br><span class="line">    print(<span class="string">&quot;你好啊, 我叫潘金莲&quot;</span>)</span><br><span class="line">    <span class="comment"># time.sleep(3)  # sleep、get属于同步操作。当程序出现了同步操作的时候. 异步就中断了</span></span><br><span class="line">    <span class="keyword">await</span> asyncio.sleep(<span class="number">3</span>)  <span class="comment"># asyncio.sleep才是异步睡眠。需要使用await挂起</span></span><br><span class="line">    print(<span class="string">&quot;你好啊, 我叫潘金莲&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">func2</span>():</span></span><br><span class="line">    print(<span class="string">&quot;你好啊, 我叫王建国&quot;</span>)</span><br><span class="line">    <span class="comment"># time.sleep(2)</span></span><br><span class="line">    <span class="keyword">await</span> asyncio.sleep(<span class="number">2</span>)</span><br><span class="line">    print(<span class="string">&quot;你好啊, 我叫王建国&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">func3</span>():</span></span><br><span class="line">    print(<span class="string">&quot;你好啊, 我叫李雪琴&quot;</span>)</span><br><span class="line">    <span class="keyword">await</span> asyncio.sleep(<span class="number">4</span>)</span><br><span class="line">    print(<span class="string">&quot;你好啊, 我叫李雪琴&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    f1 = func1()</span><br><span class="line">    f2 = func2()</span><br><span class="line">    f3 = func3()</span><br><span class="line">    tasks = [</span><br><span class="line">        f1, f2, f3</span><br><span class="line">    ]</span><br><span class="line"></span><br><span class="line">    t1 = time.time()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 一次性启动多个任务(协程)</span></span><br><span class="line">    <span class="comment"># asyncio.run(asyncio.wait(tasks))</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># python版本低于3.7时会有以下报错</span></span><br><span class="line">    <span class="comment"># AttributeError: module &#x27;asyncio&#x27; has no attribute &#x27;run&#x27;</span></span><br><span class="line">    <span class="comment"># 修正:</span></span><br><span class="line">    loop = asyncio.get_event_loop()</span><br><span class="line">    loop.run_until_complete(asyncio.wait(tasks))</span><br><span class="line"></span><br><span class="line">    t2 = time.time()</span><br><span class="line">    print(t2 - t1)</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">func1</span>():</span></span><br><span class="line">    print(<span class="string">&quot;你好啊, 我叫潘金莲&quot;</span>)</span><br><span class="line">    <span class="keyword">await</span> asyncio.sleep(<span class="number">3</span>)</span><br><span class="line">    print(<span class="string">&quot;你好啊, 我叫潘金莲&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">func2</span>():</span></span><br><span class="line">    print(<span class="string">&quot;你好啊, 我叫王建国&quot;</span>)</span><br><span class="line">    <span class="keyword">await</span> asyncio.sleep(<span class="number">2</span>)</span><br><span class="line">    print(<span class="string">&quot;你好啊, 我叫王建国&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">func3</span>():</span></span><br><span class="line">    print(<span class="string">&quot;你好啊, 我叫李雪琴&quot;</span>)</span><br><span class="line">    <span class="keyword">await</span> asyncio.sleep(<span class="number">4</span>)</span><br><span class="line">    print(<span class="string">&quot;你好啊, 我叫李雪琴&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    <span class="comment"># 第一种写法</span></span><br><span class="line">    <span class="comment"># f1 = func1()</span></span><br><span class="line">    <span class="comment"># await f1  # 一般await挂起操作放在协程对象前面</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 第二种写法(推荐)</span></span><br><span class="line">    tasks = [</span><br><span class="line">        func1(),  <span class="comment"># py3.8以后asyncio.create_task(func1())</span></span><br><span class="line">        func2(),</span><br><span class="line">        func3()</span><br><span class="line">    ]</span><br><span class="line">    <span class="keyword">await</span> asyncio.wait(tasks)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    t1 = time.time()</span><br><span class="line">    <span class="comment"># 一次性启动多个任务(协程)</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 定义协程对象</span></span><br><span class="line">    m = main()</span><br><span class="line">    <span class="comment"># 定义事件循环对象容器</span></span><br><span class="line">    loop = asyncio.get_event_loop()</span><br><span class="line">    <span class="comment"># task = asyncio.ensure_future(coroutine)</span></span><br><span class="line">    <span class="comment"># 将协程转为task任务</span></span><br><span class="line">    task = loop.create_task(m)</span><br><span class="line">    <span class="comment"># 将task任务扔进事件循环对象中并触发</span></span><br><span class="line">    loop.run_until_complete(task)</span><br><span class="line"></span><br><span class="line">    t2 = time.time()</span><br><span class="line">    print(t2 - t1)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="aiohttp异步请求"><a href="#aiohttp异步请求" class="headerlink" title="aiohttp异步请求"></a>aiohttp异步请求</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">import</span> aiohttp</span><br><span class="line"></span><br><span class="line">urls = [</span><br><span class="line">    <span class="string">&quot;http://kr.shanghai-jiuxin.com/file/2020/1031/191468637cab2f0206f7d1d9b175ac81.jpg&quot;</span>,</span><br><span class="line">    <span class="string">&quot;http://kr.shanghai-jiuxin.com/file/2020/1031/563337d07af599a9ea64e620729f367e.jpg&quot;</span>,</span><br><span class="line">    <span class="string">&quot;http://kr.shanghai-jiuxin.com/file/2020/1031/774218be86d832f359637ab120eba52d.jpg&quot;</span></span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">aio_download</span>(<span class="params">url</span>):</span></span><br><span class="line">    name = url.rsplit(<span class="string">&#x27;/&#x27;</span>, <span class="number">1</span>)[<span class="number">1</span>]  <span class="comment"># 从右往左按&#x27;/&#x27;切分一次，即[&#x27;http...&#x27;, &#x27;...jpg&#x27;]</span></span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">with</span> aiohttp.ClientSession() <span class="keyword">as</span> session:</span><br><span class="line">        <span class="keyword">async</span> <span class="keyword">with</span> session.get(url) <span class="keyword">as</span> resp:</span><br><span class="line">            <span class="comment">#  拿到请求</span></span><br><span class="line">            <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;source/&quot;</span> + name, mode=<span class="string">&quot;wb&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">                f.write(<span class="keyword">await</span> resp.content.read())  <span class="comment"># 读取内容为异步，需要挂起</span></span><br><span class="line">    print(name, <span class="string">&quot;downloaded!&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    task = []</span><br><span class="line">    <span class="keyword">for</span> url <span class="keyword">in</span> urls:</span><br><span class="line">        task.append(aio_download(url))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">await</span> asyncio.wait(task)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    loop = asyncio.get_event_loop()</span><br><span class="line">    task = loop.create_task(main())</span><br><span class="line">    loop.run_until_complete(task)</span><br></pre></td></tr></table></figure><h2 id="实战案例"><a href="#实战案例" class="headerlink" title="实战案例"></a>实战案例</h2><h3 id="纵横小说"><a href="#纵横小说" class="headerlink" title="纵横小说"></a>纵横小说</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">from</span> lxml <span class="keyword">import</span> etree</span><br><span class="line"><span class="keyword">import</span> aiohttp</span><br><span class="line"><span class="keyword">import</span> aiofiles  <span class="comment"># 异步文件读写</span></span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;http://book.zongheng.com/showchapter/1084237.html&quot;</span></span><br><span class="line"><span class="string">&quot;http://book.zongheng.com/chapter/1084237/63603883.html&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># resp = requests.get(&quot;http://book.zongheng.com/chapter/1084237/63603883.html&quot;)</span></span><br><span class="line"><span class="comment"># print(resp.text)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">aio_download</span>(<span class="params">path, href</span>):</span></span><br><span class="line">    url = href</span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">with</span> aiohttp.ClientSession() <span class="keyword">as</span> session:</span><br><span class="line">        <span class="keyword">async</span> <span class="keyword">with</span> session.get(url) <span class="keyword">as</span> resp:</span><br><span class="line">            dic = <span class="keyword">await</span> resp.text()</span><br><span class="line">            tree = etree.HTML(dic)</span><br><span class="line">            contents = tree.xpath(<span class="string">&quot;/html/body/div[2]/div[3]/div[3]/div/div[5]/p/text()&quot;</span>)</span><br><span class="line">            <span class="keyword">async</span> <span class="keyword">with</span> aiofiles.<span class="built_in">open</span>(path, mode=<span class="string">&quot;w&quot;</span>, encoding=<span class="string">&quot;utf-8&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">                <span class="keyword">for</span> content <span class="keyword">in</span> contents:</span><br><span class="line">                    <span class="keyword">await</span> f.write(content + <span class="string">&quot;\n&quot;</span>)  <span class="comment"># 把小说内容写出</span></span><br><span class="line">    print(path, <span class="string">&quot;ok!&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">get_catalog</span>(<span class="params">url</span>):</span></span><br><span class="line">    tasks = []</span><br><span class="line">    <span class="comment"># 获取书本主页面响应</span></span><br><span class="line">    resp = requests.get(url)</span><br><span class="line">    tree = etree.HTML(resp.text)</span><br><span class="line">    chs = tree.xpath(<span class="string">&quot;/html/body/div[3]/div[2]/div[2]/div/ul&quot;</span>)[<span class="number">1</span>:<span class="number">3</span>]  <span class="comment"># todo 初步爬取</span></span><br><span class="line">    <span class="comment"># print(len(chs))  # 有四卷</span></span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> chs:  <span class="comment"># 获取每一卷中，各章节的标题和链接</span></span><br><span class="line">        hrefs = item.xpath(<span class="string">&quot;./li/a/@href&quot;</span>)</span><br><span class="line">        titles = item.xpath(<span class="string">&quot;./li/a/text()&quot;</span>)</span><br><span class="line">        <span class="keyword">for</span> title, href <span class="keyword">in</span> <span class="built_in">zip</span>(titles, hrefs):</span><br><span class="line">            <span class="comment"># 准备异步任务</span></span><br><span class="line">            <span class="comment"># print(title, href)</span></span><br><span class="line">            path = <span class="string">&quot;source/&quot;</span> + title + <span class="string">&quot;.txt&quot;</span></span><br><span class="line">            tasks.append(aio_download(path, href))</span><br><span class="line">            <span class="comment"># break  # todo 初步爬取</span></span><br><span class="line">    <span class="keyword">await</span> asyncio.wait(tasks)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    b_id = <span class="string">&quot;1084237&quot;</span></span><br><span class="line">    url_book = <span class="string">f&quot;http://book.zongheng.com/showchapter/<span class="subst">&#123;b_id&#125;</span>.html&quot;</span></span><br><span class="line"></span><br><span class="line">    loop = asyncio.get_event_loop()</span><br><span class="line">    task = loop.create_task(get_catalog(url_book))</span><br><span class="line">    loop.run_until_complete(task)</span><br></pre></td></tr></table></figure><ul><li>教程原网页已炸，这里用其他网站做测试学习</li><li>主要还是需要自己去定位资源位置</li><li><em>有加密的是真的烦，还有些直接导向其他域名，离谱</em></li><li><em>幸好纵横的基本不反爬，比较容易</em></li></ul><h3 id="抓取视频"><a href="#抓取视频" class="headerlink" title="抓取视频"></a>抓取视频</h3><ul><li><p>一般在html中写入<code>&lt;video src=&quot;不能播的视频.mp4&quot;&gt;&lt;/video&gt;</code>即可播放视频，但是其需要加载完整个视频资源，效率极低。</p></li><li><p>网站上视频一般都需要：①转码成不同分辨率； ②切片处理以减少拉动进度条时的资源占用。</p></li><li><p>因此需要一个M3U8（本质就是utf-8文本）文件记录：1.视频切片播放顺序；2.视频切片存放的路径……</p></li><li><p>想要抓取一个视频:</p><ol><li>找到m3u8</li><li>通过m3u8下载到ts文件</li><li>把ts文件合并为一个mp4文件</li></ol></li></ul><h4 id="简单版"><a href="#简单版" class="headerlink" title="简单版"></a>简单版</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">流程:</span></span><br><span class="line"><span class="string">    1. 拿到548121-1-1.html的页面源代码</span></span><br><span class="line"><span class="string">    2. 从源代码中提取到m3u8的url。</span></span><br><span class="line"><span class="string">    3. 下载m3u8</span></span><br><span class="line"><span class="string">    4. 读取m3u8文件, 下载视频</span></span><br><span class="line"><span class="string">    5. 合并视频</span></span><br><span class="line"><span class="string">tips:</span></span><br><span class="line"><span class="string">    1. 第二部的url中?note=是从第一步中拿到的，即必须先第一步才能第二步</span></span><br><span class="line"><span class="string">    2. 这个note具备时效性，间隔太长则拒绝访问</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line"><span class="comment"># url在js中，所以用re而不是xpath来提取m3u8的url地址</span></span><br><span class="line"><span class="comment"># 复制并查找 url: &#x27; 和 &#x27;, 是否在文件中唯一</span></span><br><span class="line">obj = re.<span class="built_in">compile</span>(<span class="string">r&quot;url: &#x27;(?P&lt;url&gt;.*?)&#x27;,&quot;</span>, re.S)</span><br><span class="line"></span><br><span class="line">url_html = <span class="string">&quot;https://www.91kanju.com/vod-play/54812-1-1.html&quot;</span></span><br><span class="line"></span><br><span class="line">headers = &#123;</span><br><span class="line">    <span class="string">&quot;User-Agent&quot;</span>: <span class="string">&quot;User-Agent&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">resp = requests.get(url_html, headers=headers)</span><br><span class="line">url_m3u8 = obj.search(resp.text).group(<span class="string">&quot;url&quot;</span>)  <span class="comment"># 拿到m3u8的地址</span></span><br><span class="line">print(url_m3u8)</span><br><span class="line">resp.close()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 下载m3u8文件</span></span><br><span class="line">resp_m3u8 = requests.get(url_m3u8, headers=headers)</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;哲仁王后.m3u8&quot;</span>, mode=<span class="string">&quot;wb&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    f.write(resp_m3u8.content)  <span class="comment"># 直接以wb二进制形式写入，避免编码问题</span></span><br><span class="line"></span><br><span class="line">resp_m3u8.close()</span><br><span class="line">print(<span class="string">&quot;下载完毕&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 解析m3u8文件</span></span><br><span class="line">n = <span class="number">1</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;哲仁王后.m3u8&quot;</span>, mode=<span class="string">&quot;r&quot;</span>, encoding=<span class="string">&quot;utf-8&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> f:</span><br><span class="line">        line = line.strip()  <span class="comment"># 去除空格, 空白, 换行符</span></span><br><span class="line">        <span class="keyword">if</span> line.startswith(<span class="string">&quot;#&quot;</span>):  <span class="comment"># 如果以#开头. 则跳过</span></span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 下载视频片段</span></span><br><span class="line">        <span class="keyword">with</span> requests.get(line) <span class="keyword">as</span> resp3:</span><br><span class="line">            <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">f&quot;video/<span class="subst">&#123;n&#125;</span>.ts&quot;</span>, mode=<span class="string">&quot;wb&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">                f.write(resp3.content)</span><br><span class="line">        n += <span class="number">1</span></span><br><span class="line">        print(<span class="string">&quot;完成了1个&quot;</span>)</span><br></pre></td></tr></table></figure><h4 id="复杂版"><a href="#复杂版" class="headerlink" title="复杂版"></a>复杂版</h4><p><img src="/2021/06/%E7%88%AC%E8%99%ABPart4/image-20210605103918532.png" alt="image-20210605103918532"></p><ul><li>当遇到右键点不了的网页时，可以通过source-&gt;top/buding520.com/acg/19888/1.html找到页面源代码</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">思路:</span></span><br><span class="line"><span class="string">    1. 拿到主页面的页面源代码, 找到iframe</span></span><br><span class="line"><span class="string">    2. 从iframe的页面源代码中拿到m3u8文件的地址</span></span><br><span class="line"><span class="string">    3. 下载第一层m3u8文件 -&gt; 下载第二层m3u8文件(视频存放路径)</span></span><br><span class="line"><span class="string">    4. 下载ts切片视频(协程)</span></span><br><span class="line"><span class="string">    5. 下载秘钥, 进行解密操作(协程)</span></span><br><span class="line"><span class="string">    6. 合并所有ts文件为一个mp4文件</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">import</span> aiohttp</span><br><span class="line"><span class="keyword">import</span> aiofiles</span><br><span class="line"><span class="keyword">from</span> Crypto.Cipher <span class="keyword">import</span> AES  <span class="comment"># pip install pycryptodome + 文件夹改名crypto-&gt;Crypto</span></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_iframe_src</span>(<span class="params">url</span>):</span></span><br><span class="line">    resp = requests.get(url)</span><br><span class="line">    main_page = BeautifulSoup(resp.text, <span class="string">&quot;html.parser&quot;</span>)  <span class="comment"># 可以用bs/xpath</span></span><br><span class="line">    src = main_page.find(<span class="string">&quot;iframe&quot;</span>).get(<span class="string">&quot;src&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> src</span><br><span class="line">    <span class="comment"># return &quot;https://boba.52kuyun.com/share/xfPs9NPHvYGhNzFp&quot;  # 为了测试</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_first_m3u8_url</span>(<span class="params">url</span>):</span></span><br><span class="line">    resp = requests.get(url)</span><br><span class="line">    <span class="comment"># print(resp.text)</span></span><br><span class="line">    <span class="comment"># 从js中找，所以用re</span></span><br><span class="line">    obj = re.<span class="built_in">compile</span>(<span class="string">r&#x27;var main = &quot;(?P&lt;m3u8_url&gt;.*?)&quot;&#x27;</span>, re.S)</span><br><span class="line">    m3u8_url = obj.search(resp.text).group(<span class="string">&quot;m3u8_url&quot;</span>)</span><br><span class="line">    <span class="comment"># print(m3u8_url)</span></span><br><span class="line">    <span class="keyword">return</span> m3u8_url</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">download_m3u8_file</span>(<span class="params">url, name</span>):</span></span><br><span class="line">    resp = requests.get(url)</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(name, mode=<span class="string">&quot;wb&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        f.write(resp.content)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">download_ts</span>(<span class="params">url, name, session</span>):</span></span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">with</span> session.get(url) <span class="keyword">as</span> resp:</span><br><span class="line">        <span class="keyword">async</span> <span class="keyword">with</span> aiofiles.<span class="built_in">open</span>(<span class="string">f&quot;video2/<span class="subst">&#123;name&#125;</span>&quot;</span>, mode=<span class="string">&quot;wb&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">            <span class="keyword">await</span> f.write(<span class="keyword">await</span> resp.content.read())  <span class="comment"># 把下载到的内容写入到文件中</span></span><br><span class="line">    print(<span class="string">f&quot;<span class="subst">&#123;name&#125;</span>下载完毕&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">aio_download</span>(<span class="params">up_url</span>):</span>  <span class="comment"># https://boba.52kuyun.com/20170906/Moh2l9zV/hls/</span></span><br><span class="line">    tasks = []</span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">with</span> aiohttp.ClientSession() <span class="keyword">as</span> session:  <span class="comment"># 提前准备好session</span></span><br><span class="line">        <span class="keyword">async</span> <span class="keyword">with</span> aiofiles.<span class="built_in">open</span>(<span class="string">&quot;越狱第一季第一集_second_m3u8.txt&quot;</span>, mode=<span class="string">&quot;r&quot;</span>, encoding=<span class="string">&#x27;utf-8&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">            <span class="keyword">async</span> <span class="keyword">for</span> line <span class="keyword">in</span> f:</span><br><span class="line">                <span class="keyword">if</span> line.startswith(<span class="string">&quot;#&quot;</span>):</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                <span class="comment"># line就是xxxxx.ts</span></span><br><span class="line">                line = line.strip()  <span class="comment"># 去掉没用的空格和换行</span></span><br><span class="line">                <span class="comment"># 拼接真正的ts路径</span></span><br><span class="line">                ts_url = up_url + line</span><br><span class="line">                task = asyncio.create_task(download_ts(ts_url, line, session))  <span class="comment"># 创建任务</span></span><br><span class="line">                tasks.append(task)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">await</span> asyncio.wait(tasks)  <span class="comment"># 等待任务结束</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_key</span>(<span class="params">url</span>):</span></span><br><span class="line">    resp = requests.get(url)</span><br><span class="line">    <span class="keyword">return</span> resp.text</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">dec_ts</span>(<span class="params">name, key</span>):</span></span><br><span class="line">    aes = AES.new(key=key, IV=<span class="string">b&quot;0000000000000000&quot;</span>, mode=AES.MODE_CBC)</span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">with</span> aiofiles.<span class="built_in">open</span>(<span class="string">f&quot;video2/<span class="subst">&#123;name&#125;</span>&quot;</span>, mode=<span class="string">&quot;rb&quot;</span>) <span class="keyword">as</span> f1, \</span><br><span class="line">            aiofiles.<span class="built_in">open</span>(<span class="string">f&quot;video2/temp_<span class="subst">&#123;name&#125;</span>&quot;</span>, mode=<span class="string">&quot;wb&quot;</span>) <span class="keyword">as</span> f2:</span><br><span class="line">        bs = <span class="keyword">await</span> f1.read()  <span class="comment"># 从源文件读取内容</span></span><br><span class="line">        <span class="keyword">await</span> f2.write(aes.decrypt(bs))  <span class="comment"># 把解密好的内容写入文件</span></span><br><span class="line">    print(<span class="string">f&quot;<span class="subst">&#123;name&#125;</span>处理完毕&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">aio_dec</span>(<span class="params">key</span>):</span></span><br><span class="line">    <span class="comment"># 解密</span></span><br><span class="line">    tasks = []</span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">with</span> aiofiles.<span class="built_in">open</span>(<span class="string">&quot;越狱第一季第一集_second_m3u8.txt&quot;</span>, mode=<span class="string">&quot;r&quot;</span>, encoding=<span class="string">&quot;utf-8&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        <span class="keyword">async</span> <span class="keyword">for</span> line <span class="keyword">in</span> f:</span><br><span class="line">            <span class="keyword">if</span> line.startswith(<span class="string">&quot;#&quot;</span>):</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            line = line.strip()</span><br><span class="line">            <span class="comment"># 开始创建异步任务</span></span><br><span class="line">            task = asyncio.create_task(dec_ts(line, key))</span><br><span class="line">            tasks.append(task)</span><br><span class="line">        <span class="keyword">await</span> asyncio.wait(tasks)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">merge_ts</span>():</span>  <span class="comment"># 其实也可以用ab追加写入</span></span><br><span class="line">    <span class="comment"># mac: cat 1.ts 2.ts 3.ts &gt; xxx.mp4</span></span><br><span class="line">    <span class="comment"># windows: copy /b 1.ts+2.ts+3.ts xxx.mp4</span></span><br><span class="line">    lst = []</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;越狱第一季第一集_second_m3u8.txt&quot;</span>, mode=<span class="string">&quot;r&quot;</span>, encoding=<span class="string">&quot;utf-8&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        <span class="keyword">for</span> line <span class="keyword">in</span> f:</span><br><span class="line">            <span class="keyword">if</span> line.startswith(<span class="string">&quot;#&quot;</span>):</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            line = line.strip()</span><br><span class="line">            lst.append(<span class="string">f&quot;video2/temp_<span class="subst">&#123;line&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">    s = <span class="string">&quot;+&quot;</span>.join(lst)  <span class="comment"># 1.ts+2.ts+3.ts...</span></span><br><span class="line">    os.system(<span class="string">f&quot;copy /b <span class="subst">&#123;s&#125;</span> movie.mp4&quot;</span>)</span><br><span class="line">    print(<span class="string">&quot;done!&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>(<span class="params">url</span>):</span></span><br><span class="line">    <span class="comment"># 1. 拿到主页面的页面源代码, 找到iframe对应的url</span></span><br><span class="line">    iframe_src = get_iframe_src(url)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 2. 拿到第一层的m3u8文件的下载地址</span></span><br><span class="line">    first_m3u8_url = get_first_m3u8_url(iframe_src)</span><br><span class="line">    <span class="comment"># 拿到iframe的域名 &quot;https://boba.52kuyun.com/share/xfPs9NPHvYGhNzFp&quot;</span></span><br><span class="line">    iframe_domain = iframe_src.split(<span class="string">&quot;/share&quot;</span>)[<span class="number">0</span>]</span><br><span class="line">    <span class="comment"># 拼接出真正的m3u8的下载路径</span></span><br><span class="line">    first_m3u8_url = iframe_domain + first_m3u8_url</span><br><span class="line">    <span class="comment"># https://boba.52kuyun.com/20170906/Moh2l9zV/index.m3u8?sign=548ae366a075f0f9e7c76af215aa18e1</span></span><br><span class="line">    <span class="comment"># print(first_m3u8_url)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 3.1 下载第一层m3u8文件</span></span><br><span class="line">    download_m3u8_file(first_m3u8_url, <span class="string">&quot;越狱第一季第一集_first_m3u8.txt&quot;</span>)</span><br><span class="line">    <span class="comment"># 3.2 下载第二层m3u8文件</span></span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;越狱第一季第一集_first_m3u8.txt&quot;</span>, mode=<span class="string">&quot;r&quot;</span>, encoding=<span class="string">&quot;utf-8&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        <span class="keyword">for</span> line <span class="keyword">in</span> f:</span><br><span class="line">            <span class="keyword">if</span> line.startswith(<span class="string">&quot;#&quot;</span>):</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                line = line.strip()  <span class="comment"># 去掉空白或者换行符  hls/index.m3u8</span></span><br><span class="line">                <span class="comment"># 准备拼接第二层m3u8的下载路径</span></span><br><span class="line">                <span class="comment"># https://boba.52kuyun.com/20170906/Moh2l9zV/ + hls/index.m3u8</span></span><br><span class="line">                <span class="comment"># https://boba.52kuyun.com/20170906/Moh2l9zV/hls/index.m3u8</span></span><br><span class="line">                <span class="comment"># https://boba.52kuyun.com/20170906/Moh2l9zV/hls/cFN8o3436000.ts</span></span><br><span class="line">                second_m3u8_url = first_m3u8_url.split(<span class="string">&quot;index.m3u8&quot;</span>)[<span class="number">0</span>] + line</span><br><span class="line">                download_m3u8_file(second_m3u8_url, <span class="string">&quot;越狱第一季第一集_second_m3u8.txt&quot;</span>)</span><br><span class="line">                print(<span class="string">&quot;m3u8文件下载完毕&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 4. 下载视频</span></span><br><span class="line">    second_m3u8_url_up = second_m3u8_url.replace(<span class="string">&quot;index.m3u8&quot;</span>, <span class="string">&quot;&quot;</span>)</span><br><span class="line">    <span class="comment"># 异步协程</span></span><br><span class="line">    asyncio.run(aio_download(second_m3u8_url_up))  <span class="comment"># 测试的使用可以注释掉</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 5.1 拿到秘钥</span></span><br><span class="line">    key_url = second_m3u8_url_up + <span class="string">&quot;key.key&quot;</span>  <span class="comment"># 偷懒写法, 正常应该去m3u8文件里去找</span></span><br><span class="line">    key = get_key(key_url)</span><br><span class="line">    <span class="comment"># 5.2 解密</span></span><br><span class="line">    asyncio.run(aio_dec(key))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 6. 合并ts文件为mp4文件</span></span><br><span class="line">    merge_ts()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="comment"># ↓↓↓网站已挂↓↓↓</span></span><br><span class="line">    url = <span class="string">&quot;https://www.91kanju.com/vod-play/541-2-1.html&quot;</span></span><br><span class="line">    main(url)</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>寻找思路时：复杂问题简单化（逻辑化思路）</p><p>实现思路时：简单问题复杂化（思考更多可能性）</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 爬虫 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>爬虫Part3</title>
      <link href="/2021/06/%E7%88%AC%E8%99%ABPart3/"/>
      <url>/2021/06/%E7%88%AC%E8%99%ABPart3/</url>
      
        <content type="html"><![CDATA[<h1 id="爬虫Part3——Requests进阶"><a href="#爬虫Part3——Requests进阶" class="headerlink" title="爬虫Part3——Requests进阶"></a>爬虫Part3——Requests进阶</h1><p>[TOC]</p><h2 id="Requests进阶概述"><a href="#Requests进阶概述" class="headerlink" title="Requests进阶概述"></a>Requests进阶概述</h2><p>HTTP协议中的请求头header，⼀般会包含安全验证信息，比如常见的User-Agent, token, cookie等。</p><ol><li>模拟浏览器登录 -&gt; 处理cookie</li><li>防盗链处理 -&gt; 抓取梨视频数据</li><li>代理 -&gt; 防⽌被封IP</li></ol><h2 id="模拟浏览器登录"><a href="#模拟浏览器登录" class="headerlink" title="模拟浏览器登录"></a>模拟浏览器登录</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line"><span class="comment"># 初始化session</span></span><br><span class="line">session = requests.session()</span><br><span class="line"><span class="comment"># 准备帐密</span></span><br><span class="line">data = &#123;</span><br><span class="line">    <span class="string">&quot;loginName&quot;</span>: <span class="string">&quot;loginName&quot;</span>,</span><br><span class="line">    <span class="string">&quot;password&quot;</span>: <span class="string">&quot;password&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment"># 必须先登录，才能使session获得cookie</span></span><br><span class="line">url = <span class="string">&quot;https://passport.17k.com/ck/user/login&quot;</span></span><br><span class="line">resp_login = session.post(url=url, data=data)</span><br><span class="line">print(resp_login.text)</span><br><span class="line">print(resp_login.cookies)</span><br><span class="line"><span class="comment"># 使用包含cookie的session拿到书架数据</span></span><br><span class="line">resp_book = session.get(<span class="string">&quot;https://user.17k.com/ck/author/shelf?page=1&amp;appKey=2406394919&quot;</span>)</span><br><span class="line">print(resp_book.json())</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在header中添加cookie进行请求是等效的</span></span><br><span class="line">resp_req = requests.get(<span class="string">&quot;https://user.17k.com/ck/author/shelf?page=1&amp;appKey=2406394919&quot;</span>, headers=&#123;</span><br><span class="line">    <span class="string">&quot;Cookie&quot;</span>: <span class="string">&quot;cookie&quot;</span></span><br><span class="line">&#125;)</span><br><span class="line">print(resp_req.json())</span><br></pre></td></tr></table></figure><ul><li>使用错误的帐密登录，以抓取login信息</li></ul><p><img src="/2021/06/%E7%88%AC%E8%99%ABPart3/image-20210603110845823.png" alt="image-20210603110845823"></p><h2 id="防盗链处理"><a href="#防盗链处理" class="headerlink" title="防盗链处理"></a>防盗链处理</h2><ul><li>虽然在开发者工具中能看到<video>标签，但这是本地通过js脚本生成的。而在网页源代码中，<video>是不存在的，视频资源是二次加载的。</video></video></li><li>服务器返回页面源代码之后生成以下右边的文件，之后的操作与页面源代码就没有关系了。</li><li>浏览器的视图界面是由右边的文件实时渲染的。当删除右边的语句时，左边的相应组件也会同步消失。</li></ul><p><img src="/2021/06/%E7%88%AC%E8%99%ABPart3/image-20210603125745611.png" alt="image-20210603125745611"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line"><span class="comment"># 视频原网站</span></span><br><span class="line">url = <span class="string">&quot;https://www.pearvideo.com/video_1713901&quot;</span></span><br><span class="line">contId = url.split(<span class="string">&quot;_&quot;</span>)[<span class="number">1</span>]  <span class="comment"># 截取id</span></span><br><span class="line">videoStatus_url = <span class="string">f&quot;https://www.pearvideo.com/videoStatus.jsp?contId=<span class="subst">&#123;contId&#125;</span>&amp;mrd=0.8770894467476524&quot;</span></span><br><span class="line"></span><br><span class="line">headers = &#123;</span><br><span class="line">    <span class="string">&quot;User-Agent&quot;</span>: <span class="string">&quot;User-Agent&quot;</span>,</span><br><span class="line">    <span class="string">&quot;Referer&quot;</span>: url  <span class="comment"># 防盗链，溯源本次请求由哪个url产生</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 修正视频地址</span></span><br><span class="line">resp = requests.get(url=videoStatus_url, headers=headers)</span><br><span class="line">dic = resp.json()</span><br><span class="line">system_time = dic[<span class="string">&quot;systemTime&quot;</span>]</span><br><span class="line">video_url = dic[<span class="string">&quot;videoInfo&quot;</span>][<span class="string">&quot;videos&quot;</span>][<span class="string">&quot;srcUrl&quot;</span>].replace(system_time, <span class="string">f&quot;cont-<span class="subst">&#123;contId&#125;</span>&quot;</span>)</span><br><span class="line">print(video_url)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 下载视频</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">f&quot;<span class="subst">&#123;contId&#125;</span>.mp4&quot;</span>, mode=<span class="string">&quot;wb&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    f.write(requests.get(video_url).content)</span><br></pre></td></tr></table></figure><h2 id="代理"><a href="#代理" class="headerlink" title="代理"></a>代理</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line">headers = &#123;</span><br><span class="line">    <span class="string">&quot;User-Agent&quot;</span>: <span class="string">&quot;User-Agent&quot;</span></span><br><span class="line">&#125;</span><br><span class="line">proxies = &#123;</span><br><span class="line">    <span class="string">&quot;https&quot;</span>: <span class="string">&quot;115.219.2.82:3256&quot;</span></span><br><span class="line">&#125;</span><br><span class="line">resp = requests.get(<span class="string">&quot;https://www.baidu.com&quot;</span>, headers=headers, proxies=proxies)</span><br><span class="line">resp.encoding = <span class="string">&quot;utf-8&quot;</span></span><br><span class="line">print(resp.text)</span><br></pre></td></tr></table></figure><h2 id="网易云音乐评论"><a href="#网易云音乐评论" class="headerlink" title="网易云音乐评论"></a>网易云音乐评论</h2><p><img src="/2021/06/%E7%88%AC%E8%99%ABPart3/image-20210603164018457.png" alt="image-20210603164018457"></p><ul><li>使用定位工具可以发现评论在html文件中的位置，但是不要忘了这是经过脚本生成的，并不是通过get使服务器返还的初始的网页源代码。</li></ul><p><img src="/2021/06/%E7%88%AC%E8%99%ABPart3/image-20210603163736597.png" alt="image-20210603163736597"></p><ul><li>网易云音乐的网页页面是由多个html拼接而成，因此可以看见有<strong>框架源代码</strong>和<strong>网页源代码</strong>两个html文件。</li><li>但是在两个html中搜寻，均没有评论资源。由此可知，评论是通过二次请求得到的。</li></ul><p><img src="/2021/06/%E7%88%AC%E8%99%ABPart3/image-20210603163551436.png" alt="image-20210603163551436"></p><ul><li>使用Network抓包工具-&gt;筛选XHR二次请求-&gt;找到comment资源</li></ul><p><img src="/2021/06/%E7%88%AC%E8%99%ABPart3/image-20210603164605502.png" alt="image-20210603164605502"></p><ul><li>继续查看headers信息。可知：<ol><li>请求目标的URL：<code>https://music.163.com/weapi/comment/resource/comments/get</code></li><li><code>csrf_token=</code>后为登录信息，<code>?</code>后的参数可以忽略</li><li><code>Request Method: POST</code>请求方式为<strong>POST</strong>。</li><li>同时发送了两个加密data：<code>params</code>和<code>encSecKey</code></li></ol></li></ul><p><img src="/2021/06/%E7%88%AC%E8%99%ABPart3/image-20210603170549795.png" alt="image-20210603170549795"></p><ul><li>查看发起请求之前所调用过的栈、js脚本执行的过程。最开始执行的在最底部。点击最后调用的脚本。</li></ul><p><img src="/2021/06/%E7%88%AC%E8%99%ABPart3/image-20210603171043357.png" alt="image-20210603171043357"></p><ul><li>现在是压缩过后的代码，需要点击正下方的按钮，更换成优质打印。</li></ul><p><img src="/2021/06/%E7%88%AC%E8%99%ABPart3/image-20210603171817947.png" alt="image-20210603171817947"></p><ul><li>在语句<code>send()</code>处设置断点，刷新网页</li><li>观察变量<code>request-&gt;url</code>，恢复程序执行直到更新为<code>https://music.163.com/weapi/comment/resource/comments/get</code></li><li>数据处于加密状态，因此需要通过调用堆栈不断回调函数，直到找到未加密的data</li></ul><p><img src="/2021/06/%E7%88%AC%E8%99%ABPart3/image-20210603173446525.png" alt="image-20210603173446525"></p><ul><li>回调时发现data未加密，立刻定位到加密函数为<code>t8l.be8W</code></li><li>数据在变量<code>i8a</code>与变量<code>e8e</code>之间完成了加密</li></ul><p><img src="/2021/06/%E7%88%AC%E8%99%ABPart3/image-20210603174358762.png" alt="image-20210603174358762"></p><ul><li>需要在已定的小范围内进一步缩小范围，因此在函数开始处增加新断点，重新刷新页面</li><li>发现在<code>window.asrsea()</code>方法中<code>i8a</code>作为参数之一，返回变量<code>bMl1x</code></li><li>发现变量<code>bMl1x</code>已经被加密，拥有<code>encSecKey</code>和<code>encText</code></li><li><code>bMl1x</code>的数据又赋给<code>e8e.data</code>，由此加密data完成</li></ul><h3 id="简易实现版"><a href="#简易实现版" class="headerlink" title="简易实现版"></a>简易实现版</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line">api = <span class="string">&quot;https://music.163.com/api/comment/resource/comments/get&quot;</span></span><br><span class="line">data = &#123;</span><br><span class="line">    <span class="string">&quot;cursor&quot;</span>: <span class="string">&quot;-1&quot;</span>,</span><br><span class="line">    <span class="string">&quot;offset&quot;</span>: <span class="string">&quot;0&quot;</span>,</span><br><span class="line">    <span class="string">&quot;orderType&quot;</span>: <span class="string">&quot;1&quot;</span>,</span><br><span class="line">    <span class="string">&quot;pageNo&quot;</span>: <span class="string">&quot;1&quot;</span>,</span><br><span class="line">    <span class="string">&quot;pageSize&quot;</span>: <span class="string">&quot;20&quot;</span>,</span><br><span class="line">    <span class="string">&quot;rid&quot;</span>: <span class="string">&quot;R_SO_4_1841819403&quot;</span>,</span><br><span class="line">    <span class="string">&quot;threadId&quot;</span>: <span class="string">&quot;R_SO_4_1841819403&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">resp = requests.get(api, params=data)</span><br><span class="line">json = resp.json()</span><br><span class="line">print(resp.json())</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 爬虫 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>爬虫Part2</title>
      <link href="/2021/05/%E7%88%AC%E8%99%ABPart2/"/>
      <url>/2021/05/%E7%88%AC%E8%99%ABPart2/</url>
      
        <content type="html"><![CDATA[<h1 id="爬虫Part2——数据解析与提取"><a href="#爬虫Part2——数据解析与提取" class="headerlink" title="爬虫Part2——数据解析与提取"></a>爬虫Part2——数据解析与提取</h1><p>[TOC]</p><h2 id="数据解析概述"><a href="#数据解析概述" class="headerlink" title="数据解析概述"></a>数据解析概述</h2><p>当需要只是需要部分网页的内容而不是全部时，就要用到数据提取：</p><ol><li><p>Re解析</p></li><li><p>Bs4解析</p></li><li><p>Xpath解析</p></li></ol><h2 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h2><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><p>正则表达式（Regular Expression）是⼀种使用表达式的方式对字符串进行匹配的语法规则。</p><p>在线测试正则表达式：<a href="https://tool.oschina.net/regex/">https://tool.oschina.net/regex/</a></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">元字符: 具有固定含义的特殊符号</span><br><span class="line"></span><br><span class="line">. 匹配除换⾏符以外的任意字符</span><br><span class="line">\w 匹配字⺟或数字或下划线</span><br><span class="line">\s 匹配任意的空⽩符</span><br><span class="line">\d 匹配数字</span><br><span class="line">\n 匹配⼀个换⾏符</span><br><span class="line">\t 匹配⼀个制表符</span><br><span class="line"></span><br><span class="line">^ 匹配字符串的开始</span><br><span class="line">$ 匹配字符串的结尾</span><br><span class="line"></span><br><span class="line">\W 匹配⾮字⺟或数字或下划线</span><br><span class="line">\D 匹配⾮数字</span><br><span class="line">\S 匹配⾮空⽩符</span><br><span class="line">a|b 匹配字符a或字符b</span><br><span class="line">() 匹配括号内的表达式，也表示⼀个组</span><br><span class="line">[...] 匹配字符组中的字符  # 是否属于[a-zA-Z0-9]</span><br><span class="line">[^...] 匹配除了字符组中字符的所有字符  # 这里^表示非</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">量词: 控制前⾯的元字符出现的次数</span><br><span class="line"></span><br><span class="line">* 重复零次或更多次(尽可能多地去匹配)</span><br><span class="line">+ 重复⼀次或更多次</span><br><span class="line">? 重复零次或⼀次</span><br><span class="line">&#123;n&#125; 重复n次</span><br><span class="line">&#123;n,&#125; 重复n次或更多次</span><br><span class="line">&#123;n,m&#125; 重复n到m次</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">匹配:贪婪匹配和惰性匹配</span><br><span class="line"></span><br><span class="line">.* 贪婪匹配  # 尽可能长的匹配</span><br><span class="line">.*? 惰性匹配  # 回溯到最短的一次匹配</span><br></pre></td></tr></table></figure><h3 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">str: 玩⼉吃鸡游戏, 晚上⼀起上游戏, ⼲嘛呢? 打游戏啊</span><br><span class="line">reg: 玩⼉.*?游戏</span><br><span class="line">结果: 玩⼉吃鸡游戏</span><br><span class="line">reg: 玩⼉.*游戏</span><br><span class="line">结果: 玩⼉吃鸡游戏, 晚上⼀起上游戏, ⼲嘛呢? 打游戏 </span><br><span class="line"> </span><br><span class="line">str: &lt;div&gt;胡辣汤&lt;/div&gt;</span><br><span class="line">reg: &lt;.*&gt;</span><br><span class="line">结果: &lt;div&gt;胡辣汤&lt;/div&gt;</span><br><span class="line">str: &lt;div&gt;胡辣汤&lt;/div&gt;</span><br><span class="line">reg: &lt;.*?&gt;</span><br><span class="line">结果: &lt;div&gt;      &lt;/div&gt;</span><br><span class="line"></span><br><span class="line">str: &lt;div&gt;胡辣汤&lt;/div&gt;&lt;span&gt;饭团&lt;/span&gt;</span><br><span class="line">reg: &lt;div&gt;.*?&lt;/div&gt;</span><br><span class="line">结果: &lt;div&gt;胡辣汤&lt;/div&gt;</span><br></pre></td></tr></table></figure><h2 id="Re模块-Regular-Expression"><a href="#Re模块-Regular-Expression" class="headerlink" title="Re模块(Regular Expression)"></a>Re模块(Regular Expression)</h2><h3 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h3><h4 id="findall"><a href="#findall" class="headerlink" title="findall()"></a>findall()</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># findall: 匹配字符串中所有符合正则的内容，返回list</span></span><br><span class="line">lst = re.findall(<span class="string">r&quot;\d+&quot;</span>, <span class="string">&quot;5点之前. 你要给我5000万&quot;</span>)</span><br><span class="line">print(lst)  </span><br><span class="line"></span><br><span class="line"><span class="comment"># [&#x27;5&#x27;, &#x27;5000&#x27;]</span></span><br></pre></td></tr></table></figure><blockquote><p>字符串前加r防止转义，表示原生字符串（rawstring）。</p><p>不使用r，则匹配时候需要4个反斜杠：正则需要转化一次，python解释器需要转化。</p></blockquote><h4 id="finditer"><a href="#finditer" class="headerlink" title="finditer()"></a>finditer()</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># finditer: 匹配字符串中所有符合正则的内容，返回iter</span></span><br><span class="line">it = re.finditer(<span class="string">r&quot;\d+&quot;</span>, <span class="string">&quot;5点之前. 你要给我5000万&quot;</span>)  <span class="comment"># 字符串前加r防止转义</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> it:</span><br><span class="line">    print(i)</span><br><span class="line">    print(i.group())</span><br><span class="line"></span><br><span class="line"><span class="comment"># &lt;_sre.SRE_Match object; span=(0, 1), match=&#x27;5&#x27;&gt;</span></span><br><span class="line"><span class="comment"># 5</span></span><br><span class="line"><span class="comment"># &lt;_sre.SRE_Match object; span=(10, 14), match=&#x27;5000&#x27;&gt;</span></span><br><span class="line"><span class="comment"># 5000</span></span><br></pre></td></tr></table></figure><ul><li>要使用.group()提取match对象的value</li></ul><h4 id="search"><a href="#search" class="headerlink" title="search()"></a>search()</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># search: 找到第一个就返回，返回的是match，使用group()提取</span></span><br><span class="line">s = re.search(<span class="string">r&quot;\d+&quot;</span>, <span class="string">&quot;5点之前. 你要给我5000万&quot;</span>)</span><br><span class="line">print(s.group())</span><br><span class="line"></span><br><span class="line"><span class="comment"># 5</span></span><br></pre></td></tr></table></figure><h4 id="match"><a href="#match" class="headerlink" title="match()"></a>match()</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># match: 从第一个字符开始要求匹配，返回的是match</span></span><br><span class="line">m = re.match(<span class="string">r&quot;\d+&quot;</span>, <span class="string">&quot;5点之前. 你要给我5000万&quot;</span>)</span><br><span class="line">print(m.group())</span><br><span class="line"></span><br><span class="line"><span class="comment"># 5</span></span><br></pre></td></tr></table></figure><ul><li>如果字符串为<code>&quot;在5点之前. 你要给我5000万&quot;</code>则匹配失败</li><li>相当于自带<code>^</code></li></ul><h4 id="compile"><a href="#compile" class="headerlink" title="compile()"></a>compile()</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">rule = re.<span class="built_in">compile</span>(<span class="string">r&quot;\d+&quot;</span>)</span><br><span class="line">lst = rule.findall(<span class="string">&quot;5点之前. 你要给我5000万&quot;</span>)</span><br><span class="line">print(lst)</span><br><span class="line"></span><br><span class="line"><span class="comment"># [&#x27;5&#x27;, &#x27;5000&#x27;]</span></span><br><span class="line"></span><br><span class="line">m = rule.match(<span class="string">&quot;5点之前. 你要给我5000万&quot;</span>)</span><br><span class="line">print(m.group())</span><br><span class="line"></span><br><span class="line"><span class="comment"># 5</span></span><br></pre></td></tr></table></figure><ul><li>预加载正则表达式</li><li>可以反复使用</li></ul><h4 id="group"><a href="#group" class="headerlink" title="group()"></a>group()</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">s = <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">&lt;div class=&#x27;⻄游记&#x27;&gt;&lt;span id=&#x27;1&#x27;&gt;中国联通&lt;/span&gt;&lt;/div&gt;</span></span><br><span class="line"><span class="string">&lt;div class=&#x27;⻄&#x27;&gt;&lt;span id=&#x27;2&#x27;&gt;中国&lt;/span&gt;&lt;/div&gt;</span></span><br><span class="line"><span class="string">&lt;div class=&#x27;游&#x27;&gt;&lt;span id=&#x27;3&#x27;&gt;联通&lt;/span&gt;&lt;/div&gt;</span></span><br><span class="line"><span class="string">&lt;div class=&#x27;记&#x27;&gt;&lt;span id=&#x27;4&#x27;&gt;中通&lt;/span&gt;&lt;/div&gt;</span></span><br><span class="line"><span class="string">&lt;div class=&#x27;⻄记&#x27;&gt;&lt;span id=&#x27;5&#x27;&gt;国联&lt;/span&gt;&lt;/div&gt;</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line">obj = re.<span class="built_in">compile</span>(<span class="string">r&quot;&lt;div class=&#x27;(?P&lt;class&gt;.*?&#x27;&gt;&lt;span id)=&#x27;(?P&lt;id&gt;\d+)&#x27;&gt;(?P&lt;val&gt;.*?)&lt;/span&gt;&lt;/div&gt;&quot;</span>, re.S)  <span class="comment"># re.S表示使.能够匹配换行符</span></span><br><span class="line">result = obj.search(s)</span><br><span class="line">print(result.group())  <span class="comment"># &lt;div class=&#x27;⻄游记&#x27;&gt;&lt;span id=&#x27;1&#x27;&gt;中国联通&lt;/span&gt;&lt;/div&gt;</span></span><br><span class="line">print(result.group(<span class="string">&quot;id&quot;</span>))  <span class="comment"># 1</span></span><br><span class="line">print(result.group(<span class="string">&quot;val&quot;</span>))  <span class="comment"># 中国联通</span></span><br><span class="line">print(result.group(<span class="string">&quot;class&quot;</span>))  <span class="comment"># ⻄游记&#x27;&gt;&lt;span id</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>分组：使用<code>(?P&lt;变量名&gt;正则表达式)</code>进一步提取内容</li></ul><h3 id="实战案例"><a href="#实战案例" class="headerlink" title="实战案例"></a>实战案例</h3><h4 id="豆瓣top250电影排行"><a href="#豆瓣top250电影排行" class="headerlink" title="豆瓣top250电影排行"></a>豆瓣top250电影排行</h4><ul><li>首先要确认目标数据位置（源码or抓包）</li><li>抓不到的时候首先看<code>User-Agent</code></li><li>次数太频繁的时候记得<code>Keep-Alive</code></li><li>正则表达式写的越详细越容易匹配</li><li>①用<code>\n\s*</code>去匹配换行和空格；②用<code>.strip()</code>去除空格</li><li><code>match.groupdict()</code>转换成字典</li><li><code>newline=&quot;&quot;</code>不使用自动换行符</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> csv</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line"><span class="comment"># 预编译正则表达式: &quot;电影名称&quot;,&quot;上映年份&quot;,&quot;评分&quot;,&quot;评分⼈数&quot;</span></span><br><span class="line">rule = re.<span class="built_in">compile</span>(<span class="string">r&#x27;&lt;li&gt;.*?&lt;span class=&quot;title&quot;&gt;(?P&lt;name&gt;.*?)&lt;/span&gt;.*?&#x27;</span></span><br><span class="line">                  <span class="string">r&#x27;&lt;br&gt;\n\s*(?P&lt;year&gt;\d+)&amp;nbsp;/&amp;nbsp;.*?&#x27;</span></span><br><span class="line">                  <span class="string">r&#x27;property=&quot;v:average&quot;&gt;(?P&lt;score&gt;.*?)&lt;/span&gt;.*?&#x27;</span></span><br><span class="line">                  <span class="string">r&#x27;&lt;span&gt;(?P&lt;person&gt;.*?)人评价&lt;/span&gt;&#x27;</span>, re.S)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 准备文件写入</span></span><br><span class="line">f = <span class="built_in">open</span>(<span class="string">&quot;data.csv&quot;</span>, mode=<span class="string">&quot;w&quot;</span>, encoding=<span class="string">&quot;utf-8&quot;</span>, newline=<span class="string">&quot;&quot;</span>)  <span class="comment"># 设置newline=&quot;&quot;不使用多余换行符</span></span><br><span class="line">csv_writer = csv.writer(f)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取网页源码</span></span><br><span class="line">url = <span class="string">&quot;https://movie.douban.com/top250&quot;</span></span><br><span class="line">headers = &#123;</span><br><span class="line">    <span class="string">&quot;user-agent&quot;</span>: <span class="string">&quot;user-agent&quot;</span>,</span><br><span class="line">    <span class="string">&#x27;Keep-Alive&#x27;</span>: <span class="string">&#x27;timeout=15&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> p <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="number">250</span>, <span class="number">25</span>):</span><br><span class="line">    <span class="comment"># 跳转多个页面</span></span><br><span class="line">    params = &#123;</span><br><span class="line">        <span class="string">&#x27;start&#x27;</span>: p</span><br><span class="line">    &#125;</span><br><span class="line">    resp = requests.get(url=url, headers=headers, params=params)</span><br><span class="line">    <span class="comment"># print(resp.text)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 数据解析</span></span><br><span class="line">    result = rule.finditer(resp.text)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> result:</span><br><span class="line">        <span class="comment"># print(i.group(&quot;name&quot;))</span></span><br><span class="line">        <span class="comment"># print(i.group(&quot;year&quot;))  # 取出空白符也可以使用.strip()</span></span><br><span class="line">        <span class="comment"># print(i.group(&quot;score&quot;))</span></span><br><span class="line">        <span class="comment"># print(i.group(&quot;person&quot;))</span></span><br><span class="line">        dic = i.groupdict()  <span class="comment"># 转换成dict</span></span><br><span class="line">        print(dic)</span><br><span class="line">        csv_writer.writerow(dic.values())</span><br><span class="line"></span><br><span class="line">f.close()</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="电影天堂板块信息"><a href="#电影天堂板块信息" class="headerlink" title="电影天堂板块信息"></a>电影天堂板块信息</h4><ul><li>html中标签<code>&lt;a href=&#39;url&#39;&gt;xxx&lt;/a&gt;</code>表示超链接</li><li>当编码不一致时，根据网页源代码的标注信息<code>charset=gb2312</code>进行修正： <code>resp.encoding = &quot;gb2312&quot;</code></li><li><code>verify=False</code>去除安全认证</li><li>拼接域名时要注意<code>/</code>数量</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line"><span class="comment"># 1.获取主页源码</span></span><br><span class="line">domain = <span class="string">&quot;https://www.dytt89.com/&quot;</span></span><br><span class="line">resp = requests.get(domain, verify=<span class="literal">False</span>)  <span class="comment"># 去除安全认证</span></span><br><span class="line">resp.encoding = <span class="string">&quot;gb2312&quot;</span>  <span class="comment"># 修改成指定字符集</span></span><br><span class="line"><span class="comment"># print(resp.text)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 2.定位2021必看片板块</span></span><br><span class="line">rule1 = re.<span class="built_in">compile</span>(<span class="string">r&quot;2021必看热片.*?&lt;ul&gt;(?P&lt;ul&gt;.*?)&lt;/ul&gt;&quot;</span>, re.S)</span><br><span class="line">result1 = rule1.search(resp.text)</span><br><span class="line">ul = result1.group(<span class="string">&quot;ul&quot;</span>).strip()</span><br><span class="line"><span class="comment"># print(ul)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 3.从板块中提取子页面的链接地址</span></span><br><span class="line">rule2 = re.<span class="built_in">compile</span>(<span class="string">r&quot;href=&#x27;(?P&lt;href&gt;.*?)&#x27;&quot;</span>, re.S)</span><br><span class="line">result2 = rule2.finditer(ul)</span><br><span class="line">child_href_list = []</span><br><span class="line"><span class="keyword">for</span> h <span class="keyword">in</span> result2:</span><br><span class="line">    child_href = domain + h.group(<span class="string">&quot;href&quot;</span>).strip(<span class="string">&quot;/&quot;</span>)  <span class="comment"># domain中也有/，去掉一个</span></span><br><span class="line">    child_href_list.append(child_href)</span><br><span class="line">    <span class="comment"># print(child_href)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 4.请求子页面地址，拿到下载地址</span></span><br><span class="line">rule3 = re.<span class="built_in">compile</span>(<span class="string">r&#x27;&lt;meta name=keywords content=&quot;(?P&lt;name&gt;.*?)下载&quot;&gt;.*?&#x27;</span></span><br><span class="line">                   <span class="string">r&#x27;&lt;td style=&quot;WORD-WRAP: break-word&quot; bgcolor=&quot;#fdfddf&quot;&gt;&lt;a href=&quot;(?P&lt;download&gt;.*?)&quot;&gt;&#x27;</span>, re.S)</span><br><span class="line">download_list = &#123;&#125;</span><br><span class="line"><span class="keyword">for</span> c <span class="keyword">in</span> child_href_list:</span><br><span class="line">    child_resp = requests.get(c, verify=<span class="literal">False</span>)  <span class="comment"># 去除安全认证</span></span><br><span class="line">    child_resp.encoding = <span class="string">&quot;gb2312&quot;</span>  <span class="comment"># 修改成指定字符集</span></span><br><span class="line">    result3 = rule3.search(child_resp.text)</span><br><span class="line">    download_list[result3.group(<span class="string">&quot;name&quot;</span>)] = result3.group(<span class="string">&quot;download&quot;</span>)</span><br><span class="line">    </span><br><span class="line"><span class="keyword">for</span> d <span class="keyword">in</span> download_list.items():</span><br><span class="line">    print(d)</span><br></pre></td></tr></table></figure><h2 id="Bs4模块-Beautiful-Soup"><a href="#Bs4模块-Beautiful-Soup" class="headerlink" title="Bs4模块(Beautiful Soup)"></a>Bs4模块(Beautiful Soup)</h2><h3 id="html语法规则"><a href="#html语法规则" class="headerlink" title="html语法规则"></a>html语法规则</h3><p>HTML(Hyper Text Markup Language)超文本标记语言，是我们编写网页的最基本也是最核心的⼀种语⾔，其语法规则就是用不同的标签对网页上的内容进行标记，从⽽使网页显示出不同的展示效果。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--第一种标记--&gt;</span></span><br><span class="line">&lt;标签 </span><br><span class="line">    属性=&quot;值&quot; </span><br><span class="line">    属性=&quot;值&quot;&gt;</span><br><span class="line">    被标记的内容</span><br><span class="line">&lt;/标签&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--第二种标记--&gt;</span></span><br><span class="line">&lt;标签 属性=&quot;值&quot; </span><br><span class="line">    属性=&quot;值&quot;/&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="基本使用-1"><a href="#基本使用-1" class="headerlink" title="基本使用"></a>基本使用</h3><p>通过网页源码建立<code>BeautifulSoup</code>对象，来检索页面源代码中的html标签。</p><ul><li><code>find(标签, 属性=值)</code>  只找一个</li><li><code>find_all(标签, 属性=值)</code>  找出所有</li></ul><h3 id="实战案例-1"><a href="#实战案例-1" class="headerlink" title="实战案例"></a>实战案例</h3><h4 id="新发地菜价"><a href="#新发地菜价" class="headerlink" title="新发地菜价"></a>新发地菜价</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> csv</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup</span><br><span class="line"></span><br><span class="line">url = <span class="string">&quot;http://www.xinfadi.com.cn/marketanalysis/0/list/1.shtml&quot;</span></span><br><span class="line">resp = requests.get(url)</span><br><span class="line"></span><br><span class="line">f = <span class="built_in">open</span>(<span class="string">&quot;菜价.csv&quot;</span>, mode=<span class="string">&quot;w&quot;</span>, encoding=<span class="string">&quot;utf-8&quot;</span>, newline=<span class="string">&quot;&quot;</span>)</span><br><span class="line">csv_writer = csv.writer(f)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 1. 把页面源代码交给BeautifulSoup进行处理, 生成bs对象</span></span><br><span class="line">page = BeautifulSoup(resp.text, <span class="string">&quot;html.parser&quot;</span>)  <span class="comment"># 指定html解析器</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 从bs对象中查找数据，找到目标表格</span></span><br><span class="line">attrs = &#123;</span><br><span class="line">    <span class="string">&quot;class&quot;</span>: <span class="string">&quot;hq_table&quot;</span></span><br><span class="line">&#125;</span><br><span class="line">table = page.find(<span class="string">&quot;table&quot;</span>, attrs=attrs)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. 拿到有效的数据行</span></span><br><span class="line">trs = table.find_all(<span class="string">&quot;tr&quot;</span>)[<span class="number">1</span>:]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 4. 对每行数据分解属性</span></span><br><span class="line"><span class="keyword">for</span> tr <span class="keyword">in</span> trs:</span><br><span class="line">    tds = tr.find_all(<span class="string">&quot;td&quot;</span>)  <span class="comment"># 拿到每行中的td</span></span><br><span class="line">    name = tds[<span class="number">0</span>].text  <span class="comment"># .text 表示拿到被标签标记的内容</span></span><br><span class="line">    low = tds[<span class="number">1</span>].text</span><br><span class="line">    avg = tds[<span class="number">2</span>].text</span><br><span class="line">    high = tds[<span class="number">3</span>].text</span><br><span class="line">    spec = tds[<span class="number">4</span>].text  <span class="comment"># 规格</span></span><br><span class="line">    unit = tds[<span class="number">5</span>].text  <span class="comment"># 单位</span></span><br><span class="line">    day = tds[<span class="number">6</span>].text  <span class="comment"># 发布日期</span></span><br><span class="line">    print(name, low, avg, high, spec, unit, day)</span><br><span class="line">    csv_writer.writerow([name, low, avg, high, spec, unit, day])</span><br><span class="line"></span><br><span class="line">f.close()</span><br></pre></td></tr></table></figure><ul><li><p>这里通过URL可以发现</p></li><li><p>规避Python关键字属性的方法</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">table = page.find(<span class="string">&quot;table&quot;</span>, class_=<span class="string">&quot;hq_table&quot;</span>)</span><br><span class="line">table = page.find(<span class="string">&quot;table&quot;</span>, attrs=&#123;<span class="string">&quot;class&quot;</span>: <span class="string">&quot;hq_table&quot;</span>&#125;)</span><br></pre></td></tr></table></figure><h4 id="优美图库"><a href="#优美图库" class="headerlink" title="优美图库"></a>优美图库</h4></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup</span><br><span class="line"></span><br><span class="line">url = <span class="string">&quot;https://www.umei.cc/bizhitupian/weimeibizhi/&quot;</span></span><br><span class="line">resp = requests.get(url=url)</span><br><span class="line">resp.encoding = <span class="string">&quot;utf-8&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 解析主页面</span></span><br><span class="line">main_page = BeautifulSoup(resp.text, <span class="string">&quot;html.parser&quot;</span>)</span><br><span class="line">a_list = main_page.find(<span class="string">&quot;div&quot;</span>, class_=<span class="string">&quot;TypeList&quot;</span>).find_all(<span class="string">&quot;a&quot;</span>)</span><br><span class="line"><span class="keyword">for</span> a <span class="keyword">in</span> a_list:</span><br><span class="line">    href = url + a.get(<span class="string">&quot;href&quot;</span>).split(<span class="string">&quot;/&quot;</span>)[-<span class="number">1</span>]  <span class="comment"># 手动拼接url</span></span><br><span class="line">    <span class="comment"># print(href)</span></span><br><span class="line">    child_page_resp = requests.get(href)</span><br><span class="line">    child_page_resp.encoding = <span class="string">&quot;utf-8&quot;</span></span><br><span class="line">    <span class="comment"># 解析子界面</span></span><br><span class="line">    child_page = BeautifulSoup(child_page_resp.text, <span class="string">&quot;html.parser&quot;</span>)</span><br><span class="line">    p = child_page.find(<span class="string">&quot;p&quot;</span>, align=<span class="string">&quot;center&quot;</span>)  <span class="comment"># 找到标签为p、居中对齐的超文本</span></span><br><span class="line">    img = p.find(<span class="string">&quot;img&quot;</span>)  <span class="comment"># 找到标签为img的超文本</span></span><br><span class="line">    src = img.get(<span class="string">&quot;src&quot;</span>)  <span class="comment"># 取出src属性的值</span></span><br><span class="line">    <span class="comment"># 下载图片</span></span><br><span class="line">    img_resp = requests.get(src)  <span class="comment"># 该响应文件本身就是图片</span></span><br><span class="line">    img_name = src.split(<span class="string">&quot;/&quot;</span>)[-<span class="number">1</span>]  <span class="comment"># 设定文件名</span></span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;source/&quot;</span> + img_name, mode=<span class="string">&quot;wb&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        f.write(img_resp.content)  <span class="comment"># 将拿到的响应内容以字节流形式写入文件</span></span><br><span class="line">    print(img_name + <span class="string">&quot; has been downloaded!&quot;</span>)</span><br></pre></td></tr></table></figure><h2 id="Xpath"><a href="#Xpath" class="headerlink" title="Xpath"></a>Xpath</h2><h3 id="基本使用-2"><a href="#基本使用-2" class="headerlink" title="基本使用"></a>基本使用</h3><p>XPath是一门在 XML 文档中查找信息的语言。XPath可⽤来在 XML文档中对元素和属性进行遍历，而我们熟知的HTML恰巧属于XML的⼀个⼦集，所以完全可以用Xpath去查找html中的内容。</p><ul><li>demo1：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> lxml <span class="keyword">import</span> etree</span><br><span class="line"></span><br><span class="line">xml = <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">&lt;book&gt;</span></span><br><span class="line"><span class="string">    &lt;id&gt;1&lt;/id&gt;</span></span><br><span class="line"><span class="string">    &lt;name&gt;野花遍地⾹&lt;/name&gt;</span></span><br><span class="line"><span class="string">    &lt;price&gt;1.23&lt;/price&gt;</span></span><br><span class="line"><span class="string">    &lt;nick&gt;臭⾖腐&lt;/nick&gt;</span></span><br><span class="line"><span class="string">    &lt;author&gt;</span></span><br><span class="line"><span class="string">        &lt;nick id=&quot;10086&quot;&gt;周⼤强&lt;/nick&gt;</span></span><br><span class="line"><span class="string">        &lt;nick id=&quot;10010&quot;&gt;周芷若&lt;/nick&gt;</span></span><br><span class="line"><span class="string">        &lt;nick class=&quot;joy&quot;&gt;周杰伦&lt;/nick&gt;</span></span><br><span class="line"><span class="string">        &lt;nick class=&quot;jolin&quot;&gt;蔡依林&lt;/nick&gt;</span></span><br><span class="line"><span class="string">        &lt;div&gt;</span></span><br><span class="line"><span class="string">            &lt;nick&gt;惹了&lt;/nick&gt;</span></span><br><span class="line"><span class="string">        &lt;/div&gt;</span></span><br><span class="line"><span class="string">    &lt;/author&gt;</span></span><br><span class="line"><span class="string">    &lt;partner&gt;</span></span><br><span class="line"><span class="string">        &lt;nick id=&quot;ppc&quot;&gt;胖胖陈&lt;/nick&gt;</span></span><br><span class="line"><span class="string">        &lt;nick id=&quot;ppbc&quot;&gt;胖胖不陈&lt;/nick&gt;</span></span><br><span class="line"><span class="string">    &lt;/partner&gt;</span></span><br><span class="line"><span class="string">&lt;/book&gt;</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">tree = etree.XML(xml)</span><br><span class="line">result = tree.xpath(<span class="string">&quot;/book&quot;</span>)  <span class="comment"># [&lt;Element book at 0x26943009048&gt;]</span></span><br><span class="line">result = tree.xpath(<span class="string">&quot;/book/name&quot;</span>)  <span class="comment"># [&lt;Element name at 0x2403a5ffb48&gt;]</span></span><br><span class="line">result = tree.xpath(<span class="string">&quot;/book/name/text()&quot;</span>)  <span class="comment"># [&#x27;野花遍地⾹&#x27;]</span></span><br><span class="line">result = tree.xpath(<span class="string">&quot;/book/author/nick&quot;</span>)  <span class="comment"># [&lt;Element nick at 0x2702b1dfb08&gt;, ……, &lt;Element nick at 0x2702b3516c8&gt;]</span></span><br><span class="line">result = tree.xpath(<span class="string">&quot;/book/author/nick/text()&quot;</span>)  <span class="comment"># [&#x27;周⼤强&#x27;, &#x27;周芷若&#x27;, &#x27;周杰伦&#x27;, &#x27;蔡依林&#x27;]</span></span><br><span class="line">result = tree.xpath(<span class="string">&quot;/book/author/div/nick/text()&quot;</span>)  <span class="comment"># [&#x27;惹了&#x27;]</span></span><br><span class="line">result = tree.xpath(<span class="string">&quot;/book/author//nick/text()&quot;</span>)  <span class="comment"># 任意层后代 [&#x27;周⼤强&#x27;, &#x27;周芷若&#x27;, &#x27;周杰伦&#x27;, &#x27;蔡依林&#x27;, &#x27;惹了&#x27;]</span></span><br><span class="line">result = tree.xpath(<span class="string">&quot;/book/author/*/nick/text()&quot;</span>)  <span class="comment"># 单层通配符 [&#x27;惹了&#x27;]</span></span><br><span class="line"></span><br><span class="line">print(result)</span><br></pre></td></tr></table></figure><ul><li>demo2：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> lxml <span class="keyword">import</span> etree</span><br><span class="line"></span><br><span class="line">tree = etree.parse(<span class="string">&quot;my_html.html&quot;</span>)</span><br><span class="line">result = tree.xpath(<span class="string">&quot;/html/body/ul/li/a/text()&quot;</span>)  <span class="comment"># [&#x27;百度&#x27;, &#x27;⾕歌&#x27;, &#x27;搜狗&#x27;]  使用开发者工具快速定位xpath</span></span><br><span class="line">result = tree.xpath(<span class="string">&quot;/html/body/ul/li[1]/a/text()&quot;</span>)  <span class="comment"># [&#x27;百度&#x27;]  从1开始计数</span></span><br><span class="line">result = tree.xpath(<span class="string">&quot;/html/body/ol/li/a[@href=&#x27;dapao&#x27;]/text()&quot;</span>)  <span class="comment"># [&#x27;⼤炮&#x27;]  属性筛选</span></span><br><span class="line">result_list = tree.xpath(<span class="string">&quot;/html/body/ol/li&quot;</span>)</span><br><span class="line"><span class="keyword">for</span> result <span class="keyword">in</span> result_list:</span><br><span class="line">    r1 = result.xpath(<span class="string">&quot;./a/text()&quot;</span>)</span><br><span class="line">    print(r1)  <span class="comment"># ./ 当前位置</span></span><br><span class="line">    r2 = result.xpath(<span class="string">&quot;./a/@href&quot;</span>)</span><br><span class="line">    print(r2)  <span class="comment"># @ 提取属性值</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="开发者工具使用技巧"><a href="#开发者工具使用技巧" class="headerlink" title="开发者工具使用技巧"></a>开发者工具使用技巧</h3><ul><li>快速定位网页资源在HTML中的位置</li></ul><p><img src="/2021/05/%E7%88%AC%E8%99%ABPart2/image-20210602214418408.png" alt="image-20210602214418408"></p><ul><li>快速获取XPath，并做一些微调</li></ul><p><img src="/2021/05/%E7%88%AC%E8%99%ABPart2/image-20210602214849284.png" alt="image-20210602214849284"></p><h3 id="实战案例-2"><a href="#实战案例-2" class="headerlink" title="实战案例"></a>实战案例</h3><h4 id="猪八戒网"><a href="#猪八戒网" class="headerlink" title="猪八戒网"></a>猪八戒网</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">from</span> lxml <span class="keyword">import</span> etree</span><br><span class="line"><span class="keyword">import</span> csv</span><br><span class="line"></span><br><span class="line">f = <span class="built_in">open</span>(<span class="string">&quot;猪八戒.csv&quot;</span>, mode=<span class="string">&quot;w&quot;</span>, encoding=<span class="string">&quot;utf-8&quot;</span>, newline=<span class="string">&quot;&quot;</span>)</span><br><span class="line">csv_writer = csv.writer(f)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获得主页面</span></span><br><span class="line">url = <span class="string">&quot;https://beijing.zbj.com/search/f/?type=new&amp;kw=saas&quot;</span></span><br><span class="line">resp = requests.get(url=url)</span><br><span class="line">html = etree.HTML(resp.text)</span><br><span class="line">divs = html.xpath(<span class="string">&quot;/html/body/div[6]/div/div/div[2]/div[5]/div[1]/div&quot;</span>)  <span class="comment"># 先定位到div[1]，然后改成div</span></span><br><span class="line"><span class="comment"># 每一个服务商</span></span><br><span class="line"><span class="keyword">for</span> div <span class="keyword">in</span> divs:</span><br><span class="line">    price = div.xpath(<span class="string">&#x27;./div/div/a[1]/div[2]/div[1]/span[1]/text()&#x27;</span>)[<span class="number">0</span>].strip(<span class="string">&quot;¥&quot;</span>)  <span class="comment"># 使用工具定位完整xpath，然后将重复地址替换./</span></span><br><span class="line">    title = <span class="string">&quot;SAAS&quot;</span>.join(div.xpath(<span class="string">&#x27;./div/div/a[1]/div[2]/div[2]/p/text()&#x27;</span>))  <span class="comment"># join()通过指定字符连接序列中元素，生成新字符串</span></span><br><span class="line">    company_name = div.xpath(<span class="string">&#x27;./div/div/a[2]/div[1]/p/text()&#x27;</span>)[<span class="number">0</span>]</span><br><span class="line">    location = div.xpath(<span class="string">&quot;./div/div/a[2]/div[1]/div/span/text()&quot;</span>)[<span class="number">0</span>]</span><br><span class="line">    csv_writer.writerow([price, title, company_name, location])</span><br><span class="line">    print([price, title, company_name, location])</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 爬虫 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>爬虫Part1</title>
      <link href="/2021/05/%E7%88%AC%E8%99%ABPart1/"/>
      <url>/2021/05/%E7%88%AC%E8%99%ABPart1/</url>
      
        <content type="html"><![CDATA[<h1 id="爬虫Part1——原理与request入门"><a href="#爬虫Part1——原理与request入门" class="headerlink" title="爬虫Part1——原理与request入门"></a>爬虫Part1——原理与request入门</h1><p>[TOC]</p><h2 id="基本知识"><a href="#基本知识" class="headerlink" title="基本知识"></a>基本知识</h2><p>爬虫：模拟浏览器抓取网站资源。</p><p>爬⾍在法律上是不被禁⽌的，但是也具有违法⻛险。因此使用爬虫我们要做到：</p><ul><li>不能影响⽹站的正常运营</li><li>不能窃取⽤户隐私和商业机密等敏感内容</li><li>遵循 robots.txt 协议</li></ul><h2 id="第一个爬虫"><a href="#第一个爬虫" class="headerlink" title="第一个爬虫"></a>第一个爬虫</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> urllib.request <span class="keyword">import</span> urlopen</span><br><span class="line"></span><br><span class="line">url = <span class="string">&quot;https://www.baidu.com&quot;</span></span><br><span class="line">resp = urlopen(url)</span><br><span class="line"></span><br><span class="line">print(resp)  <span class="comment"># 响应地址 &lt;http.client.HTTPResponse object at 0x00000174ADF4F128&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;my_baidu.html&quot;</span>, mode=<span class="string">&quot;w&quot;</span>, encoding=<span class="string">&quot;utf-8&quot;</span>) <span class="keyword">as</span> f:  <span class="comment"># 写入保存网页源代码</span></span><br><span class="line">    f.write(resp.read().decode(<span class="string">&quot;utf-8&quot;</span>))  <span class="comment"># resp不能read()两次</span></span><br></pre></td></tr></table></figure><ul><li>在win10中必须加上 utf-8，否则使用环境默认值 gbk</li><li>网页本质就是html文件</li><li>在网页源码中有标记解码方式</li></ul><blockquote><p>使用edge要在 <a href="https://msedgewebdriverstorage.z22.web.core.windows.net/">官网</a> 下载对应版本的driver，pycharm中用浏览器打开地址都使用driver：</p><p>driver放在python根目录下：D:\Programming Kits\Python36\msedgedriver.exe</p><p>edge默认在：C:\Program Files (x86)\Microsoft\Edge\Application\msedge.exe</p></blockquote><h2 id="Web请求过程解析"><a href="#Web请求过程解析" class="headerlink" title="Web请求过程解析"></a>Web请求过程解析</h2><p>网页上所有的数据不一定全在页面源代码中，这关系到常⻅的两种⻚⾯渲染过程：</p><ol><li><p>服务器渲染</p><p>在请求到服务器的时候，服务器直接把数据全部写入到html中，因此我们能直接拿到带有数据的html内容，我们能看到的数据都在页面源代码中能找的到。</p></li><li><p>前端JS渲染</p><p>这种机制⼀般是第⼀次请求服务器返回基本的HTML框架结构，然后再次请求到数据库服务器，由这个服务器返回数据，最后在浏览器上对数据进⾏加载。</p><p>这便对应异步请求，在我们进行页面滚动时，浏览器向服务器发送数据请求。</p><p>这样做的好处是服务器缓解压力，而且分工明确，容易维护。</p></li></ol><p>两种渲染对于爬虫都各有利弊。</p><h2 id="Http协议"><a href="#Http协议" class="headerlink" title="Http协议"></a>Http协议</h2><p>协议：就是两个计算机之间为了能够流畅的进⾏沟通⽽设置的⼀个协定。常⻅的协议有TCP/IP、SOAP协议、HTTP协议、SMTP协议等等…..</p><ul><li>HTTP协议，超⽂本传输协议（Hyper Text Transfer Protocol）的缩写，是⽤于从万维⽹（WWW：World Wide Web）服务器传输超⽂本到本地浏览器的传送协议。</li><li>HTTP协议把⼀条消息分为三⼤块内容。</li></ul><p>请求：</p><ul><li>请求行 -&gt; 请求方式（method:get/post）、请求地址（authority:url）、协议（scheme:https）、浏览器接受数据的要求（accept:）</li><li>请求头 -&gt; 服务器要使用的附加信息（cookie），设备和浏览器信息（user-agent:）</li><li>请求体 -&gt; 请求参数</li></ul><p>响应：</p><ul><li>状态⾏ -&gt; 协议、状态码（200请求成功/404页面不存在/500服务器崩溃/302重定向）</li><li>响应头 -&gt; 客户端要使⽤的附加信息</li><li>响应体 -&gt; 服务器返回客户端真正要⽤的内容（HTML、json等）</li></ul><p>写爬⾍的时候要格外注意请求头和响应头，这两个地⽅⼀般都隐含着⼀些⽐较重要的内容。</p><p><img src="/2021/05/%E7%88%AC%E8%99%ABPart1/image-20210519182940008.png" alt="image-20210519182940008"></p><p>请求头中最常⻅的⼀些重要内容（爬⾍需要）:</p><ol><li><p>User-Agent：请求载体的身份标识（用啥发送的请求）</p></li><li><p>Referer：防盗链（这次请求是从哪个页面来的，反爬会⽤到）</p></li><li><p>cookie：本地字符串数据信息（用户登录信息，反爬的token）</p></li></ol><p>响应头中⼀些重要的内容:</p><ol><li><p>cookie</p></li><li><p>各种神奇的莫名其妙的字符串（⼀般都是token字样, 防止各种攻击和反爬）</p></li></ol><p>请求⽅式：</p><ol><li>GET：显式提交。主要从服务器获取数据</li><li>POST：隐式提交。主要向服务器传送数据</li></ol><blockquote><p>如果请求的方式是get或head，则只发送消息头到服务器；如果是post请求，那么消息体（网页表单内容）和消息头都将传送到服务器。因此，用get速度更快，但由于url暴露在用户面前，可能导致sql注入等非法攻击； 用post提交，速度会慢一些，但是由于url是隐藏在了表单中，所以安全性会好一点。这就是为什么，一般登录页面都用post提交而不用get提交。</p></blockquote><h2 id="request入门"><a href="#request入门" class="headerlink" title="request入门"></a>request入门</h2><h3 id="GET显式提交"><a href="#GET显式提交" class="headerlink" title="GET显式提交"></a>GET显式提交</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line">query = <span class="string">&quot;Python&quot;</span></span><br><span class="line">url = <span class="string">f&quot;https://www.baidu.com/s?wd=<span class="subst">&#123;query&#125;</span>&quot;</span></span><br><span class="line">headers = &#123;</span><br><span class="line">    <span class="string">&quot;user-agent&quot;</span>: <span class="string">&quot;your-user-agent&quot;</span></span><br><span class="line">&#125;  <span class="comment"># 设置user-agent以处理反爬</span></span><br><span class="line">reps = requests.get(url=url, headers=headers)</span><br><span class="line"></span><br><span class="line">print(reps)  <span class="comment"># &lt;Response [200]&gt;</span></span><br><span class="line"><span class="comment"># print(reps.text)  # 页面源代码</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;Python.html&quot;</span>, mode=<span class="string">&quot;w&quot;</span>, encoding=<span class="string">&quot;utf-8&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    f.write(reps.text)</span><br></pre></td></tr></table></figure><ul><li>地址栏链接统一都是GET方式</li></ul><h3 id="POST隐式提交"><a href="#POST隐式提交" class="headerlink" title="POST隐式提交"></a>POST隐式提交</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line">url = <span class="string">&quot;https://fanyi.baidu.com/sug&quot;</span></span><br><span class="line">kw = <span class="string">&quot;dog&quot;</span></span><br><span class="line">data = &#123;</span><br><span class="line">    <span class="string">&quot;kw&quot;</span>: kw</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">resp = requests.post(url, data=data)</span><br><span class="line">print(resp.json())</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">&#123;&#x27;errno&#x27;: 0,</span></span><br><span class="line"><span class="string"> &#x27;data&#x27;: [&#123;&#x27;k&#x27;: &#x27;dog&#x27;, &#x27;v&#x27;: &#x27;n. 狗; 蹩脚货; 丑女人; 卑鄙小人 v. 困扰; 跟踪&#x27;&#125;, </span></span><br><span class="line"><span class="string">          &#123;&#x27;k&#x27;: &#x27;DOG&#x27;, &#x27;v&#x27;: &#x27;abbr. Data Output Gate 数据输出门&#x27;&#125;,</span></span><br><span class="line"><span class="string">          &#123;&#x27;k&#x27;: &#x27;doge&#x27;, &#x27;v&#x27;: &#x27;n. 共和国总督&#x27;&#125;, </span></span><br><span class="line"><span class="string">          &#123;&#x27;k&#x27;: &#x27;dogm&#x27;, &#x27;v&#x27;: &#x27;abbr. dogmatic 教条的; 独断的; dogmatism 教条主义; dogmatist&#x27;&#125;,</span></span><br><span class="line"><span class="string">          &#123;&#x27;k&#x27;: &#x27;Dogo&#x27;, &#x27;v&#x27;: &#x27;[地名] [马里、尼日尔、乍得] 多戈; [地名] [韩国] 道高&#x27;&#125;]</span></span><br><span class="line"><span class="string"> &#125;</span></span><br><span class="line"><span class="string"> &quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure><ul><li>对于像翻译这种发送请求才能接收数据的使用post，并且要注意请求的url。</li><li>一般第二次请求都是Type：xhr</li></ul><h3 id="带参数的get请求"><a href="#带参数的get请求" class="headerlink" title="带参数的get请求"></a>带参数的get请求</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line">url = <span class="string">&quot;https://movie.douban.com/j/chart/top_list&quot;</span></span><br><span class="line"></span><br><span class="line">params = &#123;</span><br><span class="line">    <span class="string">&#x27;type&#x27;</span>: <span class="string">&#x27;16&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;interval_id&#x27;</span>: <span class="string">&#x27;100:90&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;action&#x27;</span>: <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;start&#x27;</span>: <span class="number">0</span>,</span><br><span class="line">    <span class="string">&#x27;limit&#x27;</span>: <span class="number">20</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">headers = &#123;</span><br><span class="line">    <span class="string">&#x27;user-agent&#x27;</span>: <span class="string">&quot;user-agent&quot;</span>, </span><br><span class="line">    <span class="string">&#x27;Keep-Alive&#x27;</span>: <span class="string">&#x27;timeout=30&#x27;</span>  <span class="comment"># 或者&#x27;false&#x27;用来关闭连接</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">resp = requests.get(url, params=params, headers=headers)</span><br><span class="line">print(resp.request.url)  <span class="comment"># 带参数的网址</span></span><br><span class="line">print(resp.request.headers[<span class="string">&quot;user-agent&quot;</span>])  <span class="comment"># python-requests/2.25.1  大小写不敏感</span></span><br><span class="line">print(resp.json())</span><br><span class="line"><span class="comment"># resp.close()  # 关闭连接</span></span><br></pre></td></tr></table></figure><ul><li>url地址的 ‘?’ 后面是get请求的参数（query string parameter）</li><li>python模拟的user-agent为：python-requests/2.25.1</li><li>一般出现问题，首先检查headers的user-agent</li></ul>]]></content>
      
      
      <categories>
          
          <category> 爬虫 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Docker基础-完结目录</title>
      <link href="/2021/04/Docker%E5%9F%BA%E7%A1%80-%E5%AE%8C%E7%BB%93%E7%9B%AE%E5%BD%95/"/>
      <url>/2021/04/Docker%E5%9F%BA%E7%A1%80-%E5%AE%8C%E7%BB%93%E7%9B%AE%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<h1 id="Docker基础——完结目录"><a href="#Docker基础——完结目录" class="headerlink" title="Docker基础——完结目录"></a>Docker基础——完结目录</h1><p>教程视频传送门：</p><ol><li><a href="https://www.bilibili.com/video/BV1og4y1q7M4?p=1">【狂神说Java】Docker最新超详细版教程通俗易懂</a></li></ol><p>讲的通俗易懂，循序渐进，但是需要自己过后再重新梳理一遍、详细总结。</p><p>==part2、part6还有Nginx、Tomcat、ES+Kibana、Redis、springboot部署==</p><table><thead><tr><th align="center"><a href="/2021/04/Docker%E5%9F%BA%E7%A1%80Part1/">DockerPart1——概述</a></th></tr></thead><tbody><tr><td align="center"><strong><a href="/2021/04/Docker%E5%9F%BA%E7%A1%80Part2/">DockerPart2——基本命令</a></strong></td></tr><tr><td align="center"><strong><a href="/2021/04/Docker%E5%9F%BA%E7%A1%80Part3/">Docker基础Part3——镜像讲解</a></strong></td></tr><tr><td align="center"><strong><a href="/2021/04/Docker%E5%9F%BA%E7%A1%80Part4/">Docker基础Part4——数据卷</a></strong></td></tr><tr><td align="center"><strong><a href="/2021/04/Docker%E5%9F%BA%E7%A1%80Part5/">Docker基础Part5——DockerFlie</a></strong></td></tr><tr><td align="center"><strong><a href="/2021/04/Docker%E5%9F%BA%E7%A1%80Part6/">Docker基础Part6——Docker网络</a></strong></td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> Docker基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker基础Part6</title>
      <link href="/2021/04/Docker%E5%9F%BA%E7%A1%80Part6/"/>
      <url>/2021/04/Docker%E5%9F%BA%E7%A1%80Part6/</url>
      
        <content type="html"><![CDATA[<h1 id="Docker基础Part6——Docker网络"><a href="#Docker基础Part6——Docker网络" class="headerlink" title="Docker基础Part6——Docker网络"></a>Docker基础Part6——Docker网络</h1><p>[TOC]</p><h2 id="Docker0"><a href="#Docker0" class="headerlink" title="Docker0"></a>Docker0</h2><h3 id="veth-pair"><a href="#veth-pair" class="headerlink" title="veth-pair"></a>veth-pair</h3><p><a href="https://www.cnblogs.com/bakari/p/10613710.html">https://www.cnblogs.com/bakari/p/10613710.html</a></p><ul><li>只要安装了docker，就会有docker0桥接模式，使用的是veth-pair技术。</li><li>veth-pair 就是一对的虚拟设备接口，他们都是成对出现的，一端连着协议，一端彼此相连。</li><li>OpenStac、Docker容器之间的连接、OVS的连接，都是使用evth-pair技术。</li></ul><h3 id="主机与容器的网络"><a href="#主机与容器的网络" class="headerlink" title="主机与容器的网络"></a>主机与容器的网络</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1.查看主机网络地址</span></span><br><span class="line">[root@VM-1-14-centos ~]<span class="comment"># ip addr</span></span><br><span class="line">1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000</span><br><span class="line">    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00</span><br><span class="line">    inet 127.0.0.1/8 scope host lo  <span class="comment"># lo 本机回环地址</span></span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">    inet6 ::1/128 scope host </span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">2: eth0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc mq state UP group default qlen 1000</span><br><span class="line">    link/ether 52:54:00:23:6f:89 brd ff:ff:ff:ff:ff:ff</span><br><span class="line">    inet 172.17.1.14/20 brd 172.17.15.255 scope global eth0 <span class="comment"># eth0 阿里云内网地址</span></span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">    inet6 fe80::5054:ff:fe23:6f89/64 scope link </span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">3: docker0: &lt;NO-CARRIER,BROADCAST,MULTICAST,UP&gt; mtu 1500 qdisc noqueue state DOWN group default </span><br><span class="line">    link/ether 02:42:76:5e:c5:42 brd ff:ff:ff:ff:ff:ff</span><br><span class="line">    inet 172.18.0.1/16 brd 172.18.255.255 scope global docker0  <span class="comment"># docker0 docker地址</span></span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">    inet6 fe80::42:76ff:fe5e:c542/64 scope link </span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">       </span><br><span class="line"><span class="comment"># 2.运行Tomcat</span></span><br><span class="line">[root@VM-1-14-centos ~]<span class="comment"># docker run -d -P --name tomcat01 tomcat</span></span><br><span class="line">......</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3.查看容器内网络地址</span></span><br><span class="line">[root@VM-1-14-centos ~]<span class="comment"># docker exec -it tomcat01 ip addr</span></span><br><span class="line">1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000</span><br><span class="line">    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00</span><br><span class="line">    inet 127.0.0.1/8 scope host lo</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">582: eth0@if583: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue state UP group default </span><br><span class="line">    link/ether 02:42:ac:12:00:02 brd ff:ff:ff:ff:ff:ff link-netnsid 0</span><br><span class="line">    inet 172.18.0.2/16 brd 172.18.255.255 scope global eth0</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">       </span><br><span class="line"><span class="comment"># 4.在Linux主机可以ping通容器</span></span><br><span class="line">[root@VM-1-14-centos ~]<span class="comment"># ping 172.18.0.2</span></span><br><span class="line">PING 172.18.0.2 (172.18.0.2) 56(84) bytes of data.</span><br><span class="line">64 bytes from 172.18.0.2: icmp_seq=1 ttl=64 time=0.062 ms</span><br><span class="line">64 bytes from 172.18.0.2: icmp_seq=2 ttl=64 time=0.049 ms</span><br><span class="line">64 bytes from 172.18.0.2: icmp_seq=3 ttl=64 time=0.049 ms</span><br><span class="line"></span><br><span class="line"><span class="comment"># 5.每次启动一个容器就会多一对网卡，给docker容器分配一个ip</span></span><br><span class="line">[root@VM-1-14-centos ~]<span class="comment"># docker run -d -P --name tomcat02 tomcat</span></span><br><span class="line">bb207d673d6b6a3b0898494d23850d87d852263b8c612b9788533fd3978bcdff</span><br><span class="line">[root@VM-1-14-centos ~]<span class="comment"># docker exec -it tomcat02 ip addr</span></span><br><span class="line">1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000</span><br><span class="line">    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00</span><br><span class="line">    inet 127.0.0.1/8 scope host lo</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">584: eth0@if585: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue state UP group default </span><br><span class="line">    link/ether 02:42:ac:12:00:03 brd ff:ff:ff:ff:ff:ff link-netnsid 0</span><br><span class="line">    inet 172.18.0.3/16 brd 172.18.255.255 scope global eth0</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">[root@VM-1-14-centos ~]<span class="comment"># ip addr</span></span><br><span class="line">1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000</span><br><span class="line">......</span><br><span class="line">2: eth0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc mq state UP group default qlen 1000</span><br><span class="line">......</span><br><span class="line">3: docker0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue state UP group default </span><br><span class="line">......</span><br><span class="line">583: veth10795dd@if582: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue master docker0 state UP group default </span><br><span class="line">    link/ether e6:83:7d:be:d2:57 brd ff:ff:ff:ff:ff:ff link-netnsid 0</span><br><span class="line">    inet6 fe80::e483:7dff:febe:d257/64 scope link </span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">585: veth3c80d43@if584: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue master docker0 state UP group default </span><br><span class="line">    link/ether 92:75:28:4c:a7:02 brd ff:ff:ff:ff:ff:ff link-netnsid 1</span><br><span class="line">    inet6 fe80::9075:28ff:fe4c:a702/64 scope link </span><br><span class="line">       valid_lft forever preferred_lft forever</span><br></pre></td></tr></table></figure><h3 id="容器之间的网络互通"><a href="#容器之间的网络互通" class="headerlink" title="容器之间的网络互通"></a>容器之间的网络互通</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1.获取tomcat01的ip 172.17.0.2   </span></span><br><span class="line">[root@VM-1-14-centos ~]<span class="comment"># docker exec -it tomcat01 ip addr  </span></span><br><span class="line">550: eth0@if551: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue state UP group default </span><br><span class="line">    link/ether 02:42:ac:11:00:02 brd ff:ff:ff:ff:ff:ff link-netnsid 0</span><br><span class="line">    inet 172.17.0.2/16 brd 172.17.255.255 scope global eth0</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2.用tomcat02 ping通 tomcat01</span></span><br><span class="line">[root@VM-1-14-centos ~]<span class="comment"># docker exec -it tomcat02 ping 172.18.0.2</span></span><br><span class="line">PING 172.18.0.2 (172.18.0.2) 56(84) bytes of data.</span><br><span class="line">64 bytes from 172.18.0.2: icmp_seq=1 ttl=64 time=0.074 ms</span><br><span class="line">64 bytes from 172.18.0.2: icmp_seq=2 ttl=64 time=0.051 ms</span><br></pre></td></tr></table></figure><h3 id="docker内网结构"><a href="#docker内网结构" class="headerlink" title="docker内网结构"></a>docker内网结构</h3><ul><li>所有的 docker 容器在不指定网络的情况下，都是由 docker0 使用Linux虚拟化技术、充当虚拟内网的路由/桥接，由 docker0 给容器分配一个可用ip，并由veth-pair连接，直到容器删除。</li><li>Docker中所有网络接口都是虚拟的，虚拟的转发效率高（内网传递文件）。</li><li>路由上发送信息可以通过两种方法：1.对每一个设备都进行注册；2.进行广播，看谁进行了回应。</li></ul><p><img src="/2021/04/Docker%E5%9F%BA%E7%A1%80Part6/image-20210427082646681.png" alt="image-20210427082646681"></p><h2 id="容器互联"><a href="#容器互联" class="headerlink" title="容器互联"></a>容器互联</h2><h3 id="–link-使用"><a href="#–link-使用" class="headerlink" title="–link 使用"></a>–link 使用</h3><p>为了保证数据ip更换时，项目不需要重启，并且通过名字来访问容器。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1.在未使用 --link 时，不能使用名字ping通</span></span><br><span class="line">[root@VM-1-14-centos ~]<span class="comment"># docker exec -it tomcat02 ping tomcat01</span></span><br><span class="line">ping: tomcat01: Name or service not known</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2.使用--link连接tomcat02、tomcat03</span></span><br><span class="line">[root@VM-1-14-centos ~]<span class="comment"># docker run -d -P --name tomcat03 --link tomcat02 tomcat</span></span><br><span class="line">16d977fe6d16ffd3e7e813e2487a55c9d52319a2c94c967fe3eed85f26078fd8</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3.可以单向ping通</span></span><br><span class="line">[root@VM-1-14-centos ~]<span class="comment"># docker exec -it tomcat03 ping tomcat02</span></span><br><span class="line">PING tomcat02 (172.18.0.3) 56(84) bytes of data.</span><br><span class="line">64 bytes from tomcat02 (172.18.0.3): icmp_seq=1 ttl=64 time=0.081 ms</span><br><span class="line">64 bytes from tomcat02 (172.18.0.3): icmp_seq=2 ttl=64 time=0.050 ms</span><br><span class="line">64 bytes from tomcat02 (172.18.0.3): icmp_seq=3 ttl=64 time=0.053 ms</span><br><span class="line"></span><br><span class="line"><span class="comment"># 4.对于没有进行配置的容器，不能与其他容器直接ping通</span></span><br><span class="line">[root@VM-1-14-centos ~]<span class="comment"># docker exec -it tomcat02 ping tomcat03</span></span><br><span class="line">ping: tomcat03: Name or service not known</span><br></pre></td></tr></table></figure><h3 id="–link-原理"><a href="#–link-原理" class="headerlink" title="–link 原理"></a>–link 原理</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看总体网络</span></span><br><span class="line">[root@VM-1-14-centos ~]<span class="comment"># docker network ls</span></span><br><span class="line">NETWORK ID     NAME      DRIVER    SCOPE</span><br><span class="line">c49bd3c9074e   bridge    bridge    <span class="built_in">local</span></span><br><span class="line">7137f78f9152   host      host      <span class="built_in">local</span></span><br><span class="line">830f9dcb1238   none      null      <span class="built_in">local</span></span><br><span class="line">[root@VM-1-14-centos ~]<span class="comment"># docker network inspect c49bd3c9074e</span></span><br><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">&quot;Name&quot;</span>: <span class="string">&quot;bridge&quot;</span>,</span><br><span class="line">        <span class="string">&quot;Id&quot;</span>: <span class="string">&quot;c49bd3c9074eccb131f580ae87a0f639459d8fbfb6106ff16d95de982f955cb6&quot;</span>,</span><br><span class="line">        <span class="string">&quot;Created&quot;</span>: <span class="string">&quot;2021-04-20T21:44:51.886039709+08:00&quot;</span>,</span><br><span class="line">        <span class="string">&quot;Scope&quot;</span>: <span class="string">&quot;local&quot;</span>,</span><br><span class="line">        <span class="string">&quot;Driver&quot;</span>: <span class="string">&quot;bridge&quot;</span>,</span><br><span class="line">        <span class="string">&quot;EnableIPv6&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">        <span class="string">&quot;IPAM&quot;</span>: &#123;</span><br><span class="line">            <span class="string">&quot;Driver&quot;</span>: <span class="string">&quot;default&quot;</span>,</span><br><span class="line">            <span class="string">&quot;Options&quot;</span>: null,</span><br><span class="line">            <span class="string">&quot;Config&quot;</span>: [</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="string">&quot;Subnet&quot;</span>: <span class="string">&quot;172.18.0.0/16&quot;</span>,  <span class="comment"># 局域网</span></span><br><span class="line">                    <span class="string">&quot;Gateway&quot;</span>: <span class="string">&quot;172.18.0.1&quot;</span>  <span class="comment"># docker0地址</span></span><br><span class="line">                &#125;</span><br><span class="line">            ]</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">&quot;Internal&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">        <span class="string">&quot;Attachable&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">        <span class="string">&quot;Ingress&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">        <span class="string">&quot;ConfigFrom&quot;</span>: &#123;</span><br><span class="line">            <span class="string">&quot;Network&quot;</span>: <span class="string">&quot;&quot;</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">&quot;ConfigOnly&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">        <span class="string">&quot;Containers&quot;</span>: &#123;  <span class="comment"># 三个tomcat地址</span></span><br><span class="line">            <span class="string">&quot;16d977fe6d16ffd3e7e813e2487a55c9d52319a2c94c967fe3eed85f26078fd8&quot;</span>: &#123;</span><br><span class="line">                <span class="string">&quot;Name&quot;</span>: <span class="string">&quot;tomcat03&quot;</span>,</span><br><span class="line">                <span class="string">&quot;EndpointID&quot;</span>: <span class="string">&quot;5a5630f2d5c897c1d9c36c9fef6df14885c381bdd5bd3bb38c1936335b65ccef&quot;</span>,</span><br><span class="line">                <span class="string">&quot;MacAddress&quot;</span>: <span class="string">&quot;02:42:ac:12:00:04&quot;</span>,</span><br><span class="line">                <span class="string">&quot;IPv4Address&quot;</span>: <span class="string">&quot;172.18.0.4/16&quot;</span>,</span><br><span class="line">                <span class="string">&quot;IPv6Address&quot;</span>: <span class="string">&quot;&quot;</span></span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="string">&quot;35806ff980cd8d16855934bceaacc02a6b99d50efeb9c9ff078ae43027c1ffbc&quot;</span>: &#123;</span><br><span class="line">                <span class="string">&quot;Name&quot;</span>: <span class="string">&quot;tomcat01&quot;</span>,</span><br><span class="line">                <span class="string">&quot;EndpointID&quot;</span>: <span class="string">&quot;fda00eb71c90561f15bdfd6c535411e7d38830c82315c747ac806b6369dcd623&quot;</span>,</span><br><span class="line">                <span class="string">&quot;MacAddress&quot;</span>: <span class="string">&quot;02:42:ac:12:00:02&quot;</span>,</span><br><span class="line">                <span class="string">&quot;IPv4Address&quot;</span>: <span class="string">&quot;172.18.0.2/16&quot;</span>,</span><br><span class="line">                <span class="string">&quot;IPv6Address&quot;</span>: <span class="string">&quot;&quot;</span></span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="string">&quot;bb207d673d6b6a3b0898494d23850d87d852263b8c612b9788533fd3978bcdff&quot;</span>: &#123;</span><br><span class="line">                <span class="string">&quot;Name&quot;</span>: <span class="string">&quot;tomcat02&quot;</span>,</span><br><span class="line">                <span class="string">&quot;EndpointID&quot;</span>: <span class="string">&quot;33d04884bfec102e7b8d1ac0985a60636c2766c4e4aebcc68bc8d766ec13c037&quot;</span>,</span><br><span class="line">                <span class="string">&quot;MacAddress&quot;</span>: <span class="string">&quot;02:42:ac:12:00:03&quot;</span>,</span><br><span class="line">                <span class="string">&quot;IPv4Address&quot;</span>: <span class="string">&quot;172.18.0.3/16&quot;</span>,</span><br><span class="line">                <span class="string">&quot;IPv6Address&quot;</span>: <span class="string">&quot;&quot;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">&quot;Options&quot;</span>: &#123;</span><br><span class="line">            <span class="string">&quot;com.docker.network.bridge.default_bridge&quot;</span>: <span class="string">&quot;true&quot;</span>,</span><br><span class="line">            <span class="string">&quot;com.docker.network.bridge.enable_icc&quot;</span>: <span class="string">&quot;true&quot;</span>,</span><br><span class="line">            <span class="string">&quot;com.docker.network.bridge.enable_ip_masquerade&quot;</span>: <span class="string">&quot;true&quot;</span>,</span><br><span class="line">            <span class="string">&quot;com.docker.network.bridge.host_binding_ipv4&quot;</span>: <span class="string">&quot;0.0.0.0&quot;</span>,</span><br><span class="line">            <span class="string">&quot;com.docker.network.bridge.name&quot;</span>: <span class="string">&quot;docker0&quot;</span>,</span><br><span class="line">            <span class="string">&quot;com.docker.network.driver.mtu&quot;</span>: <span class="string">&quot;1500&quot;</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">&quot;Labels&quot;</span>: &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看容器网络</span></span><br><span class="line">[root@VM-1-14-centos ~]<span class="comment"># docker ps</span></span><br><span class="line">CONTAINER ID   IMAGE     COMMAND             CREATED          STATUS          PORTS                                         NAMES</span><br><span class="line">16d977fe6d16   tomcat    <span class="string">&quot;catalina.sh run&quot;</span>   11 minutes ago   Up 11 minutes   0.0.0.0:49158-&gt;8080/tcp, :::49158-&gt;8080/tcp   tomcat03</span><br><span class="line">bb207d673d6b   tomcat    <span class="string">&quot;catalina.sh run&quot;</span>   16 hours ago     Up 16 hours     0.0.0.0:49156-&gt;8080/tcp, :::49156-&gt;8080/tcp   tomcat02</span><br><span class="line">35806ff980cd   tomcat    <span class="string">&quot;catalina.sh run&quot;</span>   17 hours ago     Up 17 hours     0.0.0.0:49155-&gt;8080/tcp, :::49155-&gt;8080/tcp   tomcat01</span><br><span class="line">[root@VM-1-14-centos ~]<span class="comment"># docker inspect 16d977fe6d16</span></span><br><span class="line">......</span><br><span class="line">        <span class="string">&quot;HostConfig&quot;</span>: &#123;</span><br><span class="line">            ......</span><br><span class="line">            <span class="string">&quot;Links&quot;</span>: [  <span class="comment"># 绑定的容器连接信息</span></span><br><span class="line">                <span class="string">&quot;/tomcat02:/tomcat03/tomcat02&quot;</span></span><br><span class="line">            ],</span><br><span class="line">            ......</span><br><span class="line">         &#125;</span><br><span class="line">......</span><br><span class="line"></span><br><span class="line">[root@VM-1-14-centos ~]<span class="comment"># docker exec -it tomcat03 cat /etc/hosts</span></span><br><span class="line">127.0.0.1localhost</span><br><span class="line">::1localhost ip6-localhost ip6-loopback</span><br><span class="line">fe00::0ip6-localnet</span><br><span class="line">ff00::0ip6-mcastprefix</span><br><span class="line">ff02::1ip6-allnodes</span><br><span class="line">ff02::2ip6-allrouters</span><br><span class="line">172.18.0.3tomcat02 bb207d673d6b  <span class="comment"># 添加了对tomcat02的解析映射</span></span><br><span class="line">172.18.0.416d977fe6d16</span><br></pre></td></tr></table></figure><blockquote><p>现在Docker不建议使用–link，以及官方提供的docker0，因为不支持容器名连接访问，较为局限，而是使用自定义网络。</p></blockquote><h2 id="自定义网络"><a href="#自定义网络" class="headerlink" title="自定义网络"></a>自定义网络</h2><h3 id="查看网络信息"><a href="#查看网络信息" class="headerlink" title="查看网络信息"></a>查看网络信息</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">docker network [ <span class="built_in">command</span> ]</span><br><span class="line"></span><br><span class="line">Commands:</span><br><span class="line">  connect     Connect a container to a network</span><br><span class="line">  create      Create a network</span><br><span class="line">  disconnect  Disconnect a container from a network</span><br><span class="line">  inspect     Display detailed information on one or more networks</span><br><span class="line">  ls          List networks</span><br><span class="line">  prune       Remove all unused networks</span><br><span class="line">  rm          Remove one or more networks</span><br></pre></td></tr></table></figure><h3 id="网络信息解释"><a href="#网络信息解释" class="headerlink" title="网络信息解释"></a>网络信息解释</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-1-14-centos ~]<span class="comment"># docker network ls</span></span><br><span class="line">NETWORK ID     NAME      DRIVER    SCOPE</span><br><span class="line">c49bd3c9074e   bridge    bridge    <span class="built_in">local</span></span><br><span class="line">7137f78f9152   host      host      <span class="built_in">local</span></span><br><span class="line">830f9dcb1238   none      null      <span class="built_in">local</span></span><br></pre></td></tr></table></figure><ul><li>bridge ：桥接 docker（默认，自定义也使用bridge）</li><li>none ：不配置网络，一般不用</li><li>host ：和主机共享网络</li><li>container ：容器网络连通（局限大，用得少）</li></ul><h3 id="创建自定义网络"><a href="#创建自定义网络" class="headerlink" title="创建自定义网络"></a>创建自定义网络</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1.默认--net bridge，bridge就是docker0。因此以下两者等效</span></span><br><span class="line">docker run -d -P --name tomcat01 tomcat</span><br><span class="line">docker run -d -P --name tomcat01 --net bridge tomcat</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2.自定义一个网络</span></span><br><span class="line">[root@VM-1-14-centos ~]<span class="comment"># docker network create --driver bridge --subnet 192.168.0.0/16 --gateway 192.168.0.1 mynet</span></span><br><span class="line">1144482c2ac35e85b348c18a0038fe93c9fd871bcb83612beea9c1a272589596</span><br><span class="line">[root@VM-1-14-centos ~]<span class="comment"># docker network ls</span></span><br><span class="line">NETWORK ID     NAME      DRIVER    SCOPE</span><br><span class="line">c49bd3c9074e   bridge    bridge    <span class="built_in">local</span></span><br><span class="line">7137f78f9152   host      host      <span class="built_in">local</span></span><br><span class="line">1144482c2ac3   mynet     bridge    <span class="built_in">local</span></span><br><span class="line">830f9dcb1238   none      null      <span class="built_in">local</span></span><br><span class="line">[root@VM-1-14-centos ~]<span class="comment"># docker network inspect mynet</span></span><br><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">&quot;Name&quot;</span>: <span class="string">&quot;mynet&quot;</span>,</span><br><span class="line">        <span class="string">&quot;Id&quot;</span>: <span class="string">&quot;1144482c2ac35e85b348c18a0038fe93c9fd871bcb83612beea9c1a272589596&quot;</span>,</span><br><span class="line">        <span class="string">&quot;Created&quot;</span>: <span class="string">&quot;2021-04-27T10:25:16.077076141+08:00&quot;</span>,</span><br><span class="line">        <span class="string">&quot;Scope&quot;</span>: <span class="string">&quot;local&quot;</span>,</span><br><span class="line">        <span class="string">&quot;Driver&quot;</span>: <span class="string">&quot;bridge&quot;</span>,</span><br><span class="line">        <span class="string">&quot;EnableIPv6&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">        <span class="string">&quot;IPAM&quot;</span>: &#123;</span><br><span class="line">            <span class="string">&quot;Driver&quot;</span>: <span class="string">&quot;default&quot;</span>,</span><br><span class="line">            <span class="string">&quot;Options&quot;</span>: &#123;&#125;,</span><br><span class="line">            <span class="string">&quot;Config&quot;</span>: [</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="string">&quot;Subnet&quot;</span>: <span class="string">&quot;192.168.0.0/16&quot;</span>,</span><br><span class="line">                    <span class="string">&quot;Gateway&quot;</span>: <span class="string">&quot;192.168.0.1&quot;</span></span><br><span class="line">                &#125;</span><br><span class="line">            ]</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">&quot;Internal&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">        <span class="string">&quot;Attachable&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">        <span class="string">&quot;Ingress&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">        <span class="string">&quot;ConfigFrom&quot;</span>: &#123;</span><br><span class="line">            <span class="string">&quot;Network&quot;</span>: <span class="string">&quot;&quot;</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">&quot;ConfigOnly&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">        <span class="string">&quot;Containers&quot;</span>: &#123;&#125;,</span><br><span class="line">        <span class="string">&quot;Options&quot;</span>: &#123;&#125;,</span><br><span class="line">        <span class="string">&quot;Labels&quot;</span>: &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3.在自定义网络下启动Tomcat</span></span><br><span class="line">[root@VM-1-14-centos ~]<span class="comment"># docker run -d -P --name tomcat-net-01 --net mynet tomcat</span></span><br><span class="line">8efc7a929482e82d74f723d2af17f77560b53561752fc1aab50d0189e06d7237</span><br><span class="line">[root@VM-1-14-centos ~]<span class="comment"># docker run -d -P --name tomcat-net-02 --net mynet tomcat</span></span><br><span class="line">6ccb4239abcfda10aa1b463d2f44d4a9ca4bc312735b56d08cad55266545ce2a</span><br><span class="line"></span><br><span class="line"><span class="comment"># 4.测试可以使用容器名直接ping通</span></span><br><span class="line">[root@VM-1-14-centos ~]<span class="comment"># docker exec -it tomcat-net-01 ping tomcat-net-02</span></span><br><span class="line">PING tomcat-net-02 (192.168.0.3) 56(84) bytes of data.</span><br><span class="line">64 bytes from tomcat-net-02.mynet (192.168.0.3): icmp_seq=1 ttl=64 time=0.069 ms</span><br><span class="line">64 bytes from tomcat-net-02.mynet (192.168.0.3): icmp_seq=2 ttl=64 time=0.061 ms</span><br><span class="line">64 bytes from tomcat-net-02.mynet (192.168.0.3): icmp_seq=3 ttl=64 time=0.056 ms</span><br></pre></td></tr></table></figure><p>好处：</p><ul><li>不同的集群使用不同的网络，保证集群是互相隔离并且安全的。</li></ul><h2 id="网络连通"><a href="#网络连通" class="headerlink" title="网络连通"></a>网络连通</h2><h3 id="connect"><a href="#connect" class="headerlink" title="connect"></a>connect</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">docker network connect --<span class="built_in">help</span></span><br><span class="line"></span><br><span class="line">Options:</span><br><span class="line">      --<span class="built_in">alias</span> strings           Add network-scoped <span class="built_in">alias</span> <span class="keyword">for</span> the container</span><br><span class="line">      --driver-opt strings      driver options <span class="keyword">for</span> the network</span><br><span class="line">      --ip string               IPv4 address (e.g., 172.30.100.104)</span><br><span class="line">      --ip6 string              IPv6 address (e.g., 2001:db8::33)</span><br><span class="line">      --link list               Add link to another container</span><br><span class="line">      --link-local-ip strings   Add a link-local address <span class="keyword">for</span> the container</span><br></pre></td></tr></table></figure><h3 id="容器与不同网段的连通"><a href="#容器与不同网段的连通" class="headerlink" title="容器与不同网段的连通"></a>容器与不同网段的连通</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1.测试两个不同的网络连通 ：再启动两个 tomcat 并使用默认网络 docker0</span></span><br><span class="line">[root@VM-1-14-centos ~]<span class="comment"># docker run -d -P --name tomcat01 tomcat</span></span><br><span class="line">0ad36e6d140040e1c6324695f6fe7102f8857b28b6251a6a21f8e4f8eb88839d</span><br><span class="line">[root@VM-1-14-centos ~]<span class="comment"># docker run -d -P --name tomcat02 tomcat</span></span><br><span class="line">aa8836b5fe93c9437490deb86796cc9d2d12d051df7ffc74b5b618b89c094a95</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2.此时tomcat01与tomcat-net-01不能ping通</span></span><br><span class="line">[root@VM-1-14-centos ~]<span class="comment"># docker exec tomcat01 ping tomcat-net-01</span></span><br><span class="line">ping: tomcat-net-01: Name or service not known</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3.连通容器与不同网段</span></span><br><span class="line">[root@VM-1-14-centos ~]<span class="comment"># docker network connect mynet tomcat01</span></span><br><span class="line">[root@VM-1-14-centos ~]<span class="comment"># docker network inspect mynet </span></span><br><span class="line">......</span><br><span class="line">        <span class="string">&quot;Containers&quot;</span>: &#123;</span><br><span class="line">            <span class="string">&quot;0ad36e6d140040e1c6324695f6fe7102f8857b28b6251a6a21f8e4f8eb88839d&quot;</span>: &#123;</span><br><span class="line">                <span class="string">&quot;Name&quot;</span>: <span class="string">&quot;tomcat01&quot;</span>,  <span class="comment"># 连通子网与不在此子网的容器，就是把容器加入到此子网的配置中</span></span><br><span class="line">                <span class="string">&quot;EndpointID&quot;</span>: <span class="string">&quot;a2f785c266adf679b186367e95cdcc48cc6c976b02b693de43100a625a6ca251&quot;</span>,</span><br><span class="line">                <span class="string">&quot;MacAddress&quot;</span>: <span class="string">&quot;02:42:c0:a8:00:04&quot;</span>,</span><br><span class="line">                <span class="string">&quot;IPv4Address&quot;</span>: <span class="string">&quot;192.168.0.4/16&quot;</span>,</span><br><span class="line">                <span class="string">&quot;IPv6Address&quot;</span>: <span class="string">&quot;&quot;</span></span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="string">&quot;6ccb4239abcfda10aa1b463d2f44d4a9ca4bc312735b56d08cad55266545ce2a&quot;</span>: &#123;</span><br><span class="line">                <span class="string">&quot;Name&quot;</span>: <span class="string">&quot;tomcat-net-02&quot;</span>,</span><br><span class="line">                <span class="string">&quot;EndpointID&quot;</span>: <span class="string">&quot;4e03b4f4fd3e11254ad5a5b3b1d1a6e4e8d5d9088eeb7be5e371875bb9885fa6&quot;</span>,</span><br><span class="line">                <span class="string">&quot;MacAddress&quot;</span>: <span class="string">&quot;02:42:c0:a8:00:03&quot;</span>,</span><br><span class="line">                <span class="string">&quot;IPv4Address&quot;</span>: <span class="string">&quot;192.168.0.3/16&quot;</span>,</span><br><span class="line">                <span class="string">&quot;IPv6Address&quot;</span>: <span class="string">&quot;&quot;</span></span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="string">&quot;8efc7a929482e82d74f723d2af17f77560b53561752fc1aab50d0189e06d7237&quot;</span>: &#123;</span><br><span class="line">                <span class="string">&quot;Name&quot;</span>: <span class="string">&quot;tomcat-net-01&quot;</span>,</span><br><span class="line">                <span class="string">&quot;EndpointID&quot;</span>: <span class="string">&quot;07427902cf0a5d5c1f72971ccf0615b0155eae830da1811b5e74e55226256d59&quot;</span>,</span><br><span class="line">                <span class="string">&quot;MacAddress&quot;</span>: <span class="string">&quot;02:42:c0:a8:00:02&quot;</span>,</span><br><span class="line">                <span class="string">&quot;IPv4Address&quot;</span>: <span class="string">&quot;192.168.0.2/16&quot;</span>,</span><br><span class="line">                <span class="string">&quot;IPv6Address&quot;</span>: <span class="string">&quot;&quot;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">......</span><br><span class="line"></span><br><span class="line"><span class="comment"># 4.测试连接成功</span></span><br><span class="line">[root@VM-1-14-centos ~]<span class="comment"># docker exec tomcat01 ping tomcat-net-01</span></span><br><span class="line">PING tomcat-net-01 (192.168.0.2) 56(84) bytes of data.</span><br><span class="line">64 bytes from tomcat-net-01.mynet (192.168.0.2): icmp_seq=1 ttl=64 time=0.065 ms</span><br><span class="line">64 bytes from tomcat-net-01.mynet (192.168.0.2): icmp_seq=2 ttl=64 time=0.069 ms</span><br><span class="line">64 bytes from tomcat-net-01.mynet (192.168.0.2): icmp_seq=3 ttl=64 time=0.054 ms</span><br></pre></td></tr></table></figure><ul><li>子网跟子网不能连通，但是容器和所在以外的子网能够连通。</li><li>一个容器具备多个ip，以访问不同网段。</li></ul><h2 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h2><p><a href="https://www.bilibili.com/video/BV1og4y1q7M4?p=38">Redis集群部署</a></p><p><a href="https://www.bilibili.com/video/BV1og4y1q7M4?p=39">springboot以服务打包镜像</a></p>]]></content>
      
      
      <categories>
          
          <category> Docker基础 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Docker基础Part5</title>
      <link href="/2021/04/Docker%E5%9F%BA%E7%A1%80Part5/"/>
      <url>/2021/04/Docker%E5%9F%BA%E7%A1%80Part5/</url>
      
        <content type="html"><![CDATA[<h1 id="Docker基础Part5——DockerFlie"><a href="#Docker基础Part5——DockerFlie" class="headerlink" title="Docker基础Part5——DockerFlie"></a>Docker基础Part5——DockerFlie</h1><p>[TOC]</p><h2 id="DockerFile介绍"><a href="#DockerFile介绍" class="headerlink" title="DockerFile介绍"></a>DockerFile介绍</h2><p>Dockerfile 是一个用来构建镜像的文本文件，文本内容包含了一条条构建镜像所需的指令和说明。</p><p>Dockerfile 是面向开发的，Docker镜像逐渐成为企业交付、发布项目的标准。</p><p>构建步骤：</p><ol><li>编写 dockerfile 文件</li><li>docker build 构建镜像</li><li>docker run 运行镜像</li><li>docker push 发布镜像（DockerHub 、阿里云仓库）</li></ol><blockquote><p>每一个指令都会创建一个新的镜像层并提交。</p></blockquote><h2 id="DockerFile指令"><a href="#DockerFile指令" class="headerlink" title="DockerFile指令"></a>DockerFile指令</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">FROM<span class="comment"># 基础镜像，一切从这里开始构建</span></span><br><span class="line">MAINTAINER<span class="comment"># 镜像是谁写的， 姓名+邮箱</span></span><br><span class="line">RUN<span class="comment"># 镜像构建的时候需要运行的命令</span></span><br><span class="line">ADD<span class="comment"># 步骤，tomcat镜像，这个tomcat压缩包！添加内容 添加同目录</span></span><br><span class="line">WORKDIR<span class="comment"># 镜像的工作目录</span></span><br><span class="line">VOLUME<span class="comment"># 挂载的目录</span></span><br><span class="line">EXPOSE<span class="comment"># 开放端口配置</span></span><br><span class="line">CMD<span class="comment"># 指定这个容器启动的时候要运行的命令，只有最后一个会生效，可被替代。</span></span><br><span class="line">ENTRYPOINT<span class="comment"># 指定这个容器启动的时候要运行的命令，可以追加命令</span></span><br><span class="line">ONBUILD<span class="comment"># 当构建一个被继承 DockerFile 这个时候就会运行ONBUILD的指令，触发指令。</span></span><br><span class="line">COPY<span class="comment"># 类似ADD，将我们文件拷贝到镜像中</span></span><br><span class="line">ENV<span class="comment"># 构建的时候设置环境变量</span></span><br></pre></td></tr></table></figure><h2 id="实战测试"><a href="#实战测试" class="headerlink" title="实战测试"></a>实战测试</h2><ul><li>DockerHub中大部分镜像都是从<code>FROM scratch</code>开始。</li><li>关键字不一定要大写，但是一般都是大写来和变量区分。</li></ul><p>官方的centos镜像没有<code>vim、ifconfig</code>命令，这里制作自己的centos镜像。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1.编写Dockerfile文件</span></span><br><span class="line">[root@VM-1-14-centos dockerfile]<span class="comment"># vim mydockerfile_centos </span></span><br><span class="line">[root@VM-1-14-centos dockerfile]<span class="comment"># cat mydockerfile_centos </span></span><br><span class="line">FROM centos</span><br><span class="line">MAINTAINER NephrenCake&lt;834957063@qq.com&gt;</span><br><span class="line"></span><br><span class="line">ENV MYPATH /usr/<span class="built_in">local</span></span><br><span class="line">WOKDIR <span class="variable">$MYPATH</span></span><br><span class="line"></span><br><span class="line">run yum -y install vim</span><br><span class="line">RUN yum -y install net-tools</span><br><span class="line"></span><br><span class="line">EXPOSE 80</span><br><span class="line"></span><br><span class="line">CMD <span class="built_in">echo</span> <span class="variable">$MYPATH</span></span><br><span class="line">CMD <span class="built_in">echo</span> <span class="string">&quot;-----end-----&quot;</span></span><br><span class="line">CMD /bin/bash</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2.构建镜像</span></span><br><span class="line"><span class="comment"># 命令 docker build -f 文件路径 -t 镜像名:[tag] 目标路径</span></span><br><span class="line">docker build -f mydockerfile_centos -t mycentos:0.1 .  <span class="comment"># &lt;-注意这里的一个“.”表示镜像文件生成在当前目录</span></span><br><span class="line">......</span><br><span class="line">Successfully built 0fb03cb15b56</span><br><span class="line">Successfully tagged mycentos:0.1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3.测试运行</span></span><br><span class="line">[root@VM-1-14-centos dockerfile]<span class="comment"># docker run -it mycentos:0.1 /bin/bash</span></span><br><span class="line">[root@6db4033677cd <span class="built_in">local</span>]<span class="comment"># pwd</span></span><br><span class="line">/usr/<span class="built_in">local</span>  <span class="comment"># 进入设置的工作目录</span></span><br><span class="line">[root@6db4033677cd <span class="built_in">local</span>]<span class="comment"># ifconfig</span></span><br><span class="line">......  <span class="comment"># ifconfig 可以正常使用</span></span><br><span class="line">[root@6db4033677cd <span class="built_in">local</span>]<span class="comment"># vim --version</span></span><br><span class="line">......  <span class="comment"># vim 可以正常使用</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 4.查看构建过程</span></span><br><span class="line">[root@VM-1-14-centos dockerfile]<span class="comment"># docker history mycentos:0.1</span></span><br><span class="line">IMAGE          CREATED          CREATED BY                                      SIZE      COMMENT</span><br><span class="line">0fb03cb15b56   25 minutes ago   /bin/sh -c <span class="comment">#(nop)  CMD [&quot;/bin/sh&quot; &quot;-c&quot; &quot;/bin…   0B        </span></span><br><span class="line">857a02979c6b   25 minutes ago   /bin/sh -c <span class="comment">#(nop)  CMD [&quot;/bin/sh&quot; &quot;-c&quot; &quot;echo…   0B        </span></span><br><span class="line">9b1d90e765f1   25 minutes ago   /bin/sh -c <span class="comment">#(nop)  CMD [&quot;/bin/sh&quot; &quot;-c&quot; &quot;echo…   0B        </span></span><br><span class="line">383a1fdc4420   25 minutes ago   /bin/sh -c <span class="comment">#(nop)  EXPOSE 80                    0B        </span></span><br><span class="line">315a1c8eafe2   25 minutes ago   /bin/sh -c yum -y install net-tools             23.3MB    </span><br><span class="line">1bd3533bf951   25 minutes ago   /bin/sh -c yum -y install vim                   58MB      </span><br><span class="line">e7468e6156a1   26 minutes ago   /bin/sh -c <span class="comment">#(nop) WORKDIR /usr/local            0B        </span></span><br><span class="line">02c89bb6f0d5   26 minutes ago   /bin/sh -c <span class="comment">#(nop)  ENV MYPATH=/usr/local        0B        </span></span><br><span class="line">1e2c46d0633d   26 minutes ago   /bin/sh -c <span class="comment">#(nop)  MAINTAINER NephrenCake&lt;83…   0B        </span></span><br><span class="line">300e315adb2f   4 months ago     /bin/sh -c <span class="comment">#(nop)  CMD [&quot;/bin/bash&quot;]            0B        </span></span><br><span class="line">&lt;missing&gt;      4 months ago     /bin/sh -c <span class="comment">#(nop)  LABEL org.label-schema.sc…   0B        </span></span><br><span class="line">&lt;missing&gt;      4 months ago     /bin/sh -c <span class="comment">#(nop) ADD file:bd7a2aed6ede423b7…   209MB</span></span><br></pre></td></tr></table></figure><ul><li>建议在dockerfile所在目录构建镜像。</li><li>对所有拿到的镜像都可以<code>docker history</code>来分析其构建过程。</li></ul><h2 id="CMD-和-ENTRYPOINT区别"><a href="#CMD-和-ENTRYPOINT区别" class="headerlink" title="CMD 和 ENTRYPOINT区别"></a>CMD 和 ENTRYPOINT区别</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CMD<span class="comment"># 指定这个容器启动的时候要运行的命令，只有最后一个会生效，可被替代。</span></span><br><span class="line">ENTRYPOINT<span class="comment"># 指定这个容器启动的时候要运行的命令，可以追加命令</span></span><br></pre></td></tr></table></figure><p>test CMD：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1.编写dockerfile文件</span></span><br><span class="line">[root@VM-1-14-centos dockerfile]<span class="comment"># vim dockerfile-test-cmd</span></span><br><span class="line">FROM centos</span><br><span class="line">CMD [<span class="string">&quot;ls&quot;</span>,<span class="string">&quot;-a&quot;</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2.构建镜像</span></span><br><span class="line">[root@VM-1-14-centos dockerfile]<span class="comment"># docker build  -f dockerfile-test-cmd -t cmd-test:0.1 .</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 3.运行镜像</span></span><br><span class="line">$ docker run cmd-test:0.1</span><br><span class="line">.</span><br><span class="line">..</span><br><span class="line">.dockerenv</span><br><span class="line">bin</span><br><span class="line">dev</span><br><span class="line">......  <span class="comment"># 成功执行设置的cmd指令</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 4.意图追加命令  -l 成为ls -al</span></span><br><span class="line">[root@VM-1-14-centos dockerfile]<span class="comment"># docker run cmd-test:0.1 -l</span></span><br><span class="line">docker: Error response from daemon: OCI runtime create failed: container_linux.go:349: starting container process caused <span class="string">&quot;exec: \&quot;-l\&quot;:</span></span><br><span class="line"><span class="string"> executable file not found in <span class="variable">$PATH</span>&quot;</span>: unknown.</span><br><span class="line">ERRO[0000] error waiting <span class="keyword">for</span> container: context canceled </span><br><span class="line"><span class="comment"># cmd的情况下 `-l` 替换了 `CMD[&quot;ls&quot;,&quot;-a&quot;]` ，而 `-l` 不是命令所以报错</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 5.修正：</span></span><br><span class="line">[root@VM-1-14-centos dockerfile]<span class="comment"># docker run cmd-test:0.1 ls -l</span></span><br><span class="line">total 48</span><br><span class="line">lrwxrwxrwx   1 root root    7 Nov  3 15:22 bin -&gt; usr/bin</span><br><span class="line">drwxr-xr-x   5 root root  340 Apr 25 03:10 dev</span><br><span class="line">drwxr-xr-x   1 root root 4096 Apr 25 03:09 etc</span><br><span class="line">drwxr-xr-x   2 root root 4096 Nov  3 15:22 home</span><br><span class="line">......</span><br><span class="line"></span><br><span class="line"><span class="comment"># 6.没有停留在容器的原因是执行完cmd指令自动退出了</span></span><br><span class="line">[root@VM-1-14-centos dockerfile]<span class="comment"># docker ps -a</span></span><br><span class="line">CONTAINER ID   IMAGE          COMMAND   CREATED          STATUS                      PORTS     NAMES</span><br><span class="line">9ce9877f6610   cmd-test:0.1   <span class="string">&quot;ls -l&quot;</span>   11 seconds ago   Exited (0) 10 seconds ago             interesting_knuth</span><br></pre></td></tr></table></figure><p>test ENTRYPOINT：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1.编写dockerfile文件</span></span><br><span class="line">[root@VM-1-14-centos dockerfile]<span class="comment"># vim dockerfile-test-entrypoint</span></span><br><span class="line">FROM centos</span><br><span class="line">ENTRYPOINT [<span class="string">&quot;ls&quot;</span>,<span class="string">&quot;-a&quot;</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2.构建镜像</span></span><br><span class="line">[root@VM-1-14-centos dockerfile]<span class="comment"># docker build  -f dockerfile-test-entrypoint -t entrypoint-test:0.1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 3.运行镜像</span></span><br><span class="line">[root@VM-1-14-centos dockerfile]<span class="comment"># docker run entrypoint-test:0.1</span></span><br><span class="line">.</span><br><span class="line">..</span><br><span class="line">.dockerenv</span><br><span class="line">bin</span><br><span class="line">dev</span><br><span class="line">......</span><br><span class="line"></span><br><span class="line"><span class="comment"># 4.追加命令</span></span><br><span class="line">[root@VM-1-14-centos dockerfile]<span class="comment"># docker run entrypoint-test:0.1 -l</span></span><br><span class="line">total 56</span><br><span class="line">drwxr-xr-x   1 root root 4096 May 16 06:32 .</span><br><span class="line">drwxr-xr-x   1 root root 4096 May 16 06:32 ..</span><br><span class="line">-rwxr-xr-x   1 root root    0 May 16 06:32 .dockerenv</span><br><span class="line">......</span><br></pre></td></tr></table></figure><h2 id="Tomcat实战"><a href="#Tomcat实战" class="headerlink" title="Tomcat实战"></a>Tomcat实战</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1.准备镜像文件</span></span><br><span class="line">Tomcat jdk dockerfile readme</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2.编写dockerfile</span></span><br><span class="line">FROM centos <span class="comment">#</span></span><br><span class="line">MAINTAINER cheng&lt;1204598429@qq.com&gt;</span><br><span class="line">COPY README /usr/<span class="built_in">local</span>/README <span class="comment">#复制文件</span></span><br><span class="line">ADD jdk-8u231-linux-x64.tar.gz /usr/<span class="built_in">local</span>/ <span class="comment">#复制解压</span></span><br><span class="line">ADD apache-tomcat-9.0.35.tar.gz /usr/<span class="built_in">local</span>/ <span class="comment">#复制解压</span></span><br><span class="line">RUN yum -y install vim</span><br><span class="line">ENV MYPATH /usr/<span class="built_in">local</span> <span class="comment">#设置环境变量</span></span><br><span class="line">WORKDIR <span class="variable">$MYPATH</span> <span class="comment">#设置工作目录</span></span><br><span class="line">ENV JAVA_HOME /usr/<span class="built_in">local</span>/jdk1.8.0_231 <span class="comment">#设置环境变量</span></span><br><span class="line">ENV CATALINA_HOME /usr/<span class="built_in">local</span>/apache-tomcat-9.0.35 <span class="comment">#设置环境变量</span></span><br><span class="line">ENV PATH <span class="variable">$PATH</span>:<span class="variable">$JAVA_HOME</span>/bin:<span class="variable">$CATALINA_HOME</span>/lib <span class="comment">#设置环境变量 分隔符是：</span></span><br><span class="line">EXPOSE 8080 <span class="comment">#设置暴露的端口</span></span><br><span class="line">CMD /usr/<span class="built_in">local</span>/apache-tomcat-9.0.35/bin/startup.sh &amp;&amp; tail -F /usr/<span class="built_in">local</span>/apache-tomcat-9.0.35/logs/catalina.out <span class="comment"># 设置默认命令</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 3.构建image  因为dockerfile命名使用默认命名 因此不用使用-f 指定文件</span></span><br><span class="line">$ docker build -t mytomcat:0.1 .</span><br><span class="line"></span><br><span class="line"><span class="comment"># 4.运行image</span></span><br><span class="line">$ docker run -d -p 8080:8080 --name tomcat01 -v /home/kuangshen/build/tomcat/<span class="built_in">test</span>:/usr/<span class="built_in">local</span>/apache-tomcat-9.0.35/webapps/<span class="built_in">test</span> -v /home/kuangshen/build/tomcat/tomcatlogs/:/usr/<span class="built_in">local</span>/apache-tomcat-9.0.35/logs mytomcat:0.1</span><br></pre></td></tr></table></figure><h2 id="发布镜像"><a href="#发布镜像" class="headerlink" title="发布镜像"></a>发布镜像</h2><h3 id="登录"><a href="#登录" class="headerlink" title="登录"></a>登录</h3><p>注册<a href="https://hub.docker.com/">DockerHub</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">docker login [OPTIONS] [SERVER]</span><br><span class="line"></span><br><span class="line">Options:</span><br><span class="line">  -p, --password string   Password</span><br><span class="line">      --password-stdin    Take the password from stdin</span><br><span class="line">  -u, --username string   Username</span><br></pre></td></tr></table></figure><h3 id="提交"><a href="#提交" class="headerlink" title="提交"></a>提交</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">docker push xxx/image:[镜像版本号]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 没有前缀默认push到官方的library</span></span><br><span class="line"><span class="comment"># 第一种 build的时候添加你的dockerhub用户名，然后在push就可以放到自己的仓库了</span></span><br><span class="line">$ docker build -t nephrencake/mytomcat:1.0 .</span><br><span class="line"><span class="comment"># 第二种 使用docker tag 然后再次push</span></span><br><span class="line">$ docker tag 容器id nephrencake/mytomcat:1.0</span><br></pre></td></tr></table></figure><h3 id="修改版本"><a href="#修改版本" class="headerlink" title="修改版本"></a>修改版本</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ docker tag [ImageId] registry.cn-xxx.aliyuncs.com/xxxx/image:[镜像版本号]</span><br><span class="line"><span class="comment"># 修改id 和 版本</span></span><br><span class="line">$ sudo docker tag a5ef1f32aaae registry.cn-xxx.aliyuncs.com/xxxx/image:1.0</span><br><span class="line"><span class="comment"># 修改仓库镜像版本</span></span><br><span class="line">$ docker push registry.cn-xxx.aliyuncs.com/xxxx/image:[镜像版本号]</span><br></pre></td></tr></table></figure><h3 id="打包镜像"><a href="#打包镜像" class="headerlink" title="打包镜像"></a>打包镜像</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker save [OPTIONS] IMAGE [IMAGE...]</span><br><span class="line"></span><br><span class="line">Options:</span><br><span class="line">  -o, --output string   Write to a file, instead of STDOUT</span><br></pre></td></tr></table></figure><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p><img src="/2021/04/Docker%E5%9F%BA%E7%A1%80Part5/image-20210427110036461.png" alt="image-20210427110036461"></p>]]></content>
      
      
      <categories>
          
          <category> Docker基础 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Docker基础Part4</title>
      <link href="/2021/04/Docker%E5%9F%BA%E7%A1%80Part4/"/>
      <url>/2021/04/Docker%E5%9F%BA%E7%A1%80Part4/</url>
      
        <content type="html"><![CDATA[<h1 id="Docker基础Part4——数据卷"><a href="#Docker基础Part4——数据卷" class="headerlink" title="Docker基础Part4——数据卷"></a>Docker基础Part4——数据卷</h1><p>[TOC]</p><h2 id="数据卷是什么"><a href="#数据卷是什么" class="headerlink" title="数据卷是什么"></a>数据卷是什么</h2><p>docker镜像是为了打包应用和环境。</p><ul><li>要防止容器的销毁造成数据的丢失。</li><li>减少不必要进入容器修改配置文件。</li></ul><p>docker容器中产生的数据不应当被存储在容器中，数据应当被同步共享到本机。</p><p>在docker容器中存放数据的文件目录（如：/usr/mysql/）可以挂载到本机的指定目录（如：/home/mysql/），实现数据同步共享。</p><p>多个容器之间依然可以通过上述相同的方式，实现多个容器的数据共享。</p><p><img src="/2021/04/Docker%E5%9F%BA%E7%A1%80Part4/image-20210424140857577.png" alt="image-20210424140857577"></p><h2 id="数据卷使用"><a href="#数据卷使用" class="headerlink" title="数据卷使用"></a>数据卷使用</h2><h3 id="指定路径挂载"><a href="#指定路径挂载" class="headerlink" title="指定路径挂载"></a>指定路径挂载</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -it -v 主机目录:容器内目录  -p 主机端口:容器内端口</span><br></pre></td></tr></table></figure><p>demo：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-1-14-centos ~]<span class="comment"># docker run -it -v /home/volume:/home centos</span></span><br><span class="line">[root@287b41b8e1eb /]<span class="comment"># cd home</span></span><br><span class="line">[root@287b41b8e1eb home]<span class="comment"># touch test.txt</span></span><br><span class="line">[root@287b41b8e1eb home]<span class="comment"># ls</span></span><br><span class="line">test.txt</span><br><span class="line">[root@VM-1-14-centos volume]<span class="comment"># ls</span></span><br><span class="line">test.txt</span><br></pre></td></tr></table></figure><p>容器内与主机内挂载的目录下，所有操作都相互等效。</p><p>即使容器停止、重启、删除，目录、数据依然同步。</p><h3 id="MySQL实战"><a href="#MySQL实战" class="headerlink" title="MySQL实战"></a>MySQL实战</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-1-14-centos ~]<span class="comment"># docker pull mysql:5.7</span></span><br><span class="line">[root@VM-1-14-centos ~]<span class="comment"># docker run -d -p 3310:3306 -v /home/mysql/conf:/etc/mysql/conf.d -v /home/mysql/data:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=123456 --name mysql01 mysql:5.7</span></span><br><span class="line">67a1b52b307b59d14029fee48ae553b9334c57037ad001d914e2e87ba96fa6cb</span><br><span class="line"><span class="comment"># -d 后台运行 -p 端口映射 -v 卷挂载 -e 环境配置 -- name 容器名字</span></span><br><span class="line">[root@VM-1-14-centos mysql]<span class="comment"># ls data/</span></span><br><span class="line">auto.cnf    ca.pem           client-key.pem  ibdata1      ib_logfile1  mysql               private_key.pem  server-cert.pem  sys</span><br><span class="line">ca-key.pem  client-cert.pem  ib_buffer_pool  ib_logfile0  ibtmp1       performance_schema  public_key.pem   server-key.pem</span><br><span class="line">[root@VM-1-14-centos ~]<span class="comment"># docker rm -f 67a1b52b307b</span></span><br><span class="line">67a1b52b307b</span><br><span class="line">[root@VM-1-14-centos mysql]<span class="comment"># ls data/</span></span><br><span class="line">auto.cnf    ca.pem           client-key.pem  ibdata1      ib_logfile1  mysql               private_key.pem  server-cert.pem  sys</span><br><span class="line">ca-key.pem  client-cert.pem  ib_buffer_pool  ib_logfile0  ibtmp1       performance_schema  public_key.pem   server-key.pem</span><br></pre></td></tr></table></figure><h3 id="具名和匿名挂载"><a href="#具名和匿名挂载" class="headerlink" title="具名和匿名挂载"></a>具名和匿名挂载</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 挂载方式</span></span><br><span class="line">docker run  -d -P --name xxx -v (str1:)str2 image</span><br><span class="line"><span class="comment"># str1 不加/为具名，加/为主机根目录下地址</span></span><br><span class="line"><span class="comment"># str2 容器内路径</span></span><br><span class="line"><span class="comment"># 匿名挂载：    -v 容器内路径</span></span><br><span class="line"><span class="comment"># 具名挂载：    -v 卷名:容器内路径</span></span><br><span class="line"><span class="comment"># 指定路径挂载: -v /宿主机路径:容器内路径</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 数据卷操作</span></span><br><span class="line">docker volume [ options ]</span><br><span class="line"></span><br><span class="line">Commands:</span><br><span class="line">  create      Create a volume</span><br><span class="line">  inspect     Display detailed information on one or more volumes</span><br><span class="line">  ls          List volumes</span><br><span class="line">  prune       Remove all unused <span class="built_in">local</span> volumes</span><br><span class="line">  rm          Remove one or more volumes</span><br></pre></td></tr></table></figure><p>demo：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 匿名挂载</span></span><br><span class="line">[root@VM-1-14-centos mysql]<span class="comment"># docker run -d -P --name nginx01 -v /etc/nginx nginx</span></span><br><span class="line"><span class="comment"># 查看所有的volume的情况</span></span><br><span class="line">[root@VM-1-14-centos mysql]<span class="comment"># docker volume ls</span></span><br><span class="line">DRIVER              VOLUME NAME</span><br><span class="line"><span class="built_in">local</span>               33ae588fae6d34f511a769948f0d3d123c9d45c442ac7728cb85599c2657e50d</span><br><span class="line">......</span><br><span class="line"><span class="comment"># 具名挂载</span></span><br><span class="line">[root@VM-1-14-centos mysql]<span class="comment"># docker run -d -P --name nginx02 -v juming-nginx:/etc/nginx nginx</span></span><br><span class="line">[root@VM-1-14-centos mysql]<span class="comment"># docker volume ls                  </span></span><br><span class="line">DRIVER              VOLUME NAME</span><br><span class="line"><span class="built_in">local</span>               juming-nginx</span><br><span class="line">......</span><br><span class="line"><span class="comment"># 查看详细信息</span></span><br><span class="line">[root@VM-1-14-centos mysql]<span class="comment"># docker volume inspect juming-nginx</span></span><br><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">&quot;CreatedAt&quot;</span>: <span class="string">&quot;2021-04-24T19:42:24+08:00&quot;</span>,</span><br><span class="line">        <span class="string">&quot;Driver&quot;</span>: <span class="string">&quot;local&quot;</span>,</span><br><span class="line">        <span class="string">&quot;Labels&quot;</span>: null,</span><br><span class="line">        <span class="string">&quot;Mountpoint&quot;</span>: <span class="string">&quot;/var/lib/docker/volumes/juming-nginx/_data&quot;</span>,</span><br><span class="line">        <span class="string">&quot;Name&quot;</span>: <span class="string">&quot;juming-nginx&quot;</span>,</span><br><span class="line">        <span class="string">&quot;Options&quot;</span>: null,</span><br><span class="line">        <span class="string">&quot;Scope&quot;</span>: <span class="string">&quot;local&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><ul><li>所有的docker容器内的卷，没有指定目录的情况下都是在<code>/var/lib/docker/volumes/xxxx/_data</code>下</li><li>如果指定了目录，docker volume ls 是查看不到的</li></ul><blockquote><p>通过具名挂载可以很容易地找到数据卷，因此通常使用具名挂载。</p></blockquote><h3 id="ro-rw"><a href="#ro-rw" class="headerlink" title="ro/rw"></a>ro/rw</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -v 容器内路径:ro/rw 改变读写权限</span></span><br><span class="line">ro <span class="comment">#readonly 只读（只能通过宿主机操作）</span></span><br><span class="line">rw <span class="comment">#readwrite 可读可写</span></span><br><span class="line">docker run -d -P --name nginx05 -v juming:/etc/nginx:ro nginx</span><br><span class="line">docker run -d -P --name nginx05 -v juming:/etc/nginx:rw nginx</span><br></pre></td></tr></table></figure><h3 id="Dockerfile中设置挂载"><a href="#Dockerfile中设置挂载" class="headerlink" title="Dockerfile中设置挂载"></a>Dockerfile中设置挂载</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-1-14-centos ~]<span class="comment"># mkdir docker_test</span></span><br><span class="line">[root@VM-1-14-centos ~]<span class="comment"># cd docker_test/</span></span><br><span class="line">[root@VM-1-14-centos docker_test]<span class="comment"># vim dockerfile1</span></span><br><span class="line">[root@VM-1-14-centos docker_test]<span class="comment"># cat dockerfile1 </span></span><br><span class="line">FROM centos  <span class="comment"># 设置基础镜像</span></span><br><span class="line">VOLUME [<span class="string">&quot;volume01&quot;</span>,<span class="string">&quot;volume02&quot;</span>]  <span class="comment"># 设置挂载，新建两个匿名卷</span></span><br><span class="line">CMD <span class="built_in">echo</span> <span class="string">&quot;----end----&quot;</span> <span class="comment"># 写出内部命令end</span></span><br><span class="line">CMD /bin/bash  <span class="comment"># 进入bin/bash</span></span><br><span class="line">[root@VM-1-14-centos docker_test]<span class="comment"># docker build -f /root/docker_test/dockerfile1 -t nephrencake/centos:1.0 .</span></span><br><span class="line">Sending build context to Docker daemon  2.048kB</span><br><span class="line">Step 1/4 : FROM centos</span><br><span class="line"> ---&gt; 300e315adb2f</span><br><span class="line">Step 2/4 : VOLUME [<span class="string">&quot;volume01&quot;</span>,<span class="string">&quot;volume02&quot;</span>]</span><br><span class="line"> ---&gt; Running <span class="keyword">in</span> 40898156bffb</span><br><span class="line">Removing intermediate container 40898156bffb</span><br><span class="line"> ---&gt; f7982a2145cb</span><br><span class="line">Step 3/4 : CMD <span class="built_in">echo</span> <span class="string">&quot;----end----&quot;</span> </span><br><span class="line"> ---&gt; Running <span class="keyword">in</span> cd21a00b4b6e</span><br><span class="line">Removing intermediate container cd21a00b4b6e</span><br><span class="line"> ---&gt; dc3c858b0b01</span><br><span class="line">Step 4/4 : CMD /bin/bash</span><br><span class="line"> ---&gt; Running <span class="keyword">in</span> d6937914df26</span><br><span class="line">Removing intermediate container d6937914df26</span><br><span class="line"> ---&gt; 706bb05073c4</span><br><span class="line">Successfully built 706bb05073c4</span><br><span class="line">Successfully tagged nephrencake/centos:1.0</span><br><span class="line">[root@VM-1-14-centos docker_test]<span class="comment"># docker images</span></span><br><span class="line">REPOSITORY            TAG       IMAGE ID       CREATED         SIZE</span><br><span class="line">nephrencake/centos    1.0       706bb05073c4   2 minutes ago   209MB</span><br><span class="line">[root@VM-1-14-centos docker_test]<span class="comment"># docker run -it 706bb05073c4</span></span><br><span class="line">[root@f42ba8b35f43 /]<span class="comment"># ls -l</span></span><br><span class="line">total 56</span><br><span class="line">......</span><br><span class="line">drwxr-xr-x   2 root root 4096 Apr 24 13:23 volume01  <span class="comment"># 发现设置的挂载数据卷</span></span><br><span class="line">drwxr-xr-x   2 root root 4096 Apr 24 13:23 volume02</span><br><span class="line">[root@VM-1-14-centos ~]<span class="comment"># docker inspect f42ba8b35f43</span></span><br><span class="line">......</span><br><span class="line">        <span class="string">&quot;Mounts&quot;</span>: [</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="string">&quot;Type&quot;</span>: <span class="string">&quot;volume&quot;</span>,</span><br><span class="line">                <span class="string">&quot;Name&quot;</span>: <span class="string">&quot;646d7481a3762934113020b27f86b43c980b3d76bddd15072b327785bc9672fc&quot;</span>,</span><br><span class="line">                <span class="string">&quot;Source&quot;</span>: <span class="string">&quot;/var/lib/docker/volumes/646d7481a3762934113020b27f86b43c980b3d76bddd15072b327785bc9672fc/_data&quot;</span>,</span><br><span class="line">                <span class="string">&quot;Destination&quot;</span>: <span class="string">&quot;volume02&quot;</span>,</span><br><span class="line">                <span class="string">&quot;Driver&quot;</span>: <span class="string">&quot;local&quot;</span>,</span><br><span class="line">                <span class="string">&quot;Mode&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">                <span class="string">&quot;RW&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">                <span class="string">&quot;Propagation&quot;</span>: <span class="string">&quot;&quot;</span></span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="string">&quot;Type&quot;</span>: <span class="string">&quot;volume&quot;</span>,</span><br><span class="line">                <span class="string">&quot;Name&quot;</span>: <span class="string">&quot;860d1d86119aca1e8f1022c5588542608ce116e0530a758b7ba5e590cc7545ce&quot;</span>,</span><br><span class="line">                <span class="string">&quot;Source&quot;</span>: <span class="string">&quot;/var/lib/docker/volumes/860d1d86119aca1e8f1022c5588542608ce116e0530a758b7ba5e590cc7545ce/_data&quot;</span>,</span><br><span class="line">                <span class="string">&quot;Destination&quot;</span>: <span class="string">&quot;volume01&quot;</span>,</span><br><span class="line">                <span class="string">&quot;Driver&quot;</span>: <span class="string">&quot;local&quot;</span>,</span><br><span class="line">                <span class="string">&quot;Mode&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">                <span class="string">&quot;RW&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">                <span class="string">&quot;Propagation&quot;</span>: <span class="string">&quot;&quot;</span></span><br><span class="line">            &#125;</span><br><span class="line">        ],</span><br><span class="line">......</span><br></pre></td></tr></table></figure><blockquote><p>docker run xxx 等效于 docker run xxx:latest</p><p>因此 docker run xxx:latest 是找不到 docker run xxx:1.0 的</p></blockquote><h3 id="多容器同步数据卷"><a href="#多容器同步数据卷" class="headerlink" title="多容器同步数据卷"></a>多容器同步数据卷</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -it --name container2 --volumes-from container1 image</span><br></pre></td></tr></table></figure><p>demo：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建docker01容器并在挂载数据卷中创建文件</span></span><br><span class="line">[root@VM-1-14-centos ~]<span class="comment"># docker run -it --name docker01 706bb05073c4</span></span><br><span class="line">[root@fc4ad8c3e129 /]<span class="comment"># ls -l</span></span><br><span class="line">total 56</span><br><span class="line">......</span><br><span class="line">drwxr-xr-x   2 root root 4096 Apr 25 00:22 volume01</span><br><span class="line">drwxr-xr-x   2 root root 4096 Apr 25 00:22 volume02</span><br><span class="line">[root@fc4ad8c3e129 /]<span class="comment"># cd volume01</span></span><br><span class="line">[root@fc4ad8c3e129 volume01]<span class="comment"># touch docker01.txt</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建docker02并查看同步的数据卷</span></span><br><span class="line">[root@VM-1-14-centos ~]<span class="comment"># docker run -it --name docker02 --volumes-from docker01 706bb05073c4</span></span><br><span class="line">[root@1f84a808b9bb /]<span class="comment"># ls -l</span></span><br><span class="line">total 56</span><br><span class="line">......</span><br><span class="line">drwxr-xr-x   2 root root 4096 Apr 25 00:22 volume01</span><br><span class="line">drwxr-xr-x   2 root root 4096 Apr 25 00:22 volume02</span><br><span class="line">[root@1f84a808b9bb /]<span class="comment"># cd volume01</span></span><br><span class="line">[root@1f84a808b9bb volume01]<span class="comment"># ls</span></span><br><span class="line">docker01.txt  <span class="comment"># docker01创建的文件在docker02中被同步</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除docker01并查看docker02的数据仍然存在</span></span><br><span class="line">[root@VM-1-14-centos ~]<span class="comment"># docker rm -f docker01</span></span><br><span class="line">docker01</span><br><span class="line">[root@1f84a808b9bb volume01]<span class="comment"># ls</span></span><br><span class="line">docker01.txt</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>container2和container1共享的数据卷<strong>互相共享但双向拷贝</strong>。</p></blockquote><h3 id="多个MySQL数据共享"><a href="#多个MySQL数据共享" class="headerlink" title="多个MySQL数据共享"></a>多个MySQL数据共享</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -p 3306:3306 -v /home/mysql/conf:/etc/mysql/conf.d -v /home/mysql/data:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=123456 --name mysql01 mysql:5.7</span><br><span class="line">docker run -d -p 3307:3306 -e MYSQL_ROOT_PASSWORD=123456 --name mysql02 --volumes-from mysql01  mysql:5.7</span><br><span class="line"><span class="comment"># -v 设置的挂载路径只需要设置一次，后来的继承即可</span></span><br></pre></td></tr></table></figure><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>便于集群建配置的同步共享。</p><p>数据卷的生命周期一直持续到所有容器被消灭为止（高可用）。</p><p>持久化到本地时，即使容器删除，本地数据依然保留。</p>]]></content>
      
      
      <categories>
          
          <category> Docker基础 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Docker基础Part3</title>
      <link href="/2021/04/Docker%E5%9F%BA%E7%A1%80Part3/"/>
      <url>/2021/04/Docker%E5%9F%BA%E7%A1%80Part3/</url>
      
        <content type="html"><![CDATA[<h1 id="Docker基础Part3——镜像讲解"><a href="#Docker基础Part3——镜像讲解" class="headerlink" title="Docker基础Part3——镜像讲解"></a>Docker基础Part3——镜像讲解</h1><p>[TOC]</p><h2 id="Docker镜像加载原理"><a href="#Docker镜像加载原理" class="headerlink" title="Docker镜像加载原理"></a>Docker镜像加载原理</h2><h3 id="镜像是什么"><a href="#镜像是什么" class="headerlink" title="镜像是什么"></a>镜像是什么</h3><p>镜像是一种轻量级、可执行的独立软件保，用来打包软件运行环境和基于运行环境开发的软件，他包含运行某个软件所需的所有内容，包括代码、运行时库、环境变量和配置文件。</p><blockquote><p>docker镜像文件 = (Linux的bootfs) + 基础镜像的rootfs + 镜像本身的依赖 + 镜像本身</p></blockquote><h3 id="UnionFs"><a href="#UnionFs" class="headerlink" title="UnionFs"></a>UnionFs</h3><p>Docker镜像实际上由一层一层的文件系统组成，这种层级的文件系统叫UnionFS。</p><p>UnionFs（联合文件系统）：Union文件系统是一种分层、轻量级并且高性能的文件系统，他支持对文件系统的修改（增加新的操作环境）作为一次提交来一层层的叠加，同时可以将不同目录挂载到同一个虚拟文件系统下。镜像可以通过分层来进行继承，基于基础镜像，可以制作各种具体的应用镜像。</p><blockquote><p>特性：一次同时加载多个文件系统，但从外面看起来，只能看到一个文件系统，联合加载会把各层需要文件系统叠加统合起来（<strong>不同的镜像可能会使用相同的部分层级文件</strong>），最终的文件系统会包含所有需要的底层文件和目录。</p></blockquote><h3 id="bootfs-amp-rootfs"><a href="#bootfs-amp-rootfs" class="headerlink" title="bootfs &amp; rootfs"></a>bootfs &amp; rootfs</h3><p>典型的Linux文件系统由<strong>bootfs</strong>和<strong>rootfs</strong>两部分组成，而 Docker 镜像的最底层就是 Linux 内核。</p><p>bootfs（boot file system）包含 bootloader和 kernel。bootloader主要负责引导加载内核 kernel。这一层与主机的Linux/Unix系统是一样的，用户不会修改这个文件系统 。在启动过程完成后，整个内核 kernel 都会被加载进内存，此时 bootfs 会被 umount 卸载从而释放出所占用的内存。</p><p>rootfs（root file system）在 bootfs之上。包括 /dev、/proc、/bin、/etc、/lib、/usr、/tmp 等再加上要运行用户应用所需要的所有配置文件，二进制文件和库文件。 各个版本的bootfs是一样的，区别就是rootfs。Linux 系统在启动时，rootfs 首先会被挂载为只读模式，然后在启动完成后被修改为读写模式，随后它们就可以被修改了。</p><blockquote><ul><li>所有 Docker 容器都共享主机系统的 bootfs 即 Linux 内核</li><li>每个容器有自己的 rootfs，它来自不同的 Linux 发行版的基础镜像，包括 Ubuntu，Debian 和 SUSE 等</li><li>所有基于一种基础镜像的容器都共享这种 rootfs</li></ul></blockquote><img src="/2021/04/Docker%E5%9F%BA%E7%A1%80Part3/20150825141358_122.png" alt="Docker" style="zoom:200%;"><h2 id="Docker分层理解"><a href="#Docker分层理解" class="headerlink" title="Docker分层理解"></a>Docker分层理解</h2><h3 id="分层共享"><a href="#分层共享" class="headerlink" title="分层共享"></a>分层共享</h3><p>Docker镜像采用分层结构最大的好处就是资源共享（镜像的每一层都可以被共享）。当多个镜像具备相同的一层镜像文件，则宿主机只需在磁盘上保留一份镜像文件（相同的镜像文件不会被重复下载），同时内存中也只需要加载一份镜像文件（相同的镜像文件不会被重复加载），就可以为所有的容器服务了。</p><ul><li>所有的 Docker镜像都起始于一个基础镜像层，当进行修改或添加新的内容时，就会在当前镜像层之上，创建新的镜像层。</li></ul><p><img src="/2021/04/Docker%E5%9F%BA%E7%A1%80Part3/image-20210424123316106.png" alt="image-20210424123316106"></p><ul><li>在添加额外的镜像层的同时，镜像始终保持是当前所有镜像的组合。</li></ul><p><img src="/2021/04/Docker%E5%9F%BA%E7%A1%80Part3/image-20210424123442809.png" alt="image-20210424123442809"></p><ul><li>对于版本更新的新文件，在打包合并镜像时会舍弃旧文件。</li></ul><p><img src="/2021/04/Docker%E5%9F%BA%E7%A1%80Part3/image-20210424123755365.png" alt="image-20210424123755365"></p><h3 id="存储引擎"><a href="#存储引擎" class="headerlink" title="存储引擎"></a>存储引擎</h3><p>Docker通过存储引擎（新版本采用快照机制）的方式来实现镜像层堆栈，并保证多镜像层对外展示为统一的文件系统。</p><p>Linux上可用的存储引撃有AUFS、 Overlay2、 Device Mapper、Btrfs以及ZFS。每种存储引擎都有其独有的性能特点。</p><p>Docker在 Windows上仅支持 windowsfilter 一种存储引擎，该引擎基于NTFS文件系统之上实现了分层和CoW。</p><h3 id="镜像层-amp-容器层"><a href="#镜像层-amp-容器层" class="headerlink" title="镜像层&amp;容器层"></a>镜像层&amp;容器层</h3><p>Docker 镜像都是只读的，当容器启动时，一个新的可写的容器层加载到镜像层的上方。</p><img src="/2021/04/Docker%E5%9F%BA%E7%A1%80Part3/1265713-20190402151517616-1614953387.png" alt="img" style="zoom: 150%;"><h2 id="提交镜像"><a href="#提交镜像" class="headerlink" title="提交镜像"></a>提交镜像</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker commit -m=<span class="string">&quot;描述信息&quot;</span> -a=<span class="string">&quot;作者&quot;</span> 容器id 镜像名:[TAG]</span><br></pre></td></tr></table></figure><p>demo:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1、启动一个默认的tomcat</span></span><br><span class="line">[root@VM-1-14-centos ~]<span class="comment"># docker run -d -p 8080:8080 tomcat</span></span><br><span class="line">[root@VM-1-14-centos ~]<span class="comment"># docker exec -it 容器id</span></span><br><span class="line"><span class="comment"># 2、默认的tomcat没有webapps应用，即/usr/local/tomcat/webapps下没有文件</span></span><br><span class="line">root@6043e496a1c0:/usr/<span class="built_in">local</span>/tomcat<span class="comment"># ls webapps</span></span><br><span class="line"><span class="comment"># 3、拷贝文件进去</span></span><br><span class="line">root@6043e496a1c0:/usr/<span class="built_in">local</span>/tomcat<span class="comment"># cp -r webapps.dist/* webapps</span></span><br><span class="line"><span class="comment"># 4、将操作过的容器通过commit提交为一个镜像</span></span><br><span class="line">[root@VM-1-14-centos ~]<span class="comment"># docker commit -a=&quot;NephrenCake&quot; -m=&quot;add webapps app&quot; 6043e496a1c0 tomcat02:1.0</span></span><br><span class="line">sha256:ad23de72c26b7b3fb360fd745734738a2be98043bff43938a7ee0b8d772e7708</span><br><span class="line">[root@VM-1-14-centos ~]<span class="comment"># docker images</span></span><br><span class="line">REPOSITORY            TAG       IMAGE ID       CREATED          SIZE</span><br><span class="line">tomcat02              1.0       ad23de72c26b   19 seconds ago   672MB</span><br><span class="line">tomcat                latest    c0e850d7b9bb   31 hours ago     667MB</span><br><span class="line">portainer/portainer   latest    580c0e4e98b0   5 weeks ago      79.1MB</span><br></pre></td></tr></table></figure><blockquote><p>刚开始学习时，可以对概念理解模糊，但一定要实践。最终通过实践和概念相结合，完全理解知识点。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Docker基础 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Docker基础Part2</title>
      <link href="/2021/04/Docker%E5%9F%BA%E7%A1%80Part2/"/>
      <url>/2021/04/Docker%E5%9F%BA%E7%A1%80Part2/</url>
      
        <content type="html"><![CDATA[<h1 id="Docker基础Part2——基本命令"><a href="#Docker基础Part2——基本命令" class="headerlink" title="Docker基础Part2——基本命令"></a>Docker基础Part2——基本命令</h1><p>[TOC]</p><h2 id="帮助命令"><a href="#帮助命令" class="headerlink" title="帮助命令"></a>帮助命令</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker version  <span class="comment"># 版本信息</span></span><br><span class="line">docker info  <span class="comment"># 系统信息，包括镜像、容器、运行状态、插件</span></span><br><span class="line">docker 命令 --<span class="built_in">help</span></span><br></pre></td></tr></table></figure><p>帮助文档 <a href="https://docs.docker.com/reference/">https://docs.docker.com/reference/</a></p><h2 id="镜像命令"><a href="#镜像命令" class="headerlink" title="镜像命令"></a>镜像命令</h2><blockquote><p>注意这里是镜像，不是容器。</p></blockquote><h3 id="docker-images"><a href="#docker-images" class="headerlink" title="docker images"></a>docker images</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-1-14-centos ~]<span class="comment"># docker images</span></span><br><span class="line">REPOSITORY    TAG       IMAGE ID       CREATED       SIZE</span><br><span class="line">hello-world   latest    d1165f221234   6 weeks ago   13.3kB</span><br><span class="line"></span><br><span class="line"><span class="comment"># 解释</span></span><br><span class="line">REPOSITORY：镜像的仓库源</span><br><span class="line">TAG：镜像的标签</span><br><span class="line">IMAGE ID：镜像ID</span><br><span class="line">CREATED：镜像创建时间</span><br><span class="line">SIZE：镜像大小</span><br><span class="line"></span><br><span class="line"><span class="comment"># 可选项</span></span><br><span class="line">  -a, --all             <span class="comment"># 列出所有镜像</span></span><br><span class="line">  -q, --quiet           <span class="comment"># 只显示镜像</span></span><br></pre></td></tr></table></figure><h3 id="docker-search"><a href="#docker-search" class="headerlink" title="docker search"></a>docker search</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-1-14-centos ~]<span class="comment"># docker search mysql</span></span><br><span class="line">NAME                              DESCRIPTION                                     STARS     OFFICIAL   AUTOMATED</span><br><span class="line">mysql                             MySQL is a widely used, open-source relation…   10777     [OK]       </span><br><span class="line">mariadb                           MariaDB Server is a high performing open sou…   4058      [OK]       </span><br><span class="line">......</span><br><span class="line"></span><br><span class="line"><span class="comment"># 可选项</span></span><br><span class="line">  -f, --filter filter   Filter output based on conditions provided</span><br><span class="line">      --format string   Pretty-print search using a Go template</span><br><span class="line">      --<span class="built_in">limit</span> int       Max number of search results (default 25)</span><br><span class="line">      --no-trunc        Don<span class="string">&#x27;t truncate output</span></span><br><span class="line"><span class="string">      </span></span><br><span class="line"><span class="string"># demo</span></span><br><span class="line"><span class="string">docker search mysql --filter=STARS=3000  # 只显示stars&gt;=3k的</span></span><br></pre></td></tr></table></figure><h3 id="docker-pull"><a href="#docker-pull" class="headerlink" title="docker pull"></a>docker pull</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-1-14-centos ~]<span class="comment"># docker pull mysql</span></span><br><span class="line">Using default tag: latest  <span class="comment"># 不指定tag则默认latest</span></span><br><span class="line">latest: Pulling from library/mysql</span><br><span class="line">f7ec5a41d630: Pull complete  <span class="comment"># 分层下载是docker的核心，联合文件系统</span></span><br><span class="line">9444bb562699: Pull complete </span><br><span class="line">6a4207b96940: Pull complete </span><br><span class="line">181cefd361ce: Pull complete </span><br><span class="line">8a2090759d8a: Pull complete </span><br><span class="line">15f235e0d7ee: Pull complete </span><br><span class="line">d870539cd9db: Pull complete </span><br><span class="line">493aaa84617a: Pull complete </span><br><span class="line">bfc0e534fc78: Pull complete </span><br><span class="line">fae20d253f9d: Pull complete </span><br><span class="line">9350664305b3: Pull complete </span><br><span class="line">e47da95a5aab: Pull complete </span><br><span class="line">Digest: sha256:04ee7141256e83797ea4a84a4d31b1f1bc10111c8d1bc1879d52729ccd19e20a  <span class="comment"># 签名</span></span><br><span class="line">Status: Downloaded newer image <span class="keyword">for</span> mysql:latest</span><br><span class="line">docker.io/library/mysql:latest  <span class="comment"># 真实地址 </span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 两者等价</span></span><br><span class="line">docker pull mysql</span><br><span class="line">docker pull docker.io/library/mysql:latest</span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定版本下载(一定要来源于官方支持的版本)</span></span><br><span class="line">[root@VM-1-14-centos ~]<span class="comment"># docker pull mysql:5.7</span></span><br><span class="line">5.7: Pulling from library/mysql</span><br><span class="line">f7ec5a41d630: Already exists  <span class="comment"># 已存在的部分分层文件可以共用，不需要重复下载</span></span><br><span class="line">9444bb562699: Already exists </span><br><span class="line">6a4207b96940: Already exists </span><br><span class="line">181cefd361ce: Already exists </span><br><span class="line">8a2090759d8a: Already exists </span><br><span class="line">15f235e0d7ee: Already exists </span><br><span class="line">d870539cd9db: Already exists </span><br><span class="line">cb7af63cbefa: Pull complete  <span class="comment"># 只需要更新不同的文件</span></span><br><span class="line">151f1721bdbf: Pull complete </span><br><span class="line">fcd19c3dd488: Pull complete </span><br><span class="line">415af2aa5ddc: Pull complete </span><br><span class="line">Digest: sha256:a655529fdfcbaf0ef28984d68a3e21778e061c886ff458b677391924f62fb457</span><br><span class="line">Status: Downloaded newer image <span class="keyword">for</span> mysql:5.7</span><br><span class="line">docker.io/library/mysql:5.7</span><br><span class="line"></span><br><span class="line"><span class="comment"># 可选项</span></span><br><span class="line">  -a, --all-tags                Download all tagged images <span class="keyword">in</span> the repository</span><br><span class="line">      --disable-content-trust   Skip image verification (default <span class="literal">true</span>)</span><br><span class="line">      --platform string         Set platform <span class="keyword">if</span> server is multi-platform capable</span><br><span class="line">  -q, --quiet                   Suppress verbose output</span><br></pre></td></tr></table></figure><h3 id="docker-rmi"><a href="#docker-rmi" class="headerlink" title="docker rmi"></a>docker rmi</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-1-14-centos ~]<span class="comment"># docker rmi -f 87eca374c0ed</span></span><br><span class="line">Untagged: mysql:5.7</span><br><span class="line">Untagged: mysql@sha256:a655529fdfcbaf0ef28984d68a3e21778e061c886ff458b677391924f62fb457</span><br><span class="line">Deleted: sha256:87eca374c0ed97f0f0b504174b0d22b0a0add454414c0dbf5ae43870369f6854  <span class="comment"># 只删除了5.7部分</span></span><br><span class="line">Deleted: sha256:3b035442a2f8d52d6c5c2d83a18c6c21a89b4dc6c89b481bcf40df89087655ce</span><br><span class="line">Deleted: sha256:a223f1762b2c619a59b81fc2304bf4c9b791c777c8bdb19760c09cbd1f061efc</span><br><span class="line">Deleted: sha256:92402939b3fd03bee3745eb90df9799bcb7d0ef92ca8ecf7ef37ad9c8a550084</span><br><span class="line">Deleted: sha256:028b21e33aa4cd9c88acdd194d5cbef25638ffbca8669bfc0da72ad1eb148997</span><br><span class="line"></span><br><span class="line"><span class="comment"># rmi中i表示image</span></span><br><span class="line"><span class="comment"># -f全部删除</span></span><br><span class="line"><span class="comment"># 可以通过镜像的名字或者id删</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除多个/所有镜像</span></span><br><span class="line">[root@VM-1-14-centos ~]<span class="comment"># docker rmi -f $(docker images -aq)</span></span><br></pre></td></tr></table></figure><h2 id="容器命令"><a href="#容器命令" class="headerlink" title="容器命令"></a>容器命令</h2><h3 id="启动容器"><a href="#启动容器" class="headerlink" title="启动容器"></a>启动容器</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">docker run [ option ] image</span><br><span class="line"></span><br><span class="line"><span class="comment"># 参数说明</span></span><br><span class="line">-name=<span class="string">&quot;Name&quot;</span>  <span class="comment"># 容器名字</span></span><br><span class="line">-d            <span class="comment"># 后台方式运行</span></span><br><span class="line">-it           <span class="comment"># 使用交互方式运行，进入容器查看内容</span></span><br><span class="line">-p            <span class="comment"># 指定容器端口 -p 8080:8080</span></span><br><span class="line">    -p ip:主机端口:容器端口</span><br><span class="line">    -p 主机端口:容器端口  <span class="comment"># 常用，将主机端口映射到容器端口</span></span><br><span class="line">    -p 容器端口  <span class="comment"># 内部使用</span></span><br><span class="line">    容器端口</span><br><span class="line">-P            <span class="comment"># 随机指定端口</span></span><br></pre></td></tr></table></figure><blockquote><p>每次run都是新建一个容器！</p></blockquote><p>demo</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在 linux 上下载 centos 镜像，启动并进入容器</span></span><br><span class="line"><span class="comment"># 使用 /bin/bash 或 /bin/sh 启用控制台命令交互</span></span><br><span class="line"><span class="comment"># 此处主机名 33a022c1918a 就是容器id</span></span><br><span class="line"><span class="comment"># 此时这个容器内部就是一个centos系统，但是很多地方不完善</span></span><br><span class="line"><span class="comment"># exit退出镜像回到主机</span></span><br><span class="line">[root@VM-1-14-centos ~]<span class="comment"># docker pull centos</span></span><br><span class="line">[root@VM-1-14-centos ~]<span class="comment"># docker run -it centos /bin/bash</span></span><br><span class="line">[root@33a022c1918a /]<span class="comment"># ls</span></span><br><span class="line">bin  dev  etc  home  lib  lib64  lost+found  media  mnt  opt  proc  root  run  sbin  srv  sys  tmp  usr  var</span><br><span class="line">[root@33a022c1918a /]<span class="comment"># exit</span></span><br><span class="line"><span class="built_in">exit</span></span><br><span class="line">[root@VM-1-14-centos ~]<span class="comment"># ls /</span></span><br><span class="line">bin  boot  data  dev  etc  home  lib  lib64  lost+found  media  mnt  opt  proc  root  run  sbin  srv  sys  tmp  usr  var</span><br></pre></td></tr></table></figure><h3 id="查看容器"><a href="#查看容器" class="headerlink" title="查看容器"></a>查看容器</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">docker ps [ options ]</span><br><span class="line"></span><br><span class="line">Options:</span><br><span class="line">  -a, --all             <span class="comment"># 列出当前正在运行(默认)+历史运行过的容器</span></span><br><span class="line">  -n, --last int        <span class="comment"># 最近n个创建过的容器</span></span><br><span class="line">  -q, --quiet           <span class="comment"># 只显示id</span></span><br></pre></td></tr></table></figure><p>demo</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-1-14-centos ~]<span class="comment"># docker ps</span></span><br><span class="line">CONTAINER ID   IMAGE     COMMAND   CREATED   STATUS    PORTS     NAMES</span><br><span class="line">[root@VM-1-14-centos ~]<span class="comment"># docker ps -all</span></span><br><span class="line">CONTAINER ID   IMAGE     COMMAND       CREATED          STATUS                       PORTS     NAMES</span><br><span class="line">33a022c1918a   centos    <span class="string">&quot;/bin/bash&quot;</span>   13 minutes ago   Exited (127) 9 minutes ago             nostalgic_hermann</span><br><span class="line">[root@VM-1-14-centos ~]<span class="comment"># docker ps -a</span></span><br><span class="line">CONTAINER ID   IMAGE          COMMAND       CREATED          STATUS                       PORTS     NAMES</span><br><span class="line">33a022c1918a   centos         <span class="string">&quot;/bin/bash&quot;</span>   14 minutes ago   Exited (127) 9 minutes ago             nostalgic_hermann</span><br><span class="line">d036353864f6   d1165f221234   <span class="string">&quot;/hello&quot;</span>      2 days ago       Exited (0) 2 days ago                  cranky_nash</span><br><span class="line">[root@VM-1-14-centos ~]<span class="comment"># docker ps -aq</span></span><br><span class="line">33a022c1918a</span><br><span class="line">d036353864f6</span><br></pre></td></tr></table></figure><h3 id="退出容器"><a href="#退出容器" class="headerlink" title="退出容器"></a>退出容器</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">exit</span>  <span class="comment"># 退出并停止容器运行</span></span><br><span class="line">ctrl+P+Q  <span class="comment"># 退出但不停止</span></span><br></pre></td></tr></table></figure><h3 id="删除容器"><a href="#删除容器" class="headerlink" title="删除容器"></a>删除容器</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker rm 容器id  <span class="comment"># 删除指定的容器，不能删除正在运行的容器，除非 rm -f</span></span><br><span class="line">docker rm -f $(docker ps -aq)  <span class="comment"># 删除所有容器</span></span><br><span class="line">docker ps -aq | xargs docker rm  <span class="comment"># 删除所有容器</span></span><br></pre></td></tr></table></figure><h3 id="启动-停止容器"><a href="#启动-停止容器" class="headerlink" title="启动/停止容器"></a>启动/停止容器</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker start 容器id  <span class="comment"># 启动</span></span><br><span class="line">docker restart 容器id  <span class="comment"># 重启</span></span><br><span class="line">docker stop 容器id  <span class="comment"># 停止</span></span><br><span class="line">docker <span class="built_in">kill</span> 容器id  <span class="comment"># 强制停止</span></span><br></pre></td></tr></table></figure><h2 id="其他命令"><a href="#其他命令" class="headerlink" title="其他命令"></a>其他命令</h2><h3 id="后台启动容器"><a href="#后台启动容器" class="headerlink" title="后台启动容器"></a>后台启动容器</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># docker run -d 镜像</span></span><br><span class="line">[root@VM-1-14-centos ~]<span class="comment"># docker run -d centos</span></span><br><span class="line">9dfce832258f344250b3ad0ddaed6e55a9e4ae711a558bb5083dcf9162dd551b</span><br><span class="line"></span><br><span class="line"><span class="comment"># 虽然创建了容器后台运行，但是没有检测到前台应用进程，所以自动停止了。</span></span><br><span class="line"><span class="comment"># 例如：Nginx容器启动之后，发现自己没有提供服务，就立刻停止</span></span><br></pre></td></tr></table></figure><h3 id="查看日志"><a href="#查看日志" class="headerlink" title="查看日志"></a>查看日志</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">docker logs</span><br><span class="line"></span><br><span class="line">Options:</span><br><span class="line">      --details        Show extra details provided to logs</span><br><span class="line">  -f, --follow         Follow <span class="built_in">log</span> output</span><br><span class="line">      --since string   Show logs since timestamp (e.g. 2013-01-02T13:23:37Z) or relative (e.g. 42m <span class="keyword">for</span> 42 minutes)</span><br><span class="line">  -n, --tail string    Number of lines to show from the end of the logs (default <span class="string">&quot;all&quot;</span>)</span><br><span class="line">  -t, --timestamps     Show timestamps</span><br><span class="line">      --until string   Show logs before a timestamp (e.g. 2013-01-02T13:23:37Z) or relative (e.g. 42m <span class="keyword">for</span> 42 minutes)</span><br></pre></td></tr></table></figure><p>demo</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-1-14-centos ~]<span class="comment"># docker run -d centos /bin/bash -c &quot;while true;do echo NephrenCake;sleep 1;done&quot;</span></span><br><span class="line">[root@VM-1-14-centos ~]<span class="comment"># docker ps</span></span><br><span class="line">CONTAINER ID   IMAGE     COMMAND                  CREATED         STATUS         PORTS     NAMES</span><br><span class="line">813d27116121   centos    <span class="string">&quot;/bin/bash -c &#x27;while…&quot;</span>   7 minutes ago   Up 7 minutes             peaceful_gag</span><br><span class="line">[root@VM-1-14-centos ~]<span class="comment"># docker logs -f -t --tail 5 813d27116121</span></span><br><span class="line">2021-04-23T06:18:08.137574755Z NephrenCake</span><br><span class="line">......  <span class="comment"># ctrl + c 退出</span></span><br><span class="line">[root@VM-1-14-centos ~]<span class="comment"># docker stop 813d27116121</span></span><br></pre></td></tr></table></figure><h3 id="查看容器中进程信息"><a href="#查看容器中进程信息" class="headerlink" title="查看容器中进程信息"></a>查看容器中进程信息</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker top 进程id</span><br></pre></td></tr></table></figure><p>demo</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-1-14-centos ~]<span class="comment"># docker restart 813d27116121</span></span><br><span class="line">813d27116121</span><br><span class="line">[root@VM-1-14-centos ~]<span class="comment"># docker logs -ft --tail 5 813d27116121</span></span><br><span class="line">2021-04-23T06:38:02.133138721Z NephrenCake</span><br><span class="line">......  <span class="comment"># restart重新启动，依然执行之前的命令</span></span><br><span class="line">[root@VM-1-14-centos ~]<span class="comment"># docker top 813d27116121</span></span><br><span class="line">UID                 PID                 PPID                C                   STIME               TTY                 TIME                CMD</span><br><span class="line">root                11818               11796               0                   14:38               ?                   00:00:00            /bin/bash -c <span class="keyword">while</span> <span class="literal">true</span>;<span class="keyword">do</span> <span class="built_in">echo</span> NephrenCake;sleep 1;<span class="keyword">done</span></span><br><span class="line">root                11935               11818               0                   14:38               ?                   00:00:00            /usr/bin/coreutils --coreutils-prog-shebang=sleep /usr/bin/sleep 1</span><br></pre></td></tr></table></figure><h3 id="查看镜像的元数据"><a href="#查看镜像的元数据" class="headerlink" title="查看镜像的元数据"></a>查看镜像的元数据</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">docker inspect [ options ] 容器id</span><br><span class="line"></span><br><span class="line">Options:</span><br><span class="line">  -f, --format string   Format the output using the given Go template</span><br><span class="line">  -s, --size            Display total file sizes <span class="keyword">if</span> the <span class="built_in">type</span> is container</span><br><span class="line">      --<span class="built_in">type</span> string     Return JSON <span class="keyword">for</span> specified <span class="built_in">type</span></span><br></pre></td></tr></table></figure><p>demo</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 容器的元数据================================================================================================</span></span><br><span class="line">[root@VM-1-14-centos ~]<span class="comment"># docker inspect 813d27116121</span></span><br><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">&quot;Id&quot;</span>: <span class="string">&quot;813d2711612126bdc63c81b30d29f11894f4d51a179749e33b1500e917b56b38&quot;</span>,  <span class="comment"># 使用的id只是全id的缩写</span></span><br><span class="line">        <span class="string">&quot;Created&quot;</span>: <span class="string">&quot;2021-04-23T06:09:40.625524708Z&quot;</span>,  <span class="comment"># 创建时间</span></span><br><span class="line">        <span class="string">&quot;Path&quot;</span>: <span class="string">&quot;/bin/bash&quot;</span>,  <span class="comment"># 控制台目录</span></span><br><span class="line">        <span class="string">&quot;Args&quot;</span>: [  <span class="comment"># 传递的参数</span></span><br><span class="line">            <span class="string">&quot;-c&quot;</span>,</span><br><span class="line">            <span class="string">&quot;while true;do echo NephrenCake;sleep 1;done&quot;</span></span><br><span class="line">        ],</span><br><span class="line">        <span class="string">&quot;State&quot;</span>: &#123;</span><br><span class="line">            <span class="string">&quot;Status&quot;</span>: <span class="string">&quot;running&quot;</span>,</span><br><span class="line">            <span class="string">&quot;Running&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">            <span class="string">&quot;Paused&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">            <span class="string">&quot;Restarting&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">            <span class="string">&quot;OOMKilled&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">            <span class="string">&quot;Dead&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">            <span class="string">&quot;Pid&quot;</span>: 11818,  <span class="comment"># 父进程id</span></span><br><span class="line">            <span class="string">&quot;ExitCode&quot;</span>: 0,</span><br><span class="line">            <span class="string">&quot;Error&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">            <span class="string">&quot;StartedAt&quot;</span>: <span class="string">&quot;2021-04-23T06:38:02.136315705Z&quot;</span>,</span><br><span class="line">            <span class="string">&quot;FinishedAt&quot;</span>: <span class="string">&quot;2021-04-23T06:23:18.602040203Z&quot;</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">&quot;Image&quot;</span>: <span class="string">&quot;sha256:300e315adb2f96afe5f0b2780b87f28ae95231fe3bdd1e16b9ba606307728f55&quot;</span>,  <span class="comment"># 镜像源</span></span><br><span class="line">        <span class="string">&quot;ResolvConfPath&quot;</span>: <span class="string">&quot;/var/lib/docker/containers/813d2711612126bdc63c81b30d29f11894f4d51a179749e33b1500e917b56b38/resolv.conf&quot;</span>,</span><br><span class="line">        <span class="string">&quot;HostnamePath&quot;</span>: <span class="string">&quot;/var/lib/docker/containers/813d2711612126bdc63c81b30d29f11894f4d51a179749e33b1500e917b56b38/hostname&quot;</span>,</span><br><span class="line">        <span class="string">&quot;HostsPath&quot;</span>: <span class="string">&quot;/var/lib/docker/containers/813d2711612126bdc63c81b30d29f11894f4d51a179749e33b1500e917b56b38/hosts&quot;</span>,</span><br><span class="line">        <span class="string">&quot;LogPath&quot;</span>: <span class="string">&quot;/var/lib/docker/containers/813d2711612126bdc63c81b30d29f11894f4d51a179749e33b1500e917b56b38/813d2711612126bdc63c81b30d29f11894f4d51a179749e33b1500e917b56b38-json.log&quot;</span>,</span><br><span class="line">        <span class="string">&quot;Name&quot;</span>: <span class="string">&quot;/peaceful_gagarin&quot;</span>,</span><br><span class="line">        <span class="string">&quot;RestartCount&quot;</span>: 0,</span><br><span class="line">        <span class="string">&quot;Driver&quot;</span>: <span class="string">&quot;overlay2&quot;</span>,</span><br><span class="line">        <span class="string">&quot;Platform&quot;</span>: <span class="string">&quot;linux&quot;</span>,</span><br><span class="line">        <span class="string">&quot;MountLabel&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">        <span class="string">&quot;ProcessLabel&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">        <span class="string">&quot;AppArmorProfile&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">        <span class="string">&quot;ExecIDs&quot;</span>: null,</span><br><span class="line">        <span class="string">&quot;HostConfig&quot;</span>: &#123;  <span class="comment"># 主机配置</span></span><br><span class="line">            <span class="string">&quot;Binds&quot;</span>: null,</span><br><span class="line">            <span class="string">&quot;ContainerIDFile&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">            <span class="string">&quot;LogConfig&quot;</span>: &#123;</span><br><span class="line">                <span class="string">&quot;Type&quot;</span>: <span class="string">&quot;json-file&quot;</span>,</span><br><span class="line">                <span class="string">&quot;Config&quot;</span>: &#123;&#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="string">&quot;NetworkMode&quot;</span>: <span class="string">&quot;default&quot;</span>,</span><br><span class="line">            <span class="string">&quot;PortBindings&quot;</span>: &#123;&#125;,</span><br><span class="line">            <span class="string">&quot;RestartPolicy&quot;</span>: &#123;</span><br><span class="line">                <span class="string">&quot;Name&quot;</span>: <span class="string">&quot;no&quot;</span>,</span><br><span class="line">                <span class="string">&quot;MaximumRetryCount&quot;</span>: 0</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="string">&quot;AutoRemove&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">            <span class="string">&quot;VolumeDriver&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">            <span class="string">&quot;VolumesFrom&quot;</span>: null,</span><br><span class="line">            <span class="string">&quot;CapAdd&quot;</span>: null,</span><br><span class="line">            <span class="string">&quot;CapDrop&quot;</span>: null,</span><br><span class="line">            <span class="string">&quot;CgroupnsMode&quot;</span>: <span class="string">&quot;host&quot;</span>,</span><br><span class="line">            <span class="string">&quot;Dns&quot;</span>: [],</span><br><span class="line">            <span class="string">&quot;DnsOptions&quot;</span>: [],</span><br><span class="line">            <span class="string">&quot;DnsSearch&quot;</span>: [],</span><br><span class="line">            <span class="string">&quot;ExtraHosts&quot;</span>: null,</span><br><span class="line">            <span class="string">&quot;GroupAdd&quot;</span>: null,</span><br><span class="line">            <span class="string">&quot;IpcMode&quot;</span>: <span class="string">&quot;private&quot;</span>,</span><br><span class="line">            <span class="string">&quot;Cgroup&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">            <span class="string">&quot;Links&quot;</span>: null,</span><br><span class="line">            <span class="string">&quot;OomScoreAdj&quot;</span>: 0,</span><br><span class="line">            <span class="string">&quot;PidMode&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">            <span class="string">&quot;Privileged&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">            <span class="string">&quot;PublishAllPorts&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">            <span class="string">&quot;ReadonlyRootfs&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">            <span class="string">&quot;SecurityOpt&quot;</span>: null,</span><br><span class="line">            <span class="string">&quot;UTSMode&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">            <span class="string">&quot;UsernsMode&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">            <span class="string">&quot;ShmSize&quot;</span>: 67108864,</span><br><span class="line">            <span class="string">&quot;Runtime&quot;</span>: <span class="string">&quot;runc&quot;</span>,</span><br><span class="line">            <span class="string">&quot;ConsoleSize&quot;</span>: [</span><br><span class="line">                0,</span><br><span class="line">                0</span><br><span class="line">            ],</span><br><span class="line">            <span class="string">&quot;Isolation&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">            <span class="string">&quot;CpuShares&quot;</span>: 0,</span><br><span class="line">            <span class="string">&quot;Memory&quot;</span>: 0,</span><br><span class="line">            <span class="string">&quot;NanoCpus&quot;</span>: 0,</span><br><span class="line">            <span class="string">&quot;CgroupParent&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">            <span class="string">&quot;BlkioWeight&quot;</span>: 0,</span><br><span class="line">            <span class="string">&quot;BlkioWeightDevice&quot;</span>: [],</span><br><span class="line">            <span class="string">&quot;BlkioDeviceReadBps&quot;</span>: null,</span><br><span class="line">            <span class="string">&quot;BlkioDeviceWriteBps&quot;</span>: null,</span><br><span class="line">            <span class="string">&quot;BlkioDeviceReadIOps&quot;</span>: null,</span><br><span class="line">            <span class="string">&quot;BlkioDeviceWriteIOps&quot;</span>: null,</span><br><span class="line">            <span class="string">&quot;CpuPeriod&quot;</span>: 0,</span><br><span class="line">            <span class="string">&quot;CpuQuota&quot;</span>: 0,</span><br><span class="line">            <span class="string">&quot;CpuRealtimePeriod&quot;</span>: 0,</span><br><span class="line">            <span class="string">&quot;CpuRealtimeRuntime&quot;</span>: 0,</span><br><span class="line">            <span class="string">&quot;CpusetCpus&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">            <span class="string">&quot;CpusetMems&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">            <span class="string">&quot;Devices&quot;</span>: [],</span><br><span class="line">            <span class="string">&quot;DeviceCgroupRules&quot;</span>: null,</span><br><span class="line">            <span class="string">&quot;DeviceRequests&quot;</span>: null,</span><br><span class="line">            <span class="string">&quot;KernelMemory&quot;</span>: 0,</span><br><span class="line">            <span class="string">&quot;KernelMemoryTCP&quot;</span>: 0,</span><br><span class="line">            <span class="string">&quot;MemoryReservation&quot;</span>: 0,</span><br><span class="line">            <span class="string">&quot;MemorySwap&quot;</span>: 0,</span><br><span class="line">            <span class="string">&quot;MemorySwappiness&quot;</span>: null,</span><br><span class="line">            <span class="string">&quot;OomKillDisable&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">            <span class="string">&quot;PidsLimit&quot;</span>: null,</span><br><span class="line">            <span class="string">&quot;Ulimits&quot;</span>: null,</span><br><span class="line">            <span class="string">&quot;CpuCount&quot;</span>: 0,</span><br><span class="line">            <span class="string">&quot;CpuPercent&quot;</span>: 0,</span><br><span class="line">            <span class="string">&quot;IOMaximumIOps&quot;</span>: 0,</span><br><span class="line">            <span class="string">&quot;IOMaximumBandwidth&quot;</span>: 0,</span><br><span class="line">            <span class="string">&quot;MaskedPaths&quot;</span>: [</span><br><span class="line">                <span class="string">&quot;/proc/asound&quot;</span>,</span><br><span class="line">                <span class="string">&quot;/proc/acpi&quot;</span>,</span><br><span class="line">                <span class="string">&quot;/proc/kcore&quot;</span>,</span><br><span class="line">                <span class="string">&quot;/proc/keys&quot;</span>,</span><br><span class="line">                <span class="string">&quot;/proc/latency_stats&quot;</span>,</span><br><span class="line">                <span class="string">&quot;/proc/timer_list&quot;</span>,</span><br><span class="line">                <span class="string">&quot;/proc/timer_stats&quot;</span>,</span><br><span class="line">                <span class="string">&quot;/proc/sched_debug&quot;</span>,</span><br><span class="line">                <span class="string">&quot;/proc/scsi&quot;</span>,</span><br><span class="line">                <span class="string">&quot;/sys/firmware&quot;</span></span><br><span class="line">            ],</span><br><span class="line">            <span class="string">&quot;ReadonlyPaths&quot;</span>: [</span><br><span class="line">                <span class="string">&quot;/proc/bus&quot;</span>,</span><br><span class="line">                <span class="string">&quot;/proc/fs&quot;</span>,</span><br><span class="line">                <span class="string">&quot;/proc/irq&quot;</span>,</span><br><span class="line">                <span class="string">&quot;/proc/sys&quot;</span>,</span><br><span class="line">                <span class="string">&quot;/proc/sysrq-trigger&quot;</span></span><br><span class="line">            ]</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">&quot;GraphDriver&quot;</span>: &#123;</span><br><span class="line">            <span class="string">&quot;Data&quot;</span>: &#123;</span><br><span class="line">                <span class="string">&quot;LowerDir&quot;</span>: <span class="string">&quot;/var/lib/docker/overlay2/b6d0d37faec7c071970c4880b019ff1d55f117ef18406c988b813f302bb227d0-init/diff:/var/lib/docker/overlay2/e7f999e147eaa9cc6658059fe0a66e6f6bca79957c99cf69bfe563b82bcbd2be/diff&quot;</span>,</span><br><span class="line">                <span class="string">&quot;MergedDir&quot;</span>: <span class="string">&quot;/var/lib/docker/overlay2/b6d0d37faec7c071970c4880b019ff1d55f117ef18406c988b813f302bb227d0/merged&quot;</span>,</span><br><span class="line">                <span class="string">&quot;UpperDir&quot;</span>: <span class="string">&quot;/var/lib/docker/overlay2/b6d0d37faec7c071970c4880b019ff1d55f117ef18406c988b813f302bb227d0/diff&quot;</span>,</span><br><span class="line">                <span class="string">&quot;WorkDir&quot;</span>: <span class="string">&quot;/var/lib/docker/overlay2/b6d0d37faec7c071970c4880b019ff1d55f117ef18406c988b813f302bb227d0/work&quot;</span></span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="string">&quot;Name&quot;</span>: <span class="string">&quot;overlay2&quot;</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">&quot;Mounts&quot;</span>: [  <span class="comment"># 挂载</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="string">&quot;Type&quot;</span>: <span class="string">&quot;bind&quot;</span>,</span><br><span class="line">                <span class="string">&quot;Source&quot;</span>: <span class="string">&quot;/home/volume&quot;</span>,  <span class="comment"># 主机内目录</span></span><br><span class="line">                <span class="string">&quot;Destination&quot;</span>: <span class="string">&quot;/home&quot;</span>,  <span class="comment"># 容器内目录，目标地址</span></span><br><span class="line">                <span class="string">&quot;Mode&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">                <span class="string">&quot;RW&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">                <span class="string">&quot;Propagation&quot;</span>: <span class="string">&quot;rprivate&quot;</span></span><br><span class="line">            &#125;</span><br><span class="line">        ],</span><br><span class="line">        <span class="string">&quot;Config&quot;</span>: &#123;</span><br><span class="line">            <span class="string">&quot;Hostname&quot;</span>: <span class="string">&quot;813d27116121&quot;</span>,  <span class="comment"># 容器名</span></span><br><span class="line">            <span class="string">&quot;Domainname&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">            <span class="string">&quot;User&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">            <span class="string">&quot;AttachStdin&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">            <span class="string">&quot;AttachStdout&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">            <span class="string">&quot;AttachStderr&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">            <span class="string">&quot;Tty&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">            <span class="string">&quot;OpenStdin&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">            <span class="string">&quot;StdinOnce&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">            <span class="string">&quot;Env&quot;</span>: [  <span class="comment"># 环境变量</span></span><br><span class="line">                <span class="string">&quot;PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin&quot;</span></span><br><span class="line">            ],</span><br><span class="line">            <span class="string">&quot;Cmd&quot;</span>: [  <span class="comment"># command命令行命令</span></span><br><span class="line">                <span class="string">&quot;/bin/bash&quot;</span>,</span><br><span class="line">                <span class="string">&quot;-c&quot;</span>,</span><br><span class="line">                <span class="string">&quot;while true;do echo NephrenCake;sleep 1;done&quot;</span></span><br><span class="line">            ],</span><br><span class="line">            <span class="string">&quot;Image&quot;</span>: <span class="string">&quot;centos&quot;</span>,</span><br><span class="line">            <span class="string">&quot;Volumes&quot;</span>: null,</span><br><span class="line">            <span class="string">&quot;WorkingDir&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">            <span class="string">&quot;Entrypoint&quot;</span>: null,</span><br><span class="line">            <span class="string">&quot;OnBuild&quot;</span>: null,</span><br><span class="line">            <span class="string">&quot;Labels&quot;</span>: &#123;</span><br><span class="line">                <span class="string">&quot;org.label-schema.build-date&quot;</span>: <span class="string">&quot;20201204&quot;</span>,</span><br><span class="line">                <span class="string">&quot;org.label-schema.license&quot;</span>: <span class="string">&quot;GPLv2&quot;</span>,</span><br><span class="line">                <span class="string">&quot;org.label-schema.name&quot;</span>: <span class="string">&quot;CentOS Base Image&quot;</span>,</span><br><span class="line">                <span class="string">&quot;org.label-schema.schema-version&quot;</span>: <span class="string">&quot;1.0&quot;</span>,</span><br><span class="line">                <span class="string">&quot;org.label-schema.vendor&quot;</span>: <span class="string">&quot;CentOS&quot;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">&quot;NetworkSettings&quot;</span>: &#123;</span><br><span class="line">            <span class="string">&quot;Bridge&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">            <span class="string">&quot;SandboxID&quot;</span>: <span class="string">&quot;a58ab6299e5a5cb4b40068484267752f8958795d9073e2bf70ad47478cfd76e3&quot;</span>,</span><br><span class="line">            <span class="string">&quot;HairpinMode&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">            <span class="string">&quot;LinkLocalIPv6Address&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">            <span class="string">&quot;LinkLocalIPv6PrefixLen&quot;</span>: 0,</span><br><span class="line">            <span class="string">&quot;Ports&quot;</span>: &#123;&#125;,</span><br><span class="line">            <span class="string">&quot;SandboxKey&quot;</span>: <span class="string">&quot;/var/run/docker/netns/a58ab6299e5a&quot;</span>,</span><br><span class="line">            <span class="string">&quot;SecondaryIPAddresses&quot;</span>: null,</span><br><span class="line">            <span class="string">&quot;SecondaryIPv6Addresses&quot;</span>: null,</span><br><span class="line">            <span class="string">&quot;EndpointID&quot;</span>: <span class="string">&quot;8b66ea3b5e36bc2599ef8f9f8423036daec31b9df332ba6a9a6924125c3770d9&quot;</span>,</span><br><span class="line">            <span class="string">&quot;Gateway&quot;</span>: <span class="string">&quot;172.18.0.1&quot;</span>,</span><br><span class="line">            <span class="string">&quot;GlobalIPv6Address&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">            <span class="string">&quot;GlobalIPv6PrefixLen&quot;</span>: 0,</span><br><span class="line">            <span class="string">&quot;IPAddress&quot;</span>: <span class="string">&quot;172.18.0.3&quot;</span>,</span><br><span class="line">            <span class="string">&quot;IPPrefixLen&quot;</span>: 16,</span><br><span class="line">            <span class="string">&quot;IPv6Gateway&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">            <span class="string">&quot;MacAddress&quot;</span>: <span class="string">&quot;02:42:ac:12:00:03&quot;</span>,</span><br><span class="line">            <span class="string">&quot;Networks&quot;</span>: &#123;  <span class="comment"># docker网络</span></span><br><span class="line">                <span class="string">&quot;bridge&quot;</span>: &#123;  <span class="comment"># 桥接网卡</span></span><br><span class="line">                    <span class="string">&quot;IPAMConfig&quot;</span>: null,</span><br><span class="line">                    <span class="string">&quot;Links&quot;</span>: null,</span><br><span class="line">                    <span class="string">&quot;Aliases&quot;</span>: null,</span><br><span class="line">                    <span class="string">&quot;NetworkID&quot;</span>: <span class="string">&quot;c49bd3c9074eccb131f580ae87a0f639459d8fbfb6106ff16d95de982f955cb6&quot;</span>,</span><br><span class="line">                    <span class="string">&quot;EndpointID&quot;</span>: <span class="string">&quot;8b66ea3b5e36bc2599ef8f9f8423036daec31b9df332ba6a9a6924125c3770d9&quot;</span>,</span><br><span class="line">                    <span class="string">&quot;Gateway&quot;</span>: <span class="string">&quot;172.18.0.1&quot;</span>,</span><br><span class="line">                    <span class="string">&quot;IPAddress&quot;</span>: <span class="string">&quot;172.18.0.3&quot;</span>,</span><br><span class="line">                    <span class="string">&quot;IPPrefixLen&quot;</span>: 16,</span><br><span class="line">                    <span class="string">&quot;IPv6Gateway&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">                    <span class="string">&quot;GlobalIPv6Address&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">                    <span class="string">&quot;GlobalIPv6PrefixLen&quot;</span>: 0,</span><br><span class="line">                    <span class="string">&quot;MacAddress&quot;</span>: <span class="string">&quot;02:42:ac:12:00:03&quot;</span>,</span><br><span class="line">                    <span class="string">&quot;DriverOpts&quot;</span>: null</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 镜像的元数据================================================================================================</span></span><br><span class="line">[root@VM-1-14-centos ~]<span class="comment"># docker image inspect centos</span></span><br><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">&quot;Id&quot;</span>: <span class="string">&quot;sha256:300e315adb2f96afe5f0b2780b87f28ae95231fe3bdd1e16b9ba606307728f55&quot;</span>,</span><br><span class="line">        <span class="string">&quot;RepoTags&quot;</span>: [</span><br><span class="line">            <span class="string">&quot;centos:latest&quot;</span></span><br><span class="line">        ],</span><br><span class="line">        <span class="string">&quot;RepoDigests&quot;</span>: [</span><br><span class="line">            <span class="string">&quot;centos@sha256:5528e8b1b1719d34604c87e11dcd1c0a20bedf46e83b5632cdeac91b8c04efc1&quot;</span></span><br><span class="line">        ],</span><br><span class="line">        <span class="string">&quot;Parent&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">        <span class="string">&quot;Comment&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">        <span class="string">&quot;Created&quot;</span>: <span class="string">&quot;2020-12-08T00:22:53.076477777Z&quot;</span>,</span><br><span class="line">        <span class="string">&quot;Container&quot;</span>: <span class="string">&quot;395e0bfa7301f73bc994efe15099ea56b8836c608dd32614ac5ae279976d33e4&quot;</span>,</span><br><span class="line">        <span class="string">&quot;ContainerConfig&quot;</span>: &#123;</span><br><span class="line">            <span class="string">&quot;Hostname&quot;</span>: <span class="string">&quot;395e0bfa7301&quot;</span>,</span><br><span class="line">            <span class="string">&quot;Domainname&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">            <span class="string">&quot;User&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">            <span class="string">&quot;AttachStdin&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">            <span class="string">&quot;AttachStdout&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">            <span class="string">&quot;AttachStderr&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">            <span class="string">&quot;Tty&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">            <span class="string">&quot;OpenStdin&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">            <span class="string">&quot;StdinOnce&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">            <span class="string">&quot;Env&quot;</span>: [</span><br><span class="line">                <span class="string">&quot;PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin&quot;</span></span><br><span class="line">            ],</span><br><span class="line">            <span class="string">&quot;Cmd&quot;</span>: [</span><br><span class="line">                <span class="string">&quot;/bin/sh&quot;</span>,</span><br><span class="line">                <span class="string">&quot;-c&quot;</span>,</span><br><span class="line">                <span class="string">&quot;#(nop) &quot;</span>,</span><br><span class="line">                <span class="string">&quot;CMD [\&quot;/bin/bash\&quot;]&quot;</span></span><br><span class="line">            ],</span><br><span class="line">            <span class="string">&quot;Image&quot;</span>: <span class="string">&quot;sha256:6de05bdfbf9a9d403458d10de9e088b6d93d971dd5d48d18b4b6758f4554f451&quot;</span>,</span><br><span class="line">            <span class="string">&quot;Volumes&quot;</span>: null,</span><br><span class="line">            <span class="string">&quot;WorkingDir&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">            <span class="string">&quot;Entrypoint&quot;</span>: null,</span><br><span class="line">            <span class="string">&quot;OnBuild&quot;</span>: null,</span><br><span class="line">            <span class="string">&quot;Labels&quot;</span>: &#123;</span><br><span class="line">                <span class="string">&quot;org.label-schema.build-date&quot;</span>: <span class="string">&quot;20201204&quot;</span>,</span><br><span class="line">                <span class="string">&quot;org.label-schema.license&quot;</span>: <span class="string">&quot;GPLv2&quot;</span>,</span><br><span class="line">                <span class="string">&quot;org.label-schema.name&quot;</span>: <span class="string">&quot;CentOS Base Image&quot;</span>,</span><br><span class="line">                <span class="string">&quot;org.label-schema.schema-version&quot;</span>: <span class="string">&quot;1.0&quot;</span>,</span><br><span class="line">                <span class="string">&quot;org.label-schema.vendor&quot;</span>: <span class="string">&quot;CentOS&quot;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">&quot;DockerVersion&quot;</span>: <span class="string">&quot;19.03.12&quot;</span>,</span><br><span class="line">        <span class="string">&quot;Author&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">        <span class="string">&quot;Config&quot;</span>: &#123;</span><br><span class="line">            <span class="string">&quot;Hostname&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">            <span class="string">&quot;Domainname&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">            <span class="string">&quot;User&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">            <span class="string">&quot;AttachStdin&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">            <span class="string">&quot;AttachStdout&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">            <span class="string">&quot;AttachStderr&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">            <span class="string">&quot;Tty&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">            <span class="string">&quot;OpenStdin&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">            <span class="string">&quot;StdinOnce&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">            <span class="string">&quot;Env&quot;</span>: [</span><br><span class="line">                <span class="string">&quot;PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin&quot;</span></span><br><span class="line">            ],</span><br><span class="line">            <span class="string">&quot;Cmd&quot;</span>: [</span><br><span class="line">                <span class="string">&quot;/bin/bash&quot;</span></span><br><span class="line">            ],</span><br><span class="line">            <span class="string">&quot;Image&quot;</span>: <span class="string">&quot;sha256:6de05bdfbf9a9d403458d10de9e088b6d93d971dd5d48d18b4b6758f4554f451&quot;</span>,</span><br><span class="line">            <span class="string">&quot;Volumes&quot;</span>: null,</span><br><span class="line">            <span class="string">&quot;WorkingDir&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">            <span class="string">&quot;Entrypoint&quot;</span>: null,</span><br><span class="line">            <span class="string">&quot;OnBuild&quot;</span>: null,</span><br><span class="line">            <span class="string">&quot;Labels&quot;</span>: &#123;</span><br><span class="line">                <span class="string">&quot;org.label-schema.build-date&quot;</span>: <span class="string">&quot;20201204&quot;</span>,</span><br><span class="line">                <span class="string">&quot;org.label-schema.license&quot;</span>: <span class="string">&quot;GPLv2&quot;</span>,</span><br><span class="line">                <span class="string">&quot;org.label-schema.name&quot;</span>: <span class="string">&quot;CentOS Base Image&quot;</span>,</span><br><span class="line">                <span class="string">&quot;org.label-schema.schema-version&quot;</span>: <span class="string">&quot;1.0&quot;</span>,</span><br><span class="line">                <span class="string">&quot;org.label-schema.vendor&quot;</span>: <span class="string">&quot;CentOS&quot;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">&quot;Architecture&quot;</span>: <span class="string">&quot;amd64&quot;</span>,</span><br><span class="line">        <span class="string">&quot;Os&quot;</span>: <span class="string">&quot;linux&quot;</span>,</span><br><span class="line">        <span class="string">&quot;Size&quot;</span>: 209348104,</span><br><span class="line">        <span class="string">&quot;VirtualSize&quot;</span>: 209348104,</span><br><span class="line">        <span class="string">&quot;GraphDriver&quot;</span>: &#123;</span><br><span class="line">            <span class="string">&quot;Data&quot;</span>: &#123;</span><br><span class="line">                <span class="string">&quot;MergedDir&quot;</span>: <span class="string">&quot;/var/lib/docker/overlay2/e7f999e147eaa9cc6658059fe0a66e6f6bca79957c99cf69bfe563b82bcbd2be/merged&quot;</span>,</span><br><span class="line">                <span class="string">&quot;UpperDir&quot;</span>: <span class="string">&quot;/var/lib/docker/overlay2/e7f999e147eaa9cc6658059fe0a66e6f6bca79957c99cf69bfe563b82bcbd2be/diff&quot;</span>,</span><br><span class="line">                <span class="string">&quot;WorkDir&quot;</span>: <span class="string">&quot;/var/lib/docker/overlay2/e7f999e147eaa9cc6658059fe0a66e6f6bca79957c99cf69bfe563b82bcbd2be/work&quot;</span></span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="string">&quot;Name&quot;</span>: <span class="string">&quot;overlay2&quot;</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">&quot;RootFS&quot;</span>: &#123;</span><br><span class="line">            <span class="string">&quot;Type&quot;</span>: <span class="string">&quot;layers&quot;</span>,</span><br><span class="line">            <span class="string">&quot;Layers&quot;</span>: [  <span class="comment"># 分层</span></span><br><span class="line">                <span class="string">&quot;sha256:2653d992f4ef2bfd27f94db643815aa567240c37732cae1405ad1c1309ee9859&quot;</span></span><br><span class="line">            ]</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">&quot;Metadata&quot;</span>: &#123;</span><br><span class="line">            <span class="string">&quot;LastTagTime&quot;</span>: <span class="string">&quot;0001-01-01T00:00:00Z&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="进入正在运行的容器"><a href="#进入正在运行的容器" class="headerlink" title="进入正在运行的容器"></a>进入正在运行的容器</h3><ul><li>方法1：execute</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="built_in">exec</span> -it 容器id /bin/bash  <span class="comment"># 根据id重新进入容器交互，交互的command为/bin/bash</span></span><br><span class="line"></span><br><span class="line">[root@VM-1-14-centos ~]<span class="comment"># docker exec -it 813d27116121 /bin/bash</span></span><br><span class="line">[root@813d27116121 /]<span class="comment">#</span></span><br></pre></td></tr></table></figure><ul><li>方法2：attach</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">docker attach 容器id  <span class="comment"># 根据id重新进入容器交互，交互的command为之前设置的内容</span></span><br><span class="line"></span><br><span class="line">[root@VM-1-14-centos ~]<span class="comment"># docker attach 813d27116121</span></span><br><span class="line">NephrenCake</span><br><span class="line">......</span><br></pre></td></tr></table></figure><h3 id="在容器和宿主机之间拷贝文件"><a href="#在容器和宿主机之间拷贝文件" class="headerlink" title="在容器和宿主机之间拷贝文件"></a>在容器和宿主机之间拷贝文件</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker cp 容器id:容器内路径 目的主机的路径</span><br><span class="line">docker cp 要拷贝的文件路径 容器名：要拷贝到容器里面对应的路径</span><br><span class="line"></span><br><span class="line">[root@VM-1-14-centos ~]<span class="comment"># docker cp 813d27116121:/home/test.java /home</span></span><br></pre></td></tr></table></figure><blockquote><p>这里拷贝是一个手动的过程，后面使用卷技术可以实现自动同步。</p></blockquote><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker commit -a <span class="string">&quot;liuyifei&quot;</span> fd9913dfe5ba  sealocr:v1 </span><br><span class="line">docker save -o my_ubuntu_v3.tar runoob/ubuntu:v3</span><br><span class="line">docker <span class="built_in">export</span> -o seal-ocr.tar fd9913dfe5ba</span><br></pre></td></tr></table></figure><p><img src="/2021/04/Docker%E5%9F%BA%E7%A1%80Part2/image-20210423164827183.png" alt="image-20210423164827183"></p><p><a href="https://www.bilibili.com/video/BV1og4y1q7M4?p=14">部署Nginx、Tomcat、ES+Kibana</a></p><h2 id="可视化"><a href="#可视化" class="headerlink" title="可视化"></a>可视化</h2><ul><li>portainer</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -p 8080:9000 \</span><br><span class="line">--restart=always -v /var/run/docker.sock:/var/run/docker.sock --privileged=<span class="literal">true</span> portainer/portainer</span><br><span class="line"></span><br><span class="line"><span class="comment"># 内网9000，外网8080</span></span><br><span class="line"><span class="comment"># --restart=always 启动方式</span></span><br><span class="line"><span class="comment"># -v 将数据挂载到本机</span></span><br><span class="line"><span class="comment"># --privileged=true 授权</span></span><br><span class="line"><span class="comment"># portainer/portainer 安装控制面板</span></span><br></pre></td></tr></table></figure><ul><li>Rancher</li></ul><p>在 持续集成/持续部署(CI/CD) 时使用。</p>]]></content>
      
      
      <categories>
          
          <category> Docker基础 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Docker基础Part1</title>
      <link href="/2021/04/Docker%E5%9F%BA%E7%A1%80Part1/"/>
      <url>/2021/04/Docker%E5%9F%BA%E7%A1%80Part1/</url>
      
        <content type="html"><![CDATA[<h1 id="Docker基础Part1——概述"><a href="#Docker基础Part1——概述" class="headerlink" title="Docker基础Part1——概述"></a>Docker基础Part1——概述</h1><p>[TOC]</p><h2 id="Docker简介"><a href="#Docker简介" class="headerlink" title="Docker简介"></a>Docker简介</h2><p>Docker 是一个开源的应用容器引擎，基于Go 语言。</p><p>Docker 可以让开发者打包他们的应用以及依赖包到一个轻量级、可移植的容器中，将应用程序与基础架构分开，然后发布到任何流行的 Linux 机器上，也可以实现虚拟化。</p><p>容器是完全使用沙箱机制，相互之间不会有任何接口，更重要的是容器性能开销极低。</p><h2 id="Docker的应用场景"><a href="#Docker的应用场景" class="headerlink" title="Docker的应用场景"></a>Docker的应用场景</h2><ul><li>Web 应用的自动化打包和发布。</li><li>自动化测试和持续集成、发布。</li><li>在服务型环境中部署和调整数据库或其他的后台应用。</li><li>从头编译或者扩展现有的 OpenShift 或 Cloud Foundry 平台来搭建自己的 PaaS 环境。</li></ul><h2 id="Docker-的优点"><a href="#Docker-的优点" class="headerlink" title="Docker 的优点"></a>Docker 的优点</h2><h3 id="快速，一致地交付应用程序"><a href="#快速，一致地交付应用程序" class="headerlink" title="快速，一致地交付应用程序"></a>快速，一致地交付应用程序</h3><p>Docker 允许开发人员使用您提供的应用程序或服务的本地容器在标准化环境中工作，能够快速交付软件，测试和部署代码，从而简化了开发的生命周期。</p><p>容器非常适合持续集成和持续交付（CI / CD）工作流程，请考虑以下示例方案：</p><ul><li>您的开发人员在本地编写代码，并使用 Docker 容器与同事共享他们的工作。</li><li>他们使用 Docker 将其应用程序推送到测试环境中，并执行自动或手动测试。</li><li>当开发人员发现错误时，他们可以在开发环境中对其进行修复，然后将其重新部署到测试环境中，以进行测试和验证。</li><li>测试完成后，将修补程序推送给生产环境，就像将更新的镜像推送到生产环境一样简单。</li></ul><h3 id="响应式部署和扩展"><a href="#响应式部署和扩展" class="headerlink" title="响应式部署和扩展"></a>响应式部署和扩展</h3><p>Docker 是基于容器的平台，允许高度可移植的工作负载。Docker 容器可以在开发人员的本机上，数据中心的物理或虚拟机上，云服务上或混合环境中运行。</p><p>Docker 的可移植性和轻量级的特性，还可以使您轻松地完成动态管理的工作负担，并根据业务需求指示，实时扩展或拆除应用程序和服务。</p><h3 id="在同一硬件上运行更多工作负载"><a href="#在同一硬件上运行更多工作负载" class="headerlink" title="在同一硬件上运行更多工作负载"></a>在同一硬件上运行更多工作负载</h3><p>Docker 轻巧快速。它为基于虚拟机管理程序的虚拟机提供了可行、经济、高效的替代方案，因此您可以利用更多的计算能力来实现业务目标。Docker 非常适合于高密度环境以及中小型部署，而您可以用更少的资源做更多的事情。</p><h2 id="Docker架构"><a href="#Docker架构" class="headerlink" title="Docker架构"></a>Docker架构</h2><ul><li><strong>镜像（Image）</strong>：Docker 镜像，就相当于是面向对象中静态定义的类class。</li><li><strong>容器（Container）</strong>：Docker 容器（Container），就相当于是面向对象中class的实例对象，是镜像运行时的实体，可以同时运行一个或多个。容器可以被创建、启动、停止、删除、暂停等。</li><li><strong>仓库（Repository）</strong>：仓库可看成一个代码控制中心，用来保存镜像（官方默认是DockerHub）。一个 Docker Registry 中可以包含多个仓库（Repository）；每个仓库可以包含多个标签（Tag）；每个标签对应一个镜像。通常，一个仓库会包含同一个软件不同版本的镜像，而标签就常用于对应该软件的各个版本。我们可以通过 <code>&lt;仓库名&gt;:&lt;标签&gt;</code> 的格式来指定具体是这个软件哪个版本的镜像。如果不给出标签，将以 <code>latest</code> 作为默认标签。</li><li>**客户端 (Client) **：Docker 客户端通过命令行或者其他工具使用 Docker SDK 与 Docker 的守护进程通信。</li><li>**Docker 主机 (Host) **：一个物理或者虚拟的机器用于执行 Docker 守护进程和容器。</li><li>**Docker Machine **：Docker Machine是一个简化Docker安装的命令行工具，通过一个简单的命令行即可在相应的平台上安装Docker，比如VirtualBox、 Digital Ocean、Microsoft Azure。</li></ul><p><img src="/2021/04/Docker%E5%9F%BA%E7%A1%80Part1/image-20210420204117374.png" alt="image-20210420204117374"></p><h2 id="Docker安装"><a href="#Docker安装" class="headerlink" title="Docker安装"></a>Docker安装</h2><h3 id="环境查看"><a href="#环境查看" class="headerlink" title="环境查看"></a>环境查看</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-1-14-centos /]<span class="comment"># uname -r</span></span><br><span class="line">3.10.0-1127.19.1.el7.x86_64</span><br><span class="line">[root@VM-1-14-centos /]<span class="comment"># cat /etc/os-release </span></span><br><span class="line">NAME=<span class="string">&quot;CentOS Linux&quot;</span></span><br><span class="line">VERSION=<span class="string">&quot;7 (Core)&quot;</span></span><br><span class="line">ID=<span class="string">&quot;centos&quot;</span></span><br><span class="line">ID_LIKE=<span class="string">&quot;rhel fedora&quot;</span></span><br><span class="line">VERSION_ID=<span class="string">&quot;7&quot;</span></span><br><span class="line">PRETTY_NAME=<span class="string">&quot;CentOS Linux 7 (Core)&quot;</span></span><br><span class="line">ANSI_COLOR=<span class="string">&quot;0;31&quot;</span></span><br><span class="line">CPE_NAME=<span class="string">&quot;cpe:/o:centos:centos:7&quot;</span></span><br><span class="line">HOME_URL=<span class="string">&quot;https://www.centos.org/&quot;</span></span><br><span class="line">BUG_REPORT_URL=<span class="string">&quot;https://bugs.centos.org/&quot;</span></span><br><span class="line"></span><br><span class="line">CENTOS_MANTISBT_PROJECT=<span class="string">&quot;CentOS-7&quot;</span></span><br><span class="line">CENTOS_MANTISBT_PROJECT_VERSION=<span class="string">&quot;7&quot;</span></span><br><span class="line">REDHAT_SUPPORT_PRODUCT=<span class="string">&quot;centos&quot;</span></span><br><span class="line">REDHAT_SUPPORT_PRODUCT_VERSION=<span class="string">&quot;7&quot;</span></span><br></pre></td></tr></table></figure><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><blockquote><p>建议阅读官方文档 <a href="https://docs.docker.com/">https://docs.docker.com/</a></p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1.卸载旧版本</span></span><br><span class="line">sudo yum remove docker \</span><br><span class="line">                  docker-client \</span><br><span class="line">                  docker-client-latest \</span><br><span class="line">                  docker-common \</span><br><span class="line">                  docker-latest \</span><br><span class="line">                  docker-latest-logrotate \</span><br><span class="line">                  docker-logrotate \</span><br><span class="line">                  docker-engine</span><br><span class="line">                  </span><br><span class="line"><span class="comment"># 2.依赖包</span></span><br><span class="line">sudo yum install -y yum-utils device-mapper-persistent-data lvm2</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3.设置yum源为阿里云</span></span><br><span class="line">sudo yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo</span><br><span class="line"></span><br><span class="line"><span class="comment"># 4.更新软件索引</span></span><br><span class="line">yum makecache fast</span><br><span class="line"></span><br><span class="line"><span class="comment"># 5.安装docker</span></span><br><span class="line">sudo yum install docker-ce</span><br><span class="line"></span><br><span class="line"><span class="comment"># 6.测试安装成功</span></span><br><span class="line">docker version</span><br><span class="line"></span><br><span class="line"><span class="comment"># 7.启动docker</span></span><br><span class="line">sudo systemctl start docker</span><br><span class="line"></span><br><span class="line"><span class="comment"># 8.启动镜像</span></span><br><span class="line">sudo docker run hello-world</span><br><span class="line"></span><br><span class="line"><span class="comment"># 9.查看镜像</span></span><br><span class="line">docker images</span><br></pre></td></tr></table></figure><h2 id="配置阿里云镜像"><a href="#配置阿里云镜像" class="headerlink" title="配置阿里云镜像"></a>配置阿里云镜像</h2><h3 id="登录阿里云"><a href="#登录阿里云" class="headerlink" title="登录阿里云"></a>登录阿里云</h3><p>阿里云 -&gt; 注册/登录 -&gt; 控制台 -&gt; 左上角:产品与服务 -&gt; 容器镜像服务 -&gt; 镜像中心:镜像加速器</p><h3 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1.第一次安装好docker的话，/etc目录下是没有docker目录的， 所以先创建docker目录：</span></span><br><span class="line">sudo mkdir -p /etc/docker</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2.创建并编写配置文件</span></span><br><span class="line">sudo tee /etc/docker/daemon.json &lt;&lt;-<span class="string">&#x27;EOF&#x27;</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;registry-mirrors&quot;</span>: [<span class="string">&quot;https://0uvt67mi.mirror.aliyuncs.com&quot;</span>]</span><br><span class="line">&#125;</span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3.重启docker</span></span><br><span class="line">sudo systemctl daemon-reload</span><br><span class="line">sudo systemctl restart docker</span><br><span class="line"></span><br><span class="line"><span class="comment"># 4.测试</span></span><br><span class="line">docker run hello-world</span><br></pre></td></tr></table></figure><h2 id="hello-world-简单原理"><a href="#hello-world-简单原理" class="headerlink" title="hello world 简单原理"></a>hello world 简单原理</h2><h3 id="运行镜像"><a href="#运行镜像" class="headerlink" title="运行镜像"></a>运行镜像</h3><p><img src="/2021/04/Docker%E5%9F%BA%E7%A1%80Part1/image-20210420215218606.png" alt="image-20210420215218606"></p><h3 id="更少的虚拟层"><a href="#更少的虚拟层" class="headerlink" title="更少的虚拟层"></a>更少的虚拟层</h3><p><img src="/2021/04/Docker%E5%9F%BA%E7%A1%80Part1/image-20210420222126606.png" alt="image-20210420222126606"></p><h3 id="不同虚拟化的区别"><a href="#不同虚拟化的区别" class="headerlink" title="不同虚拟化的区别"></a>不同虚拟化的区别</h3><p><img src="/2021/04/Docker%E5%9F%BA%E7%A1%80Part1/image-20210420222213286.png" alt="image-20210420222213286"></p>]]></content>
      
      
      <categories>
          
          <category> Docker基础 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Git基础-完结目录</title>
      <link href="/2021/03/Git%E5%9F%BA%E7%A1%80-%E5%AE%8C%E7%BB%93%E7%9B%AE%E5%BD%95/"/>
      <url>/2021/03/Git%E5%9F%BA%E7%A1%80-%E5%AE%8C%E7%BB%93%E7%9B%AE%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<h1 id="Git基础——完结目录"><a href="#Git基础——完结目录" class="headerlink" title="Git基础——完结目录"></a>Git基础——完结目录</h1><p>教程视频传送门：</p><ol><li><a href="https://www.bilibili.com/video/BV1FE411P7B3?from=search&seid=14741939341268860783">【狂神说Java】Git最新教程通俗易懂</a></li><li><a href="https://www.bilibili.com/video/BV1pW411A7a5?p=15">尚硅谷GitHub基础全套完整版教程</a></li></ol><p>和Linux的一样，狂神的很精简，尚硅谷的更全。</p><p>==回退版本、合并分支、解决冲突的测试==</p><table><thead><tr><th align="center"><a href="/2021/03/Git%E5%9F%BA%E7%A1%80Part1/">Part1——概述</a></th></tr></thead><tbody><tr><td align="center"><strong><a href="/2021/03/Git%E5%9F%BA%E7%A1%80Part2/">Part2——操作使用</a></strong></td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> Git基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git基础Part2</title>
      <link href="/2021/03/Git%E5%9F%BA%E7%A1%80Part2/"/>
      <url>/2021/03/Git%E5%9F%BA%E7%A1%80Part2/</url>
      
        <content type="html"><![CDATA[<h1 id="Git基础Part2——操作使用"><a href="#Git基础Part2——操作使用" class="headerlink" title="Git基础Part2——操作使用"></a>Git基础Part2——操作使用</h1><p>[TOC]</p><h2 id="打开命令行"><a href="#打开命令行" class="headerlink" title="打开命令行"></a>打开命令行</h2><p>在win上可以到指定位置使用Git Bash（在指定目录下-&gt;右键-&gt;Git Bash Here），个人认为比较方便。</p><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><h3 id="查看配置"><a href="#查看配置" class="headerlink" title="查看配置"></a>查看配置</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git config -l</span><br><span class="line">git config --system --list  <span class="comment">#查看系统config</span></span><br><span class="line">git config --global  --list  <span class="comment">#查看当前用户（global）配置</span></span><br></pre></td></tr></table></figure><ol><li>Git\etc\gitconfig  ：Git 安装目录下的 gitconfig   –system 系统级</li><li>C:\Users\Administrator\ .gitconfig   只适用于当前登录用户的配置  –global 全局</li></ol><h3 id="编辑配置"><a href="#编辑配置" class="headerlink" title="编辑配置"></a>编辑配置</h3><p>每次Git提交都会使用该信息。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config [ --global ] user.name <span class="string">&quot;你的用户名&quot;</span>  <span class="comment"># 设置用户名</span></span><br><span class="line">git config [ --global ] user.email <span class="string">&quot;你的邮箱&quot;</span>  <span class="comment"># 设置注册github的邮箱</span></span><br></pre></td></tr></table></figure><p>使用<code>--global</code>则为全局系统级别的设置，否则为仓库级别的设置。</p><h2 id="仓库与文件"><a href="#仓库与文件" class="headerlink" title="仓库与文件"></a>仓库与文件</h2><h3 id="本地仓库搭建"><a href="#本地仓库搭建" class="headerlink" title="本地仓库搭建"></a>本地仓库搭建</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git init  <span class="comment"># 在当前目录新建一个Git代码库</span></span><br></pre></td></tr></table></figure><p>此命令之后目录下生成.git隐藏文件。</p><h3 id="首次配置url"><a href="#首次配置url" class="headerlink" title="首次配置url"></a>首次配置url</h3><p>建议直接 clone 远端创建好的项目，在其基础上进行开发。</p><h3 id="克隆远程仓库"><a href="#克隆远程仓库" class="headerlink" title="克隆远程仓库"></a>克隆远程仓库</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> [ url ]  <span class="comment"># 克隆一个项目和它的整个代码历史(版本信息)</span></span><br></pre></td></tr></table></figure><h3 id="文件的四种状态"><a href="#文件的四种状态" class="headerlink" title="文件的四种状态"></a>文件的四种状态</h3><ul><li>Untracked: 未跟踪, 此文件在文件夹中, 但并没有加入到git库, 不参与版本控制. 通过git add 状态变为Staged.</li><li>Unmodify: 文件已经入库, 未修改, 即版本库中的文件快照内容与文件夹中完全一致. 这种类型的文件有两种去处, 如果它被修改, 而变为Modified. 如果使用git rm移出版本库, 则成为Untracked文件</li><li>Modified: 文件已修改, 仅仅是修改, 并没有进行其他的操作. 这个文件也有两个去处, 通过git add可进入暂存staged状态, 使用git checkout 则丢弃修改过, 返回到unmodify状态, 这个git checkout即从库中取出文件, 覆盖当前修改 !</li><li>Staged: 暂存状态. 执行git commit则将修改同步到库中, 这时库中的文件和本地文件又变为一致, 文件为Unmodify状态. 执行git reset HEAD filename取消暂存, 文件状态为Modified</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git status [filename]  <span class="comment">#查看指定文件状态</span></span><br><span class="line">git status  <span class="comment">#查看所有文件状态</span></span><br></pre></td></tr></table></figure><p>一般在IDE中查看即可。</p><h3 id="添加文件"><a href="#添加文件" class="headerlink" title="添加文件"></a>添加文件</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git add fileName  <span class="comment">#指定文件</span></span><br><span class="line">git add . <span class="comment">#所有</span></span><br></pre></td></tr></table></figure><p>将工作区的文件添加到暂存区</p><h3 id="提交文件"><a href="#提交文件" class="headerlink" title="提交文件"></a>提交文件</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit -m <span class="string">&#x27;commit message&#x27;</span> [ fileName ]</span><br></pre></td></tr></table></figure><p>将暂存区内容提交到本地库</p><h3 id="删除文件"><a href="#删除文件" class="headerlink" title="删除文件"></a>删除文件</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git rm 文件名  <span class="comment"># 删除缓存区的该文件</span></span><br><span class="line">git commit -m<span class="string">&quot;注释&quot;</span>  <span class="comment"># 将仓库文件删除</span></span><br></pre></td></tr></table></figure><h3 id="查看历史记录"><a href="#查看历史记录" class="headerlink" title="查看历史记录"></a>查看历史记录</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">log</span> </span><br><span class="line">git reflog  <span class="comment"># 常用</span></span><br><span class="line">git <span class="built_in">log</span> --greph <span class="comment"># 图形显示,更直观</span></span><br><span class="line">git <span class="built_in">log</span> --pretty=oneline <span class="comment"># 漂亮一行显示(建议)</span></span><br><span class="line">git <span class="built_in">log</span> --oneline <span class="comment"># 简洁显示</span></span><br></pre></td></tr></table></figure><p>HEAD@{移动到当前版本需要多少步}</p><h3 id="前进后退"><a href="#前进后退" class="headerlink" title="前进后退"></a>前进后退</h3><p>基于索引值（推荐）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git reset --hard [ commit id ]</span><br><span class="line">git reset --hard a6ace91 <span class="comment">#回到这个状态</span></span><br></pre></td></tr></table></figure><p>使用 <strong>^</strong> 符号（只能后退）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset --hard HEAD^  <span class="comment"># 几个 ^ 表示后退几步</span></span><br></pre></td></tr></table></figure><p>使用 <strong>~</strong> 符号（只能后退）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset --hard HEAD~n  <span class="comment"># 后退几步</span></span><br></pre></td></tr></table></figure><p>soft: </p><ul><li>仅本地库移动HEAD 指针 </li></ul><p>mixed:</p><ul><li>在本地库移动HEAD指针</li><li>重置暂存区</li></ul><p>hard:</p><ul><li>在本地库移动HEAD指针</li><li>重置暂存区</li><li>重置工作区</li></ul><h3 id="文件差异比较"><a href="#文件差异比较" class="headerlink" title="文件差异比较"></a>文件差异比较</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git diff 文件名</span><br><span class="line">git diff 哈希值 文件名  <span class="comment"># 和历史中的一个版本比较</span></span><br><span class="line">git diff  <span class="comment"># 不带文件名，则比较多个文件</span></span><br></pre></td></tr></table></figure><h3 id="忽略文件"><a href="#忽略文件" class="headerlink" title="忽略文件"></a>忽略文件</h3><p>不想把某些文件纳入版本控制中时，可以在主目录下建立”.gitignore”文件。</p><ol><li>忽略文件中的空行或以井号（#）开始的行将会被忽略。</li><li>可以使用Linux通配符。例如：星号（*）代表任意多个字符，问号（？）代表一个字符，方括号（[abc]）代表可选字符范围，大括号（{string1,string2,…}）代表可选的字符串等。</li><li>如果名称的最前面有一个感叹号（!），表示例外规则，将不被忽略。</li><li>如果名称的最前面是一个路径分隔符（/），表示要忽略的文件在此目录下，而子目录中的文件不忽略。</li><li>如果名称的最后面是一个路径分隔符（/），表示要忽略的是此目录下该名称的子目录，而非文件（默认文件或目录都忽略）。</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">*.txt        <span class="comment">#忽略所有 .txt结尾的文件,这样的话上传就不会被选中！</span></span><br><span class="line">!lib.txt     <span class="comment">#但lib.txt除外</span></span><br><span class="line">/temp        <span class="comment">#仅忽略项目根目录下的TODO文件,不包括其它目录temp</span></span><br><span class="line">build/       <span class="comment">#忽略build/目录下的所有文件</span></span><br><span class="line">doc/*.txt    <span class="comment">#会忽略 doc/notes.txt 但不包括 doc/server/arch.txt</span></span><br></pre></td></tr></table></figure><p>一般可以使用JetBrain中的插件.ignore来生成。</p><h2 id="分支管理"><a href="#分支管理" class="headerlink" title="分支管理"></a>分支管理</h2><h3 id="分支的好处"><a href="#分支的好处" class="headerlink" title="分支的好处"></a>分支的好处</h3><ul><li>同时并行推进多个功能开发，提高开发效率</li><li>某一分支开发失败，不会对其它分支有任何影响</li></ul><p>master主分支应该非常稳定，用来发布新版本，一般情况下不允许在上面工作，工作一般情况下在新建的dev分支上工作，工作完后，比如上要发布，或者说dev分支代码稳定后可以合并到主分支master上来。</p><h3 id="分支操作"><a href="#分支操作" class="headerlink" title="分支操作"></a>分支操作</h3><ul><li>创建分支</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch [branch]  <span class="comment"># 新建一个分支，但依然停留在当前分支</span></span><br></pre></td></tr></table></figure><ul><li>查看分支</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git branch  <span class="comment"># 列出所有本地分支</span></span><br><span class="line">git branch -v </span><br><span class="line">git branch -r  <span class="comment"># 列出所有远程分支</span></span><br></pre></td></tr></table></figure><ul><li>切换分支</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git checkout [branch]  <span class="comment"># 切换分支</span></span><br><span class="line">git checkout -b [branch]  <span class="comment"># 新建一个分支，并切换到该分支</span></span><br></pre></td></tr></table></figure><ul><li>合并分支<code>相当于把修改了的文件拉过来</code></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git merge [branch]  <span class="comment"># 合并指定分支到当前分支</span></span><br></pre></td></tr></table></figure><p>注意：在a分支里面修改后，要合并到master，就先切换到master，然后合并a。</p><ul><li>删除分支</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git branch -d [branch]  <span class="comment"># 删除分支，注意在删除分支时要退出该分支</span></span><br><span class="line"></span><br><span class="line">git push origin --delete [branch]</span><br><span class="line">git branch -dr [remote/branch]  <span class="comment"># 删除远程分支</span></span><br></pre></td></tr></table></figure><h3 id="解决冲突"><a href="#解决冲突" class="headerlink" title="解决冲突"></a>解决冲突</h3><ul><li>第一步：编辑，删除特殊标记<code>&lt;&lt;&lt;</code> <code>===</code></li><li>第二步：修改到满意为止，保存退出</li><li>第三步：添加到缓存区 <code>git add 文件名</code></li><li>第四步：提交到本地库 <code>git commit -m &#39;日志信息&#39;</code>  <code>注意：后面一定不能带文件名</code></li></ul><h2 id="Git-结合Github"><a href="#Git-结合Github" class="headerlink" title="Git 结合Github"></a>Git 结合Github</h2><h3 id="创建远程库地址别名"><a href="#创建远程库地址别名" class="headerlink" title="创建远程库地址别名"></a>创建远程库地址别名</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git remote -v  <span class="comment">#查看远程地址别名</span></span><br><span class="line">git remote add 别名 远程地址 </span><br><span class="line">demo：git remote add origin https://xx</span><br></pre></td></tr></table></figure><h3 id="推送"><a href="#推送" class="headerlink" title="推送"></a>推送</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git push 别名 分支名</span><br><span class="line">git push -u 别名 分支名    <span class="comment">#-u指定默认主机</span></span><br><span class="line">例子：git push origin master</span><br></pre></td></tr></table></figure><h3 id="克隆"><a href="#克隆" class="headerlink" title="克隆"></a>克隆</h3><p>完整的把远程库克隆到本地，克隆下来后不要在主分支里面做开发。clone进行一次，从无到有的过程，更新用pull。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span>  远程地址</span><br><span class="line">例子：git <span class="built_in">clone</span> https://xx</span><br></pre></td></tr></table></figure><h3 id="拉取"><a href="#拉取" class="headerlink" title="拉取"></a>拉取</h3><p>本地存在clone下来的文件 就用pull更新</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">pull = fetch + merge</span><br><span class="line">    git fetch 别名 分支名</span><br><span class="line">    git merge 别名 分支名</span><br><span class="line">git pull 别名 分支名</span><br></pre></td></tr></table></figure><h3 id="解决冲突-1"><a href="#解决冲突-1" class="headerlink" title="解决冲突"></a>解决冲突</h3><p>注意：解决冲突后的提交是不能带文件名的</p><p>如果不是基于远程库最新版做的修改不能推送，必须先pull下来安装冲突办法解决</p><h3 id="rebase"><a href="#rebase" class="headerlink" title="rebase"></a>rebase</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git rebase -i 索引号</span><br><span class="line">git rebase -i HEAD~3  <span class="comment">#合并最近三条记录</span></span><br><span class="line">说明：在vim编辑里面改成s</span><br></pre></td></tr></table></figure><h3 id="beyond-compare"><a href="#beyond-compare" class="headerlink" title="beyond compare"></a>beyond compare</h3><p>用软件解决冲突</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1.安装 ：</span><br><span class="line">    beyond compare </span><br><span class="line">2.配置：</span><br><span class="line">    git config --<span class="built_in">local</span> merge.tool bc3  <span class="comment">#合并名称</span></span><br><span class="line">    git config --<span class="built_in">local</span> mergetool.path <span class="string">&#x27;/usr/local/bin/bcomp&#x27;</span> <span class="comment">#软件路径</span></span><br><span class="line">    git config --<span class="built_in">local</span> mergetool.keepBackup <span class="literal">false</span>  <span class="comment">#False不用保存备份</span></span><br><span class="line">3.应用：</span><br><span class="line">    git mergetool</span><br><span class="line">说明：--<span class="built_in">local</span>指只在当前操作系统有效</span><br></pre></td></tr></table></figure><h3 id="跨团队合作"><a href="#跨团队合作" class="headerlink" title="跨团队合作"></a>跨团队合作</h3><p>代码review之后合并</p><ul><li><p><strong>适用于个人</strong></p><p><strong>邀请成员</strong>:<code>Settings</code> –&gt; <code>Collaborators</code> –&gt;<code>填写用户名</code> –&gt;<code>打开链接接受邀请</code></p></li><li><p><strong>企业</strong> <code>创建一个组织</code> <code>方便管理</code></p></li><li><p><strong>review</strong></p><p><code>组织做review</code> <code>通过Pull request</code></p></li><li><p><strong>给开源社区共享代码</strong></p><p><code>点击别人仓库的fork 到自己的仓库</code> – &gt; <code>然后clone下来 修改后推送到远程库</code> –&gt; <code>点击Pull Request请求</code> –&gt; <code>Create pull request发消息</code></p></li></ul><h3 id="Tag标签"><a href="#Tag标签" class="headerlink" title="Tag标签"></a>Tag标签</h3><p>为了清晰的版本管理，公司一般不会直接使用commit提交</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">git tag -a v1.0 -m <span class="string">&#x27;版本介绍&#x27;</span>   <span class="comment">#创建本地tag信息</span></span><br><span class="line">git tag -d v1.0         <span class="comment">#删除tag</span></span><br><span class="line">git push origin --tags   <span class="comment">#将本地tag信息推送到远程库</span></span><br><span class="line">git pull origin --tags    <span class="comment">#拉取到本地</span></span><br><span class="line"></span><br><span class="line">git checkout v.10    <span class="comment">#切换tag</span></span><br><span class="line">git <span class="built_in">clone</span> -b v0.1 地址   <span class="comment">#指定tag下载代码</span></span><br></pre></td></tr></table></figure><h3 id="SSH-免密登录"><a href="#SSH-免密登录" class="headerlink" title="SSH 免密登录"></a>SSH 免密登录</h3><ul><li>输入<code>ssh-keygen -t rsa -C GitHub邮箱地址</code></li><li>进入<code>.ssh</code>目录，复制<code>id_rsa.pub</code>文件内容</li><li>登录GitHub。<code>Settings</code>  –&gt; <code>SSH and GPG keys</code> –&gt; <code>New SSH Key</code></li><li>回到git通过ssh地址创建。<code>git remote add 别名 SSH地址</code></li></ul>]]></content>
      
      
      <categories>
          
          <category> Git基础 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Git基础Part1</title>
      <link href="/2021/03/Git%E5%9F%BA%E7%A1%80Part1/"/>
      <url>/2021/03/Git%E5%9F%BA%E7%A1%80Part1/</url>
      
        <content type="html"><![CDATA[<h1 id="Git基础Part1——概述"><a href="#Git基础Part1——概述" class="headerlink" title="Git基础Part1——概述"></a>Git基础Part1——概述</h1><p>[TOC]</p><h2 id="版本控制"><a href="#版本控制" class="headerlink" title="版本控制"></a>版本控制</h2><p>版本控制（Revision control）是一种在开发的过程中用于管理我们对文件、目录或工程等内容的修改历史，方便查看更改历史记录，备份以便恢复以前的版本的软件工程技术。</p><ul><li>实现跨区域多人协同开发</li><li>追踪和记载一个或者多个文件的历史记录</li><li>组织和保护你的源代码和文档</li><li>统计工作量</li><li>并行开发、提高开发效率</li><li>跟踪记录整个软件的开发过程</li><li>减轻开发人员的负担，节省时间，同时降低人为错误</li></ul><p>没有进行版本控制或者版本控制本身缺乏正确的流程管理，在软件开发过程中将会引入很多问题，如软件代码的一致性、软件内容的冗余、软件过程的事物性、软件开发过程中的并发性、软件源代码的安全性，以及软件的整合等问题。</p><h2 id="常见的版本控制工具"><a href="#常见的版本控制工具" class="headerlink" title="常见的版本控制工具"></a>常见的版本控制工具</h2><ul><li><strong>Git</strong></li><li><strong>SVN</strong>（Subversion）</li><li><strong>CVS</strong>（Concurrent Versions System）</li><li><strong>VSS</strong>（Micorosoft Visual SourceSafe）</li><li><strong>TFS</strong>（Team Foundation Server）</li></ul><p>现在影响力最大且使用最广泛的是Git与SVN。</p><h2 id="版本控制分类"><a href="#版本控制分类" class="headerlink" title="版本控制分类"></a>版本控制分类</h2><p><strong>1、本地版本控制</strong></p><p>记录文件每次的更新，可以对每个版本做一个快照，或是记录补丁文件，适合个人用，如RCS。</p><p><strong>2、集中版本控制 SVN</strong></p><p>所有的版本数据都保存在服务器上，协同开发者从服务器上同步更新或上传自己的修改。</p><p>所有的版本数据都存在服务器上，用户的本地只有自己以前所同步的版本，如果不连网的话，用户就看不到历史版本，也无法切换版本验证问题，或在不同分支工作。而且，所有数据都保存在单一的服务器上，有很大的风险这个服务器会损坏，这样就会丢失所有的数据，当然可以定期备份。代表产品：SVN、CVS、VSS</p><p><strong>3、分布式版本控制 Git</strong></p><p>所有版本信息仓库全部同步到本地的每个用户，这样就可以在本地查看所有版本历史，可以离线在本地提交，只需在连网时push到相应的服务器或其他用户那里。</p><p>每个人都拥有全部的代码，是安全隐患！由于每个用户那里保存的都是所有的版本数据，只要有一个用户的设备没有问题就可以恢复所有的数据，但这增加了本地存储空间的占用。</p><h2 id="Git工作流程"><a href="#Git工作流程" class="headerlink" title="Git工作流程"></a>Git工作流程</h2><ol><li>从远程仓库中克隆 Git 资源作为本地仓库。</li><li>从本地仓库中checkout代码然后进行代码修改</li><li>在提交前先将代码提交到暂存区。</li><li>提交修改。提交到本地仓库。本地仓库中保存修改的各个历史版本。</li><li>在修改完成后，需要和团队成员共享代码时，可以将代码push到远程仓库。</li></ol><img src="/2021/03/Git%E5%9F%BA%E7%A1%80Part1/image-20210314153241990.png" alt="image-20210314153241990" style="zoom:150%;"><h2 id="git原理"><a href="#git原理" class="headerlink" title="git原理"></a>git原理</h2><p>Git 底层采用的是 SHA-1 算法。 哈希算法可以被用来验证文件。</p><ol><li>不管输入数据的数据量有多大，输入同一个哈希算法，得到的加密结果长度固定。 </li><li>哈希算法确定，输入数据确定，输出数据能够保证不变 </li><li>哈希算法确定，输入数据有变化，输出数据一定有变化，而且通常变化很大 </li><li>哈希算法不可逆</li></ol><p>Git 把数据看作是小型文件系统的一组快照。每次提交更新时 Git 都会对当前的全部文件制作一个快照并保存这个快照的索引。为了高效，如果文件没有修改，Git 不再重新存储该文件，而是只保留一个链接指向之前存储的文件。所以 Git 的工作方式可以称之为快照流。</p><h2 id="fork与git-clone的区别"><a href="#fork与git-clone的区别" class="headerlink" title="fork与git clone的区别"></a>fork与git clone的区别</h2><p>1.区别</p><p>git clone 是在自己电脑直接敲命令，结果是将github仓库中的项目克隆到自己本地电脑中。</p><p>fork是直接访问github网站，在项目页面中点击fork，然后自己github项目中就会多出一个复制的项目。</p><p>2.用法</p><p>如果我们想要修改他人github项目的话，我们直接git clone代码到本地是不能pull的，所以我们使用fork，先把代码复制到自己的github仓库，然后git clone到本地修改，然后在提交pull（这里的pull是pull到自己github仓库了，我们自己的github仓库中的代码是fork源的一个分支），这时候我们想要把修改的代码提交给他人的话，就可以在自己github上pull，等其他人看到后就可以把代码做一个合并。</p>]]></content>
      
      
      <categories>
          
          <category> Git基础 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Linux基础-完结目录</title>
      <link href="/2021/03/Linux%E5%9F%BA%E7%A1%80-%E5%AE%8C%E7%BB%93%E7%9B%AE%E5%BD%95/"/>
      <url>/2021/03/Linux%E5%9F%BA%E7%A1%80-%E5%AE%8C%E7%BB%93%E7%9B%AE%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<h1 id="Linux基础-完结目录"><a href="#Linux基础-完结目录" class="headerlink" title="Linux基础-完结目录"></a>Linux基础-完结目录</h1><p>教程视频传送门：</p><ol><li><a href="https://www.bilibili.com/video/BV1dW411M7xL?from=search&seid=2409244161150482317">尚硅谷Linux教程(千万级学习人次，linux最新升级版)</a></li><li><a href="https://www.bilibili.com/video/BV187411y7hF?from=search&seid=7370772631947777047">【狂神说Java】Linux最通俗易懂的教程阿里云真实环境学习</a></li><li><a href="https://www.runoob.com/linux/linux-tutorial.html">Linux 教程</a></li></ol><p>狂神的比较精简，使用上差不多足够，与菜鸟教程的文本大多相同。尚硅谷的更全。</p><table><thead><tr><th align="center"><a href="/2021/03/Linux%E5%9F%BA%E7%A1%80Part1/">Part1——概述</a></th></tr></thead><tbody><tr><td align="center"><strong><a href="/2021/03/Linux%E5%9F%BA%E7%A1%80Part2/">Part2——基本命令</a></strong></td></tr><tr><td align="center"><strong><a href="/2021/03/Linux%E5%9F%BA%E7%A1%80Part3/">Part3——VIM使用</a></strong></td></tr><tr><td align="center"><strong><a href="/2021/03/Linux%E5%9F%BA%E7%A1%80Part4/">Part4——用户和用户组</a></strong></td></tr><tr><td align="center"><strong><a href="/2021/03/Linux%E5%9F%BA%E7%A1%80Part5/">Part5——系统管理</a></strong></td></tr><tr><td align="center"><strong><a href="/2021/03/Linux%E5%9F%BA%E7%A1%80Part6/">Part6——环境安装</a></strong></td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> Linux基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux基础Part6</title>
      <link href="/2021/03/Linux%E5%9F%BA%E7%A1%80Part6/"/>
      <url>/2021/03/Linux%E5%9F%BA%E7%A1%80Part6/</url>
      
        <content type="html"><![CDATA[<h1 id="Linux基础Part6——环境安装"><a href="#Linux基础Part6——环境安装" class="headerlink" title="Linux基础Part6——环境安装"></a>Linux基础Part6——环境安装</h1><p>[TOC]</p><h2 id="环境安装"><a href="#环境安装" class="headerlink" title="环境安装"></a>环境安装</h2><p>一般有三种方式：</p><ol><li>rpm</li><li>yum</li><li>解压缩</li></ol><h2 id="RPM-Redhat-Package-Manager"><a href="#RPM-Redhat-Package-Manager" class="headerlink" title="RPM(Redhat Package Manager)"></a>RPM(Redhat Package Manager)</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">rpm –qa | grep xx  <span class="comment"># 查询安装列表</span></span><br><span class="line">rpm -qi 软件包名  <span class="comment"># 查询软件包信息</span></span><br><span class="line">rpm -qf 文件全路径名  <span class="comment"># 查询文件所属的软件包</span></span><br><span class="line">rpm -e [ --nodeps ] 包名  <span class="comment"># rpm包卸载</span></span><br><span class="line">rpm -ivh RPM 包全路径名称</span><br><span class="line">rpm -ivh 包名  <span class="comment"># 安装</span></span><br></pre></td></tr></table></figure><blockquote><p>使用rpm安装jdk不需要配置环境变量，只需要重启就好了</p></blockquote><h2 id="YUM"><a href="#YUM" class="headerlink" title="YUM"></a>YUM</h2><p>Yum 是一个 Shell 前端软件包管理器。基于 RPM 包管理，能够从指定的服务器自动下载 RPM 包并且安装，可以自动处理依赖性关系，并且一次安装所有依赖的软件包。使用 yum 的前提是可以联网。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum [ options ] [ <span class="built_in">command</span> ] [ package ... ]</span><br></pre></td></tr></table></figure><ul><li>列出所有可更新的软件清单命令：<strong>yum check-update</strong> </li><li>更新所有软件命令：<strong>yum update</strong></li><li>仅安装指定的软件命令：<strong>yum install <package_name></package_name></strong></li><li>仅更新指定的软件命令：<strong>yum update <package_name></package_name></strong></li><li>列出所有可安裝的软件清单命令：<strong>yum list</strong></li><li>删除软件包命令：<strong>yum remove <package_name></package_name></strong></li><li>查找软件包命令：**yum search <key_word> **</key_word></li><li>清除缓存命令:<ul><li><strong>yum clean packages</strong>: 清除缓存目录下的软件包</li><li><strong>yum clean headers</strong>: 清除缓存目录下的 headers</li><li><strong>yum clean oldheaders</strong>: 清除缓存目录下旧的 headers</li><li><strong>yum clean, yum clean all (= yum clean packages; yum clean oldheaders)</strong> :清除缓存目录下的软件包及旧的 headers</li></ul></li><li>-y：自动确认所有提示</li></ul>]]></content>
      
      
      <categories>
          
          <category> Linux基础 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Linux基础Part5</title>
      <link href="/2021/03/Linux%E5%9F%BA%E7%A1%80Part5/"/>
      <url>/2021/03/Linux%E5%9F%BA%E7%A1%80Part5/</url>
      
        <content type="html"><![CDATA[<h1 id="Linux基础Part5——系统管理"><a href="#Linux基础Part5——系统管理" class="headerlink" title="Linux基础Part5——系统管理"></a>Linux基础Part5——系统管理</h1><p>[TOC]</p><h2 id="任务调度"><a href="#任务调度" class="headerlink" title="任务调度"></a>任务调度</h2><p>任务调度：是指系统在某个时间执行的特定的命令或程序。</p><ol><li><p>系统工作：有些重要的工作必须周而复始地执行。如病毒扫描等</p><p>设置任务调度文件：/etc/crontab</p></li><li><p>用户工作：个别用户可能希望执行某些程序，比如对 mysql 数据库的备份</p><p>执行 <code>crontab –e</code> 命令，输入任务到调度文件</p></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">crontab [ -erl ]</span><br><span class="line">service crond restart：[ 重启任务调度 ]</span><br></pre></td></tr></table></figure><ul><li>-e：编辑定时crontab任务</li><li>-l：查询crontab任务</li><li>-r：删除当前用户所有的crontab任务</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">*/1 * * * * ls –l /etc/ &gt; /tmp/to.txt  <span class="comment"># 每小时的每分钟执行 ls –l /etc/ &gt; /tmp/to.txt 命令</span></span><br></pre></td></tr></table></figure><ul><li>第1个*：一小时中的第几分钟。0~59。</li><li>第2个*：一天中的第几小时。0~23。</li><li>第3个*：一个月中的第几天。1~31。</li><li>第4个*：一年中的第几月。1~12。</li><li>第5个*：一周中的星期几。0~7。(0、7都表示周日)</li><li>*：代表任何时间</li><li>,：代表不连续的时间</li><li>-：代表连续的时间范围</li><li>*/n：代表每隔多久执行一次</li></ul><p>demo：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">先编写一个文件 /home/mytask1.sh</span><br><span class="line">date &gt;&gt; /tmp/mydate</span><br><span class="line">给 mytask1.sh 一个可以执行权限chmod 744 /home/mytask1.sh</span><br><span class="line">crontab -e</span><br><span class="line">*/1 * * * * /home/mytask1.sh</span><br><span class="line"></span><br><span class="line">[root@VM-1-14-centos ~]<span class="comment"># vim task1.sh  # 先编写一个shell脚本</span></span><br><span class="line">date &gt;&gt; /tmp/mydate</span><br><span class="line">[root@VM-1-14-centos ~]<span class="comment"># chmod 744 task1.sh  # 给脚本一个可执行权限</span></span><br><span class="line">[root@VM-1-14-centos ~]<span class="comment"># crontab -e  # 编辑任务</span></span><br><span class="line">*/1 * * * * /home/mytask1.sh</span><br><span class="line">[root@VM-1-14-centos ~]<span class="comment"># cd /tmp/</span></span><br><span class="line">[root@VM-1-14-centos tmp]<span class="comment"># cat mydate  # 查看输出</span></span><br><span class="line">Sat Mar 13 13:35:01 CST 2021</span><br><span class="line">Sat Mar 13 13:36:01 CST 2021</span><br><span class="line">Sat Mar 13 13:37:01 CST 2021</span><br></pre></td></tr></table></figure><h2 id="磁盘管理"><a href="#磁盘管理" class="headerlink" title="磁盘管理"></a>磁盘管理</h2><h3 id="分区基础知识"><a href="#分区基础知识" class="headerlink" title="分区基础知识"></a>分区基础知识</h3><p>分区的方式：</p><ol><li>mbr 分区:<ol><li>最多支持四个主分区</li><li>系统只能安装在主分区</li><li>扩展分区要占一个主分区</li><li>MBR 最大只支持 2TB，但拥有最好的兼容性</li></ol></li><li>gpt 分区:<ol><li>支持无限多个主分区（但操作系统可能限制，比如 windows 下最多 128 个分区）</li><li>最大支持 18EB 的大容量（1EB=1024 PB，1PB=1024 TB ）</li><li>windows7 64 位以后支持 gpt</li></ol></li></ol><h3 id="Linux分区"><a href="#Linux分区" class="headerlink" title="Linux分区"></a>Linux分区</h3><ol><li>原理：<ol><li>Linux 来说无论有几个分区，分给哪一目录使用，它归根结底就只有一个根目录，一个独立且唯一的文件结构 , Linux 中每个分区都是用来组成整个文件系统的一部分。</li><li>Linux 采用了一种叫“载入”的处理方法，它的整个文件系统中包含了一整套的文件和目录， 且将一个分区和一个目录联系起来。这时要载入的一个分区将使它的存储空间在一个目录下获得。</li></ol></li><li>硬盘说明：<ol><li>Linux 硬盘分 IDE 硬盘和 SCSI 硬盘，目前基本上是 SCSI 硬盘</li><li>对于 IDE 硬盘，驱动器标识符为“hdx<del>”,其中“hd”表明分区所在设备的类型，这里是指 IDE 硬盘了。“x”为盘号（a 为基本盘，b 为基本从属盘，c 为辅助主盘，d 为辅助从属盘）,“</del>”代表分区，前四个分区用数字 1 到 4 表示，它们是主分区或扩展分区，从 5 开始就是逻辑分区。例，hda3 表示为第一个 IDE 硬盘上的第三个主分区或扩展分区,hdb2 表示为第二个 IDE 硬盘上的第二个主分区或扩展分区。</li><li>对于 SCSI 硬盘则标识为“sdx~”，SCSI 硬盘是用“sd”来表示分区所在设备的类型的，其余则和 IDE 硬盘的表示方法一样</li></ol></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-1-14-centos tmp]<span class="comment"># lsblk  # 老色比裂开 查看系统分区和挂载情况</span></span><br><span class="line">NAME   MAJ:MIN RM  SIZE RO TYPE MOUNTPOINT</span><br><span class="line">sr0     11:0    1  111M  0 rom              <span class="comment"># 光驱</span></span><br><span class="line">vda    253:0    0   50G  0 disk             <span class="comment"># 硬盘</span></span><br><span class="line">└─vda1 253:1    0   50G  0 part /           <span class="comment"># 分区1</span></span><br><span class="line">[root@VM-1-14-centos tmp]<span class="comment"># lsblk -f</span></span><br><span class="line">NAME   FSTYPE  LABEL    UUID                                 MOUNTPOINT</span><br><span class="line">sr0    iso9660 config-2 2021-03-06-19-49-34-00               </span><br><span class="line">vda                                                          </span><br><span class="line">└─vda1 ext4             4b499d76-769a-40a0-93dc-4a31a59add28 /</span><br><span class="line"><span class="comment"># 分区名 分区类型          格式化产生的40位唯一标识分区id         挂载点</span></span><br></pre></td></tr></table></figure><h3 id="在虚拟机上挂载一块硬盘"><a href="#在虚拟机上挂载一块硬盘" class="headerlink" title="在虚拟机上挂载一块硬盘"></a>在虚拟机上挂载一块硬盘</h3><ol><li><p><strong>虚拟机添加硬盘</strong></p></li><li><p><strong>分区</strong> <code>fdisk /dev/sdb</code></p></li><li><p><strong>格式化</strong> <code>mkfs -t ext4 /dev/sdb1</code></p></li><li><p><strong>临时挂载</strong><br>先创建目录 <code>/home/newdisk</code><br>挂载指令：<code>mount /dev/sdb1 /home/newdisk</code><br>卸载指令：<code>umount 挂载目录或硬盘目录</code></p></li><li><p><strong>永久挂载</strong><br>修改设置：<code>vim /etc/fstab</code><br>添加一行：<code>/dev/sdb1 /home/newdisk ext4 defaults 0 0</code></p><p>生效：<code>mount -a</code></p></li></ol><h2 id="磁盘查询"><a href="#磁盘查询" class="headerlink" title="磁盘查询"></a>磁盘查询</h2><h3 id="df-：查询系统磁盘总体占用情况"><a href="#df-：查询系统磁盘总体占用情况" class="headerlink" title="df ：查询系统磁盘总体占用情况"></a>df ：查询系统磁盘总体占用情况</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df [ -ahikHTm ] [ 目录或文件名 ]</span><br></pre></td></tr></table></figure><ul><li>-a ：列出所有的文件系统，包括系统特有的 /proc 等文件系统</li><li>-h ：以人们较易阅读的 GBytes, MBytes, KBytes 等格式自行显示</li><li>-H ：以 M=1000K 取代 M=1024K 的进位方式</li><li>-T ：显示文件系统类型, 连同该 partition 的 filesystem 名称 (例如 ext3) 也列出</li><li>-i ：不用硬盘容量，而以 inode 的数量来显示</li><li>[ 目录或文件名 ]：指定挂载目录</li></ul><p>demo：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-1-14-centos tmp]<span class="comment"># df -h</span></span><br><span class="line">Filesystem      Size  Used Avail Use% Mounted on</span><br><span class="line">devtmpfs        3.9G     0  3.9G   0% /dev</span><br><span class="line">tmpfs           3.9G   24K  3.9G   1% /dev/shm</span><br><span class="line">tmpfs           3.9G  428K  3.9G   1% /run</span><br><span class="line">tmpfs           3.9G     0  3.9G   0% /sys/fs/cgroup</span><br><span class="line">/dev/vda1        50G  3.3G   44G   8% /</span><br><span class="line">tmpfs           783M     0  783M   0% /run/user/0</span><br></pre></td></tr></table></figure><h3 id="du：查询指定目录的磁盘占用情况"><a href="#du：查询指定目录的磁盘占用情况" class="headerlink" title="du：查询指定目录的磁盘占用情况"></a>du：查询指定目录的磁盘占用情况</h3><p>与 df 不一样的是，du 这个命令会直接到文件系统内去搜寻所有的文件数据。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">du [ -ahskm ] 文件或目录名称</span><br></pre></td></tr></table></figure><ul><li>-a ：列出所有的文件与目录容量，因为默认仅统计目录底下的文件夹而已</li><li>-h ：以人们较易读的容量格式 (G/M) 显示</li><li>-s ：列出总量而已，而不列出每个各别的目录占用容量</li><li>-S ：不包括子目录下的总计，与 -s 有点差别</li><li>–max-depth=1 子目录深度</li></ul><p>demo：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-1-14-centos tmp]<span class="comment"># du -h  # 默认为当前目录下文件夹(包含隐藏文件夹)的磁盘占用情况</span></span><br><span class="line">4.0K./.XIM-unix</span><br><span class="line">4.0K./.font-unix</span><br><span class="line">4.0K./.X11-unix</span><br><span class="line">4.0K./systemd-private-93e24fc7bc744033a007e9d37393f18d-ntpd.service-qBqeOq/tmp</span><br><span class="line">8.0K./systemd-private-93e24fc7bc744033a007e9d37393f18d-ntpd.service-qBqeOq</span><br><span class="line">4.0K./.ICE-unix</span><br><span class="line">13M./d0ba2854fb7784799d5cfe6838f4f3a6</span><br><span class="line">4.0K./.Test-unix</span><br><span class="line">13M.                              <span class="comment"># 当前目录下文件夹的总量</span></span><br><span class="line">[root@VM-1-14-centos tmp]<span class="comment"># du -ach</span></span><br><span class="line">4.0K./virtio_blk_affinity.log</span><br><span class="line">4.0K./.XIM-unix</span><br><span class="line">......</span><br><span class="line">4.0K./.Test-unix</span><br><span class="line">13M.</span><br><span class="line">13Mtotal</span><br></pre></td></tr></table></figure><h3 id="实用指令"><a href="#实用指令" class="headerlink" title="实用指令"></a>实用指令</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-1-14-centos ~]<span class="comment"># ls -l | grep &quot;^d&quot; | wc -l  # 统计当前目录下文件夹数量</span></span><br><span class="line">2</span><br><span class="line">[root@VM-1-14-centos ~]<span class="comment"># ls -l | grep &quot;^-&quot; | wc -l  # 统计当前目录下文件数量</span></span><br><span class="line">5</span><br><span class="line">[root@VM-1-14-centos ~]<span class="comment"># ls -lr | grep &quot;^-&quot; | wc -l  # 递归统计当前目录下文件数量</span></span><br><span class="line">5</span><br><span class="line">[root@VM-1-14-centos ~]<span class="comment"># yum install tree  # 安装tree</span></span><br><span class="line">[root@VM-1-14-centos ~]<span class="comment"># tree /  # 以树状显示目录结构</span></span><br></pre></td></tr></table></figure><h2 id="网络配置"><a href="#网络配置" class="headerlink" title="网络配置"></a>网络配置</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-1-14-centos ~]<span class="comment"># ifconfig  # 显示或设置网络设备</span></span><br><span class="line">[root@VM-1-14-centos ~]<span class="comment"># ping www.baidu.com  # 测试网络连通</span></span><br></pre></td></tr></table></figure><p><a href="https://www.bilibili.com/video/BV1dW411M7xL?p=46&spm_id_from=pageDriver">主要是虚拟机用</a></p><h2 id="线程管理"><a href="#线程管理" class="headerlink" title="线程管理"></a>线程管理</h2><h3 id="进程的基本介绍"><a href="#进程的基本介绍" class="headerlink" title="进程的基本介绍"></a>进程的基本介绍</h3><ol><li>在 LINUX 中，每个执行的程序（代码）都称为一个进程。每一个进程都分配一个 ID 号（进程号PID）。</li><li>每一个进程，都会对应一个父进程（父进程号PPID），而这个父进程可以复制多个子进程例如 www 服务器。</li><li>每个进程都可能以两种方式存在的。前台与后台，所谓前台进程就是用户目前的屏幕上可以进行操作的。后台进程（守护进程）则是实际在操作，但屏幕上无法看到的进程。</li><li>一般系统的服务都是以后台进程的方式存在，而且都会常驻在系统中，直到关机才才结束。</li></ol><h3 id="查看进程"><a href="#查看进程" class="headerlink" title="查看进程"></a>查看进程</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps [ -aux ]</span><br></pre></td></tr></table></figure><ul><li>-a：显示当前终端所有进程信息</li><li>-u：以用户的格式显示进程</li><li>-x：显示后台进程运行的参数</li><li>-e：显示所有进程</li><li>-f：全格式</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-1-14-centos ~]<span class="comment"># ps -aux | grep xxx  # 查看是否有xxx进程</span></span><br><span class="line">root     16906  0.0  0.0 112812   972 pts/0    S+   19:19   0:00 grep --color=auto xxx</span><br><span class="line">[root@VM-1-14-centos ~]<span class="comment"># ps -aux</span></span><br><span class="line">USER       PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND</span><br><span class="line">root         1  0.0  0.0 191036  4036 ?        Ss   Mar06   0:59 /usr/lib/systemd/systemd --switched-root --system --dese</span><br><span class="line">......</span><br><span class="line">[root@VM-1-14-centos ~]<span class="comment"># ps -ef</span></span><br><span class="line">UID        PID  PPID  C STIME TTY          TIME CMD</span><br><span class="line">root         1     0  0 Mar06 ?        00:01:00 /usr/lib/systemd/systemd --switched-root --system --deserialize 22</span><br><span class="line">......</span><br></pre></td></tr></table></figure><ul><li><p>USER：用户名称</p></li><li><p>PID：进程号</p></li><li><p>%CPU：进程占用 CPU 的百分比</p></li><li><p>%MEM：进程占用物理内存的百分比</p></li><li><p>VSZ：进程占用的虚拟内存大小（单位：KB）</p></li><li><p>RSS：进程占用的物理内存大小（单位：KB）</p></li><li><p>TTY：终端名称</p></li><li><p>STAT：进程状态，其中 S-睡眠，s-表示该进程是会话的先导进程，N-表示进程拥有比普通优先级更低的优先级，R-正在运行，D-短期等待，Z-僵死进程，T-被跟踪或者被停止等等</p></li><li><p>START：进程的启动时间</p></li><li><p>TIME：CPU 时间，即进程使用 CPU 的总时间</p></li><li><p>COMMAND：启动进程所用的命令和参数，如果过长会被截断显示</p></li><li><p>C：CPU 用于计算执行优先级的因子。数值越大，表明进程是 CPU 密集型运算，执行优先级会降低；数值越小，表明进程是 I/O 密集型运算，执行优先级会提高</p></li><li><p>STIME：进程启动的时间</p></li><li><p>TTY：完整的终端名称</p></li><li><p>TIME：CPU 时间</p></li><li><p>CMD：启动进程所用的命令和参数</p></li></ul><h3 id="结束进程"><a href="#结束进程" class="headerlink" title="结束进程"></a>结束进程</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">kill</span> [ -9 ] 进程号</span><br><span class="line">killall 进程名</span><br></pre></td></tr></table></figure><ul><li>9：强制终止</li></ul><p>demo：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-1-14-centos ~]<span class="comment"># kill 1590  # 结束/usr/sbin/sshd进程，终止远程登录服务</span></span><br><span class="line">[root@VM-1-14-centos ~]<span class="comment"># killall gedit  # 结束所有gedit进程</span></span><br></pre></td></tr></table></figure><h3 id="进程树"><a href="#进程树" class="headerlink" title="进程树"></a>进程树</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pstree [ -pu ]</span><br></pre></td></tr></table></figure><ul><li>-p :显示进程的 PID</li><li>-u :显示进程的所属用户</li></ul><h3 id="服务（守护进程）管理"><a href="#服务（守护进程）管理" class="headerlink" title="服务（守护进程）管理"></a>服务（守护进程）管理</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">service 服务名 [ start | stop | restart | reload | status ]</span><br></pre></td></tr></table></figure><h3 id="查看服务列表"><a href="#查看服务列表" class="headerlink" title="查看服务列表"></a>查看服务列表</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls -l /etc/init.d/</span><br></pre></td></tr></table></figure><h3 id="chkconfig指令"><a href="#chkconfig指令" class="headerlink" title="chkconfig指令"></a>chkconfig指令</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">chkconfig --list | grep 服务名</span><br><span class="line">chkconfig --level n 服务名 on/off</span><br></pre></td></tr></table></figure><p>demo：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#  案例 1： 请显示当前系统所有服务的各个运行级别的运行状态</span></span><br><span class="line">chkconfig --list</span><br><span class="line"><span class="comment">#  案例 2 ：请查看 sshd 服务的运行状态</span></span><br><span class="line">service sshd status</span><br><span class="line"><span class="comment">#  案例 3： 将 sshd 服务在运行级别 5 下设置为不自动启动</span></span><br><span class="line">chkconfig --level 5 sshd off</span><br><span class="line"><span class="comment">#  案例 4： 当运行级别为 5 时，关闭防火墙。</span></span><br><span class="line">chkconfig --level 5 iptables off</span><br><span class="line"><span class="comment">#  案例 5： 在所有运行级别下，关闭防火墙</span></span><br><span class="line">chkconfig iptables off</span><br><span class="line"><span class="comment">#  案例 6： 在所有运行级别下，开启防火墙</span></span><br><span class="line">chkconfig iptables on</span><br></pre></td></tr></table></figure><h3 id="动态监控进程"><a href="#动态监控进程" class="headerlink" title="动态监控进程"></a>动态监控进程</h3><p>top 与 ps 命令很相似，都用来显示正在执行的进程。但不同在于 top 在执行一段时间可以更新正在运行的的进程。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">top [ -dip ]</span><br></pre></td></tr></table></figure><ul><li>-d：秒数，指定top命令间隔多少秒更新，默认3秒</li><li>-i：使top不显示闲置或僵死进程</li><li>-p：通过指定进程PID来显示相应进程状态</li></ul><p>交互操作：</p><ul><li>P：以CPU使用率排序（默认此项）</li><li>M：以内存使用率来排序</li><li>N：以PID排序</li><li>q：退出top</li><li>k：杀死进程</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">top - 21:15:35 up 7 days,  1:25,  1 user,  load average: 0.00, 0.02, 0.05        <span class="comment"># 当前时间 运行时间 登录用户数 负载均衡</span></span><br><span class="line">Tasks:  93 total,   2 running,  91 sleeping,   0 stopped,   0 zombie</span><br><span class="line">%Cpu(s):  0.3 us,  0.2 sy,  0.0 ni, 99.5 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st  <span class="comment"># cpu使用情况</span></span><br><span class="line">KiB Mem :  8009084 total,  5870600 free,   217104 used,  1921380 buff/cache      <span class="comment"># 内存使用情况</span></span><br><span class="line">KiB Swap:        0 total,        0 free,        0 used.  7481244 avail Mem </span><br><span class="line"></span><br><span class="line">  PID USER      PR  NI    VIRT    RES    SHR S  %CPU %MEM     TIME+ COMMAND                                             </span><br><span class="line"> 7164 root      20   0  161996   2176   1552 R   0.3  0.0   0:00.16 top                                                 </span><br><span class="line">24146 root      20   0  160712   9412   2020 S   0.3  0.1   4:59.89 barad_agent                                         </span><br><span class="line">24147 root      20   0  607352  15888   2200 S   0.3  0.2  25:44.34 barad_agent  </span><br><span class="line">......</span><br></pre></td></tr></table></figure><h3 id="查看网络状态"><a href="#查看网络状态" class="headerlink" title="查看网络状态"></a>查看网络状态</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netstat [ -anp ]</span><br></pre></td></tr></table></figure><ul><li>-an 按一定顺序排列输出</li><li>-p 显示哪个进程在调用</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-1-14-centos ~]<span class="comment"># netstat -anp | grep sshd</span></span><br><span class="line">tcp        0      0 0.0.0.0:22              0.0.0.0:*               LISTEN      1590/sshd           </span><br><span class="line">tcp        0     52 172.17.1.14:22          114.222.3.200:9702      ESTABLISHED 4553/sshd: root@pts </span><br><span class="line">unix  3      [ ]         STREAM     CONNECTED     17005    1590/sshd            </span><br><span class="line">unix  2      [ ]         DGRAM                    11566495 4553/sshd: root@pts  </span><br></pre></td></tr></table></figure><h2 id="指定运行级别"><a href="#指定运行级别" class="headerlink" title="指定运行级别"></a>指定运行级别</h2><p>运行级别说明：</p><ol start="0"><li>关机</li><li>单用户(在实体机上开机时进入单用户模式，找回root密码)</li><li>多用户无网络</li><li>多用户有网络</li><li>保留级别</li><li>图形界面</li><li>系统重启</li></ol><p>修改默认运行级别可以修改文件 <code>/etc/inittab</code> 中的 <code>id:5:initdefault: </code></p><p>或者使用命令：<code>init [ 0123456 ]</code></p><p>开机流程：</p><ol><li>开机</li><li>BIOS</li><li>/boot</li><li>init进程1</li><li>运行级别</li><li>运行级别对应的服务</li></ol>]]></content>
      
      
      <categories>
          
          <category> Linux基础 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Linux基础Part4</title>
      <link href="/2021/03/Linux%E5%9F%BA%E7%A1%80Part4/"/>
      <url>/2021/03/Linux%E5%9F%BA%E7%A1%80Part4/</url>
      
        <content type="html"><![CDATA[<h1 id="Linux基础Part4——用户和用户组"><a href="#Linux基础Part4——用户和用户组" class="headerlink" title="Linux基础Part4——用户和用户组"></a>Linux基础Part4——用户和用户组</h1><p>[TOC]</p><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>Linux系统是一个多用户多任务的分时操作系统，任何一个要使用系统资源的用户，都必须首先向系统管理员申请一个账号，然后以这个账号的身份进入系统。</p><p>用户的账号一方面可以帮助系统管理员对使用系统的用户进行跟踪，并控制他们对系统资源的访问；另一方面也可以帮助用户组织文件，并为用户提供安全性保护。</p><p>每个用户账号都拥有一个唯一的用户名和各自的口令。</p><p>用户在登录时键入正确的用户名和口令后，就能够进入系统和自己的主目录。</p><p>实现用户账号的管理，要完成的工作主要有如下几个方面：</p><ul><li>用户账号的添加、删除与修改。</li><li>用户口令的管理。</li><li>用户组的管理。</li></ul><h2 id="用户管理"><a href="#用户管理" class="headerlink" title="用户管理"></a>用户管理</h2><h3 id="添加用户"><a href="#添加用户" class="headerlink" title="添加用户"></a>添加用户</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">useradd [ -cdgGsu ] 用户名</span><br></pre></td></tr></table></figure><ul><li>-c comment 指定一段注释性描述</li><li>-d 目录 指定用户主目录，如果此目录不存在，则一并创建</li><li>-g 用户组 指定用户所属的用户组 <code>useradd -g group user</code></li><li>-G 用户组，用户组 指定用户所属的附加组(SentOS每个用户只有一个附加组)</li><li>-s Shell文件 指定用户的登录Shell</li><li>-u 用户号 指定用户的用户号，如果同时有-o选项，则可以重复使用其他用户的标识号</li></ul><p>如果不使用参数，则默认在 /home 新建一个  /home/用户名 ，注意不要提前自己新建目录，因为还需要生成一系列隐藏文件。</p><h3 id="口令管理"><a href="#口令管理" class="headerlink" title="口令管理"></a>口令管理</h3><p>用户账号刚创建时没有口令，被系统锁定，无法使用，必须为其指定口令后才可以使用，即使是指定空口令。</p><p>指定和修改用户口令的Shell命令是<code>passwd</code>。超级用户可以为自己和其他用户指定口令，普通用户只能用它修改自己的口令。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">passwd [ -ludf ] 用户名</span><br></pre></td></tr></table></figure><ul><li>-l 锁定口令，即禁用账号</li><li>-u 口令解锁</li><li>-d 使账号无口令</li><li>-f 强迫用户下次登录时修改口令</li></ul><p>如果默认用户名，则修改当前用户的口令</p><p>普通用户修改自己的口令时，要求先输入原口令；而超级用户为用户指定口令时，就不需要原口令。</p><h3 id="删除用户"><a href="#删除用户" class="headerlink" title="删除用户"></a>删除用户</h3><p>如果一个用户的账号不再使用，可以从系统中删除。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">userdel [ -r ] 用户名</span><br></pre></td></tr></table></figure><ul><li> -r 把用户相关文件一起删除，包括用户在系统文件中（主要是/etc/passwd, /etc/shadow, /etc/group等）的记录，同时删除用户的主目录。</li></ul><p>一般公司员工离职会删除用户但保存家目录，因为其贡献的代码都在家目录中。</p><h3 id="修改用户"><a href="#修改用户" class="headerlink" title="修改用户"></a>修改用户</h3><p>修改用户账号就是根据实际情况更改用户的有关属性，如用户号、主目录、用户组、登录Shell等。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">usermod [ -cdgGsu ] 用户名</span><br></pre></td></tr></table></figure><p>常用的选项包括 -c, -d, -m, -g, -G, -s, -u, -o 等，这些选项的意义同 <code>useradd</code> ，可以为用户指定新的资源值。</p><p>另外，有些系统可以使用选项：-l 将原来的用户名改为新的用户名。</p><h3 id="查询用户"><a href="#查询用户" class="headerlink" title="查询用户"></a>查询用户</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">id 用户名</span><br></pre></td></tr></table></figure><p>demo：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-1-14-centos tt]<span class="comment"># id root</span></span><br><span class="line">uid=0(root) gid=0(root) groups=0(root)</span><br><span class="line">[root@VM-1-14-centos tt]<span class="comment"># id xu</span></span><br><span class="line">id: xu: no such user</span><br></pre></td></tr></table></figure><h3 id="切换用户"><a href="#切换用户" class="headerlink" title="切换用户"></a>切换用户</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">su 用户名</span><br></pre></td></tr></table></figure><p>高权限用户到低权限用户不需要输入密码，反之需要</p><p>可以通过 <code>exit</code> 返回原用户</p><h3 id="查看当前用户"><a href="#查看当前用户" class="headerlink" title="查看当前用户"></a>查看当前用户</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">whoami</span><br></pre></td></tr></table></figure><p>返回当前登录用户名</p><h2 id="用户组管理"><a href="#用户组管理" class="headerlink" title="用户组管理"></a>用户组管理</h2><p>每个用户都有一个用户组，系统可以对一个用户组中的所有用户进行集中管理。</p><p>组的增加、删除和修改实际上就是对/etc/group文件的更新。</p><h3 id="新增用户组"><a href="#新增用户组" class="headerlink" title="新增用户组"></a>新增用户组</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">groupadd [ -go ] 用户组</span><br></pre></td></tr></table></figure><ul><li>-g GID 指定新用户组的组标识号（GID）。</li><li>-o 一般与-g选项同时使用，表示新用户组的GID可以与系统已有用户组的GID相同。</li></ul><p>不指定GID则默认在当前已有的最大组标识号的基础上加1。</p><h3 id="删除用户组"><a href="#删除用户组" class="headerlink" title="删除用户组"></a>删除用户组</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">groupdel 用户组</span><br></pre></td></tr></table></figure><h3 id="修改用户组属性"><a href="#修改用户组属性" class="headerlink" title="修改用户组属性"></a>修改用户组属性</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">groupmod [ -gon ] 用户组</span><br></pre></td></tr></table></figure><ul><li>-g GID 为用户组指定新的组标识号。</li><li>-o 与-g选项同时使用，用户组的新GID可以与系统已有用户组的GID相同。</li><li>-n新用户组 将用户组的名字改为新名字</li></ul><p>demo；</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">groupmod –g 10000 -n group3 group2  <span class="comment"># 将组group2的标识号改为10000，组名修改为group3</span></span><br></pre></td></tr></table></figure><h3 id="切换用户组"><a href="#切换用户组" class="headerlink" title="切换用户组"></a>切换用户组</h3><p>如果一个用户同时属于多个用户组，那么用户可以在用户组之间切换，以便具有其他用户组的权限。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">newgrp 用户组</span><br></pre></td></tr></table></figure><h2 id="用户和用户组的系统文件"><a href="#用户和用户组的系统文件" class="headerlink" title="用户和用户组的系统文件"></a>用户和用户组的系统文件</h2><p>管理用户和用户组实际上都是对有关的系统文件进行修改，包括/etc/passwd, /etc/shadow, /etc/group等。</p><h3 id="etc-passwd"><a href="#etc-passwd" class="headerlink" title="/etc/passwd"></a>/etc/passwd</h3><p>Linux系统中的每个用户都在/etc/passwd文件中有一个对应的记录行，它记录了这个用户的一些基本属性。</p><p>这个文件对所有用户都是可读的。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-1-14-centos home]<span class="comment"># cat /etc/passwd</span></span><br><span class="line">root:x:0:0:root:/root:/bin/bash</span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line">用户名:口令:用户标识号:组标识号:注释性描述:主目录:登录Shell</span><br></pre></td></tr></table></figure><h4 id="用户名"><a href="#用户名" class="headerlink" title="用户名"></a>用户名</h4><p>“用户名”是代表用户账号的字符串。通常长度不超过8个字符，并且由大小写字母和/或数字组成。</p><p>登录名中不能有冒号(:)，因为冒号在这里是分隔符。为了兼容起见，登录名中最好不要包含点字符(.)，并且不使用连字符(-)和加号(+)打头。</p><h4 id="口令"><a href="#口令" class="headerlink" title="口令"></a>口令</h4><p>虽然这个字段存放的只是用户口令的加密串，不是明文，但是由于/etc/passwd文件对所有用户都可读，所以这仍是一个安全隐患。</p><p>因此，现在许多Linux 系统都使用了shadow技术，把真正的加密后的用户口令字存放到/etc/shadow文件中，而在/etc/passwd文件的口令字段中只存放一个特殊的字符，例如“x”或者“*”。</p><h4 id="用户标识号"><a href="#用户标识号" class="headerlink" title="用户标识号"></a>用户标识号</h4><p>一般情况下它与用户名是一一对应的。如果几个用户名对应的用户标识号是一样的，系统内部将把它们视为同一个用户，但是它们可以有不同的口令、不同的主目录以及不同的登录Shell等。</p><p>通常用户标识号的取值范围是0～65 535。0是超级用户root的标识号，1～99由系统保留，作为管理账号，普通用户的标识号从100开始。在Linux系统中，这个界限是500。</p><h4 id="组标识号"><a href="#组标识号" class="headerlink" title="组标识号"></a>组标识号</h4><p>它对应着/etc/group文件中的一条记录。</p><h4 id="注释性描述"><a href="#注释性描述" class="headerlink" title="注释性描述"></a>注释性描述</h4><p>例如用户的真实姓名、电话、地址等，这个字段并没有什么实际的用途。格式也没有统一。在许多Linux系统中，用做finger命令的输出。没有就为空。</p><h4 id="主目录"><a href="#主目录" class="headerlink" title="主目录"></a>主目录</h4><p>是用户在登录到系统之后所处的家目录。各用户的主目录都被放在 /home 下，通常来说用户主目录的名称就是该用户的登录名。</p><p>各用户对自己的主目录有读、写、执行权限，其他用户对此目录的访问权限则根据具体情况设置。</p><h4 id="登录Shell"><a href="#登录Shell" class="headerlink" title="登录Shell"></a>登录Shell</h4><p>Shell是用户与Linux系统之间的接口。Linux的Shell有许多种，每种都有不同的特点。常用的有sh(Bourne Shell), csh(C Shell), ksh(Korn Shell), tcsh(TENEX/TOPS-20 type C Shell), bash(Bourne Again Shell)等。</p><p>系统管理员可以根据系统情况和用户习惯为用户指定某个Shell。如果不指定Shell，那么系统使用sh为默认的登录Shell，即这个字段的值为/bin/sh。</p><p>用户的登录Shell也可以指定为某个特定的程序（此程序不是一个命令解释器）。</p><p>利用这一特点，我们可以限制用户只能运行指定的应用程序，在该应用程序运行结束后，用户就自动退出了系统。有些Linux 系统要求只有那些在系统中登记了的程序才能出现在这个字段中。</p><h4 id="伪用户-pseudo-users"><a href="#伪用户-pseudo-users" class="headerlink" title="伪用户(pseudo users)"></a>伪用户(pseudo users)</h4><p>这些用户在/etc/passwd文件中也占有一条记录，但是不能登录，因为它们的登录Shell为空。它们的存在主要是方便系统管理，满足相应的系统进程对文件属主的要求。</p><ul><li>bin 拥有可执行的用户命令文件 </li><li>sys 拥有系统文件 </li><li>adm 拥有帐户文件 </li><li>uucp UUCP使用 </li><li>lp lp或lpd子系统使用 </li><li>nobody NFS使用</li></ul><h3 id="etc-shadow"><a href="#etc-shadow" class="headerlink" title="/etc/shadow"></a>/etc/shadow</h3><p>与/etc/passwd记录一一对应，由pwconv命令根据/etc/passwd中的数据自动产生。但只有超级用户才拥有该文件读权限。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-1-14-centos home]<span class="comment"># cat /etc/shadow</span></span><br><span class="line">root:$1$ltOhBJKQ<span class="variable">$X</span>/KwY82TfyngQn/GVxk..1:18692:0:99999:7:::</span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line">登录名:加密口令:最后一次修改时间:最小时间间隔:最大时间间隔:警告时间:不活动时间:失效时间:标志</span><br></pre></td></tr></table></figure><ol><li>“登录名”是与/etc/passwd文件中的登录名相一致的用户账号</li><li>“口令”字段存放的是加密后的用户口令字，长度为13个字符。如果为空，则对应用户没有口令，登录时不需要口令；如果含有不属于集合 { ./0-9A-Za-z }中的字符，则对应的用户不能登录。</li><li>“最后一次修改时间”表示的是从某个时刻起，到用户最后一次修改口令时的天数。时间起点对不同的系统可能不一样。</li><li>“最小时间间隔”指的是两次修改口令之间所需的最小天数。</li><li>“最大时间间隔”指的是口令保持有效的最大天数。</li><li>“警告时间”字段表示的是从系统开始警告用户到用户密码正式失效之间的天数。</li><li>“不活动时间”表示的是用户没有登录活动但账号仍能保持有效的最大天数。</li><li>“失效时间”字段给出的是一个绝对的天数，如果使用了这个字段，那么就给出相应账号的生存期。期满后，该账号就不再是一个合法的账号，也就不能再用来登录了。</li></ol><h3 id="etc-group"><a href="#etc-group" class="headerlink" title="/etc/group"></a>/etc/group</h3><p>用户组的所有信息都存放在 /etc/group 文件中。</p><p>将用户分组是 Linux 系统中对用户进行管理及控制访问权限的一种手段。</p><p>每个用户都属于某个用户组；一个组中可以有多个用户，一个用户也可以属于不同的组。</p><p>当一个用户同时是多个组中的成员时，在 /etc/passwd 文件中记录的是用户所属的主组，也就是登录时所属的默认组，而其他组称为附加组。</p><p>用户要访问属于附加组的文件时，必须首先使用 <code>newgrp</code> 命令使自己成为所要访问的组中的成员。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-1-14-centos home]<span class="comment"># cat /etc/shadow</span></span><br><span class="line">root:$1$ltOhBJKQ<span class="variable">$X</span>/KwY82TfyngQn/GVxk..1:18692:0:99999:7:::</span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line">组名:口令:组标识号:组内用户列表</span><br></pre></td></tr></table></figure><ol><li>“组名”是用户组的名称，由字母或数字构成。与/etc/passwd中的登录名一样，组名不应重复。</li><li>“口令”字段存放的是用户组加密后的口令字。一般Linux 系统的用户组都没有口令，即这个字段一般为空，或者是*。</li><li>“组标识号”与用户标识号类似，也是一个整数，被系统内部用来标识组。</li><li>“组内用户列表”是属于这个组的所有用户的列表，不同用户之间用逗号(,)分隔。这个用户组可能是用户的主组，也可能是附加组。</li></ol><p>口令和主组内用户列表一般是看不到的</p><h2 id="添加批量用户"><a href="#添加批量用户" class="headerlink" title="添加批量用户"></a>添加批量用户</h2><h3 id="（1）先编辑一个文本用户文件"><a href="#（1）先编辑一个文本用户文件" class="headerlink" title="（1）先编辑一个文本用户文件"></a>（1）先编辑一个文本用户文件</h3><p>每一列按照<code>/etc/passwd</code>密码文件的格式书写，要注意每个用户的用户名、UID、宿主目录都不可以相同，其中密码栏可以留做空白或输入x号。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">user001::600:100:user:/home/user001:/bin/bash</span><br><span class="line">user002::601:100:user:/home/user002:/bin/bash</span><br><span class="line">user003::602:100:user:/home/user003:/bin/bash</span><br><span class="line">user004::603:100:user:/home/user004:/bin/bash</span><br><span class="line">user005::604:100:user:/home/user005:/bin/bash</span><br><span class="line">user006::605:100:user:/home/user006:/bin/bash</span><br></pre></td></tr></table></figure><h3 id="（2）以root身份执行-usr-sbin-newusers并导入user-txt"><a href="#（2）以root身份执行-usr-sbin-newusers并导入user-txt" class="headerlink" title="（2）以root身份执行 /usr/sbin/newusers并导入user.txt"></a>（2）以root身份执行 <code>/usr/sbin/newusers</code>并导入<code>user.txt</code></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># newusers &lt; user.txt</span><br></pre></td></tr></table></figure><p>然后可以执行命令 <code>vipw</code> 或 <code>vi /etc/passwd</code> 检查 <code>/etc/passwd</code> 文件是否已经出现这些用户的数据，并且用户的宿主目录是否已经创建。</p><h3 id="（3）执行命令-usr-sbin-pwunconv"><a href="#（3）执行命令-usr-sbin-pwunconv" class="headerlink" title="（3）执行命令/usr/sbin/pwunconv"></a>（3）执行命令/usr/sbin/pwunconv</h3><p>将 <code>/etc/shadow</code> 产生的 <code>shadow</code> 密码解码，然后回写到 <code>/etc/passwd</code> 中，并将<code>/etc/shadow</code>的<code>shadow</code>密码栏删掉。这是为了方便下一步的密码转换工作，即先取消 <code>shadow password</code> 功能。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># pwunconv</span></span><br></pre></td></tr></table></figure><h3 id="（4）编辑每个用户的密码对照文件"><a href="#（4）编辑每个用户的密码对照文件" class="headerlink" title="（4）编辑每个用户的密码对照文件"></a>（4）编辑每个用户的密码对照文件</h3><p>格式为：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">用户名:密码</span><br></pre></td></tr></table></figure><p>实例文件 <code>passwd.txt</code> 内容如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">user001:123456</span><br><span class="line">user002:123456</span><br><span class="line">user003:123456</span><br><span class="line">user004:123456</span><br><span class="line">user005:123456</span><br><span class="line">user006:123456</span><br></pre></td></tr></table></figure><h3 id="（5）以-root-身份执行命令-usr-sbin-chpasswd"><a href="#（5）以-root-身份执行命令-usr-sbin-chpasswd" class="headerlink" title="（5）以 root 身份执行命令 /usr/sbin/chpasswd"></a>（5）以 root 身份执行命令 <code>/usr/sbin/chpasswd</code></h3><p>创建用户密码，<code>chpasswd</code> 会将经过 <code>/usr/bin/passwd</code> 命令编码过的密码写入 <code>/etc/passwd</code> 的密码栏。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># chpasswd &lt; passwd.txt</span></span><br></pre></td></tr></table></figure><h3 id="（6）确定密码经编码写入-etc-passwd的密码栏后"><a href="#（6）确定密码经编码写入-etc-passwd的密码栏后" class="headerlink" title="（6）确定密码经编码写入/etc/passwd的密码栏后"></a>（6）确定密码经编码写入/etc/passwd的密码栏后</h3><p>执行命令 <code>/usr/sbin/pwconv</code> 将密码编码为 <code>shadow password</code>，并将结果写入 <code>/etc/shadow</code>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># pwconv</span></span><br></pre></td></tr></table></figure><p>这样就完成了大量用户的创建了，之后您可以到/home下检查这些用户宿主目录的权限设置是否都正确，并登录验证用户密码是否正确。</p>]]></content>
      
      
      <categories>
          
          <category> Linux基础 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Linux基础Part3</title>
      <link href="/2021/03/Linux%E5%9F%BA%E7%A1%80Part3/"/>
      <url>/2021/03/Linux%E5%9F%BA%E7%A1%80Part3/</url>
      
        <content type="html"><![CDATA[<h1 id="Linux基础Part3——VIM使用"><a href="#Linux基础Part3——VIM使用" class="headerlink" title="Linux基础Part3——VIM使用"></a>Linux基础Part3——VIM使用</h1><p>[TOC]</p><h2 id="VIM简介"><a href="#VIM简介" class="headerlink" title="VIM简介"></a>VIM简介</h2><p>Vim是从 vi 发展出来的一个文本编辑器。具有代码补完、编译及错误跳转等丰富的编程功能。</p><p><img src="/2021/03/Linux%E5%9F%BA%E7%A1%80Part3/vi-vim-cheat-sheet-sch.gif" alt="img"></p><h2 id="vi-vim-的使用"><a href="#vi-vim-的使用" class="headerlink" title="vi/vim 的使用"></a>vi/vim 的使用</h2><p>基本上 vi/vim 共分为三种模式，分别是<strong>命令模式（Command mode）</strong>、<strong>输入模式（Insert mode）</strong>、<strong>底线命令模式（Last line mode）</strong>。 </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim 文件名</span><br></pre></td></tr></table></figure><ul><li>这里的文件可以是存在的，也可以是不存在的</li></ul><h3 id="命令-一般模式"><a href="#命令-一般模式" class="headerlink" title="命令/一般模式"></a>命令/一般模式</h3><p>用户刚刚启动 vi/vim，便进入了命令模式。</p><p>此状态下敲击键盘动作会被Vim识别为命令，而非输入字符。比如我们此时按下i，并不会输入一个字符，i被当作了一个命令。</p><ul><li><strong>i</strong> 切换到输入模式，以输入字符。tip：用 i, I, o, O, a, A, r, R 都可以进入编辑模式。</li><li><strong>x</strong> 删除当前光标所在处的字符。</li><li><strong>:</strong> 切换到底线命令模式，以在最底一行输入命令。</li></ul><p>命令模式只有一些最基本的命令，因此仍要依靠底线命令模式输入更多命令。</p><h3 id="输入-编辑模式"><a href="#输入-编辑模式" class="headerlink" title="输入/编辑模式"></a>输入/编辑模式</h3><p>在命令模式下按下i就进入了输入模式。</p><p>在输入模式中，可以使用以下按键：</p><ul><li><strong>字符按键以及Shift组合</strong>，输入字符</li><li><strong>ENTER</strong>，回车键，换行</li><li><strong>BACK SPACE</strong>，退格键，删除光标前一个字符</li><li><strong>DEL</strong>，删除键，删除光标后一个字符</li><li><strong>方向键</strong>，在文本中移动光标</li><li><strong>HOME</strong>/<strong>END</strong>，移动光标到行首/行尾</li><li><strong>Page Up</strong>/<strong>Page Down</strong>，上/下翻页</li><li><strong>Insert</strong>，切换光标为输入/替换模式，光标将变成竖线/下划线</li><li><strong>ESC</strong>，退出输入模式，切换到命令模式</li></ul><h3 id="底线命令模式"><a href="#底线命令模式" class="headerlink" title="底线命令模式"></a>底线命令模式</h3><p>在命令模式下按下:（英文冒号）就进入了底线命令模式。</p><ul><li>q 不保存，退出程序</li><li>w 保存文件</li><li>qw 保存并退出</li><li>q! 强制退出</li><li>ESC 退出底线命令模式。</li></ul><p><img src="/2021/03/Linux%E5%9F%BA%E7%A1%80Part3/vim-vi-workmodel.png" alt="img"></p><h2 id="vi-vim-按键说明"><a href="#vi-vim-按键说明" class="headerlink" title="vi/vim 按键说明"></a>vi/vim 按键说明</h2><h3 id="第一部分：一般模式可用的光标移动、复制粘贴、搜索替换等"><a href="#第一部分：一般模式可用的光标移动、复制粘贴、搜索替换等" class="headerlink" title="第一部分：一般模式可用的光标移动、复制粘贴、搜索替换等"></a>第一部分：一般模式可用的光标移动、复制粘贴、搜索替换等</h3><table><thead><tr><th align="left">移动光标的方法</th><th></th></tr></thead><tbody><tr><td align="left">h 或 向左箭头键(←)</td><td>光标向左移动一个字符</td></tr><tr><td align="left">j 或 向下箭头键(↓)</td><td>光标向下移动一个字符</td></tr><tr><td align="left">k 或 向上箭头键(↑)</td><td>光标向上移动一个字符</td></tr><tr><td align="left">l 或 向右箭头键(→)</td><td>光标向右移动一个字符</td></tr><tr><td align="left">如果你将右手放在键盘上的话，你会发现 hjkl 是排列在一起的，因此可以使用这四个按钮来移动光标。 如果想要进行多次移动的话，例如向下移动 30 行，可以使用 “30j” 或 “30↓” 的组合按键， 亦即加上想要进行的次数(数字)后，按下动作即可！</td><td></td></tr><tr><td align="left">[Ctrl] + [f]</td><td>屏幕『向下』移动一页，相当于 [Page Down]按键 (常用)</td></tr><tr><td align="left">[Ctrl] + [b]</td><td>屏幕『向上』移动一页，相当于 [Page Up] 按键 (常用)</td></tr><tr><td align="left">[Ctrl] + [d]</td><td>屏幕『向下』移动半页</td></tr><tr><td align="left">[Ctrl] + [u]</td><td>屏幕『向上』移动半页</td></tr><tr><td align="left">+</td><td>光标移动到非空格符的下一行</td></tr><tr><td align="left">-</td><td>光标移动到非空格符的上一行</td></tr><tr><td align="left">n<space></space></td><td>那个 n 表示『数字』，例如 20 。按下数字后再按空格键，光标会向右移动这一行的 n 个字符。例如 20<space> 则光标会向后面移动 20 个字符距离。</space></td></tr><tr><td align="left">0 或功能键[Home]</td><td>这是数字『 0 』：移动到这一行的最前面字符处 (常用)</td></tr><tr><td align="left">$ 或功能键[End]</td><td>移动到这一行的最后面字符处(常用)</td></tr><tr><td align="left">H</td><td>光标移动到这个屏幕的最上方那一行的第一个字符</td></tr><tr><td align="left">M</td><td>光标移动到这个屏幕的中央那一行的第一个字符</td></tr><tr><td align="left">L</td><td>光标移动到这个屏幕的最下方那一行的第一个字符</td></tr><tr><td align="left">G</td><td>移动到这个档案的最后一行(常用)</td></tr><tr><td align="left">nG</td><td>n 为数字。移动到这个档案的第 n 行。例如 20G 则会移动到这个档案的第 20 行(可配合 :set nu)</td></tr><tr><td align="left">gg</td><td>移动到这个档案的第一行，相当于 1G 啊！ (常用)</td></tr><tr><td align="left">n<Enter></Enter></td><td>n 为数字。光标向下移动 n 行(常用)</td></tr><tr><td align="left">搜索替换</td><td></td></tr><tr><td align="left">/word</td><td>向光标之下寻找一个名称为 word 的字符串。例如要在档案内搜寻 vbird 这个字符串，就输入 /vbird 即可！ (常用)</td></tr><tr><td align="left">?word</td><td>向光标之上寻找一个字符串名称为 word 的字符串。</td></tr><tr><td align="left">n</td><td>这个 n 是英文按键。代表重复前一个搜寻的动作。举例来说， 如果刚刚我们执行 /vbird 去向下搜寻 vbird 这个字符串，则按下 n 后，会向下继续搜寻下一个名称为 vbird 的字符串。如果是执行 ?vbird 的话，那么按下 n 则会向上继续搜寻名称为 vbird 的字符串！</td></tr><tr><td align="left">N</td><td>这个 N 是英文按键。与 n 刚好相反，为『反向』进行前一个搜寻动作。 例如 /vbird 后，按下 N 则表示『向上』搜寻 vbird 。</td></tr><tr><td align="left">使用 /word 配合 n 及 N 是非常有帮助的！可以让你重复的找到一些你搜寻的关键词！</td><td></td></tr><tr><td align="left">:n1,n2s/word1/word2/g</td><td>n1 与 n2 为数字。在第 n1 与 n2 行之间寻找 word1 这个字符串，并将该字符串取代为 word2 ！举例来说，在 100 到 200 行之间搜寻 vbird 并取代为 VBIRD 则： 『:100,200s/vbird/VBIRD/g』。(常用)</td></tr><tr><td align="left"><strong>:1,$s/word1/word2/g</strong> 或 <strong>:%s/word1/word2/g</strong></td><td>从第一行到最后一行寻找 word1 字符串，并将该字符串取代为 word2 ！(常用)</td></tr><tr><td align="left"><strong>:1,$s/word1/word2/gc</strong> 或 <strong>:%s/word1/word2/gc</strong></td><td>从第一行到最后一行寻找 word1 字符串，并将该字符串取代为 word2 ！且在取代前显示提示字符给用户确认 (confirm) 是否需要取代！(常用)</td></tr><tr><td align="left">删除、复制与贴上</td><td></td></tr><tr><td align="left">x, X</td><td>在一行字当中，x 为向后删除一个字符 (相当于 [del] 按键)， X 为向前删除一个字符(相当于 [backspace] 亦即是退格键) (常用)</td></tr><tr><td align="left">nx</td><td>n 为数字，连续向后删除 n 个字符。举例来说，我要连续删除 10 个字符， 『10x』。</td></tr><tr><td align="left">dd</td><td>删除游标所在的那一整行(常用)</td></tr><tr><td align="left">ndd</td><td>n 为数字。删除光标所在的向下 n 行，例如 20dd 则是删除 20 行 (常用)</td></tr><tr><td align="left">d1G</td><td>删除光标所在到第一行的所有数据</td></tr><tr><td align="left">dG</td><td>删除光标所在到最后一行的所有数据</td></tr><tr><td align="left">d$</td><td>删除游标所在处，到该行的最后一个字符</td></tr><tr><td align="left">d0</td><td>那个是数字的 0 ，删除游标所在处，到该行的最前面一个字符</td></tr><tr><td align="left">yy</td><td>复制游标所在的那一行(常用)</td></tr><tr><td align="left">nyy</td><td>n 为数字。复制光标所在的向下 n 行，例如 20yy 则是复制 20 行(常用)</td></tr><tr><td align="left">y1G</td><td>复制游标所在行到第一行的所有数据</td></tr><tr><td align="left">yG</td><td>复制游标所在行到最后一行的所有数据</td></tr><tr><td align="left">y0</td><td>复制光标所在的那个字符到该行行首的所有数据</td></tr><tr><td align="left">y$</td><td>复制光标所在的那个字符到该行行尾的所有数据</td></tr><tr><td align="left">p, P</td><td>p 为将已复制的数据在光标下一行贴上，P 则为贴在游标上一行！ 举例来说，我目前光标在第 20 行，且已经复制了 10 行数据。则按下 p 后， 那 10 行数据会贴在原本的 20 行之后，亦即由 21 行开始贴。但如果是按下 P 呢？ 那么原本的第 20 行会被推到变成 30 行。 (常用)</td></tr><tr><td align="left">J</td><td>将光标所在行与下一行的数据结合成同一行</td></tr><tr><td align="left">c</td><td>重复删除多个数据，例如向下删除 10 行，[ 10cj ]</td></tr><tr><td align="left">u</td><td>复原前一个动作。(常用)</td></tr><tr><td align="left">[Ctrl]+r</td><td>重做上一个动作。(常用)</td></tr><tr><td align="left">这个 u 与 [Ctrl]+r 是很常用的指令！一个是复原，另一个则是重做一次～ 利用这两个功能按键，你的编辑，嘿嘿！很快乐的啦！</td><td></td></tr><tr><td align="left">.</td><td>不要怀疑！这就是小数点！意思是重复前一个动作的意思。 如果你想要重复删除、重复贴上等等动作，按下小数点『.』就好了！ (常用)</td></tr></tbody></table><h3 id="第二部分：一般模式切换到编辑模式的可用的按钮说明"><a href="#第二部分：一般模式切换到编辑模式的可用的按钮说明" class="headerlink" title="第二部分：一般模式切换到编辑模式的可用的按钮说明"></a>第二部分：一般模式切换到编辑模式的可用的按钮说明</h3><table><thead><tr><th align="left">进入输入或取代的编辑模式</th><th></th></tr></thead><tbody><tr><td align="left">i, I</td><td>进入输入模式(Insert mode)： i 为『从目前光标所在处输入』， I 为『在目前所在行的第一个非空格符处开始输入』。 (常用)</td></tr><tr><td align="left">a, A</td><td>进入输入模式(Insert mode)： a 为『从目前光标所在的下一个字符处开始输入』， A 为『从光标所在行的最后一个字符处开始输入』。(常用)</td></tr><tr><td align="left">o, O</td><td>进入输入模式(Insert mode)： 这是英文字母 o 的大小写。o 为在目前光标所在的下一行处输入新的一行； O 为在目前光标所在的上一行处输入新的一行！(常用)</td></tr><tr><td align="left">r, R</td><td>进入取代模式(Replace mode)： r 只会取代光标所在的那一个字符一次；R会一直取代光标所在的文字，直到按下 ESC 为止；(常用)</td></tr><tr><td align="left">上面这些按键中，在 vi 画面的左下角处会出现『–INSERT–』或『–REPLACE–』的字样。 由名称就知道该动作了吧！！特别注意的是，我们上面也提过了，你想要在档案里面输入字符时， 一定要在左下角处看到 INSERT 或 REPLACE 才能输入喔！</td><td></td></tr><tr><td align="left">[Esc]</td><td>退出编辑模式，回到一般模式中(常用)</td></tr></tbody></table><h3 id="第三部分：一般模式切换到指令行模式的可用的按钮说明"><a href="#第三部分：一般模式切换到指令行模式的可用的按钮说明" class="headerlink" title="第三部分：一般模式切换到指令行模式的可用的按钮说明"></a>第三部分：一般模式切换到指令行模式的可用的按钮说明</h3><table><thead><tr><th align="left">指令行的储存、离开等指令</th><th></th></tr></thead><tbody><tr><td align="left">:w</td><td>将编辑的数据写入硬盘档案中(常用)</td></tr><tr><td align="left">:w!</td><td>若文件属性为『只读』时，强制写入该档案。不过，到底能不能写入， 还是跟你对该档案的档案权限有关</td></tr><tr><td align="left">:q</td><td>离开 vi (常用)</td></tr><tr><td align="left">:q!</td><td>若曾修改过档案，又不想储存，使用 ! 为强制离开不储存档案。</td></tr><tr><td align="left">注意一下啊，那个惊叹号 (!) 在 vi 当中，常常具有『强制』的意思～</td><td></td></tr><tr><td align="left">:wq</td><td>储存后离开，若为 :wq! 则为强制储存后离开 (常用)</td></tr><tr><td align="left">ZZ</td><td>这是大写的 Z 喔！如果修改过，保存当前文件，然后退出！效果等同于(保存并退出)</td></tr><tr><td align="left">ZQ</td><td>不保存，强制退出。效果等同于 **:q!**。</td></tr><tr><td align="left">:w [filename]</td><td>将编辑的数据储存成另一个档案（类似另存新档）</td></tr><tr><td align="left">:r [filename]</td><td>在编辑的数据中，读入另一个档案的数据。亦即将 『filename』 这个档案内容加到游标所在行后面</td></tr><tr><td align="left">:n1,n2 w [filename]</td><td>将 n1 到 n2 的内容储存成 filename 这个档案。</td></tr><tr><td align="left">:! command</td><td>暂时离开 vi 到指令行模式下执行 command 的显示结果！例如 『:! ls /home』即可在 vi 当中察看 /home 底下以 ls 输出的档案信息！</td></tr><tr><td align="left">vim 环境的变更</td><td></td></tr><tr><td align="left">:set nu</td><td>显示行号，设定之后，会在每一行的前缀显示该行的行号</td></tr><tr><td align="left">:set nonu</td><td>与 set nu 相反，为取消行号！</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> Linux基础 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Linux基础Part2</title>
      <link href="/2021/03/Linux%E5%9F%BA%E7%A1%80Part2/"/>
      <url>/2021/03/Linux%E5%9F%BA%E7%A1%80Part2/</url>
      
        <content type="html"><![CDATA[<h1 id="Linux基础Part2——基本命令"><a href="#Linux基础Part2——基本命令" class="headerlink" title="Linux基础Part2——基本命令"></a>Linux基础Part2——基本命令</h1><p>[TOC]</p><h2 id="查看帮助"><a href="#查看帮助" class="headerlink" title="查看帮助"></a>查看帮助</h2><h3 id="help"><a href="#help" class="headerlink" title="help"></a>help</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">命令 --<span class="built_in">help</span></span><br></pre></td></tr></table></figure><h3 id="man"><a href="#man" class="headerlink" title="man"></a>man</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">man 命令</span><br></pre></td></tr></table></figure><ul><li>空格/→：下一页</li><li>回车/↓：下一行</li><li>b/←：上一页</li><li>f/↑：上一行</li><li>q：退出</li></ul><h2 id="目录管理"><a href="#目录管理" class="headerlink" title="目录管理"></a>目录管理</h2><h3 id="处理目录常用命令"><a href="#处理目录常用命令" class="headerlink" title="处理目录常用命令"></a>处理目录常用命令</h3><ul><li>ls: 列出目录</li><li>cd：切换目录</li><li>pwd：显示目前的目录</li><li>mkdir：创建一个新的目录</li><li>rmdir：删除一个空的目录</li><li>cp: 复制文件或目录</li><li>rm: 移除文件或目录</li><li>mv: 移动文件与目录，或修改文件与目录的名称</li></ul><h3 id="ls-列出目录"><a href="#ls-列出目录" class="headerlink" title="ls 列出目录"></a>ls 列出目录</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls [ -al ] [ 目录名称 ]</span><br></pre></td></tr></table></figure><ul><li>-a 列出全部文件，包括隐藏文件（开头为 . 的文件）</li><li>-l 列出长数据串，包括文件的属性和权限，不包括隐藏文件</li></ul><h3 id="cd-切换目录"><a href="#cd-切换目录" class="headerlink" title="cd 切换目录"></a>cd 切换目录</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> [ 相对路径或绝对路径 ]</span><br></pre></td></tr></table></figure><ul><li>绝对路径：由 根目录<code>/</code> 写起。</li><li>相对路径：由 父级目录<code>../</code> 或者 当前目录(可省略)<code>./</code> 写起。</li></ul><h3 id="pwd-显示当前目录"><a href="#pwd-显示当前目录" class="headerlink" title="pwd 显示当前目录"></a>pwd 显示当前目录</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">pwd</span> [ -P ]</span><br></pre></td></tr></table></figure><ul><li>-P 显示出真实路径，而非使用连接(link)路径。</li></ul><h3 id="mkdir-创建目录"><a href="#mkdir-创建目录" class="headerlink" title="mkdir 创建目录"></a>mkdir 创建目录</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir  [ -mp ] 目录名称</span><br></pre></td></tr></table></figure><ul><li>-m ：配置文件的权限</li><li>-p ：递归创建多级目录</li></ul><h3 id="rmdir-删除目录"><a href="#rmdir-删除目录" class="headerlink" title="rmdir 删除目录"></a>rmdir 删除目录</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rmdir [ -p ] 目录名称</span><br></pre></td></tr></table></figure><ul><li>-p ：递归删除上一级空白目录</li></ul><p>rmdir只能删除空白目录，rm删除非空目录。</p><h3 id="cp-复制文件-目录"><a href="#cp-复制文件-目录" class="headerlink" title="cp 复制文件/目录"></a>cp 复制文件/目录</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp [ -adfilprsu ] 来源(<span class="built_in">source</span>) [ source1 source2 source3 ] 目标(destination)</span><br></pre></td></tr></table></figure><ul><li>-a：等效于 -pdr </li><li>-p：连同文件的属性一起复制过去，而非使用默认属性</li><li>-d：若来源档为连结档的属性(link file)，则复制连结档属性而非文件本身</li><li>-r：多级目录的递归复制</li><li>-f：为强制(force)的意思，若目标文件已经存在且无法开启，则移除后再尝试一次</li><li>-i：若目标档(destination)已经存在时，在覆盖时会先询问动作的进行</li><li>-l：进行硬式连结(hard link)的连结档创建，而非复制文件本身</li><li>-s：复制成为符号连结档 (symbolic link)，即『捷径』文件</li><li>-u：若 destination 比 source 旧才升级 destination ！</li></ul><h3 id="rm-移除文件-目录"><a href="#rm-移除文件-目录" class="headerlink" title="rm 移除文件/目录"></a>rm 移除文件/目录</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rm [ -fir ] 文件/目录</span><br></pre></td></tr></table></figure><p>选项与参数：</p><ul><li>-f ：(force)忽略不存在的文件，不会出现警告信息，强制删除</li><li>-i ：互动模式，在删除前会询问使用者是否删除</li><li>-r ：递归删除目录</li></ul><h3 id="mv-移动文件-目录，或修改名称"><a href="#mv-移动文件-目录，或修改名称" class="headerlink" title="mv 移动文件/目录，或修改名称"></a>mv 移动文件/目录，或修改名称</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mv [ -fiu ] <span class="built_in">source</span> [ source2 source3 ] destination</span><br></pre></td></tr></table></figure><p>选项与参数：</p><ul><li>-f ：强制移动。若存在，则直接替换</li><li>-i ：若目标文件 (destination) 已经存在时，询问是否覆盖</li><li>-u ：若存在，则保留最后更新时间最新的文件</li></ul><h3 id="touch-创建文件"><a href="#touch-创建文件" class="headerlink" title="touch 创建文件"></a>touch 创建文件</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">touch 文件名1 文件名2</span><br></pre></td></tr></table></figure><p>可以一次创建多个文件</p><p>可以随意指定文件类型</p><h3 id="gt-输出重定向-和-gt-gt-追加"><a href="#gt-输出重定向-和-gt-gt-追加" class="headerlink" title="&gt;输出重定向 和 &gt;&gt;追加"></a>&gt;输出重定向 和 &gt;&gt;追加</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ls -l&gt;文件  <span class="comment"># 列表内容覆盖写入目标文件夹</span></span><br><span class="line">ls -al&gt;&gt;文件   <span class="comment"># 列表内容追加到文件末尾</span></span><br><span class="line">cat 文件1&gt;文件2  <span class="comment"># 用文件1覆盖文件2</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;内容&quot;</span>&gt;&gt;文件  <span class="comment"># 将内容追加到文件末尾</span></span><br></pre></td></tr></table></figure><p><code>&gt;</code>, <code>&gt;&gt;</code>左右可空格也可不空格</p><h2 id="基本属性"><a href="#基本属性" class="headerlink" title="基本属性"></a>基本属性</h2><p>Linux系统是一种典型的多用户系统，不同的用户处于不同的地位，拥有不同的权限。为了保护系统的安全性，Linux系统对不同的用户访问同一文件（包括目录文件）的权限做了不同的规定。</p><blockquote><p>每个文件都有自己的所有者、所有组。</p><p>对于这个文件的属主(所有者/创建者)、属组(所有组)、其他用户(除了属主和属组)，有不同的权限。</p><p>一个文件夹要有x的权限，用户才能进入这个目录；并且要有r的权限，才能查看；只有w的权限，才能修改文件夹。</p></blockquote><h3 id="权限"><a href="#权限" class="headerlink" title="权限"></a>权限</h3><p>使用<code>ll</code>或者<code>ls –l</code>来显示一个文件的属性以及文件所属的用户和组</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-1-14-centos /]<span class="comment"># ls -ll</span></span><br><span class="line">total 64</span><br><span class="line">lrwxrwxrwx.   1 root root     7 Mar  7  2019 bin -&gt; usr/bin</span><br><span class="line">dr-xr-xr-x.   5 root root  4096 Mar  6 19:50 boot</span><br><span class="line">drwxr-xr-x    2 root root  4096 Nov  5  2019 data</span><br><span class="line">drwxr-xr-x   20 root root  3020 Mar  6 19:49 dev</span><br><span class="line">drwxr-xr-x.  90 root root  4096 Mar  6 19:50 etc</span><br><span class="line">drwxr-xr-x.   2 root root  4096 Apr 11  2018 home</span><br><span class="line">lrwxrwxrwx.   1 root root     7 Mar  7  2019 lib -&gt; usr/lib</span><br><span class="line">lrwxrwxrwx.   1 root root     9 Mar  7  2019 lib64 -&gt; usr/lib64</span><br><span class="line">drwx------.   2 root root 16384 Mar  7  2019 lost+found</span><br><span class="line">drwxr-xr-x.   2 root root  4096 Apr 11  2018 media</span><br><span class="line">drwxr-xr-x.   2 root root  4096 Apr 11  2018 mnt</span><br><span class="line">drwxr-xr-x.   4 root root  4096 Aug  5  2020 opt</span><br><span class="line">dr-xr-xr-x  104 root root     0 Mar  6 19:49 proc</span><br><span class="line">dr-xr-x---.   7 root root  4096 Mar 10 19:45 root</span><br><span class="line">drwxr-xr-x   25 root root   900 Mar  8 16:10 run</span><br><span class="line">lrwxrwxrwx.   1 root root     8 Mar  7  2019 sbin -&gt; usr/sbin</span><br><span class="line">drwxr-xr-x.   2 root root  4096 Apr 11  2018 srv</span><br><span class="line">dr-xr-xr-x   13 root root     0 Mar  9 22:52 sys</span><br><span class="line">drwxrwxrwt.   9 root root  4096 Mar 10 19:46 tmp</span><br><span class="line">drwxr-xr-x.  13 root root  4096 Mar  7  2019 usr</span><br><span class="line">drwxr-xr-x.  19 root root  4096 Apr 22  2020 var</span><br><span class="line"><span class="comment"># 权限   文件个数 属主 属组   大小 修改日期 时间 文件名</span></span><br></pre></td></tr></table></figure><p>第1个字符代表这个文件的类型(目录、文件或链接文件等)：</p><ul><li>d：表示目录</li><li>-：表示文件</li><li>l：档 (link file)</li><li>b：件里面的可供储存的接口设备 ( 可随机存取装置 )</li><li>c：件里面的串行端口设备，例如键盘、鼠标 ( 一次性读取装置 )</li></ul><p>第2-10个字符中，以三个为一组，且均为『rwx』 的三个参数的组合。</p><ul><li>r：代表可读(read)</li><li>w：代表可写(write)</li><li>x：代表可执行(execute)</li><li>-：代表无权限</li></ul><p><img src="/2021/03/Linux%E5%9F%BA%E7%A1%80Part2/363003_1227493859FdXT.png" alt="363003_1227493859FdXT"></p><h3 id="属主和属组"><a href="#属主和属组" class="headerlink" title="属主和属组"></a>属主和属组</h3><p>对于文件来说，它都有一个特定的所有者，也就是对该文件具有所有权的用户。</p><p>同时，在Linux系统中，用户是按组分类的，一个用户属于一个或多个组。</p><p>文件所有者以外的用户又可以分为文件所有者的同组用户和其他用户。</p><p>因此，Linux系统按文件所有者、文件所有者同组用户和其他用户来规定了不同的文件访问权限。</p><p>对于 root 用户来说，一般情况下，文件的权限对其不起作用。</p><h3 id="数字修改文件属性"><a href="#数字修改文件属性" class="headerlink" title="数字修改文件属性"></a>数字修改文件属性</h3><p><strong>1、chgrp：更改文件属组</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chgrp [ -R ] 属组名 文件名</span><br></pre></td></tr></table></figure><ul><li>-R：递归更改文件属组，就是在更改某个目录文件的属组时，如果加上-R的参数，那么该目录下的所有文件的属组都会更改。</li></ul><p><strong>2、chown：更改文件属主，也可以同时更改文件属组</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">chown [ –R ] 属主名 文件名</span><br><span class="line">chown [ -R ] 属主名:属组名 文件名</span><br></pre></td></tr></table></figure><p><strong>3、chmod：更改文件9个属性</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod [ -R ] xyz 文件/目录</span><br></pre></td></tr></table></figure><ul><li>-R：连同目录下的所有文件都进行递归变更</li></ul><p>Linux文件的基本权限有九个，分别是owner/group/others三种身份各有自己的read/write/execute权限。</p><p>各权限的分数对照：</p><ul><li>r = 4</li><li>w = 2</li><li>x = 1</li></ul><p>举例：</p><ul><li>可读可写可执行：rwx = 4+2+1 = 7</li><li>可读可写不可执行：rw- = 4+2+0 = 6</li><li>不可读/写/执行：— = 0+0+0 = 0</li></ul><h3 id="符号修改文件属性"><a href="#符号修改文件属性" class="headerlink" title="符号修改文件属性"></a>符号修改文件属性</h3><p>使用 u、g、o、a 代表 user用户、group组、others其他、all全部 身份</p><p>使用 r、w、x 代表读写权限</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod [ u/g/o/a ] [ +(加入) -(除去) =(设定) ] [ r w x ] 文件或目录</span><br></pre></td></tr></table></figure><p>demo：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#  touch test1    // 创建 test1 文件</span></span><br><span class="line"><span class="comment"># ls -al test1    // 查看 test1 默认权限</span></span><br><span class="line">-rw-r--r-- 1 root root 0 Nov 15 10:32 test1</span><br><span class="line"><span class="comment"># chmod u=rwx,g=rx,o=r  test1    // 修改 test1 权限</span></span><br><span class="line"><span class="comment"># ls -al test1</span></span><br><span class="line">-rwxr-xr-- 1 root root 0 Nov 15 10:32 test1</span><br><span class="line"><span class="comment">#  chmod  a-x test1</span></span><br><span class="line"><span class="comment"># ls -al test1</span></span><br><span class="line">-rw-r--r-- 1 root root 0 Nov 15 10:32 test1</span><br></pre></td></tr></table></figure><h2 id="内容查看"><a href="#内容查看" class="headerlink" title="内容查看"></a>内容查看</h2><h3 id="查看文件内容"><a href="#查看文件内容" class="headerlink" title="查看文件内容"></a>查看文件内容</h3><ul><li>cat 由第一行开始显示文件内容</li><li>tac 从最后一行开始显示</li><li>nl  显示的时候同时输出行号</li><li>more 一页一页的显示文件内容</li><li>less 与 more 类似，但是比 more 更好的是，他可以往前翻页！</li><li>head 只看开头几行</li><li>tail 只看末尾几行</li></ul><h3 id="cat"><a href="#cat" class="headerlink" title="cat"></a>cat</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat [ -AbEnTv ]</span><br></pre></td></tr></table></figure><ul><li>-A：等价于 -vET ，可列出一些特殊字符而不是空白而已</li><li>-b：列出行号，仅针对非空白行做行号显示，空白行不标行号！</li><li>-E：将结尾的断行字节 $ 显示出来；</li><li>-n：列印出行号，连同空白行也会有行号，与 -b 的选项不同；</li><li>-T：将 [tab] 按键以 ^I 显示出来；</li><li>-v：列出一些看不出来的特殊字符</li></ul><p>demo：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-1-14-centos network-scripts]<span class="comment"># cat ifcfg-eth0 </span></span><br><span class="line"><span class="comment"># Created by cloud-init on instance boot automatically, do not edit.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line">BOOTPROTO=dhcp</span><br><span class="line">DEVICE=eth0</span><br><span class="line">HWADDR=52:54:00:23:6f:89</span><br><span class="line">ONBOOT=yes</span><br><span class="line">PERSISTENT_DHCLIENT=yes</span><br><span class="line">TYPE=Ethernet</span><br><span class="line">USERCTL=no</span><br></pre></td></tr></table></figure><h3 id="tac"><a href="#tac" class="headerlink" title="tac"></a>tac</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tac [ -AbEnTv ]</span><br></pre></td></tr></table></figure><p>demo：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-1-14-centos network-scripts]<span class="comment"># tac ifcfg-eth0 </span></span><br><span class="line">USERCTL=no</span><br><span class="line">TYPE=Ethernet</span><br><span class="line">PERSISTENT_DHCLIENT=yes</span><br><span class="line">ONBOOT=yes</span><br><span class="line">HWADDR=52:54:00:23:6f:89</span><br><span class="line">DEVICE=eth0</span><br><span class="line">BOOTPROTO=dhcp</span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Created by cloud-init on instance boot automatically, do not edit.</span></span><br></pre></td></tr></table></figure><h3 id="nl"><a href="#nl" class="headerlink" title="nl"></a>nl</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nl [ -bnw ] 文件</span><br></pre></td></tr></table></figure><ul><li>-b：指定行号指定的方式，主要有两种：-b a ：表示不论是否为空行，也同样列出行号(类似 cat -n)；-b t ：如果有空行，空的那一行不要列出行号(默认值)；</li><li>-n：列出行号表示的方法，主要有三种：-n ln ：行号在荧幕的最左方显示；-n rn ：行号在自己栏位的最右方显示，且不加 0 ；-n rz ：行号在自己栏位的最右方显示，且加 0 ；</li><li>-w：行号栏位的占用的位数。</li></ul><p>demo：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-1-14-centos network-scripts]<span class="comment"># nl ifcfg-eth0 </span></span><br><span class="line">     1<span class="comment"># Created by cloud-init on instance boot automatically, do not edit.</span></span><br><span class="line">     2<span class="comment">#</span></span><br><span class="line">     3BOOTPROTO=dhcp</span><br><span class="line">     4DEVICE=eth0</span><br><span class="line">     5HWADDR=52:54:00:23:6f:89</span><br><span class="line">     6ONBOOT=yes</span><br><span class="line">     7PERSISTENT_DHCLIENT=yes</span><br><span class="line">     8TYPE=Ethernet</span><br><span class="line">     9USERCTL=no</span><br></pre></td></tr></table></figure><h3 id="more"><a href="#more" class="headerlink" title="more"></a>more</h3><ul><li>空白键 (space)：代表向下翻一页；</li><li>Enter：代表向下翻『一行』；</li><li>/字串：代表在这个显示的内容当中，向下搜寻『字串』这个关键字；</li><li>:f：立刻显示出档名以及目前显示的行数；</li><li>q：代表立刻离开 more ，不再显示该文件内容。</li><li>b 或 [ctrl]-b：代表往回翻页，不过这动作只对文件有用，对管线无用。</li></ul><h3 id="less"><a href="#less" class="headerlink" title="less"></a>less</h3><ul><li>空白键：向下翻动一页；</li><li>[pagedown]↑：向下翻动一页；</li><li>[pageup]↓：向上翻动一页；</li><li>/字串：向下搜寻『字串』的功能；</li><li>?字串：向上搜寻『字串』的功能；</li><li>n：重复前一个搜寻 (与 / 或 ? 有关！)</li><li>N：反向的重复前一个搜寻 (与 / 或 ? 有关！)</li><li>q：离开 less 这个程序；</li></ul><h3 id="echo"><a href="#echo" class="headerlink" title="echo"></a>echo</h3><p>输出内容到控制台</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> [ 内容 ]</span><br></pre></td></tr></table></figure><p>demo：输出环境变量</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-1-14-centos ~]<span class="comment"># echo $PATH</span></span><br><span class="line">/usr/<span class="built_in">local</span>/sbin:/usr/<span class="built_in">local</span>/bin:/usr/sbin:/usr/bin:/root/bin</span><br></pre></td></tr></table></figure><h3 id="head"><a href="#head" class="headerlink" title="head"></a>head</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">head [ -n number ] 文件</span><br></pre></td></tr></table></figure><ul><li>-n：后面接数字，表示显示几行，默认为10行</li></ul><h3 id="tail"><a href="#tail" class="headerlink" title="tail"></a>tail</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tail [ -n number ] 文件</span><br></pre></td></tr></table></figure><ul><li>-n ：后面接数字，表示显示几行，默认为10行</li></ul><h2 id="日期指令"><a href="#日期指令" class="headerlink" title="日期指令"></a>日期指令</h2><h3 id="date"><a href="#date" class="headerlink" title="date"></a>date</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">date</span><br><span class="line">date +%Y</span><br><span class="line">date +<span class="string">&quot;%Y-%m-%d %H:%M:%S&quot;</span></span><br><span class="line">date -s <span class="string">&quot;2021-03-12 15:06:35&quot;</span></span><br></pre></td></tr></table></figure><ul><li>-s 设置当前系统时间</li></ul><p><code>+&quot;%Y-%m-%d %H:%M:%S&quot;</code>或<code>&quot;+%Y-%m-%d %H:%M:%S&quot;</code>是等效的，但必须要有一个 <code>+</code> ，多出来的+将会被当做字符输出。</p><p>输出单个数值不需要 <code>&quot;&quot;</code>。</p><h3 id="cal"><a href="#cal" class="headerlink" title="cal"></a>cal</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cal [ 选项 ]  <span class="comment"># 默认显示当前月份</span></span><br><span class="line">cal 2021  <span class="comment"># 显示2021年整年日历</span></span><br></pre></td></tr></table></figure><h2 id="查找指令"><a href="#查找指令" class="headerlink" title="查找指令"></a>查找指令</h2><h3 id="find"><a href="#find" class="headerlink" title="find"></a>find</h3><p>find 指令将从指定目录向下递归地遍历其各个子目录，将满足条件的文件或者目录显示在终端。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find [ 搜索范围 ] [ 选项 ]</span><br></pre></td></tr></table></figure><ul><li>-name 按指定文件名查找 <code>-name 文件名</code></li><li>-user 查找属于指定用户的所有文件 <code>-user 用户名</code></li><li>-size 查找指定大小的文件(+n 大于 -n 小于 n 等于) <code>-size +20M</code></li></ul><p>demo：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find / *.txt  <span class="comment"># 查找所有.txt文件</span></span><br></pre></td></tr></table></figure><h3 id="locate"><a href="#locate" class="headerlink" title="locate"></a>locate</h3><p>locate 指令无需遍历整个文件系统，利用事先建立的系统中所有文件名称及路径的 locate 数据库，实现快速定位给定的文件路径。</p><p>第一次运行前，必须使用 <code>updatedb</code> 指令创建 locate 数据库，同时也需要定期更新 locate 时刻，以保证查找准确性。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">locate 文件名</span><br></pre></td></tr></table></figure><h3 id="grep和管道符号"><a href="#grep和管道符号" class="headerlink" title="grep和管道符号|"></a>grep和管道符号|</h3><p>grep 过滤查找 。</p><p>管道符 <code>|</code> 表示将前一个命令的处理结果输出传递给后面的命令处理。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep [ 选项 ] 内容 文件</span><br></pre></td></tr></table></figure><ul><li>-n 显示匹配行和行号</li><li>-i 忽略大小写</li></ul><p>demo：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-1-14-centos ~]<span class="comment"># grep -n main hello.java </span></span><br><span class="line">2:public static void main(String args[])&#123;</span><br><span class="line">[root@VM-1-14-centos ~]<span class="comment"># cat hello.java | grep -n main</span></span><br><span class="line">2:public static void main(String args[])&#123;</span><br></pre></td></tr></table></figure><h2 id="压缩与解压"><a href="#压缩与解压" class="headerlink" title="压缩与解压"></a>压缩与解压</h2><h3 id="gzip-gunzip"><a href="#gzip-gunzip" class="headerlink" title="gzip/gunzip"></a>gzip/gunzip</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gzip 文件名  <span class="comment"># 将文件压缩成*.gz文件</span></span><br><span class="line">gunzip 文件名  <span class="comment"># 解压*.gz文件</span></span><br></pre></td></tr></table></figure><p>使用 <code>gzip/gunzip</code> 将不会保留源文件。</p><h3 id="zip-unzip"><a href="#zip-unzip" class="headerlink" title="zip/unzip"></a>zip/unzip</h3><p>经常使用于项目打包发布中。</p><p>会保留源文件。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">zip [ -r ] 文件名.zip 需要压缩的目录或文件</span><br><span class="line">unzip [ -d ] 文件名.zip</span><br></pre></td></tr></table></figure><ul><li>-r：递归压缩</li><li>-d &lt;目录&gt; ：指定解压后文件的存放目录</li></ul><h3 id="tar"><a href="#tar" class="headerlink" title="tar"></a>tar</h3><p>tar是打包指令，即可以压缩也可以解压，最后打包后的文件是 .tar.gz 。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar[ 选项 ] XXX.tar.gz 打包的内容</span><br></pre></td></tr></table></figure><ul><li>-c：产生.tar打包文件</li><li>-v：显示详细信息</li><li>-f：指定压缩后的文件名</li><li>-z：打包同时压缩</li><li>-x：解包.tar文件</li><li>-t：列出档案文件的内容，查看已经备份了哪些文件</li></ul><p>对于解压的选项，f必须放最后，其他的位置任意，但是建议按照规范</p><p>解压到指定某个目录必须加上-C选项，不然会出错。</p><p>demo：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">tar -zcvf txt.tar.gz t1.txt t2.txt  <span class="comment"># 这里将t1.txt和t2.txt打包压缩为txt.tar.gz文件</span></span><br><span class="line">tar -zcvf home.tar.gz /home/  <span class="comment"># 将/home/目录打包</span></span><br><span class="line">tar -zxvf num.tar.gz -C ~  <span class="comment"># 这里将num.tar.gz解压到~这个目录下，这个目录必须存在</span></span><br></pre></td></tr></table></figure><h2 id="软-硬链接"><a href="#软-硬链接" class="headerlink" title="软/硬链接"></a>软/硬链接</h2><p>Linux 链接分两种，一种被称为硬链接（Hard Link），另一种被称为符号链接（Symbolic Link）。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ln [ -s ] 源文件 目标文件</span><br></pre></td></tr></table></figure><h3 id="硬连接"><a href="#硬连接" class="headerlink" title="硬连接"></a>硬连接</h3><ul><li>硬连接指通过索引节点号(Inode Index)来进行连接。即可以有两个文件名A和B指向同一个索引节点号，一个文件拥有多个有效路径名，A和B对文件系统来说是完全平等的。</li><li>删除其中任何一个都不会影响另外一个的访问，只有两个都被删除才算是真正删除了文件数据。</li><li>通常用于备份以防误删。</li></ul><h3 id="软连接"><a href="#软连接" class="headerlink" title="软连接"></a>软连接</h3><ul><li>符号连接（Symbolic Link），也叫软连接。</li><li>软链接文件实际是一个特殊的文件。内容的是另一文件的位置信息，相当于快捷方式。</li><li>A 和 B 指向的是两个不同的 inode 节点，即他们本体在磁盘的存储是两个文件。</li><li>但是 A 的数据块中存放的只是 B 的路径名（可以根据这个找到 B 的目录项）。如果 B 被删除了，A 仍然存在（因为两个是不同的文件），但指向的是一个无效的地址。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Linux基础 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Linux基础Part1</title>
      <link href="/2021/03/Linux%E5%9F%BA%E7%A1%80Part1/"/>
      <url>/2021/03/Linux%E5%9F%BA%E7%A1%80Part1/</url>
      
        <content type="html"><![CDATA[<h1 id="Linux基础Part1——概述"><a href="#Linux基础Part1——概述" class="headerlink" title="Linux基础Part1——概述"></a>Linux基础Part1——概述</h1><p>[TOC]</p><h2 id="Linux概述"><a href="#Linux概述" class="headerlink" title="Linux概述"></a>Linux概述</h2><h3 id="起源"><a href="#起源" class="headerlink" title="起源"></a>起源</h3><p>Linux 内核最初只是由芬兰人林纳斯·托瓦兹（Linus Torvalds）在赫尔辛基大学上学时出于个人爱好而编写的。</p><p>Linux 是一套免费使用和自由传播的类 Unix 操作系统，是一个基于 POSIX（可移植操作系统接口） 和 UNIX 的多用户、多任务、支持多线程和多 CPU 的操作系统。</p><p>Linux 能运行主要的 UNIX 工具软件、应用程序和网络协议。它支持 32 位和 64 位硬件。Linux 继承了 Unix 以网络为核心的设计思想，是一个性能稳定的多用户网络操作系统。</p><h3 id="发行版"><a href="#发行版" class="headerlink" title="发行版"></a>发行版</h3><p>Linux 的发行版说简单点就是将 Linux 内核与应用软件做一个打包。</p><p>目前市面上较知名的发行版有：Ubuntu、RedHat、CentOS、Debian、Fedora、SuSE、OpenSUSE、Arch Linux、SolusOS 等。（Kali Linux安全渗透测试）</p><p>Mac无缝兼容Linux指令，mac也同时具备linux的优秀工具。</p><blockquote><p>作为一个优秀的程序员，应当重视安全性！</p></blockquote><h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><p>通常服务器使用 LAMP（Linux + Apache + MySQL + PHP）或 LNMP（Linux + Nginx+ MySQL + PHP）组合。</p><h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><p><a href="https://www.bilibili.com/video/BV187411y7hF?p=3">暂时不详细记录，本人使用服务器</a></p><h3 id="本地虚拟机"><a href="#本地虚拟机" class="headerlink" title="本地虚拟机"></a>本地虚拟机</h3><p>VMware+CentOS</p><p>ctrl+alt: 退出虚拟机</p><h3 id="云端服务器"><a href="#云端服务器" class="headerlink" title="云端服务器"></a>云端服务器</h3><p>CentOS 7.0</p><ol><li><p>服务器就是一个远程电脑</p></li><li><p>访问出错基本都是端口放行问题，包括Linux的防火墙和服务器安全组</p><p>21-ftp；22-ssh；443-https；80-http；8888-39000/40000-宝塔；3306-MySQL；8080-Tomcat；9000-测试；6379/6380-redis</p></li><li><p>安全组开放端口授权对象：0.0.0.0/0（允许所有人访问）</p></li></ol><h2 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h2><h3 id="开机"><a href="#开机" class="headerlink" title="开机"></a>开机</h3><p>开机会启动许多程序。它们在Windows叫做”服务”（service），在Linux就叫做”守护进程”（daemon）。</p><p>用户的登录方式有三种：1.命令行登录；2.ssh登录；3.图形界面登录</p><p>root是最高权限，其下有更多子用户</p><h3 id="关机"><a href="#关机" class="headerlink" title="关机"></a>关机</h3><p>服务器大多数情况不会关机。</p><p>不管是重启系统还是关闭系统，首先要运行 <code>sync</code>命令，把内存中的数据写到磁盘中。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">sync <span class="comment"># 将数据由内存同步到硬盘中。</span></span><br><span class="line"></span><br><span class="line">shutdown <span class="comment"># 关机</span></span><br><span class="line"></span><br><span class="line">shutdown –h 10 <span class="comment"># 这个命令告诉大家，计算机将在10分钟后关机</span></span><br><span class="line"></span><br><span class="line">shutdown –h now <span class="comment"># 立马关机</span></span><br><span class="line"></span><br><span class="line">shutdown –h 20:25 <span class="comment"># 系统会在今天20:25关机</span></span><br><span class="line"></span><br><span class="line">shutdown –h +10 <span class="comment"># 十分钟后关机</span></span><br><span class="line"></span><br><span class="line">shutdown –r now <span class="comment"># 系统立即重启</span></span><br><span class="line"></span><br><span class="line">shutdown –r +10 <span class="comment"># 系统十分钟后重启</span></span><br><span class="line"></span><br><span class="line">reboot <span class="comment"># 重启，等效于 shutdown –r now</span></span><br><span class="line"></span><br><span class="line">halt <span class="comment"># 关机，等效于 shutdown –h now 和 poweroff</span></span><br></pre></td></tr></table></figure><blockquote><p>Linux中，在输入指令过后，没有输出即代表指令执行成功</p></blockquote><h2 id="Linux系统目录结构"><a href="#Linux系统目录结构" class="headerlink" title="Linux系统目录结构"></a>Linux系统目录结构</h2><blockquote><ol><li>一切皆文件</li><li>所有文件都挂载在根目录 <code>/</code> 下</li></ol></blockquote><p><strong>系统启动必须：</strong></p><ul><li><p><strong>/boot：</strong>存放的启动Linux 时使用的内核文件，包括连接文件以及镜像文件。</p></li><li><p><strong>/etc：</strong>存放<strong>所有</strong>的系统需要的<strong>配置文件</strong>和<strong>子目录列表，</strong>更改目录下的文件可能会导致系统不能启动。</p></li><li><p><strong>/lib</strong>：存放基本代码库（比如c++库），其作用类似于Windows里的DLL文件。几乎所有的应用程序都需要用到这些共享库。</p></li><li><p><strong>/sys</strong>： 这是linux2.6内核的一个很大的变化。该目录下安装了2.6内核中新出现的一个文件系统 sysfs 。sysfs文件系统集成了下面3种文件系统的信息：针对进程信息的proc文件系统、针对设备的devfs文件系统以及针对伪终端的devpts文件系统。该文件系统是内核设备树的一个直观反映。当一个内核对象被创建的时候，对应的文件和目录也在内核对象子系统中</p></li></ul><p><strong>指令集合：</strong></p><ul><li><p><strong>/bin：</strong>存放着最常用的程序和指令</p></li><li><p><strong>/sbin：</strong>只有系统管理员能使用的程序和指令。</p></li></ul><p><strong>外部文件管理：</strong></p><ul><li><p><strong>/dev ：</strong>Device(设备)的缩写, 存放的是Linux的外部设备。<strong>注意：</strong>在Linux中访问设备和访问文件的方式是相同的。</p></li><li><p><strong>/media</strong>：类windows的<strong>其他设备，</strong>例如U盘、光驱等等，识别后linux会把设备放到这个目录下。</p></li><li><p><strong>/mnt</strong>：临时挂载别的文件系统的，我们可以将光驱挂载在/mnt/上，然后进入该目录就可以查看光驱里的内容了。</p></li></ul><p><strong>临时文件：</strong></p><ul><li><p><strong>/run</strong>：是一个临时文件系统，存储系统启动以来的信息。当系统重启时，这个目录下的文件应该被删掉或清除。如果你的系统上有 /var/run 目录，应该让它指向 run。</p></li><li><p><strong>/lost+found</strong>：一般情况下为空的，系统非法关机后，这里就存放一些文件。</p></li><li><p><strong>/tmp</strong>：这个目录是用来存放一些临时文件的。比如：安装包。</p></li></ul><p><strong>账户：</strong></p><ul><li><p><strong>/root</strong>：系统管理员的用户主目录。</p></li><li><p><strong>/home</strong>：目录下有各个用户以账号名命名的家目录。用户登录时，会自动进入自己的家目录。</p></li><li><p><strong>/usr</strong>： usr 是 unix shared resources(共享资源) 的缩写，这是一个非常重要的目录。用户的很多应用程序和文件都放在这个目录下，类似于windows下的program files目录。</p></li><li><p><strong>/usr/bin：</strong>系统用户使用的应用程序与指令。</p></li><li><p><strong>/usr/sbin：</strong>超级用户使用的比较高级的管理程序和系统守护程序。</p></li><li><p><strong>/usr/src：</strong>内核源代码默认的放置目录。</p></li></ul><p><strong>运行过程中要用：</strong></p><ul><li><p><strong>/var</strong>：存放经常修改的数据，比如程序运行的日志文件（/var/log 目录下）。</p></li><li><p><strong>/proc</strong>：管理<strong>内存空间！</strong>虚拟的目录，是系统内存的映射，我们可以直接访问这个目录来，获取系统信息。这个目录的内容不在硬盘上而是在内存里，我们也可以直接修改里面的某些文件来做修改。</p></li></ul><p><strong>扩展用的：</strong></p><ul><li><p><strong>/opt</strong>：默认是空的，我们安装额外软件可以放在这个里面。</p></li><li><p><strong>/srv</strong>：存放服务启动后需要提取的数据<strong>（不用服务器就是空）</strong></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Linux基础 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>浙江大学机器学习课程-完结目录</title>
      <link href="/2021/02/%E6%B5%99%E6%B1%9F%E5%A4%A7%E5%AD%A6%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E8%AF%BE%E7%A8%8B-%E5%AE%8C%E7%BB%93%E7%9B%AE%E5%BD%95/"/>
      <url>/2021/02/%E6%B5%99%E6%B1%9F%E5%A4%A7%E5%AD%A6%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E8%AF%BE%E7%A8%8B-%E5%AE%8C%E7%BB%93%E7%9B%AE%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<h1 id="浙江大学机器学习课程-完结目录"><a href="#浙江大学机器学习课程-完结目录" class="headerlink" title="浙江大学机器学习课程-完结目录"></a>浙江大学机器学习课程-完结目录</h1><p>教程视频传送门：<a href="https://www.bilibili.com/video/BV1dJ411B7gh?p=1">浙江大学研究生机器学习课程</a></p><p>对于本人来说是看完一些机器学习入门教程之后的理论补充。这个教程包含大量具体详细的理论推导，有一定难度，但是对于想要熟悉理论的还是比较推荐。</p><p>==本人在以后会把推导不足的部分补全。==</p><table><thead><tr><th align="center"><a href="/2021/02/%E6%B5%99%E6%B1%9F%E5%A4%A7%E5%AD%A6%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E8%AF%BE%E7%A8%8BPart1/">Part1——课程概论</a></th></tr></thead><tbody><tr><td align="center"><strong><a href="/2021/02/%E6%B5%99%E6%B1%9F%E5%A4%A7%E5%AD%A6%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E8%AF%BE%E7%A8%8BPart2/">Part2——支持向量机</a></strong></td></tr><tr><td align="center"><strong><a href="/2021/02/%E6%B5%99%E6%B1%9F%E5%A4%A7%E5%AD%A6%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E8%AF%BE%E7%A8%8BPart3/">Part3——人工神经网络</a></strong></td></tr><tr><td align="center"><strong><a href="/2021/02/%E6%B5%99%E6%B1%9F%E5%A4%A7%E5%AD%A6%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E8%AF%BE%E7%A8%8BPart4/">Part4——深度学习</a></strong></td></tr><tr><td align="center"><strong><a href="/2021/02/%E6%B5%99%E6%B1%9F%E5%A4%A7%E5%AD%A6%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E8%AF%BE%E7%A8%8BPart5/">Part5——强化学习</a></strong></td></tr><tr><td align="center"><strong><a href="/2021/02/%E6%B5%99%E6%B1%9F%E5%A4%A7%E5%AD%A6%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E8%AF%BE%E7%A8%8BPart6/">Part6——传统的机器学习</a></strong></td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 浙江大学机器学习课程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浙江大学机器学习课程Part6</title>
      <link href="/2021/02/%E6%B5%99%E6%B1%9F%E5%A4%A7%E5%AD%A6%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E8%AF%BE%E7%A8%8BPart6/"/>
      <url>/2021/02/%E6%B5%99%E6%B1%9F%E5%A4%A7%E5%AD%A6%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E8%AF%BE%E7%A8%8BPart6/</url>
      
        <content type="html"><![CDATA[<h1 id="浙江大学机器学习课程Part6——传统的机器学习"><a href="#浙江大学机器学习课程Part6——传统的机器学习" class="headerlink" title="浙江大学机器学习课程Part6——传统的机器学习"></a>浙江大学机器学习课程Part6——传统的机器学习</h1><p>[TOC]</p><h2 id="特征选择与特征提取"><a href="#特征选择与特征提取" class="headerlink" title="特征选择与特征提取"></a>特征选择与特征提取</h2><p>特征选择与特征提取(Feature Selection and Extraction)</p><p>特征选择是一个”物理”过程，不会产生新特征；特征提取是一个”化学”过程，会产生新特征。</p><ol><li>特征提取：主成分分析(Principle Component Analysis)</li><li>特征选择：自适应提升(AdaBoost)</li></ol><h2 id="主成分分析"><a href="#主成分分析" class="headerlink" title="主成分分析"></a>主成分分析</h2><h3 id="主成分分析与神经网络"><a href="#主成分分析与神经网络" class="headerlink" title="主成分分析与神经网络"></a>主成分分析与神经网络</h3><p>多层的神经网络，其本质也是一个特征提取器。但是，主成分分析主要目标是减少计算量。</p><p>主成分分析：构造一个A，b使：Y<del>(M*1)</del> = A<del>(M*N)</del> * X<del>(N*1)</del> + b<del>(M*1)</del></p><p>主成分分析可以看成是一个一层的，有m个神经元的神经网络。</p><h3 id="主成分分析的过程"><a href="#主成分分析的过程" class="headerlink" title="主成分分析的过程"></a>主成分分析的过程</h3><p>主成分分析：寻找方差最大的方向，并在该方向投影。在降维的同时保存最大的区分度。</p><p>这里方差最大方向指的是投影之后方差和最大，因为如果投影之后点都汇集在一起的话，那么可以近似成一个点，就区分不出来了。</p><p><a href="https://www.bilibili.com/video/BV1dJ411B7gh?p=38">主成分分析详细推导P38</a></p><ol><li><p>最大化寻找的特征方向上的方差和。</p><p>max： a<del>1</del>∑a<del>1</del>^T^=λ；s.t.：a<del>1</del>*a<del>1</del>^T^=||a<del>1</del>||^2^=1 (a<del>i</del>是A的行向量)</p></li><li><p>寻找下方差和最大化的特征方向，并且需要与刚才的方向正交。</p><p>max： a<del>2</del>∑a<del>2</del>^T^=λ；s.t.：a<del>2</del>*a<del>2</del>^T^=||a<del>2</del>||^2^=1、a<del>1</del>*a<del>2</del>^T^=a<del>2</del>*a<del>1</del>^T^=0</p></li><li><p>a<del>2</del>是∑的特征向量，λ是∑的第二大特征值</p></li><li><p>loop</p></li></ol><h3 id="PCA算法全程"><a href="#PCA算法全程" class="headerlink" title="PCA算法全程"></a>PCA算法全程</h3><ol><li><p>求 ∑=∑<del>i=1</del>^i^(X<del>i</del>-E(x))^T^</p></li><li><p>求∑的特征值并从大到小排序[λ<del>1</del>, λ<del>1</del>, λ<del>2</del>,…, λ<del>M</del>, λ<del>M+1</del>,… ]</p><p>对应特征向量[a<del>1</del>^T^, a<del>2</del>^T^, …, a<del>M</del>^T^, a<del>M+1</del>^T^, …]</p></li><li><p>归一化所有a<del>i</del>，使a<del>i</del>a<del>i</del>^T^=1</p></li><li><p>A=[[–a<del>1</del>–],[–a<del>2</del>–],…,[–a<del>m</del>–]]</p></li><li><p>Y<del>i</del>=A(X<del>i</del>-E(X))</p></li></ol><h3 id="其他算法"><a href="#其他算法" class="headerlink" title="其他算法"></a>其他算法</h3><p>奇异值分解SVD(Singular Value Decomposation)快速求出特征值来完成PCA算法。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>在特征数比较多，样本数又比较少的情况下，采用PCA，效果不会差。</p><h2 id="自适应提升-AdaBoost"><a href="#自适应提升-AdaBoost" class="headerlink" title="自适应提升(AdaBoost)"></a>自适应提升(AdaBoost)</h2><h3 id="特征选择"><a href="#特征选择" class="headerlink" title="特征选择"></a>特征选择</h3><p>从N个特征中选择M个使识别率更高。</p><p>（启发式方法，如模拟退火、基因算法）①递增法②递减法。不常用，因为神经网络已经做了这些事情，相关性不高的连线之间w会变得很小。</p><h3 id="自适应提升"><a href="#自适应提升" class="headerlink" title="自适应提升"></a>自适应提升</h3><p>针对大规模冗余的特征样本时，是一个非常好的算法。</p><p><a href="https://www.bilibili.com/video/BV1dJ411B7gh?p=39&spm_id_from=pageDriver">详细推导P39</a></p><ol><li>初始化采样权值</li><li>用D<del>m</del>采样N个样本（错的样本出现更多，对的样本出现更少），获得弱分类器</li><li>计算加权错误率</li><li>更新权值分布</li><li>-&gt; 2. loop </li><li>最终识别器</li></ol><p>定理：随着M增加，AdaBoost最终分类器在训练集上错误率越来越小。</p><p>AdaBoost过拟合速度不会上升太快。</p><h2 id="概率分类法-重点复习"><a href="#概率分类法-重点复习" class="headerlink" title="概率分类法==重点复习=="></a>概率分类法==重点复习==</h2><p>一定要特别注意先验概率！！！</p><h3 id="朴素贝叶斯"><a href="#朴素贝叶斯" class="headerlink" title="朴素贝叶斯"></a>朴素贝叶斯</h3><p><img src="/2021/02/%E6%B5%99%E6%B1%9F%E5%A4%A7%E5%AD%A6%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E8%AF%BE%E7%A8%8BPart6/image-20210213210453656.png" alt="image-20210213210453656"></p><p>限制条件：</p><ol><li>每个维度都是离散的</li><li>每个维度互相独立</li></ol><p>对于每个P(特征|类别)有：<br>$$<br>P(w|C_j)={count(w,C_j)+1\over{\sum\limits_{w∈V}cout(w,C_j)+|v|}}<br>$$<br>其中，C<del>j</del>指某个类别j，V指特征集合，|v|指特征数。</p><h3 id="高斯概率密度函数"><a href="#高斯概率密度函数" class="headerlink" title="高斯概率密度函数"></a>高斯概率密度函数</h3><p>正态分布（Normal distribution）又名高斯分布（Gaussian distribution）。</p><h4 id="多维高斯分布："><a href="#多维高斯分布：" class="headerlink" title="多维高斯分布："></a>多维高斯分布：</h4><p>$$<br>P(X|C)= {1\over{\sqrt[]{(1π)^d|∑|}}}exp[-{1\over2}(x-μ)^T∑^{-1}(x-μ)]<br>$$</p><p>已知{X<del>i</del>}<del>i={1-N}</del> ，求待求参数：∑(d×d矩阵)、μ(d×1向量)</p><p>构造目标函数（极大似然法Maximum Likedihood）<br>$$<br>E(μ,∑)=\sum\limits_{i=1}^NlnP(X_i|C)<br>$$<br>假设：①所有{X<del>i</del>}<del>i={1-N}</del>独立同分布 undependent and identical distribution ( i.i.d. )；②设定μ<del>1</del>、∑<del>1</del>使出现{X<del>i</del>}<del>i={1-N}</del>概率最大。</p><p>先是概率累乘作为似然函数，取对数方便运算，连乘就变成求和了</p><p><a href="https://www.bilibili.com/video/BV1dJ411B7gh?p=43">详细推导p43</a></p><h3 id="EM算法-Expectation-Maximization"><a href="#EM算法-Expectation-Maximization" class="headerlink" title="EM算法(Expectation-Maximization)"></a>EM算法(Expectation-Maximization)</h3><h4 id="混合高斯模型-Gaussian-Mixture-Model"><a href="#混合高斯模型-Gaussian-Mixture-Model" class="headerlink" title="混合高斯模型(Gaussian Mixture Model)"></a>混合高斯模型(Gaussian Mixture Model)</h4><p>叠加多个高斯分布拟合整个复杂的分布。</p><p>这是一个非凸问题，只能求局部极值，不能求全局极值。</p><p>求局部极值的一种方法，而且只对某一类局部极值问题可解。</p><p>优点：①不需要调任何参数，必定收敛②编程简单③理论优美</p><p>步骤：</p><ol><li>随机化，先假设类别</li><li>E-step 计算第n个样本在k个高斯的概率</li><li>M-step 更新所有N个样本中有多少个属于第k个高斯</li><li>-&gt;2 loop</li></ol><p><a href="https://www.bilibili.com/video/BV1dJ411B7gh?p=45">详细推导p45</a></p><p><a href="https://www.bilibili.com/video/BV1dJ411B7gh?p=48&spm_id_from=pageDriver">EM算法收敛性推导</a></p><h4 id="k-均值聚类-K-means-Clustering"><a href="#k-均值聚类-K-means-Clustering" class="headerlink" title="k-均值聚类(K-means Clustering)"></a>k-均值聚类(K-means Clustering)</h4><ol><li>随机化μ<del>1</del>、…、μ<del>k</del></li><li>E-step 离哪个类近，重新归属于哪一类</li><li>M-step n个样本中有多少个属于第k类，重新分配第k类的均值μ<del>k</del></li><li>-&gt;2 loop</li></ol><h2 id="GMM在说话人识别中的应用"><a href="#GMM在说话人识别中的应用" class="headerlink" title="GMM在说话人识别中的应用"></a>GMM在说话人识别中的应用</h2><ol><li>去除静音(将不说话的低能量片段去除，但保留同为低能量的辅音(使用过零率判别))</li><li>提取的特征：MEL倒谱系数 （Mel-frequency Cepstrum Coefficients, MFCC）</li></ol><p>缺点：对噪声要求严苛，因为加了噪声就相当于改变分布。</p>]]></content>
      
      
      <categories>
          
          <category> 浙江大学机器学习课程 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>浙江大学机器学习课程Part5</title>
      <link href="/2021/02/%E6%B5%99%E6%B1%9F%E5%A4%A7%E5%AD%A6%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E8%AF%BE%E7%A8%8BPart5/"/>
      <url>/2021/02/%E6%B5%99%E6%B1%9F%E5%A4%A7%E5%AD%A6%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E8%AF%BE%E7%A8%8BPart5/</url>
      
        <content type="html"><![CDATA[<h1 id="浙江大学机器学习课程Part5——强化学习"><a href="#浙江大学机器学习课程Part5——强化学习" class="headerlink" title="浙江大学机器学习课程Part5——强化学习"></a>浙江大学机器学习课程Part5——强化学习</h1><p>[TOC]</p><h2 id="增强学习与监督学习的区别"><a href="#增强学习与监督学习的区别" class="headerlink" title="增强学习与监督学习的区别"></a>增强学习与监督学习的区别</h2><ol><li>训练数据中没有标签，只有奖励函数（Reward Function）。</li><li>训练数据不是现成给定，而是由行为（Action）获得。</li><li>现在的行为（Action）不仅影响后续训练数据的获得，也影响奖励函数（Reward Function）的取值。</li><li>训练的目的是构建一个“<strong>状态-&gt;行为</strong>”*(内部状态和外部状态，外部状态不由我们的行为控制)*的函数，其中状态（State）描述了目前内部和外部的环境，在此情况下，要使一个智能体（Agent）在某个特定的状态下，通过这个函数，决定此时应该采取的行为。希望采取这些行为后，最终获得最大化的奖励函数值。</li></ol><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><ol><li>R<del>t</del>：t时刻的奖励函数</li><li>S<del>t</del>：t时刻的状态</li><li>A<del>t</del>：t时刻的行为</li></ol><h2 id="假设"><a href="#假设" class="headerlink" title="假设"></a>假设</h2><ol><li><p>马尔科夫假设：P[S<del>t+1</del>|S<del>t</del>]=P[S<del>t+1</del>|S1,…,S<del>t</del>]</p></li><li><p>下一个时刻的状态只与这一时刻的状态以及这一时刻的行为有关：</p><p>P<del>SS’</del>^a^=P[S<del>t+1</del>=s’|S<del>t</del>=s, A<del>t</del>=a]</p></li><li><p>下一时刻的奖励函数值值域这一时刻的状态以及这一时刻的行为有关：</p><p>P<del>S</del>^a^=E[R<del>t+1</del>|S<del>t</del>=s, A<del>t</del>=a]</p></li></ol><h2 id="Markov-decision-Process-MDP"><a href="#Markov-decision-Process-MDP" class="headerlink" title="Markov decision Process (MDP)"></a>Markov decision Process (MDP)</h2><ol><li>在t=0时候，环境给出一个初始状态 s ~ p(s<del>0</del>)</li><li>循环：<pre><code> -- 智能体选择行为：a~t~ -- 环境采样奖励函数：r~t~ ~ R( . |s~t~, a~t~) -- 环境产生下一个状态：s~t+1~ ~ R( . |s~t~, a~t~) -- 智能体获得奖励函数 r~t~ 和下一个状态 s~t+1~</code></pre></li><li>我们需要学习一个策略（Policy）π^*^(s<del>t</del>,a<del>t</del>)=P(a<del>t</del>|s<del>t</del>)   , 这是一个从状态到行为的映射函数，使得最大化累积的奖励。</li></ol><h2 id="Q-Learning"><a href="#Q-Learning" class="headerlink" title="Q-Learning"></a>Q-Learning</h2><h3 id="数学推导"><a href="#数学推导" class="headerlink" title="数学推导"></a>数学推导</h3><ol><li>增强学习中已经知道的的函数是：P<del>S</del>^a^=E[R<del>t+1</del>|S<del>t</del>=s, A<del>t</del>=a]</li><li>需要学习的函数是：P<del>SS’</del>^a^=P[S<del>t+1</del>=s’|S<del>t</del>=s, A<del>t</del>=a]</li><li>根据一个决策机制（Policy），我们可以获得一条路径：s<del>0</del> -&gt; a<del>0</del> -&gt; r<del>0</del> -&gt; s<del>1</del> -&gt; a<del>1</del> -&gt; r<del>1</del> …</li><li>定义1：估值函数（Value Function）是衡量某个状态最终能获得多少累积奖励的函数：<img src="/2021/02/%E6%B5%99%E6%B1%9F%E5%A4%A7%E5%AD%A6%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E8%AF%BE%E7%A8%8BPart5/image-20210210225702878.png" alt="image-20210210225702878"></li><li>定义2：Q函数是衡量某个状态下采取某个行为后，最终能获得多少累积奖励的函数：<img src="/2021/02/%E6%B5%99%E6%B1%9F%E5%A4%A7%E5%AD%A6%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E8%AF%BE%E7%A8%8BPart5/image-20210210225720116.png" alt="image-20210210225720116"></li><li>在s状态下做出行为a的概率，和这种情况下的奖励，得到估值 V^π^(s)=∑<del>a∈A</del>P(a|s)Q^π^(s,a)</li></ol><h3 id="劣势"><a href="#劣势" class="headerlink" title="劣势"></a>劣势</h3><ol><li>对于状态数和行为数很多时，使Q函数非常复杂，难以收敛。例如：①对一个ATARI游戏，状态数是相邻几帧所有像素的取值组合，这是一个天文数字；②图像方面的应用，状态数是(像素值取值范围数)^(像素个数)</li><li>很多程序，如下棋程序等，REWARD是最后获得（输或赢），不需要对每一个中间步骤都计算REWARD。</li></ol><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol><li><p>目前强化学习的发展状况：在一些特定的任务上达到人的水平或胜过人，但在一些相对复杂的任务上，例如自动驾驶等，和人存在差距。</p></li><li><p>和真人的差距，可能不完全归咎于算法。传感器、机械的物理限制等，也是决定性因素。</p></li><li><p>机器和人的另一差距是：人有一些基本的概念，依据这些概念，人能只需要很少的训练就能学会很多，但机器只有通过大规模数据，才能学会。</p></li><li><p>但是，机器速度快，机器永不疲倦，只要有源源不断的数据，在特定的任务上，机器做得比人好，是可以期待的。</p></li></ol><h2 id="Alpha-Go"><a href="#Alpha-Go" class="headerlink" title="Alpha Go"></a>Alpha Go</h2><p>围棋有必胜策略</p><p><img src="/2021/02/%E6%B5%99%E6%B1%9F%E5%A4%A7%E5%AD%A6%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E8%AF%BE%E7%A8%8BPart5/image-20210210235412124.png" alt="image-20210210235412124"></p><p><a href="https://github.com/Rochester-NRT/RocAlphaGo">Alpha Go 开源地址</a></p><p>每隔一定的轮次，训练过后的网络将和训练之前的网络对抗，已获得更多的样本数据继续训练。</p><p>另外有一个更加简单的深度策略网络(Rollout Policy Network)，牺牲准确率来换取速度，在对局后期通过不断演算，将赢的落子概率增加，输的概率减少。</p><p>蒙特卡洛树搜索 （Monte Carlo Tree Search）：多次模拟未来棋局，然后选择在模拟中选择次数最多的走法。</p><p>同时要采用多样化的步骤来增加随机性。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol><li><p>Reinforcement Learning an introduction. R. S. Sutton and A. G. Barto, 2005</p></li><li><p><a href="http://www0.cs.ucl.ac.uk/staff/d.silver/web/Teaching.html">UCL Course on RL</a></p></li><li><p>例程程序</p><p><a href="http://karpathy.github.io/2016/05/31/rl/?_utm_source=1-2-2">http://karpathy.github.io/2016/05/31/rl/?_utm_source=1-2-2</a><br><a href="https://gym.openai.com/https://github.com/openai/gym">https://gym.openai.com/https://github.com/openai/gym</a></p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 浙江大学机器学习课程 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>浙江大学机器学习课程Part4</title>
      <link href="/2021/02/%E6%B5%99%E6%B1%9F%E5%A4%A7%E5%AD%A6%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E8%AF%BE%E7%A8%8BPart4/"/>
      <url>/2021/02/%E6%B5%99%E6%B1%9F%E5%A4%A7%E5%AD%A6%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E8%AF%BE%E7%A8%8BPart4/</url>
      
        <content type="html"><![CDATA[<h1 id="浙江大学机器学习课程Part4——深度学习"><a href="#浙江大学机器学习课程Part4——深度学习" class="headerlink" title="浙江大学机器学习课程Part4——深度学习"></a>浙江大学机器学习课程Part4——深度学习</h1><p>[TOC]</p><h2 id="多层神经网络的优劣"><a href="#多层神经网络的优劣" class="headerlink" title="多层神经网络的优劣"></a>多层神经网络的优劣</h2><h3 id="多层神经网络的优势"><a href="#多层神经网络的优势" class="headerlink" title="多层神经网络的优势"></a>多层神经网络的优势</h3><ol><li>基本单元简单，多个基本单元可扩展为非常复杂的非线性函数。因此易于构建，同时模型有很强的表达能力。</li><li>训练和测试的计算并行性非常好，有利于在分布式系统上的应用。</li><li>模型构建来源于对人脑的仿生，话题丰富，各种领域的研究人员都有兴趣，都能做贡献。</li></ol><h3 id="多层神经网络的劣势"><a href="#多层神经网络的劣势" class="headerlink" title="多层神经网络的劣势"></a>多层神经网络的劣势</h3><ol><li>数学不漂亮，优化算法只能获得局部极值，算法性能与初始值有关。</li><li>不可解释。训练神经网络获得的参数与实际任务的关联性非常模糊。</li><li>模型可调整的参数很多 （网络层数、每层神经元个数、非线性函数、学习率、优化方法、终止条件等等），使得训练神经网络变成了一门“艺术”。</li><li>如果要训练相对复杂的网络，需要大量的训练样本。</li></ol><h2 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h2><ol><li>Mnist：手写数字数据库（LeCun 在1998年创造）</li><li>ImageNet：（Fei-fei Li等 2007年创造）</li></ol><h2 id="发展历史"><a href="#发展历史" class="headerlink" title="发展历史"></a>发展历史</h2><h3 id="现状"><a href="#现状" class="headerlink" title="现状"></a>现状</h3><p>神经网络是目前处理大数据最优的算法。</p><p>模拟退火和遗传算法还处于沉寂期。</p><h3 id="转机"><a href="#转机" class="headerlink" title="转机"></a>转机</h3><p>2006年是深度学习的起始年，Hinton在SCIENCE上发文，提出一种叫做自动编码机（Auto-encoder）的方法，部分解决了神经网络参数初始化的问题。</p><p>但是目前为止，自动编码机并没有什么用。</p><h2 id="卷积神经网络-CNN"><a href="#卷积神经网络-CNN" class="headerlink" title="卷积神经网络(CNN)"></a>卷积神经网络(CNN)</h2><h3 id="发展"><a href="#发展" class="headerlink" title="发展"></a>发展</h3><p>是深度学习神经网络流行起来最大的因素。</p><p>由手工设计卷积核变成自动学习卷积核。</p><h3 id="如何卷积"><a href="#如何卷积" class="headerlink" title="如何卷积"></a>如何卷积</h3><blockquote><p>一个讲解比较清晰的视频：<a href="https://www.bilibili.com/video/BV1JX4y1K7Dr">什么是卷积？</a></p></blockquote><p>详细图解原理在另一份笔记中，不重复记述：<a href="/2021/01/PyTorch%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%AE%9E%E8%B7%B5Part10/">PyTorch深度学习实践Part10</a></p><p><img src="/2021/02/%E6%B5%99%E6%B1%9F%E5%A4%A7%E5%AD%A6%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E8%AF%BE%E7%A8%8BPart4/image-20210210160012660.png" alt="image-20210210160012660"></p><p>卷积核的数量等于输出通道数。卷积核的长度等于输入通道数。</p><p>卷积过后得到的叫做特征图。</p><p>在边缘可能会丢失数据的时候，用padding补零。</p><h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><p><img src="/2021/02/%E6%B5%99%E6%B1%9F%E5%A4%A7%E5%AD%A6%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E8%AF%BE%E7%A8%8BPart4/image-20210210160114566.png" alt="image-20210210160114566"></p><p>卷积神经网络与全连接的区别。</p><ol><li>局部感受野</li><li>权值共享</li></ol><p>卷积虽然复杂，但是计算量更少。</p><h3 id="激活"><a href="#激活" class="headerlink" title="激活"></a>激活</h3><p>在卷积神经网络中，最常用的非线性函数为ReLu。</p><h3 id="后向传播"><a href="#后向传播" class="headerlink" title="后向传播"></a>后向传播</h3><p>导数会平均反向传播。</p><blockquote><p>整个网络的计算速度取决于卷积层，整个网络的参数个数取决于全连接层。</p><p>即：如果要加速神经网络，则在卷积层做文章；如果要让其内存占用更少的话，则在全连接层做文章。</p></blockquote><h2 id="AlexNet"><a href="#AlexNet" class="headerlink" title="AlexNet"></a>AlexNet</h2><h3 id="改进1——ReLU"><a href="#改进1——ReLU" class="headerlink" title="改进1——ReLU"></a>改进1——ReLU</h3><p>以ReLU函数代替sigmoid或tanh函数。</p><p><img src="/2021/02/%E6%B5%99%E6%B1%9F%E5%A4%A7%E5%AD%A6%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E8%AF%BE%E7%A8%8BPart4/image-20210210163727240.png" alt="image-20210210163727240"></p><p>实践证明，这样做能使网络训练以更快速度收敛。</p><blockquote><p>如果数据是靠近0的正态分布，则每次只激活一半的神经元。</p></blockquote><h3 id="改进2——MaxPooling"><a href="#改进2——MaxPooling" class="headerlink" title="改进2——MaxPooling"></a>改进2——MaxPooling</h3><p><img src="/2021/02/%E6%B5%99%E6%B1%9F%E5%A4%A7%E5%AD%A6%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E8%AF%BE%E7%A8%8BPart4/image-20210210163808698.png" alt="image-20210210163808698"></p><p>在AlexNet中，提出了最大池化(Max Pooling)的概念，即对每一个邻近像素组成的“池子”，选取像素最大值作为输出。在LeNet中，池化的像素是不重叠的；而在AlexNet中进行的是有重叠的池化。实践表明，有重叠的最大池化能够很好的克服过拟合问题，提升系统性能。</p><p>在反向传播时，只传播最大值，其他都为0。</p><blockquote><p>MaxPooling不仅是一个降采样的操作，同时还是一个非线性操作。只采用最大的神经元，有效降低了激活的神经元个数，从而加快了收敛的速率。</p></blockquote><h3 id="改进3——Dropout"><a href="#改进3——Dropout" class="headerlink" title="改进3——Dropout"></a>改进3——Dropout</h3><p>随机丢弃（Dropout）。为了避免系统参数更新过快导致过拟合，每次利用训练样本更新参数时候，随机的“丢弃”一定比例的神经元，被丢弃的神经元将不参加训练过程，输入和输出该神经元的权重系数也不做更新。这样每次训练时，训练的网络架构都不一样，而这些不同的网络架构却分享共同的权重系数。实验表明，随机丢弃技术减缓了网络收敛速度，也以大概率避免了过拟合的发生。</p><blockquote><p>道理和改进2一样，每次训练都只激活有限个神经元，而不要让整个网络同时改变所有的参数，导致整个网络不稳定。</p></blockquote><h3 id="改进4——增加训练样本"><a href="#改进4——增加训练样本" class="headerlink" title="改进4——增加训练样本"></a>改进4——增加训练样本</h3><p>增加训练样本。尽管ImageNet的训练样本数量有超过120万幅图片，但相对于6亿待估计参数来说，训练图像仍然不够。Alex等人采用了多种方法增加训练样本，包括：1. 将原图水平翻转；2. 将256×256的图像随机选取224×224的片段作为输入图像。运用上面两种方法的组合可以将一幅图像变为2048幅图像。还可以对每幅图片引入一定的噪声，构成新的图像。这样做可以较大规模增加训练样本，避免由于训练样本不够造成的性能损失。</p><h3 id="改进5——GPU加速"><a href="#改进5——GPU加速" class="headerlink" title="改进5——GPU加速"></a>改进5——GPU加速</h3><p>用GPU加速训练过程。采用2片GTX 580 GPU对训练过程进行加速，由于GPU强大的并行计算能力，使得训练过程的时间缩短数十倍，哪怕这样，训练时间仍然用了六天。</p><h2 id="近年来流行的网络结构"><a href="#近年来流行的网络结构" class="headerlink" title="近年来流行的网络结构"></a>近年来流行的网络结构</h2><h3 id="VGGNet-（Simonyan-and-Zisserman-2014）"><a href="#VGGNet-（Simonyan-and-Zisserman-2014）" class="headerlink" title="VGGNet: （Simonyan and Zisserman, 2014）"></a>VGGNet: （Simonyan and Zisserman, 2014）</h3><p>3个叠到一起的3 * 3卷积核，感受野（Receptive Field）是7 * 7,大致可以替代7 * 7卷积核的作用。但这样做可以使参数更少 ，参数比例大致为27:49。</p><p>但是，运算速度会因为卷积核数量的增加而大幅下降。</p><p><img src="/2021/02/%E6%B5%99%E6%B1%9F%E5%A4%A7%E5%AD%A6%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E8%AF%BE%E7%A8%8BPart4/image-20210210173031450.png" alt="image-20210210173031450"></p><h3 id="GoogLeNet-（Szegedy-2014）"><a href="#GoogLeNet-（Szegedy-2014）" class="headerlink" title="GoogLeNet: （Szegedy, 2014）"></a>GoogLeNet: （Szegedy, 2014）</h3><p>inception 结构，用一些1<em>1, 3</em>3和5*5的小卷积核用固定方式组合到一起，来代替大的卷积核，从而达到增加感受野和减少参数的目的。500万参数，比ALEXNET小了12倍。</p><p><img src="/2021/02/%E6%B5%99%E6%B1%9F%E5%A4%A7%E5%AD%A6%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E8%AF%BE%E7%A8%8BPart4/image-20210210173440780.png" alt="image-20210210173440780"></p><h3 id="残差网络Residual-Net-ResNet-（He-et-al-2015）"><a href="#残差网络Residual-Net-ResNet-（He-et-al-2015）" class="headerlink" title="残差网络Residual Net(ResNet): （He et al, 2015）"></a>残差网络Residual Net(ResNet): （He et al, 2015）</h3><p>加入了前向输入机制，将前面层获得的特征图作为监督项输入到后面层。用这样的方法使深层网络训练能够更好地收敛。</p><p><img src="/2021/02/%E6%B5%99%E6%B1%9F%E5%A4%A7%E5%AD%A6%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E8%AF%BE%E7%A8%8BPart4/image-20210210183347601.png" alt="image-20210210183347601"></p><h2 id="迁移学习-Transfer-Learning"><a href="#迁移学习-Transfer-Learning" class="headerlink" title="迁移学习(Transfer Learning )"></a>迁移学习(Transfer Learning )</h2><p>迁移学习是指，从一个domain训练好的神经网络，加入新的domain的样本进行调优，从而获得一个更好的识别效果。</p><p>例如，训练好的 Alex Net ，在最后的1k个分类后，外加一层全连接神经网络，输出十几种水果的分类，用十种水果进行调优。虽然这原本1k个分类中或许没有很明显的这十几种水果分类，但这样它能很容易排除除了这些水果以外的物品，同时经过调优之后会更容易贴合我们想要分出的十几种水果。</p><h2 id="目标检测与分割"><a href="#目标检测与分割" class="headerlink" title="目标检测与分割"></a>目标检测与分割</h2><p>这里其实算深度学习（</p><p><img src="/2021/02/%E6%B5%99%E6%B1%9F%E5%A4%A7%E5%AD%A6%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E8%AF%BE%E7%A8%8BPart4/image-20210211213322900.png" alt="image-20210211213322900"></p><h3 id="目标定位与识别"><a href="#目标定位与识别" class="headerlink" title="目标定位与识别"></a>目标定位与识别</h3><p><img src="/2021/02/%E6%B5%99%E6%B1%9F%E5%A4%A7%E5%AD%A6%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E8%AF%BE%E7%A8%8BPart4/image-20210211213742143.png" alt="image-20210211213742143"></p><h3 id="目标检测"><a href="#目标检测" class="headerlink" title="目标检测"></a>目标检测</h3><p>在一幅图片中可能有多种类别，不能确定数量。</p><p>现在这个问题基本解决，有三篇逐步递进的三篇论文。</p><h4 id="Regional-CNN-R-CNN"><a href="#Regional-CNN-R-CNN" class="headerlink" title="Regional CNN(R-CNN)"></a>Regional CNN(R-CNN)</h4><p>目标候选区域(Region Proposal)：先用传统方法或者图像处理的方法，确定可能有物体的地方候选项，再放在卷积神经网络检测。</p><h5 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h5><ol><li>Selective Search：产生RP</li><li>CNN：检测这些候选区域</li><li>SVM：分类</li></ol><p><img src="/2021/02/%E6%B5%99%E6%B1%9F%E5%A4%A7%E5%AD%A6%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E8%AF%BE%E7%A8%8BPart4/image-20210211222650735.png" alt="image-20210211222650735"></p><h5 id="缺陷"><a href="#缺陷" class="headerlink" title="缺陷"></a>缺陷</h5><ol><li>High cost to perform Selective Search (~5s per image)</li><li>Too many passes to CNN (~2000 proposals per image)</li><li>Lead to unacceptable test time (~50s per image)</li><li>High space cost to train SVM (millions of 1024-d features)</li></ol><h4 id="Fast-R-CNN"><a href="#Fast-R-CNN" class="headerlink" title="Fast R-CNN"></a>Fast R-CNN</h4><p>用 Regions of Interest(RoIs) 把不同长宽的候选区域，在Pooling层归一化成同一形状。最后依然是一路预测label，一路预测Bounding-box regressors。</p><p><img src="/2021/02/%E6%B5%99%E6%B1%9F%E5%A4%A7%E5%AD%A6%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E8%AF%BE%E7%A8%8BPart4/image-20210211224649852.png" alt="image-20210211224649852"></p><h5 id="Faster-R-CNN"><a href="#Faster-R-CNN" class="headerlink" title="Faster R-CNN"></a>Faster R-CNN</h5><p>主要通过小的Region Proposal Network产生粗略位置，来代替Selective Search</p><p><img src="/2021/02/%E6%B5%99%E6%B1%9F%E5%A4%A7%E5%AD%A6%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E8%AF%BE%E7%A8%8BPart4/image-20210211221620685.png" alt="image-20210211221620685"></p><h3 id="语义分割"><a href="#语义分割" class="headerlink" title="语义分割"></a>语义分割</h3><h4 id="全卷积网络FCN"><a href="#全卷积网络FCN" class="headerlink" title="全卷积网络FCN"></a>全卷积网络FCN</h4><p>全卷积网络(Fully Convolutional Networks)</p><p>先训练前面一半，再训练后一半。先降采样，后升采样。</p><p>卷积层的上采样（Upsampling）也叫反卷积（Deconvolution）或 转置卷积（Transpose Convolution）。</p><p>全卷积网络也可以用于边缘提取。</p><p><img src="/2021/02/%E6%B5%99%E6%B1%9F%E5%A4%A7%E5%AD%A6%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E8%AF%BE%E7%A8%8BPart4/image-20210211230604746.png" alt="image-20210211230604746"></p><h2 id="隐含马尔科夫过程-HMM-与递归神经网络-RNN"><a href="#隐含马尔科夫过程-HMM-与递归神经网络-RNN" class="headerlink" title="隐含马尔科夫过程(HMM)与递归神经网络(RNN)"></a>隐含马尔科夫过程(HMM)与递归神经网络(RNN)</h2><p>对连续信息的判断有几个问题：不知道如何划分每一个状态，因为①持续时间可能各不相同；②对于语音模型的建模是以一个音节而不是一个单词为基础。</p><h3 id="Hidden-Markov-Models-复习"><a href="#Hidden-Markov-Models-复习" class="headerlink" title="Hidden Markov Models==复习=="></a>Hidden Markov Models==复习==</h3><p>一个HMM模型是由三部分组成：λ = {A, B, π}。其中，A为状态转移矩阵，B为观测概率，π为状态先验概率。</p><ol><li>π(S<del>i</del>)表示一开始在S<del>i</del>状态的概率。</li><li>A是一个P×P的矩阵。马尔科夫链假设是强假设，后一个时刻状态和前一个(或者多个)时刻状态有关（注意这是固定假设 a<del>i,j</del>=P(q<del>t+1</del>=S<del>j</del>|q<del>t</del>=S<del>i</del>)。当t时刻的q样本是状态为S<del>i</del>类，则在t+1时刻q样本转变为状态为S<del>j</del>类的概率）</li><li>B={b<del>j</del>(0)} 若输入向量O属于S<del>j</del>，则它的概率分布用b<del>j</del>(0)表示。</li></ol><p><a href="https://www.bilibili.com/video/BV1dJ411B7gh?p=50">详细推导p50</a></p><h3 id="大词汇量连续语音识别（LVCSR）"><a href="#大词汇量连续语音识别（LVCSR）" class="headerlink" title="大词汇量连续语音识别（LVCSR）"></a>大词汇量连续语音识别（LVCSR）</h3><p>大词汇量连续语音识别（Large-scale Vocabulary Continuous Speech Recognition, LVCSR）</p><ol><li>每一个HMM模型所表达的“单词”是什么？英语中有效的Triphone个数大致在55000左右，模型过多而训练样本不足，所以需要多个Triphone 合并（Tying）、多个Triphone 联合训练（Tying）</li><li>在识别流程中如何对测试声音文件做时间轴的划分，使每一个分段（SEGMENT）对应一个“单词”？如何搜索最佳的“单词”组合？VITERBI搜索（有多种形式，如Two-Level Dynamic Programming）、A*搜索、随机搜索</li><li>如何构造语言模型 (Language Model)? 定义(N-gram): 一个单词出现的概率，只与它前面的N个单词相关。</li></ol><h3 id="结合深度网络模型的语音识别"><a href="#结合深度网络模型的语音识别" class="headerlink" title="结合深度网络模型的语音识别"></a>结合深度网络模型的语音识别</h3><p><img src="/2021/02/%E6%B5%99%E6%B1%9F%E5%A4%A7%E5%AD%A6%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E8%AF%BE%E7%A8%8BPart4/image-20210214220419460.png" alt="image-20210214220419460"></p><h3 id="Recurrent-Neural-Network"><a href="#Recurrent-Neural-Network" class="headerlink" title="Recurrent Neural Network"></a>Recurrent Neural Network</h3><h4 id="输入与输出多对多："><a href="#输入与输出多对多：" class="headerlink" title="输入与输出多对多："></a>输入与输出多对多：</h4><p>大词汇连续语音识别、机器翻译</p><p><img src="/2021/02/%E6%B5%99%E6%B1%9F%E5%A4%A7%E5%AD%A6%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E8%AF%BE%E7%A8%8BPart4/image-20210214215442390.png" alt="image-20210214215442390"></p><h4 id="输入与输出多对一："><a href="#输入与输出多对一：" class="headerlink" title="输入与输出多对一："></a>输入与输出多对一：</h4><p>动作识别、行为识别、单词量有限的语音识别</p><p><img src="/2021/02/%E6%B5%99%E6%B1%9F%E5%A4%A7%E5%AD%A6%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E8%AF%BE%E7%A8%8BPart4/image-20210214215758906.png" alt="image-20210214215758906"></p><h4 id="输入与输出一对多："><a href="#输入与输出一对多：" class="headerlink" title="输入与输出一对多："></a>输入与输出一对多：</h4><p>文本生成、图像文字标注</p><p><img src="/2021/02/%E6%B5%99%E6%B1%9F%E5%A4%A7%E5%AD%A6%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E8%AF%BE%E7%A8%8BPart4/image-20210214215916422.png" alt="image-20210214215916422"></p><h3 id="Long-Short-Term-Memory-LSTM"><a href="#Long-Short-Term-Memory-LSTM" class="headerlink" title="Long-Short Term Memory (LSTM)"></a>Long-Short Term Memory (LSTM)</h3><p>相比VANILLA RNN， LSTM的误差反向传播更方便和直接，梯度更新不存在RNN中的暴涨或消失现象。因此，建议涉及RNN的应用都用LSTM或LSTM相关的变种。</p><p><img src="/2021/02/%E6%B5%99%E6%B1%9F%E5%A4%A7%E5%AD%A6%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E8%AF%BE%E7%A8%8BPart4/image-20210214221615263.png" alt="image-20210214221615263"></p>]]></content>
      
      
      <categories>
          
          <category> 浙江大学机器学习课程 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>浙江大学机器学习课程Part3</title>
      <link href="/2021/02/%E6%B5%99%E6%B1%9F%E5%A4%A7%E5%AD%A6%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E8%AF%BE%E7%A8%8BPart3/"/>
      <url>/2021/02/%E6%B5%99%E6%B1%9F%E5%A4%A7%E5%AD%A6%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E8%AF%BE%E7%A8%8BPart3/</url>
      
        <content type="html"><![CDATA[<h1 id="浙江大学机器学习课程Part3——人工神经网络"><a href="#浙江大学机器学习课程Part3——人工神经网络" class="headerlink" title="浙江大学机器学习课程Part3——人工神经网络"></a>浙江大学机器学习课程Part3——人工神经网络</h1><p>[TOC]</p><h2 id="神经网络的生物及数学模型"><a href="#神经网络的生物及数学模型" class="headerlink" title="神经网络的生物及数学模型"></a>神经网络的生物及数学模型</h2><ol><li>硬件算力的提升</li><li>数据样本的增加</li><li>但是，<strong>其最基本的神经元模型至今没有重大改变</strong></li></ol><p><img src="/2021/02/%E6%B5%99%E6%B1%9F%E5%A4%A7%E5%AD%A6%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E8%AF%BE%E7%A8%8BPart3/image-20210209144613134.png" alt="image-20210209144613134"></p><h2 id="感知器算法-Perceptron-Algorithm"><a href="#感知器算法-Perceptron-Algorithm" class="headerlink" title="感知器算法(Perceptron Algorithm)"></a>感知器算法(Perceptron Algorithm)</h2><p><img src="/2021/02/%E6%B5%99%E6%B1%9F%E5%A4%A7%E5%AD%A6%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E8%AF%BE%E7%A8%8BPart3/image-20210209144950398.png" alt="image-20210209144950398"></p><ul><li>效果比SVM差得多，但是是机器学习最早提出的算法。</li><li>感知器每次只取单个样本，SVM从全局样本考虑。</li></ul><p><a href="https://www.bilibili.com/video/BV1dJ411B7gh?p=20">收敛性证明看p20</a></p><h2 id="多层神经网络-Multi-Layer-Neural-Networks"><a href="#多层神经网络-Multi-Layer-Neural-Networks" class="headerlink" title="多层神经网络(Multi-Layer Neural Networks)"></a>多层神经网络(Multi-Layer Neural Networks)</h2><p>线性不可分的数据集困扰了早期神经网络算法长达十年之久。</p><p>因此，我们需要用非线性的函数集合来分开非线性可分的数据集。</p><p><img src="/2021/02/%E6%B5%99%E6%B1%9F%E5%A4%A7%E5%AD%A6%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E8%AF%BE%E7%A8%8BPart3/image-20210209160042159.png" alt="image-20210209160042159"></p><p>二层神经网络模型举例。</p><h2 id="三层神经网络模拟任意决策面"><a href="#三层神经网络模拟任意决策面" class="headerlink" title="三层神经网络模拟任意决策面"></a>三层神经网络模拟任意决策面</h2><p>我个人认为：过了第一层，数据样本基本不会保持原貌，但是保留了特征，或者说特点。</p><p>在老师画的示例中，实际的数学意义为：①第一层是：坐标(x,y)进入多个函数输入相对位置，进入激活函数输出0-1；②第二层：根据上一层判断的0-1，进入函数判断是否为某一块图形内部，返回0-1；③第三层：根据上一层返回的是否在某图形内部的0-1，进入函数判断该图形是否为class1，通过或关系，输出最终结果0-1.</p><p>详情见<a href="https://www.bilibili.com/video/BV1dJ411B7gh?p=23">p23</a></p><h2 id="后向传播算法-Back-Propagation"><a href="#后向传播算法-Back-Propagation" class="headerlink" title="后向传播算法(Back Propagation)"></a>后向传播算法(Back Propagation)</h2><blockquote><p>在对于某种问题，我们究竟应该选择哪一种参数组合，如何搭建完美的网络结构。这依然是一个至今为止不完备的，对于一种问题，最好的方法还是不断试验。</p></blockquote><p>主要思想就是梯度向下法(Gradient Descent Method)来求局部极值。</p><p>常用的激活函数：sigmoid、tanh、ReLu(Rectified Linear Units)、LeakReLu</p><p><a href="https://www.bilibili.com/video/BV1dJ411B7gh?p=24">==BP推导P24==</a></p><h2 id="参数设置"><a href="#参数设置" class="headerlink" title="参数设置"></a>参数设置</h2><h3 id="随机梯度下降"><a href="#随机梯度下降" class="headerlink" title="随机梯度下降"></a>随机梯度下降</h3><ol><li>不用每输入一个样本就去变换参数，而是输入一批样本（叫做一个BATCH或MINI-BATCH），求出这些样本的梯度平均值后，根据这个平均值改变参数。</li><li>在神经网络训练中，BATCH的样本数大致设置为50-200不等。  </li></ol><h3 id="激活函数"><a href="#激活函数" class="headerlink" title="激活函数"></a>激活函数</h3><p><img src="/2021/02/%E6%B5%99%E6%B1%9F%E5%A4%A7%E5%AD%A6%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E8%AF%BE%E7%A8%8BPart3/image-20210210140226760.png" alt="image-20210210140226760"></p><h3 id="梯度消失与归一化"><a href="#梯度消失与归一化" class="headerlink" title="梯度消失与归一化"></a>梯度消失与归一化</h3><ol><li>当样本都非常大或者非常小，在sigmoid函数中就可以发现，他们的梯度将会非常小，这样意味着他们更加符合我们想要得到的预测结果，即二分类。但是这并不是我们在训练过程中想要的，因为梯度太小而导致参数无法更新以进行训练。</li><li>防止梯度消失，那么就需要使样本更加靠近在0附近，更加具有像线性模型一样的特性。因此我们经常对<strong>初</strong>始数据以及在<strong>训练过程中</strong>进行归一化Batch Normalization。</li></ol><h3 id="目标函数选择"><a href="#目标函数选择" class="headerlink" title="目标函数选择"></a>目标函数选择</h3><ol><li><p>SOFTMAX函数</p><p><img src="/2021/02/%E6%B5%99%E6%B1%9F%E5%A4%A7%E5%AD%A6%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E8%AF%BE%E7%A8%8BPart3/image-20210210131234229.png" alt="image-20210210131234229"> 处理多分类</p></li><li><p>交叉熵(Cross Entropy)</p><p><img src="/2021/02/%E6%B5%99%E6%B1%9F%E5%A4%A7%E5%AD%A6%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E8%AF%BE%E7%A8%8BPart3/image-20210210131306125.png" alt="image-20210210131306125"> 处理二分类</p></li></ol><h3 id="参数更新策略"><a href="#参数更新策略" class="headerlink" title="参数更新策略"></a>参数更新策略</h3><p>优化器不一定是MSE，因为MSE的更新通常容易出现z字路径，一般可以选择使用其他更加平滑的优化器，比如AdaGrad、RMSProp。</p>]]></content>
      
      
      <categories>
          
          <category> 浙江大学机器学习课程 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>浙江大学机器学习课程Part2</title>
      <link href="/2021/02/%E6%B5%99%E6%B1%9F%E5%A4%A7%E5%AD%A6%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E8%AF%BE%E7%A8%8BPart2/"/>
      <url>/2021/02/%E6%B5%99%E6%B1%9F%E5%A4%A7%E5%AD%A6%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E8%AF%BE%E7%A8%8BPart2/</url>
      
        <content type="html"><![CDATA[<h1 id="浙江大学机器学习课程Part2——支持向量机"><a href="#浙江大学机器学习课程Part2——支持向量机" class="headerlink" title="浙江大学机器学习课程Part2——支持向量机"></a>浙江大学机器学习课程Part2——支持向量机</h1><p>[TOC]</p><h2 id="Support-Vector-Machine"><a href="#Support-Vector-Machine" class="headerlink" title="Support Vector Machine"></a>Support Vector Machine</h2><h3 id="支持向量机"><a href="#支持向量机" class="headerlink" title="支持向量机"></a>支持向量机</h3><p>对样本数较少的时候，都会得到一个比较好的结果。</p><p>如何在两种训练集上画一条直线来分类：</p><ol><li>线性可分(Linear Separable)训练样本集</li><li>非线性可分(Non-Linear Separable)样本集</li></ol><p>将线(在多维特征下是超平面Hyperplane)向两边移动直到擦到样本点，其中间隔(Margin)最大，且线在d/2处。</p><h3 id="数学描述"><a href="#数学描述" class="headerlink" title="数学描述"></a>数学描述</h3><ol><li>将平行线擦到的向量称作支持向量(Support Vector)</li><li>训练数据及标签：(Xn, Yn)…… X为特征向量，Y为标签。Y取+1或-1来表示，方便推导。</li><li>线性模型：(W, b) 超平面：Wt * X + b = 0</li></ol><h3 id="机器学习过程"><a href="#机器学习过程" class="headerlink" title="机器学习过程"></a>机器学习过程</h3><ol><li>用复杂的函数来限定模型框架</li><li>留出待定参数</li><li>用训练样本来确定参数取值</li></ol><h3 id="线性可分的定义和条件"><a href="#线性可分的定义和条件" class="headerlink" title="线性可分的定义和条件"></a>线性可分的定义和条件</h3><p>{(Xi, Yi)}i = 1<del>N, 存在(W, b), 则对任意 i = 1</del>N. 有：</p><p>①若Yi = +1, 则 Wt * X + b &gt; 0</p><p>②若Yi = -1, 则 Wt * X + b &lt; 0</p><p>为什么要取Y=±1？因为可以得到①②等价于 Yi ( Wt * X + b ) &gt; 0</p><h2 id="优化问题-优化目标函数和限制条件"><a href="#优化问题-优化目标函数和限制条件" class="headerlink" title="优化问题(优化目标函数和限制条件)"></a>优化问题(优化目标函数和限制条件)</h2><h3 id="两个要点"><a href="#两个要点" class="headerlink" title="两个要点"></a>两个要点</h3><ol><li>点最小化(Minimize / min): 1 / 2 * ||W||² 。<strong>这里1/2只是为了求导方便</strong></li><li>限制条件(Subject to / s.t.): Y<del>i</del> ( W^T^ * X + b ) ≥ 1, (i=1~N)</li></ol><h3 id="两个事实"><a href="#两个事实" class="headerlink" title="两个事实"></a>两个事实</h3><p>事实1：W^T^ * X + b = 0 与 a * W^T^ * X + a * b = 0, (a∈R+) 是同一个平面。</p><p>​           即: 若 (W, b) 满足 W^T^ * X + b = 0 , 则 (a * W, a * b) 也满足 W^T^ * X + b = 0 </p><p>事实2：向量到超平面(点到平面)的距离公式。d = | Wt * X0 + b | / || W || *<em>1.这里的X0代表的是包含多个维度的坐标[x,y,z…]，而Y0是分类标签，不能与坐标混为一谈；2.Wt</em>X0结果是一个数而不是矩阵向量**</p><p>​           其中，模 || W || = √(W1²+W2²…+Wn²)</p><h3 id="推导"><a href="#推导" class="headerlink" title="推导"></a>推导</h3><ol><li>用a去缩放超平面参数：(W, b) &lt;=&gt; ( a * W, a * b )。根据事实1，这两组不同的参数代表的是同一个平面。</li><li>最终使在支持向量上：| W^T^ * X<del>0</del> + b | = 1。<strong>这里的W和b都是经过系数a缩放过后的，目的是为了凑出1(当然你可以凑出任意常数)，而a具体是多少，我们不需要关注。需要注意的是，这里只是带入支持向量的值，并不是指支持向量的那个点在超平面上，否则值为0。</strong></li><li>由<em>推导2</em>和<em>事实2</em>可得：d = | W^T^ * X<del>0</del> + b | / || W || = 1 / || W ||。可得<em>要点1</em>：最小化 ||W|| 即最大化 d 。</li><li>其他不是支持向量的点到超平面的距离，则大于 1 / || W || 。可得 | W^T^ * X<del>0</del> + b | &gt; 1 。可得<em>要点2</em>：限制条件 Y<del>i</del> * ( W^T^ * X + b ) ≥ 1</li></ol><p>举例：原来平面是 W^T^ * X + b = 0 , 假设带入X<del>0</del>后的值 | W^T^ * X<del>0</del> + b | = M , 现在把超平面缩放为 a * W^T^ * X + a * b = 0 , 其中a是1/M, 那么把X<del>0</del>带入则 | a * W^T^ * X<del>0</del> + a * b | = M/M = 1。与此同时，计算d的时候，因为分子分母同乘a=1/M，a不需要求出，所以我们不需要关心a的取值，只是为了凑一个 | W^T^ * X<del>0</del> + b | = 1 ，当然你可以凑出任意常数。</p><h3 id="二次优化问题-Quadratic-Programming"><a href="#二次优化问题-Quadratic-Programming" class="headerlink" title="二次优化问题(Quadratic Programming)"></a>二次优化问题(Quadratic Programming)</h3><p>二次优化问题属于凸优化问题</p><ol><li>目标函数(Obejective Function)是二次项</li><li>限制条件是一次项</li></ol><p>要么无解，要么只有唯一极值。即局部极值就是全局极值。</p><h3 id="SVM处理非线性"><a href="#SVM处理非线性" class="headerlink" title="SVM处理非线性"></a>SVM处理非线性</h3><img src="/2021/02/%E6%B5%99%E6%B1%9F%E5%A4%A7%E5%AD%A6%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E8%AF%BE%E7%A8%8BPart2/image-20210207133321372.png" alt="image-20210207133321372" style="zoom: 200%;"><p>处理这种问题的一种方案就是加上正则项(Regulation Term)（结构损失函数），在解集合中挑选出一组参数（解），使经验损失和结构损失都较低。</p><p>c是正则化的强度，是事先设定好的超参数。</p><p>ζ是松弛变量(Slack Variable)。</p><p>放到场景中就是，样本数小于参数量，在只优化经验误差函数的时候很容易发生过拟合。这个公式依然可以适用于处理线性Linear SVM。</p><h2 id="低维到高维映射"><a href="#低维到高维映射" class="headerlink" title="低维到高维映射"></a>低维到高维映射</h2><p>在低维空间中，一些线性不可分的数据集，在高维空间中，更有可能被分开。因此可以把Xi通过函数φ(x)变换映射到高维空间，通过泛函分析满足某种条件，把核函数W*φ(x)拆成两个高维向量的内积。</p><h3 id="核函数"><a href="#核函数" class="headerlink" title="核函数"></a>核函数</h3><p>我们可以不在意无限维映射φ(x)的显示表达，我们只要知道一个核函数(kernel Function)，<img src="/2021/02/%E6%B5%99%E6%B1%9F%E5%A4%A7%E5%AD%A6%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E8%AF%BE%E7%A8%8BPart2/image-20210207142313276.png" alt="image-20210207142313276">，则优化问题仍然可解。</p><p>线性内核相当于没有用核。多项式核的待定系数d取越大，则越复杂。高斯核是无限维度，分类效果最高，待定系数为σ。Tanh核的待定参数是β和b。这些待定参数的选取只能不停地试。</p><p><img src="/2021/02/%E6%B5%99%E6%B1%9F%E5%A4%A7%E5%AD%A6%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E8%AF%BE%E7%A8%8BPart2/image-20210206144627709.png" alt="image-20210206144627709"></p><h3 id="充要条件"><a href="#充要条件" class="headerlink" title="充要条件"></a>充要条件</h3><p><img src="/2021/02/%E6%B5%99%E6%B1%9F%E5%A4%A7%E5%AD%A6%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E8%AF%BE%E7%A8%8BPart2/image-20210207142313276.png" alt="image-20210207142313276">能够成立的充要条件：(Mercer’s Theorem)</p><ol><li>K(X<del>1</del>, X<del>2</del>) = K(X<del>2</del>, X<del>1</del>) <strong>(交换性)</strong></li><li>对任意 常数C<del>i</del>, 向量X<del>i</del> (i=1<del>N)，有 ∑(i=1</del>N) ∑(j=1<del>N) C</del>i~ * C<del>j</del> * K(X<del>i</del>, X<del>j</del>) ≥ 0 <strong>(半正定性)</strong></li></ol><h2 id="原问题和对偶问题-重点复习"><a href="#原问题和对偶问题-重点复习" class="headerlink" title="原问题和对偶问题==(重点复习)=="></a>原问题和对偶问题==(重点复习)==</h2><h3 id="优化理论"><a href="#优化理论" class="headerlink" title="优化理论"></a>优化理论</h3><p>优化理论(运筹学)是工程里最本质的问题</p><h4 id="推荐书籍"><a href="#推荐书籍" class="headerlink" title="推荐书籍"></a>推荐书籍</h4><ol><li>Convex optimization - Stephen Boyd - b站吴立德</li><li>Nonlinear Programming</li></ol><h3 id="原问题-Prime-Problem"><a href="#原问题-Prime-Problem" class="headerlink" title="原问题(Prime Problem)"></a>原问题(Prime Problem)</h3><p>min: f(w)</p><p>s.t. : g<del>i</del>(w)≤0 (i=1<del>K) , h</del>i<del>(w)=0 (i=1</del>M)</p><h3 id="对偶问题-Dual-Problem"><a href="#对偶问题-Dual-Problem" class="headerlink" title="对偶问题(Dual Problem)"></a>对偶问题(Dual Problem)</h3><ol><li><p>定义：<img src="/2021/02/%E6%B5%99%E6%B1%9F%E5%A4%A7%E5%AD%A6%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E8%AF%BE%E7%A8%8BPart2/image-20210207153808814.png" alt="image-20210207153808814"></p><p>x是前面的w，α是一个K维的向量，β是一个M维的向量。</p><p>拉格朗日对偶问题是运筹学基础知识。*(KKT条件求解、拉格朗日传乘数法、弱对偶性定理)*</p></li><li><p>对偶问题定义：</p><p>max: <img src="/2021/02/%E6%B5%99%E6%B1%9F%E5%A4%A7%E5%AD%A6%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E8%AF%BE%E7%A8%8BPart2/image-20210207154702680.png" alt="image-20210207154702680">(inf:求最小值)</p><p>s.t. : λ<del>i</del> ≥ 0 (i=1~K)</p></li></ol><p><img src="/2021/02/%E6%B5%99%E6%B1%9F%E5%A4%A7%E5%AD%A6%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E8%AF%BE%E7%A8%8BPart2/image-20210207161614446.png" alt="p11-19:17"></p><p><img src="/2021/02/%E6%B5%99%E6%B1%9F%E5%A4%A7%E5%AD%A6%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E8%AF%BE%E7%A8%8BPart2/image-20210207162438113.png" alt="p11-22:56"></p><p><img src="/2021/02/%E6%B5%99%E6%B1%9F%E5%A4%A7%E5%AD%A6%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E8%AF%BE%E7%A8%8BPart2/image-20210207162758286.png" alt="p11-26:14"></p><p>这里可以去看《Convex optimization》前150页内容，学习推导过程。</p><p>结论可推出：</p><p><img src="/2021/02/%E6%B5%99%E6%B1%9F%E5%A4%A7%E5%AD%A6%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E8%AF%BE%E7%A8%8BPart2/image-20210207163413689.png" alt="image-20210207163413689"></p><h2 id="支持向量机原问题转化为对偶问题-重点复习"><a href="#支持向量机原问题转化为对偶问题-重点复习" class="headerlink" title="支持向量机原问题转化为对偶问题==(重点复习)=="></a>支持向量机原问题转化为对偶问题==(重点复习)==</h2><p>凸函数的定义。w可能是高维向量，这个代数表达在高维依然适用。</p><p><img src="/2021/02/%E6%B5%99%E6%B1%9F%E5%A4%A7%E5%AD%A6%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E8%AF%BE%E7%A8%8BPart2/image-20210207164852602.png" alt="image-20210207164852602"></p><p>原问题证明建议重看<a href="https://www.bilibili.com/video/BV1dJ411B7gh?p=12">p12-23:37</a></p><h2 id="支持向量机的应用——兵王问题"><a href="#支持向量机的应用——兵王问题" class="headerlink" title="支持向量机的应用——兵王问题"></a>支持向量机的应用——兵王问题</h2><h3 id="n折交叉验证"><a href="#n折交叉验证" class="headerlink" title="n折交叉验证"></a>n折交叉验证</h3><p>对于<strong>每一组超参数</strong>，进行<strong>n折交叉验证</strong>求损失，最终选取的是损失最小的那一组超参数。</p><h3 id="测试结果中的支持向量"><a href="#测试结果中的支持向量" class="headerlink" title="测试结果中的支持向量"></a>测试结果中的支持向量</h3><p>当支持向量占比非常高，甚至是几乎等于训练样本。则表明这次训练失败，或者数据集本身没有规律，或者SVM 没法找到他的规律。</p><h3 id="评判模型好坏"><a href="#评判模型好坏" class="headerlink" title="评判模型好坏"></a>评判模型好坏</h3><h4 id="混淆矩阵"><a href="#混淆矩阵" class="headerlink" title="混淆矩阵"></a>混淆矩阵</h4><p><img src="/2021/02/%E6%B5%99%E6%B1%9F%E5%A4%A7%E5%AD%A6%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E8%AF%BE%E7%A8%8BPart2/image-20210208230203359.png" alt="image-20210208230203359"></p><p>TP: 将正样本识别为正样本的数量（或概率）</p><p>FN: 将正样本识别为负样本的数量（或概率）</p><p>FP: 将负样本识别为正样本的数量（或概率）</p><p>TN: 将负样本识别为负样本的数量（或概率）</p><p>FN减少 &lt;=&gt; TP增加 &lt;=&gt; FP增加 &lt;=&gt; TN减少</p><blockquote><p>mAP: mean Average Precision, 即各类别AP的平均值</p><p>AP: PR曲线下面积，后文会详细讲解</p><p>PR曲线: Precision-Recall曲线</p><p>Precision: TP / (TP + FP)</p><p>Recall: TP / (TP + FN)</p><p>TP: IoU&gt;0.5的检测框数量（同一Ground Truth只计算一次）</p><p>FP: IoU&lt;=0.5的检测框，或者是检测到同一个GT的多余检测框的数量</p><p>FN: 没有检测到的GT的数量</p></blockquote><h4 id="ROC曲线-Receiver-Operating-Character"><a href="#ROC曲线-Receiver-Operating-Character" class="headerlink" title="ROC曲线(Receiver Operating Character)"></a>ROC曲线(Receiver Operating Character)</h4><p><img src="/2021/02/%E6%B5%99%E6%B1%9F%E5%A4%A7%E5%AD%A6%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E8%AF%BE%E7%A8%8BPart2/image-20210209123230240.png" alt="image-20210209123230240"></p><p>四条线表示四个不同的系统</p><p>等错误率 (Equal Error Rate, EER)是两类错误FP和FN相等时候的错误率，这时错误率越小，表示系统性能约好。</p><p>AUC(Area Under Curve)曲线右下角的一块面积，面积的大小也能体现模型的好坏。</p><blockquote><p>判别模型的好坏要看具体的应用，并不是准确率越高，模型高就越好</p></blockquote><h3 id="兵王问题的Python实现-补充"><a href="#兵王问题的Python实现-补充" class="headerlink" title="兵王问题的Python实现==(补充)=="></a>兵王问题的Python实现==(补充)==</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h2 id="处理多分类问题"><a href="#处理多分类问题" class="headerlink" title="处理多分类问题"></a>处理多分类问题</h2><ol><li>改造优化的目标函数和限制条件，使之能处理多类<br>论文 SVM-Multiclass Multi-class Support Vector Machine</li><li>一类 VS 其他类</li><li>一类 VS 另一类</li></ol><p>其中，①方法通常不是很好，因为SVM是针对二分类问题开发的。</p><p>在n类问题分类中，②方法主要构造n个SVM，③方法要构造 n * (n-1) / 2 个SVM。</p><p>通常来说，③方法分类噢效果更好，但是也更复杂。</p>]]></content>
      
      
      <categories>
          
          <category> 浙江大学机器学习课程 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>浙江大学机器学习课程Part1</title>
      <link href="/2021/02/%E6%B5%99%E6%B1%9F%E5%A4%A7%E5%AD%A6%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E8%AF%BE%E7%A8%8BPart1/"/>
      <url>/2021/02/%E6%B5%99%E6%B1%9F%E5%A4%A7%E5%AD%A6%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E8%AF%BE%E7%A8%8BPart1/</url>
      
        <content type="html"><![CDATA[<h1 id="浙江大学机器学习课程Part1——课程概论"><a href="#浙江大学机器学习课程Part1——课程概论" class="headerlink" title="浙江大学机器学习课程Part1——课程概论"></a>浙江大学机器学习课程Part1——课程概论</h1><p>[TOC]</p><h2 id="推荐书籍-amp-课程"><a href="#推荐书籍-amp-课程" class="headerlink" title="推荐书籍&amp;课程"></a>推荐书籍&amp;课程</h2><ol><li>机器学习， 周志华，清华大学出版社，2016</li><li>统计学习方法，李航，清华大学出版社，2012</li><li>Machine Learning in Action, P. Harrington,人民邮电出版社</li><li>Pattern Recognition and Machine Learning (模式识别与机器学习)，Christopher M. Bishop, 2006</li><li>Machine Learning: A Probabilistic Perspective, K. P. Murphy, </li><li>Machine Learning (机器学习), Tom M. Mitchell, 机械工业出版社，2003年</li><li>Deep Learning, I. Goodfellow, Y. Bengio and A. Courville, 2016</li><li><a href="https://www.coursera.org/course/ml">Stanfrod Web course by Andrew Ng</a></li><li><a href="https://cs231n.stanford.edu/">Stanfrod Web course by Fei-fei Li</a></li></ol><h2 id="机器学习算法分类"><a href="#机器学习算法分类" class="headerlink" title="机器学习算法分类"></a>机器学习算法分类</h2><ol><li>Supervised learning 监督式学习 – SVM, NEURAL NETWORKS</li><li>Unsupervised learning 无监督式学习 – CLUSTERING, EM ALGORITHM, PCA</li><li>Semi-Supervised Learning 半监督式学习</li><li>Reinforcement learning 增强学习</li></ol><p>以预测标签为导向的分类：监督式学习、无监督式学习、半监督式学习。</p><p>不注重过程而关心结果的分类：增强学习。例如：智能驾驶（在不违反交通规则的情况下最快到达目的地）、下棋对战AI（为了最终的输赢有很多种不同的下法）</p><p>Supervised learning:  The machine learning task of inferring a function from labeled training data. Supervised learning can be further divided into </p><ol><li>classification 分类（二分类/多分类） - 离散值标签</li><li>regression 回归（单响应/多响应） - 连续值标签</li></ol><p>两者没有明确界限，以至于有些分类算法也能做回归算法。</p><h2 id="机器学习两大难点"><a href="#机器学习两大难点" class="headerlink" title="机器学习两大难点"></a>机器学习两大难点</h2><ol><li>维度</li><li>标准</li></ol><h2 id="没有免费午餐定理-No-Free-Lunch-Theorem"><a href="#没有免费午餐定理-No-Free-Lunch-Theorem" class="headerlink" title="没有免费午餐定理(No Free Lunch Theorem)"></a>没有免费午餐定理(No Free Lunch Theorem)</h2><p>任何一个预测函数，如果在一些训练样本上表现好，那么必然在另一些训练样本上表现不好，表现好与表现不好的情况一样多。</p><p>如果我们不对特征空间有先验假设，则所有算法的平均表现是一样的。</p><p>我们认为：特征差距小的样本更有可能是同一类。但是，在没有任何先前给定特征意义的情况下，我们都不能确定预测的下一个是什么。</p><p>在这个领域没有最好的算法，但是有公认的好方法。</p>]]></content>
      
      
      <categories>
          
          <category> 浙江大学机器学习课程 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>PyTorch深度学习实践-完结目录</title>
      <link href="/2021/01/PyTorch%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%AE%9E%E8%B7%B5-%E5%AE%8C%E7%BB%93%E7%9B%AE%E5%BD%95/"/>
      <url>/2021/01/PyTorch%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%AE%9E%E8%B7%B5-%E5%AE%8C%E7%BB%93%E7%9B%AE%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<h1 id="PyTorch深度学习实践-完结目录"><a href="#PyTorch深度学习实践-完结目录" class="headerlink" title="PyTorch深度学习实践-完结目录"></a>PyTorch深度学习实践-完结目录</h1><p>教程视频传送门：<a href="https://www.bilibili.com/video/BV1Y7411d7Ys?p=13">《PyTorch深度学习实践》完结合集</a></p><p>总之就是非常推荐，很适合新手入门，原理循序渐进，建议认真听，认真做。</p><table><thead><tr><th align="center"><a href="../PyTorch%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%AE%9E%E8%B7%B5Part1/">Part1——概论</a></th></tr></thead><tbody><tr><td align="center"><strong><a href="../PyTorch%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%AE%9E%E8%B7%B5Part2/">Part2——线性模型</a></strong></td></tr><tr><td align="center"><strong><a href="../PyTorch%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%AE%9E%E8%B7%B5Part3/">Part3——梯度下降算法</a></strong></td></tr><tr><td align="center"><strong><a href="../PyTorch%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%AE%9E%E8%B7%B5Part4/">Part4——反向传播</a></strong></td></tr><tr><td align="center"><strong><a href="../PyTorch%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%AE%9E%E8%B7%B5Part5/">Part5——线性回归</a></strong></td></tr><tr><td align="center"><strong><a href="../PyTorch%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%AE%9E%E8%B7%B5Part6/">Part6——逻辑斯蒂回归</a></strong></td></tr><tr><td align="center"><strong><a href="../PyTorch%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%AE%9E%E8%B7%B5Part7/">Part7——处理多维特征的输入</a></strong></td></tr><tr><td align="center"><strong><a href="../PyTorch%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%AE%9E%E8%B7%B5Part8/">Part8——加载数据集</a></strong></td></tr><tr><td align="center"><strong><a href="../PyTorch%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%AE%9E%E8%B7%B5Part9/">Part9——多分类问题</a></strong></td></tr><tr><td align="center"><strong><a href="../PyTorch%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%AE%9E%E8%B7%B5Part10/">Part10——卷积神经网络（基础篇）</a></strong></td></tr><tr><td align="center"><strong><a href="../PyTorch%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%AE%9E%E8%B7%B5Part11/">Part11——卷积神经网络（高级篇）</a></strong></td></tr><tr><td align="center"><strong><a href="../PyTorch%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%AE%9E%E8%B7%B5Part12/">Part12——循环神经网络（基础篇）</a></strong></td></tr><tr><td align="center"><strong><a href="../PyTorch%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%AE%9E%E8%B7%B5Part13/">Part13——循环神经网络（高级篇）</a></strong></td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> PyTorch深度学习实践 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PyTorch深度学习实践Part13</title>
      <link href="/2021/01/PyTorch%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%AE%9E%E8%B7%B5Part13/"/>
      <url>/2021/01/PyTorch%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%AE%9E%E8%B7%B5Part13/</url>
      
        <content type="html"><![CDATA[<h1 id="PyTorch深度学习实践Part13——循环神经网络（高级篇）"><a href="#PyTorch深度学习实践Part13——循环神经网络（高级篇）" class="headerlink" title="PyTorch深度学习实践Part13——循环神经网络（高级篇）"></a>PyTorch深度学习实践Part13——循环神经网络（高级篇）</h1><h2 id="RNN"><a href="#RNN" class="headerlink" title="RNN"></a>RNN</h2><p><img src="/2021/01/PyTorch%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%AE%9E%E8%B7%B5Part13/image-20210121201135070.png" alt="image-20210121201135070"></p><p>双向循环神经网络</p><p><img src="/2021/01/PyTorch%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%AE%9E%E8%B7%B5Part13/image-20210122101740766.png" alt="image-20210122101740766"></p><h2 id="人名处理"><a href="#人名处理" class="headerlink" title="人名处理"></a>人名处理</h2><ol><li>切分字符串</li><li>转ASCII码</li></ol><p><img src="/2021/01/PyTorch%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%AE%9E%E8%B7%B5Part13/image-20210122103511843.png" alt="image-20210122103511843"></p><ol start="3"><li>填充</li></ol><p><img src="/2021/01/PyTorch%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%AE%9E%E8%B7%B5Part13/image-20210122103548168.png" alt="image-20210122103548168"></p><ol start="4"><li>转置</li></ol><p><img src="/2021/01/PyTorch%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%AE%9E%E8%B7%B5Part13/image-20210122103627700.png" alt="image-20210122103627700"></p><ol start="5"><li>排序</li></ol><p><img src="/2021/01/PyTorch%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%AE%9E%E8%B7%B5Part13/image-20210122103701821.png" alt="image-20210122103701821"></p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> csv</span><br><span class="line"><span class="keyword">import</span> gzip</span><br><span class="line"><span class="keyword">import</span> math</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">from</span> torch.nn.utils.rnn <span class="keyword">import</span> pack_padded_sequence</span><br><span class="line"><span class="keyword">from</span> torch.utils.data <span class="keyword">import</span> DataLoader, Dataset</span><br><span class="line"></span><br><span class="line">HIDDEN_SIZE = <span class="number">100</span></span><br><span class="line">BATCH_SIZE = <span class="number">256</span></span><br><span class="line">N_LAYER = <span class="number">2</span></span><br><span class="line">N_EPOCHS = <span class="number">100</span></span><br><span class="line">N_CHARS = <span class="number">128</span></span><br><span class="line">USE_GPU = <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NameDataset</span>(<span class="params">Dataset</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, is_train_set=<span class="literal">True</span></span>):</span></span><br><span class="line">        filename = <span class="string">&#x27;../names_train.csv.gz&#x27;</span> <span class="keyword">if</span> is_train_set <span class="keyword">else</span> <span class="string">&#x27;../names_test.csv.gz&#x27;</span></span><br><span class="line">        <span class="keyword">with</span> gzip.<span class="built_in">open</span>(filename, <span class="string">&#x27;rt&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">            reader = csv.reader(f)</span><br><span class="line">            rows = <span class="built_in">list</span>(reader)</span><br><span class="line">        self.names = [row[<span class="number">0</span>] <span class="keyword">for</span> row <span class="keyword">in</span> rows]</span><br><span class="line">        self.<span class="built_in">len</span> = <span class="built_in">len</span>(self.names)</span><br><span class="line">        self.countries = [row[<span class="number">1</span>] <span class="keyword">for</span> row <span class="keyword">in</span> rows]</span><br><span class="line">        self.country_list = <span class="built_in">list</span>(<span class="built_in">sorted</span>(<span class="built_in">set</span>(self.countries)))</span><br><span class="line">        self.country_dict = self.getCountryDict()</span><br><span class="line">        self.country_num = <span class="built_in">len</span>(self.country_list)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getitem__</span>(<span class="params">self, index</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self.names[index], self.country_dict[self.countries[index]]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__len__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self.<span class="built_in">len</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getCountryDict</span>(<span class="params">self</span>):</span></span><br><span class="line">        country_dict = <span class="built_in">dict</span>()</span><br><span class="line">        <span class="keyword">for</span> idx, country_name <span class="keyword">in</span> <span class="built_in">enumerate</span>(self.country_list, <span class="number">0</span>):</span><br><span class="line">            country_dict[country_name] = idx</span><br><span class="line">        <span class="keyword">return</span> country_dict</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">idx2country</span>(<span class="params">self, index</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self.country_list[index]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getCountriesNum</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self.country_num</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">trainset = NameDataset(is_train_set=<span class="literal">True</span>)</span><br><span class="line">trainloader = DataLoader(trainset, batch_size=BATCH_SIZE, shuffle=<span class="literal">True</span>)</span><br><span class="line">testset = NameDataset(is_train_set=<span class="literal">False</span>)</span><br><span class="line">testloader = DataLoader(testset, batch_size=BATCH_SIZE, shuffle=<span class="literal">False</span>)</span><br><span class="line">N_COUNTRY = trainset.getCountriesNum()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RNNClassifier</span>(<span class="params">torch.nn.Module</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, input_size, hidden_size, output_size, n_layers=<span class="number">1</span>, bidirectional=<span class="literal">True</span></span>):</span></span><br><span class="line">        <span class="built_in">super</span>(RNNClassifier, self).__init__()</span><br><span class="line">        self.hidden_size = hidden_size</span><br><span class="line">        self.n_layers = n_layers</span><br><span class="line">        self.n_directions = <span class="number">2</span> <span class="keyword">if</span> bidirectional <span class="keyword">else</span> <span class="number">1</span></span><br><span class="line">        self.embedding = torch.nn.Embedding(input_size, hidden_size)</span><br><span class="line">        self.gru = torch.nn.GRU(hidden_size, hidden_size, n_layers,</span><br><span class="line">                                bidirectional=bidirectional)</span><br><span class="line">        self.fc = torch.nn.Linear(hidden_size * self.n_directions, output_size)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_init_hidden</span>(<span class="params">self, batch_size</span>):</span></span><br><span class="line">        hidden = torch.zeros(self.n_layers * self.n_directions,</span><br><span class="line">                             batch_size, self.hidden_size)</span><br><span class="line">        <span class="keyword">return</span> create_tensor(hidden)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span>(<span class="params">self, <span class="built_in">input</span>, seq_lengths</span>):</span></span><br><span class="line">        <span class="comment"># input shape : B x S -&gt; S x B</span></span><br><span class="line">        <span class="built_in">input</span> = <span class="built_in">input</span>.t()</span><br><span class="line">        batch_size = <span class="built_in">input</span>.size(<span class="number">1</span>)</span><br><span class="line">        hidden = self._init_hidden(batch_size)</span><br><span class="line">        embedding = self.embedding(<span class="built_in">input</span>)</span><br><span class="line">        <span class="comment"># pack them up</span></span><br><span class="line">        gru_input = pack_padded_sequence(embedding, seq_lengths)</span><br><span class="line">        output, hidden = self.gru(gru_input, hidden)</span><br><span class="line">        <span class="keyword">if</span> self.n_directions == <span class="number">2</span>:</span><br><span class="line">            hidden_cat = torch.cat([hidden[-<span class="number">1</span>], hidden[-<span class="number">2</span>]], dim=<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            hidden_cat = hidden[-<span class="number">1</span>]</span><br><span class="line">        fc_output = self.fc(hidden_cat)</span><br><span class="line">        <span class="keyword">return</span> fc_output</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">name2list</span>(<span class="params">name</span>):</span></span><br><span class="line">    arr = [<span class="built_in">ord</span>(c) <span class="keyword">for</span> c <span class="keyword">in</span> name]</span><br><span class="line">    <span class="keyword">return</span> arr, <span class="built_in">len</span>(arr)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">create_tensor</span>(<span class="params">tensor</span>):</span></span><br><span class="line">    <span class="keyword">if</span> USE_GPU:</span><br><span class="line">        device = torch.device(<span class="string">&quot;cuda:0&quot;</span>)</span><br><span class="line">        tensor = tensor.to(device)</span><br><span class="line">    <span class="keyword">return</span> tensor</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">make_tensors</span>(<span class="params">names, countries</span>):</span></span><br><span class="line">    sequences_and_lengths = [name2list(name) <span class="keyword">for</span> name <span class="keyword">in</span> names]</span><br><span class="line">    name_sequences = [sl[<span class="number">0</span>] <span class="keyword">for</span> sl <span class="keyword">in</span> sequences_and_lengths]</span><br><span class="line">    seq_lengths = torch.LongTensor([sl[<span class="number">1</span>] <span class="keyword">for</span> sl <span class="keyword">in</span> sequences_and_lengths])</span><br><span class="line">    countries = countries.long()</span><br><span class="line">    <span class="comment"># make tensor of name, BatchSize x SeqLen</span></span><br><span class="line">    seq_tensor = torch.zeros(<span class="built_in">len</span>(name_sequences), seq_lengths.<span class="built_in">max</span>()).long()</span><br><span class="line">    <span class="keyword">for</span> idx, (seq, seq_len) <span class="keyword">in</span> <span class="built_in">enumerate</span>(<span class="built_in">zip</span>(name_sequences, seq_lengths), <span class="number">0</span>):</span><br><span class="line">        seq_tensor[idx, :seq_len] = torch.LongTensor(seq)</span><br><span class="line">    <span class="comment"># sort by length to use pack_padded_sequence</span></span><br><span class="line">    seq_lengths, perm_idx = seq_lengths.sort(dim=<span class="number">0</span>, descending=<span class="literal">True</span>)</span><br><span class="line">    seq_tensor = seq_tensor[perm_idx]</span><br><span class="line">    countries = countries[perm_idx]</span><br><span class="line">    <span class="keyword">return</span> create_tensor(seq_tensor), create_tensor(seq_lengths), create_tensor(countries)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">time_since</span>(<span class="params">since</span>):</span></span><br><span class="line">    s = time.time() - since</span><br><span class="line">    m = math.floor(s / <span class="number">60</span>)</span><br><span class="line">    s -= m * <span class="number">60</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;%dm %ds&#x27;</span> % (m, s)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">trainModel</span>():</span></span><br><span class="line">    total_loss = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i, (names, countries) <span class="keyword">in</span> <span class="built_in">enumerate</span>(trainloader, <span class="number">1</span>):</span><br><span class="line">        inputs, seq_lengths, target = make_tensors(names, countries)</span><br><span class="line">        output = classifier(inputs, seq_lengths)</span><br><span class="line">        loss = criterion(output, target)</span><br><span class="line">        optimizer.zero_grad()</span><br><span class="line">        loss.backward()</span><br><span class="line">        optimizer.step()</span><br><span class="line">        total_loss += loss.item()</span><br><span class="line">        <span class="keyword">if</span> i % <span class="number">10</span> == <span class="number">0</span>:</span><br><span class="line">            print(<span class="string">f&#x27;[<span class="subst">&#123;time_since(start)&#125;</span>] Epoch <span class="subst">&#123;epoch&#125;</span> &#x27;</span>, end=<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">            print(<span class="string">f&#x27;[<span class="subst">&#123;i * <span class="built_in">len</span>(inputs)&#125;</span>/<span class="subst">&#123;<span class="built_in">len</span>(trainset)&#125;</span>] &#x27;</span>, end=<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">            print(<span class="string">f&#x27;loss=<span class="subst">&#123;total_loss / (i * <span class="built_in">len</span>(inputs))&#125;</span>&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> total_loss</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">testModel</span>():</span></span><br><span class="line">    correct = <span class="number">0</span></span><br><span class="line">    total = <span class="built_in">len</span>(testset)</span><br><span class="line">    print(<span class="string">&quot;evaluating trained model ...&quot;</span>)</span><br><span class="line">    <span class="keyword">with</span> torch.no_grad():</span><br><span class="line">        <span class="keyword">for</span> i, (names, countries) <span class="keyword">in</span> <span class="built_in">enumerate</span>(testloader, <span class="number">1</span>):</span><br><span class="line">            inputs, seq_lengths, target = make_tensors(names, countries)</span><br><span class="line">            output = classifier(inputs, seq_lengths)</span><br><span class="line">            pred = output.<span class="built_in">max</span>(dim=<span class="number">1</span>, keepdim=<span class="literal">True</span>)[<span class="number">1</span>]</span><br><span class="line">            correct += pred.eq(target.view_as(pred)).<span class="built_in">sum</span>().item()</span><br><span class="line">        percent = <span class="string">&#x27;%.2f&#x27;</span> % (<span class="number">100</span> * correct / total)</span><br><span class="line">        print(<span class="string">f&#x27;Test set: Accuracy <span class="subst">&#123;correct&#125;</span>/<span class="subst">&#123;total&#125;</span> <span class="subst">&#123;percent&#125;</span>%&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> correct / total</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    classifier = RNNClassifier(N_CHARS, HIDDEN_SIZE, N_COUNTRY, N_LAYER)</span><br><span class="line">    <span class="keyword">if</span> USE_GPU:</span><br><span class="line">        device = torch.device(<span class="string">&quot;cuda:0&quot;</span>)</span><br><span class="line">        classifier.to(device)</span><br><span class="line"></span><br><span class="line">    criterion = torch.nn.CrossEntropyLoss()  <span class="comment"># 做的是分类问题，用交叉熵</span></span><br><span class="line">    optimizer = torch.optim.Adam(classifier.parameters(), lr=<span class="number">0.001</span>)</span><br><span class="line"></span><br><span class="line">    start = time.time()</span><br><span class="line">    print(<span class="string">&quot;Training for %d epochs...&quot;</span> % N_EPOCHS)</span><br><span class="line">    acc_list = []</span><br><span class="line">    <span class="keyword">for</span> epoch <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, N_EPOCHS + <span class="number">1</span>):</span><br><span class="line">        <span class="comment"># Train cycle</span></span><br><span class="line">        trainModel()</span><br><span class="line">        acc = testModel()</span><br><span class="line">        acc_list.append(acc)</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> PyTorch深度学习实践 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>PyTorch深度学习实践Part12</title>
      <link href="/2021/01/PyTorch%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%AE%9E%E8%B7%B5Part12/"/>
      <url>/2021/01/PyTorch%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%AE%9E%E8%B7%B5Part12/</url>
      
        <content type="html"><![CDATA[<h1 id="PyTorch深度学习实践Part12——循环神经网络（基础篇）"><a href="#PyTorch深度学习实践Part12——循环神经网络（基础篇）" class="headerlink" title="PyTorch深度学习实践Part12——循环神经网络（基础篇）"></a>PyTorch深度学习实践Part12——循环神经网络（基础篇）</h1><h2 id="循环神经网络RNN"><a href="#循环神经网络RNN" class="headerlink" title="循环神经网络RNN"></a>循环神经网络RNN</h2><p>之前一开始用的是稠密网络DNN，因为是全连接，所以对每个元素都有相应的权重，因此其计算量是远大于看似复杂但是具有权重共享特性的CNN的。而RNN就是延续权重共享理念的网络。</p><p>RNN主要处理有序列连接的数据，比如自然语言、天气、股市、视频等。</p><p>RNN本质是一个线性层，与DNN不同是RNN Cell是共享的。</p><p>从图像到文本的转换：CNN+FC+RNN。</p><p>循环神经网络的激活函数更常用tanh。</p><p><img src="/2021/01/PyTorch%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%AE%9E%E8%B7%B5Part12/image-20210121142256148.png" alt="image-20210121142256148"></p><p>可以选择使用RNN Cell自己构建循环，也可以使用RNN。</p><p><img src="/2021/01/PyTorch%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%AE%9E%E8%B7%B5Part12/image-20210121145441952.png" alt="image-20210121145441952"></p><h2 id="独热编码"><a href="#独热编码" class="headerlink" title="独热编码"></a>独热编码</h2><p>处理文本使用独热编码</p><p><img src="/2021/01/PyTorch%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%AE%9E%E8%B7%B5Part12/image-20210121151229487.png" alt="image-20210121151229487"></p><p><img src="/2021/01/PyTorch%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%AE%9E%E8%B7%B5Part12/image-20210121151654777.png" alt="image-20210121151654777"></p><h2 id="嵌入层"><a href="#嵌入层" class="headerlink" title="嵌入层"></a>嵌入层</h2><p>独热编码的缺点：</p><ol><li>维度高</li><li>稀疏</li><li>硬编码</li></ol><p><img src="/2021/01/PyTorch%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%AE%9E%E8%B7%B5Part12/image-20210121153403068.png" alt="image-20210121153403068"></p><p>使用Embedding改善优化</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> torch.optim <span class="keyword">as</span> optim</span><br><span class="line"></span><br><span class="line"><span class="comment"># prepare dataset</span></span><br><span class="line">num_class = <span class="number">4</span></span><br><span class="line">input_size = <span class="number">4</span></span><br><span class="line">hidden_size = <span class="number">8</span></span><br><span class="line">embedding_size = <span class="number">10</span></span><br><span class="line">num_layers = <span class="number">2</span></span><br><span class="line">batch_size = <span class="number">1</span></span><br><span class="line">seq_len = <span class="number">5</span></span><br><span class="line"></span><br><span class="line">idx2char = [<span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;h&#x27;</span>, <span class="string">&#x27;l&#x27;</span>, <span class="string">&#x27;o&#x27;</span>]</span><br><span class="line">x_data = [[<span class="number">1</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>]]  <span class="comment"># (batch, seq_len)</span></span><br><span class="line">y_data = [<span class="number">3</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">2</span>]  <span class="comment"># (batch * seq_len)</span></span><br><span class="line">inputs = torch.LongTensor(x_data)</span><br><span class="line">labels = torch.LongTensor(y_data)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># design model using class</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Model</span>(<span class="params">torch.nn.Module</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="built_in">super</span>(Model, self).__init__()</span><br><span class="line">        self.emb = torch.nn.Embedding(input_size, embedding_size)  <span class="comment"># matrix of Embedding:[input_size, embedding_size]</span></span><br><span class="line">        self.rnn = torch.nn.RNN(input_size=embedding_size,</span><br><span class="line">                                hidden_size=hidden_size,</span><br><span class="line">                                num_layers=num_layers,</span><br><span class="line">                                batch_first=<span class="literal">True</span>)</span><br><span class="line">        self.fc = torch.nn.Linear(hidden_size, num_class)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span>(<span class="params">self, x</span>):</span></span><br><span class="line">        hidden = torch.zeros(num_layers, x.size(<span class="number">0</span>), hidden_size)</span><br><span class="line">        x = self.emb(</span><br><span class="line">            x)  <span class="comment"># 这里输入需要是长整型longtensor，输出为(𝒃𝒂𝒕𝒄𝒉𝑺𝒊𝒛𝒆, 𝒔𝒆𝒒𝑳𝒆𝒏, 𝒆𝒎𝒃𝒆𝒅𝒅𝒊𝒏𝒈𝑺𝒊𝒛𝒆)，注意batch_first=True</span></span><br><span class="line">        x, _ = self.rnn(x, hidden)  <span class="comment"># 输出(𝒃𝒂𝒕𝒄𝒉𝑺𝒊𝒛𝒆, 𝒔𝒆𝒒𝑳𝒆𝒏, 𝒉𝒊𝒅𝒅𝒆𝒏𝑺𝒊𝒛e)</span></span><br><span class="line">        x = self.fc(x)</span><br><span class="line">        <span class="keyword">return</span> x.view(-<span class="number">1</span>, num_class)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">net = Model()</span><br><span class="line"></span><br><span class="line"><span class="comment"># construct loss and optimizer</span></span><br><span class="line">criterion = torch.nn.CrossEntropyLoss()</span><br><span class="line">optimizer = optim.Adam(net.parameters(), lr=<span class="number">0.05</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># training cycle forward, backward, update</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">train</span>(<span class="params">epoch</span>):</span></span><br><span class="line">    <span class="keyword">for</span> epoch <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">15</span>):</span><br><span class="line">        optimizer.zero_grad()</span><br><span class="line">    outputs = net(inputs)</span><br><span class="line">    loss = criterion(outputs, labels)</span><br><span class="line">    loss.backward()</span><br><span class="line">    optimizer.step()</span><br><span class="line">    _, idx = outputs.<span class="built_in">max</span>(dim=<span class="number">1</span>)</span><br><span class="line">    idx = idx.data.numpy()</span><br><span class="line">    print(<span class="string">&#x27;Predicted: &#x27;</span>, <span class="string">&#x27;&#x27;</span>.join([idx2char[x] <span class="keyword">for</span> x <span class="keyword">in</span> idx]), end=<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">    print(<span class="string">&#x27;, Epoch [%d/15] loss = %.3f&#x27;</span> % (epoch + <span class="number">1</span>, loss.item()))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="keyword">for</span> epoch <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">        train(epoch)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="课后作业"><a href="#课后作业" class="headerlink" title="课后作业"></a>课后作业</h2><p>使用LSTM和GRU训练模型</p><p><img src="/2021/01/PyTorch%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%AE%9E%E8%B7%B5Part12/image-20210121192740594.png" alt="image-20210121192740594"></p><p><img src="/2021/01/PyTorch%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%AE%9E%E8%B7%B5Part12/image-20210121192834591.png" alt="image-20210121192834591"></p>]]></content>
      
      
      <categories>
          
          <category> PyTorch深度学习实践 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>PyTorch深度学习实践Part11</title>
      <link href="/2021/01/PyTorch%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%AE%9E%E8%B7%B5Part11/"/>
      <url>/2021/01/PyTorch%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%AE%9E%E8%B7%B5Part11/</url>
      
        <content type="html"><![CDATA[<h1 id="PyTorch深度学习实践Part10——卷积神经网络（高级篇）"><a href="#PyTorch深度学习实践Part10——卷积神经网络（高级篇）" class="headerlink" title="PyTorch深度学习实践Part10——卷积神经网络（高级篇）"></a>PyTorch深度学习实践Part10——卷积神经网络（高级篇）</h1><h2 id="Inception"><a href="#Inception" class="headerlink" title="Inception"></a>Inception</h2><p>寻找超参数是十分困难的，GoogleNet把不同的模型作成块Inception，在训练时优秀的超参数模块权重自然增加。</p><p>Concatenate拼接四个分支算出来的张量。</p><p>不同的分支，可以有不同的channel，但要有相同的width、height。</p><p>pooling也可以设置padding=1、stride=1来保证输出大小一样。</p><p>1*1卷积，其数量取决于输入张量的通道。</p><p>1*1卷积的信息融合，是在每一个像素点多通道方面的融合。</p><p>1*1卷积主要解决运算量过大的问题，可以减少下一层输入通道数量。</p><p><img src="/2021/01/PyTorch%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%AE%9E%E8%B7%B5Part11/image-20210119191134365.png" alt="GoogleNet"></p><p><img src="/2021/01/PyTorch%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%AE%9E%E8%B7%B5Part11/image-20210120113458095.png" alt="image-20210120113458095"></p><p>最后输出的大小一般会去掉线性层，先实例化跑一遍输出size。</p><p>在写网络时，要加上一个存盘功能，即每次准确率达到新高时做一次模型数据备份，防止意外。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> torch.nn <span class="keyword">as</span> nn</span><br><span class="line"><span class="keyword">from</span> torchvision <span class="keyword">import</span> transforms</span><br><span class="line"><span class="keyword">from</span> torchvision <span class="keyword">import</span> datasets</span><br><span class="line"><span class="keyword">from</span> torch.utils.data <span class="keyword">import</span> DataLoader</span><br><span class="line"><span class="keyword">import</span> torch.nn.functional <span class="keyword">as</span> F</span><br><span class="line"><span class="keyword">import</span> torch.optim <span class="keyword">as</span> optim</span><br><span class="line"></span><br><span class="line"><span class="comment"># prepare dataset</span></span><br><span class="line"></span><br><span class="line">batch_size = <span class="number">64</span></span><br><span class="line"><span class="comment"># Compose参数列表：转为张量；归一化,均值和方差</span></span><br><span class="line">transform = transforms.Compose([transforms.ToTensor(), transforms.Normalize((<span class="number">0.1307</span>,), (<span class="number">0.3081</span>,))])</span><br><span class="line"></span><br><span class="line">train_dataset = datasets.MNIST(root=<span class="string">&#x27;../dataset/mnist/&#x27;</span>, train=<span class="literal">True</span>, download=<span class="literal">False</span>, transform=transform)</span><br><span class="line">train_loader = DataLoader(train_dataset, shuffle=<span class="literal">True</span>, batch_size=batch_size)</span><br><span class="line">test_dataset = datasets.MNIST(root=<span class="string">&#x27;../dataset/mnist/&#x27;</span>, train=<span class="literal">False</span>, download=<span class="literal">False</span>, transform=transform)</span><br><span class="line">test_loader = DataLoader(test_dataset, shuffle=<span class="literal">False</span>, batch_size=batch_size)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># design model using class</span></span><br><span class="line"><span class="comment"># network in network</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">InceptionA</span>(<span class="params">nn.Module</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, in_channels</span>):</span></span><br><span class="line">        <span class="built_in">super</span>(InceptionA, self).__init__()</span><br><span class="line">        <span class="comment"># 4条分支</span></span><br><span class="line">        <span class="comment"># 1. 1*1卷积</span></span><br><span class="line">        self.branch1x1 = nn.Conv2d(in_channels, <span class="number">16</span>, kernel_size=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 2. 1*1卷积+5*5卷积</span></span><br><span class="line">        self.branch5x5_1 = nn.Conv2d(in_channels, <span class="number">16</span>, kernel_size=<span class="number">1</span>)</span><br><span class="line">        self.branch5x5_2 = nn.Conv2d(<span class="number">16</span>, <span class="number">24</span>, kernel_size=<span class="number">5</span>, padding=<span class="number">2</span>)  <span class="comment"># 保持图像大小不变，kernel=5，则padding=2</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 3. 1*1卷积+3*3卷积+3*3卷积</span></span><br><span class="line">        self.branch3x3_1 = nn.Conv2d(in_channels, <span class="number">16</span>, kernel_size=<span class="number">1</span>)</span><br><span class="line">        self.branch3x3_2 = nn.Conv2d(<span class="number">16</span>, <span class="number">24</span>, kernel_size=<span class="number">3</span>, padding=<span class="number">1</span>)  <span class="comment"># 保持图像大小不变，kernel=3，则padding=1</span></span><br><span class="line">        self.branch3x3_3 = nn.Conv2d(<span class="number">24</span>, <span class="number">24</span>, kernel_size=<span class="number">3</span>, padding=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 4, 池化(函数)+1*1卷积</span></span><br><span class="line">        self.branch_pool = nn.Conv2d(in_channels, <span class="number">24</span>, kernel_size=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span>(<span class="params">self, x</span>):</span></span><br><span class="line">        branch1x1 = self.branch1x1(x)</span><br><span class="line"></span><br><span class="line">        branch5x5 = self.branch5x5_1(x)</span><br><span class="line">        branch5x5 = self.branch5x5_2(branch5x5)</span><br><span class="line"></span><br><span class="line">        branch3x3 = self.branch3x3_1(x)</span><br><span class="line">        branch3x3 = self.branch3x3_2(branch3x3)</span><br><span class="line">        branch3x3 = self.branch3x3_3(branch3x3)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 池化是函数，不需要训练，只在forward中调用</span></span><br><span class="line">        <span class="comment"># 池化也可以使图像大小不变。1. kernel_size=3，则padding=1；2. stride=1</span></span><br><span class="line">        branch_pool = F.avg_pool2d(x, kernel_size=<span class="number">3</span>, stride=<span class="number">1</span>, padding=<span class="number">1</span>)</span><br><span class="line">        branch_pool = self.branch_pool(branch_pool)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Concatenate</span></span><br><span class="line">        outputs = [branch1x1, branch5x5, branch3x3, branch_pool]</span><br><span class="line">        <span class="keyword">return</span> torch.cat(outputs, dim=<span class="number">1</span>)  <span class="comment"># b,c,w,h  c对应的是dim=1，沿着channel的维度拼接</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Net</span>(<span class="params">nn.Module</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="built_in">super</span>(Net, self).__init__()</span><br><span class="line">        self.conv1 = nn.Conv2d(<span class="number">1</span>, <span class="number">10</span>, kernel_size=<span class="number">5</span>)</span><br><span class="line">        self.conv2 = nn.Conv2d(<span class="number">88</span>, <span class="number">20</span>, kernel_size=<span class="number">5</span>)  <span class="comment"># 88 = 24x3 + 16</span></span><br><span class="line"></span><br><span class="line">        self.incep1 = InceptionA(in_channels=<span class="number">10</span>)  <span class="comment"># 与conv1 中的10对应</span></span><br><span class="line">        self.incep2 = InceptionA(in_channels=<span class="number">20</span>)  <span class="comment"># 与conv2 中的20对应</span></span><br><span class="line"></span><br><span class="line">        self.mp = nn.MaxPool2d(<span class="number">2</span>)  <span class="comment"># MaxPooling</span></span><br><span class="line">        self.fc = nn.Linear(<span class="number">1408</span>, <span class="number">10</span>)  <span class="comment"># FullConnecting</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span>(<span class="params">self, x</span>):</span></span><br><span class="line">        in_size = x.size(<span class="number">0</span>)</span><br><span class="line">        x = F.relu(self.mp(self.conv1(x)))</span><br><span class="line">        x = self.incep1(x)</span><br><span class="line">        x = F.relu(self.mp(self.conv2(x)))</span><br><span class="line">        x = self.incep2(x)</span><br><span class="line">        x = x.view(in_size, -<span class="number">1</span>)  <span class="comment"># -1指在不告诉函数有多少列的情况下，根据原tensor数据和batch自动分配列数</span></span><br><span class="line">        x = self.fc(x)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">model = Net()</span><br><span class="line"></span><br><span class="line"><span class="comment"># construct loss and optimizer</span></span><br><span class="line">criterion = torch.nn.CrossEntropyLoss()</span><br><span class="line">optimizer = optim.SGD(model.parameters(), lr=<span class="number">0.01</span>, momentum=<span class="number">0.5</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># training cycle</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">train</span>(<span class="params">epoch</span>):</span></span><br><span class="line">    running_loss = <span class="number">0.0</span></span><br><span class="line">    <span class="comment"># enumerate()用于可迭代\可遍历的数据对象组合为一个索引序列，同时列出数据和数据下标</span></span><br><span class="line">    <span class="keyword">for</span> batch_idx, data <span class="keyword">in</span> <span class="built_in">enumerate</span>(train_loader, <span class="number">0</span>):</span><br><span class="line">        <span class="comment"># data里面包含图像数据inputs(tensor)和标签labels(tensor)</span></span><br><span class="line">        inputs, target = data</span><br><span class="line">        optimizer.zero_grad()</span><br><span class="line">        <span class="comment"># forward</span></span><br><span class="line">        outputs = model(inputs)</span><br><span class="line">        loss = criterion(outputs, target)</span><br><span class="line">        <span class="comment"># backward</span></span><br><span class="line">        loss.backward()</span><br><span class="line">        <span class="comment"># update</span></span><br><span class="line">        optimizer.step()</span><br><span class="line"></span><br><span class="line">        running_loss += loss.item()</span><br><span class="line">        <span class="keyword">if</span> batch_idx % <span class="number">300</span> == <span class="number">299</span>:</span><br><span class="line">            print(<span class="string">&#x27;[%d, %5d] loss: %.3f&#x27;</span> % (epoch + <span class="number">1</span>, batch_idx + <span class="number">1</span>, running_loss / <span class="number">300</span>))</span><br><span class="line">            running_loss = <span class="number">0.0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test</span>():</span></span><br><span class="line">    correct = <span class="number">0</span></span><br><span class="line">    total = <span class="number">0</span></span><br><span class="line">    <span class="keyword">with</span> torch.no_grad():  <span class="comment"># 不需要计算张量</span></span><br><span class="line">        <span class="keyword">for</span> data <span class="keyword">in</span> test_loader:</span><br><span class="line">            images, labels = data</span><br><span class="line">            outputs = model(images)</span><br><span class="line">            _, predicted = torch.<span class="built_in">max</span>(outputs.data, dim=<span class="number">1</span>)</span><br><span class="line">            total += labels.size(<span class="number">0</span>)</span><br><span class="line">            correct += (predicted == labels).<span class="built_in">sum</span>().item()</span><br><span class="line">    print(<span class="string">&#x27;accuracy on test set: %d %% &#x27;</span> % (<span class="number">100</span> * correct / total))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="keyword">for</span> epoch <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">        train(epoch)</span><br><span class="line">        test()</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>``torch.max()[0]` 只返回最大值的每个数</p><p><code>troch.max()[1]</code> 只返回最大值的每个索引</p><p><code>torch.max()[1].data</code> 只返回variable中的数据部分（去掉Variable containing:）</p><p><code>torch.max()[1].data.numpy()</code> 把数据转化成numpy ndarry</p><p><code>torch.max()[1].data.numpy().squeeze()</code> 把数据条目中维度为1 的删除掉`</p><h2 id="残差网络-Residual-Net"><a href="#残差网络-Residual-Net" class="headerlink" title="残差网络(Residual Net)"></a>残差网络(Residual Net)</h2><p>随着网络层数增加，越靠近输入模块的梯度更新就越慢，很可能导致<strong>梯度消失</strong>。</p><p>为了解决梯度消失，会在激活之前加入一个跳连接。</p><p>在使用Residual Block时要保持输入和输出通道相同。</p><p>Residual Block相当于把一串Weight Layer包裹起来。</p><p>写神经网络也要写测试方法，检验输出是否和预计相同，逐步增加网络规模（增量式开发）。</p><p><img src="/2021/01/PyTorch%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%AE%9E%E8%B7%B5Part11/image-20210120182501998.png" alt="image-20210120182501998"></p><blockquote><ol><li>从数学和工程学方面重新理解深度学习理论。《深度学习》花书。</li><li>通读PyTorch文档。</li><li>复现经典工作、论文。读代码→写代码</li><li>扩充视野</li></ol></blockquote><p>两篇论文：</p><ol><li>He K, Zhang X, Ren S, et al. Identity Mappings in Deep Residual Networks[C]</li><li>Huang G, Liu Z, Laurens V D M, et al. Densely Connected Convolutional Networks[J]. 2016:2261-2269.</li></ol>]]></content>
      
      
      <categories>
          
          <category> PyTorch深度学习实践 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>PyTorch深度学习实践Part10</title>
      <link href="/2021/01/PyTorch%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%AE%9E%E8%B7%B5Part10/"/>
      <url>/2021/01/PyTorch%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%AE%9E%E8%B7%B5Part10/</url>
      
        <content type="html"><![CDATA[<h1 id="PyTorch深度学习实践Part10——卷积神经网络（基础篇）"><a href="#PyTorch深度学习实践Part10——卷积神经网络（基础篇）" class="headerlink" title="PyTorch深度学习实践Part10——卷积神经网络（基础篇）"></a>PyTorch深度学习实践Part10——卷积神经网络（基础篇）</h1><h2 id="Basic-CNN"><a href="#Basic-CNN" class="headerlink" title="Basic CNN"></a>Basic CNN</h2><p>CNN(Convolutional Neural Network)结构：特征提取+分类。</p><p><img src="/2021/01/PyTorch%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%AE%9E%E8%B7%B5Part10/image-20210118185651529.png" alt="image-20210118185651529"></p><p>通道(Channel)×纵轴(Width)×横轴(Height)，起点为左上角。</p><p><img src="/2021/01/PyTorch%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%AE%9E%E8%B7%B5Part10/image-20210118194753606.png" alt="image-20210118194753606"></p><p>Patch逐Width扫描，矩阵作数乘(哈达玛积)。</p><p><img src="/2021/01/PyTorch%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%AE%9E%E8%B7%B5Part10/image-20210118195245850.png" alt="image-20210118195245850"></p><p>多通道的卷积中，每一个通道都要配一个卷积核，并相加。</p><p>深度学习里的卷积是数学中的互相关，但是惯例称为卷积，和数学中的卷积有点不同，但是不影响。</p><p>n*n的卷积核，上下各-(n-1)/2，原长宽-(n-1)。n一般采用奇数，卷积形状一般都是正方形，在pytorch中奇偶、长方形都行。</p><p><img src="/2021/01/PyTorch%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%AE%9E%E8%B7%B5Part10/image-20210118200458601.png" alt="image-20210118200458601"></p><p>每一组卷积核的通道数量要求和输入通道是一样的。这种卷积核组的总数和输出通道的数量是一样的。卷积过后，通道就与RGB没有关系了。</p><p>卷积(convolution)后，C(Channels)变，W(width)和H(Height)可变可不变，取决于是否填充边缘(padding)，不填充则会有边缘损失。</p><p>卷积层：保留图像的空间信息。卷积本质上也是线性计算，也是可以优化的权重。</p><p>卷积神经网络要求输入输出层是四维张量(Batch, Channel, Width, Height)，卷积层是(m输出通道数量, n输入通道数量, w卷积核宽, h卷积核长)，全连接层的输入与输出都是二维张量(B, Input_feature)。</p><p><img src="/2021/01/PyTorch%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%AE%9E%E8%B7%B5Part10/image-20210118200942877.png" alt="image-20210118200942877"></p><p>下采样(subsampling)或池化(pooling)后，C不变，W和H变成 原长度/池化长度。（MaxPool2d是下采样常用的一种，n*n最大池化默认步长为n）</p><p>池化层与sigmoid一样，没有权重。</p><p><img src="/2021/01/PyTorch%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%AE%9E%E8%B7%B5Part10/image-20210118222617886.png" alt="image-20210118222617886"></p><p>卷积(线性变换)，激活函数(非线性变换)，池化；这个过程若干次后，view打平，进入全连接层。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"></span><br><span class="line">in_channels, out_channels = <span class="number">1</span>, <span class="number">10</span></span><br><span class="line">width, height = <span class="number">10</span>, <span class="number">10</span></span><br><span class="line">kernel_size = <span class="number">3</span></span><br><span class="line">batch_size = <span class="number">1</span></span><br><span class="line"><span class="built_in">input</span> = [<span class="number">3</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">7</span>, <span class="number">2</span>, <span class="number">2</span>,</span><br><span class="line">         <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">6</span>, <span class="number">6</span>, <span class="number">1</span>, <span class="number">6</span>, <span class="number">6</span>,</span><br><span class="line">         <span class="number">7</span>, <span class="number">8</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">7</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">4</span>, <span class="number">6</span>,</span><br><span class="line">         <span class="number">6</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">7</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">6</span>,</span><br><span class="line">         <span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">6</span>,</span><br><span class="line">         <span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">6</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">6</span>,</span><br><span class="line">         <span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">6</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">6</span>,</span><br><span class="line">         <span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">6</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">6</span>,</span><br><span class="line">         <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">6</span>, <span class="number">6</span>, <span class="number">1</span>, <span class="number">6</span>, <span class="number">6</span>,</span><br><span class="line">         <span class="number">7</span>, <span class="number">8</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">7</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">4</span>, <span class="number">6</span>]</span><br><span class="line"><span class="comment"># view()将其转化成4维</span></span><br><span class="line"><span class="built_in">input</span> = torch.Tensor(<span class="built_in">input</span>).view(batch_size, </span><br><span class="line">                                 in_channels, </span><br><span class="line">                                 width, </span><br><span class="line">                                 height)</span><br><span class="line"><span class="comment"># 卷积模型的构造函数中，输入通道数量在前，输出通道数量在后；但是卷积的权重shape是先输出后输入</span></span><br><span class="line"><span class="comment"># padding边缘填充，bias一般卷积不用加偏置，stride步长，kernel_size核大小</span></span><br><span class="line">conv_layer = torch.nn.Conv2d(in_channels,</span><br><span class="line">                             out_channels,</span><br><span class="line">                             kernel_size=kernel_size)</span><br><span class="line">output = conv_layer(<span class="built_in">input</span>)</span><br><span class="line">print(<span class="built_in">input</span>.shape)  <span class="comment"># torch.Size([1, 1, 10, 10])</span></span><br><span class="line">print(output.shape)  <span class="comment"># torch.Size([1, 10, 8, 8])</span></span><br><span class="line">print(conv_layer.weight.shape)  <span class="comment"># torch.Size([10, 1, 3, 3])</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p><img src="/2021/01/PyTorch%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%AE%9E%E8%B7%B5Part10/image-20210119001547566.png" alt="image-20210119001547566"></p><p><img src="/2021/01/PyTorch%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%AE%9E%E8%B7%B5Part10/image-20210119002051268.png" alt="image-20210119002051268"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">from</span> torchvision <span class="keyword">import</span> transforms</span><br><span class="line"><span class="keyword">from</span> torchvision <span class="keyword">import</span> datasets</span><br><span class="line"><span class="keyword">from</span> torch.utils.data <span class="keyword">import</span> DataLoader</span><br><span class="line"><span class="keyword">import</span> torch.nn.functional <span class="keyword">as</span> F</span><br><span class="line"><span class="keyword">import</span> torch.optim <span class="keyword">as</span> optim</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"><span class="comment"># prepare dataset</span></span><br><span class="line"></span><br><span class="line">batch_size = <span class="number">64</span></span><br><span class="line">transform = transforms.Compose([transforms.ToTensor(), transforms.Normalize((<span class="number">0.1307</span>,), (<span class="number">0.3081</span>,))])</span><br><span class="line"></span><br><span class="line">train_dataset = datasets.MNIST(root=<span class="string">&#x27;../dataset/mnist/&#x27;</span>, train=<span class="literal">True</span>, download=<span class="literal">True</span>, transform=transform)</span><br><span class="line">train_loader = DataLoader(train_dataset, shuffle=<span class="literal">True</span>, batch_size=batch_size)</span><br><span class="line">test_dataset = datasets.MNIST(root=<span class="string">&#x27;../dataset/mnist/&#x27;</span>, train=<span class="literal">False</span>, download=<span class="literal">True</span>, transform=transform)</span><br><span class="line">test_loader = DataLoader(test_dataset, shuffle=<span class="literal">False</span>, batch_size=batch_size)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># design model using class</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Net</span>(<span class="params">torch.nn.Module</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="built_in">super</span>(Net, self).__init__()</span><br><span class="line">        self.conv1 = torch.nn.Conv2d(<span class="number">1</span>, <span class="number">10</span>, kernel_size=<span class="number">5</span>)  <span class="comment"># 卷积</span></span><br><span class="line">        self.conv2 = torch.nn.Conv2d(<span class="number">10</span>, <span class="number">20</span>, kernel_size=<span class="number">5</span>)</span><br><span class="line">        self.pooling = torch.nn.MaxPool2d(<span class="number">2</span>)  <span class="comment"># 池化</span></span><br><span class="line">        self.fc = torch.nn.Linear(<span class="number">320</span>, <span class="number">10</span>)  <span class="comment"># 线性</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span>(<span class="params">self, x</span>):</span></span><br><span class="line">        <span class="comment"># flatten data from (n,1,28,28) to (n, 784)</span></span><br><span class="line">        batch_size = x.size(<span class="number">0</span>)  <span class="comment"># 先求batch，多少条记录</span></span><br><span class="line">        x = self.pooling(F.relu(self.conv1(x)))</span><br><span class="line">        x = self.pooling(F.relu(self.conv2(x)))</span><br><span class="line">        x = x.view(batch_size, -<span class="number">1</span>)  <span class="comment"># -1 此处自动算出的是320</span></span><br><span class="line">        <span class="comment"># print(&quot;x.shape&quot;,x.shape)</span></span><br><span class="line">        x = self.fc(x)</span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">model = Net()</span><br><span class="line">device = torch.device(<span class="string">&quot;cuda&quot;</span> <span class="keyword">if</span> torch.cuda.is_available() <span class="keyword">else</span> <span class="string">&quot;cpu&quot;</span>)</span><br><span class="line">model.to(device)  <span class="comment"># GPU加速</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># construct loss and optimizer</span></span><br><span class="line">criterion = torch.nn.CrossEntropyLoss()</span><br><span class="line">optimizer = optim.SGD(model.parameters(), lr=<span class="number">0.01</span>, momentum=<span class="number">0.5</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># training cycle forward, backward, update</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">train</span>(<span class="params">epoch</span>):</span></span><br><span class="line">    running_loss = <span class="number">0.0</span></span><br><span class="line">    <span class="keyword">for</span> batch_idx, data <span class="keyword">in</span> <span class="built_in">enumerate</span>(train_loader, <span class="number">0</span>):</span><br><span class="line">        inputs, target = data</span><br><span class="line">        inputs, target = inputs.to(device), target.to(device)</span><br><span class="line">        optimizer.zero_grad()</span><br><span class="line"></span><br><span class="line">        outputs = model(inputs)</span><br><span class="line">        loss = criterion(outputs, target)</span><br><span class="line">        loss.backward()</span><br><span class="line">        optimizer.step()</span><br><span class="line"></span><br><span class="line">        running_loss += loss.item()</span><br><span class="line">        <span class="keyword">if</span> batch_idx % <span class="number">300</span> == <span class="number">299</span>:</span><br><span class="line">            print(<span class="string">&#x27;[%d, %5d] loss: %.3f&#x27;</span> % (epoch + <span class="number">1</span>, batch_idx + <span class="number">1</span>, running_loss / <span class="number">300</span>))</span><br><span class="line">            running_loss = <span class="number">0.0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test</span>():</span></span><br><span class="line">    correct = <span class="number">0</span></span><br><span class="line">    total = <span class="number">0</span></span><br><span class="line">    <span class="keyword">with</span> torch.no_grad():</span><br><span class="line">        <span class="keyword">for</span> data <span class="keyword">in</span> test_loader:</span><br><span class="line">            images, labels = data</span><br><span class="line">            images, labels = images.to(device), labels.to(device)</span><br><span class="line">            outputs = model(images)</span><br><span class="line">            _, predicted = torch.<span class="built_in">max</span>(outputs.data, dim=<span class="number">1</span>)</span><br><span class="line">            total += labels.size(<span class="number">0</span>)</span><br><span class="line">            correct += (predicted == labels).<span class="built_in">sum</span>().item()</span><br><span class="line">    print(<span class="string">&#x27;accuracy on test set: %d %% &#x27;</span> % (<span class="number">100</span> * correct / total))</span><br><span class="line">    <span class="keyword">return</span> correct / total</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    epoch_list = []</span><br><span class="line">    acc_list = []</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> epoch <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">        train(epoch)</span><br><span class="line">        acc = test()</span><br><span class="line">        epoch_list.append(epoch)</span><br><span class="line">        acc_list.append(acc)</span><br><span class="line"></span><br><span class="line">    plt.plot(epoch_list, acc_list)</span><br><span class="line">    plt.ylabel(<span class="string">&#x27;accuracy&#x27;</span>)</span><br><span class="line">    plt.xlabel(<span class="string">&#x27;epoch&#x27;</span>)</span><br><span class="line">    plt.show()</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> PyTorch深度学习实践 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>PyTorch深度学习实践Part9</title>
      <link href="/2021/01/PyTorch%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%AE%9E%E8%B7%B5Part9/"/>
      <url>/2021/01/PyTorch%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%AE%9E%E8%B7%B5Part9/</url>
      
        <content type="html"><![CDATA[<h1 id="PyTorch深度学习实践Part9——多分类问题"><a href="#PyTorch深度学习实践Part9——多分类问题" class="headerlink" title="PyTorch深度学习实践Part9——多分类问题"></a>PyTorch深度学习实践Part9——多分类问题</h1><h2 id="二分类与多分类"><a href="#二分类与多分类" class="headerlink" title="二分类与多分类"></a>二分类与多分类</h2><ol><li><p>多输出之间会有抑制关系，不能用二分类分别对n个目标输出n次。</p></li><li><p>二分类对0/1只需要求对一个的概率就行，但是多分类需要研究分布差异。</p></li><li><p>中间层用Sigmoid变换，最终输出层用Softmax输出一个分布，将每个最终输出z都变化成<strong>大于0且和为1</strong>(先转正，再归一)。</p><p><img src="/2021/01/PyTorch%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%AE%9E%E8%B7%B5Part9/image-20210118152538935.png" alt="image-20210118152538935"></p><p><img src="/2021/01/PyTorch%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%AE%9E%E8%B7%B5Part9/image-20210118152129056.png" alt="image-20210118152129056"></p><p><img src="/2021/01/PyTorch%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%AE%9E%E8%B7%B5Part9/image-20210118153734193.png" alt="image-20210118153734193"></p></li><li><p>在使用交叉熵损失时，最后一层线性输出不用做激活变换。</p><p><img src="/2021/01/PyTorch%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%AE%9E%E8%B7%B5Part9/image-20210118153824744.png" alt="image-20210118153824744"></p></li><li><p>要理解 CrossEntropyLoss 和 LogSoftmax + NLLLoss 之间的区别</p><p>• <a href="https://pytorch.org/docs/stable/nn.html#crossentropyloss">https://pytorch.org/docs/stable/nn.html#crossentropyloss</a></p><p>• <a href="https://pytorch.org/docs/stable/nn.html#nllloss">https://pytorch.org/docs/stable/nn.html#nllloss</a></p></li></ol><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">from</span> torchvision <span class="keyword">import</span> transforms  <span class="comment"># 针对图像进行的处理</span></span><br><span class="line"><span class="keyword">from</span> torchvision <span class="keyword">import</span> datasets</span><br><span class="line"><span class="keyword">from</span> torch.utils.data <span class="keyword">import</span> DataLoader</span><br><span class="line"><span class="keyword">import</span> torch.nn.functional <span class="keyword">as</span> F</span><br><span class="line"><span class="keyword">import</span> torch.optim <span class="keyword">as</span> optim</span><br><span class="line"></span><br><span class="line"><span class="comment"># prepare dataset</span></span><br><span class="line"></span><br><span class="line">batch_size = <span class="number">64</span></span><br><span class="line"><span class="comment"># 神经网络输入值在[-1,1]效果最好，服从正态分布</span></span><br><span class="line"><span class="comment"># 构建的是Compose类的对象，参数是列表[]</span></span><br><span class="line"><span class="comment"># transforms.ToTensor()：PIL Image =&gt; PyTorch Tensor，单通道变多通道</span></span><br><span class="line"><span class="comment"># transforms.Normalize((mean,), (std,)：归一化，正态分布需要的期望和标准差，映射到[0,1]分布。数据是算好的，换成标准之后可以解决梯度爆炸问题</span></span><br><span class="line">transform = transforms.Compose([transforms.ToTensor(), transforms.Normalize((<span class="number">0.1307</span>,), (<span class="number">0.3081</span>,))])</span><br><span class="line"></span><br><span class="line">train_dataset = datasets.MNIST(root=<span class="string">&#x27;../dataset/mnist/&#x27;</span>, train=<span class="literal">True</span>, download=<span class="literal">True</span>, transform=transform)</span><br><span class="line">train_loader = DataLoader(train_dataset, shuffle=<span class="literal">True</span>, batch_size=batch_size)</span><br><span class="line">test_dataset = datasets.MNIST(root=<span class="string">&#x27;../dataset/mnist/&#x27;</span>, train=<span class="literal">False</span>, download=<span class="literal">True</span>, transform=transform)</span><br><span class="line">test_loader = DataLoader(test_dataset, shuffle=<span class="literal">False</span>, batch_size=batch_size)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># design model using class</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Net</span>(<span class="params">torch.nn.Module</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="built_in">super</span>(Net, self).__init__()</span><br><span class="line">        self.linear1 = torch.nn.Linear(<span class="number">784</span>, <span class="number">512</span>)</span><br><span class="line">        self.linear2 = torch.nn.Linear(<span class="number">512</span>, <span class="number">256</span>)</span><br><span class="line">        self.linear3 = torch.nn.Linear(<span class="number">256</span>, <span class="number">128</span>)</span><br><span class="line">        self.linear4 = torch.nn.Linear(<span class="number">128</span>, <span class="number">64</span>)</span><br><span class="line">        self.linear5 = torch.nn.Linear(<span class="number">64</span>, <span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span>(<span class="params">self, x</span>):</span></span><br><span class="line">        x = x.view(-<span class="number">1</span>, <span class="number">784</span>)  <span class="comment"># -1自动获取mini-batch：N。把样本[N,1,28,28]转变成[N,784]</span></span><br><span class="line">        x = F.relu(self.linear1(x))</span><br><span class="line">        x = F.relu(self.linear2(x))</span><br><span class="line">        x = F.relu(self.linear3(x))</span><br><span class="line">        x = F.relu(self.linear4(x))</span><br><span class="line">        <span class="keyword">return</span> self.linear5(x)  <span class="comment"># 最后一层不做非线性变换</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">model = Net()</span><br><span class="line"></span><br><span class="line"><span class="comment"># construct loss and optimizer</span></span><br><span class="line">criterion = torch.nn.CrossEntropyLoss()</span><br><span class="line">optimizer = optim.SGD(model.parameters(), lr=<span class="number">0.01</span>, momentum=<span class="number">0.5</span>)  <span class="comment"># momentum冲量</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># training cycle</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">train</span>(<span class="params">epoch</span>):</span></span><br><span class="line">    running_loss = <span class="number">0.0</span></span><br><span class="line">    <span class="keyword">for</span> batch_idx, data <span class="keyword">in</span> <span class="built_in">enumerate</span>(train_loader, <span class="number">0</span>):</span><br><span class="line">        inputs, target = data</span><br><span class="line">        optimizer.zero_grad()</span><br><span class="line"></span><br><span class="line">        <span class="comment"># forward</span></span><br><span class="line">        outputs = model(inputs)</span><br><span class="line">        loss = criterion(outputs, target)</span><br><span class="line">        <span class="comment"># backward</span></span><br><span class="line">        loss.backward()</span><br><span class="line">        <span class="comment"># update</span></span><br><span class="line">        optimizer.step()</span><br><span class="line"></span><br><span class="line">        running_loss += loss.item()</span><br><span class="line">        <span class="keyword">if</span> batch_idx % <span class="number">300</span> == <span class="number">299</span>:</span><br><span class="line">            print(<span class="string">&#x27;[%d, %5d] loss: %.3f&#x27;</span> % (epoch + <span class="number">1</span>, batch_idx + <span class="number">1</span>, running_loss / <span class="number">300</span>))</span><br><span class="line">            running_loss = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test</span>():</span></span><br><span class="line">    correct = <span class="number">0</span></span><br><span class="line">    total = <span class="number">0</span></span><br><span class="line">    <span class="keyword">with</span> torch.no_grad():  <span class="comment"># 包裹的一部分不会构建计算图</span></span><br><span class="line">        <span class="keyword">for</span> data <span class="keyword">in</span> test_loader:</span><br><span class="line">            images, labels = data</span><br><span class="line">            outputs = model(images)</span><br><span class="line">            _, predicted = torch.<span class="built_in">max</span>(outputs.data, dim=<span class="number">1</span>)  <span class="comment"># 列是dim=0，行是dim=1。返回最大值和最大值的下标</span></span><br><span class="line">            total += labels.size(<span class="number">0</span>)</span><br><span class="line">            correct += (predicted == labels).<span class="built_in">sum</span>().item()  <span class="comment"># 序列求和，一共猜对的数量</span></span><br><span class="line">    print(<span class="string">&#x27;accuracy on test set: %d %% &#x27;</span> % (<span class="number">100</span> * correct / total))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="keyword">for</span> epoch <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">        train(epoch)</span><br><span class="line">        test()</span><br><span class="line"></span><br><span class="line"><span class="comment"># [1,   300] loss: 2.244</span></span><br><span class="line"><span class="comment"># [1,   600] loss: 1.005</span></span><br><span class="line"><span class="comment"># [1,   900] loss: 0.437</span></span><br><span class="line"><span class="comment"># ..........................</span></span><br><span class="line"><span class="comment"># [8,   300] loss: 0.045</span></span><br><span class="line"><span class="comment"># [8,   600] loss: 0.051</span></span><br><span class="line"><span class="comment"># [8,   900] loss: 0.048</span></span><br><span class="line"><span class="comment"># accuracy on test set: 97 % </span></span><br><span class="line"><span class="comment"># [9,   300] loss: 0.034</span></span><br><span class="line"><span class="comment"># [9,   600] loss: 0.039</span></span><br><span class="line"><span class="comment"># [9,   900] loss: 0.044</span></span><br><span class="line"><span class="comment"># accuracy on test set: 97 % </span></span><br><span class="line"><span class="comment"># [10,   300] loss: 0.030</span></span><br><span class="line"><span class="comment"># [10,   600] loss: 0.027</span></span><br><span class="line"><span class="comment"># [10,   900] loss: 0.036</span></span><br><span class="line"><span class="comment"># accuracy on test set: 96 %</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><ol><li><a href="https://blog.csdn.net/Answer3664/article/details/99460175">torch.no_grad()</a>  <a href="https://blog.csdn.net/ego_bai/article/details/80873242">Python中with的用法</a></li><li><a href="https://zhuanlan.zhihu.com/p/105783765?utm_source=com.miui.notes">Python中各种下划线的操作</a> </li><li><a href="https://blog.csdn.net/Z_lbj/article/details/79766690">torch.max( )的用法</a> <a href="https://blog.csdn.net/qq_40210586/article/details/103874000">torch.max( )使用讲解</a></li><li>用全连接神经网络训练图像会忽略局部信息的利用，在距离很远的两个点都会产生联系，而这个是没必要的。</li><li>图像的特征提取：傅里叶变换（缺点：都是正弦波）、Wavelet、小波。但是这些都是人工提取。自动提取的有：CNN</li></ol>]]></content>
      
      
      <categories>
          
          <category> PyTorch深度学习实践 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>PyTorch深度学习实践Part8</title>
      <link href="/2021/01/PyTorch%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%AE%9E%E8%B7%B5Part8/"/>
      <url>/2021/01/PyTorch%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%AE%9E%E8%B7%B5Part8/</url>
      
        <content type="html"><![CDATA[<h1 id="PyTorch深度学习实践Part8——加载数据集"><a href="#PyTorch深度学习实践Part8——加载数据集" class="headerlink" title="PyTorch深度学习实践Part8——加载数据集"></a>PyTorch深度学习实践Part8——加载数据集</h1><h2 id="Dataset-and-DataLoader"><a href="#Dataset-and-DataLoader" class="headerlink" title="Dataset and DataLoader"></a>Dataset and DataLoader</h2><ol><li><p>Dataset：主要构造数据集，支持索引。</p></li><li><p>DataLoader：主要能拿出mini-batch，拿出一组组数据以快速使用。</p><p>改成mini-batch之后，训练循环会变成一个二层的嵌套循环，第一层迭代epoch，第二层迭代mini-batch。</p></li><li><p>Epoch：将所有的样本都参与了一次正向传播、训练，是一次epoch。</p></li><li><p>Batch-Size：每次训练(前馈+反馈+更新)所用的样本数量。</p></li><li><p>Iteration：batch分了多少批，内层的迭代执行多少次。例如：1w个样本，1k个batch，iteration为10。</p></li></ol><p><img src="/2021/01/PyTorch%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%AE%9E%E8%B7%B5Part8/image-20210118100748425.png" alt="image-20210118100748425"></p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>处理数据方式</p><ol><li>全部读取到内存，适用于关系表或者小批量结构化的数据。</li><li>将数据文件分开，路径存放在列表中打包，适用于图像、音频等非结构化数据。</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">from</span> torch.utils.data <span class="keyword">import</span> DataLoader</span><br><span class="line"><span class="keyword">from</span> torch.utils.data <span class="keyword">import</span> Dataset  <span class="comment"># Dataset是抽象类，需要继承</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 处理数据</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DiabetesDataset</span>(<span class="params">Dataset</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, filepath</span>):</span>  <span class="comment"># 初始化，提供数据集路径加载</span></span><br><span class="line">        xy = np.loadtxt(filepath, delimiter=<span class="string">&#x27;,&#x27;</span>, dtype=np.float32)</span><br><span class="line">        self.<span class="built_in">len</span> = xy.shape[<span class="number">0</span>]  <span class="comment"># shape(行数,列数)是元组</span></span><br><span class="line">        self.x_data = torch.from_numpy(xy[:, :-<span class="number">1</span>])</span><br><span class="line">        self.y_data = torch.from_numpy(xy[:, [-<span class="number">1</span>]])</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getitem__</span>(<span class="params">self, index</span>):</span>  <span class="comment"># 获取数据索引</span></span><br><span class="line">        <span class="keyword">return</span> self.x_data[index], self.y_data[index]  <span class="comment"># 返回的是元组</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__len__</span>(<span class="params">self</span>):</span>  <span class="comment"># 获取数据总量</span></span><br><span class="line">        <span class="keyword">return</span> self.<span class="built_in">len</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">dataset = DiabetesDataset(<span class="string">&#x27;diabetes.csv.gz&#x27;</span>)</span><br><span class="line"><span class="comment"># shuffle=True打乱mini-batch保证随机，num_workers多线程</span></span><br><span class="line">train_loader = DataLoader(dataset=dataset, batch_size=<span class="number">32</span>, shuffle=<span class="literal">True</span>, num_workers=<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建模型</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Model</span>(<span class="params">torch.nn.Module</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="built_in">super</span>(Model, self).__init__()</span><br><span class="line">        self.linear1 = torch.nn.Linear(<span class="number">8</span>, <span class="number">6</span>)</span><br><span class="line">        self.linear2 = torch.nn.Linear(<span class="number">6</span>, <span class="number">4</span>)</span><br><span class="line">        self.linear3 = torch.nn.Linear(<span class="number">4</span>, <span class="number">1</span>)</span><br><span class="line">        self.activate = torch.nn.Sigmoid()  <span class="comment"># 是模块而不是函数，没有参数，没有需要训练的地方，只用来构建计算图</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span>(<span class="params">self, x</span>):</span></span><br><span class="line">        x = self.activate(self.linear1(x))</span><br><span class="line">        x = self.activate(self.linear2(x))</span><br><span class="line">        x = self.activate(self.linear3(x))</span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">model = Model()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 损失&amp;优化</span></span><br><span class="line">criterion = torch.nn.BCELoss(reduction=<span class="string">&#x27;mean&#x27;</span>)</span><br><span class="line"><span class="comment"># model.parameters()会扫描module中的所有成员，如果成员中有相应权重，那么都会将结果加到要训练的参数集合上</span></span><br><span class="line">optimizer = torch.optim.SGD(model.parameters(), lr=<span class="number">1</span>)</span><br><span class="line">loss_list = []</span><br><span class="line"></span><br><span class="line"><span class="comment"># 循环训练</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:  <span class="comment"># 在windows系统下要用if封装训练循环，否则会报错</span></span><br><span class="line">    <span class="keyword">for</span> epoch <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">100</span>):</span><br><span class="line">        loss_sum = <span class="number">0</span></span><br><span class="line">        num = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i, data <span class="keyword">in</span> <span class="built_in">enumerate</span>(train_loader, <span class="number">0</span>):</span><br><span class="line">            <span class="comment"># prepare data</span></span><br><span class="line">            inputs, labels = data  <span class="comment"># 此时两个已经转化成tensor</span></span><br><span class="line">            <span class="comment"># Forward</span></span><br><span class="line">            y_pred = model(inputs)</span><br><span class="line">            loss = criterion(y_pred, labels)</span><br><span class="line">            print(epoch, i, loss.item())</span><br><span class="line"></span><br><span class="line">            loss_sum += loss.item()</span><br><span class="line">            num += <span class="number">1</span></span><br><span class="line">            <span class="comment"># Backward</span></span><br><span class="line">            optimizer.zero_grad()</span><br><span class="line">            loss.backward()</span><br><span class="line">            <span class="comment"># Update</span></span><br><span class="line">            optimizer.step()</span><br><span class="line"></span><br><span class="line">        loss_list.append(loss_sum / num)</span><br><span class="line"></span><br><span class="line">    plt.plot(<span class="built_in">range</span>(<span class="number">100</span>), loss_list)</span><br><span class="line">    plt.ylabel(<span class="string">&#x27;loss&#x27;</span>)</span><br><span class="line">    plt.xlabel(<span class="string">&#x27;epoch&#x27;</span>)</span><br><span class="line">    plt.show()</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="/2021/01/PyTorch%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%AE%9E%E8%B7%B5Part8/image-20210118110538070.png" alt="image-20210118110538070"></p><p>二层循环速度反而变慢了，效率也没有很大提升？t</p>]]></content>
      
      
      <categories>
          
          <category> PyTorch深度学习实践 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>PyTorch深度学习实践Part7</title>
      <link href="/2021/01/PyTorch%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%AE%9E%E8%B7%B5Part7/"/>
      <url>/2021/01/PyTorch%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%AE%9E%E8%B7%B5Part7/</url>
      
        <content type="html"><![CDATA[<h1 id="PyTorch深度学习实践Part7——处理多维特征的输入"><a href="#PyTorch深度学习实践Part7——处理多维特征的输入" class="headerlink" title="PyTorch深度学习实践Part7——处理多维特征的输入"></a>PyTorch深度学习实践Part7——处理多维特征的输入</h1><h2 id="多维特征输入"><a href="#多维特征输入" class="headerlink" title="多维特征输入"></a>多维特征输入</h2><p>从单一特征的数据，转而输入多为特征的数据，模型发生以下改变：</p><ol><li><p>对于每一条(/第i条)有n个特征(x1…xn)的数据，则有n个不同的weight(w1…wn)和1个相同的bias(b将进行广播)，并通过非线性激活函数，得出一个y_hat（假设输出维度为1）。</p><p><img src="/2021/01/PyTorch%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%AE%9E%E8%B7%B5Part7/image-20210117203233443.png" alt="image-20210117203233443"></p></li><li><p>对于每个zn(=xn*wn+b)都要通过非线性激活函数，Sigmoid函数是对于每个元素的，类似于numpy。</p><p><img src="/2021/01/PyTorch%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%AE%9E%E8%B7%B5Part7/image-20210117203726634.png" alt="image-20210117203726634"></p></li><li><p>转换成矩阵运算可以发挥cpu/gpu并行运算的优势。</p></li><li><p>在之前的代码上，想要进行多维输入，只需要修改样本以及模型构造函数。</p></li></ol><h2 id="增加神经网络层数"><a href="#增加神经网络层数" class="headerlink" title="增加神经网络层数"></a>增加神经网络层数</h2><ol><li>如何增加神经网络层数？将多层模型输入和输出，<strong>头尾相连</strong>。例如：torch.nn.Linear(8, 6)、torch.nn.Linear(6, 4)、torch.nn.Linear(4, 1)。</li><li>什么是矩阵？矩阵是<strong>空间变换函数</strong>。例如：y=A*x，y是M×1的矩阵，x是N×1的矩阵，A是M×N的矩阵，则A就是将x从N维转换到y这个M维空间的空间变换函数。</li><li>矩阵是线性变换，但是很多实际情况都是复杂、非线性的。所以，需要用多个线性变换层，通过找到最优的权重组合起来，来模拟非线性的变换。<strong>寻找非线性变换函数</strong>，就是神经网络的本质。</li><li>多层神经网络可以降维也可以升维，至于如何达到最优，则是<strong>超参数的搜索</strong>。</li><li>神经元、网络层数越多，学习能力就越强，但是同时要小心过拟合的问题。要学习数据真值和具备泛化的能力。</li></ol><p><img src="/2021/01/PyTorch%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%AE%9E%E8%B7%B5Part7/image-20210117212227590.png" alt="image-20210117212227590"></p><blockquote><p><strong>能在编程道路上立稳脚跟的核心能力：</strong></p><ol><li>读文档</li><li>基本架构理念(cpu、操作系统、主机、编译原理)</li></ol></blockquote><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 处理数据</span></span><br><span class="line">xy = np.loadtxt(<span class="string">&#x27;diabetes.csv.gz&#x27;</span>, delimiter=<span class="string">&#x27;,&#x27;</span>, dtype=np.float32)  <span class="comment"># 分隔符&#x27;,&#x27;，大多数显卡只支持32位float</span></span><br><span class="line">x_data = torch.from_numpy(xy[:, :-<span class="number">1</span>])  <span class="comment"># 左闭右开，取所有行、第一列到最后第二列。torch.from_numpy返回tensor</span></span><br><span class="line">y_data = torch.from_numpy(xy[:, [-<span class="number">1</span>]])  <span class="comment"># 取所有行、最后一列。[-1]表示拿出来的是矩阵，-1表示拿出来的是向量</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建模型</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Model</span>(<span class="params">torch.nn.Module</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="built_in">super</span>(Model, self).__init__()</span><br><span class="line">        self.linear1 = torch.nn.Linear(<span class="number">8</span>, <span class="number">6</span>)</span><br><span class="line">        self.linear2 = torch.nn.Linear(<span class="number">6</span>, <span class="number">4</span>)</span><br><span class="line">        self.linear3 = torch.nn.Linear(<span class="number">4</span>, <span class="number">1</span>)</span><br><span class="line">        self.activate = torch.nn.Sigmoid()  <span class="comment"># 是模块而不是函数，没有参数，没有需要训练的地方，只用来构建计算图</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span>(<span class="params">self, x</span>):</span></span><br><span class="line">        x = self.activate(self.linear1(x))</span><br><span class="line">        x = self.activate(self.linear2(x))</span><br><span class="line">        x = self.activate(self.linear3(x))</span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">model = Model()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 损失&amp;优化</span></span><br><span class="line">criterion = torch.nn.BCELoss(reduction=<span class="string">&#x27;mean&#x27;</span>)</span><br><span class="line">optimizer = torch.optim.SGD(model.parameters(), lr=<span class="number">1.0</span>)</span><br><span class="line">loss_list = []</span><br><span class="line"></span><br><span class="line"><span class="comment"># 循环训练</span></span><br><span class="line"><span class="keyword">for</span> epoch <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">500000</span>):</span><br><span class="line">    <span class="comment"># Forward</span></span><br><span class="line">    y_pred = model(x_data)  <span class="comment"># 这里并没有用到mini-batch</span></span><br><span class="line">    loss = criterion(y_pred, y_data)</span><br><span class="line">    print(epoch, loss.item())</span><br><span class="line">    loss_list.append(loss.item())</span><br><span class="line">    <span class="comment"># Backward</span></span><br><span class="line">    optimizer.zero_grad()</span><br><span class="line">    loss.backward()</span><br><span class="line">    <span class="comment"># Update</span></span><br><span class="line">    optimizer.step()</span><br><span class="line"></span><br><span class="line">plt.plot(<span class="built_in">range</span>(<span class="number">500000</span>), loss_list)</span><br><span class="line">plt.ylabel(<span class="string">&#x27;loss&#x27;</span>)</span><br><span class="line">plt.xlabel(<span class="string">&#x27;epoch&#x27;</span>)</span><br><span class="line">plt.show()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看不同网络层参数</span></span><br><span class="line">layer1_weight = model.linear1.weight.data</span><br><span class="line">layer1_bias = model.linear1.bias.data</span><br><span class="line">print(<span class="string">&quot;layer1_weight&quot;</span>, layer1_weight)</span><br><span class="line">print(<span class="string">&quot;layer1_weight.shape&quot;</span>, layer1_weight.shape)</span><br><span class="line">print(<span class="string">&quot;layer1_bias&quot;</span>, layer1_bias)</span><br><span class="line">print(<span class="string">&quot;layer1_bias.shape&quot;</span>, layer1_bias.shape)</span><br><span class="line"></span><br></pre></td></tr></table></figure><ol><li>在100次训练时，损失卡在了0.65。</li><li>在1w次训练时，损失跨过0.65停在了0.45。</li><li>将学习率提升到10.0，1w次训练可以看出图像震荡，无法收敛，但是损失突破0.4以下。</li><li>将学习率调整到1.0，10w次训练，损失突破0.3以下</li><li>学习率1.0，50w次训练，损失达到0.28</li><li><a href="https://pytorch.org/docs/stable/nn.html#non-linear-activations-weighted-sum-nonlinearity">pytorch激活函数文档</a></li></ol><p><img src="/2021/01/PyTorch%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%AE%9E%E8%B7%B5Part7/image-20210117233025403.png" alt="image-20210117233025403"></p><p><img src="/2021/01/PyTorch%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%AE%9E%E8%B7%B5Part7/image-20210117235832948.png" alt="image-20210117235832948"></p>]]></content>
      
      
      <categories>
          
          <category> PyTorch深度学习实践 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>PyTorch深度学习实践Part6</title>
      <link href="/2021/01/PyTorch%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%AE%9E%E8%B7%B5Part6/"/>
      <url>/2021/01/PyTorch%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%AE%9E%E8%B7%B5Part6/</url>
      
        <content type="html"><![CDATA[<h1 id="PyTorch深度学习实践Part6——逻辑斯蒂回归"><a href="#PyTorch深度学习实践Part6——逻辑斯蒂回归" class="headerlink" title="PyTorch深度学习实践Part6——逻辑斯蒂回归"></a>PyTorch深度学习实践Part6——逻辑斯蒂回归</h1><h2 id="分类问题"><a href="#分类问题" class="headerlink" title="分类问题"></a>分类问题</h2><p>逻辑斯蒂回归是处理分类问题，而不是回归任务。</p><p>处理分类问题，不能使用回归的思想，即使输出可以为0或1。原因在于：若有一个0-9，10个手写数字的分类问题，在回归模型中，1和0距离很近，0和9离得很远，但是在分类模型中，7和9的相似度就比8与7或9的相似度要高。</p><p>分类问题本质上输出的是概率，例如P(0)、P(1)…。</p><h3 id="二分类问题"><a href="#二分类问题" class="headerlink" title="二分类问题"></a>二分类问题</h3><p>通过考试的概率是多少</p><h3 id="多分类问题"><a href="#多分类问题" class="headerlink" title="多分类问题"></a>多分类问题</h3><p>0-9手写数字检测分类</p><h2 id="torchvision工具包"><a href="#torchvision工具包" class="headerlink" title="torchvision工具包"></a>torchvision工具包</h2><p>指定目录，训练/测试，是否需要下载</p><p>MNIST、CIFAR10…</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torchvision</span><br><span class="line">train_set = torchvision.datasets.MNIST(root=<span class="string">&#x27;../dataset/mnist&#x27;</span>, train=<span class="literal">True</span>, download=<span class="literal">True</span>)</span><br><span class="line">test_set = torchvision.datasets.MNIST(root=<span class="string">&#x27;../dataset/mnist&#x27;</span>, train=<span class="literal">False</span>, download=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure><h2 id="饱和函数"><a href="#饱和函数" class="headerlink" title="饱和函数"></a>饱和函数</h2><h3 id="逻辑斯蒂函数"><a href="#逻辑斯蒂函数" class="headerlink" title="逻辑斯蒂函数"></a>逻辑斯蒂函数</h3><p><img src="/2021/01/PyTorch%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%AE%9E%E8%B7%B5Part6/image-20210117161720715.png" alt="image-20210117161720715"></p><h3 id="其他Sigmoid-functions"><a href="#其他Sigmoid-functions" class="headerlink" title="其他Sigmoid functions"></a>其他Sigmoid functions</h3><p><img src="/2021/01/PyTorch%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%AE%9E%E8%B7%B5Part6/image-20210117161834404.png" alt="image-20210117161834404"></p><h2 id="逻辑斯蒂回归"><a href="#逻辑斯蒂回归" class="headerlink" title="逻辑斯蒂回归"></a>逻辑斯蒂回归</h2><ol><li><p>Logistic Regression类似于正态分布。</p></li><li><p>Logistic Regression是Sigmoid functions中最著名的，所以有些地方用Sigmoid指代Logistic。</p></li><li><p>逻辑斯蒂回归和线性模型的明显区别是在线性模型的后面，添加了激活函数(非线性变换)，将y_hat代入逻辑斯蒂公式中的x。</p></li><li><p><a href="https://blog.csdn.net/C_chuxin/article/details/86174807">交叉熵损失函数的推导过程与直观理解</a></p></li><li><p>y_hat是预测的值[0,1]之间的概率，y是真实值，预测与标签越接近，BCE损失越小。</p></li></ol><p><img src="/2021/01/PyTorch%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%AE%9E%E8%B7%B5Part6/image-20210117164616620.png" alt="image-20210117164616620"></p><blockquote><p>要计算的是分布的差异，而不是数值上的距离</p></blockquote><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><ol><li><a href="https://blog.csdn.net/weixin_42621901/article/details/107664771">torch.sigmoid()、torch.nn.Sigmoid()和torch.nn.functional.sigmoid()三者之间的区别</a></li><li>BCELoss(Binary CrossEntropyLoss)是CrossEntropyLoss的一个特例，只用于二分类问题，而CrossEntropyLoss可以用于二分类，也可以用于多分类。</li><li><a href="https://www.cnblogs.com/samwoog/p/13857843.html">BCE和CE交叉熵损失函数的区别</a></li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"><span class="comment"># ---------------------------Prepare dataset----------------------------#</span></span><br><span class="line">x_data = torch.Tensor([[<span class="number">1.0</span>], [<span class="number">2.0</span>], [<span class="number">3.0</span>]])</span><br><span class="line">y_data = torch.Tensor([[<span class="number">0</span>], [<span class="number">0</span>], [<span class="number">1</span>]])  <span class="comment"># 二分类</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># ---------------------------Design model using Class----------------------------#</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LogisticRegressionModel</span>(<span class="params">torch.nn.Module</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="built_in">super</span>(LogisticRegressionModel, self).__init__()</span><br><span class="line">        self.linear = torch.nn.Linear(<span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># nn.functional.sigmoid is deprecated</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span>(<span class="params">self, x</span>):</span></span><br><span class="line">        <span class="keyword">return</span> torch.sigmoid(self.linear(x))  <span class="comment"># 激活函数sigmoid不需要参数训练，直接调用</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">model = LogisticRegressionModel()</span><br><span class="line"><span class="comment"># --------------------------Construct loss and optimizer-----------------------------#</span></span><br><span class="line">criterion = torch.nn.BCELoss(reduction=<span class="string">&#x27;sum&#x27;</span>)  <span class="comment"># 交叉熵，size_average=False已经被弃用</span></span><br><span class="line">optimizer = torch.optim.SGD(model.parameters(), lr=<span class="number">0.01</span>)</span><br><span class="line"><span class="comment"># --------------------------Training cycle-----------------------------#</span></span><br><span class="line">loss_list = []</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> epoch <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1000</span>):</span><br><span class="line">    y_pred = model(x_data)  <span class="comment"># 正向传播</span></span><br><span class="line">    loss = criterion(y_pred, y_data)  <span class="comment"># 计算损失</span></span><br><span class="line">    print(epoch, loss.item())</span><br><span class="line">    loss_list.append(loss.item())  <span class="comment"># 保存loss</span></span><br><span class="line"></span><br><span class="line">    optimizer.zero_grad()  <span class="comment"># 将梯度归零</span></span><br><span class="line">    loss.backward()  <span class="comment"># 反向传播</span></span><br><span class="line">    optimizer.step()  <span class="comment"># 进行更新</span></span><br><span class="line"></span><br><span class="line">print(<span class="string">&#x27;w = &#x27;</span>, model.linear.weight.item())</span><br><span class="line">print(<span class="string">&#x27;b = &#x27;</span>, model.linear.bias.item())</span><br><span class="line"></span><br><span class="line">x_test = torch.Tensor([[<span class="number">4.0</span>]])</span><br><span class="line">y_test = model(x_test)</span><br><span class="line">print(<span class="string">&#x27;y_pred = &#x27;</span>, y_test.item())</span><br><span class="line"></span><br><span class="line">plt.plot(<span class="built_in">range</span>(<span class="number">1000</span>), loss_list)</span><br><span class="line">plt.ylabel(<span class="string">&#x27;Loss&#x27;</span>)</span><br><span class="line">plt.xlabel(<span class="string">&#x27;Epoch&#x27;</span>)</span><br><span class="line">plt.show()</span><br><span class="line"><span class="comment"># y_pred =  0.8808996081352234</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="/2021/01/PyTorch%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%AE%9E%E8%B7%B5Part6/image-20210117172329760.png" alt="image-20210117172329760"></p>]]></content>
      
      
      <categories>
          
          <category> PyTorch深度学习实践 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>PyTorch深度学习实践Part5</title>
      <link href="/2021/01/PyTorch%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%AE%9E%E8%B7%B5Part5/"/>
      <url>/2021/01/PyTorch%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%AE%9E%E8%B7%B5Part5/</url>
      
        <content type="html"><![CDATA[<h1 id="PyTorch深度学习实践Part5——线性回归"><a href="#PyTorch深度学习实践Part5——线性回归" class="headerlink" title="PyTorch深度学习实践Part5——线性回归"></a>PyTorch深度学习实践Part5——线性回归</h1><h2 id="PyTorch周期"><a href="#PyTorch周期" class="headerlink" title="PyTorch周期"></a>PyTorch周期</h2><ol><li>prepare dataset</li><li>design model using Class 目的是为了前馈forward，即计算y hat(预测值)</li><li>Construct loss and optimizer (using PyTorch API) 其中，计算loss是为了进行反向传播，optimizer是为了更新梯度。</li><li>Training cycle (<u><strong><em>forward,backward,update</em></strong></u>)</li></ol><h2 id="广播"><a href="#广播" class="headerlink" title="广播"></a>广播</h2><p>原本w只是1×1的矩阵，比如tensor([0.], requires_grad=True)，很有可能行列数量与xy对不上，这个时候pytorch会进行<strong>广播</strong>，将w<strong>扩展成一个3×1矩阵</strong>。</p><p><img src="/2021/01/PyTorch%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%AE%9E%E8%B7%B5Part5/image-20210117122903497.png" alt="image-20210117122903497"></p><blockquote><p>pytorch直接写“*”表示矩阵<strong>对应位置元素相乘</strong>（哈达玛积），数学上的矩阵乘法有另外的函数torch.matmul</p></blockquote><p>这里x、y的维度都是1（有可能不是1），但是都应当看成一个<strong>矩阵</strong>，而不能是向量。</p><blockquote><p>x、y的列是维度/特征，行是记录/样本</p></blockquote><h2 id="模型"><a href="#模型" class="headerlink" title="模型"></a>模型</h2><ol><li>要把计算模型定义成一个类，<strong>继承于torch.nn.Model</strong>。（nn：neural network）</li><li>如果有pytorch没有提供的需求，或者其效率不够高，可以从Function中继承，构造自己的计算块。</li><li>Linear类包括成员变量weight和bias，默认bias=True，同样继承于torch.nn.Model，可以进行反向传播。</li><li>权重放在x右边，或者转置放在左边。（不管怎么放都是为了凑矩阵基本积）</li><li>父类实现了callable函数，让其能够被调用。在call中会调用前馈forward()，所以必须重写forward()。</li></ol><p><img src="/2021/01/PyTorch%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%AE%9E%E8%B7%B5Part5/image-20210117132843838.png" alt="image-20210117132843838"></p><p>*args, **kwargs的用法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fun</span>(<span class="params">*args, **kwargs</span>):</span></span><br><span class="line">    print(<span class="string">&#x27;args:&#x27;</span>, args)</span><br><span class="line">    print(<span class="string">&#x27;kwargs:&#x27;</span>, kwargs)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">fun(<span class="number">1</span>, <span class="number">2</span>, <span class="number">7</span>, x=<span class="number">6</span>, y=<span class="number">5</span>)</span><br><span class="line"><span class="comment"># args: (1, 2, 7)</span></span><br><span class="line"><span class="comment"># kwargs: &#123;&#x27;x&#x27;: 6&#125;</span></span><br></pre></td></tr></table></figure><h2 id="损失-amp-优化"><a href="#损失-amp-优化" class="headerlink" title="损失&amp;优化"></a>损失&amp;优化</h2><ol><li>计算损失使用现成的类 torch.nn.MSELoss 。</li><li>一般使用随机梯度下降算法，求和平均是没有必要的，torch.nn.MSELoss(size_average=<strong>False</strong>)</li><li>使用现成的优化器类torch.optim.SGD</li><li><a href="https://pytorch.org/docs/1.7.0/optim.html">不同的优化器，官方文档</a></li><li>控制训练次数，不能过少（训练不到位），也不能过多（过拟合）</li></ol><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 准备数据，要是矩阵</span></span><br><span class="line">x_data = torch.Tensor([[<span class="number">1.0</span>], [<span class="number">2.0</span>], [<span class="number">3.0</span>]])</span><br><span class="line">y_data = torch.Tensor([[<span class="number">2.0</span>], [<span class="number">4.0</span>], [<span class="number">6.0</span>]])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 构建模型，继承、重写</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LinearModel</span>(<span class="params">torch.nn.Module</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="built_in">super</span>(LinearModel, self).__init__()</span><br><span class="line">        self.linear = torch.nn.Linear(<span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span>(<span class="params">self, x</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self.linear(x)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成模型的对象</span></span><br><span class="line">model = LinearModel()</span><br><span class="line">criterion = torch.nn.MSELoss(reduction=<span class="string">&#x27;sum&#x27;</span>)  <span class="comment"># size_average=False已经被弃用</span></span><br><span class="line">optimizer = torch.optim.SGD(model.parameters(), lr=<span class="number">0.01</span>)  <span class="comment"># 这里要设置迭代器管理的权重</span></span><br><span class="line"></span><br><span class="line">loss_list = []</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> epoch <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">100</span>):</span><br><span class="line">    y_pred = model(x_data)  <span class="comment"># __call__()调用forward()正向传播计算预测值</span></span><br><span class="line">    loss = criterion(y_pred, y_data)  <span class="comment"># 计算损失</span></span><br><span class="line">    print(epoch, loss.item())  <span class="comment"># 可以直接打印loss，因为调用的是__str__()不会产生计算图</span></span><br><span class="line">    loss_list.append(loss.item())  <span class="comment"># 保存loss</span></span><br><span class="line"></span><br><span class="line">    optimizer.zero_grad()  <span class="comment"># 将梯度归零，这一步要在下一轮计算反向传播之前进行</span></span><br><span class="line">    loss.backward()  <span class="comment"># 反向传播，计算梯度</span></span><br><span class="line">    optimizer.step()  <span class="comment"># 进行更新</span></span><br><span class="line"></span><br><span class="line">print(<span class="string">&#x27;w = &#x27;</span>, model.linear.weight.item())</span><br><span class="line">print(<span class="string">&#x27;b = &#x27;</span>, model.linear.bias.item())</span><br><span class="line"></span><br><span class="line">x_test = torch.Tensor([[<span class="number">4.0</span>]])</span><br><span class="line">y_test = model(x_test)  <span class="comment"># 使用训练好的模型进行预测</span></span><br><span class="line">print(<span class="string">&#x27;y_pred = &#x27;</span>, y_test.item())</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打印图表</span></span><br><span class="line">plt.plot(<span class="built_in">range</span>(<span class="number">100</span>), loss_list)</span><br><span class="line">plt.ylabel(<span class="string">&#x27;Loss&#x27;</span>)</span><br><span class="line">plt.xlabel(<span class="string">&#x27;Epoch&#x27;</span>)</span><br><span class="line">plt.show()</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="课后作业"><a href="#课后作业" class="headerlink" title="课后作业"></a>课后作业</h2><p>测试不同的优化器。除了LBFGS，只需要修改调用对应优化器的构造器。</p><h3 id="Adagrad"><a href="#Adagrad" class="headerlink" title="Adagrad"></a>Adagrad</h3><p>w =  0.20570674538612366</p><p>b =  -0.5057424902915955</p><p>y_pred =  0.31708449125289917</p><p><img src="/2021/01/PyTorch%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%AE%9E%E8%B7%B5Part5/image-20210117152240566.png" alt="image-20210117152240566"></p><h3 id="Adam"><a href="#Adam" class="headerlink" title="Adam"></a>Adam</h3><p>w =  1.466607928276062</p><p>b =  0.14079217612743378</p><p>y_pred =  6.007224082946777</p><p><img src="/2021/01/PyTorch%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%AE%9E%E8%B7%B5Part5/image-20210117152322232.png" alt="image-20210117152322232"></p><h3 id="Adamax"><a href="#Adamax" class="headerlink" title="Adamax"></a>Adamax</h3><p>w =  -0.022818174213171005</p><p>b =  0.9245702028274536</p><p>y_pred =  0.8332974910736084</p><p><img src="/2021/01/PyTorch%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%AE%9E%E8%B7%B5Part5/image-20210117152149494.png" alt="image-20210117152149494"></p><h3 id="ASGD"><a href="#ASGD" class="headerlink" title="ASGD"></a>ASGD</h3><p>w =  1.6153326034545898</p><p>b =  0.87442547082901</p><p>y_pred =  7.335755825042725</p><p><img src="/2021/01/PyTorch%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%AE%9E%E8%B7%B5Part5/image-20210117151915659.png" alt="image-20210117151915659"></p><h3 id="LBFGS"><a href="#LBFGS" class="headerlink" title="LBFGS"></a>LBFGS</h3><p>由于LBFGS算法需要重复多次计算函数，因此需要传入一个闭包去允许它们重新计算模型。这个闭包应当清空梯度， 计算损失，然后返回。</p><p>参考<a href="https://blog.csdn.net/ys1305/article/details/94332643">一篇关于优化器的博文</a></p><p>训练模型部分代码应修改为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">closure</span>():</span></span><br><span class="line">    optimizer.zero_grad()  <span class="comment"># 将梯度归零</span></span><br><span class="line">    y_pred = model(x_data)  <span class="comment"># __call__()调用forward()正向传播计算预测值</span></span><br><span class="line">    loss = criterion(y_pred, y_data)  <span class="comment"># 计算损失</span></span><br><span class="line">    print(epoch, loss.item())  <span class="comment"># 可以直接打印loss，因为调用的是__str__()不会产生计算图</span></span><br><span class="line">    loss_list.append(loss.item())  <span class="comment"># 保存loss</span></span><br><span class="line">    loss.backward()  <span class="comment"># 反向传播</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> epoch <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">100</span>):</span><br><span class="line">    optimizer.step(closure())  <span class="comment"># 进行更新</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>w =  1.7660775184631348</p><p>b =  0.531760573387146</p><p>y_pred =  7.596070766448975</p><p><img src="/2021/01/PyTorch%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%AE%9E%E8%B7%B5Part5/image-20210117153648037.png" alt="image-20210117153648037"></p><h3 id="RMSprop"><a href="#RMSprop" class="headerlink" title="RMSprop"></a>RMSprop</h3><p>w =  1.734222650527954</p><p>b =  0.5857117176055908</p><p>y_pred =  7.522602081298828</p><p><img src="/2021/01/PyTorch%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%AE%9E%E8%B7%B5Part5/image-20210117150905304.png" alt="image-20210117150905304"></p><h3 id="Rprop"><a href="#Rprop" class="headerlink" title="Rprop"></a>Rprop</h3><p>w =  1.9997763633728027</p><p>b =  0.0004527860146481544</p><p>y_pred =  7.999558448791504</p><p><img src="/2021/01/PyTorch%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%AE%9E%E8%B7%B5Part5/Rprop.png" alt="image-20210117150540886"></p><h3 id="SGD"><a href="#SGD" class="headerlink" title="SGD"></a>SGD</h3><p>w =  1.8483222723007202</p><p>b =  0.3447989821434021</p><p>y_pred =  7.738088130950928</p><p><img src="/2021/01/PyTorch%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%AE%9E%E8%B7%B5Part5/SGD.png" alt="image-20210117150219223"></p>]]></content>
      
      
      <categories>
          
          <category> PyTorch深度学习实践 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>PyTorch深度学习实践Part4</title>
      <link href="/2021/01/PyTorch%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%AE%9E%E8%B7%B5Part4/"/>
      <url>/2021/01/PyTorch%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%AE%9E%E8%B7%B5Part4/</url>
      
        <content type="html"><![CDATA[<h1 id="PyTorch深度学习实践Part4——反向传播"><a href="#PyTorch深度学习实践Part4——反向传播" class="headerlink" title="PyTorch深度学习实践Part4——反向传播"></a>PyTorch深度学习实践Part4——反向传播</h1><p>对于简单模型可以手动求解析式，但是对于复杂模型求解析式几乎不可能。</p><h2 id="计算图"><a href="#计算图" class="headerlink" title="计算图"></a>计算图</h2><p>每一层神经网络包括一次矩阵乘法(Matrix Multiplication)、一次向量加法、非线性变化函数(为了防止展开函数而导致深层神经网络无意义)</p><p><img src="/2021/01/PyTorch%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%AE%9E%E8%B7%B5Part4/image-20210116225529823.png" alt="image-20210116225529823"></p><h2 id="链式法则"><a href="#链式法则" class="headerlink" title="链式法则"></a>链式法则</h2><p>在pytorch中，梯度存在变量而不是计算模块里。</p><p><img src="/2021/01/PyTorch%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%AE%9E%E8%B7%B5Part4/image-20210116230629292.png" alt="image-20210116230629292"></p><p><img src="/2021/01/PyTorch%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%AE%9E%E8%B7%B5Part4/image-20210117091957454.png" alt="image-20210117091957454"></p><p>在计算过程中中，虽然有些变量可以不求导，但是一样要具备能够求导的能力。比如x的值就有可能是前一层网络的y_hat传递下来的。</p><p>核心在于梯度，loss虽然不会作为变量参与计算过程，但是同样需要保留，作为图像数据来判断最终是否收敛。</p><h2 id="PyTorch实现反向传播"><a href="#PyTorch实现反向传播" class="headerlink" title="PyTorch实现反向传播"></a>PyTorch实现反向传播</h2><p>线性模型y=w*x，用pytorch实现反向传播</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"></span><br><span class="line">x_data = [<span class="number">1.0</span>, <span class="number">2.0</span>, <span class="number">3.0</span>]</span><br><span class="line">y_data = [<span class="number">2.0</span>, <span class="number">4.0</span>, <span class="number">6.0</span>]</span><br><span class="line"></span><br><span class="line">w = torch.Tensor([<span class="number">1.0</span>])  <span class="comment"># data必须是一个序列</span></span><br><span class="line">w.requires_grad = <span class="literal">True</span>  <span class="comment"># 需要计算梯度</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">forward</span>(<span class="params">x</span>):</span></span><br><span class="line">    <span class="keyword">return</span> x * w  <span class="comment"># w是Tensor，运算符重载，x也会转成tensor</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">loss</span>(<span class="params">x, y</span>):</span></span><br><span class="line">    y_pred = forward(x)</span><br><span class="line">    <span class="keyword">return</span> (y_pred - y) ** <span class="number">2</span>  <span class="comment"># 看到代码一定要有意识想到如何构建计算图</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">print(<span class="string">&quot;predict (before training)&quot;</span>, <span class="number">4</span>, forward(<span class="number">4</span>).item())</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> epoch <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">100</span>):</span><br><span class="line">    <span class="keyword">for</span> x, y <span class="keyword">in</span> <span class="built_in">zip</span>(x_data, y_data):</span><br><span class="line">        l = loss(x, y)  <span class="comment"># 前馈过程，正式构建计算图，计算损失更新l</span></span><br><span class="line">        l.backward()  <span class="comment"># 反向传播，计算梯度，释放计算图</span></span><br><span class="line">        print(<span class="string">&#x27;\tgrad:&#x27;</span>, x, y, w.grad.item())</span><br><span class="line">        w.data = w.data - <span class="number">0.01</span> * w.grad.data  <span class="comment"># 更新权重w，注意grad也是一个tensor，不使用.data的话相当于在构建计算图</span></span><br><span class="line"></span><br><span class="line">        w.grad.data.zero_()  <span class="comment"># 将梯度w.grad.data清零</span></span><br><span class="line"></span><br><span class="line">    print(<span class="string">&#x27;progress:&#x27;</span>, epoch, l.item())  <span class="comment"># 取出loss使用l.item，不要直接使用l（l是tensor会构建计算图）</span></span><br><span class="line"></span><br><span class="line">print(<span class="string">&quot;predict (after training)&quot;</span>, <span class="number">4</span>, forward(<span class="number">4</span>).item())</span><br><span class="line"><span class="comment"># predict (after training) 4 7.999998569488525</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="课后作业"><a href="#课后作业" class="headerlink" title="课后作业"></a>课后作业</h2><p>二次模型y=w1<em>x²+w2</em>x+b的反向传播</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"></span><br><span class="line"><span class="comment"># y = x ** 2 + 2 * x + 1</span></span><br><span class="line">x_data = [<span class="number">1.0</span>, <span class="number">2.0</span>, <span class="number">3.0</span>]</span><br><span class="line">y_data = [<span class="number">4.0</span>, <span class="number">9.0</span>, <span class="number">16.0</span>]</span><br><span class="line"></span><br><span class="line">w1 = torch.Tensor([<span class="number">1.0</span>])</span><br><span class="line">w2 = torch.Tensor([<span class="number">1.0</span>])</span><br><span class="line">b = torch.Tensor([<span class="number">1.0</span>])</span><br><span class="line">w1.requires_grad, w2.requires_grad, b.requires_grad = <span class="literal">True</span>, <span class="literal">True</span>, <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">forward</span>(<span class="params">x</span>):</span></span><br><span class="line">    <span class="keyword">return</span> w1 * x * x + w2 * x + b</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">loss</span>(<span class="params">x, y</span>):</span></span><br><span class="line">    y_pred = forward(x)</span><br><span class="line">    <span class="keyword">return</span> (y_pred - y) ** <span class="number">2</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">print(<span class="string">&quot;predict (before training)&quot;</span>, <span class="number">4</span>, forward(<span class="number">4</span>).item())</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> epoch <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">100</span>):</span><br><span class="line">    <span class="keyword">for</span> x, y <span class="keyword">in</span> <span class="built_in">zip</span>(x_data, y_data):</span><br><span class="line">        l = loss(x, y)  <span class="comment"># 前馈过程，正式构建计算图，计算损失更新l</span></span><br><span class="line">        l.backward()  <span class="comment"># 反向传播，计算梯度，释放计算图</span></span><br><span class="line">        print(<span class="string">&#x27;\tgrad:&#x27;</span>, x, y, w1.grad.item(), w2.grad.item(), b.grad.item())</span><br><span class="line">        w1.data = w1.data - <span class="number">0.01</span> * w1.grad.data</span><br><span class="line">        w2.data = w2.data - <span class="number">0.01</span> * w2.grad.data</span><br><span class="line">        b.data = b.data - <span class="number">0.01</span> * b.grad.data</span><br><span class="line">        w1.grad.data.zero_()</span><br><span class="line">        w2.grad.data.zero_()</span><br><span class="line">        b.grad.data.zero_()</span><br><span class="line">    print(<span class="string">&#x27;progress:&#x27;</span>, epoch, l.item())  <span class="comment"># 取出loss使用l.item，不要直接使用l（l是tensor会构建计算图）</span></span><br><span class="line"></span><br><span class="line">print(<span class="string">&quot;predict (after training)&quot;</span>, <span class="number">4</span>, forward(<span class="number">4</span>).item())</span><br><span class="line">print(w1.data, w2.data, b.data)</span><br><span class="line"><span class="comment"># predict (after training) 4 25.259323120117188</span></span><br><span class="line"><span class="comment"># tensor([1.1145]) tensor([1.4928]) tensor([1.4557])</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>改了一下原本的数据集，更符合二次函数，但是因为样本量过少，预测的权重并不是很好。</p>]]></content>
      
      
      <categories>
          
          <category> PyTorch深度学习实践 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>PyTorch深度学习实践Part3</title>
      <link href="/2021/01/PyTorch%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%AE%9E%E8%B7%B5Part3/"/>
      <url>/2021/01/PyTorch%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%AE%9E%E8%B7%B5Part3/</url>
      
        <content type="html"><![CDATA[<h1 id="PyTorch深度学习实践Part3——梯度下降算法"><a href="#PyTorch深度学习实践Part3——梯度下降算法" class="headerlink" title="PyTorch深度学习实践Part3——梯度下降算法"></a>PyTorch深度学习实践Part3——梯度下降算法</h1><h2 id="优化问题"><a href="#优化问题" class="headerlink" title="优化问题"></a>优化问题</h2><ol><li><p>上讲是穷举所有可能值并肉眼搜索损失最低点。</p></li><li><p>分治法可能错失关键，最终只找到局部最优</p><blockquote><p>穷举和分治都不能有效解决大数据</p></blockquote></li><li><p>梯度(gradient)决定权重w往哪个方向走，梯度即成本对权重求导，为了控制步伐需要设定一个较小的学习率。</p><p><img src="/2021/01/PyTorch%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%AE%9E%E8%B7%B5Part3/image-20210116203946162.png" alt="image-20210116203946162"></p></li><li><p>在大量的实验中发现，其实很多情况下，我们很难陷入到局部最优点。但是存在另外一个问题，鞍点。鞍点会导致无法继续迭代，可以选择通过引入动量解决。</p></li></ol><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">x_data = [<span class="number">1.0</span>, <span class="number">2.0</span>, <span class="number">3.0</span>]</span><br><span class="line">y_data = [<span class="number">2.0</span>, <span class="number">4.0</span>, <span class="number">6.0</span>]</span><br><span class="line">w = <span class="number">1.0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">forward</span>(<span class="params">x</span>):</span></span><br><span class="line">    <span class="keyword">return</span> x * w</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">cost</span>(<span class="params">xs, ys</span>):</span></span><br><span class="line">    cost = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> x, y <span class="keyword">in</span> <span class="built_in">zip</span>(xs, ys):  <span class="comment"># 3行数据</span></span><br><span class="line">        y_pred = forward(x)</span><br><span class="line">        cost += (y_pred - y) ** <span class="number">2</span>  <span class="comment"># 累加损失平方</span></span><br><span class="line">    <span class="keyword">return</span> cost / <span class="built_in">len</span>(xs)  <span class="comment"># 平均</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">gradient</span>(<span class="params">xs, ys</span>):</span></span><br><span class="line">    grad = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> x, y <span class="keyword">in</span> <span class="built_in">zip</span>(xs, ys):</span><br><span class="line">        grad += <span class="number">2</span> * x * (x * w - y)  <span class="comment"># 成本对权重求导</span></span><br><span class="line">    <span class="keyword">return</span> grad / <span class="built_in">len</span>(xs)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">print(<span class="string">&#x27;Predict(before training)&#x27;</span>, <span class="number">4</span>, forward(<span class="number">4</span>))</span><br><span class="line">mse_list = []  <span class="comment"># 保存损失的变化曲线</span></span><br><span class="line"><span class="keyword">for</span> epoch <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">100</span>):</span><br><span class="line">    cost_val = cost(x_data, y_data)  <span class="comment"># 计算损失</span></span><br><span class="line">    mse_list.append(cost_val)  <span class="comment"># 记录损失变化</span></span><br><span class="line">    grad_val = gradient(x_data, y_data)  <span class="comment"># 计算梯度</span></span><br><span class="line">    w -= <span class="number">0.01</span> * grad_val  <span class="comment"># 改善权重</span></span><br><span class="line">    print(<span class="string">&#x27;Epoch:&#x27;</span>, epoch, <span class="string">&#x27;w=&#x27;</span>, w, <span class="string">&#x27;loss=&#x27;</span>, cost_val)</span><br><span class="line">print(<span class="string">&#x27;Predict(after training)&#x27;</span>, <span class="number">4</span>, forward(<span class="number">4</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 图表打印</span></span><br><span class="line">plt.plot(<span class="built_in">range</span>(<span class="number">100</span>), mse_list)</span><br><span class="line">plt.ylabel(<span class="string">&#x27;Loss&#x27;</span>)</span><br><span class="line">plt.xlabel(<span class="string">&#x27;Epoch&#x27;</span>)</span><br><span class="line">plt.show()</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="/2021/01/PyTorch%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%AE%9E%E8%B7%B5Part3/image-20210116215632394.png" alt="image-20210116215632394"></p><ol><li>绘图时想要消除局部震荡，可以使用指数加权均值方法，使其变成更加平滑的曲线</li><li>如果训练的图像发散，则表明这次训练失败了。其原因有很多，比如，学习率取太大。</li></ol><h2 id="随机梯度下降"><a href="#随机梯度下降" class="headerlink" title="随机梯度下降"></a>随机梯度下降</h2><p>使用梯度下降方法时，更加常用随机梯度下降(Stochastic Gradient Descent)。</p><p>随机梯度下降也是跨越鞍点的一种方法，同时也可以大幅减少计算量。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line">x_data = [<span class="number">1.0</span>, <span class="number">2.0</span>, <span class="number">3.0</span>]</span><br><span class="line">y_data = [<span class="number">2.0</span>, <span class="number">4.0</span>, <span class="number">6.0</span>]</span><br><span class="line">w = <span class="number">1.0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">forward</span>(<span class="params">x</span>):</span></span><br><span class="line">    <span class="keyword">return</span> x * w</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">loss</span>(<span class="params">x, y</span>):</span></span><br><span class="line">    y_pred = forward(x)</span><br><span class="line">    <span class="keyword">return</span> (y_pred - y) ** <span class="number">2</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">gradient</span>(<span class="params">x, y</span>):</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span> * x * (x * w - y)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">print(<span class="string">&#x27;Predict(before training)&#x27;</span>, <span class="number">4</span>, forward(<span class="number">4</span>))</span><br><span class="line">mse_list = []  <span class="comment"># 保存损失的变化曲线</span></span><br><span class="line"><span class="keyword">for</span> epoch <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">100</span>):</span><br><span class="line">    x, y, i = <span class="number">0</span>, <span class="number">0</span>, random.randint(<span class="number">0</span>, <span class="number">2</span>)</span><br><span class="line">    <span class="comment"># 样本原本就是随机的，所以不需要打乱样本</span></span><br><span class="line">    <span class="keyword">for</span> m, n, j <span class="keyword">in</span> <span class="built_in">zip</span>(x_data, y_data, <span class="built_in">range</span>(<span class="number">0</span>, <span class="number">2</span>, <span class="number">1</span>)):</span><br><span class="line">        <span class="keyword">if</span> j == i:</span><br><span class="line">            x, y = m, n  <span class="comment"># 3组中随机选取一组</span></span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    grad = gradient(x, y)  <span class="comment"># 计算梯度</span></span><br><span class="line">    w -= <span class="number">0.01</span> * grad  <span class="comment"># 改善权重</span></span><br><span class="line">    cost_val = loss(x, y)  <span class="comment"># 计算损失</span></span><br><span class="line">    mse_list.append(cost_val)  <span class="comment"># 记录损失变化</span></span><br><span class="line">    print(<span class="string">&#x27;Epoch:&#x27;</span>, epoch, <span class="string">&#x27;w=&#x27;</span>, w, <span class="string">&#x27;loss=&#x27;</span>, cost_val)</span><br><span class="line">print(<span class="string">&#x27;Predict(after training)&#x27;</span>, <span class="number">4</span>, forward(<span class="number">4</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 图表打印</span></span><br><span class="line">plt.plot(<span class="built_in">range</span>(<span class="number">100</span>), mse_list)</span><br><span class="line">plt.ylabel(<span class="string">&#x27;Loss&#x27;</span>)</span><br><span class="line">plt.xlabel(<span class="string">&#x27;Epoch&#x27;</span>)</span><br><span class="line">plt.show()</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="/2021/01/PyTorch%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%AE%9E%E8%B7%B5Part3/image-20210116222847776.png" alt="image-20210116222847776"></p><p>随机梯度下降可能享受不到并行计算的效率加成，因此会使用折中方法，批量随机梯度下降(Mini-Batch/Batch)</p>]]></content>
      
      
      <categories>
          
          <category> PyTorch深度学习实践 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>PyTorch深度学习实践Part2</title>
      <link href="/2021/01/PyTorch%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%AE%9E%E8%B7%B5Part2/"/>
      <url>/2021/01/PyTorch%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%AE%9E%E8%B7%B5Part2/</url>
      
        <content type="html"><![CDATA[<h1 id="PyTorch深度学习实践Part2——线性模型"><a href="#PyTorch深度学习实践Part2——线性模型" class="headerlink" title="PyTorch深度学习实践Part2——线性模型"></a>PyTorch深度学习实践Part2——线性模型</h1><h2 id="一般过程"><a href="#一般过程" class="headerlink" title="一般过程"></a>一般过程</h2><ol><li>Data Set </li><li>Model（神经网络、决策树、朴素贝叶斯）</li><li>Trainning</li><li>Infering</li></ol><h2 id="训练-amp-测试"><a href="#训练-amp-测试" class="headerlink" title="训练&amp;测试"></a>训练&amp;测试</h2><h3 id="训练集拆分"><a href="#训练集拆分" class="headerlink" title="训练集拆分"></a>训练集拆分</h3><p>在竞赛中，训练集是可见的，测试集一般是不可见的。为了提高或验证模型的准确度，一般会把手中的训练集拆分，以及交叉验证。</p><h3 id="过拟合"><a href="#过拟合" class="headerlink" title="过拟合"></a>过拟合</h3><p>当模型对训练集的噪声也学习进去的时候，对训练集以外的数据可能会出现准确率下降的情况。因此一个好的模型需要有良好的泛化能力。</p><h2 id="损失函数"><a href="#损失函数" class="headerlink" title="损失函数"></a>损失函数</h2><p><img src="/2021/01/PyTorch%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%AE%9E%E8%B7%B5Part2/image-20210116101533492.png" alt="image-20210116101533492"></p><p>平均平方误差（MSE MeanSquareError）</p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">x_data = [<span class="number">1.0</span>, <span class="number">2.0</span>, <span class="number">3.0</span>]</span><br><span class="line">y_data = [<span class="number">2.0</span>, <span class="number">4.0</span>, <span class="number">6.0</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 前馈</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">forward</span>(<span class="params">x</span>):</span></span><br><span class="line">    <span class="keyword">return</span> x * w</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 损失</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">loss</span>(<span class="params">x, y</span>):</span></span><br><span class="line">    y_pred = forward(x)</span><br><span class="line">    <span class="keyword">return</span> (y_pred - y) * (y_pred - y)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 存放结果，所有权重和对应的均方差</span></span><br><span class="line">w_list = []</span><br><span class="line">mse_list = []</span><br><span class="line"><span class="comment"># 穷举所有权重0.0-4.1步长0.1</span></span><br><span class="line"><span class="keyword">for</span> w <span class="keyword">in</span> np.arange(<span class="number">0.0</span>, <span class="number">4.1</span>, <span class="number">0.1</span>):</span><br><span class="line">    print(<span class="string">&#x27;w=&#x27;</span>, w)</span><br><span class="line">    l_sum = <span class="number">0</span>  <span class="comment"># 损失的和</span></span><br><span class="line">    <span class="keyword">for</span> x_val, y_val <span class="keyword">in</span> <span class="built_in">zip</span>(x_data, y_data):  <span class="comment"># 打包，一共三行</span></span><br><span class="line">        y_pred_val = forward(x_val)  <span class="comment"># 前馈算出此权重和样本得出的预测值，其实已经包含在loss()中，只是为了打印</span></span><br><span class="line">        loss_val = loss(x_val, y_val)  <span class="comment"># 计算该权重预测值得损失</span></span><br><span class="line">        l_sum += loss_val  <span class="comment"># 求损失和</span></span><br><span class="line">        print(<span class="string">&#x27;\t&#x27;</span>, x_val, y_val, y_pred_val, loss_val)  <span class="comment"># 当前的x、y值、预测值、损失</span></span><br><span class="line">    print(<span class="string">&#x27;MSE=&#x27;</span>, l_sum / <span class="number">3</span>)  <span class="comment"># 求损失的平均</span></span><br><span class="line">    <span class="comment"># 保存记录</span></span><br><span class="line">    w_list.append(w)</span><br><span class="line">    mse_list.append(l_sum / <span class="number">3</span>)</span><br><span class="line"><span class="comment"># 图表打印</span></span><br><span class="line">plt.plot(w_list, mse_list)</span><br><span class="line">plt.ylabel(<span class="string">&#x27;Loss&#x27;</span>)</span><br><span class="line">plt.xlabel(<span class="string">&#x27;w&#x27;</span>)</span><br><span class="line">plt.show()</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="/2021/01/PyTorch%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%AE%9E%E8%B7%B5Part2/image-20210116155722125.png" alt="image-20210116155722125"></p><blockquote><p>做深度学习要定期存盘，防止意外导致数据丢失</p></blockquote><h2 id="课后作业"><a href="#课后作业" class="headerlink" title="课后作业"></a>课后作业</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 这里设函数为y=3x+2</span></span><br><span class="line">x_data = [<span class="number">1.0</span>, <span class="number">2.0</span>, <span class="number">3.0</span>]</span><br><span class="line">y_data = [<span class="number">5.0</span>, <span class="number">8.0</span>, <span class="number">11.0</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">forward</span>(<span class="params">x</span>):</span></span><br><span class="line">    <span class="keyword">return</span> x * w + b</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">loss</span>(<span class="params">x, y</span>):</span></span><br><span class="line">    y_pred = forward(x)</span><br><span class="line">    <span class="keyword">return</span> (y_pred - y) * (y_pred - y)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 1.arange()左闭右开；2.打印 0.0、1.0 时只会显示 0.、1.；3.meshgrid()之后w、b都是41*41矩阵</span></span><br><span class="line"><span class="comment"># 4.这里前馈中是矩阵点对点的运算，但注意并不是矩阵运算，好处是省去了n层for循环，举例：</span></span><br><span class="line"><span class="comment"># a=[[1 2 3][1 2 3]]</span></span><br><span class="line"><span class="comment"># b=[[7 7 7][8 8 8]]</span></span><br><span class="line"><span class="comment"># a*b=[[ 7 14 21][ 8 16 24]]</span></span><br><span class="line">w_list = np.arange(<span class="number">0.0</span>, <span class="number">4.1</span>, <span class="number">0.1</span>)</span><br><span class="line">b_list = np.arange(<span class="number">0.0</span>, <span class="number">4.1</span>, <span class="number">0.1</span>)</span><br><span class="line">w, b = np.meshgrid(w_list, b_list)</span><br><span class="line"></span><br><span class="line">l_sum = <span class="number">0</span>  <span class="comment"># 损失的和</span></span><br><span class="line"><span class="keyword">for</span> x_val, y_val <span class="keyword">in</span> <span class="built_in">zip</span>(x_data, y_data):  <span class="comment"># 遍历三次</span></span><br><span class="line">    <span class="comment"># y_pred_val、loss_val都是41*41的矩阵，即41个w和41个b组合的预测结果和损失</span></span><br><span class="line">    y_pred_val = forward(x_val)</span><br><span class="line">    loss_val = loss(x_val, y_val)</span><br><span class="line">    l_sum += loss_val</span><br><span class="line">    print(<span class="string">&#x27;\nx_val：&#x27;</span>, x_val,<span class="string">&#x27;\ny_val：&#x27;</span>, y_val, <span class="string">&#x27;\ny_pred_val：&#x27;</span>,y_pred_val, <span class="string">&#x27;\nloss_val：&#x27;</span>,loss_val)  <span class="comment"># 当前的x、y值、预测值、损失</span></span><br><span class="line">mse_list = l_sum / <span class="number">3</span></span><br><span class="line"><span class="comment"># mse_list也是一个ndarray类型的41*41矩阵</span></span><br><span class="line">print(<span class="string">&#x27;MSE=&#x27;</span>, mse_list)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3d图表</span></span><br><span class="line">fig = plt.figure()</span><br><span class="line">ax = fig.add_subplot(<span class="number">111</span>, projection=<span class="string">&#x27;3d&#x27;</span>)</span><br><span class="line">ax.plot_surface(w, b, mse_list)</span><br><span class="line">plt.show()</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 这里设函数为y=3x+2</span></span><br><span class="line">x_data = [<span class="number">1.0</span>, <span class="number">2.0</span>, <span class="number">3.0</span>]</span><br><span class="line">y_data = [<span class="number">5.0</span>, <span class="number">8.0</span>, <span class="number">11.0</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">forward</span>(<span class="params">x</span>):</span></span><br><span class="line">    <span class="keyword">return</span> x * w + b</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">loss</span>(<span class="params">x, y</span>):</span></span><br><span class="line">    y_pred = forward(x)</span><br><span class="line">    <span class="keyword">return</span> (y_pred - y) * (y_pred - y)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 这里都是矩阵的运算</span></span><br><span class="line"><span class="comment"># 1.arange()左闭右开；2.打印 0.0、1.0 时只会显示 0.、1.；3.meshgrid之后w、b都是41*41矩阵</span></span><br><span class="line">w_list = np.arange(<span class="number">0.0</span>, <span class="number">4.1</span>, <span class="number">0.1</span>)</span><br><span class="line">b_list = np.arange(<span class="number">0.0</span>, <span class="number">4.1</span>, <span class="number">0.1</span>)</span><br><span class="line">w, b = np.meshgrid(w_list, b_list)</span><br><span class="line"></span><br><span class="line">l_sum = <span class="number">0</span>  <span class="comment"># 损失的和</span></span><br><span class="line"><span class="keyword">for</span> x_val, y_val <span class="keyword">in</span> <span class="built_in">zip</span>(x_data, y_data):  <span class="comment"># 遍历三次</span></span><br><span class="line">    y_pred_val = forward(x_val)</span><br><span class="line">    loss_val = loss(x_val, y_val)</span><br><span class="line">    l_sum += loss_val</span><br><span class="line">    print(<span class="string">&#x27;\nx_val：&#x27;</span>, x_val,<span class="string">&#x27;\ny_val：&#x27;</span>, y_val, <span class="string">&#x27;\ny_pred_val：&#x27;</span>,y_pred_val, <span class="string">&#x27;\nloss_val：&#x27;</span>,loss_val)  <span class="comment"># 当前的x、y值、预测值、损失</span></span><br><span class="line">mse_list = l_sum / <span class="number">3</span></span><br><span class="line"><span class="comment"># mse_list也是一个ndarray类型的41*41矩阵</span></span><br><span class="line">print(<span class="string">&#x27;MSE=&#x27;</span>, mse_list)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3d图表</span></span><br><span class="line">fig = plt.figure()</span><br><span class="line">ax = fig.add_subplot(<span class="number">111</span>, projection=<span class="string">&#x27;3d&#x27;</span>)</span><br><span class="line">ax.plot_surface(w, b, mse_list)</span><br><span class="line">plt.show()</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="/2021/01/PyTorch%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%AE%9E%E8%B7%B5Part2/image-20210116155626917.png" alt="image-20210116155626917"></p>]]></content>
      
      
      <categories>
          
          <category> PyTorch深度学习实践 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>PyTorch深度学习实践Part1</title>
      <link href="/2021/01/PyTorch%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%AE%9E%E8%B7%B5Part1/"/>
      <url>/2021/01/PyTorch%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%AE%9E%E8%B7%B5Part1/</url>
      
        <content type="html"><![CDATA[<h1 id="PyTorch深度学习实践Part1——概论"><a href="#PyTorch深度学习实践Part1——概论" class="headerlink" title="PyTorch深度学习实践Part1——概论"></a>PyTorch深度学习实践Part1——概论</h1><h2 id="技术成熟度曲线"><a href="#技术成熟度曲线" class="headerlink" title="技术成熟度曲线"></a>技术成熟度曲线</h2><p><img src="/2021/01/PyTorch%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%AE%9E%E8%B7%B5Part1/3b87e950352ac65ca9eb5abaa5e3f21692138a21.jpeg" alt="技术成熟度曲线"></p><p><strong>科技诞生的促动期</strong> (Technology Trigger)：在此阶段，随着媒体大肆的报道过度，非理性的渲染，产品的知名度无所不在，然而随着这个科技的缺点、问题、限制出现，失败的案例大于成功的案例，例如:.com公司 1998~2000年之间的非理性疯狂飙升期。</p><p><strong>过高期望的峰值</strong>（Peak of Inflated Expectations）：早期公众的过分关注演绎出了一系列成功的故事——当然同时也有众多失败的例子。对于失败，有些公司采取了补救措施，而大部分却无动于衷。</p><p><strong>泡沫化的底谷期</strong> (Trough of Disillusionment)：在历经前面阶段所存活的科技经过多方扎实有重点的试验，而对此科技的适用范围及限制是以客观的并实际的了解，成功并能存活的经营模式逐渐成长。</p><p><strong>稳步爬升的光明期</strong> (Slope of Enlightenment)：在此阶段，有一新科技的诞生，在市面上受到主要媒体与业界高度的注意，例如:1996年的Internet ，Web。</p><p><strong>实质生产的高峰期</strong> (Plateau of Productivity)：在此阶段，新科技产生的利益与潜力被市场实际接受，实质支援此经营模式的工具、方法论经过数代的演进，进入了非常成熟的阶段。</p><blockquote><p>在使用pytorch或一系列新技术的时候，一定要学会看官方文档，这是一个非常重要的能力！</p></blockquote><h2 id="人工智能"><a href="#人工智能" class="headerlink" title="人工智能"></a>人工智能</h2><p><img src="/2021/01/PyTorch%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%AE%9E%E8%B7%B5Part1/image-20210115233930514.png" alt="AI技术"></p><p>AI除了machine learning之外还有机器视觉、自然语言处理nlp、因果推断等。</p><p>机器学习大部分都是监督学习，即用一组标签过的值进行模型训练。</p><p>机器学习中的算法区别于普通的算法（穷举、贪心等），是通过数据训练并验证得出一个好用的模型，其计算过程来自于数据而不是人工的设计。</p><p>深度学习从模型上看用的是神经网络，从目标上看属于表示学习的分支。方法有，多层感知机、卷积神经网络、循环神经网络等。</p><h2 id="维度诅咒"><a href="#维度诅咒" class="headerlink" title="维度诅咒"></a>维度诅咒</h2><p>随着feature上升，为了保持准确性，其所需的数据量将急速上升，然而获取打过标签的数据，工作量大、成本高。</p><p>n<em>1的向量采样点需要一个3</em>n的矩阵来映射到3*1的向量，实现降维（PCA主成成分分析）。但是降维的同时也要尽量保证高维空间的度量信息，这个过程叫做表示学习（Present）。这个数据分布是在高维空间里的低维流行（Manifold）。</p><h2 id="发展历史"><a href="#发展历史" class="headerlink" title="发展历史"></a>发展历史</h2><p><img src="/2021/01/PyTorch%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%AE%9E%E8%B7%B5Part1/image-20210116083615697.png" alt="image-20210116083615697"></p><h2 id="传统机器学习分类"><a href="#传统机器学习分类" class="headerlink" title="传统机器学习分类"></a>传统机器学习分类</h2><p><img src="/2021/01/PyTorch%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%AE%9E%E8%B7%B5Part1/image-20210116083809610.png" alt="image-20210116083809610"></p><h2 id="神经网络发展"><a href="#神经网络发展" class="headerlink" title="神经网络发展"></a>神经网络发展</h2><p>由生物实验得出，哺乳动物的视觉神经是分层的。浅层只检测物体的运动等，深层才开始识别物体的分类。由此出现了感知机。</p><p>现在神经网络早已不是生物的范畴，而是工程与数学方面。</p><p>真正让神经网络发展起来的是反向传播（Back Propagation），其核心在于计算图。</p><p><img src="/2021/01/PyTorch%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%AE%9E%E8%B7%B5Part1/image-20210116090403146.png" alt="image-20210116090403146"></p>]]></content>
      
      
      <categories>
          
          <category> PyTorch深度学习实践 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>个人博客建站教程-完结目录</title>
      <link href="/2021/01/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E5%BB%BA%E7%AB%99%E6%95%99%E7%A8%8B-%E5%AE%8C%E7%BB%93%E7%9B%AE%E5%BD%95/"/>
      <url>/2021/01/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E5%BB%BA%E7%AB%99%E6%95%99%E7%A8%8B-%E5%AE%8C%E7%BB%93%E7%9B%AE%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<h1 id="个人博客建站教程-完结目录"><a href="#个人博客建站教程-完结目录" class="headerlink" title="个人博客建站教程-完结目录"></a>个人博客建站教程-完结目录</h1><h2 id="个人博客网站教程"><a href="#个人博客网站教程" class="headerlink" title="个人博客网站教程"></a>个人博客网站教程</h2><p>其实不是一件很难的事，花个一点时间，祝每个人都能做出自己风格的博客小家。</p><p>之后的博客维护以发文章为主，一键三连~ <code>hexo clean &amp; hexo g &amp; hexo d</code></p><table><thead><tr><th align="center"><a href="2021/01/Hexo%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E5%92%8C%E9%83%A8%E7%BD%B2/">Part1——博客搭建与部署</a></th></tr></thead><tbody><tr><td align="center"><a href="2021/01/Butterfly%E4%B8%BB%E9%A2%98%E5%AE%89%E8%A3%85%E5%92%8C%E9%AD%94%E6%94%B9/"><strong>Part2——主题安装与魔改</strong></a></td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> Hexo博客搭建 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Butterfly主题安装和魔改</title>
      <link href="/2021/01/Butterfly%E4%B8%BB%E9%A2%98%E5%AE%89%E8%A3%85%E5%92%8C%E9%AD%94%E6%94%B9/"/>
      <url>/2021/01/Butterfly%E4%B8%BB%E9%A2%98%E5%AE%89%E8%A3%85%E5%92%8C%E9%AD%94%E6%94%B9/</url>
      
        <content type="html"><![CDATA[<h1 id="安装butterfly"><a href="#安装butterfly" class="headerlink" title="安装butterfly"></a>安装butterfly</h1><ol><li>运行<code>git clone https://github.com/jerryc127/hexo-theme-butterfly themes/butterfly</code></li><li>打开_config.yml找到这一行<code>theme: landspace</code>然后将landspace替换butterfly</li><li>安装插件<code>cnpm install hexo-renderer-pug hexo-renderer-stylus</code></li><li>安装插件<code>cnpm install --save hexo-renderer-jade hexo-generator-feed hexo-generator-sitemap hexo-browsersync hexo-generator-archive</code></li></ol><blockquote><p>为了以后升级方便，这里不推荐直接对主题的配置文件进行修改，而是复制配置文件进行修改。个人推荐把主題的配置文件_config.yml复制到 Hexo 工作目录下的source/_data/butterfly.yml，如果目录不存在那就创建一个。</p></blockquote><h1 id="butterfly主题魔改"><a href="#butterfly主题魔改" class="headerlink" title="butterfly主题魔改"></a>butterfly主题魔改</h1><p>自己一开始动手做的时候大部分都参考Dreamy.TZK的博客</p><p><a href="https://www.antmoe.com/posts/75a6347a/index.html">Hexo安装并使用Butterfly主题</a></p><p>但是改到后来就越来越觉得，版本问题导致的主题修改不兼容，问题实在很大。甚至到后来想要获得自己的预期效果时，已经不得不去在源代码上下手<del>，因为还没有学过前端，改的属实面目全非</del>。</p><h2 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h2><p>这里只能为想要自己动手改的小伙伴一些建议，比如想修改文章页，可以结合浏览器的开发者工具来找到相应的参数，来修改对应的值。</p><p><img src="/2021/01/Butterfly%E4%B8%BB%E9%A2%98%E5%AE%89%E8%A3%85%E5%92%8C%E9%AD%94%E6%94%B9/Untitled.png" alt="Butterfly主题安装和魔改/Untitled.png"></p><p><img src="/2021/01/Butterfly%E4%B8%BB%E9%A2%98%E5%AE%89%E8%A3%85%E5%92%8C%E9%AD%94%E6%94%B9/Untitled%201.png" alt="Butterfly主题安装和魔改/Untitled%201.png"></p><h2 id="相册的使用"><a href="#相册的使用" class="headerlink" title="相册的使用"></a>相册的使用</h2><p><a href="https://blog.ahzoo.cn/2020/07/20/b7201/">https://blog.ahzoo.cn/2020/07/20/b7201/</a></p><h2 id="关于文章中插入图片"><a href="#关于文章中插入图片" class="headerlink" title="关于文章中插入图片"></a>关于文章中插入图片</h2><p>先把hexo的配置文件中的 relative_link 参数确保为false。否则会导致butterfly各分页面的链接错乱</p><p><img src="/2021/01/Butterfly%E4%B8%BB%E9%A2%98%E5%AE%89%E8%A3%85%E5%92%8C%E9%AD%94%E6%94%B9/image-20201231210020980.png" alt="image-20201231210020980"></p><p>把每个文章开头部分加一个参数 relative_link: true。使每个文章部分遵从相对位置的引用，这样可以将文章的图片，不仅在typora或是在服务器上，都能够实时看到自己文章图片引用的效果。</p><p><img src="/2021/01/Butterfly%E4%B8%BB%E9%A2%98%E5%AE%89%E8%A3%85%E5%92%8C%E9%AD%94%E6%94%B9/image-20201231205840731.png" alt="image-20201231205840731"></p><p><img src="/2021/01/Butterfly%E4%B8%BB%E9%A2%98%E5%AE%89%E8%A3%85%E5%92%8C%E9%AD%94%E6%94%B9/image-20201231210339382.png" alt="image-20201231210339382"></p><h2 id="关于分类管理-post下的文章"><a href="#关于分类管理-post下的文章" class="headerlink" title="关于分类管理_post下的文章"></a>关于分类管理_post下的文章</h2><p>主要参考<a href="https://blog.csdn.net/maosidiaoxian/article/details/85220394">如何在Hexo中对文章md文件分类</a></p><p>现在文章中的permalink:参数会完全覆盖_config.yml中的设置，要注意。</p><h1 id="后面应该还会慢慢更新一些有用的东西"><a href="#后面应该还会慢慢更新一些有用的东西" class="headerlink" title="后面应该还会慢慢更新一些有用的东西~"></a>后面应该还会慢慢更新一些有用的东西~</h1>]]></content>
      
      
      <categories>
          
          <category> Hexo博客搭建 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Hexo静态博客搭建和部署</title>
      <link href="/2021/01/Hexo%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E5%92%8C%E9%83%A8%E7%BD%B2/"/>
      <url>/2021/01/Hexo%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E5%92%8C%E9%83%A8%E7%BD%B2/</url>
      
        <content type="html"><![CDATA[<h1 id="软件安装"><a href="#软件安装" class="headerlink" title="软件安装"></a>软件安装</h1><h2 id="Nodejs"><a href="#Nodejs" class="headerlink" title="Nodejs"></a>Nodejs</h2><p><a href="https://nodejs.org/en/">Node.js</a></p><ul><li><code>node -v</code>确认nodejs版本，安装成功</li></ul><h2 id="Git-Bash"><a href="#Git-Bash" class="headerlink" title="Git Bash"></a>Git Bash</h2><p><a href="https://www.git-scm.com/download/win">Downloading Git</a></p><ul><li><code>git --version</code>确认nodejs版本，安装成功</li></ul><blockquote><p>nodejs和git自己选好安装位置之后无脑下一步就行。以下都以我个人的安装目录（D:\ProgrammingKits\nodejs 和 D:\ProgrammingKits\Git）为前提，请大家各自修改为自己的路径。</p></blockquote><h1 id="Nodejs插件安装"><a href="#Nodejs插件安装" class="headerlink" title="Nodejs插件安装"></a>Nodejs插件安装</h1><ul><li><p>最新的Nodejs自带npm，但是默认安装和缓存地址不在Nodejs根目录下</p><p>  npm的默认全局模块的安装地址是 C:\Users\Administrator\AppData\Roaming\npm</p><p>  npm的默认缓存的地址是 C:\Users\Administrator\AppData\Roaming\npm_cache</p></li></ul><p>首先修改nodejs的prefix（全局）和cache（缓存）文件夹地址</p><ul><li>运行<code>npm config set cache &quot;D:\ProgrammingKits\nodejs\node_cache&quot;</code>设置缓存文件夹</li><li>运行<code>npm config set prefix &quot;D:\ProgrammingKits\nodejs\nodejs&quot;</code>设置全局模块存放路径。</li></ul><p><del>这种方法可以不用像<code>npm config set prefix &quot;D:\ProgrammingKits\nodejs\node_global&quot;</code>需要修改环境变量。</del></p><p>以后npm和cnpm安装的全局模块都会被放到 D:\ProgrammingKits\nodejs\node_modules 下，跟自带的npm模块本体在一个文件夹中。</p><h2 id="cnpm"><a href="#cnpm" class="headerlink" title="cnpm"></a>cnpm</h2><p>这里安装淘宝的cnpm包管理器，以提高下载速度。</p><ul><li>运行<code>npm install -g cnpm --registry=http://registry.npm.taobao.org</code></li><li><code>cnpm -v</code> 确认cnpm版本，安装成功</li></ul><h2 id="hexo"><a href="#hexo" class="headerlink" title="hexo"></a>hexo</h2><p>静态博客框架</p><ul><li>运行<code>cnpm install -g hexo-cli</code> 安装hexo框架</li><li><code>hexo -v</code>确认hexo版本，安装成功</li></ul><h1 id="Hexo框架的使用"><a href="#Hexo框架的使用" class="headerlink" title="Hexo框架的使用"></a>Hexo框架的使用</h1><ul><li>hexo常用命令<ul><li><code>hexo init</code>初始化博客</li><li><code>hexo clean</code>清理缓存文件</li><li><code>hexo g</code>生成文件</li><li><code>hexo s</code>运行本地服务器</li><li><code>hexo d</code>部署到服务器</li><li><code>hexo n &quot;MyBlog&quot;</code>创建新的文章</li></ul></li></ul><p>现在我们只需要在 D:\MyBlog\HexoBlog 下运行<code>hexo init &amp; hexo s</code>，在浏览器中输入 <a href="http://localhost:4000/">localhost:4000</a> 即为最初始的博客内容。</p><h1 id="部署博客"><a href="#部署博客" class="headerlink" title="部署博客"></a>部署博客</h1><h2 id="创建仓库"><a href="#创建仓库" class="headerlink" title="创建仓库"></a>创建仓库</h2><p>用来存放你的代码/网站供别人访问</p><p><img src="/2021/01/Hexo%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E5%92%8C%E9%83%A8%E7%BD%B2/Untitled.png" alt="Hexo静态博客搭建和部署/Untitled.png"></p><p><img src="/2021/01/Hexo%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E5%92%8C%E9%83%A8%E7%BD%B2/Untitled%201.png" alt="Hexo静态博客搭建和部署/Untitled%201.png"></p><h2 id="创建部署分支"><a href="#创建部署分支" class="headerlink" title="创建部署分支"></a>创建部署分支</h2><p>master用来放代码，ph-pages用来部署网站</p><p><img src="/2021/01/Hexo%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E5%92%8C%E9%83%A8%E7%BD%B2/Untitled%202.png" alt="Hexo静态博客搭建和部署/Untitled%202.png"></p><p><img src="/2021/01/Hexo%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E5%92%8C%E9%83%A8%E7%BD%B2/Untitled%203.png" alt="Hexo静态博客搭建和部署/Untitled%203.png"></p><h2 id="开启Gitee-Pages服务"><a href="#开启Gitee-Pages服务" class="headerlink" title="开启Gitee Pages服务"></a>开启Gitee Pages服务</h2><p><img src="/2021/01/Hexo%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E5%92%8C%E9%83%A8%E7%BD%B2/Untitled%204.png" alt="Hexo静态博客搭建和部署/Untitled%204.png"></p><h2 id="创建公钥"><a href="#创建公钥" class="headerlink" title="创建公钥"></a>创建公钥</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -C <span class="string">&quot;邮箱地址&quot;</span></span><br></pre></td></tr></table></figure><p>密钥对生成后默认的位置是在 C:\Users\Administrator.ssh 的目录下。</p><p>其中 id_rsa 是私钥，id_rsa.pub 是公钥。</p><p>用记事本打开并复制公钥。</p><h2 id="添加公钥"><a href="#添加公钥" class="headerlink" title="添加公钥"></a>添加公钥</h2><p><img src="/2021/01/Hexo%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E5%92%8C%E9%83%A8%E7%BD%B2/Untitled%205.png" alt="Hexo静态博客搭建和部署/Untitled%205.png"></p><p>将复制到的公钥粘贴进去并确定保存。</p><h2 id="安装hexo-deployer-git"><a href="#安装hexo-deployer-git" class="headerlink" title="安装hexo-deployer-git"></a>安装hexo-deployer-git</h2><ul><li>运行<code>npm install hexo-deployer-git --save</code></li></ul><h2 id="修改配置文件"><a href="#修改配置文件" class="headerlink" title="修改配置文件"></a>修改配置文件</h2><p>打开D:\MyBlog\HexoBlog_config.yml查找deploy，并行修改下面这段代码</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line"><span class="built_in">type</span>: git</span><br><span class="line">repo: https://gitee.com/NephrenCake/NephrenCake.git</span><br><span class="line">branch: ph-pages</span><br></pre></td></tr></table></figure><h2 id="部署至云端"><a href="#部署至云端" class="headerlink" title="部署至云端"></a>部署至云端</h2><ul><li>运行<code>hexo d</code></li></ul><blockquote><p><a href="https://nephrencake.gitee.io/">https://nephrencake.gitee.io/</a> 即静态博客的地址了。</p></blockquote><ul><li>如果有网页不同步的时候<ul><li>在Gitee Pages 服务中更新部署（每次deploy之后都要手动更新）</li><li>清理浏览器缓存</li></ul></li></ul><p><img src="/2021/01/Hexo%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E5%92%8C%E9%83%A8%E7%BD%B2/Untitled%206.png" alt="Hexo静态博客搭建和部署/Untitled%206.png"></p>]]></content>
      
      
      <categories>
          
          <category> Hexo博客搭建 </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
</search>
